
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for positive real numbers $a, b, c$ such that $a + b + c = 6$, the following inequality holds: $$ \\sqrt[3]{a b + b c} + \\sqrt[3]{b c + c a} + \\sqrt[3]{c a + a b} \\leq 6 $$

Proof: Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$. By the power mean inequality for non-negative numbers, $rac{\sqrt[3]{x} + \sqrt[3]{y} + \sqrt[3]{z}}{3} \leq \sqrt[3]{rac{x+y+z}{3}}$. We have $x+y+z = 2(ab+bc+ca)$ and $ab+bc+ca \leq rac{(a+b+c)^2}{3}$. Given $a+b+c=6$, it follows that $x+y+z \leq 24$. Therefore, $\sqrt[3]{x} + \sqrt[3]{y} + \sqrt[3]{z} \leq 3\sqrt[3]{8} = 6$, which implies $\sqrt[3]{ab+bc} + \sqrt[3]{bc+ca} + \sqrt[3]{ca+ab} \leq 6$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "for positive real numbers $a, b, c$", "statement": "Premise:\n\u2022 a, b, c are positive real numbers (a>0, b>0, c>0) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c : \u211d)\n(tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a b c : \u211d)' correctly declares a, b, c as real numbers, matching the natural language statement that they are real numbers", "The condition 'a > 0' in the natural language is captured by the first part of the conjunction 'a > 0' in tc_1", "The condition 'b > 0' in the natural language is captured by the second part of the conjunction 'b > 0' in tc_1", "The condition 'c > 0' in the natural language is captured by the third part of the conjunction 'c > 0' in tc_1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "a + b + c = 6", "statement": "Premise:\n\u2022 a, b, c are positive real numbers (a>0, b>0, c>0) [tc_1]\n\u2022 a + b + c = 6 [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c : \u211d)\n(tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n(tc_2 : a + b + c = 6)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c are real numbers and all positive. The variable declaration establishes the type as real numbers, and tc_1 uses conjunction to express that all three are positive, which perfectly matches the natural language condition.", "The Lean formalization exactly matches the natural language condition with identical mathematical notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$.", "statement": "Definition:\n\u2022 Let x, y, z be real numbers defined as x = ab+bc, y = bc+ca, and z = ca+ab [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c : \u211d)\n(tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n(def_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["Lean correctly declares a, b, c as real numbers matching the natural language requirement", "Lean adds the constraint that a > 0 \u2227 b > 0 \u2227 c > 0, which is not mentioned in the natural language. The natural language only states they are real numbers without positivity constraints. However, this is an additional constraint that doesn't contradict the original statement", "The equation x = a * b + b * c perfectly matches x = ab + bc from the natural language", "The equation y = b * c + c * a perfectly matches y = bc + ca from the natural language", "The equation z = c * a + a * b perfectly matches z = ca + ab from the natural language, and the Lean formalization correctly captures that x, y, z are real numbers with these relationships"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "By the power mean inequality for non-negative numbers, $\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\frac{x+y+z}{3}}$.", "statement": "We assume:\n\u2022 a, b, c are positive real numbers (a>0, b>0, c>0) [tc_1]\n\u2022 Let x, y, z be real numbers defined as x = ab+bc, y = bc+ca, and z = ca+ab [def_1]\nTherefore, we conclude:\n\u2022 (\u221bx + \u221by + \u221bz) / 3 \u2264 \u221b((x+y+z)/3) [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n  (x y z : \u211d)\n  (def_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b) :\n  (x^(1/3) + y^(1/3) + z^(1/3)) / 3 \u2264 ((x + y + z) / 3)^(1/3) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n  (x y z : \u211d)\n  (def_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b) :\n  (x^(1/3) + y^(1/3) + z^(1/3)) / 3 \u2264 ((x + y + z) / 3)^(1/3) := by\n  have hx : x > 0 := by\n    rw [def_1.1]\n    nlinarith [tc_1.1, tc_1.2.1, tc_1.2.2]\n  have hy : y > 0 := by\n    rw [def_1.2.1]\n    nlinarith [tc_1.1, tc_1.2.1, tc_1.2.2]\n  have hz : z > 0 := by\n    rw [def_1.2.2]\n    nlinarith [tc_1.1, tc_1.2.1, tc_1.2.2]\n  have hxyz : (x + y + z) / 3 > 0 := by\n    rw [\u2190 add_div]\n    apply div_pos\n    linarith [hx, hy, hz]\n    norm_num\n  have h := pow_arith_mean_le_arith_mean_pow (fun _ => (1/3 : \u211d)) (by norm_num) ![x, y, z]\n    (by intro i; fin_cases i <;> simp [hx, hy, hz])\n  simp at h\n  convert h using 1\n  \u00b7 simp [Finset.univ_eq_attach, Finset.card_fin]\n  \u00b7 simp [Finset.univ_eq_attach, Finset.card_fin]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 8, "endLine": 21, "endColumn": 17, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.15385 / ?m.15387 + ?m.15386 / ?m.15387 + if ?m.15387 \u2264 ?m.15385 % ?m.15387 + ?m.15386 % ?m.15387 then 1 else 0\na b c : \u211d\ntc_1 : a > 0 \u2227 b > 0 \u2227 c > 0\nx y z : \u211d\ndef_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b\nhx : x > 0\nhy : y > 0\nhz : z > 0\n\u22a2 (x + y + z) / 3 > 0"}, {"line": 25, "column": 67, "endLine": 25, "endColumn": 78, "data": "unsolved goals\na b c : \u211d\ntc_1 : a > 0 \u2227 b > 0 \u2227 c > 0\nx y z : \u211d\ndef_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b\nhx : x > 0\nhy : y > 0\nhz : z > 0\nhxyz : (x + y + z) / 3 > 0\n\u22a2 Fin 3 \u2192 \u211d"}, {"line": 26, "column": 5, "endLine": 26, "endColumn": 50, "data": "unsolved goals\ncase \u00ab0\u00bb\na b c : \u211d\ntc_1 : a > 0 \u2227 b > 0 \u2227 c > 0\nx y z : \u211d\ndef_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b\nhx : x > 0\nhy : y > 0\nhz : z > 0\nhxyz : (x + y + z) / 3 > 0\n\u22a2 0 \u2208 ?m.15977 \u2192 0 \u2264 sorry 0\n\ncase \u00ab1\u00bb\na b c : \u211d\ntc_1 : a > 0 \u2227 b > 0 \u2227 c > 0\nx y z : \u211d\ndef_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b\nhx : x > 0\nhy : y > 0\nhz : z > 0\nhxyz : (x + y + z) / 3 > 0\n\u22a2 1 \u2208 ?m.15977 \u2192 0 \u2264 sorry 1\n\ncase \u00ab2\u00bb\na b c : \u211d\ntc_1 : a > 0 \u2227 b > 0 \u2227 c > 0\nx y z : \u211d\ndef_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b\nhx : x > 0\nhy : y > 0\nhz : z > 0\nhxyz : (x + y + z) / 3 > 0\n\u22a2 2 \u2208 ?m.15977 \u2192 0 \u2264 sorry 2"}, {"line": 25, "column": 45, "endLine": 25, "endColumn": 65, "data": "application type mismatch\n  pow_arith_mean_le_arith_mean_pow fun x => 1 / 3\nargument\n  fun x => 1 / 3\nhas type\n  ?m.15477 \u2192 \u211d : Sort (max 1 ?u.15476)\nbut is expected to have type\n  Finset (Fin (succ 0).succ.succ) : Type"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured with proper real number types and conjunction of inequalities.", "The definitions of x, y, z are exactly translated with explicit multiplication notation maintaining the same mathematical relationships.", "The main inequality is perfectly preserved using appropriate Lean notation for cube roots and division operations.", "The logical structure from assumptions to conclusion is correctly represented as a lemma with proper hypothesis-goal format.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1 :\n  \u2203 (a b c : \u211d), a > 0 \u2227 b > 0 \u2227 c > 0 \u2227\n  \u2203 (x y z : \u211d), x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b \u2227\n  \u00ac ((x^(1/3) + y^(1/3) + z^(1/3)) / 3 \u2264 ((x + y + z) / 3)^(1/3)) := by\n  let a : \u211d := 1\n  let b : \u211d := 1\n  let c : \u211d := 2\n  use a, b, c\n  constructor\n  \u00b7 simp [a, b, c]\n  constructor\n  \u00b7 simp [a, b, c]\n  let x := a * b + b * c\n  let y := b * c + c * a\n  let z := c * a + a * b\n  use x, y, z\n  constructor\n  \u00b7 simp [x, y, z, a, b, c]\n  constructor\n  \u00b7 simp [x, y, z, a, b, c]\n  simp [x, y, z, a, b, c]\n  norm_num\n  rw [\u2190 not_le]\n  norm_num\n  have : (3^(1/3) + 4^(1/3) + 3^(1/3)) > (10/3)^(1/3) := by\n    have h1 : 3^(1/3) \u2248 1.4422495703 := by rfl\n    have h2 : 4^(1/3) \u2248 1.587401052 := by rfl\n    have h3 : (10/3)^(1/3) \u2248 1.4938015829 := by rfl\n    linarith\n  exact this"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "We have $x+y+z = 2(ab+bc+ca)$", "statement": "We assume:\n\u2022 Let x, y, z be real numbers defined as x = ab+bc, y = bc+ca, and z = ca+ab [def_1]\nTherefore, we conclude:\n\u2022 x + y + z = 2(ab + bc + ca) [l2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a b c x y z : \u211d)\n  (def_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b) :\n  x + y + z = 2 * (a * b + b * c + c * a) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a b c x y z : \u211d)\n  (def_1 : x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b) :\n  x + y + z = 2 * (a * b + b * c + c * a) := by\n  rw [def_1.1, def_1.2.1, def_1.2.2]\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly and completely captures all logical and mathematical meaning from the natural language. The variable definitions are accurately translated with explicit multiplication notation, the conclusion matches exactly, and the logical structure (assumptions leading to conclusion) is properly represented. The addition of variables a, b, c as real numbers is a necessary and logically consistent detail since they are used in the definitions but not explicitly typed in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "and $ab+bc+ca \\leq \frac{(a+b+c)^2}{3}$.", "statement": "We assume:\n\u2022 a, b, c are real numbers [tc_1]\nTherefore, we conclude:\n\u2022 ab + bc + ca \u2264 (a+b+c)\u00b2/3 [l3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0) :\n  a * b + b * c + c * a \u2264 (a + b + c) ^ 2 / 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0) :\n  a * b + b * c + c * a \u2264 (a + b + c) ^ 2 / 3 := by\n  have h : (a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a) := by ring\n  rw [h, div_eq_mul_inv, mul_add, mul_add, \u2190 mul_assoc, \u2190 mul_assoc, \u2190 mul_assoc]\n  have h\u2081 : 0 \u2264 (a - b)^2 + (b - c)^2 + (c - a)^2 := by positivity\n  have h\u2082 : (a - b)^2 + (b - c)^2 + (c - a)^2 = 2*(a^2 + b^2 + c^2 - (a*b + b*c + c*a)) := by ring\n  rw [h\u2082] at h\u2081\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["Variable declarations match perfectly - both specify a, b, c as real numbers", "The Lean formalization adds positivity constraints (a > 0 \u2227 b > 0 \u2227 c > 0) that are not mentioned in the natural language, which restricts the domain from all reals to positive reals", "The conclusion inequality is represented identically in both versions, with only notational differences (multiplication symbols and exponent notation)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Given $a+b+c=6$, it follows that $x+y+z \\leq 24$.", "statement": "We assume:\n\u2022 a + b + c = 6 [tc_2]\n\u2022 x + y + z = 2(ab + bc + ca) [l2]\n\u2022 ab + bc + ca \u2264 (a+b+c)\u00b2/3 [l3]\nTherefore, we conclude:\n\u2022 x + y + z \u2264 24 [l4].", "dependencies": ["tc_2", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a b c : \u211d)\n  (tc_2 : a + b + c = 6)\n  (l2 : (a b c x y z : \u211d) \u2192 (x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b) \u2192 x + y + z = 2 * (a * b + b * c + c * a))\n  (l3_hyp : a * b + b * c + c * a \u2264 (a + b + c) ^ 2 / 3) :\n  2 * (a * b + b * c + c * a) \u2264 24 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a b c : \u211d)\n  (tc_2 : a + b + c = 6)\n  (l2 : (a b c x y z : \u211d) \u2192 (x = a * b + b * c \u2227 y = b * c + c * a \u2227 z = c * a + a * b) \u2192 x + y + z = 2 * (a * b + b * c + c * a))\n  (l3_hyp : a * b + b * c + c * a \u2264 (a + b + c) ^ 2 / 3) :\n  2 * (a * b + b * c + c * a) \u2264 24 := by\n  rw [tc_2] at l3_hyp\n  have h : (6 : \u211d) ^ 2 / 3 = 12 := by norm_num\n  rw [h] at l3_hyp\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The constraint a + b + c = 6 is correctly formalized with appropriate real number typing.", "The relationship x + y + z = 2(ab + bc + ca) is formalized as a conditional implication rather than a direct constraint. The natural language treats this as an assumption about the values of x, y, z, but the Lean version only states what would be true IF x, y, z were defined in a particular way, without actually constraining their values.", "The inequality ab + bc + ca \u2264 (a+b+c)\u00b2/3 is correctly captured in the Lean formalization.", "The conclusion bypasses the variables x, y, z entirely and directly states the inequality in terms of a, b, c. This misses the logical structure where the conclusion should be about x + y + z, with the relationship to the expression in a, b, c established through the l2 constraint."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The constraint a + b + c = 6 is correctly formalized with appropriate real number typing.', 'The relationship x + y + z = 2(ab + bc + ca) is formalized as a conditional implication rather than a direct constraint. The natural language treats this as an assumption about the values of x, y, z, but the Lean version only states what would be true IF x, y, z were defined in a particular way, without actually constraining their values.', 'The inequality ab + bc + ca \u2264 (a+b+c)\u00b2/3 is correctly captured in the Lean formalization.', 'The conclusion bypasses the variables x, y, z entirely and directly states the inequality in terms of a, b, c. This misses the logical structure where the conclusion should be about x + y + z, with the relationship to the expression in a, b, c established through the l2 constraint.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, $\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z} \\leq 3\\sqrt[3]{8} = 6$", "statement": "We assume:\n\u2022 (\u221bx + \u221by + \u221bz) / 3 \u2264 \u221b((x+y+z)/3) [l1]\n\u2022 x + y + z \u2264 24 [l4]\nTherefore, we conclude:\n\u2022 \u221bx + \u221by + \u221bz \u2264 6 [l5].", "dependencies": ["l1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (x y z : \u211d)\n  (l1 : (x^(1/3) + y^(1/3) + z^(1/3)) / 3 \u2264 ((x + y + z) / 3)^(1/3))\n  (l4 : x + y + z \u2264 24) :\n  x^(1/3) + y^(1/3) + z^(1/3) \u2264 6 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (x y z : \u211d)\n  (hx : 0 \u2264 x)\n  (hy : 0 \u2264 y)\n  (hz : 0 \u2264 z)\n  (l1 : (x^(1/3) + y^(1/3) + z^(1/3)) / 3 \u2264 ((x + y + z) / 3)^(1/3))\n  (l4 : x + y + z \u2264 24) :\n  x^(1/3) + y^(1/3) + z^(1/3) \u2264 6 := by\n  have h : (x + y + z) / 3 \u2264 8 := by linarith [l4]\n  have h' : ((x + y + z) / 3)^(1/3) \u2264 8^(1/3) := by\n    apply rpow_le_rpow (by positivity) h (by positivity)\n  have h'' : 8^(1/3) = 2 := by norm_num\n  rw [\u2190 mul_le_mul_left (by norm_num : (0:\u211d) < 3), mul_div_cancel' _ (by norm_num : (3:\u211d) \u2260 0)] at l1\n  linarith [l1, h', h'']", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 4, "endLine": 15, "endColumn": 56, "data": "tactic 'apply' failed, failed to unify\n  ((x + y + z) / 3) ^ ?m.12860 \u2264 8 ^ ?m.12860\nwith\n  ((x + y + z) / 3) ^ (1 / 3) \u2264 8 ^ (1 / 3)\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhz : 0 \u2264 z\nl1 : (x ^ (1 / 3) + y ^ (1 / 3) + z ^ (1 / 3)) / 3 \u2264 ((x + y + z) / 3) ^ (1 / 3)\nl4 : x + y + z \u2264 24\nh : (x + y + z) / 3 \u2264 8\n\u22a2 ((x + y + z) / 3) ^ (1 / 3) \u2264 8 ^ (1 / 3)"}, {"line": 16, "column": 28, "endLine": 16, "endColumn": 39, "data": "unsolved goals\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhz : 0 \u2264 z\nl1 : (x ^ (1 / 3) + y ^ (1 / 3) + z ^ (1 / 3)) / 3 \u2264 ((x + y + z) / 3) ^ (1 / 3)\nl4 : x + y + z \u2264 24\nh : (x + y + z) / 3 \u2264 8\nh' : ((x + y + z) / 3) ^ (1 / 3) \u2264 8 ^ (1 / 3)\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly capture the implicit real number types from the natural language context", "The cube root inequality is correctly formalized using exponent notation x^(1/3) which is mathematically equivalent to \u221bx", "The sum constraint x + y + z \u2264 24 is translated identically", "The conclusion uses consistent exponent notation for cube roots, maintaining mathematical equivalence with the natural language", "The logical structure properly represents the assumption-conclusion relationship as a lemma with hypotheses and goal", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5 :\n    \u2203 (x y z : \u211d),\n    (x^(1/3) + y^(1/3) + z^(1/3)) / 3 \u2264 ((x + y + z) / 3)^(1/3) \u2227\n    x + y + z \u2264 24 \u2227\n    \u00ac(x^(1/3) + y^(1/3) + z^(1/3) \u2264 6) := by\n  let x : \u211d := 0\n  let y : \u211d := 0\n  let z : \u211d := 27\n  refine \u27e8x, y, z, ?_, ?_, ?_\u27e9\n  \u00b7 simp [x, y, z]\n    norm_num\n  \u00b7 simp [x, y, z]\n    norm_num\n  \u00b7 simp [x, y, z]\n    norm_num"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "which implies $\\sqrt[3]{ab+bc} + \\sqrt[3]{bc+ca} + \\sqrt[3]{ca+ab} \\leq 6$.", "statement": "We assume:\n\u2022 Let x, y, z be real numbers defined as x = ab+bc, y = bc+ca, and z = ca+ab [def_1]\n\u2022 \u221bx + \u221by + \u221bz \u2264 6 [l5]\nTherefore, we conclude:\n\u2022 \u221b(ab+bc) + \u221b(bc+ca) + \u221b(ca+ab) \u2264 6 [ts_1].", "dependencies": ["def_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n  (def_1 : (a * b + b * c = x) \u2227 (b * c + c * a = y) \u2227 (c * a + a * b = z))\n  (l5 : x^(1/3) + y^(1/3) + z^(1/3) \u2264 6) :\n  (a * b + b * c)^(1/3) + (b * c + c * a)^(1/3) + (c * a + a * b)^(1/3) \u2264 6 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n  (def_1 : (a * b + b * c = x) \u2227 (b * c + c * a = y) \u2227 (c * a + a * b = z))\n  (l5 : x^(1/3) + y^(1/3) + z^(1/3) \u2264 6) :\n  (a * b + b * c)^(1/3) + (b * c + c * a)^(1/3) + (c * a + a * b)^(1/3) \u2264 6 := by\n  rw [\u2190 def_1.1, \u2190 def_1.2.1, \u2190 def_1.2.2]\n  exact l5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 6, "endLine": 11, "endColumn": 15, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  x\nx y z a b c : \u211d\ntc_1 : a > 0 \u2227 b > 0 \u2227 c > 0\ndef_1 : a * b + b * c = x \u2227 b * c + c * a = y \u2227 c * a + a * b = z\nl5 : x ^ (1 / 3) + y ^ (1 / 3) + z ^ (1 / 3) \u2264 6\n\u22a2 (a * b + b * c) ^ (1 / 3) + (b * c + c * a) ^ (1 / 3) + (c * a + a * b) ^ (1 / 3) \u2264 6"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable definitions are mathematically equivalent, with order of equality being irrelevant", "Constraint l5 correctly translates cube root notation to exponential form", "Conclusion preserves the exact mathematical statement", "Additional positivity constraint is a reasonable mathematical assumption that doesn't contradict the natural language", "Overall logical structure and flow from premises to conclusion is preserved", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  (a b c : \u211d)\n  (tc_1 : a > 0 \u2227 b > 0 \u2227 c > 0)\n  (def_1 : (a * b + b * c = x) \u2227 (b * c + c * a = y) \u2227 (c * a + a * b = z))\n  (l5 : x^(1/3) + y^(1/3) + z^(1/3) \u2264 6) :\n  \u00ac((a * b + b * c)^(1/3) + (b * c + c * a)^(1/3) + (c * a + a * b)^(1/3) \u2264 6) := by\n  intro h\n  have h1 : (a * b + b * c)^(1/3) = x^(1/3) := by rw [def_1.1]\n  have h2 : (b * c + c * a)^(1/3) = y^(1/3) := by rw [def_1.2.1]\n  have h3 : (c * a + a * b)^(1/3) = z^(1/3) := by rw [def_1.2.2]\n  rw [h1, h2, h3] at h\n  have : x^(1/3) + y^(1/3) + z^(1/3) = x^(1/3) + y^(1/3) + z^(1/3) := rfl\n  contradiction"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    