
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \cdot a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = 2^{F_{n-1}}$ where $F_n$ is the $n$-th Fibonacci number with $F_0=0$, $F_1=1$.

Proof: This proof uses **strong mathematical induction** because the recurrence relation depends on two previous terms. First, we verify the formula for the initial terms, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1 = 2^{F_{1-1}} = 2^{F_0} = 2^0 = 1$, which matches the given value. For $n=2$, the formula gives $a_2 = 2^{F_{2-1}} = 2^{F_1} = 2^1 = 2$, which also matches. Now for the inductive step, assume the formula holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{F_{j-1}}$ is true. We must now prove that the formula holds for $n=k+1$, i.e., $a_{k+1} = 2^{F_{k}}$. Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = a_k \cdot a_{k-1}$. By our inductive assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = (2^{F_{k-1}}) \cdot (2^{F_{k-2}})$. Using the laws of exponents, we add the powers: $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$. By the definition of the Fibonacci numbers, we know that $F_{k-1} + F_{k-2} = F_k$. Thus, $a_{k+1} = 2^{F_k}$. This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \\cdot a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence $(a_n)$ of integers is defined by:\n  \u2022 $a_1 = 1$\n  \u2022 $a_2 = 2$\n  \u2022 $a_n = a_{n-1} \\cdot a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2124)\n(tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The condition a_1 = 1 is directly captured in the Lean conjunction as 'a 1 = 1'", "The condition a_2 = 2 is directly captured in the Lean conjunction as 'a 2 = 2'", "The recurrence relation is perfectly captured as '\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)' which matches the mathematical statement exactly", "The requirement that the sequence consists of integers is captured by the type declaration 'a : \u2115 \u2192 \u2124' which explicitly makes a a function to integers", "The conclusion that the sequence is well-defined for all positive integers is implicitly captured by the Lean type system - declaring 'a : \u2115 \u2192 \u2124' with the given constraints ensures the sequence is well-defined for all natural numbers (which includes all positive integers)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "where $F_n$ is the $n$-th Fibonacci number with $F_0=0$, $F_1=1$.", "statement": "Premise:\n\u2022 The Fibonacci sequence $(F_n)$ of integers is defined by:\n  \u2022 $F_0 = 0$\n  \u2022 $F_1 = 1$\n  \u2022 $F_n = F_{n-1} + F_{n-2}$ for all integers $n \\geq 2$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (F : \u2115 \u2192 \u2124)\n(tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The condition F_0 = 0 is directly captured in the Lean formalization as 'F 0 = 0' within the conjunction tc_2", "The condition F_1 = 1 is directly captured in the Lean formalization as 'F 1 = 1' within the conjunction tc_2", "The recurrence relation F_n = F_{n-1} + F_{n-2} for n \u2265 2 is perfectly captured as '\u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)' in the Lean formalization", "The conclusion that the Fibonacci sequence of integers is defined is captured by the variable declaration 'F : \u2115 \u2192 \u2124' which declares F as a function from natural numbers to integers, combined with the defining conditions in tc_2"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1 = 2^{F_{1-1}} = 2^{F_0} = 2^0 = 1$, which matches the given value.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined with $a_1 = 1$ [tc_1].\n\u2022 The Fibonacci sequence $(F_n)$ is defined with $F_0 = 0$ [tc_2].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=1$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u2124) (F : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)) :\n  a 1 = (2 : \u2124)^(F (1 - 1)) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 8, "endLine": 9, "endColumn": 27, "data": "failed to synthesize\n  HPow \u2124 \u2124 ?m.542\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u2124) (F : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)) :\n  a 1 = (2 : \u2124)^(F 0) := by\n  rw [tc_1.1, tc_2.1]\n  simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 8, "endLine": 9, "endColumn": 21, "data": "failed to synthesize\n  HPow \u2124 \u2124 ?m.487\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 10, "column": 6, "endLine": 10, "endColumn": 12, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  a 1\na F : \u2115 \u2192 \u2124\ntc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n \u2265 3, a n = a (n - 1) * a (n - 2)\ntc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n \u2265 2, F n = F (n - 1) + F (n - 2)\n\u22a2 sorry"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, the formula gives $a_2 = 2^{F_{2-1}} = 2^{F_1} = 2^1 = 2$, which also matches.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined with $a_2 = 2$ [tc_1].\n\u2022 The Fibonacci sequence $(F_n)$ is defined with $F_1 = 1$ [tc_2].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=2$ [l2].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))\n  (F : \u2115 \u2192 \u2124)\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)) :\n  a 2 = (2 : \u211d) ^ (F (2 - 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))\n  (F : \u2115 \u2192 \u2124)\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)) :\n  a 2 = (2 : \u211d) ^ (F (2 - 1)) := by\n  have hF1 : F (2 - 1) = F 1 := by simp\n  have hF1_val : F 1 = 1 := tc_2.2.1\n  rw [tc_1.2.1, hF1, hF1_val]\n  simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition includes additional consistent details (a_1 = 1 and recurrence relation) beyond what's stated in natural language, but doesn't contradict the given a_2 = 2", "The Fibonacci sequence definition includes standard additional details (F_0 = 0 and recurrence relation) beyond the stated F_1 = 1, but remains consistent", "The conclusion formula is correctly formalized as a_2 = 2^(F_1) which perfectly matches the natural language statement", "Type specifications are reasonable mathematical interpretations that don't contradict the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "assume the formula holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{F_{j-1}}$ is true.", "statement": "Definition:\n\u2022 This is the Inductive Hypothesis (IH): For a fixed integer $k \\geq 2$, assume that $a_j = 2^{F_{j-1}}$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (fib (j - 1)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language specifies 'integer k \u2265 2' while Lean uses 'k : \u2115' with 'hk : 2 \u2264 k'. Natural numbers are a subset of integers, so this is a minor restriction that doesn't affect the mathematical meaning since k \u2265 2 implies k is positive anyway.", "The Lean formalization perfectly captures both the constraint on j (1 \u2264 j \u2264 k) and the inductive hypothesis (a j = 2^(F_{j-1})) in a single universal quantification. The use of 'fib' for Fibonacci numbers F is standard notation in Lean."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language specifies 'integer k \u2265 2' while Lean uses 'k : \u2115' with 'hk : 2 \u2264 k'. Natural numbers are a subset of integers, so this is a minor restriction that doesn't affect the mathematical meaning since k \u2265 2 implies k is positive anyway.\", \"The Lean formalization perfectly captures both the constraint on j (1 \u2264 j \u2264 k) and the inductive hypothesis (a j = 2^(F_{j-1})) in a single universal quantification. The use of 'fib' for Fibonacci numbers F is standard notation in Lean.\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = a_k \\cdot a_{k-1}$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined by $a_n = a_{n-1} \\cdot a_{n-2}$ for $n \\geq 3$ [tc_1].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = a_k \\cdot a_{k-1}$ [l3].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))\n  (def_1 : 2 \u2264 k) :\n  a (k + 1) = a k * a (k - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)))\n  (def_1 : 2 \u2264 k) :\n  a (k + 1) = a k * a (k - 1) := by\n  have h1 := tc_1.2.2 (k + 1)\n  have h2 : 3 \u2264 k + 1 := by linarith\n  exact h1 h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The recurrence relation a_n = a_{n-1} * a_{n-2} for n \u2265 3 is correctly formalized as a universal quantification over natural numbers with the same constraint.", "The constraint k \u2265 2 is properly captured. Using natural numbers instead of integers is acceptable since all relevant values are positive.", "The conclusion a_{k+1} = a_k * a_{k-1} is exactly matched in the Lean formalization.", "The additional initial conditions a(1)=1 and a(2)=2 are extra constraints that don't contradict the natural language and are logically consistent with defining a complete sequence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By our inductive assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = (2^{F_{k-1}}) \\cdot (2^{F_{k-2}})$.", "statement": "We assume:\n\u2022 For a fixed integer $k \\geq 2$, it is assumed that $a_j = 2^{F_{j-1}}$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1].\n\u2022 $a_{k+1} = a_k \\cdot a_{k-1}$ [l3].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_{k-1}} \\cdot 2^{F_{k-2}}$ [l4].", "dependencies": ["def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (fib (j - 1)))\n  (l3 : a (k + 1) = a k * a (k - 1)) :\n  a (k + 1) = 2 ^ (fib (k - 1)) * 2 ^ (fib (k - 2)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (fib (j - 1)))\n  (l3 : a (k + 1) = a k * a (k - 1)) :\n  a (k + 1) = 2 ^ (fib (k - 1)) * 2 ^ (fib (k - 2)) := by\n  have hk1 : 1 \u2264 k := by linarith\n  have hkk : k \u2264 k := by linarith\n  have hkm1 : 1 \u2264 k - 1 := by\n    rw [\u2190 Nat.succ_le_succ, Nat.succ_pred_eq_of_pos]\n    exact hk\n    exact hk\n  have hkm1k : k - 1 \u2264 k := Nat.sub_le k 1\n  rw [l3, def_1 k \u27e8hk1, hkk\u27e9, def_1 (k - 1) \u27e8hkm1, hkm1k\u27e9]\n  simp [Nat.sub_sub]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 8, "endLine": 15, "endColumn": 26, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  succ ?m.4574 \u2264 succ ?m.4575\na : \u2115 \u2192 \u211d\nk : \u2115\nhk : 2 \u2264 k\ndef_1 : \u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ fib (j - 1)\nl3 : a (k + 1) = a k * a (k - 1)\nhk1 : 1 \u2264 k\nhkk : k \u2264 k\n\u22a2 1 \u2264 k - 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly capture the sequence a_j and constraint k \u2265 2", "Definition def_1 accurately formalizes the assumption with proper universal quantification and range conditions", "Assumption l3 is a direct and correct translation of the recurrence relation", "Conclusion l4 correctly represents the mathematical result of substituting def_1 into l3", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (fib (j - 1)))\n  (l3 : a (k + 1) = a k * a (k - 1)) :\n  \u00ac (a (k + 1) = 2 ^ (fib (k - 1)) * 2 ^ (fib (k - 2))) := by\n  intro h\n  have h1 : a (k + 1) = 2 ^ (fib (k - 1) + fib (k - 2)) := by\n    rw [h, pow_add]\n  have h2 : fib (k - 1) + fib (k - 2) = fib k := by\n    cases k\n    \u00b7 linarith [hk]\n    \u00b7 rw [\u2190fib_add_two (k-1)]\n      simp [Nat.sub_add_cancel (by omega)]\n  rw [h2] at h1\n  have h3 : a (k + 1) = 2 ^ (fib k) := h1\n  have h4 : a (k + 1) = a k * a (k - 1) := l3\n  have h5 : a k = 2 ^ (fib (k - 1)) := def_1 k \u27e8by omega, by omega\u27e9\n  have h6 : a (k - 1) = 2 ^ (fib (k - 2)) := def_1 (k - 1) \u27e8by omega, by omega\u27e9\n  rw [h5, h6] at h4\n  rw [h4] at h3\n  simp only [pow_add] at h3\n  have : fib k = fib (k - 1) + fib (k - 2) := by rw [\u2190h2]\n  rw [this] at h3\n  have : fib k > 0 := fib_pos (by omega)\n  exact (pow_ne_iff_of_ne_two (by norm_num)).1 rfl h3.symm"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Using the laws of exponents, we add the powers: $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$.", "statement": "We assume:\n\u2022 $a_{k+1} = 2^{F_{k-1}} \\cdot 2^{F_{k-2}}$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (l4 : a (k + 1) = 2 ^ (fib (k - 1)) * 2 ^ (fib (k - 2))) :\n  a (k + 1) = 2 ^ (fib (k - 1) + fib (k - 2)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (l4 : a (k + 1) = 2 ^ (fib (k - 1)) * 2 ^ (fib (k - 2))) :\n  a (k + 1) = 2 ^ (fib (k - 1) + fib (k - 2)) := by\n  rw [l4]\n  rw [\u2190 rpow_add (by norm_num)]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 6, "endLine": 12, "endColumn": 30, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.670 ^ ?y * ?m.670 ^ ?z\na : \u2115 \u2192 \u211d\nk : \u2115\nhk : 2 \u2264 k\nl4 : a (k + 1) = 2 ^ fib (k - 1) * 2 ^ fib (k - 2)\n\u22a2 2 ^ fib (k - 1) * 2 ^ fib (k - 2) = 2 ^ (fib (k - 1) + fib (k - 2))"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The mathematical relationship from premise to conclusion is correctly captured in Lean", "Variable types are appropriately declared, with 'fib' correctly representing Fibonacci numbers F", "The assumption l4 is accurately formalized as a hypothesis", "The conclusion l5 is correctly stated as the goal to prove", "The additional constraint 'hk : 2 \u2264 k' is a reasonable mathematical requirement that doesn't contradict the natural language", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : 2 \u2264 k)\n  (l4 : a (k + 1) = 2 ^ (fib (k - 1)) * 2 ^ (fib (k - 2))) :\n  \u00ac (a (k + 1) = 2 ^ (fib (k - 1) + fib (k - 2))) := by\n  rw [l4, pow_add]\n  intro h\n  contradiction"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By the definition of the Fibonacci numbers, we know that $F_{k-1} + F_{k-2} = F_k$.", "statement": "We assume:\n\u2022 The Fibonacci sequence is defined by $F_n = F_{n-1} + F_{n-2}$ for $n \\geq 2$ [tc_2].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $F_k = F_{k-1} + F_{k-2}$ [l6].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (F : \u2115 \u2192 \u2124) (k : \u2115)\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (def_1 : k \u2265 2) :\n  F k = F (k - 1) + F (k - 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (F : \u2115 \u2192 \u2124) (k : \u2115)\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 (n : \u2115), n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (def_1 : k \u2265 2) :\n  F k = F (k - 1) + F (k - 2) := by\n  exact (tc_2.2.2 k def_1)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language. The addition of standard Fibonacci base cases (F\u2080=0, F\u2081=1) and the use of natural numbers for k (instead of integers) are reasonable mathematical choices that don't contradict the original statement. The recurrence relation, constraint on k, and conclusion are all faithfully represented."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Thus, $a_{k+1} = 2^{F_k}$.", "statement": "We assume:\n\u2022 $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$ [l5].\n\u2022 $F_k = F_{k-1} + F_{k-2}$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_k}$ [l7].", "dependencies": ["l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l5 : a (k + 1) = 2 ^ (fib (k - 1) + fib (k - 2)))\n  (l6 : fib k = fib (k - 1) + fib (k - 2)) :\n  a (k + 1) = 2 ^ (fib k) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l5 : a (k + 1) = 2 ^ (fib (k - 1) + fib (k - 2)))\n  (l6 : fib k = fib (k - 1) + fib (k - 2)) :\n  a (k + 1) = 2 ^ (fib k) := by\n  rw [l5, l6]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly represent the mathematical objects - sequence a as a function from naturals to reals, and Fibonacci sequence using Mathlib's fib function", "Assumption l5 is perfectly translated from mathematical notation to Lean syntax", "Assumption l6 correctly captures the Fibonacci recurrence relation", "Conclusion l7 is correctly formalized and the overall logical structure (prove l7 from l5 and l6) matches the natural language reasoning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=1$ [l1].\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=2$ [l2].\n\u2022 The inductive step is proven: for any integer $k \\geq 2$, the assumption that $a_j = 2^{F_{j-1}}$ for all $1 \\leq j \\leq k$ implies that $a_{k+1} = 2^{F_k}$ (which corresponds to the formula at $n=k+1$) [l7].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \\geq 1$ [ts_1].", "dependencies": ["l1", "l2", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (F : \u2115 \u2192 \u2124)\n  (l1 : a 1 = 2 ^ (F (1 - 1)))\n  (l2 : a 2 = 2 ^ (F (2 - 1)))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (F (j - 1))) \u2192 a (k + 1) = 2 ^ (F k)) :\n  \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2 ^ (F (n - 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (F : \u2115 \u2192 \u2124)\n  (l1 : a 1 = 2 ^ (F (1 - 1)))\n  (l2 : a 2 = 2 ^ (F (2 - 1)))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (F (j - 1))) \u2192 a (k + 1) = 2 ^ (F k)) :\n  \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2 ^ (F (n - 1)) := by\n  intro n hn\n  induction' n using Nat.strong_induction_on with n ih\n  cases' n with n\n  \u00b7 cases hn\n  cases' n with n\n  \u00b7 exact l1\n  \u00b7 cases' n with n\n    \u00b7 exact l2\n    \u00b7 have hk : n + 2 \u2265 2 := by simp\n      apply l7 (n + 2) hk\n      intro j hj\n      have hj' : j \u2264 n + 2 := hj.2\n      have hj1 : 1 \u2264 j := hj.1\n      have : j < n + 3 := by linarith\n      exact ih j this hj1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Base cases l1 and l2 are correctly formalized using the exact mathematical expressions with proper indexing arithmetic", "The inductive step l7 accurately captures the logical structure with universal quantification, range conditions, and implication", "The conclusion ts_1 properly represents the universal statement for all n\u22651", "Function type declarations (\u2115\u2192\u211d for a, \u2115\u2192\u2124 for F) are mathematically sound and consistent with the context", "The overall logical structure of the induction proof (base cases + inductive step \u2192 conclusion) is faithfully preserved in the Lean formalization"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    