
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Suppose that  $K$ is a bounded set with zero content and $\epsilon,$
$\rho>0.$  Then there are cubes $C_1,$ $C_2,$ \dots$,$
$C_r$ with edge lengths
$<\rho$ such that  $C_j\cap K
e\emptyset,$ $1\le j\le r,$
\begin{equation}\label{eq:7.3.5}
K\subset\bigcup_{j=1}^r C_j,
\end{equation}
and
$$
\sum_{j=1}^r V(C_j)<\epsilon.
$$

Proof: Since $V(K)=0$,
$$
\int_C\psi_K(\mathbf{X})\,d\mathbf{X}=0
$$
if $C$ is any cube containing $K$. From this and the
definition of the integral, there is a $\delta>0$ such that if ${\bf
P}$ is any partition of $C$ with $\|{\bf P}\|\le\delta$ and $\sigma$
is any Riemann sum of $\psi_K$ over ${\bf P}$, then
\begin{equation}\label{eq:7.3.6}
0\le\sigma\le\epsilon.
\end{equation}

ewpage

oindent
Now suppose that  ${\bf P}=\{C_1,C_2,\dots,C_k\}$ is a partition of $C$
into cubes with
\begin{equation}\label{eq:7.3.7}
\|{\bf P}\|<\min (\rho,\delta),
\end{equation}
and let $C_1$, $C_2$, \dots, $C_k$ be numbered so that $C_j\cap K
e
\emptyset$ if $1\le j\le r$  and
$C_j\cap K=\emptyset$ if $r+1\le j\le k$. Then \eqref{eq:7.3.5} holds, and
a typical Riemann sum of $\psi_K$ over ${\bf P}$ is of the form
$$
\sigma=\sum_{j=1}^r\psi_K(\mathbf{X}_j)V(C_j)
$$
with $\mathbf{X}_j\in C_j$, $1\le j\le r$. In particular, we
can choose
$\mathbf{X}_j$ from $K$, so that $\psi_K(\mathbf{X}_j)=1$,  and
$$
\sigma=\sum_{j=1}^r V(C_j).
$$
Now \eqref{eq:7.3.6} and \eqref{eq:7.3.7} imply that $C_1$, $C_2$, \dots,
$C_r$ have the required properties.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "K is a bounded set", "statement": "Premise:\n\u2022 K is a bounded set in \u211d\u207f [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (K : Set (\u211d\u207f)) (tc_1 : Metric.Bounded K)", "lean_pass": false, "error_msg": [{"line": 5, "column": 28, "endLine": 5, "endColumn": 29, "data": "unexpected token '\u207f'; expected ')', ',' or ':'"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "K is a bounded set with zero content", "statement": "Premise:\n\u2022 K has zero content, denoted as V(K) = 0 [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115} (K : Set (EuclideanSpace \u211d (Fin n)))\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (tc_2 : V K = 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition 'K has zero content' is not explicitly formalized in Lean. While K is declared as a set in Euclidean space, there's no constraint stating that it has zero content.", "The conclusion 'V(K) = 0' in natural language is treated as a hypothesis 'tc_2 : V K = 0' in Lean, reversing the logical structure. What should be derived as a conclusion is instead given as an assumption."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The condition 'K has zero content' is not explicitly formalized in Lean. While K is declared as a set in Euclidean space, there's no constraint stating that it has zero content.\", \"The conclusion 'V(K) = 0' in natural language is treated as a hypothesis 'tc_2 : V K = 0' in Lean, reversing the logical structure. What should be derived as a conclusion is instead given as an assumption.\"]"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "\u03f5, \u03c1 > 0", "statement": "Premise:\n\u2022 \u03f5 is a positive real number (\u03f5 > 0) [tc_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (\u03b5 : \u211d)\n  (tc_3 : \u03b5 > 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly declares \u03b5 as a real number, with the positivity condition handled separately in the next component", "The Lean formalization exactly matches the condition \u03b5 > 0"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "\u03f5, \u03c1 > 0", "statement": "Premise:\n\u2022 \u03c1 is a positive real number (\u03c1 > 0) [tc_4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (\u03c1 : \u211d)\n(tc_4 : \u03c1 > 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that \u03c1 is a real number through 'variable (\u03c1 : \u211d)' and that it's positive through '(tc_4 : \u03c1 > 0)'. The combination of these two statements in Lean is equivalent to stating '\u03c1 is a positive real number'", "The Lean condition '(tc_4 : \u03c1 > 0)' directly matches the natural language condition '\u03c1 > 0'", "Both the natural language and Lean formalization are premise statements with no new conclusions derived, which matches perfectly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since V(K)=0, \u222b_C \u03c8_K(X) dX = 0 if C is any cube containing K.", "statement": "We assume:\n\u2022 K has zero content, V(K) = 0 [tc_2].\nTherefore, we conclude:\n\u2022 For any cube C that contains K, the Riemann integral of the characteristic function of K over C is zero: \u222b_C \u03c8_K(X) dX = 0 [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (K : Set (EuclideanSpace \u211d (Fin n))) (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (tc_2 : V K = 0)\n  (C : Box (EuclideanSpace \u211d (Fin n))) (hC : K \u2286 C.toSet) :\n  \u222b x in C, K.indicator (fun _ => (1:\u211d)) x = 0 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 7, "endLine": 8, "endColumn": 37, "data": "function expected at\n  Box\nterm has type\n  ?m.56"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (K : Set (EuclideanSpace \u211d (Fin n))) (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (tc_2 : V K = 0)\n  (C : Set (EuclideanSpace \u211d (Fin n))) [MeasureSpace (EuclideanSpace \u211d (Fin n))] (hC : K \u2286 C) :\n  \u222b x in C, Set.indicator K (fun _ => (1:\u211d)) x \u2202volume = 0 := by\n  rw [\u2190 MeasureTheory.integral_indicator hC]\n  simp [tc_2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 40, "endLine": 8, "endColumn": 79, "data": "invalid binder annotation, type is not a class instance\n  ?m.106\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From this and the definition of the integral, there is a \u03b4>0 such that if P is any partition of C with \u2225P\u2225\u2264\u03b4 and \u03c3 is any Riemann sum of \u03c8_K over P, then 0\u2264\u03c3\u2264\u03f5.", "statement": "We assume:\n\u2022 For any cube C containing K, \u222b_C \u03c8_K(X) dX = 0 [l1].\n\u2022 \u03f5 > 0 [tc_3].\nTherefore, we conclude:\n\u2022 For any cube C containing K, there exists a \u03b4 > 0 such that if P is any partition of C with norm \u2225P\u2225 \u2264 \u03b4, then any Riemann sum \u03c3 of \u03c8_K over P satisfies 0 \u2264 \u03c3 \u2264 \u03f5 [l2].", "dependencies": ["l1", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] [BorelSpace E] [FiniteDimensional \u211d E]\n  (K : Set E)\n  (C : Set E) [MeasureTheory.IsBounded C] [MeasureTheory.IsClosed C] [c_is_cube : IsCube C]\n  (l1 : MeasureTheory.integral C (K.indicator (fun _ => (1:\u211d))) volume = 0)\n  (\u03b5 : \u211d) (tc_3 : \u03b5 > 0) :\n  C.contains K \u2192\n  \u2203 \u03b4 > 0, \u2200 (P : Set (Set E)) (hP_partition : IsPartition C P) (hP_norm : P.toFinset.sup (fun s => (s.diameter)) \u2264 \u03b4),\n    \u2200 (\u03c3 : \u211d), (\u2200 s \u2208 P, \u2203 x \u2208 s, \u03c3 = \u2211 s in P.toFinset, (K.indicator (fun _ => (1:\u211d))) x * volume.measure (s.toMeasurable (MeasureTheory.MeasureSpace.volume).measurableSet_sMeasurableSet_of_isClosed.some)) \u2192 0 \u2264 \u03c3 \u2227 \u03c3 \u2264 \u03b5 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 6, "column": 73, "endLine": 6, "endColumn": 94, "data": "failed to synthesize\n  Module \u211d E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E] [MeasureTheory.MeasureSpace E]\n  (K : Set E)\n  (C : Set E) (hC : IsCompact C) (c_is_cube : \u2203 a b : E, C = {x | \u2200 i, a i \u2264 x i \u2227 x i \u2264 b i})\n  (l1 : \u222b x in C, Set.indicator K (fun _ => (1:\u211d)) x = 0)\n  (\u03b5 : \u211d) (tc_3 : \u03b5 > 0) :\n  K \u2286 C \u2192\n  \u2203 \u03b4 > 0, \u2200 (P : Finset (Set E)) (hP_partition : \u2200 s \u2208 P, MeasurableSet s) \n    (hP_union : \u22c3 s \u2208 P, s = C) (hP_disjoint : \u2200 s \u2208 P, \u2200 t \u2208 P, s \u2260 t \u2192 Disjoint s t)\n    (hP_norm : P.sup (fun s => Metric.diam s) \u2264 \u03b4),\n    \u2200 (\u03c3 : \u211d), (\u2200 s \u2208 P, \u2203 x \u2208 s, \u03c3 = \u2211 s in P, Set.indicator K (fun _ => (1:\u211d)) x * ENNReal.toReal (volume s)) \u2192 0 \u2264 \u03c3 \u2227 \u03c3 \u2264 \u03b5 := by\n  intro hK\n  obtain \u27e8\u03b4, h\u03b4, h\u27e9 := exists_partition_integral_approx (Set.indicator K (fun _ => (1:\u211d))) C \u03b5 tc_3 l1\n  refine \u27e8\u03b4, h\u03b4, ?_\u27e9\n  intro P hP hP_union hP_disjoint hP_norm \u03c3 h\u03c3\n  have h1 := h P hP hP_union hP_disjoint hP_norm\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 apply le_trans _ (h1.1 _)\n    apply Finset.sum_nonneg\n    intro s hs\n    exact mul_nonneg (Set.indicator_nonneg (fun _ _ => zero_le_one) _) ENNReal.toReal_nonneg\n  \u00b7 apply le_trans (h1.2 _) h1.3\n    exact h\u03c3", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 71, "endLine": 8, "endColumn": 74, "data": "function expected at\n  a\nterm has type\n  E"}, {"line": 8, "column": 89, "endLine": 8, "endColumn": 92, "data": "function expected at\n  b\nterm has type\n  E"}, {"line": 8, "column": 77, "endLine": 8, "endColumn": 80, "data": "function expected at\n  x\nterm has type\n  E"}, {"line": 8, "column": 83, "endLine": 8, "endColumn": 86, "data": "function expected at\n  x\nterm has type\n  E"}, {"line": 14, "column": 15, "endLine": 14, "endColumn": 45, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 101, "endLine": 15, "endColumn": 109, "data": "function expected at\n  volume\nterm has type\n  ?m.5275"}, {"line": 17, "column": 23, "endLine": 17, "endColumn": 55, "data": "unknown identifier 'exists_partition_integral_approx'"}, {"line": 18, "column": 10, "endLine": 18, "endColumn": 11, "data": "unknown identifier '\u03b4'"}, {"line": 18, "column": 13, "endLine": 18, "endColumn": 15, "data": "unknown identifier 'h\u03b4'"}, {"line": 20, "column": 13, "endLine": 20, "endColumn": 14, "data": "unknown identifier 'h'"}, {"line": 15, "column": 131, "endLine": 27, "endColumn": 12, "data": "unsolved goals\ncase zero\nx\u271d : Sort u_2\nvolume : x\u271d\nE : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : FiniteDimensional \u211d E\ninst\u271d : MeasureTheory.MeasureSpace E\nK C : Set E\nhC : IsCompact C\nc_is_cube : \u2203 a b, C = {x | \u2200 (i : ?m.12612 K C hC a b x), sorry \u2264 ?m.6001 \u2227 ?m.6260 \u2264 sorry}\nl1 : \u222b (x : E) in C, K.indicator (fun x => 1) x = 0\n\u03b5 : \u211d\ntc_3 : \u03b5 > 0\nhK : K \u2286 C\nP : Finset (Set E)\nhP : \u2200 s \u2208 P, MeasurableSet s\nhP_union : \u22c3 s \u2208 P, s = C\nhP_disjoint : \u2200 s \u2208 P, \u2200 t \u2208 P, s \u2260 t \u2192 Disjoint s t\nhP_norm : 0 \u2264 sorry\n\u03c3 : \u211d\nh\u03c3 : \u2200 s \u2208 P, \u2203 x \u2208 s, \u03c3 = \u2211 s \u2208 P, K.indicator (fun x => 1) x * sorry.toReal\n\u22a2 0 \u2264 \u03c3 \u2227 \u03c3 \u2264 \u03b5"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now suppose that P={C_1,C_2,\u2026,C_k} is a partition of C into cubes with \u2225P\u2225<min(\u03c1,\u03b4)", "statement": "Definition:\n\u2022 Since K is bounded [tc_1], let C be a cube containing K.\n\u2022 Let \u03b4 > 0 be the number from [l2] corresponding to C and \u03f5 [tc_3].\n\u2022 Let P = {C_1, C_2, ..., C_k} be a partition of C into cubes with partition norm \u2225P\u2225 < min(\u03c1, \u03b4), where \u03c1 is from [tc_4] [def_1].", "dependencies": ["tc_1", "tc_4", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (K : Set (EuclideanSpace \u211d n))\n  (tc_1 : Bornology.IsBounded K)\n  (C : Set (EuclideanSpace \u211d n))\n  (h_C_cube : IsCube C)\n  (h_K_subset_C : K \u2286 C)\n  (\u03f5 : \u211d)\n  (tc_3 : \u03f5 > 0)\n  (l2 : \u2200 (C' : Set (EuclideanSpace \u211d n)), K \u2286 C' \u2192 IsCube C' \u2192 \u2203 \u03b4 > 0, \u2200 (P : List (Set (EuclideanSpace \u211d n))), IsPartition C' P \u2192 (\u2200 C\u1d62 \u2208 P, IsCube C\u1d62) \u2192 (\u2200 C\u1d62 \u2208 P, diam C\u1d62 < \u03b4) \u2192 \u2200 (\u03c3 : \u211d), (\u2200 (X\u1d62 : EuclideanSpace \u211d n) (C\u1d62_1 : Set (EuclideanSpace \u211d n)), C\u1d62_1 \u2208 P \u2192 X\u1d62 \u2208 C\u1d62_1 \u2192 (\u03c8 K X\u1d62) * volume C\u1d62_1 = \u03c3) \u2192 0 \u2264 \u03c3 \u2227 \u03c3 \u2264 \u03f5)\n  (\u03c1 : \u211d)\n  (tc_4 : \u03c1 > 0)\n  (P : List (Set (EuclideanSpace \u211d n)))\n  (def_1_P_is_partition_of_C : IsPartition C P)\n  (def_1_P_cubes : \u2200 C\u1d62 \u2208 P, IsCube C\u1d62)\n  (def_1_P_norm : \u2200 C\u1d62 \u2208 P, diam C\u1d62 < min \u03c1 (Classical.choose (l2 C (K.subset_trans h_K_subset_C) h_C_cube)))", "lean_pass": false, "error_msg": [{"line": 7, "column": 29, "endLine": 7, "endColumn": 30, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.20841 : Type (?u.20841 + 1)"}, {"line": 9, "column": 29, "endLine": 9, "endColumn": 30, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.21735 : Type (?u.21735 + 1)"}, {"line": 14, "column": 38, "endLine": 14, "endColumn": 39, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.22618 : Type (?u.22618 + 1)"}, {"line": 14, "column": 108, "endLine": 14, "endColumn": 109, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.23633 : Type (?u.23633 + 1)"}, {"line": 14, "column": 220, "endLine": 14, "endColumn": 221, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.24799 : Type (?u.24799 + 1)"}, {"line": 14, "column": 253, "endLine": 14, "endColumn": 254, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.25623 : Type (?u.25623 + 1)"}, {"line": 17, "column": 35, "endLine": 17, "endColumn": 36, "data": "application type mismatch\n  EuclideanSpace \u211d n\nargument\n  n\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Type ?u.26815 : Type (?u.26815 + 1)"}, {"line": 10, "column": 14, "endLine": 10, "endColumn": 22, "data": "function expected at\n  IsCube\nterm has type\n  ?m.1728"}, {"line": 14, "column": 52, "endLine": 14, "endColumn": 61, "data": "function expected at\n  IsCube\nterm has type\n  ?m.1728"}, {"line": 14, "column": 114, "endLine": 14, "endColumn": 130, "data": "function expected at\n  IsPartition\nterm has type\n  ?m.5369"}, {"line": 14, "column": 144, "endLine": 14, "endColumn": 153, "data": "function expected at\n  IsCube\nterm has type\n  ?m.1728"}, {"line": 14, "column": 168, "endLine": 14, "endColumn": 175, "data": "function expected at\n  diam\nterm has type\n  ?m.9198"}, {"line": 14, "column": 282, "endLine": 14, "endColumn": 288, "data": "function expected at\n  \u03c8\nterm has type\n  ?m.15015"}, {"line": 14, "column": 292, "endLine": 14, "endColumn": 303, "data": "function expected at\n  volume\nterm has type\n  ?m.20835"}, {"line": 18, "column": 31, "endLine": 18, "endColumn": 46, "data": "function expected at\n  IsPartition\nterm has type\n  ?m.5369"}, {"line": 19, "column": 29, "endLine": 19, "endColumn": 38, "data": "function expected at\n  IsCube\nterm has type\n  ?m.1728"}, {"line": 20, "column": 28, "endLine": 20, "endColumn": 35, "data": "function expected at\n  diam\nterm has type\n  ?m.9198"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "and let C_1, C_2, \u2026, C_k be numbered so that C_j\u2229K\u2260\u2205 if 1\u2264j\u2264r and C_j\u2229K=\u2205 if r+1\u2264j\u2264k.", "statement": "Definition:\n\u2022 Given the partition P from [def_1], we re-index its cubes {C_1, ..., C_k} and define an integer r such that C_j \u2229 K \u2260 \u2205 for 1 \u2264 j \u2264 r, and C_j \u2229 K = \u2205 for r+1 \u2264 j \u2264 k. This defines the sub-collection of cubes {C_1, ..., C_r} [def_2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (P : List (Set (EuclideanSpace \u211d (Fin n))))\n  (K : Set (EuclideanSpace \u211d (Fin n)))\n  (k : \u2115)\n  (C_reindexed : Fin k \u2192 Set (EuclideanSpace \u211d (Fin n)))\n  (def_1 : List.IsPartition P \u2227 P.length = k \u2227 (\u2200 i, C_reindexed i = P.nth i (by simp [List.length_eq_nil.mp (List.length_pos_iff_ne_nil.mpr (by assumption)) (by simp [P.length_pos] : 0 < P.length)])))\n  (r : \u2115)\n  (def_2_cond_1 : \u2200 j : Fin r, (C_reindexed j.val) \u2229 K \u2260 \u2205)\n  (def_2_cond_2 : \u2200 j : Fin (k - r), (C_reindexed (r + j.val)) \u2229 K = \u2205)", "lean_pass": false, "error_msg": [{"line": 11, "column": 11, "endLine": 11, "endColumn": 29, "data": "unknown constant 'List.IsPartition'"}, {"line": 11, "column": 69, "endLine": 11, "endColumn": 199, "data": "invalid field 'nth', the environment does not contain 'List.nth'\n  P\nhas type\n  List (Set (EuclideanSpace \u211d (Fin n)))"}, {"line": 13, "column": 44, "endLine": 13, "endColumn": 49, "data": "application type mismatch\n  C_reindexed \u2191j\nargument\n  \u2191j\nhas type\n  \u2115 : Type\nbut is expected to have type\n  Fin k : Type"}, {"line": 14, "column": 51, "endLine": 14, "endColumn": 60, "data": "type mismatch\n  r + \u2191j\nhas type\n  \u2115 : outParam Type\nbut is expected to have type\n  Fin k : Type"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Then (7.3.5) holds,", "statement": "We assume:\n\u2022 P={C_1,\u2026,C_k} is a partition of a cube C that contains K [def_1].\n\u2022 The cubes are indexed such that C_j \u2229 K \u2260 \u2205 for 1 \u2264 j \u2264 r and C_j \u2229 K = \u2205 for r+1 \u2264 j \u2264 k [def_2].\nTherefore, we conclude:\n\u2022 K is a subset of the union of the first r cubes: K \u2282 \u22c3_{j=1}^r C_j [l3].", "dependencies": ["def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] [FiniteDimensional \u211d E]\n  (K C : Set E) (V : Set E \u2192 \u211d) (P : List (Set E)) (k r : \u2115)\n  (def_1 : K \u2286 C \u2227 (\u2200 C_i \u2208 P, IsCuboid C_i) \u2227 (\u22c3 C_i \u2208 P, C_i) = C \u2227 List.finite P)\n  (def_2 : \u2200 (j : Fin k), (j.val < r \u2192 (P.get j) \u2229 K \u2260 \u2205) \u2227 (j.val \u2265 r \u2192 (P.get j) \u2229 K = \u2205)) :\n  K \u2286 (\u22c3 (j : Fin r), P.get (Fin.castLE (Nat.le_of_lt j.isLt) j)) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 6, "column": 58, "endLine": 6, "endColumn": 79, "data": "failed to synthesize\n  Module \u211d E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  (K C : Set E) (P : List (Set E)) (k r : \u2115)\n  (hPk : P.length = k)\n  (def_1 : K \u2286 C \u2227 (\u2200 C_i \u2208 P, C_i \u2286 C) \u2227 \u22c3 C_i \u2208 P, C_i = C)\n  (def_2 : \u2200 (j : Fin P.length), (\u2191j < r \u2192 P.get j \u2229 K \u2260 \u2205) \u2227 (\u2191j \u2265 r \u2192 P.get j \u2229 K = \u2205)) :\n  K \u2286 \u22c3 (j : Fin r), P.get (Fin.castLE (le_of_eq (Eq.symm hPk) \u25b8 j.isLt) j) := by\n  intro x hx\n  have hxC := def_1.1 hx\n  rw [def_1.2.2] at hxC\n  simp only [Set.mem_iUnion, List.mem_def] at hxC\n  obtain \u27e8i, hi, hxi\u27e9 := hxC\n  let j : Fin P.length := \u27e8P.indexOf i, by simp [hi]\u27e9\n  have hj : P.get j = i := List.get_of_mem (by simp [hi])\n  by_cases hjr : \u2191j < r\n  \u00b7 use \u27e8j, hjr\u27e9\n    rw [hj]\n    exact hxi\n  \u00b7 have hK := (def_2 j).2 hjr\n    rw [hj] at hK\n    have hxK : x \u2208 K := hx\n    have hxP : x \u2208 i := hxi\n    simp [hK, hxK, hxP] at *", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 40, "endLine": 11, "endColumn": 71, "data": "invalid `\u25b8` notation, argument\n  le_of_eq (Eq.symm hPk)\nhas type\n  k \u2264 P.length\nequality expected"}, {"line": 14, "column": 6, "endLine": 14, "endColumn": 15, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u22c3 C_i \u2208 P, C_i\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : FiniteDimensional \u211d E\nK C : Set E\nP : List (Set E)\nk r : \u2115\nhPk : P.length = k\ndef_1 : K \u2286 C \u2227 (\u2200 C_i \u2208 P, C_i \u2286 C) \u2227 \u22c3 C_i \u2208 P, C_i = C\ndef_2 : \u2200 (j : Fin P.length), (\u2191j < r \u2192 P.get j \u2229 K \u2260 \u2205) \u2227 (\u2191j \u2265 r \u2192 P.get j \u2229 K = \u2205)\nx : E\nhx : x \u2208 K\nhxC : x \u2208 C\n\u22a2 x \u2208 \u22c3 j, P.get (Fin.castLE \u22ef j)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "and a typical Riemann sum of \u03c8_K over P is of the form \u03c3=\u2211_{j=1}^r \u03c8_K(X_j)V(C_j) with X_j\u2208C_j, 1\u2264j\u2264r.", "statement": "We assume:\n\u2022 The cubes of partition P are indexed such that C_j \u2229 K = \u2205 for j > r [def_2].\nTherefore, we conclude:\n\u2022 A Riemann sum \u03c3 = \u2211_{j=1}^k \u03c8_K(X_j)V(C_j) over the partition P simplifies to \u03c3 = \u2211_{j=1}^r \u03c8_K(X_j)V(C_j), because for j > r, any X_j \u2208 C_j is not in K, making \u03c8_K(X_j) = 0 [l4].", "dependencies": ["def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4 {k r : \u2115} {C : \u2115 \u2192 Set (EuclideanSpace \u211d (Fin n))} {K : Set (EuclideanSpace \u211d (Fin n))}\n  (P : Set (Set (EuclideanSpace \u211d (Fin n))))\n  (X : \u2115 \u2192 (EuclideanSpace \u211d (Fin n)))\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (\u03c8_K : (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (def_2 : \u2200 j, r + 1 \u2264 j \u2192 j \u2264 k \u2192 C j \u2229 K = \u2205)\n  (h\u03c8_K : \u2200 x, x \u2208 K \u2192 \u03c8_K x = 1)\n  (h\u03c8_K_not_in_K : \u2200 x, x \u2209 K \u2192 \u03c8_K x = 0)\n  (hX_in_C : \u2200 j, X j \u2208 C j) :\n  \u2211 j in Finset.range k, \u03c8_K (X j) * V (C j) = \u2211 j in Finset.range r, \u03c8_K (X j) * V (C j) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4 {k r : \u2115} {C : \u2115 \u2192 Set (EuclideanSpace \u211d (Fin n))} {K : Set (EuclideanSpace \u211d (Fin n))}\n  (P : Set (Set (EuclideanSpace \u211d (Fin n))))\n  (X : \u2115 \u2192 (EuclideanSpace \u211d (Fin n)))\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (\u03c8_K : (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (def_2 : \u2200 j, r + 1 \u2264 j \u2192 j \u2264 k \u2192 C j \u2229 K = \u2205)\n  (h\u03c8_K : \u2200 x, x \u2208 K \u2192 \u03c8_K x = 1)\n  (h\u03c8_K_not_in_K : \u2200 x, x \u2209 K \u2192 \u03c8_K x = 0)\n  (hX_in_C : \u2200 j, X j \u2208 C j) :\n  \u2211 j in Finset.range k, \u03c8_K (X j) * V (C j) = \u2211 j in Finset.range r, \u03c8_K (X j) * V (C j) := by\n  rw [\u2190 Finset.sum_range_add_sum_Ioo _ (Nat.lt_succ_self r)]\n  simp only [Finset.sum_Ioo_eq_zero]\n  intro j hj\n  have hjr : r + 1 \u2264 j := by linarith [hj.1]\n  have hjk : j \u2264 k := by linarith [hj.2]\n  have hCj : C j \u2229 K = \u2205 := def_2 j hjr hjk\n  have hXj : X j \u2209 K := by\n    intro hXj\n    have : X j \u2208 C j \u2229 K := \u27e8hX_in_C j, hXj\u27e9\n    rw [hCj] at this\n    exact this\n  rw [h\u03c8_K_not_in_K _ hXj]\n  simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 8, "endLine": 15, "endColumn": 59, "data": "unknown constant 'Finset.sum_range_add_sum_Ioo'"}, {"line": 15, "column": 6, "endLine": 15, "endColumn": 59, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.742\nn k r : \u2115\nC : \u2115 \u2192 Set (EuclideanSpace \u211d (Fin n))\nK : Set (EuclideanSpace \u211d (Fin n))\nP : Set (Set (EuclideanSpace \u211d (Fin n)))\nX : \u2115 \u2192 EuclideanSpace \u211d (Fin n)\nV : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d\n\u03c8_K : EuclideanSpace \u211d (Fin n) \u2192 \u211d\ndef_2 : \u2200 (j : \u2115), r + 1 \u2264 j \u2192 j \u2264 k \u2192 C j \u2229 K = \u2205\nh\u03c8_K : \u2200 x \u2208 K, \u03c8_K x = 1\nh\u03c8_K_not_in_K : \u2200 x \u2209 K, \u03c8_K x = 0\nhX_in_C : \u2200 (j : \u2115), X j \u2208 C j\n\u22a2 \u2211 j \u2208 Finset.range k, \u03c8_K (X j) * V (C j) = \u2211 j \u2208 Finset.range r, \u03c8_K (X j) * V (C j)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning and logical structure of the natural language statement. The only difference is the indexing convention: Lean uses 0-based indexing (Finset.range k = {0,1,...,k-1}) while the natural language uses 1-based indexing ({1,2,...,k}). This is a common and acceptable translation difference that doesn't affect the mathematical content. All key components are present: the assumption about cube intersections, the Riemann sum structure, the simplification, and the underlying reasoning through the characteristic function properties.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the mathematical meaning and logical structure of the natural language statement. The only difference is the indexing convention: Lean uses 0-based indexing (Finset.range k = {0,1,...,k-1}) while the natural language uses 1-based indexing ({1,2,...,k}). This is a common and acceptable translation difference that doesn't affect the mathematical content. All key components are present: the assumption about cube intersections, the Riemann sum structure, the simplification, and the underlying reasoning through the characteristic function properties.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "In particular, we can choose X_j from K, so that \u03c8_K(X_j)=1, and \u03c3=\u2211_{j=1}^r V(C_j).", "statement": "We assume:\n\u2022 For 1 \u2264 j \u2264 r, C_j \u2229 K \u2260 \u2205 [def_2].\n\u2022 A Riemann sum has the form \u03c3 = \u2211_{j=1}^r \u03c8_K(X_j)V(C_j) [l4].\nTherefore, we conclude:\n\u2022 There exists a specific Riemann sum \u03c3 (by choosing sample points X_j \u2208 C_j \u2229 K) which is equal to \u2211_{j=1}^r V(C_j) [l5].", "dependencies": ["def_2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {k r : \u2115} {n : \u2115} {C : \u2115 \u2192 Set (EuclideanSpace \u211d (Fin n))} {K : Set (EuclideanSpace \u211d (Fin n))}\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (\u03c8_K : (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (def_2 : \u2200 j, 1 \u2264 j \u2192 j \u2264 r \u2192 C j \u2229 K \u2260 \u2205)\n  (l4_h\u03c8_K : \u2200 x, x \u2208 K \u2192 \u03c8_K x = 1) :\n  \u2203 (X : \u2115 \u2192 (EuclideanSpace \u211d (Fin n))),\n    (\u2200 j, 1 \u2264 j \u2192 j \u2264 r \u2192 X j \u2208 C j \u2229 K) \u2227\n    (\u2211 j in Finset.range r, \u03c8_K (X j) * V (C j) = \u2211 j in Finset.range r, V (C j)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {k r : \u2115} {n : \u2115} {C : \u2115 \u2192 Set (EuclideanSpace \u211d (Fin n))} {K : Set (EuclideanSpace \u211d (Fin n))}\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (\u03c8_K : (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (def_2 : \u2200 j, 1 \u2264 j \u2192 j \u2264 r \u2192 C j \u2229 K \u2260 \u2205)\n  (l4_h\u03c8_K : \u2200 x, x \u2208 K \u2192 \u03c8_K x = 1) :\n  \u2203 (X : \u2115 \u2192 (EuclideanSpace \u211d (Fin n))),\n    (\u2200 j, 1 \u2264 j \u2192 j \u2264 r \u2192 X j \u2208 C j \u2229 K) \u2227\n    (\u2211 j in Finset.range r, \u03c8_K (X j) * V (C j) = \u2211 j in Finset.range r, V (C j)) := by\n  have h : \u2200 j, 1 \u2264 j \u2192 j \u2264 r \u2192 \u2203 x, x \u2208 C j \u2229 K := fun j hj1 hj2 => Set.nonempty_of_ne_empty (def_2 j hj1 hj2)\n  choose X hX using h\n  refine \u27e8X, ?_, ?_\u27e9\n  \u00b7 exact fun j hj1 hj2 => hX j hj1 hj2\n  \u00b7 simp only [Finset.sum_congr rfl (fun j hj => ?_)]\n    rcases Finset.mem_range.1 hj with \u27e8hj1, hj2\u27e9\n    have := hX j (by omega) hj2\n    simp [l4_h\u03c8_K _ this.2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 69, "endLine": 14, "endColumn": 111, "data": "unknown constant 'Set.nonempty_of_ne_empty'"}, {"line": 16, "column": 10, "endLine": 16, "endColumn": 11, "data": "application type mismatch\n  Exists.intro X\nargument\n  X\nhas type\n  (j : \u2115) \u2192 1 \u2264 j \u2192 j \u2264 r \u2192 EuclideanSpace \u211d (Fin n) : Type\nbut is expected to have type\n  \u2115 \u2192 EuclideanSpace \u211d (Fin n) : Type"}, {"line": 18, "column": 4, "endLine": 18, "endColumn": 53, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization is missing the explicit l4 assumption about the form of Riemann sums mentioned in the natural language. However, this form appears correctly in the conclusion, and the logical structure is preserved.", "The conclusion correctly captures the existence of sample points and the equality of the Riemann sum to the simplified sum, matching the natural language statement perfectly.", "There's a minor indexing difference: Lean uses range r (0 to r-1) while natural language uses 1 to r, but this doesn't affect the mathematical meaning since both represent r terms in the sum.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization is missing the explicit l4 assumption about the form of Riemann sums mentioned in the natural language. However, this form appears correctly in the conclusion, and the logical structure is preserved.', 'The conclusion correctly captures the existence of sample points and the equality of the Riemann sum to the simplified sum, matching the natural language statement perfectly.', \"There's a minor indexing difference: Lean uses range r (0 to r-1) while natural language uses 1 to r, but this doesn't affect the mathematical meaning since both represent r terms in the sum.\"]"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Now (7.3.6) and (7.3.7) imply that C_1, C_2, \u2026, C_r have the required properties.", "statement": "We assume:\n\u2022 For the chosen partition P, its norm \u2225P\u2225 < \u03b4 [def_1].\n\u2022 For any partition with norm \u2264 \u03b4, any Riemann sum \u03c3 satisfies 0 \u2264 \u03c3 \u2264 \u03f5 [l2].\n\u2022 There exists a particular Riemann sum \u03c3 equal to \u2211_{j=1}^r V(C_j) [l5].\nTherefore, we conclude:\n\u2022 The sum of the volumes of the selected cubes is bounded by \u03f5: \u2211_{j=1}^r V(C_j) \u2264 \u03f5 [l6].", "dependencies": ["l2", "def_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {n : \u2115}\n  (K : Set (EuclideanSpace \u211d (Fin n)))\n  (C : Set (EuclideanSpace \u211d (Fin n)))\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (\u03c8_K : (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (P : List (Set (EuclideanSpace \u211d (Fin n))))\n  (r : \u2115)\n  (def_1 : \u2203 (P_list : List (Set (EuclideanSpace \u211d (Fin n)))), P = P_list \u2227 (\u2200 C_j \u2208 P_list, IsCuboid C_j) \u2227 (\u2200 C_j C_l \u2208 P_list, C_j \u2260 C_l \u2192 Set.disjoint C_j C_l) \u2227 (Set.unionList P_list = C) \u2227 (MeasureTheory.getPartitionNorm P < min \u03c1 \u03b4))\n  (l2 : \u2200 (C_0 : Set (EuclideanSpace \u211d (Fin n))), MeasureTheory.IsCuboid C_0 \u2192 K \u2286 C_0 \u2192 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 (\u03b4_0 : \u211d), \u03b4_0 > 0 \u2227 \u2200 (P_0 : List (Set (EuclideanSpace \u211d (Fin n)))), (\u2200 C_j \u2208 P_0, MeasureTheory.IsCuboid C_j) \u2192 (\u2200 C_j C_l \u2208 P_0, C_j \u2260 C_l \u2192 Set.disjoint C_j C_l) \u2192 (Set.unionList P_0 = C_0) \u2192 MeasureTheory.getPartitionNorm P_0 \u2264 \u03b4_0 \u2192 \u2200 (\u03c3 : \u211d), (\u2203 (X_0 : List (EuclideanSpace \u211d (Fin n))), (\u2200 i : Fin (P_0.length), X_0.get i \u2208 P_0.get i) \u2227 \u03c3 = \u2211 i in Finset.range P_0.length, \u03c8_K (X_0.get i) * V (P_0.get i)) \u2192 0 \u2264 \u03c3 \u2227 \u03c3 \u2264 \u03b5)\n  (l5 : \u2203 (X : \u2115 \u2192 (EuclideanSpace \u211d (Fin n))), (\u2200 j, 1 \u2264 j \u2192 j \u2264 r \u2192 X j \u2208 P.nth j.pred.succ.val \u2229 K.val) \u2227 (\u2211 j in Finset.range r, \u03c8_K (X j) * V (P.nth j.pred.succ.val) = \u2211 j in Finset.range r, V (P.nth j.pred.succ.val))) :\n  \u2211 j in Finset.range r, V (P.nth j.pred.succ.val) \u2264 \u03f5 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 13, "column": 119, "endLine": 13, "endColumn": 121, "data": "unexpected token '\u2208'; expected ','"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {n : \u2115}\n  (K : Set (EuclideanSpace \u211d (Fin n)))\n  (C : Set (EuclideanSpace \u211d (Fin n)))\n  (V : Set (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (\u03c8_K : (EuclideanSpace \u211d (Fin n)) \u2192 \u211d)\n  (P : List (Set (EuclideanSpace \u211d (Fin n))))\n  (r : \u2115)\n  (def_1 : \u2203 (P_list : List (Set (EuclideanSpace \u211d (Fin n)))), P = P_list \u2227 (\u2200 C_j \u2208 P_list, IsCuboid C_j) \u2227 (\u2200 C_j C_l \u2208 P_list, C_j \u2260 C_l \u2192 Disjoint C_j C_l) \u2227 (\u22c3\u2080 P_list = C) \u2227 (MeasureTheory.getPartitionNorm P < min \u03c1 \u03b4))\n  (l2 : \u2200 (C_0 : Set (EuclideanSpace \u211d (Fin n))), IsCuboid C_0 \u2192 K \u2286 C_0 \u2192 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 (\u03b4_0 : \u211d), \u03b4_0 > 0 \u2227 \u2200 (P_0 : List (Set (EuclideanSpace \u211d (Fin n)))), (\u2200 C_j \u2208 P_0, IsCuboid C_j) \u2192 (\u2200 C_j C_l \u2208 P_0, C_j \u2260 C_l \u2192 Disjoint C_j C_l) \u2192 (\u22c3\u2080 P_0 = C_0) \u2192 MeasureTheory.getPartitionNorm P_0 \u2264 \u03b4_0 \u2192 \u2200 (\u03c3 : \u211d), (\u2203 (X_0 : Fin P_0.length \u2192 EuclideanSpace \u211d (Fin n)), (\u2200 i, X_0 i \u2208 P_0.get \u27e8i, by simp\u27e9) \u2227 \u03c3 = \u2211 i, \u03c8_K (X_0 i) * V (P_0.get \u27e8i, by simp\u27e9)) \u2192 0 \u2264 \u03c3 \u2227 \u03c3 \u2264 \u03b5)\n  (l5 : \u2203 (X : Fin r \u2192 EuclideanSpace \u211d (Fin n)), (\u2200 j, X j \u2208 P.get \u27e8j, by simp\u27e9 \u2229 K) \u2227 (\u2211 j, \u03c8_K (X j) * V (P.get \u27e8j, by simp\u27e9) = \u2211 j, V (P.get \u27e8j, by simp\u27e9))) :\n  \u2211 j, V (P.get \u27e8j, by simp\u27e9) \u2264 \u03b5 := by\n  obtain \u27e8X, hX1, hX2\u27e9 := l5\n  obtain \u27e8P_list, hP1, hP2, hP3, hP4, hP5\u27e9 := def_1\n  rw [hP1] at *\n  have h\u03c3 : \u2203 \u03c3 : \u211d, \u03c3 = \u2211 j, V (P.get \u27e8j, by simp\u27e9) \u2227 \u2203 (X_0 : Fin r \u2192 EuclideanSpace \u211d (Fin n)), (\u2200 i, X_0 i \u2208 P.get \u27e8i, by simp\u27e9) \u2227 \u03c3 = \u2211 i, \u03c8_K (X_0 i) * V (P.get \u27e8i, by simp\u27e9) := by\n    use \u2211 j, V (P.get \u27e8j, by simp\u27e9), rfl, X\n    constructor\n    \u00b7 intro i\n      exact (hX1 i).1\n    \u00b7 exact hX2\n  obtain \u27e8\u03c3, h\u03c31, h\u03c32\u27e9 := h\u03c3\n  have h\u03c3_le := (l2 C (hP2 C (by simp)) (by rw [hP4]; exact subset_union\u209b P_list (by simp)) \u03b5 (by simp) \u03b4 (by simp) P hP2 hP3 hP4 hP5 \u03c3 h\u03c32).2\n  rw [h\u03c31] at h\u03c3_le\n  exact h\u03c3_le", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 119, "endLine": 13, "endColumn": 121, "data": "unexpected token '\u2208'; expected ','"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Now suppose that P={C_1,C_2,\u2026,C_k} is a partition of C into cubes with \u2225P\u2225<min(\u03c1,\u03b4)", "statement": "We assume:\n\u2022 The partition P has norm \u2225P\u2225 < min(\u03c1, \u03b4) [def_1].\nTherefore, we conclude:\n\u2022 The edge length of each cube C_j in the partition is less than \u03c1 [l7].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {n : \u2115} {E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [FiniteDimensional \u211d E]\n  (K : Set E) (C : Set E) (hK_bdd : Bounded K) (hC_cube : IsCube C) (hK_in_C : K \u2286 C) (\u03b4 \u03c1 \u03b5 : \u211d)\n  (h\u03b4_pos : \u03b4 > 0) (h\u03c1_pos : \u03c1 > 0) (h\u03b5_pos : \u03b5 > 0)\n  (P : List (Set E)) (def_1 : IsPartition P C \u2227 (\u2200 j, IsCube (P.get j)) \u2227 PartitionNorm P < min \u03c1 \u03b4) (j : Fin P.length) :\n  diam (P.get j) < \u03c1 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 36, "endLine": 7, "endColumn": 45, "data": "function expected at\n  Bounded\nterm has type\n  ?m.664"}, {"line": 7, "column": 58, "endLine": 7, "endColumn": 66, "data": "function expected at\n  IsCube\nterm has type\n  ?m.939"}, {"line": 9, "column": 30, "endLine": 9, "endColumn": 45, "data": "function expected at\n  IsPartition\nterm has type\n  ?m.1339"}, {"line": 9, "column": 54, "endLine": 9, "endColumn": 70, "data": "function expected at\n  IsCube\nterm has type\n  ?m.939"}, {"line": 9, "column": 74, "endLine": 9, "endColumn": 89, "data": "function expected at\n  PartitionNorm\nterm has type\n  ?m.1737"}, {"line": 10, "column": 2, "endLine": 10, "endColumn": 16, "data": "function expected at\n  diam\nterm has type\n  ?m.2157"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.Analysis.NormedSpace.Basic\nimport Mathlib.Analysis.SpecialFunctions.Pow.Real\nimport Mathlib.MeasureTheory.Measure.Lebesgue.Basic\nimport Mathlib.Topology.MetricSpace.Basic\n\nopen Set Metric\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {n : \u2115} {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]\n  (C : Set E) (\u03c1 \u03b4 : \u211d) (h\u03c1_pos : \u03c1 > 0) (h\u03b4_pos : \u03b4 > 0)\n  (P : List (Set E)) (hP : \u2200 j : Fin P.length, IsClosed (P.get j) \u2227 IsBounded (P.get j)) \n  (hP_norm : \u2203 d : \u211d, \u2200 j : Fin P.length, diam (P.get j) \u2264 d \u2227 d < min \u03c1 \u03b4) (j : Fin P.length) :\n  diam (P.get j) < \u03c1 := by\n  obtain \u27e8d, hd\u27e9 := hP_norm\n  specialize hd j\n  rcases hd with \u27e8hle, hlt\u27e9\n  apply lt_of_le_of_lt hle\n  exact lt_of_lt_of_le hlt (min_le_left \u03c1 \u03b4)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Now (7.3.6) and (7.3.7) imply that C_1, C_2, \u2026, C_r have the required properties.", "statement": "We assume:\n\u2022 A set of cubes {C_1, ..., C_r} is defined by selecting all cubes from a partition P that have a non-empty intersection with K [def_2].\n\u2022 These cubes have edge lengths less than \u03c1 [l7].\n\u2022 The set K is contained in the union of these cubes, K \u2282 \u22c3_{j=1}^r C_j [l3].\n\u2022 The sum of the volumes of these cubes satisfies \u2211_{j=1}^r V(C_j) \u2264 \u03f5 [l6].\nTherefore, we conclude:\n\u2022 There exist cubes C_1, ..., C_r with edge lengths < \u03c1 such that C_j \u2229 K \u2260 \u2205 for 1 \u2264 j \u2264 r, K \u2282 \u22c3_{j=1}^r C_j, and \u2211_{j=1}^r V(C_j) \u2264 \u03f5, satisfying the theorem's conditions (with \u2264 \u03f5 as proved) [ts_1].", "dependencies": ["def_2", "l3", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} [MeasurableSpace \u03b1] [MetricSpace \u03b1] [CompleteSpace \u03b1] [pMeasurableSpace \u03b1] [pMetricSpace \u03b1]\n  (K : Set \u03b1) (C : \u2115 \u2192 Set \u03b1) (r : \u2115) (\u03c1 \u03f5 : \u211d)\n  (def_2 : \u2200 j : Fin r, (C j) \u2229 K \u2260 \u2205)\n  (l3 : K \u2286 \u22c3 j : Fin r, C j)\n  (l6 : \u2211 j : Fin r, volume (C j) \u2264 \u03f5)\n  (l7 : \u2200 j : Fin r, (C j).edge_length < \u03c1) :\n  \u2203 (C_cubes : Fin r \u2192 Set \u03b1),\n    (\u2200 j : Fin r, (C_cubes j).edge_length < \u03c1) \u2227\n    (\u2200 j : Fin r, (C_cubes j) \u2229 K \u2260 \u2205) \u2227\n    (K \u2286 \u22c3 j : Fin r, C_cubes j) \u2227\n    (\u2211 j : Fin r, volume (C_cubes j) \u2264 \u03f5) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 6, "column": 69, "endLine": 6, "endColumn": 87, "data": "invalid binder annotation, type is not a class instance\n  ?m.443\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} [MetricSpace \u03b1] [MeasurableSpace \u03b1]\n  (K : Set \u03b1) (C : Fin r \u2192 Set \u03b1) (r : \u2115) (\u03c1 \u03f5 : \u211d)\n  (def_2 : \u2200 j : Fin r, (C j) \u2229 K \u2260 \u2205)\n  (l3 : K \u2286 \u22c3 j : Fin r, C j)\n  (l6 : \u2211 j : Fin r, volume (C j) \u2264 \u03f5)\n  (l7 : \u2200 j : Fin r, EMetric.diam (C j) < \u03c1) :\n  \u2203 (C_cubes : Fin r \u2192 Set \u03b1),\n    (\u2200 j : Fin r, EMetric.diam (C_cubes j) < \u03c1) \u2227\n    (\u2200 j : Fin r, (C_cubes j) \u2229 K \u2260 \u2205) \u2227\n    (K \u2286 \u22c3 j : Fin r, C_cubes j) \u2227\n    (\u2211 j : Fin r, volume (C_cubes j) \u2264 \u03f5) := by\n  exact \u27e8C, l7, def_2, l3, l6\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 27, "endLine": 8, "endColumn": 28, "data": "application type mismatch\n  C j\nargument\n  j\nhas type\n  Fin r : Type\nbut is expected to have type\n  Fin r\u271d : Type"}, {"line": 9, "column": 27, "endLine": 9, "endColumn": 28, "data": "application type mismatch\n  C j\nargument\n  j\nhas type\n  Fin r : Type\nbut is expected to have type\n  Fin r\u271d : Type"}, {"line": 11, "column": 37, "endLine": 11, "endColumn": 38, "data": "application type mismatch\n  C j\nargument\n  j\nhas type\n  Fin r : Type\nbut is expected to have type\n  Fin r\u271d : Type"}, {"line": 11, "column": 42, "endLine": 11, "endColumn": 43, "data": "type mismatch\n  \u03c1\nhas type\n  \u211d : Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 13, "column": 45, "endLine": 13, "endColumn": 46, "data": "type mismatch\n  \u03c1\nhas type\n  \u211d : Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 10, "column": 21, "endLine": 10, "endColumn": 33, "data": "function expected at\n  volume\nterm has type\n  ?m.2503"}, {"line": 16, "column": 18, "endLine": 16, "endColumn": 36, "data": "function expected at\n  volume\nterm has type\n  ?m.2503"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    