
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$. Let $(b_n)$ be a sequence defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$. Prove that for all integers $n \geq 1$, the inequality $a_n < b_n$ holds.

Proof: First, we find the explicit formulas for the terms of both sequences and then showing the inequality holds. For the sequence $(a_n)$, we have $a_1=1$. For $n=1$, $a_2=3a_1-2=3(1)-2=1$. For $n=2$, $a_3=3a_2-2=3(1)-2=1$. By induction, we can show that $a_n=1$ for all $n \geq 1$. For the sequence $(b_n)$, we have $b_1=3$. We can show that $b_n=2^{n+1}-1$ by induction. For the base case $n=1$, $b_1=2^{1+1}-1=2^2-1=3$ holds. Assume $b_k=2^{k+1}-1$ for some $k \geq 1$. Then $b_{k+1}=2b_k+1=2(2^{k+1}-1)+1=2^{k+2}-2+1=2^{k+2}-1$. So $b_{k+1}=2^{(k+1)+1}-1$ holds. Thus $b_n=2^{n+1}-1$ for all $n \geq 1$. Now we need to prove the inequality $a_n < b_n$. Substituting our explicit formulas, we need to show that $1 < 2^{n+1}-1$. This is equivalent to showing $2 < 2^{n+1}$, which is $1 < 2^n$. This inequality holds for all integers $n \geq 1$. Therefore, the inequality $a_n < b_n$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$.", "statement": "Premise:\n\u2022 $(a_n)_{n \\ge 1}$ is a sequence of real numbers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for all integers $n \\ge 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1_a1 : a 1 = 1)\n(tc_1_recurrence : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `a : \u2115 \u2192 \u211d` correctly captures a sequence of real numbers indexed by natural numbers, which corresponds to $(a_n)_{n \u2265 1}$", "The Lean condition `a 1 = 1` exactly matches the mathematical statement $a_1 = 1$", "The Lean recurrence relation `\u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2` perfectly captures the mathematical recurrence $a_{n+1} = 3a_n - 2$ for all integers $n \u2265 1$", "The well-definedness of the sequence is implicitly established in Lean through the type declaration and the explicit conditions, which corresponds to the conclusion that the sequence is well-defined"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $(b_n)$ be a sequence defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$.", "statement": "Premise:\n\u2022 $(b_n)_{n \\ge 1}$ is a sequence of real numbers defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$ for all integers $n \\ge 1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (b : \u2115 \u2192 \u211d)\n(tc_2 : b 1 = 3 \u2227 \u2200 n \u2265 1, b (n + 1) = 2 * b n + 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'b : \u2115 \u2192 \u211d' correctly captures that b is a sequence of real numbers indexed by natural numbers, which corresponds to the mathematical notation $(b_n)_{n \\ge 1}$", "The Lean condition 'b 1 = 3' exactly matches the mathematical statement $b_1 = 3$", "The Lean condition '\u2200 n \u2265 1, b (n + 1) = 2 * b n + 1' precisely captures the recurrence relation $b_{n+1} = 2b_n + 1$ for all integers $n \\ge 1$", "The Lean formalization implicitly establishes that the sequence is well-defined through the type declaration and the explicit conditions. In Lean's type theory, declaring the variable and providing the constraints is equivalent to asserting the sequence is well-defined"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For the sequence $(a_n)$, we have $a_1=1$. For $n=1$, $a_2=3a_1-2=3(1)-2=1$. For $n=2$, $a_3=3a_2-2=3(1)-2=1$. By induction, we can show that $a_n=1$ for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\ge 1}$ is a sequence of real numbers defined by $a_1=1$ and $a_{n+1}=3a_n-2$ for all integers $n \\ge 1$ [tc_1].\nTherefore, we conclude:\n\u2022 For all integers $n \\ge 1$, $a_n=1$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1_a1 : a 1 = 1)\n  (tc_1_recurrence : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1_a1 : a 1 = 1)\n  (tc_1_recurrence : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 := by\n  intro n hn\n  induction' n with d hd\n  \u00b7 linarith\n  \u00b7 cases' d with k\n    \u00b7 exact tc_1_a1\n    \u00b7 have hk : k + 1 \u2265 1 := by simp\n      specialize hd hk\n      rw [tc_1_recurrence (k + 1) hk, hd]\n      norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition, initial condition a\u2081=1, and domain specification are correctly captured. Using \u2115\u2192\u211d appropriately represents a sequence of real numbers indexed by positive integers.", "The recurrence relation a_{n+1}=3a_n-2 for n\u22651 is perfectly formalized with correct quantification and the constraint n\u22651.", "The conclusion statement 'for all integers n\u22651, a_n=1' is exactly captured in the Lean formalization with proper universal quantification and constraint."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For the sequence $(b_n)$, we have $b_1=3$. We can show that $b_n=2^{n+1}-1$ by induction. For the base case $n=1$, $b_1=2^{1+1}-1=2^2-1=3$ holds. Assume $b_k=2^{k+1}-1$ for some $k \\geq 1$. Then $b_{k+1}=2b_k+1=2(2^{k+1}-1)+1=2^{k+2}-2+1=2^{k+2}-1$. So $b_{k+1}=2^{(k+1)+1}-1$ holds. Thus $b_n=2^{n+1}-1$ for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(b_n)_{n \\ge 1}$ is a sequence of real numbers defined by $b_1=3$ and $b_{n+1}=2b_n+1$ for all integers $n \\ge 1$ [tc_2].\nTherefore, we conclude:\n\u2022 For all integers $n \\ge 1$, $b_n = 2^{n+1}-1$ [l2].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (b : \u2115 \u2192 \u211d)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n \u2265 1, b (n + 1) = 2 * b n + 1) :\n  \u2200 n \u2265 1, b n = 2^(n + 1) - 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (b : \u2115 \u2192 \u211d)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n \u2265 1, b (n + 1) = 2 * b n + 1) :\n  \u2200 n \u2265 1, b n = 2^(n + 1) - 1 := by\n  intro n hn\n  induction' n using Nat.strong_induction_on with n ih\n  cases' n with n\n  \u00b7 simp at hn\n    have : n = 0 := by omega\n    subst this\n    rw [tc_2.1]\n    norm_num\n  \u00b7 have h\u2081 : n + 1 \u2265 1 := by omega\n    rw [tc_2.2 _ h\u2081]\n    have h\u2082 : n \u2265 1 \u2192 b n = 2 ^ (n + 1) - 1 := by\n      intro h\n      apply ih n\n      \u00b7 omega\n      \u00b7 exact h\n    by_cases h\u2083 : n = 0\n    \u00b7 subst h\u2083\n      simp [tc_2.1]\n      norm_num\n    \u00b7 have : n \u2265 1 := by omega\n      rw [h\u2082 this]\n      ring_nf\n      rw [pow_succ]\n      ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 4, "endLine": 13, "endColumn": 8, "data": "no goals to be solved"}, {"line": 18, "column": 8, "endLine": 18, "endColumn": 19, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  b (n + 1 + 1)\ncase h.succ\nb : \u2115 \u2192 \u211d\ntc_2 : b 1 = 3 \u2227 \u2200 n \u2265 1, b (n + 1) = 2 * b n + 1\nn : \u2115\nih : \u2200 m < n + 1, m \u2265 1 \u2192 b m = 2 ^ (m + 1) - 1\nhn h\u2081 : n + 1 \u2265 1\n\u22a2 b (n + 1) = 2 ^ (n + 1 + 1) - 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition, initial condition, and typing are correctly captured in Lean.", "The recurrence relation is mathematically equivalent, but uses natural numbers (\u2115) instead of integers (\u2124) as specified in natural language. However, since we're only concerned with n \u2265 1, this doesn't affect the mathematical validity.", "The conclusion formula is perfectly translated from mathematical notation to Lean syntax.", "The overall logical structure correctly represents the premise-conclusion relationship as a lemma with appropriate hypotheses.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.75 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  (b : \u2115 \u2192 \u211d)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n \u2265 1, b (n + 1) = 2 * b n + 1) :\n  \u00ac \u2200 n \u2265 1, b n = 2^(n + 1) - 1 := by\n  intro h\n  have h4 := h 4\n  simp [tc_2.2 3 (by linarith), tc_2.2 2 (by linarith), tc_2.2 1 (by linarith), tc_2.1] at h4\n  norm_num at h4"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Substituting our explicit formulas, we need to show that $1 < 2^{n+1}-1$.", "statement": "We assume:\n\u2022 For all integers $n \\ge 1$, $a_n=1$ [l1].\n\u2022 For all integers $n \\ge 1$, $b_n=2^{n+1}-1$ [l2].\nTherefore, we conclude:\n\u2022 For all integers $n \\ge 1$, the inequality $a_n < b_n$ is equivalent to $1 < 2^{n+1}-1$ [l3].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a b : \u2115 \u2192 \u211d)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a b : \u2115 \u2192 \u211d)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) := by\n  intro n hn\n  rw [l1 n hn, l2 n hn]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 54, "endLine": 11, "endColumn": 23, "data": "unsolved goals\na b : \u2115 \u2192 \u211d\nl1 : \u2200 n \u2265 1, a n = 1\nl2 : \u2200 n \u2265 1, b n = 2 ^ (n + 1) - 1\nn : \u2115\nhn : n \u2265 1\n\u22a2 1 < 2 ^ (n + 1) - 1 \u2194 1 < 2 ^ (n + 1) - 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language specifies 'integers n \u2265 1' while Lean uses natural numbers (\u2115). However, since we're only considering n \u2265 1, this restriction makes the domains effectively equivalent for the mathematical content. The function codomain is \u211d in Lean but unspecified in natural language, which is an acceptable additional detail.", "The logical structure of the conclusion perfectly matches. Both express the equivalence between a_n < b_n and 1 < 2^(n+1) - 1 for all n \u2265 1. The biconditional (\u2194) correctly captures the 'equivalent to' relationship.", "Minor notational difference in domain specification (integers vs natural numbers), but the mathematical meaning is preserved since we only consider n \u2265 1. The additional type information in Lean (\u211d codomain) doesn't contradict the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language specifies 'integers n \u2265 1' while Lean uses natural numbers (\u2115). However, since we're only considering n \u2265 1, this restriction makes the domains effectively equivalent for the mathematical content. The function codomain is \u211d in Lean but unspecified in natural language, which is an acceptable additional detail.\", \"The logical structure of the conclusion perfectly matches. Both express the equivalence between a_n < b_n and 1 < 2^(n+1) - 1 for all n \u2265 1. The biconditional (\u2194) correctly captures the 'equivalent to' relationship.\", \"Minor notational difference in domain specification (integers vs natural numbers), but the mathematical meaning is preserved since we only consider n \u2265 1. The additional type information in Lean (\u211d codomain) doesn't contradict the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "This is equivalent to showing $2 < 2^{n+1}$, which is $1 < 2^n$.", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\ge 1$.\nTherefore, we conclude:\n\u2022 The inequality $1 < 2^{n+1}-1$ is equivalent to the inequality $1 < 2^n$ [l4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115) (hn : n \u2265 1) :\n  (1 < 2^(n+1) - 1) \u2194 (1 < 2^n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115) (hn : n \u2265 1) :\n  (1 < 2^(n+1) - 1) \u2194 (1 < 2^n) := by\n  constructor\n  \u00b7 intro h\n    rw [pow_succ] at h\n    linarith\n  \u00b7 intro h\n    rw [pow_succ]\n    linarith", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 4, "endLine": 11, "endColumn": 12, "data": "linarith failed to find a contradiction\ncase mp.h\nn : \u2115\nhn : n \u2265 1\nh : 1 < 2 ^ n * 2 - 1\na\u271d : 1 \u2265 2 ^ n\n\u22a2 False failed"}, {"line": 14, "column": 4, "endLine": 14, "endColumn": 12, "data": "linarith failed to find a contradiction\ncase mpr.h\nn : \u2115\nhn : n \u2265 1\nh : 1 < 2 ^ n\na\u271d : 1 \u2265 2 ^ n * 2 - 1\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language specifies 'integer' while Lean uses natural numbers (\u2115). However, since the constraint is n \u2265 1, this restricts to positive integers, which are equivalent to natural numbers \u2265 1 in this context. This is a minor notational difference that doesn't affect the mathematical meaning.", "The equivalence statement is perfectly captured in Lean using the biconditional (\u2194) operator, correctly representing the mathematical equivalence between the two inequalities.", "The label [l4] in natural language corresponds exactly to the lemma name 'l4' in Lean.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l4 : \u00ac \u2200 (n : \u2115), n \u2265 1 \u2192 (1 < 2^(n+1) - 1 \u2194 1 < 2^n) := by\n  push_neg\n  use 1\n  constructor\n  \u00b7 norm_num\n  \u00b7 constructor\n    \u00b7 norm_num\n    \u00b7 intro h\n      simp at h"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This inequality holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\ge 1$.\nTherefore, we conclude:\n\u2022 $1 < 2^n$ [l5].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2115) (hn : n \u2265 1) :\n  1 < 2^n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2115) (hn : n \u2265 1) :\n  1 < 2^n := by\n  induction n with\n  | zero => simp at hn\n  | succ k hk =>\n    cases k with\n    | zero => simp [hn]\n    | succ m =>\n      rw [pow_succ]\n      refine lt_mul_of_one_lt_left (by positivity) ?_\n      exact hk (by omega)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 39, "endLine": 15, "endColumn": 49, "data": "failed to synthesize\n  Zero ?m.2796\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization uses natural numbers (\u2115) instead of integers (\u2124) as specified in the natural language. However, since the constraint n \u2265 1 is present, the effective domain (positive integers) remains the same in both cases. The conclusion 1 < 2^n is correctly captured. This represents a minor structural difference in type specification that doesn't affect the core mathematical meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization uses natural numbers (\u2115) instead of integers (\u2124) as specified in the natural language. However, since the constraint n \u2265 1 is present, the effective domain (positive integers) remains the same in both cases. The conclusion 1 < 2^n is correctly captured. This represents a minor structural difference in type specification that doesn't affect the core mathematical meaning.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, the inequality $a_n < b_n$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 For all integers $n \\ge 1$, the inequality $a_n < b_n$ is equivalent to $1 < 2^{n+1}-1$ [l3].\n\u2022 For any integer $n \\ge 1$, the inequality $1 < 2^{n+1}-1$ is equivalent to $1 < 2^n$ [l4].\n\u2022 For any integer $n \\ge 1$, the inequality $1 < 2^n$ is true [l5].\nTherefore, we conclude:\n\u2022 For all integers $n \\ge 1$, the inequality $a_n < b_n$ holds [ts_1].", "dependencies": ["l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b : \u2115 \u2192 \u211d)\n  (l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 < 2^(n + 1) - 1 \u2194 1 < 2^n))\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b : \u2115 \u2192 \u211d)\n  (l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 < 2^(n + 1) - 1 \u2194 1 < 2^n))\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\n  intro n hn\n  rw [l3 n hn]\n  rw [l4 n hn]\n  exact l5 n hn", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The function declarations appropriately capture the mathematical sequences a_n and b_n as functions from natural numbers to real numbers.", "Assumption l3 is perfectly formalized with correct equivalence (\u2194) and universal quantification matching the natural language.", "Assumption l4 correctly captures the equivalence between the two inequalities with proper quantification.", "Assumption l5 is accurately formalized as a universal statement about the inequality 1 < 2^n.", "The conclusion ts_1 perfectly matches the natural language statement, and the overall logical structure correctly represents the mathematical reasoning from assumptions to conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    