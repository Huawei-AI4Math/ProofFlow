
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ and $(b_n)$ be sequences defined by $a_n = \frac{1}{n(n+1)}$ and $b_n = \frac{1}{n^2}$. Let $S_N = \sum_{n=1}^{N} a_n$ and $T_N = \sum_{n=1}^{N} b_n$ be their respective partial sums. Prove that for all integers $N \geq 1$, the inequality $S_N < T_N$ holds.

Proof: We will prove this by establishing a more general inequality for the terms of the sequences. First, consider the generic terms $a_n$ and $b_n$. We need to show that $a_n < b_n$ for all $n \geq 1$. We have $a_n = \frac{1}{n(n+1)}$ and $b_n = \frac{1}{n^2}$. The inequality is $\frac{1}{n(n+1)} < \frac{1}{n^2}$. Since $n \geq 1$, both denominators are positive, so we can cross-multiply, which gives $n^2 < n(n+1)$. This simplifies to $n^2 < n^2+n$. Subtracting $n^2$ from both sides gives $0 < n$, which is true for all integers $n \geq 1$. Since $a_n < b_n$ for all $n \geq 1$, we can take the sum of the first $N$ terms for both sequences. The sum of a smaller set of positive terms will be smaller than the sum of a larger set of positive terms. Therefore, for any $N \geq 1$, we have $\sum_{n=1}^{N} a_n < \sum_{n=1}^{N} b_n$. This means $S_N < T_N$. The inequality holds for all integers $N \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ and $(b_n)$ be sequences defined by $a_n = \\frac{1}{n(n+1)}$ and $b_n = \\frac{1}{n^2}$.", "statement": "Premise:\n\u2022 $(a_n)_{n\\ge 1}$ and $(b_n)_{n\\ge 1}$ are sequences of real numbers defined for integers $n \\ge 1$ by $a_n = \\frac{1}{n(n+1)}$ and $b_n = \\frac{1}{n^2}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (a b : \u2115 \u2192 \u211d)\n  (tc_1 : (\u2200 n \u2265 1, a n = 1 / (n * (n + 1))) \u2227 (\u2200 n \u2265 1, b n = 1 / (n * n)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `(a b : \u2115 \u2192 \u211d)` correctly captures that both sequences are functions from natural numbers to real numbers, which matches the mathematical description of sequences of real numbers defined for integers n \u2265 1", "The Lean condition `\u2200 n \u2265 1, a n = 1 / (n * (n + 1))` perfectly matches the mathematical formula $a_n = \\frac{1}{n(n+1)}$ with the appropriate domain restriction", "The Lean condition `\u2200 n \u2265 1, b n = 1 / (n * n)` perfectly matches the mathematical formula $b_n = \\frac{1}{n^2}$ with the appropriate domain restriction, where `n * n` is equivalent to `n^2`", "The Lean formalization establishes both sequences with their respective formulas through the conjunction in tc_1, which matches the conclusion that the sequences are established with their formulas"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $S_N = \\sum_{n=1}^{N} a_n$ and $T_N = \\sum_{n=1}^{N} b_n$ be their respective partial sums.", "statement": "Premise:\n\u2022 $(a_n)_{n\\ge 1}$ and $(b_n)_{n\\ge 1}$ are the sequences from [tc_1].\n\u2022 $S_N$ and $T_N$ are partial sums defined as $S_N = \\sum_{n=1}^{N} a_n$ and $T_N = \\sum_{n=1}^{N} b_n$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (a b : \u2115 \u2192 \u211d)\n  (tc_1 : (\u2200 n \u2265 1, a n = 1 / (n * (n + 1))) \u2227 (\u2200 n \u2265 1, b n = 1 / (n * n)))\n  (S T : \u2115 \u2192 \u211d)\n  (tc_2 : (\u2200 N \u2265 1, S N = \u2211 n in Finset.range (N + 1), a n) \u2227 (\u2200 N \u2265 1, T N = \u2211 n in Finset.range (N + 1), b n))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures that sequences a and b are defined by tc_1, matching the natural language reference to sequences from [tc_1]", "The Lean uses `Finset.range (N + 1)` which sums from 0 to N, while the mathematical notation $\\sum_{n=1}^{N} a_n$ sums from 1 to N. However, since the sequences are typically defined for n \u2265 1, this could be equivalent if a(0) and b(0) are 0 or undefined. The indexing difference represents a minor structural inconsistency in the translation"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that sequences a and b are defined by tc_1, matching the natural language reference to sequences from [tc_1]', 'The Lean uses `Finset.range (N + 1)` which sums from 0 to N, while the mathematical notation $\\\\sum_{n=1}^{N} a_n$ sums from 1 to N. However, since the sequences are typically defined for n \u2265 1, this could be equivalent if a(0) and b(0) are 0 or undefined. The indexing difference represents a minor structural inconsistency in the translation']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "for all integers $N \\geq 1$", "statement": "Premise:\n\u2022 The proposition is to be proven for all integers $N \\geq 1$ [tc_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (N : \u2115)\n  (tc_3 : N \u2265 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies N as an integer, but Lean declares N as a natural number (\u2115). Since N \u2265 1, natural numbers are sufficient and this is a reasonable restriction, but it's not a direct translation of 'integer'.", "The condition N \u2265 1 is perfectly captured in both the natural language and Lean formalization.", "The universal quantification over all valid N values is appropriately captured by the Lean variable declaration structure."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since $n \\geq 1$, both denominators are positive", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\ge 1$ (from the definition of the sequences in [tc_1]).\nTherefore, we conclude:\n\u2022 $n(n+1) > 0$ and $n^2 > 0$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115)\n  (tc_1 : n \u2265 1) :\n  n * (n + 1) > 0 \u2227 n * n > 0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115)\n  (tc_1 : n \u2265 1) :\n  n * (n + 1) > 0 \u2227 n * n > 0 := by\n  constructor\n  \u00b7 apply mul_pos\n    \u00b7 exact Nat.pos_of_ne_zero (Nat.ne_of_gt tc_1)\n    \u00b7 exact Nat.succ_pos n\n  \u00b7 apply mul_pos\n    \u00b7 exact Nat.pos_of_ne_zero (Nat.ne_of_gt tc_1)\n    \u00b7 exact Nat.pos_of_ne_zero (Nat.ne_of_gt tc_1)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language specifies 'n is an integer such that n \u2265 1' but the Lean formalization uses (n : \u2115) which represents natural numbers (non-negative integers). While natural numbers with n \u2265 1 are effectively positive integers and the mathematical meaning is preserved, this is a slight structural difference in the type system representation.", "The conclusion perfectly matches - both express that n(n+1) > 0 and n\u00b2 > 0. The Lean formalization correctly uses conjunction (\u2227) to represent 'and', and n * n is equivalent to n\u00b2 in this context."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language specifies 'n is an integer such that n \u2265 1' but the Lean formalization uses (n : \u2115) which represents natural numbers (non-negative integers). While natural numbers with n \u2265 1 are effectively positive integers and the mathematical meaning is preserved, this is a slight structural difference in the type system representation.\", \"The conclusion perfectly matches - both express that n(n+1) > 0 and n\u00b2 > 0. The Lean formalization correctly uses conjunction (\u2227) to represent 'and', and n * n is equivalent to n\u00b2 in this context.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "so we can cross-multiply, which gives $n^2 < n(n+1)$.", "statement": "We assume:\n\u2022 $n(n+1) > 0$ and $n^2 > 0$ [l1].\nTherefore, we conclude:\n\u2022 The inequality $\\frac{1}{n(n+1)} < \\frac{1}{n^2}$ holds if and only if $n^2 < n(n+1)$ [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u211d)\n  (l1 : n * (n + 1) > 0 \u2227 n * n > 0) :\n  (1 / (n * (n + 1)) < 1 / (n * n)) \u2194 (n * n < n * (n + 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u211d)\n  (l1 : n * (n + 1) > 0 \u2227 n * n > 0) :\n  (1 / (n * (n + 1)) < 1 / (n * n)) \u2194 (n * n < n * (n + 1)) := by\n  rw [div_lt_div_iff (l1.1) (l1.2)]\n  simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The variable declaration as a real number is appropriate, the assumptions are properly represented as a conjunction, and the main biconditional statement accurately translates the mathematical relationship. The logical structure from assumptions to conclusion is preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "This simplifies to $n^2 < n^2+n$. Subtracting $n^2$ from both sides gives $0 < n$.", "statement": "We assume:\n\u2022 $n$ is an integer.\nTherefore, we conclude:\n\u2022 The inequality $n^2 < n(n+1)$ is equivalent to $0 < n$ [l3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2124) :\n  (n^2 < n * (n + 1) \u2194 0 < n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2124) :\n  (n^2 < n * (n + 1) \u2194 0 < n) := by\n  constructor\n  \u00b7 intro h\n    rw [pow_two, mul_add] at h\n    simp only [mul_one] at h\n    exact Int.lt_of_add_lt_add_left h\n  \u00b7 intro h\n    rw [pow_two, mul_add]\n    simp only [mul_one]\n    exact Int.add_lt_add_left h (n * n)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 36, "endLine": 12, "endColumn": 37, "data": "application type mismatch\n  Int.lt_of_add_lt_add_left h\nargument\n  h\nhas type\n  n * n < n * n + n : Prop\nbut is expected to have type\n  ?m.1984 + 0 < ?m.1984 + n : Prop"}, {"line": 16, "column": 4, "endLine": 16, "endColumn": 39, "data": "type mismatch\n  Int.add_lt_add_left h (n * n)\nhas type\n  n * n + 0 < n * n + n : Prop\nbut is expected to have type\n  n * n < n * n + n : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. The variable declaration (n : \u2124) correctly represents 'n is an integer', and the equivalence statement n^2 < n * (n + 1) \u2194 0 < n exactly matches the claimed equivalence between the inequality n\u00b2 < n(n+1) and 0 < n. The additional Lean infrastructure (lemma declaration, imports, etc.) does not affect the mathematical content and is expected in a formal proof system.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3_negation :\n  \u00ac \u2200 (n : \u2124), (n^2 < n * (n + 1) \u2194 0 < n) := by\n  intro h\n  have h1 := h (-1)\n  simp at h1\n  have h2 : (-1 : \u2124)^2 < (-1) * ((-1) + 1) := by norm_num\n  have h3 : \u00ac(0 < (-1 : \u2124)) := by norm_num\n  rw [h1] at h2\n  exact h3 h2"}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "which is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\ge 1$ (from the definition of the sequences in [tc_1]).\nTherefore, we conclude:\n\u2022 $0 < n$ [l4].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (tc_1 : n \u2265 1) :\n  0 < n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (tc_1 : n \u2265 1) :\n  0 < n := by\n  exact Nat.pos_of_ne_zero (Nat.not_eq_zero_of_lt (Nat.succ_le_iff.mp tc_1))", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The natural language states 'n is an integer' but Lean uses 'n : \u2115' (natural numbers). While \u2115 \u2286 \u2124 and the constraint n \u2265 1 makes this practically equivalent, there's a slight type difference since natural numbers are a subset of integers.", "The assumption n \u2265 1 is correctly captured as hypothesis tc_1 in the Lean formalization, with the reference [tc_1] properly corresponding to the hypothesis name.", "The conclusion 0 < n is exactly captured as the goal of lemma l4, with the label [l4] correctly corresponding to the lemma name.", "The logical structure of 'assuming X, therefore concluding Y' is perfectly captured by the Lean lemma format where tc_1 is the hypothesis and 0 < n is the goal to be proved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "First, consider the generic terms $a_n$ and $b_n$. We need to show that $a_n < b_n$ for all $n \\geq 1$. We have $a_n = \\frac{1}{n(n+1)}$ and $b_n = \\frac{1}{n^2}$. The inequality is $\\frac{1}{n(n+1)} < \\frac{1}{n^2}$. Since $n \\geq 1$, both denominators are positive, so we can cross-multiply, which gives $n^2 < n(n+1)$. This simplifies to $n^2 < n^2+n$. Subtracting $n^2$ from both sides gives $0 < n$, which is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $a_n = \\frac{1}{n(n+1)}$ and $b_n = \\frac{1}{n^2}$ for integers $n \\ge 1$ [tc_1].\n\u2022 For $n \\ge 1$, the inequality $\\frac{1}{n(n+1)} < \\frac{1}{n^2}$ is equivalent to $n^2 < n(n+1)$ [l2].\n\u2022 For an integer $n$, the inequality $n^2 < n(n+1)$ is equivalent to $0 < n$ [l3].\n\u2022 For an integer $n \\ge 1$, it is true that $0 < n$ [l4].\nTherefore, we conclude:\n\u2022 For any integer $n \\geq 1$, $a_n < b_n$ [l5].", "dependencies": ["tc_1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a b : \u2115 \u2192 \u211d)\n  (n : \u2115)\n  (tc_1 : (\u2200 n \u2265 1, a n = 1 / (n * (n + 1))) \u2227 (\u2200 n \u2265 1, b n = 1 / (n * n)))\n  (l2 : (n : \u211d) * ((n : \u211d) + 1) > 0 \u2227 (n : \u211d) * (n : \u211d) > 0 \u2192 (1 / ((n : \u211d) * ((n : \u211d) + 1)) < 1 / ((n : \u211d) * (n : \u211d))) \u2194 ((n : \u211d) * (n : \u211d) < (n : \u211d) * ((n : \u211d) + 1)))\n  (l3 : ((n : \u2124)^2 < (n : \u2124) * ((n : \u2124) + 1) \u2194 0 < (n : \u2124)))\n  (l4 : n \u2265 1 \u2192 0 < n) :\n  n \u2265 1 \u2192 a n < b n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a b : \u2115 \u2192 \u211d)\n  (n : \u2115)\n  (tc_1 : (\u2200 n \u2265 1, a n = 1 / (n * (n + 1))) \u2227 (\u2200 n \u2265 1, b n = 1 / (n * n)))\n  (l2 : (n : \u211d) * ((n : \u211d) + 1) > 0 \u2227 (n : \u211d) * (n : \u211d) > 0 \u2192 (1 / ((n : \u211d) * ((n : \u211d) + 1)) < 1 / ((n : \u211d) * (n : \u211d))) \u2194 ((n : \u211d) * (n : \u211d) < (n : \u211d) * ((n : \u211d) + 1)))\n  (l3 : ((n : \u2124)^2 < (n : \u2124) * ((n : \u2124) + 1) \u2194 0 < (n : \u2124)))\n  (l4 : n \u2265 1 \u2192 0 < n) :\n  n \u2265 1 \u2192 a n < b n := by\n  intro hn\n  have ha := (tc_1.1 n hn)\n  have hb := (tc_1.2 n hn)\n  rw [ha, hb]\n  have hpos : (n : \u211d) * (n + 1) > 0 \u2227 (n : \u211d) * n > 0 := by\n    constructor\n    \u00b7 apply mul_pos (Nat.cast_pos.mpr (l4 hn)) (Nat.cast_pos.mpr (succ_pos n))\n    \u00b7 exact Nat.cast_pos.mpr (mul_pos (l4 hn) (l4 hn))\n  have h := l2 hpos\n  rw [h]\n  simp only [Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_pow]\n  rw [\u2190 Int.cast_lt (\u03b1 := \u211d), \u2190 Int.cast_mul, \u2190 Int.cast_mul, \u2190 Int.cast_pow, \u2190 Int.cast_add, Int.cast_one]\n  rw [l3]\n  exact Int.cast_pos.mpr (l4 hn)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 6, "endLine": 19, "endColumn": 78, "data": "tactic 'apply' failed, failed to unify\n  0 < \u2191n * \u2191n.succ\nwith\n  \u2191n * (\u2191n + 1) > 0\ncase left\na b : \u2115 \u2192 \u211d\nn : \u2115\ntc_1 : (\u2200 n \u2265 1, a n = 1 / (\u2191n * (\u2191n + 1))) \u2227 \u2200 n \u2265 1, b n = 1 / (\u2191n * \u2191n)\nl2 : \u2191n * (\u2191n + 1) > 0 \u2227 \u2191n * \u2191n > 0 \u2192 1 / (\u2191n * (\u2191n + 1)) < 1 / (\u2191n * \u2191n) \u2194 \u2191n * \u2191n < \u2191n * (\u2191n + 1)\nl3 : \u2191n ^ 2 < \u2191n * (\u2191n + 1) \u2194 0 < \u2191n\nl4 : n \u2265 1 \u2192 0 < n\nhn : n \u2265 1\nha : a n = 1 / (\u2191n * (\u2191n + 1))\nhb : b n = 1 / (\u2191n * \u2191n)\n\u22a2 \u2191n * (\u2191n + 1) > 0"}, {"line": 20, "column": 6, "endLine": 20, "endColumn": 54, "data": "type mismatch\n  Nat.cast_pos.mpr (mul_pos (l4 hn) (l4 hn))\nhas type\n  0 < \u2191(n * n) : Prop\nbut is expected to have type\n  \u2191n * \u2191n > 0 : Prop"}, {"line": 21, "column": 12, "endLine": 21, "endColumn": 19, "data": "function expected at\n  l2\nterm has type\n  \u2191n * (\u2191n + 1) > 0 \u2227 \u2191n * \u2191n > 0 \u2192 1 / (\u2191n * (\u2191n + 1)) < 1 / (\u2191n * \u2191n) \u2194 \u2191n * \u2191n < \u2191n * (\u2191n + 1)"}, {"line": 12, "column": 23, "endLine": 26, "endColumn": 32, "data": "unsolved goals\na b : \u2115 \u2192 \u211d\nn : \u2115\ntc_1 : (\u2200 n \u2265 1, a n = 1 / (\u2191n * (\u2191n + 1))) \u2227 \u2200 n \u2265 1, b n = 1 / (\u2191n * \u2191n)\nl2 : \u2191n * (\u2191n + 1) > 0 \u2227 \u2191n * \u2191n > 0 \u2192 1 / (\u2191n * (\u2191n + 1)) < 1 / (\u2191n * \u2191n) \u2194 \u2191n * \u2191n < \u2191n * (\u2191n + 1)\nl3 : \u2191n ^ 2 < \u2191n * (\u2191n + 1) \u2194 0 < \u2191n\nl4 : n \u2265 1 \u2192 0 < n\nhn : n \u2265 1\nha : a n = 1 / (\u2191n * (\u2191n + 1))\nhb : b n = 1 / (\u2191n * \u2191n)\nhpos : \u2191n * (\u2191n + 1) > 0 \u2227 \u2191n * \u2191n > 0\n\u22a2 1 / (\u2191n * (\u2191n + 1)) < 1 / (\u2191n * \u2191n)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definitions tc_1 correctly capture the mathematical content with appropriate type declarations.", "The inequality equivalence l2 correctly captures the mathematical relationship, with reasonable addition of positivity conditions for well-defined division operations.", "The algebraic equivalence l3 captures the correct mathematical relationship but has a type inconsistency - n is declared as \u2115 but cast to \u2124, and should be universally quantified rather than referring to the specific parameter n.", "The positivity statement l4 perfectly matches the natural language logical content.", "The main conclusion l5 perfectly captures the logical structure of the final statement.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['The sequence definitions tc_1 correctly capture the mathematical content with appropriate type declarations.', 'The inequality equivalence l2 correctly captures the mathematical relationship, with reasonable addition of positivity conditions for well-defined division operations.', 'The algebraic equivalence l3 captures the correct mathematical relationship but has a type inconsistency - n is declared as \u2115 but cast to \u2124, and should be universally quantified rather than referring to the specific parameter n.', 'The positivity statement l4 perfectly matches the natural language logical content.', 'The main conclusion l5 perfectly captures the logical structure of the final statement.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since $a_n < b_n$ for all $n \\geq 1$, we can take the sum of the first $N$ terms for both sequences. The sum of a smaller set of positive terms will be smaller than the sum of a larger set of positive terms. Therefore, for any $N \\geq 1$, we have $\\sum_{n=1}^{N} a_n < \\sum_{n=1}^{N} b_n$. This means $S_N < T_N$. The inequality holds for all integers $N \\geq 1$.", "statement": "We assume:\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ and $T_N = \\sum_{n=1}^{N} b_n$ for sequences from [tc_1] and for any integer $N \\geq 1$ [tc_2, tc_3].\n\u2022 For any integer $n \\geq 1$, $a_n < b_n$ [l5].\nTherefore, we conclude:\n\u2022 For any integer $N \\geq 1$, $S_N < T_N$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b : \u2115 \u2192 \u211d) (S T : \u2115 \u2192 \u211d) (N : \u2115)\n  (tc_1 : (\u2200 n \u2265 1, a n = 1 / (n * (n + 1))) \u2227 (\u2200 n \u2265 1, b n = 1 / (n * n)))\n  (tc_2 : (\u2200 N_1 \u2265 1, S N_1 = \u2211 n in Finset.range (N_1 + 1), a n) \u2227 (\u2200 N_1 \u2265 1, T N_1 = \u2211 n in Finset.range (N_1 + 1), b n))\n  (tc_3 : N \u2265 1)\n  (l5 : N \u2265 1 \u2192 a N < b N) :\n  S N < T N := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b : \u2115 \u2192 \u211d) (S T : \u2115 \u2192 \u211d) (N : \u2115)\n  (tc_1 : (\u2200 n \u2265 1, a n = 1 / (n * (n + 1))) \u2227 (\u2200 n \u2265 1, b n = 1 / (n * n)))\n  (tc_2 : (\u2200 N_1 \u2265 1, S N_1 = \u2211 n in Finset.range (N_1 + 1), a n) \u2227 (\u2200 N_1 \u2265 1, T N_1 = \u2211 n in Finset.range (N_1 + 1), b n))\n  (tc_3 : N \u2265 1)\n  (l5 : N \u2265 1 \u2192 a N < b N) :\n  S N < T N := by\n  have hS := tc_2.left N tc_3\n  have hT := tc_2.right N tc_3\n  rw [hS, hT]\n  apply Finset.sum_lt_sum\n  \u00b7 intro n hn\n    have hn' : n \u2208 Finset.range (N + 1) := hn\n    simp at hn'\n    cases' Nat.eq_zero_or_pos n with h h\n    \u00b7 rw [h]\n      simp [a, b]\n    \u00b7 have h1 := tc_1.left n h\n      have h2 := tc_1.right n h\n      rw [h1, h2]\n      simp\n      exact div_lt_div_of_lt_left (by norm_num) (by nlinarith) (by nlinarith)\n  \u00b7 use N\n    simp [tc_3]\n    exact l5 tc_3", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 6, "endLine": 21, "endColumn": 17, "data": "invalid argument, variable is not a proposition or let-declaration"}, {"line": 21, "column": 6, "endLine": 21, "endColumn": 17, "data": "invalid argument, variable is not a proposition or let-declaration"}, {"line": 20, "column": 4, "endLine": 21, "endColumn": 17, "data": "unsolved goals\ncase hle.inl\na b S T : \u2115 \u2192 \u211d\nN : \u2115\ntc_1 : (\u2200 n \u2265 1, a n = 1 / (\u2191n * (\u2191n + 1))) \u2227 \u2200 n \u2265 1, b n = 1 / (\u2191n * \u2191n)\ntc_2 : (\u2200 N_1 \u2265 1, S N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), a n) \u2227 \u2200 N_1 \u2265 1, T N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), b n\ntc_3 : N \u2265 1\nl5 : N \u2265 1 \u2192 a N < b N\nhS : S N = \u2211 n \u2208 Finset.range (N + 1), a n\nhT : T N = \u2211 n \u2208 Finset.range (N + 1), b n\nn : \u2115\nhn : n \u2208 Finset.range (N + 1)\nhn' : n < N + 1\nh : n = 0\n\u22a2 a 0 \u2264 b 0"}, {"line": 26, "column": 35, "endLine": 26, "endColumn": 46, "data": "unsolved goals\na b S T : \u2115 \u2192 \u211d\nN : \u2115\ntc_1 : (\u2200 n \u2265 1, a n = 1 / (\u2191n * (\u2191n + 1))) \u2227 \u2200 n \u2265 1, b n = 1 / (\u2191n * \u2191n)\ntc_2 : (\u2200 N_1 \u2265 1, S N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), a n) \u2227 \u2200 N_1 \u2265 1, T N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), b n\ntc_3 : N \u2265 1\nl5 : N \u2265 1 \u2192 a N < b N\nhS : S N = \u2211 n \u2208 Finset.range (N + 1), a n\nhT : T N = \u2211 n \u2208 Finset.range (N + 1), b n\nn : \u2115\nhn : n \u2208 Finset.range (N + 1)\nhn' : n < N + 1\nh : n > 0\nh1 : a n = 1 / (\u2191n * (\u2191n + 1))\nh2 : b n = 1 / (\u2191n * \u2191n)\n\u22a2 0 < ?m.24828"}, {"line": 26, "column": 52, "endLine": 26, "endColumn": 61, "data": "linarith failed to find a contradiction\na b S T : \u2115 \u2192 \u211d\nN : \u2115\ntc_1 : (\u2200 n \u2265 1, a n = 1 / (\u2191n * (\u2191n + 1))) \u2227 \u2200 n \u2265 1, b n = 1 / (\u2191n * \u2191n)\ntc_2 : (\u2200 N_1 \u2265 1, S N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), a n) \u2227 \u2200 N_1 \u2265 1, T N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), b n\ntc_3 : N \u2265 1\nl5 : N \u2265 1 \u2192 a N < b N\nhS : S N = \u2211 n \u2208 Finset.range (N + 1), a n\nhT : T N = \u2211 n \u2208 Finset.range (N + 1), b n\nn : \u2115\nhn : n \u2208 Finset.range (N + 1)\nhn' : n < N + 1\nh : n > 0\nh1 : a n = 1 / (\u2191n * (\u2191n + 1))\nh2 : b n = 1 / (\u2191n * \u2191n)\n\u22a2 False failed"}, {"line": 26, "column": 67, "endLine": 26, "endColumn": 76, "data": "linarith failed to find a contradiction\na b S T : \u2115 \u2192 \u211d\nN : \u2115\ntc_1 : (\u2200 n \u2265 1, a n = 1 / (\u2191n * (\u2191n + 1))) \u2227 \u2200 n \u2265 1, b n = 1 / (\u2191n * \u2191n)\ntc_2 : (\u2200 N_1 \u2265 1, S N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), a n) \u2227 \u2200 N_1 \u2265 1, T N_1 = \u2211 n \u2208 Finset.range (N_1 + 1), b n\ntc_3 : N \u2265 1\nl5 : N \u2265 1 \u2192 a N < b N\nhS : S N = \u2211 n \u2208 Finset.range (N + 1), a n\nhT : T N = \u2211 n \u2208 Finset.range (N + 1), b n\nn : \u2115\nhn : n \u2208 Finset.range (N + 1)\nhn' : n < N + 1\nh : n > 0\nh1 : a n = 1 / (\u2191n * (\u2191n + 1))\nh2 : b n = 1 / (\u2191n * \u2191n)\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sum definitions in tc_2 use Finset.range (N_1 + 1) which sums from n=0 to N, but the natural language specifies sums from n=1 to N. This is a significant mathematical difference.", "The inequality condition l5 only states a N < b N for the specific value N, but the natural language requires a_n < b_n for any integer n \u2265 1. This weakens the premise substantially.", "The conclusion S N < T N correctly captures the natural language conclusion that S_N < T_N for any integer N \u2265 1.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sum definitions in tc_2 use Finset.range (N_1 + 1) which sums from n=0 to N, but the natural language specifies sums from n=1 to N. This is a significant mathematical difference.', 'The inequality condition l5 only states a N < b N for the specific value N, but the natural language requires a_n < b_n for any integer n \u2265 1. This weakens the premise substantially.', 'The conclusion S N < T N correctly captures the natural language conclusion that S_N < T_N for any integer N \u2265 1.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    