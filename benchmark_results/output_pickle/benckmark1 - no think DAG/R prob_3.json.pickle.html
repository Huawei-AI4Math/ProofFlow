
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a discrete random variable with a sample space $S = \{0, 1, 2\}$ and a probability mass function (PMF) of the form $P(X=k) = c(k+1)$ for $k \in S$. Then, the variance of $X$ is $Var(X) = 5/9$.

Proof: First, we determine the constant $c$ using the axiom that the sum of probabilities for a discrete random variable must be 1. For the given sample space, this means $\sum_{k=0}^{2} P(X=k) = 1$. Substituting the PMF formula gives $c(0+1) + c(1+1) + c(2+1) = 1$, which results in $c=1/6$. Next, we calculate the expected value of $X$, defined as $E[X] = \sum_{k \in S} k \cdot P(X=k)$. Using the now known probabilities, we compute $E[X] = 0(1/6) + 1(2/6) + 2(3/6) = 4/3$. Then, we calculate the expected value of $X^2$, defined as $E[X^2] = \sum_{k \in S} k^2 \cdot P(X=k)$. This gives $E[X^2] = 0^2(1/6) + 1^2(2/6) + 2^2(3/6) = 7/3$. Finally, the variance is found using the formula $Var(X) = E[X^2] - (E[X])^2$. Substituting our computed expected values, we get $Var(X) = 7/3 - (4/3)^2 = 5/9$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a discrete random variable with a sample space $S = \\{0, 1, 2\\}$", "statement": "Premise:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (X : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization defines X as a function from all natural numbers to reals (\u2115 \u2192 \u211d), but a discrete random variable with sample space {0, 1, 2} should be a function from that specific sample space to reals. The domain is incorrectly specified.", "The Lean code defines tc_1 as the set {0, 1, 2} but fails to establish any connection between this set and X as its sample space. The variable name doesn't match (tc_1 vs S) and there's no explicit relationship showing that this set serves as the sample space for the random variable X."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization defines X as a function from all natural numbers to reals (\u2115 \u2192 \u211d), but a discrete random variable with sample space {0, 1, 2} should be a function from that specific sample space to reals. The domain is incorrectly specified.', \"The Lean code defines tc_1 as the set {0, 1, 2} but fails to establish any connection between this set and X as its sample space. The variable name doesn't match (tc_1 vs S) and there's no explicit relationship showing that this set serves as the sample space for the random variable X.\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "a probability mass function (PMF) of the form $P(X=k) = c(k+1)$ for $k \\in S$.", "statement": "Premise:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].\n\u2022 The PMF of X is given by P(X=k) = c(k+1) for k in S, where c is a constant [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (X : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))\n  (tc_2 : \u2200 k : \u2115, k \u2208 tc_1 \u2192 X k = (k + 1) * 1 / 6)", "lean_pass": false, "error_msg": [{"line": 8, "column": 19, "endLine": 8, "endColumn": 27, "data": "failed to synthesize\n  Membership \u2115 \u2191{0, 1, 2}\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "we determine the constant $c$ using the axiom that the sum of probabilities for a discrete random variable must be 1. For the given sample space, this means $\\sum_{k=0}^{2} P(X=k) = 1$.", "statement": "We assume:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].\nDefinition:\n\u2022 The sum of probabilities for the discrete random variable X over its sample space S must be 1. For S = {0, 1, 2}, this is expressed as $\\sum_{k=0}^{2} P(X=k) = 1$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (X : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))\n  (def_1 : \u2200 P : \u2115 \u2192 \u211d, (\u2200 k \u2208 ({0, 1, 2} : Set \u2115), P k \u2265 0) \u2192 (\u2211 k in ({0, 1, 2} : Set \u2115), P k) = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization represents X as a function from naturals to reals (X : \u2115 \u2192 \u211d), but this doesn't capture that X is a discrete random variable with sample space {0, 1, 2}. A random variable should map from a sample space to real values, not from naturals to reals. The tc_1 declaration just defines a set but doesn't establish the connection between X and this sample space. The formalization is missing the proper probabilistic structure.", "The Lean formalization uses a universal quantification over any function P : \u2115 \u2192 \u211d with non-negativity conditions, but this doesn't represent the specific conclusion that the sum of probabilities for the random variable X equals 1. Instead, it states a general property about any non-negative function on the set {0, 1, 2}. The conclusion should specifically refer to P(X=k) for the given random variable X, not a general statement about arbitrary functions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization represents X as a function from naturals to reals (X : \u2115 \u2192 \u211d), but this doesn't capture that X is a discrete random variable with sample space {0, 1, 2}. A random variable should map from a sample space to real values, not from naturals to reals. The tc_1 declaration just defines a set but doesn't establish the connection between X and this sample space. The formalization is missing the proper probabilistic structure.\", \"The Lean formalization uses a universal quantification over any function P : \u2115 \u2192 \u211d with non-negativity conditions, but this doesn't represent the specific conclusion that the sum of probabilities for the random variable X equals 1. Instead, it states a general property about any non-negative function on the set {0, 1, 2}. The conclusion should specifically refer to P(X=k) for the given random variable X, not a general statement about arbitrary functions.\"]"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Substituting the PMF formula gives $c(0+1) + c(1+1) + c(2+1) = 1$", "statement": "We assume:\n\u2022 The PMF of X is given by P(X=k) = c(k+1) for k in S = {0, 1, 2} [tc_2].\n\u2022 $\\sum_{k=0}^{2} P(X=k) = 1$ [def_1].\nTherefore, we conclude:\n\u2022 $c(0+1) + c(1+1) + c(2+1) = 1$ [l1].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (X : \u2115 \u2192 \u211d)\n  (c : \u211d)\n  (tc_2 : \u2200 k \u2208 ({0, 1, 2} : Set \u2115), X k = c * (k + 1))\n  (def_1 : (\u2211 k in ({0, 1, 2} : Set \u2115), X k) = 1) :\n  c * (0 + 1) + c * (1 + 1) + c * (2 + 1) = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (X : \u2115 \u2192 \u211d)\n  (c : \u211d)\n  (tc_2 : \u2200 k \u2208 ({0, 1, 2} : Set \u2115), X k = c * (k + 1))\n  (def_1 : (\u2211 k in ({0, 1, 2} : Finset \u2115), X k) = 1) :\n  c * (0 + 1) + c * (1 + 1) + c * (2 + 1) = 1 := by\n  have h0 : X 0 = c * (0 + 1) := tc_2 0 (by simp)\n  have h1 : X 1 = c * (1 + 1) := tc_2 1 (by simp)\n  have h2 : X 2 = c * (2 + 1) := tc_2 2 (by simp)\n  rw [\u2190 def_1, Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton]\n  repeat' aesop", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 33, "endLine": 11, "endColumn": 49, "data": "type mismatch\n  tc_2 0 ?m.1276\nhas type\n  X 0 = c * (\u21910 + 1) : Prop\nbut is expected to have type\n  X 0 = c * (0 + 1) : Prop"}, {"line": 12, "column": 33, "endLine": 12, "endColumn": 49, "data": "type mismatch\n  tc_2 1 ?m.2309\nhas type\n  X 1 = c * (\u21911 + 1) : Prop\nbut is expected to have type\n  X 1 = c * (1 + 1) : Prop"}, {"line": 10, "column": 49, "endLine": 15, "endColumn": 15, "data": "unsolved goals\nX : \u2115 \u2192 \u211d\ndef_1 : X 0 + (X 0 * (1 + 1) + X 0 * (2 + 1)) = 1\nh1 : X 1 = X 0 * (1 + 1)\nh2 : X 2 = X 0 * (2 + 1)\n\u22a2 X 0 + X 0 * (1 + 1) + X 0 * (2 + 1) = 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The PMF definition interprets c(k+1) as multiplication c*(k+1) rather than function application, but this is a reasonable interpretation in probability contexts", "The normalization condition is correctly formalized as a sum over the support set equaling 1", "The conclusion consistently uses multiplication interpretation, maintaining internal consistency with the PMF definition", "The logical structure correctly captures the derivation from premises to conclusion", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The PMF definition interprets c(k+1) as multiplication c*(k+1) rather than function application, but this is a reasonable interpretation in probability contexts', 'The normalization condition is correctly formalized as a sum over the support set equaling 1', 'The conclusion consistently uses multiplication interpretation, maintaining internal consistency with the PMF definition', 'The logical structure correctly captures the derivation from premises to conclusion']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "which results in $c=1/6$.", "statement": "We assume:\n\u2022 $c(0+1) + c(1+1) + c(2+1) = 1$ [l1].\nTherefore, we conclude:\n\u2022 c = 1/6 [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (c : \u211d)\n  (l1 : c * (0 + 1) + c * (1 + 1) + c * (2 + 1) = 1) :\n  c = 1 / 6 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (c : \u211d)\n  (l1 : c * (0 + 1) + c * (1 + 1) + c * (2 + 1) = 1) :\n  c = 1 / 6 := by\n  simp at l1\n  have h : c * (1 + 2 + 3) = 1 := by linarith\n  have h' : c * 6 = 1 := by linarith\n  rw [\u2190 mul_inv_eq_iff_eq_mul\u2080 (by norm_num : (6:\u211d) \u2260 0)] at h'\n  simp at h'\n  exact h'", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 6, "endLine": 12, "endColumn": 56, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.2473 = ?m.2475 * 6\nc : \u211d\nl1 : c + c * (1 + 1) + c * (2 + 1) = 1\nh : c * (1 + 2 + 3) = 1\nh' : c * 6 = 1\n\u22a2 c = 1 / 6"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the logical structure and mathematical relationships, but there is a minor notational interpretation difference. The natural language uses c(0+1) which could be interpreted as either function application or multiplication, while the Lean code explicitly uses multiplication (c * (0+1)). Given the mathematical context and the fact that the conclusion c = 1/6 is correct under the multiplication interpretation, this represents a reasonable but not perfectly direct translation of the notation.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the logical structure and mathematical relationships, but there is a minor notational interpretation difference. The natural language uses c(0+1) which could be interpreted as either function application or multiplication, while the Lean code explicitly uses multiplication (c * (0+1)). Given the mathematical context and the fact that the conclusion c = 1/6 is correct under the multiplication interpretation, this represents a reasonable but not perfectly direct translation of the notation.']"}, "solved_negation": null, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "we calculate the expected value of $X$, defined as $E[X] = \\sum_{k \\in S} k \\cdot P(X=k)$.", "statement": "We assume:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].\nDefinition:\n\u2022 The expected value of X is $E[X] = \\sum_{k \\in S} k \\cdot P(X=k)$ [def_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (S : Finset \u2115)\n  (X : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (tc_1 : S = ({0, 1, 2} : Finset \u2115))\n  (def_2 : \u2211 k in S, k * P k = X 0) -- X 0 is a placeholder for E[X]", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states 'X is a discrete random variable with sample space S = {0, 1, 2}', but the Lean formalization defines X as 'X : \u2115 \u2192 \u211d' (a function from naturals to reals) and S separately as a finite set. The Lean version doesn't capture that X is a random variable with S as its sample space - instead it treats X and S as independent objects. A random variable should map from some probability space to the sample space, not be an arbitrary function from naturals to reals.", "The natural language defines the expected value as 'E[X] = \u2211_{k \u2208 S} k \u00b7 P(X=k)', but the Lean formalization uses 'def_2 : \u2211 k in S, k * P k = X 0'. The Lean version treats P as an arbitrary function P : \u2115 \u2192 \u211d rather than a probability mass function P(X=k), and uses 'X 0' as a placeholder for E[X] rather than properly defining the expected value. The mathematical meaning is fundamentally different - P should represent P(X=k) not just any function P(k)."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states 'X is a discrete random variable with sample space S = {0, 1, 2}', but the Lean formalization defines X as 'X : \u2115 \u2192 \u211d' (a function from naturals to reals) and S separately as a finite set. The Lean version doesn't capture that X is a random variable with S as its sample space - instead it treats X and S as independent objects. A random variable should map from some probability space to the sample space, not be an arbitrary function from naturals to reals.\", \"The natural language defines the expected value as 'E[X] = \u2211_{k \u2208 S} k \u00b7 P(X=k)', but the Lean formalization uses 'def_2 : \u2211 k in S, k * P k = X 0'. The Lean version treats P as an arbitrary function P : \u2115 \u2192 \u211d rather than a probability mass function P(X=k), and uses 'X 0' as a placeholder for E[X] rather than properly defining the expected value. The mathematical meaning is fundamentally different - P should represent P(X=k) not just any function P(k).\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Using the now known probabilities, we compute $E[X] = 0(1/6) + 1(2/6) + 2(3/6) = 4/3$.", "statement": "We assume:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].\n\u2022 The PMF of X is P(X=k) = c(k+1) [tc_2].\n\u2022 c = 1/6 [l2].\n\u2022 The expected value of X is $E[X] = \\sum_{k \\in S} k \\cdot P(X=k)$ [def_2].\nTherefore, we conclude:\n\u2022 E[X] = 4/3 [l3].", "dependencies": ["tc_1", "tc_2", "l2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (c : \u211d)\n  (S : Finset \u2115)\n  (X : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (tc_1 : S = ({0, 1, 2} : Finset \u2115))\n  (tc_2 : \u2200 k \u2208 S, P k = c * (k + 1))\n  (l2 : c = 1 / 6)\n  (def_2 : \u2211 k in S, (k : \u211d) * P k = X 0) :\n  X 0 = 4 / 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (c : \u211d)\n  (S : Finset \u2115)\n  (X : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (tc_1 : S = ({0, 1, 2} : Finset \u2115))\n  (tc_2 : \u2200 k \u2208 S, P k = c * (k + 1))\n  (l2 : c = 1 / 6)\n  (def_2 : \u2211 k in S, (k : \u211d) * P k = X 0) :\n  X 0 = 4 / 3 := by\n  rw [def_2]\n  simp [tc_1]\n  rw [Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton]\n  simp\n  rw [tc_2 0, tc_2 1, tc_2 2] <;> simp\n  rw [l2]\n  norm_num", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 6, "endLine": 15, "endColumn": 11, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2211 k \u2208 S, \u2191k * P k\nc : \u211d\nS : Finset \u2115\nX P : \u2115 \u2192 \u211d\ntc_1 : S = {0, 1, 2}\ntc_2 : \u2200 k \u2208 S, P k = c * (\u2191k + 1)\nl2 : c = 1 / 6\ndef_2 : \u2211 k \u2208 S, \u2191k * P k = X 0\n\u22a2 X 0 = 4 / 3"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Sample space definition S = {0, 1, 2} is correctly captured", "PMF definition P(X=k) = c(k+1) is correctly formalized with explicit multiplication", "Parameter c = 1/6 is perfectly matched", "Expected value definition has major inconsistency: E[X] should be a single real number, but Lean treats it as X 0 where X is a function \u2115 \u2192 \u211d, creating conceptual confusion about what X represents", "Conclusion E[X] = 4/3 follows the same problematic pattern as the definition, maintaining the conceptual mismatch where expected value is represented as X 0 rather than a direct real number", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Sample space definition S = {0, 1, 2} is correctly captured', 'PMF definition P(X=k) = c(k+1) is correctly formalized with explicit multiplication', 'Parameter c = 1/6 is perfectly matched', 'Expected value definition has major inconsistency: E[X] should be a single real number, but Lean treats it as X 0 where X is a function \u2115 \u2192 \u211d, creating conceptual confusion about what X represents', 'Conclusion E[X] = 4/3 follows the same problematic pattern as the definition, maintaining the conceptual mismatch where expected value is represented as X 0 rather than a direct real number']"}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "Then, we calculate the expected value of $X^2$, defined as $E[X^2] = \\sum_{k \\in S} k^2 \\cdot P(X=k)$.", "statement": "We assume:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].\nDefinition:\n\u2022 The expected value of X^2 is $E[X^2] = \\sum_{k \\in S} k^2 \\cdot P(X=k)$ [def_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (P : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))\n  (def_3 : \u2211 k in tc_1.toFinset, (k : \u211d)^2 * P k = ENNReal.ofReal (\u2211 k in tc_1.toFinset, (k : \u211d)^2 * P k) )", "lean_pass": false, "error_msg": [{"line": 8, "column": 18, "endLine": 8, "endColumn": 31, "data": "invalid field 'toFinset', the environment does not contain 'Set.Elem.toFinset'\n  tc_1\nhas type\n  \u2191{0, 1, 2}"}, {"line": 8, "column": 18, "endLine": 8, "endColumn": 31, "data": "invalid field 'toFinset', the environment does not contain 'Subtype.toFinset'\n  tc_1\nhas type\n  { x // x \u2208 {0, 1, 2} }"}, {"line": 8, "column": 47, "endLine": 8, "endColumn": 48, "data": "application type mismatch\n  P k\nargument\n  k\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}, {"line": 8, "column": 74, "endLine": 8, "endColumn": 87, "data": "invalid field 'toFinset', the environment does not contain 'Set.Elem.toFinset'\n  tc_1\nhas type\n  \u2191{0, 1, 2}"}, {"line": 8, "column": 74, "endLine": 8, "endColumn": 87, "data": "invalid field 'toFinset', the environment does not contain 'Subtype.toFinset'\n  tc_1\nhas type\n  { x // x \u2208 {0, 1, 2} }"}, {"line": 8, "column": 103, "endLine": 8, "endColumn": 104, "data": "application type mismatch\n  P k\nargument\n  k\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "This gives $E[X^2] = 0^2(1/6) + 1^2(2/6) + 2^2(3/6) = 7/3$.", "statement": "We assume:\n\u2022 X is a discrete random variable with a sample space S = {0, 1, 2} [tc_1].\n\u2022 The PMF of X is P(X=k) = c(k+1) [tc_2].\n\u2022 c = 1/6 [l2].\n\u2022 The expected value of X^2 is $E[X^2] = \\sum_{k \\in S} k^2 \\cdot P(X=k)$ [def_3].\nTherefore, we conclude:\n\u2022 E[X^2] = 7/3 [l4].", "dependencies": ["tc_1", "tc_2", "l2", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (X : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))\n  (c : \u211d)\n  (tc_2 : \u2200 (k : \u2115), k \u2208 ({0, 1, 2} : Set \u2115) \u2192 X k = c * (k + 1))\n  (l2 : c = 1 / 6)\n  (E_X_sq : \u211d)\n  (def_3 : E_X_sq = \u2211 k in ({0, 1, 2} : Finset \u2115), (k : \u211d)^2 * X k) :\n  E_X_sq = 7 / 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (X : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))\n  (c : \u211d)\n  (tc_2 : \u2200 (k : \u2115), k \u2208 ({0, 1, 2} : Set \u2115) \u2192 X k = c * (k + 1))\n  (l2 : c = 1 / 6)\n  (E_X_sq : \u211d)\n  (def_3 : E_X_sq = \u2211 k in ({0, 1, 2} : Finset \u2115), (k : \u211d)^2 * X k) :\n  E_X_sq = 7 / 3 := by\n  rw [def_3]\n  have h0 : X 0 = c * (0 + 1) := tc_2 0 (by simp)\n  have h1 : X 1 = c * (1 + 1) := tc_2 1 (by simp)\n  have h2 : X 2 = c * (2 + 1) := tc_2 2 (by simp)\n  rw [h0, h1, h2]\n  rw [l2]\n  simp\n  norm_num", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 33, "endLine": 15, "endColumn": 49, "data": "type mismatch\n  tc_2 0 ?m.1577\nhas type\n  X 0 = c * (\u21910 + 1) : Prop\nbut is expected to have type\n  X 0 = c * (0 + 1) : Prop"}, {"line": 16, "column": 33, "endLine": 16, "endColumn": 49, "data": "type mismatch\n  tc_2 1 ?m.2610\nhas type\n  X 1 = c * (\u21911 + 1) : Prop\nbut is expected to have type\n  X 1 = c * (1 + 1) : Prop"}, {"line": 18, "column": 6, "endLine": 18, "endColumn": 8, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  X 0\nX : \u2115 \u2192 \u211d\ntc_1 : \u2191{0, 1, 2}\nc : \u211d\ntc_2 : \u2200 k \u2208 {0, 1, 2}, X k = c * (\u2191k + 1)\nl2 : c = 1 / 6\nE_X_sq : \u211d\ndef_3 : E_X_sq = \u2211 k \u2208 {0, 1, 2}, \u2191k ^ 2 * X k\nh0 : X 0 = c * (0 + 1)\nh1 : X 1 = c * (1 + 1)\nh2 : X 2 = c * (2 + 1)\n\u22a2 \u2211 k \u2208 {0, 1, 2}, \u2191k ^ 2 * X k = 7 / 3"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sample space and random variable representation are correctly formalized. X as a function \u2115 \u2192 \u211d appropriately represents a discrete random variable.", "The PMF condition is correctly captured with the universal quantification over the sample space elements.", "The constant c = 1/6 is exactly represented.", "The expected value definition is properly formalized using Lean's sum notation over the finite set, with the correct formula structure.", "The conclusion E[X^2] = 7/3 is exactly represented as the goal to be proven.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l4\n  (X : \u2115 \u2192 \u211d)\n  (tc_1 : ({0, 1, 2} : Set \u2115))\n  (c : \u211d)\n  (tc_2 : \u2200 (k : \u2115), k \u2208 ({0, 1, 2} : Set \u2115) \u2192 X k = c * (k + 1))\n  (l2 : c = 1 / 6)\n  (E_X_sq : \u211d)\n  (def_3 : E_X_sq = \u2211 k in ({0, 1, 2} : Finset \u2115), (k : \u211d)^2 * X k) :\n  \u00ac E_X_sq = 7 / 3 := by\n  rw [def_3]\n  simp [tc_2, l2]\n  have h0 : (0 : \u211d) \u2208 ({0, 1, 2} : Finset \u2115) := by simp\n  have h1 : (1 : \u211d) \u2208 ({0, 1, 2} : Finset \u2115) := by simp\n  have h2 : (2 : \u211d) \u2208 ({0, 1, 2} : Finset \u2115) := by simp\n  simp [h0, h1, h2]\n  norm_num"}, "type": "lemma"}, "def_4": {"id": "def_4", "natural_language": "Finally, the variance is found using the formula $Var(X) = E[X^2] - (E[X])^2$.", "statement": "Definition:\n\u2022 The variance of X is given by the formula $Var(X) = E[X^2] - (E[X])^2$ [def_4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {\u03a9 : Type*}\n  [MeasureSpace \u03a9]\n  {X : \u03a9 \u2192 \u211d}\n  [IsRandomVariable X]\n  (def_4 : variance X = expectedValue (fun \u03c9 => (X \u03c9 - expectedValue X)^2))", "lean_pass": false, "error_msg": [{"line": 7, "column": 3, "endLine": 7, "endColumn": 17, "data": "invalid binder annotation, type is not a class instance\n  ?m.12\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting our computed expected values, we get $Var(X) = 7/3 - (4/3)^2 = 5/9$.", "statement": "We assume:\n\u2022 E[X] = 4/3 [l3].\n\u2022 E[X^2] = 7/3 [l4].\n\u2022 The variance of X is given by the formula $Var(X) = E[X^2] - (E[X])^2$ [def_4].\nTherefore, we conclude:\n\u2022 Var(X) = 5/9 [ts_1].", "dependencies": ["l3", "l4", "def_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (EX EX_sq VarX : \u211d)\n  (l3 : EX = 4 / 3)\n  (l4 : EX_sq = 7 / 3)\n  (def_4 : VarX = EX_sq - EX^2) :\n  VarX = 5 / 9 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (EX EX_sq VarX : \u211d)\n  (l3 : EX = 4 / 3)\n  (l4 : EX_sq = 7 / 3)\n  (def_4 : VarX = EX_sq - EX^2) :\n  VarX = 5 / 9 := by\n  rw [def_4, l4, l3]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical logic and relationships from the natural language. The only difference is in variable naming conventions (EX vs E[X], EX_sq vs E[X\u00b2], VarX vs Var(X)), which represents a minor notational difference but preserves all semantic meaning. All assumptions, the variance formula, and the conclusion are properly formalized."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures all the mathematical logic and relationships from the natural language. The only difference is in variable naming conventions (EX vs E[X], EX_sq vs E[X\u00b2], VarX vs Var(X)), which represents a minor notational difference but preserves all semantic meaning. All assumptions, the variance formula, and the conclusion are properly formalized.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_4", "label": "def_4", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    