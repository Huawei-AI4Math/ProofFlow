
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Suppose that $g$ is continuous at $x_0,$ $g(x_0)$ is an interior point
of $D_f,$ and $f$ is continuous at $g(x_0).$ Then
 $f\circ g$ is continuous at $x_0.$

Proof: Suppose that $\epsilon>0$.  Since $g(x_0)$ is an interior
point of $D_f$ and  $f$ is continuous at $g(x_0)$, there is a
$\delta_1>0$ such that $f(t)$ is defined and
\begin{equation}\label{eq:2.2.4}
|f(t)-f(g(x_0))|<\epsilon\mbox{\quad if \quad} |t-g(x_0)|<
\delta_1.
\end{equation}
Since $g$ is continuous at $x_0$, there is a $\delta>0$ such that
$g(x)$ is defined and
\begin{equation}\label{eq:2.2.5}
|g(x)-g(x_0)|<\delta_1\mbox{\quad if \quad}|x-x_0|<\delta.
\end{equation}
Now \eqref{eq:2.2.4} and \eqref{eq:2.2.5} imply that
$$
|f(g(x))-f(g(x_0))|<\epsilon\mbox{\quad if \quad}|x-x_0|<\delta.
$$
 Therefore, $f\circ g$ is continuous at $x_0$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "g is continuous at x_0", "statement": "Premise:\n\u2022 Let $g: X \\to Y$ be a function between metric spaces, and let $x_0 \\in X$. $g$ is continuous at $x_0$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {X Y : Type*} [MetricSpace X] [MetricSpace Y]\n  (g : X \u2192 Y) (x0 : X)\n  (tc_1 : ContinuousAt g x0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that g is a function from X to Y where both X and Y are metric spaces through the type declarations and MetricSpace instances", "The Lean formalization correctly declares x0 as an element of X, matching the natural language condition", "The Lean formalization correctly captures the continuity of g at x0 using ContinuousAt g x0, which is the standard way to express pointwise continuity in Lean"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "g(x_0) is an interior point of D_f", "statement": "Premise:\n\u2022 Let $f: Y \\to Z$ be a function between metric spaces with domain $D_f \\subseteq Y$. The point $g(x_0)$ is an interior point of $D_f$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {Y Z : Type*} [MetricSpace Y] [MetricSpace Z] (f : Y \u2192 Z) (Df : Set Y)\n  (g : X \u2192 Y) [MetricSpace X] (x0 : X)\n(tc_2 : interior Df (g x0))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly declares f as a function from Y to Z where both Y and Z are metric spaces, matching the natural language exactly.", "The Lean declares Df as a set in Y, which captures the subset relationship D_f \u2286 Y. However, the natural language explicitly states this is the 'domain of f', but the Lean formalization doesn't establish this connection between f and Df - they are declared as separate entities. The mathematical meaning is preserved but the explicit domain relationship is not formalized.", "The Lean formalization correctly captures that g(x0) is an interior point of Df using 'interior Df (g x0)'. The Lean also introduces additional structure by declaring g as a function from metric space X to Y and x0 as an element of X, which provides extra context not contradicting the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "f is continuous at g(x_0)", "statement": "Premise:\n\u2022 Let $f: Y \\to Z$ be a function between metric spaces. $f$ is continuous at the point $g(x_0) \\in D_f$ [tc_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {Y Z : Type*} [MetricSpace Y] [MetricSpace Z] (f : Y \u2192 Z) (g : \u211d \u2192 Y) (x\u2080 : \u211d)\n(tc_3 : ContinuousAt f (g x\u2080))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the function f between metric spaces Y and Z as stated in the natural language.", "The Lean formalization correctly captures the continuity of f at point g(x\u2080). The additional declarations of g and x\u2080 provide necessary context that was implicit in the natural language, and the domain condition g(x\u2080) \u2208 D_f is automatically satisfied by the type system."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since g(x_0) is an interior point of D_f and f is continuous at g(x_0), there is a \u03b4_1>0 such that f(t) is defined and |f(t)-f(g(x_0))|<\u03b5 if |t-g(x_0)|< \u03b4_1.", "statement": "We assume:\n\u2022 $f$ is a function from a metric space $Y$ to a metric space $Z$ with domain $D_f \\subseteq Y$, and $g(x_0)$ is an interior point of $D_f$ [tc_2].\n\u2022 $f$ is continuous at $g(x_0)$ [tc_3].\nTherefore, we conclude:\n\u2022 For any $\\epsilon > 0$, there exists a $\\delta_1 > 0$ such that for any point $t \\in Y$, if $|t - g(x_0)| < \\delta_1$, then $t \\in D_f$ and $|f(t) - f(g(x_0))| < \\epsilon$ [l1].", "dependencies": ["tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]\n  (f : Y \u2192 Z) (Df : Set Y) (g : X \u2192 Y) (x0 : X)\n  (tc_2 : interior Df (g x0))\n  (tc_3 : ContinuousAt f (g x0)) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]\n  (f : Y \u2192 Z) (Df : Set Y) (g : X \u2192 Y) (x0 : X)\n  (tc_2 : interior Df (g x0))\n  (tc_3 : ContinuousAt f (g x0)) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5 := by\n  intro \u03b5 h\u03b5\n  obtain \u27e8\u03b4\u2081, h\u03b4\u2081, h\u2081\u27e9 := Metric.continuousAt_iff.mp tc_3 \u03b5 h\u03b5\n  obtain \u27e8\u03b4\u2082, h\u03b4\u2082, h\u2082\u27e9 := Metric.mem_interior_iff.mp tc_2\n  refine \u27e8min \u03b4\u2081 \u03b4\u2082, lt_min h\u03b4\u2081 h\u03b4\u2082, fun t ht => ?_\u27e9\n  have h : dist t (g x0) < \u03b4\u2082 := by\n    apply lt_of_lt_of_le ht (min_le_right \u03b4\u2081 \u03b4\u2082)\n  exact \u27e8h\u2082 t h, h\u2081 t (lt_of_lt_of_le ht (min_le_left \u03b4\u2081 \u03b4\u2082))\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 26, "endLine": 13, "endColumn": 52, "data": "unknown identifier 'Metric.mem_interior_iff.mp'"}, {"line": 13, "column": 9, "endLine": 13, "endColumn": 22, "data": "rcases tactic failed: x\u271d : ?m.4002 is not an inductive datatype"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The main issue is the treatment of function domain. The natural language describes f as a function with domain D_f \u2286 Y, implying f is only defined on D_f. However, the Lean formalization declares f as a total function Y \u2192 Z, which means f is defined on all of Y. This creates a semantic mismatch because the conclusion states that when dist t (g x0) < \u03b4\u2081, then t \u2208 Df AND dist (f t) (f (g x0)) < \u03b5. If f were truly a total function, the membership condition t \u2208 Df would be unnecessary for f(t) to be well-defined. The formalization should either use a partial function or restrict f's type to Df.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The main issue is the treatment of function domain. The natural language describes f as a function with domain D_f \u2286 Y, implying f is only defined on D_f. However, the Lean formalization declares f as a total function Y \u2192 Z, which means f is defined on all of Y. This creates a semantic mismatch because the conclusion states that when dist t (g x0) < \u03b4\u2081, then t \u2208 Df AND dist (f t) (f (g x0)) < \u03b5. If f were truly a total function, the membership condition t \u2208 Df would be unnecessary for f(t) to be well-defined. The formalization should either use a partial function or restrict f's type to Df.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since g is continuous at x_0, there is a \u03b4>0 such that g(x) is defined and |g(x)-g(x_0)|<\u03b4_1 if |x-x_0|<\u03b4.", "statement": "We assume:\n\u2022 $g$ is a function from a metric space $X$ to a metric space $Y$, and is continuous at $x_0 \\in X$ [tc_1].\n\u2022 For any $\\epsilon > 0$, there exists a $\\delta_1 > 0$ such that for any point $t \\in Y$ with $|t - g(x_0)| < \\delta_1$, we have $t \\in D_f$ and $|f(t) - f(g(x_0))| < \\epsilon$ [l1].\nTherefore, we conclude:\n\u2022 For a given $\\epsilon > 0$ and its corresponding $\\delta_1 > 0$ from [l1], there exists a $\\delta > 0$ such that for any point $x \\in X$, if $|x - x_0| < \\delta$, then $g(x)$ is defined and $|g(x) - g(x_0)| < \\delta_1$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X Y : Type*} [MetricSpace X] [MetricSpace Y]\n  (g : X \u2192 Y) (x0 : X)\n  (tc_1 : ContinuousAt g x0)\n  {Z : Type*} [MetricSpace Z] (f : Y \u2192 Z) (Df : Set Y)\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : X, dist x x0 < \u03b4 \u2192 dist (g x) (g x0) < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X Y : Type*} [MetricSpace X] [MetricSpace Y]\n  (g : X \u2192 Y) (x0 : X)\n  (tc_1 : ContinuousAt g x0)\n  {Z : Type*} [MetricSpace Z] (f : Y \u2192 Z) (Df : Set Y)\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : X, dist x x0 < \u03b4 \u2192 dist (g x) (g x0) < \u03b5 := by\n  intro \u03b5 h\u03b5\n  obtain \u27e8\u03b4, h\u03b4, h\u27e9 := MetricSpace.continuousAt_iff.1 tc_1 \u03b5 h\u03b5\n  exact \u27e8\u03b4, h\u03b4, h\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 23, "endLine": 13, "endColumn": 63, "data": "unknown constant 'MetricSpace.continuousAt_iff'"}, {"line": 13, "column": 9, "endLine": 13, "endColumn": 19, "data": "rcases tactic failed: x\u271d : ?m.4970 is not an inductive datatype"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function g, metric spaces X and Y, point x0, and continuity condition tc_1 are correctly formalized.", "Condition l1 about function f is accurately captured with proper quantifier structure and logical connectives.", "The conclusion l2 has a discrepancy: natural language mentions \u03b4\u2081 in the conclusion while Lean uses \u03b5. However, the Lean version correctly represents the mathematical concept of continuity.", "Additional declarations in Lean (metric space Z, function f, set Df) are necessary supporting elements that don't contradict the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.75 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  {X Y : Type*} [MetricSpace X] [MetricSpace Y]\n  (g : X \u2192 Y) (x0 : X)\n  (tc_1 : ContinuousAt g x0)\n  {Z : Type*} [MetricSpace Z] (f : Y \u2192 Z) (Df : Set Y)\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5) :\n  \u00ac (\u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : X, dist x x0 < \u03b4 \u2192 dist (g x) (g x0) < \u03b5) := by\n  simp only [not_forall, not_lt]\n  use 1, zero_lt_one\n  intro h\n  simp only [not_exists, not_forall, not_lt] at h\n  obtain \u27e8\u03b4, h\u03b4, h\u27e9 := h\n  sorry"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Now \\eqref{eq:2.2.4} and \\eqref{eq:2.2.5} imply that\n$$\n|f(g(x))-f(g(x_0))|<\\epsilon\\mbox{\\quad if \\quad}|x-x_0|<\\delta.\n$$\n Therefore, $f\\circ g$ is continuous at $x_0$.", "statement": "We assume:\n\u2022 For any $\\epsilon > 0$, there exists a $\\delta_1 > 0$ such that for any point $t \\in Y$, if $|t - g(x_0)| < \\delta_1$, then $t$ is in the domain of $f$ and $|f(t) - f(g(x_0))| < \\epsilon$ [l1].\n\u2022 For a given $\\epsilon > 0$ and its corresponding $\\delta_1 > 0$, there exists a $\\delta > 0$ such that for any point $x \\in X$, if $|x - x_0| < \\delta$, then $|g(x) - g(x_0)| < \\delta_1$ [l2].\nTherefore, we conclude:\n\u2022 The composite function $f \\circ g$ is continuous at $x_0$ [ts_1].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]\n  (f : Y \u2192 Z) (Df : Set Y) (g : X \u2192 Y) (x0 : X)\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5)\n  (l2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : X, dist x x0 < \u03b4 \u2192 dist (g x) (g x0) < \u03b5) :\n  ContinuousAt (f \u2218 g) x0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]\n  (f : Y \u2192 Z) (Df : Set Y) (g : X \u2192 Y) (x0 : X)\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5)\n  (l2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : X, dist x x0 < \u03b4 \u2192 dist (g x) (g x0) < \u03b5) :\n  ContinuousAt (f \u2218 g) x0 := by\n  rw [continuousAt_iff]\n  intro \u03b5 h\u03b5\n  obtain \u27e8\u03b4\u2081, h\u03b4\u2081, h\u2081\u27e9 := l1 \u03b5 h\u03b5\n  obtain \u27e8\u03b4, h\u03b4, h\u2082\u27e9 := l2 \u03b4\u2081 h\u03b4\u2081\n  use \u03b4, h\u03b4\n  intro x hx\n  exact (h\u2081 (g x) (h\u2082 x hx)).2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 6, "endLine": 11, "endColumn": 22, "data": "unknown identifier 'continuousAt_iff'"}, {"line": 11, "column": 6, "endLine": 11, "endColumn": 22, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.4989\nX : Type u_1\nY : Type u_2\nZ : Type u_3\ninst\u271d\u00b2 : MetricSpace X\ninst\u271d\u00b9 : MetricSpace Y\ninst\u271d : MetricSpace Z\nf : Y \u2192 Z\nDf : Set Y\ng : X \u2192 Y\nx0 : X\nl1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 (t : Y), Dist.dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 Dist.dist (f t) (f (g x0)) < \u03b5\nl2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 (x : X), Dist.dist x x0 < \u03b4 \u2192 Dist.dist (g x) (g x0) < \u03b5\n\u22a2 ContinuousAt (f \u2218 g) x0"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Function types and metric space structure correctly formalized with appropriate domain handling", "First assumption (l1) perfectly captures the epsilon-delta condition with domain membership requirement", "Second assumption (l2) correctly formalizes continuity of g, with proper variable usage that enables the chain rule proof", "Conclusion correctly states continuity of the composite function using standard Lean notation", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  {X Y Z : Type*} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]\n  (f : Y \u2192 Z) (Df : Set Y) (g : X \u2192 Y) (x0 : X)\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : Y, dist t (g x0) < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) (f (g x0)) < \u03b5)\n  (l2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : X, dist x x0 < \u03b4 \u2192 dist (g x) (g x0) < \u03b5) :\n  \u00acContinuousAt (f \u2218 g) x0 := by\n  let f : \u211d \u2192 \u211d := fun y => if y = 0 then 0 else 1\n  let Df : Set \u211d := {0}\n  let g : \u211d \u2192 \u211d := fun x => x\n  let x0 : \u211d := 0\n  have l1 : \u2200 \u03b5 > 0, \u2203 \u03b4\u2081 > 0, \u2200 t : \u211d, dist t 0 < \u03b4\u2081 \u2192 t \u2208 Df \u2227 dist (f t) 0 < \u03b5 := by\n    intro \u03b5 h\u03b5\n    use 1, zero_lt_one\n    intro t ht\n    simp [dist] at ht\n    simp [Df, f, ht.le]\n  have l2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x : \u211d, dist x 0 < \u03b4 \u2192 dist x 0 < \u03b5 := by\n    intro \u03b5 h\u03b5\n    use \u03b5, h\u03b5\n    intro x hx\n    exact hx\n  simp [ContinuousAt]\n  push_neg\n  use 1, zero_lt_one\n  intro \u03b4 h\u03b4\n  use \u03b4 / 2\n  constructor\n  \u00b7 simp [dist]\n    rw [abs_of_pos (half_pos h\u03b4)]\n    exact half_lt_self h\u03b4\n  \u00b7 simp [f, dist]\n    split_ifs\n    \u00b7 norm_num\n    \u00b7 norm_num"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    