
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}$ and $\mathbf{Y}$ are in $\R^n,$ then
\begin{equation}\label{eq:5.1.6}
|\mathbf{X}+\mathbf{Y}|\le |\mathbf{X}|+|\mathbf{Y}|,
\end{equation}
with equality if and only if one of the vectors is a nonnegative
multiple of the other$.$

We can assume the following statement(s) without a proof. 

If $\mathbf{X}$ and $\mathbf{Y}$ are any two vectors in $\R^n,$ then
\begin{equation} \label{eq:5.1.3}
|\mathbf{X}\cdot\mathbf{Y}|\le |\mathbf{X}|\,|\mathbf{Y}|,
\end{equation}
with equality  if and only if one of the vectors is a scalar
multiple of the other$.$

Proof: By definition,
\begin{equation} \label{eq:5.1.7}
\begin{array}{rcl}
|\mathbf{X}+\mathbf{Y}|^2\ar=\dst\sum^n_{i=1} (x_i+y_i)^2=\sum^n_{i=1} x^2_i+
2\sum^n_{i=1} x_iy_i+\sum^n_{i=1}y^2_i\\[4\jot]
\ar=|\mathbf{X}|^2+2(\mathbf{X}\cdot\mathbf{Y})+|\mathbf{Y}|^2\\[2\jot]
\ar\le  |\mathbf{X}|^2+2|\mathbf{X}|\,|\mathbf{Y}|+|\mathbf{Y}|^2\mbox{\quad (by
Schwarz's inequality)}\\[2\jot]
\ar=(|\mathbf{X}|+|\mathbf{Y}|)^2.
\end{array}
\end{equation}
Hence,
$$
|\mathbf{X}+\mathbf{Y}|^2\le (|\mathbf{X}|+|\mathbf{Y}|)^2.
$$
Taking square roots yields \eqref{eq:5.1.6}.
From the third line of \eqref{eq:5.1.7},
equality holds in \eqref{eq:5.1.6} if and
only  if $\mathbf{X}\cdot\mathbf{Y}=|\mathbf{X}||\mathbf{Y}|$, which is true if
and
only if one of the vectors $\mathbf{X}$ and $\mathbf{Y}$ is a nonnegative
scalar multiple of the other (Lemma~\ref{thmtype:5.1.5}).
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X}$ and $\\mathbf{Y}$ are in $\\R^n,$", "statement": "Premise:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X Y : Fin n \u2192 \u211d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `(X : Fin n \u2192 \u211d)` correctly represents a vector in \u211d\u207f using the standard Lean representation of vectors as functions from finite types to reals", "The Lean formalization `(Y : Fin n \u2192 \u211d)` correctly represents a vector in \u211d\u207f using the standard Lean representation of vectors as functions from finite types to reals"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $\\mathbf{X}$ and $\\mathbf{Y}$ are any two vectors in $\\R^n,$ then\n\\begin{equation} \\label{eq:5.1.3}\n|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|,\n\\end{equation}\nwith equality  if and only if one of the vectors is a scalar\nmultiple of the other$.$", "statement": "Premise:\n\u2022 For any vectors $\\mathbf{X}, \\mathbf{Y}$ in $\\mathbb{R}^n$, the Schwarz inequality holds: $|\\mathbf{X} \\cdot \\mathbf{Y}| \\le |\\mathbf{X}| |\\mathbf{Y}|$, with equality if and only if one of the vectors is a scalar multiple of the other [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X Y : Fin n \u2192 \u211d)\n(tc_2 : |(inner X Y)| \u2264 |X| * |Y| \u2227 (|(inner X Y)| = |X| * |Y| \u2194 (\u2203 (c : \u211d), Y = c \u2022 X \u2228 X = c \u2022 Y)))", "lean_pass": false, "error_msg": [{"line": 6, "column": 10, "endLine": 6, "endColumn": 19, "data": "failed to synthesize\n  Inner (Fin n \u2192 \u211d) (Fin n \u2192 \u211d)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 6, "column": 39, "endLine": 6, "endColumn": 48, "data": "failed to synthesize\n  Inner (Fin n \u2192 \u211d) (Fin n \u2192 \u211d)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "By definition,", "statement": "Definition:\n\u2022 For a vector $\\mathbf{V} \\in \\mathbb{R}^n$ with components $v_i$, its Euclidean norm is defined by $|\\mathbf{V}|^2 = \\sum_{i=1}^n v_i^2$. The dot product of vectors $\\mathbf{U}$ and $\\mathbf{V}$ is $\\mathbf{U} \\cdot \\mathbf{V} = \\sum_{i=1}^n u_i v_i$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (V U X Y : \u211d\u207f)\n  (v u x y : (Fin n) \u2192 \u211d)\n  (def_1 : \u2016V\u2016^2 = \u2211 i : Fin n, (v i)^2 \u2227 V \u2b1d U = \u2211 i : Fin n, (v i) * (u i))", "lean_pass": false, "error_msg": [{"line": 7, "column": 14, "endLine": 7, "endColumn": 15, "data": "unexpected token '\u207f'; expected ')'"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "|\\mathbf{X}+\\mathbf{Y}|^2\\ar=\\dst\\sum^n_{i=1} (x_i+y_i)^2=\\sum^n_{i=1} x^2_i+\n2\\sum^n_{i=1} x_iy_i+\\sum^n_{i=1}y^2_i\\[4\\jot]\n\\ar=|\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1]\n\u2022 The definitions of vector norm and dot product [def_1]\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d) :\n  (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d) :\n  (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2) := by\n  simp only [add_pow_two]\n  rw [Finset.sum_add_distrib]\n  simp only [mul_assoc, mul_comm, mul_left_comm]\n  rw [\u2190Finset.sum_add_distrib]\n  simp only [mul_assoc, mul_comm, mul_left_comm]\n  rw [\u2190Finset.sum_add_distrib]\n  simp only [mul_assoc, mul_comm, mul_left_comm]\n  rw [\u2190Finset.sum_mul]\n  simp only [mul_assoc, mul_comm, mul_left_comm]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 2, "endLine": 12, "endColumn": 48, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language statement. The vector representation using Fin n \u2192 \u211d is standard for finite-dimensional real vectors, and the explicit sum notation for norms and dot products represents the standard definitions of these operations. The equation structure and mathematical meaning are preserved exactly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem not_l1 :\n    \u00ac \u2200 {n : \u2115} (X Y : Fin n \u2192 \u211d),\n    (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2) := by\n  intro h\n  let X : Fin 1 \u2192 \u211d := fun _ => 1\n  let Y : Fin 1 \u2192 \u211d := fun _ => 2\n  have := h X Y\n  simp at this\n  norm_num at this\n  linarith"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "\\ar\\le  |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2\\mbox{\\quad (by\nSchwarz's inequality)}", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1]\n\u2022 The Schwarz inequality: $|\\mathbf{X} \\cdot \\mathbf{Y}| \\le |\\mathbf{X}| |\\mathbf{Y}|$ [tc_2]\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2 \\le |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2$ [l2].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (tc_2 : |\u2211 i, X i * Y i| \u2264 (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) :\n  (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (tc_2 : |\u2211 i, X i * Y i| \u2264 (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) :\n  (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2 := by\n  have h : \u2211 i, X i * Y i \u2264 |\u2211 i, X i * Y i| := le_abs_self (\u2211 i, X i * Y i)\n  have h' := le_trans h tc_2\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The vector representation using functions Fin n \u2192 \u211d correctly captures n-dimensional real vectors as stated in the natural language.", "The Schwarz inequality is accurately formalized with proper dot product and L2 norm representations using summations and square roots.", "The main inequality conclusion is precisely translated with all terms and operations correctly represented in Lean syntax while preserving the exact mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "\\ar=(|\\mathbf{X}|+|\\mathbf{Y}|)^2.", "statement": "We assume:\n\u2022 $|\\mathbf{X}|$ and $|\\mathbf{Y}|$ are real numbers.\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2 = (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (X_abs Y_abs : \u211d) :\n  X_abs^2 + 2 * X_abs * Y_abs + Y_abs^2 = (X_abs + Y_abs)^2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (X_abs Y_abs : \u211d) :\n  X_abs^2 + 2 * X_abs * Y_abs + Y_abs^2 = (X_abs + Y_abs)^2 := by\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content. While the natural language suggests X_abs and Y_abs represent norms of vectors X and Y, the Lean version treats them as arbitrary real numbers, which is a valid generalization since norms are indeed real numbers. The core algebraic identity (a + b)\u00b2 = a\u00b2 + 2ab + b\u00b2 is perfectly preserved in both versions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Hence,\n$$\n|\\mathbf{X}+\\mathbf{Y}|^2\\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2.\n$$", "statement": "We assume:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2$ [l1]\n\u2022 $|\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2 \\le |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2$ [l2]\n\u2022 $|\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2 = (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l3]\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l4].", "dependencies": ["l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (tc_2 : |\u2211 i, X i * Y i| \u2264 (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)))\n  (l1 : (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2))\n  (l2 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2)\n  (l3 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2))^2 = ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2) :\n  (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (tc_2 : |\u2211 i, X i * Y i| \u2264 (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)))\n  (l1 : (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2))\n  (l2 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2)\n  (l3 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2))^2 = ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2) :\n  (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2 := by\n  rw [l1]\n  have h1 : (\u2211 i, (X i)^2) = (Real.sqrt (\u2211 i, (X i)^2))^2 := by simp [sq_sqrt (sum_nonneg (fun i => sq_nonneg (X i)))]\n  have h2 : (\u2211 i, (Y i)^2) = (Real.sqrt (\u2211 i, (Y i)^2))^2 := by simp [sq_sqrt (sum_nonneg (fun i => sq_nonneg (Y i)))]\n  rw [h1, h2]\n  exact le_trans l2 (le_of_eq l3)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 79, "endLine": 13, "endColumn": 89, "data": "unknown identifier 'sum_nonneg'"}, {"line": 13, "column": 64, "endLine": 13, "endColumn": 118, "data": "simp made no progress"}, {"line": 14, "column": 79, "endLine": 14, "endColumn": 89, "data": "unknown identifier 'sum_nonneg'"}, {"line": 14, "column": 64, "endLine": 14, "endColumn": 118, "data": "simp made no progress"}, {"line": 16, "column": 30, "endLine": 16, "endColumn": 32, "data": "application type mismatch\n  le_of_eq l3\nargument\n  l3\nhas type\n  \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * \u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2 =\n    (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2 : Prop\nbut is expected to have type\n  \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * (\u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2)) + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2 =\n    (\u221a(\u221a(\u2211 i : Fin n, X i ^ 2) ^ 2) + \u221a(\u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2)) ^ 2 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Vector notation correctly translated to finite-dimensional function representation", "Dot product correctly represented as sum of component products", "Norm-squared expansion formula correctly formalized", "Cauchy-Schwarz step correctly represented with explicit norm calculations", "Perfect square expansion correctly formalized", "Triangle inequality conclusion correctly stated", "Additional Cauchy-Schwarz constraint (tc_2) is mathematically consistent and provides necessary foundation for the proof, though not explicitly mentioned in natural language", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l4\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (tc_2 : |\u2211 i, X i * Y i| \u2264 (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)))\n  (l1 : (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2))\n  (l2 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2)\n  (l3 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2))^2 = ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2) :\n  \u00ac (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2 := by\n  intro h\n  have h1 : (Real.sqrt (\u2211 i, (X i)^2))^2 = \u2211 i, (X i)^2 := by\n    apply Real.sq_sqrt\n    exact Finset.sum_nonneg (fun i _ => sq_nonneg (X i))\n  have h2 : (Real.sqrt (\u2211 i, (Y i)^2))^2 = \u2211 i, (Y i)^2 := by\n    apply Real.sq_sqrt\n    exact Finset.sum_nonneg (fun i _ => sq_nonneg (Y i))\n  rw [l1, h1, h2] at h\n  rw [h1, h2, l3] at h\n  simp [h1, h2] at l2\n  have h3 : \u2211 i, X i * Y i \u2264 |\u2211 i, X i * Y i| := le_abs_self _\n  have h4 : \u2211 i, X i * Y i \u2264 (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) := by linarith\n  linarith"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Taking square roots yields \\eqref{eq:5.1.6}.", "statement": "We assume:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l4]\n\u2022 The norm of a vector is a non-negative real number.\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l4 : (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2) :\n  Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l4 : (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2) :\n  Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2) := by\n  have h\u2081 : 0 \u2264 \u2211 i, (X i + Y i)^2 := by\n    apply sum_nonneg\n    intro i\n    exact pow_two_nonneg _\n  have h\u2082 : 0 \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2) := by\n    apply add_nonneg\n    \u00b7 apply Real.sqrt_nonneg\n    \u00b7 apply Real.sqrt_nonneg\n  rw [\u2190 Real.sqrt_le_sqrt_iff h\u2081, Real.sqrt_sq h\u2082]\n  exact l4", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 10, "endLine": 10, "endColumn": 20, "data": "unknown identifier 'sum_nonneg'"}, {"line": 11, "column": 4, "endLine": 11, "endColumn": 11, "data": "no goals to be solved"}, {"line": 17, "column": 6, "endLine": 17, "endColumn": 32, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.11794 \u2264 \u2211 i : Fin n, (X i + Y i) ^ 2\nn : \u2115\nX Y : Fin n \u2192 \u211d\nl4 : \u2211 i : Fin n, (X i + Y i) ^ 2 \u2264 (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2\nh\u2081 : 0 \u2264 \u2211 i : Fin n, (X i + Y i) ^ 2\nh\u2082 : 0 \u2264 \u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)\n\u22a2 \u221a(\u2211 i : Fin n, (X i + Y i) ^ 2) \u2264 \u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The abstract vector notation |**X**| is properly translated to the explicit Euclidean norm formula Real.sqrt (\u2211 i, (X i)^2). The assumption l4 and conclusion ts_1 are mathematically equivalent to their natural language counterparts. The specification of n-dimensional real vectors is a reasonable concrete instantiation of the abstract vectors mentioned in natural language. The non-negativity property of norms, while not explicitly stated in Lean, is inherent in the Real.sqrt function. The logical flow from assumption to conclusion is preserved correctly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l4 : (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2) :\n  \u00ac (Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) := by\n  intro h\n  have h_sq : (\u2211 i, (X i + Y i)^2) \u2264 (Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2))^2 := l4\n  have h_sqrt : Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt ((Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2))^2) := by\n    apply Real.sqrt_le_sqrt\n    exact h_sq\n  rw [Real.sqrt_sq (add_nonneg (Real.sqrt_nonneg _) (Real.sqrt_nonneg _))] at h_sqrt\n  exact lt_irrefl _ (h_sqrt.trans_lt (not_le.mp h))"}, "type": "solution"}, "def_2": {"id": "def_2", "natural_language": "which is true if\nand\nonly if one of the vectors $\\mathbf{X}$ and $\\mathbf{Y}$ is a nonnegative\nscalar multiple of the other (Lemma~\\ref{thmtype:5.1.5}).", "statement": "Definition:\n\u2022 For vectors $\\mathbf{X}, \\mathbf{Y}$ in $\\mathbb{R}^n$, the condition $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$ holds if and only if one of the vectors is a nonnegative scalar multiple of the other [def_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X Y : Fin n \u2192 \u211d)\n(def_2 : X \u2219 Y = \u2016X\u2016 * \u2016Y\u2016 \u2194 (\u2203 c : \u211d, 0 \u2264 c \u2227 Y = c \u2022 X) \u2228 (\u2203 c : \u211d, 0 \u2264 c \u2227 X = c \u2022 Y))", "lean_pass": false, "error_msg": [{"line": 6, "column": 9, "endLine": 6, "endColumn": 10, "data": "application type mismatch\n  @Submodule.span X\nargument\n  X\nhas type\n  Fin n \u2192 \u211d : Type\nbut is expected to have type\n  Type ?u.13 : Type (?u.13 + 1)"}, {"line": 6, "column": 17, "endLine": 6, "endColumn": 26, "data": "type mismatch\n  \u2016X\u2016 * \u2016Y\u2016\nhas type\n  \u211d : outParam Type\nbut is expected to have type\n  Fin n \u2192 \u211d : Type"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "From the third line of \\eqref{eq:5.1.7},\nequality holds in \\eqref{eq:5.1.6} if and\nonly  if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$,", "statement": "We assume:\n\u2022 The inequality $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1] is derived from the chain of relations in [l1], [l2], and [l3].\nTherefore, we conclude:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ if and only if $\\mathbf{X}\\cdot\\mathbf{Y} = |\\mathbf{X}||\\mathbf{Y}|$ [l5].", "dependencies": ["l1", "l2", "l3", "l4", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2))\n  (l2 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2)\n  (l3 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2))^2 = ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2)\n  (l4 : (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2)\n  (ts_1 : Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) :\n  (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2))\n  (l2 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2)\n  (l3 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2))^2 = ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2)\n  (l4 : (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2)\n  (ts_1 : Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) :\n  (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) := by\n  constructor\n  \u00b7 intro h\n    have h1 := congr_arg (fun x => x^2) h\n    simp at h1\n    rw [\u2190 l1, l3] at h1\n    rw [\u2190 h1]\n    simp\n    rw [\u2190 l2]\n    simp\n    exact le_antisymm (by linarith) (by linarith)\n  \u00b7 intro h\n    have h1 : (\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) := h\n    rw [\u2190 l1, h1, l3]\n    have h2 : (Real.sqrt (\u2211 i, (X i + Y i)^2))^2 = (Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2))^2 := by\n      rw [\u2190 l1, h1, l3]\n    have h3 : Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt ((Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2))^2) := by\n      rw [\u2190 h2]\n    simp at h3\n    exact h3", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 8, "endLine": 17, "endColumn": 12, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2211 i : Fin n, X i ^ 2 + 2 * \u2211 i : Fin n, X i * Y i + \u2211 i : Fin n, Y i ^ 2\ncase mp\nn : \u2115\nX Y : Fin n \u2192 \u211d\nl1 : \u2211 i : Fin n, (X i + Y i) ^ 2 = \u2211 i : Fin n, X i ^ 2 + 2 * \u2211 i : Fin n, X i * Y i + \u2211 i : Fin n, Y i ^ 2\nl2 :\n  \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * \u2211 i : Fin n, X i * Y i + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2 \u2264\n    \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * (\u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2)) + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2\nl3 :\n  \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * \u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2 =\n    (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2\nl4 : \u2211 i : Fin n, (X i + Y i) ^ 2 \u2264 (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2\nts_1 : \u221a(\u2211 i : Fin n, (X i + Y i) ^ 2) \u2264 \u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)\nh : \u221a(\u2211 i : Fin n, (X i + Y i) ^ 2) = \u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)\nh1 : \u221a(\u2211 i : Fin n, (X i + Y i) ^ 2) ^ 2 = (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2\n\u22a2 \u2211 i : Fin n, X i * Y i = \u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2)"}, {"line": 25, "column": 8, "endLine": 25, "endColumn": 12, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2211 i : Fin n, X i ^ 2 + 2 * \u2211 i : Fin n, X i * Y i + \u2211 i : Fin n, Y i ^ 2\ncase mpr\nn : \u2115\nX Y : Fin n \u2192 \u211d\nl1 : \u2211 i : Fin n, (X i + Y i) ^ 2 = \u2211 i : Fin n, X i ^ 2 + 2 * \u2211 i : Fin n, X i * Y i + \u2211 i : Fin n, Y i ^ 2\nl2 :\n  \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * \u2211 i : Fin n, X i * Y i + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2 \u2264\n    \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * (\u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2)) + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2\nl3 :\n  \u221a(\u2211 i : Fin n, X i ^ 2) ^ 2 + 2 * \u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2) ^ 2 =\n    (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2\nl4 : \u2211 i : Fin n, (X i + Y i) ^ 2 \u2264 (\u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)) ^ 2\nts_1 : \u221a(\u2211 i : Fin n, (X i + Y i) ^ 2) \u2264 \u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)\nh h1 : \u2211 i : Fin n, X i * Y i = \u221a(\u2211 i : Fin n, X i ^ 2) * \u221a(\u2211 i : Fin n, Y i ^ 2)\n\u22a2 \u221a(\u2211 i : Fin n, (X i + Y i) ^ 2) = \u221a(\u2211 i : Fin n, X i ^ 2) + \u221a(\u2211 i : Fin n, Y i ^ 2)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The triangle inequality is correctly formalized using Euclidean norms with square root of sum of squares notation", "The derivation chain is appropriately represented through the premise conditions l1, l2, l3, with additional supporting lemmas l4 and ts_1", "The main conclusion about equality conditions is perfectly captured with the correct biconditional relationship and mathematical expressions", "All mathematical objects (vector norms, dot products, equality conditions) are accurately translated to their Lean equivalents", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : (\u2211 i, (X i + Y i) ^ 2) = (\u2211 i, (X i) ^ 2) + 2 * (\u2211 i, (X i) * (Y i)) + (\u2211 i, (Y i) ^ 2))\n  (l2 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (\u2211 i, X i * Y i) + (Real.sqrt (\u2211 i, (Y i)^2))^2 \u2264 (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * ((Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) + (Real.sqrt (\u2211 i, (Y i)^2))^2)\n  (l3 : (Real.sqrt (\u2211 i, (X i)^2))^2 + 2 * (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2))^2 = ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2)\n  (l4 : (\u2211 i, (X i + Y i) ^ 2) \u2264 ((Real.sqrt (\u2211 i, (X i)^2)) + (Real.sqrt (\u2211 i, (Y i)^2)))^2)\n  (ts_1 : Real.sqrt (\u2211 i, (X i + Y i)^2) \u2264 Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) :\n  \u00ac((Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)))) := by\n  intro h\n  have h_forward : \u2200 X Y : Fin n \u2192 \u211d, (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2192 \n    (\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) := by\n    intro X Y h_eq\n    exact (h.mp h_eq)\n  \n  let X : Fin n \u2192 \u211d := fun _ => 1\n  let Y : Fin n \u2192 \u211d := fun _ => -1\n  have h_eq : Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2) := by\n    simp [X, Y]\n    rw [Real.sqrt_eq_iff_sq_eq]\n    \u00b7 simp\n      ring\n    \u00b7 simp\n  have h_dot : (\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2)) := by\n    simp [X, Y]\n  specialize h_forward X Y h_eq\n  simp [X, Y] at h_forward\n  norm_num at h_forward"}, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "equality holds in \\eqref{eq:5.1.6} if and\nonly  if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$, which is true if\nand\nonly if one of the vectors $\\mathbf{X}$ and $\\mathbf{Y}$ is a nonnegative\nscalar multiple of the other (Lemma~\\ref{thmtype:5.1.5}).", "statement": "We assume:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ if and only if $\\mathbf{X}\\cdot\\mathbf{Y} = |\\mathbf{X}||\\mathbf{Y}|$ [l5]\n\u2022 $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$ if and only if one of the vectors is a nonnegative scalar multiple of the other [def_2]\nTherefore, we conclude:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ if and only if one of the vectors is a nonnegative scalar multiple of the other [ts_2].", "dependencies": ["l5", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l5 : (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))))\n  (def_2 : ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) \u2194 (\u2203 (c : \u211d), (0 \u2264 c \u2227 Y = c \u2022 X) \u2228 (0 \u2264 c \u2227 X = c \u2022 Y))) :\n  (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 (\u2203 (c : \u211d), (0 \u2264 c \u2227 Y = c \u2022 X) \u2228 (0 \u2264 c \u2227 X = c \u2022 Y)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l5 : (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))))\n  (def_2 : ((\u2211 i, X i * Y i) = (Real.sqrt (\u2211 i, (X i)^2)) * (Real.sqrt (\u2211 i, (Y i)^2))) \u2194 (\u2203 (c : \u211d), (0 \u2264 c \u2227 Y = c \u2022 X) \u2228 (0 \u2264 c \u2227 X = c \u2022 Y))) :\n  (Real.sqrt (\u2211 i, (X i + Y i)^2) = Real.sqrt (\u2211 i, (X i)^2) + Real.sqrt (\u2211 i, (Y i)^2)) \u2194 (\u2203 (c : \u211d), (0 \u2264 c \u2227 Y = c \u2022 X) \u2228 (0 \u2264 c \u2227 X = c \u2022 Y)) := by\n  rw [l5, def_2]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The triangle inequality equality condition l5 is correctly formalized using concrete Euclidean norm and dot product expressions that precisely capture the abstract vector notation.", "The characterization def_2 properly translates the bidirectional relationship between dot product condition and scalar multiple condition, correctly using disjunction for 'one of the vectors'.", "The main conclusion ts_2 correctly combines the premises to state the desired equivalence between triangle inequality equality and the scalar multiple condition.", "The logical structure properly represents the transitive reasoning from the natural language, with ts_2 as a lemma to be proven from premises l5 and def_2.", "All mathematical concepts are accurately translated to their concrete Lean representations while preserving the semantic meaning of the original statements."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    