
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ and $Y$ be independent and identically distributed random variables with finite mean $E[X] = \mu$ and finite variance $	ext{Var}(X) = \sigma^2$. Let $S = X+Y$. Then, it follows that $E[X|S] = \frac{S}{2}$ and $E[	ext{Var}(X|S)] = \frac{\sigma^2}{2}$.

Proof: First, we find the conditional expectation $E[X|S]$. By linearity of conditional expectation, $E[X|S] + E[Y|S] = E[X+Y|S]$. Since $S=X+Y$ is $\sigma(S)$-measurable, $E[X+Y|S] = S$. Therefore, we have the relation $E[X|S] + E[Y|S] = S$. Given that $X$ and $Y$ are independent and identically distributed, their conditional expectations given their sum $S$ must be equal, so $E[X|S] = E[Y|S]$. Substituting this into the previous equation yields $2E[X|S] = S$. Solving for $E[X|S]$ gives our first result, $E[X|S] = \frac{S}{2}$.

Next, we find $E[	ext{Var}(X|S)]$ using the law of total variance: $	ext{Var}(X) = E[	ext{Var}(X|S)] + 	ext{Var}(E[X|S])$. We first compute the term $	ext{Var}(E[X|S])$. Using our first result, the independence of $X$ and $Y$, and their identical variance $\sigma^2$, we get $	ext{Var}(E[X|S]) = 	ext{Var}(\frac{S}{2}) = \frac{1}{4}	ext{Var}(X+Y) = \frac{1}{4}(	ext{Var}(X)+	ext{Var}(Y)) = \frac{1}{4}(\sigma^2+\sigma^2) = \frac{\sigma^2}{2}$. Now we substitute this and $	ext{Var}(X) = \sigma^2$ back into the law of total variance equation: $\sigma^2 = E[	ext{Var}(X|S)] + \frac{\sigma^2}{2}$. Rearranging the terms gives the second result, $E[	ext{Var}(X|S)] = \frac{\sigma^2}{2}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ and $Y$ be independent and identically distributed random variables with finite mean $E[X] = \\mu$ and finite variance $\\text{Var}(X) = \\sigma^2$.", "statement": "Premise:\n\u2022 X and Y are independent and identically distributed (i.i.d.) random variables with finite mean E[X] = \u03bc and finite variance Var(X) = \u03c3^2 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {\u03a9 : Type*} {m : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}\n  (X Y : \u03a9 \u2192 \u211d) (\u03bc_X_finite : Integrable X \u03bc) (\u03bc_Y_finite : Integrable Y \u03bc) (\u03bc_X_sq_finite : Integrable (fun x => (X x - (\u222b x, X x \u2202\u03bc)) ^ 2) \u03bc)\n  (\u03bc_Y_sq_finite : Integrable (fun x => (Y x - (\u222b x, Y x \u2202\u03bc)) ^ 2) \u03bc)\n  (tc_1 : Measure.IsField X \u03bc \u2227 Measure.IsField Y \u03bc \u2227 X.Indep Y \u03bc \u2227 Measure.IsIdist X Y \u03bc \u2227\n          (\u2203 \u03bc_val : \u211d, \u222b \u03c9, X \u03c9 \u2202\u03bc = \u03bc_val) \u2227 (\u2203 \u03c3_sq_val : \u211d, \u222b \u03c9, (X \u03c9 - (\u222b x, X x \u2202\u03bc)) ^ 2 \u2202\u03bc = \u03c3_sq_val))", "lean_pass": false, "error_msg": [{"line": 9, "column": 54, "endLine": 9, "endColumn": 65, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  X\nhas type\n  \u03a9 \u2192 \u211d"}, {"line": 6, "column": 43, "endLine": 6, "endColumn": 52, "data": "function expected at\n  Measure\nterm has type\n  ?m.9"}, {"line": 7, "column": 30, "endLine": 7, "endColumn": 44, "data": "function expected at\n  Integrable\nterm has type\n  ?m.30"}, {"line": 7, "column": 60, "endLine": 7, "endColumn": 74, "data": "function expected at\n  Integrable\nterm has type\n  ?m.30"}, {"line": 7, "column": 93, "endLine": 7, "endColumn": 142, "data": "function expected at\n  Integrable\nterm has type\n  ?m.30"}, {"line": 8, "column": 19, "endLine": 8, "endColumn": 68, "data": "function expected at\n  Integrable\nterm has type\n  ?m.30"}, {"line": 9, "column": 10, "endLine": 9, "endColumn": 29, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Measure\nhas type\n  ?m.9"}, {"line": 9, "column": 32, "endLine": 9, "endColumn": 51, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Measure\nhas type\n  ?m.9"}, {"line": 9, "column": 68, "endLine": 9, "endColumn": 89, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Measure\nhas type\n  ?m.9"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $S = X+Y$.", "statement": "We assume:\n\u2022 X and Y are random variables [tc_1].\nDefinition:\n\u2022 S = X+Y [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter MeasureTheory ProbabilityTheory\n\nvariable\n  {\u03a9 : Type*} {\u03b1 : Type*} [MeasurableSpace \u03a9] {\u03bc : Measure \u03a9}\n  (X Y : \u03a9 \u2192 \u211d)\n  (tc_1 : IsRandomVariable X \u03bc \u2227 IsRandomVariable Y \u03bc \u2227 IsIndepFun \u03bc X Y \u2227\n          (\u2200 (s : Set \u211d), \u03bc (X \u207b\u00b9' s) = \u03bc (Y \u207b\u00b9' s)) \u2227\n          (\u2203 (\u03bc_val : \u211d), snorm X 1 \u03bc < \u22a4 \u2227 integral X \u03bc = \u03bc_val) \u2227\n          (\u2203 (\u03c3_sq_val : \u211d), snorm (X - (integral X \u03bc)) 2 \u03bc < \u22a4 \u2227 integral ((X - (integral X \u03bc))^2) \u03bc = \u03c3_sq_val))\n  (def_1_var : \u03a9 \u2192 \u211d) (def_1 : def_1_var = X + Y)", "lean_pass": false, "error_msg": [{"line": 10, "column": 44, "endLine": 10, "endColumn": 56, "data": "failed to synthesize\n  NormedAddCommGroup ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 41, "endLine": 11, "endColumn": 53, "data": "failed to synthesize\n  NormedAddCommGroup ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 82, "endLine": 11, "endColumn": 94, "data": "failed to synthesize\n  NormedAddCommGroup ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 66, "endLine": 11, "endColumn": 101, "data": "failed to synthesize\n  NormedAddCommGroup ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 76, "endLine": 11, "endColumn": 98, "data": "failed to synthesize\n  HPow (\u03a9 \u2192 \u211d) \u2115 (Measure (Set \u03a9))\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 8, "column": 10, "endLine": 8, "endColumn": 30, "data": "function expected at\n  IsRandomVariable\nterm has type\n  ?m.32"}, {"line": 8, "column": 33, "endLine": 8, "endColumn": 53, "data": "function expected at\n  IsRandomVariable\nterm has type\n  ?m.32"}, {"line": 8, "column": 56, "endLine": 8, "endColumn": 72, "data": "function expected at\n  IsIndepFun\nterm has type\n  ?m.63"}, {"line": 11, "column": 91, "endLine": 11, "endColumn": 92, "data": "application type mismatch\n  integral X\nargument\n  X\nhas type\n  \u03a9 \u2192 \u211d : Type u_1\nbut is expected to have type\n  Measure (Set \u03a9) : Type u_1"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "By linearity of conditional expectation, $E[X|S] + E[Y|S] = E[X+Y|S]$.", "statement": "We assume:\n\u2022 X, Y are random variables with finite mean [tc_1].\n\u2022 S = X+Y [def_1].\nTherefore, we conclude:\n\u2022 By the linearity of conditional expectation, E[X|S] + E[Y|S] = E[X+Y|S] [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03a9 : Type*} {m : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}\n  (X Y S : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.Integrable X \u03bc \u2227 MeasureTheory.Integrable Y \u03bc)\n  (def_1 : S = X + Y) :\n  MeasureTheory.condexp (X + Y) m = MeasureTheory.condexp X m + MeasureTheory.condexp Y m := by\nsorry", "lean_pass": false, "error_msg": [{"line": 6, "column": 43, "endLine": 6, "endColumn": 52, "data": "function expected at\n  Measure\nterm has type\n  ?m.9"}, {"line": 10, "column": 88, "endLine": 10, "endColumn": 89, "data": "application type mismatch\n  MeasureTheory.condexp ?m.5207 m\nargument\n  m\nhas type\n  MeasurableSpace \u03a9 : Type u_1\nbut is expected to have type\n  MeasureTheory.Measure ?m.4810 : Type ?u.4809"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.Probability.Notation\nimport Mathlib.Probability.ConditionalExpectation\n\nopen MeasureTheory ProbabilityTheory\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03a9 : Type*} [MeasureSpace \u03a9] {m : MeasurableSpace \u03a9} [h\u03bc : IsFiniteMeasure (\u03bc : Measure \u03a9)]\n  (X Y : \u03a9 \u2192 \u211d) (S := X + Y)\n  (tc_1 : Integrable X \u03bc \u2227 Integrable Y \u03bc) :\n  \u03bc[\ud835\udd3c[X|m]] + \u03bc[\ud835\udd3c[Y|m]] = \u03bc[\ud835\udd3c[X + Y|m]] := by\n  rw [condexp_add (tc_1.left) (tc_1.right)]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since $S=X+Y$ is $\\sigma(S)$-measurable, $E[X+Y|S] = S$.", "statement": "We assume:\n\u2022 S = X+Y, where X and Y are random variables with finite mean [def_1, tc_1].\nTherefore, we conclude:\n\u2022 Since S is measurable with respect to the sigma-algebra generated by S, E[X+Y|S] = S [l2].", "dependencies": ["def_1", "tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03a9 : Type*} {m\u03a9 : MeasureTheory.MeasurableSpace \u03a9} {\u03bc : MeasureTheory.Measure \u03a9}\n  (X Y S : \u03a9 \u2192 \u211d)\n  (def_1 : S = X + Y)\n  (tc_1 : MeasureTheory.Integrable X \u03bc \u2227 MeasureTheory.Integrable Y \u03bc) :\n  MeasureTheory.condexp (X + Y) (MeasureTheory.Measure.map S \u03bc) = S := by\nsorry", "lean_pass": false, "error_msg": [{"line": 6, "column": 20, "endLine": 6, "endColumn": 49, "data": "unknown identifier 'MeasureTheory.MeasurableSpace'"}, {"line": 6, "column": 58, "endLine": 6, "endColumn": 81, "data": "failed to synthesize\n  MeasurableSpace \u03a9\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 10, "column": 33, "endLine": 10, "endColumn": 62, "data": "failed to synthesize\n  MeasurableSpace \u03a9\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 10, "column": 66, "endLine": 10, "endColumn": 67, "data": "type mismatch\n  S\nhas type\n  \u03a9 \u2192 \u211d : Type u_1\nbut is expected to have type\n  (\u211d \u2192 ?m.1278) \u2192 \u211d \u2192 ?m.1278 : Type (max ?u.1275 0)"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.Probability.ConditionalExpectation\nimport Mathlib.MeasureTheory.Measure.MeasureSpace\n\nopen MeasureTheory\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] {\u03bc : Measure \u03a9}\n  (X Y S : \u03a9 \u2192 \u211d)\n  (def_1 : S = X + Y)\n  (hX : Integrable X \u03bc) (hY : Integrable Y \u03bc) :\n  \u03bc[fun x => X x + Y x | m\u03b2 := Submodule.span \u211d {S}] =\u1d50[\u03bc] S := by\n  rw [def_1]\n  exact condexp_add hX hY", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, we have the relation $E[X|S] + E[Y|S] = S$.", "statement": "We assume:\n\u2022 E[X|S] + E[Y|S] = E[X+Y|S] [l1].\n\u2022 E[X+Y|S] = S [l2].\nTherefore, we conclude:\n\u2022 E[X|S] + E[Y|S] = S [l3].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03b1 : Type*} [MeasurableSpace \u03b1] {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} (X Y S : \u03b1 \u2192 \u211d)\n  (l1 : MeasureTheory.condexp (\u03bb a, X a) m \u03bc + MeasureTheory.condexp (\u03bb a, Y a) m \u03bc = MeasureTheory.condexp (\u03bb a, X a + Y a) m \u03bc)\n  (l2 : MeasureTheory.condexp (\u03bb a, X a + Y a) m \u03bc = S) :\n  MeasureTheory.condexp (\u03bb a, X a) m \u03bc + MeasureTheory.condexp (\u03bb a, Y a) m \u03bc = S := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 34, "endLine": 7, "endColumn": 35, "data": "unexpected token ','; expected '\u21a6', '=>'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : MeasureTheory.Measure \u03b1} (X Y S : \u03b1 \u2192 \u211d)\n  (l1 : MeasureTheory.condexp X \u03bc + MeasureTheory.condexp Y \u03bc = MeasureTheory.condexp (X + Y) \u03bc)\n  (l2 : MeasureTheory.condexp (X + Y) \u03bc = S) :\n  MeasureTheory.condexp X \u03bc + MeasureTheory.condexp Y \u03bc = S := by\n  rw [l1, l2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 2, "endLine": 9, "endColumn": 55, "data": "typeclass instance problem is stuck, it is often due to metavariables\n  HAdd ((\u03b1 \u2192 ?m.13972) \u2192 \u03b1 \u2192 ?m.13972) ((\u03b1 \u2192 ?m.14690) \u2192 \u03b1 \u2192 ?m.14690) (\u03b1 \u2192 \u211d)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Given that $X$ and $Y$ are independent and identically distributed, their conditional expectations given their sum $S$ must be equal, so $E[X|S] = E[Y|S]$.", "statement": "We assume:\n\u2022 X and Y are i.i.d. random variables [tc_1].\n\u2022 S = X+Y [def_1].\nTherefore, we conclude:\n\u2022 By symmetry, E[X|S] = E[Y|S] [l4].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4 {\u03a9 : Type*} {f : Filter \u03a9} {m\u03a9 : MeasurableSpace \u03a9} {\u03bc : MeasureTheory.Measure \u03a9}\n  (X Y S : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.IsIndependent X Y \u03bc \u2227 MeasureTheory.IsIdenticallyDistributed X Y \u03bc)\n  (def_1 : S = X + Y) :\n  MeasureTheory.condexp (MeasureTheory.instSigmaAlgebra S) X \u03bc = MeasureTheory.condexp (MeasureTheory.instSigmaAlgebra S) Y \u03bc := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 10, "endLine": 7, "endColumn": 37, "data": "unknown identifier 'MeasureTheory.IsIndependent'"}, {"line": 7, "column": 46, "endLine": 7, "endColumn": 84, "data": "unknown identifier 'MeasureTheory.IsIdenticallyDistributed'"}, {"line": 9, "column": 25, "endLine": 9, "endColumn": 55, "data": "unknown identifier 'MeasureTheory.instSigmaAlgebra'"}, {"line": 9, "column": 2, "endLine": 9, "endColumn": 62, "data": "failed to synthesize\n  NormedAddCommGroup ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 88, "endLine": 9, "endColumn": 118, "data": "unknown identifier 'MeasureTheory.instSigmaAlgebra'"}, {"line": 9, "column": 65, "endLine": 9, "endColumn": 125, "data": "failed to synthesize\n  NormedAddCommGroup ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Probability.ConditionalExpectation\nimport Probability.Notation\n\nopen MeasureTheory ProbabilityTheory\n\nimport Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4 {\u03a9 : Type*} [MeasureSpace \u03a9] (X Y S : \u03a9 \u2192 \u211d)\n  (tc_1 : IndepFun X Y volume \u2227 IdentDistrib X Y volume)\n  (def_1 : \u2200 \u03c9, S \u03c9 = X \u03c9 + Y \u03c9) :\n  \u03bc[|S] X = \u03bc[|S] Y := by\n  have hXY : IdentDistrib X Y volume := tc_1.2\n  have h_swap : IdentDistrib (fun \u03c9 => (X \u03c9, Y \u03c9)) (fun \u03c9 => (Y \u03c9, X \u03c9)) volume := by\n    apply IdentDistrib.prod_mk\n    exact hXY.symm\n    exact hXY\n    exact tc_1.1.symm\n  have hS : \u2200 \u03c9, S \u03c9 = Y \u03c9 + X \u03c9 := by intro \u03c9; rw [def_1, add_comm]\n  have h_eq : \u03bc[|S] X = \u03bc[|fun \u03c9 => (Y \u03c9 + X \u03c9)] X := by congr; ext \u03c9; rw [hS]\n  rw [h_eq, \u2190 def_1]\n  exact condExp_congr _ _ h_swap (Measurable.add measurable_id measurable_id)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 1, "column": 5, "endLine": 1, "endColumn": 18, "data": "unknown namespace 'MeasureTheory'"}, {"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Substituting this into the previous equation yields $2E[X|S] = S$.", "statement": "We assume:\n\u2022 E[X|S] + E[Y|S] = S [l3].\n\u2022 E[X|S] = E[Y|S] [l4].\nTherefore, we conclude:\n\u2022 2*E[X|S] = S [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (E_X_S E_Y_S S : \u211d)\n  (l3 : E_X_S + E_Y_S = S)\n  (l4 : E_X_S = E_Y_S) :\n  2 * E_X_S = S := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (E_X_S E_Y_S S : \u211d)\n  (l3 : E_X_S + E_Y_S = S)\n  (l4 : E_X_S = E_Y_S) :\n  2 * E_X_S = S := by\n  rw [\u2190 l4] at l3\n  rw [\u2190 two_mul] at l3\n  exact l3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations appropriately represent the mathematical objects as real numbers", "Assumption l3 is correctly translated with proper variable correspondence", "Assumption l4 is correctly translated with proper variable correspondence", "The conclusion l5 is correctly captured in the goal statement", "The logical structure perfectly mirrors the natural language deductive reasoning, with assumptions as hypotheses and conclusion as goal"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Solving for $E[X|S]$ gives our first result, $E[X|S] = \\frac{S}{2}$.", "statement": "We assume:\n\u2022 2*E[X|S] = S [l5].\nTherefore, we conclude:\n\u2022 E[X|S] = S / 2 [ts_1].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (E_X_S S : \u211d)\n  (l5 : 2 * E_X_S = S) :\n  E_X_S = S / 2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (E_X_S S : \u211d)\n  (l5 : 2 * E_X_S = S) :\n  E_X_S = S / 2 := by\n  rw [eq_div_iff (two_ne_zero : (2 : \u211d) \u2260 0), mul_comm]\n  exact l5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical and logical content from the natural language. The assumption '2*E[X|S] = S' is properly represented as hypothesis 'l5 : 2 * E_X_S = S', and the conclusion 'E[X|S] = S / 2' is accurately formalized as 'E_X_S = S / 2'. The variable name E_X_S is a reasonable representation of the conditional expectation notation E[X|S]. The logical structure (assumption implies conclusion) is preserved perfectly in the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "l6": {"id": "l6", "natural_language": "Next, we find $E[\\text{Var}(X|S)]$ using the law of total variance: $\\text{Var}(X) = E[\\text{Var}(X|S)] + \\text{Var}(E[X|S])$.", "statement": "We assume:\n\u2022 X is a random variable with finite variance [tc_1].\n\u2022 S is a random variable [def_1].\nTherefore, we conclude:\n\u2022 The law of total variance states that Var(X) = E[Var(X|S)] + Var(E[X|S]) [l6].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {\u03a9 : Type*} [MeasureSpace \u03a9]\n  (X S : \u03a9 \u2192 \u211d) [IsRandomVariable X] [IsRandomVariable S]\n  (tc_1 : Var X \u2260 \u22a4)\n  (def_1 : S = X + Y) :\n  Var X = ennreal.toReal (E[Var (X | S)] + Var (E[X | S])) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 10, "column": 34, "endLine": 10, "endColumn": 36, "data": "unexpected token '|'; expected ')', ',' or ':'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {\u03a9 : Type*} [MeasureSpace \u03a9]\n  (X S : \u03a9 \u2192 \u211d) [IsFiniteMeasure \u03a9] [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n  (hX : Measurable X) (hS : Measurable S)\n  (tc_1 : Var X \u2260 \u22a4) :\n  Var X = (E[fun \u03c9 => Var[fun \u03c9' => X \u03c9' | S \u03c9'] \u03c9] + Var[fun \u03c9 => E[fun \u03c9' => X \u03c9' | S \u03c9'] \u03c9]) := by\n  rw [\u2190 MeasureTheory.law_total_variance hX hS]\n  simp [Var]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 40, "endLine": 10, "endColumn": 42, "data": "unexpected token '|'; expected ':', ']' or ']''"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Using our first result, the independence of $X$ and $Y$, and their identical variance $\\sigma^2$, we get $\\text{Var}(E[X|S]) = \\text{Var}(\\frac{S}{2}) = \\frac{1}{4}\\text{Var}(X+Y) = \\frac{1}{4}(\\text{Var}(X)+\\text{Var}(Y)) = \\frac{1}{4}(\\sigma^2+\\sigma^2) = \\frac{\\sigma^2}{2}$.", "statement": "We assume:\n\u2022 X and Y are i.i.d. with Var(X) = \u03c3^2 [tc_1].\n\u2022 S = X+Y [def_1].\n\u2022 E[X|S] = S / 2 [ts_1].\nTherefore, we conclude:\n\u2022 Var(E[X|S]) = \u03c3^2 / 2 [l7].", "dependencies": ["tc_1", "def_1", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {\u2119 : Measure \u03a9}\n  {X Y S : \u03a9 \u2192 \u211d} [IsRandomVariable X] [IsRandomVariable Y] [IsRandomVariable S]\n  (tc_1 : iid X Y \u2227 Var X = (\u03c3^2 : \u211d))\n  (def_1 : S = X + Y)\n  (ts_1 : E[X | S] = S / 2) :\n  Var (E[X | S]) = (\u03c3^2) / 2 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 10, "column": 13, "endLine": 10, "endColumn": 15, "data": "unexpected token '|'; expected ':', ']' or ']''"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {\u03a9 : Type*} [MeasureSpace \u03a9]\n  {X Y S : \u03a9 \u2192 \u211d} [IsProbabilityMeasure (\u2119 : Measure \u03a9)]\n  (tc_1 : IdentDistrib X Y \u2227 Var[X] = (\u03c3^2 : \u211d))\n  (def_1 : \u2200 \u03c9, S \u03c9 = X \u03c9 + Y \u03c9)\n  (ts_1 : \u2200 \u03c9, \ud835\udd3c[X | S] \u03c9 = S \u03c9 / 2) :\n  Var[\ud835\udd3c[X | S]] = (\u03c3^2) / 2 := by\n  rw [ts_1]\n  simp_rw [def_1]\n  have hXY : Cov[X, Y] = 0 := by\n    rcases tc_1 with \u27e8h\u2081, h\u2082\u27e9\n    exact h\u2081.indep.cov_eq_zero\n  have hVarS : Var[S] = 2 * \u03c3^2 := by\n    rw [\u2190 tc_1.2]\n    simp [def_1, Var.add X Y, hXY]\n  rw [Var.div_const, hVarS]\n  field_simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 18, "endLine": 10, "endColumn": 20, "data": "unexpected token '|'; expected ':' or ']'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Now we substitute this and $\\text{Var}(X) = \\sigma^2$ back into the law of total variance equation: $\\sigma^2 = E[\\text{Var}(X|S)] + \\frac{\\sigma^2}{2}$.", "statement": "We assume:\n\u2022 Var(X) = \u03c3^2 [tc_1].\n\u2022 Var(X) = E[Var(X|S)] + Var(E[X|S]) [l6].\n\u2022 Var(E[X|S]) = \u03c3^2 / 2 [l7].\nTherefore, we conclude:\n\u2022 \u03c3^2 = E[Var(X|S)] + \u03c3^2 / 2 [l8].", "dependencies": ["tc_1", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u211d} [IsRandomVariable X]\n  (\u03c3 : \u211d) (h\u03c3_pos : \u03c3 > 0)\n  (tc_1 :  Var X = \u03c3^2)\n  (l6 : Var X = E (Var (X | cond)) + Var (E (X | cond)))\n  (l7 : Var (E (X | cond)) = \u03c3^2 / 2) :\n  \u03c3^2 = E (Var (X | cond)) + \u03c3^2 / 2 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 10, "column": 25, "endLine": 10, "endColumn": 27, "data": "unexpected token '|'; expected ')', ',' or ':'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u211d} [IsRandomVariable X]\n  (\u03c3 : \u211d) (h\u03c3_pos : \u03c3 > 0)\n  (tc_1 :  Var X = \u03c3^2)\n  (l6 : Var X = E (fun \u03c9 => Var (X | \u03c9)) + Var (fun \u03c9 => E (X | \u03c9)))\n  (l7 : Var (fun \u03c9 => E (X | \u03c9)) = \u03c3^2 / 2) :\n  \u03c3^2 = E (fun \u03c9 => Var (X | \u03c9)) + \u03c3^2 / 2 := by\n  rw [\u2190 tc_1, l6, l7]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 34, "endLine": 10, "endColumn": 36, "data": "unexpected token '|'; expected ')', ',' or ':'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Rearranging the terms gives the second result, $E[\\text{Var}(X|S)] = \\frac{\\sigma^2}{2}$.", "statement": "We assume:\n\u2022 \u03c3^2 = E[Var(X|S)] + \u03c3^2 / 2 [l8].\nTherefore, we conclude:\n\u2022 E[Var(X|S)] = \u03c3^2 / 2 [ts_2].", "dependencies": ["l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (\u03c3_sq E_Var_X_S : \u211d)\n  (l8 : \u03c3_sq = E_Var_X_S + \u03c3_sq / 2) :\n  E_Var_X_S = \u03c3_sq / 2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (\u03c3_sq E_Var_X_S : \u211d)\n  (l8 : \u03c3_sq = E_Var_X_S + \u03c3_sq / 2) :\n  E_Var_X_S = \u03c3_sq / 2 := by\n  rw [eq_comm]\n  apply eq_sub_of_add_eq'\n  rw [add_comm] at l8\n  exact l8", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 2, "endLine": 10, "endColumn": 25, "data": "tactic 'apply' failed, failed to unify\n  ?a = ?b - ?c\nwith\n  \u03c3_sq / 2 = E_Var_X_S\n\u03c3_sq E_Var_X_S : \u211d\nl8 : \u03c3_sq = E_Var_X_S + \u03c3_sq / 2\n\u22a2 \u03c3_sq / 2 = E_Var_X_S"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly represent the mathematical concepts with appropriate Lean syntax adaptations (\u03c3_sq for \u03c3\u00b2, E_Var_X_S for E[Var(X|S)]).", "The assumption l8 is accurately formalized as an equation matching the natural language premise exactly.", "The conclusion ts_2 correctly captures the target equality that should be derived.", "The logical structure properly represents the implication from assumption to conclusion using Lean's lemma format.", "The mathematical reasoning (algebraic manipulation to isolate E[Var(X|S)]) is correctly preserved in the formal structure.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_2\n  (\u03c3_sq E_Var_X_S : \u211d)\n  (l8 : \u03c3_sq = E_Var_X_S + \u03c3_sq / 2) :\n  \u00ac (E_Var_X_S = \u03c3_sq / 2) := by\n  intro h\n  rw [h] at l8\n  have : \u03c3_sq = \u03c3_sq := by rfl\n  contradiction"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    