
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $f$ be continuous at $\mathbf{X}_1=(x_{11},x_{21}, \dots, x_{n1})$
and $\mathbf{X}_2=(x_{12},x_{22}, \dots,x_{n2})$ and differentiable on the
line segment $L$ from $\mathbf{X}_1$ to $\mathbf{X}_2.$ Then
\begin{equation} \label{eq:5.4.21}
f(\mathbf{X}_2)-f(\mathbf{X}_1)=\sum_{i=1}^n f_{x_i} (\mathbf{X}_0)(x_{i2}-x_{i1})=(d_{\mathbf{X}_0}f)(\mathbf{X}_2
-\mathbf{X}_1)
\end{equation}
for some $\mathbf{X}_0$ on $L$ distinct
from $\mathbf{X}_1$ and $\mathbf{X}_2$.

We can assume the following statement(s) without a proof. 

If $f$ is continuous on the closed interval $[a,b]$ and differentiable
on the open interval $(a,b),$ then
$$
f'(c)=\frac{f(b)-f(a)}{ b-a}
$$
for some $c$ in $(a,b).$

Proof: An equation of $L$ is
$$
\mathbf{X}=\mathbf{X}(t)=t\mathbf{X}_2+(1-t)\mathbf{X}_1,\quad 0\le t\le1.
$$
Our hypotheses imply that the function
$$
h(t)=f(\mathbf{X}(t))
$$
is continuous on $[0,1]$ and differentiable on $(0,1)$.  Since
$$
x_i(t)=tx_{i2}+(1-t)x_{i1},
$$
\eqref{eq:5.4.20} implies that
$$
h'(t)=\sum_{i=1}^n f_{x_i}(\mathbf{X}(t))(x_{i2}-x_{i1}),\quad 0<t<1.
$$
From the mean value theorem for functions of one variable
(Theorem~\ref{thmtype:2.3.11}),
$$
h(1)-h(0)=h'(t_0)
$$
for some $t_0\in (0,1)$.  Since $h(1)=f(\mathbf{X}_2)$ and
$h(0)=f(\mathbf{X}_1)$, this implies \eqref{eq:5.4.21} with
$\mathbf{X}_0=\mathbf{X}(t_0)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f$ be continuous at $\\mathbf{X}_1=(x_{11},x_{21}, \\dots, x_{n1})$ and $\\mathbf{X}_2=(x_{12},x_{22}, \\dots,x_{n2})$ and differentiable on the line segment $L$ from $\\mathbf{X}_1$ to $\\mathbf{X}_2.$", "statement": "Premise:\n\u2022 $\\mathbf{X}_1, \\mathbf{X}_2$ are points in $\\mathbb{R}^n$.\n\u2022 $L$ is the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$.\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is continuous at $\\mathbf{X}_1$ and $\\mathbf{X}_2$, and differentiable on $L$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n(tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousAt f X1 \u2227 ContinuousAt f X2 \u2227 DifferentiableOn \u211d f L)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents points in \u211d\u207f using Fin n \u2192 \u211d, which is the standard way to represent n-dimensional real vectors in Lean", "The Lean definition of L as a parametric line segment with parameter t \u2208 [0,1] perfectly captures the mathematical concept of a line segment from X1 to X2", "The Lean formalization uses ContinuousAt f X1 \u2227 ContinuousAt f X2 which exactly matches the requirement that f is continuous at both points", "DifferentiableOn \u211d f L correctly formalizes that f is differentiable on the line segment L"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_mvt": {"id": "def_mvt", "natural_language": "If $f$ is continuous on the closed interval $[a,b]$ and differentiable on the open interval $(a,b),$ then $f'(c)=\\frac{f(b)-f(a)}{ b-a}$ for some $c$ in $(a,b).$", "statement": "Definition:\n\u2022 The Mean Value Theorem for a single-variable function $g$ states that if $g$ is continuous on $[a,b]$ and differentiable on $(a,b)$, then there exists some $c \\in (a,b)$ such that $g(b) - g(a) = (b-a)g'(c)$ [def_mvt].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (g : \u211d \u2192 \u211d)\n  (a b : \u211d)\n  (cont_g : ContinuousOn g (Set.Icc a b))\n  (diff_g : DifferentiableOn \u211d g (Set.Ioo a b))\n  (def_mvt : \u2203 c : \u211d, c \u2208 Set.Ioo a b \u2227 g b - g a = (b - a) * (deriv g c))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `ContinuousOn g (Set.Icc a b)` correctly captures continuity on the closed interval [a,b]", "The Lean formalization `DifferentiableOn \u211d g (Set.Ioo a b)` correctly captures differentiability on the open interval (a,b)", "The Lean formalization correctly captures the existence of c in the open interval with the Mean Value Theorem equation. The notation `(b - a) * (deriv g c)` is equivalent to `(b-a)g'(c)` from the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_1": {"id": "def_1", "natural_language": "An equation of $L$ is\n$$\n\\mathbf{X}=\\mathbf{X}(t)=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1,\\quad 0\\le t\\le1.\n$$", "statement": "We assume:\n\u2022 $\\mathbf{X}_1, \\mathbf{X}_2$ are points in $\\mathbb{R}^n$ [tc_1].\nDefinition:\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = (1-t)\\mathbf{X}_1 + t\\mathbf{X}_2$ for $t \\in [0,1]$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n(tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousAt f X1 \u2227 ContinuousAt f X2 \u2227 DifferentiableOn \u211d f L)\n(def_1 : \u2200 t : \u211d, t \u2208 [0,1] \u2192 ((1 - t) \u2022 X1 + t \u2022 X2) \u2208 L)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly represents points in \u211d\u207f using 'Fin n \u2192 \u211d', which is the standard way to represent n-dimensional vectors in Lean", "The natural language states 't \u2208 [0,1]' as a condition, but in Lean this appears as part of the definition of L and as a premise in def_1, not as a standalone condition. The Lean formalization also introduces additional mathematical concepts (ContinuousAt f X1, ContinuousAt f X2, DifferentiableOn \u211d f L) that are not mentioned in the natural language at all", "The natural language presents the parameterization as a conclusion/definition, but the Lean formalization splits this into two parts: tc_1 defines L as a set containing points of the form t \u2022 X2 + (1 - t) \u2022 X1, and def_1 states that points of the form (1 - t) \u2022 X1 + t \u2022 X2 belong to L. Additionally, the Lean version introduces continuity and differentiability conditions for function f that are completely absent from the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly represents points in \u211d\u207f using 'Fin n \u2192 \u211d', which is the standard way to represent n-dimensional vectors in Lean\", \"The natural language states 't \u2208 [0,1]' as a condition, but in Lean this appears as part of the definition of L and as a premise in def_1, not as a standalone condition. The Lean formalization also introduces additional mathematical concepts (ContinuousAt f X1, ContinuousAt f X2, DifferentiableOn \u211d f L) that are not mentioned in the natural language at all\", 'The natural language presents the parameterization as a conclusion/definition, but the Lean formalization splits this into two parts: tc_1 defines L as a set containing points of the form t \u2022 X2 + (1 - t) \u2022 X1, and def_1 states that points of the form (1 - t) \u2022 X1 + t \u2022 X2 belong to L. Additionally, the Lean version introduces continuity and differentiability conditions for function f that are completely absent from the natural language statement']"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "Our hypotheses imply that the function\n$$\nh(t)=f(\\mathbf{X}(t))\n$$", "statement": "We assume:\n\u2022 $f$ is a function from $\\mathbb{R}^n$ to $\\mathbb{R}$ [tc_1].\n\u2022 $\\mathbf{X}(t)$ is a path in $\\mathbb{R}^n$ [def_1].\nDefinition:\n\u2022 A single-variable function $h(t)$ is defined as the composition $h(t) = f(\\mathbf{X}(t))$ for $t \\in [0,1]$ [def_2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n(tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousAt f X1 \u2227 ContinuousAt f X2 \u2227 DifferentiableOn \u211d f L)\n(def_1 : \u2200 t : \u211d, t \u2208 [0,1] \u2192 ((1 - t) \u2022 X1 + t \u2022 X2) \u2208 L)\n(h : \u211d \u2192 \u211d) (h_def : \u2200 t : \u211d, t \u2208 [0,1] \u2192 h t = f (((1 - t) \u2022 X1) + (t \u2022 X2)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly represents f as a function from \u211d\u207f to \u211d using (Fin n \u2192 \u211d) \u2192 \u211d, but tc_1 includes many additional properties (continuity, differentiability, set L definition) that are not mentioned in the natural language condition.", "The natural language describes X(t) as a general path in \u211d\u207f, but the Lean formalization restricts it to a specific linear interpolation between two fixed points X1 and X2. This is much more restrictive than a general path.", "The natural language defines h(t) = f(X(t)) for a general path X(t), but the Lean version defines h specifically as f applied to a linear combination (1-t)\u2022X1 + t\u2022X2. This is a very specific case rather than the general composition described in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly represents f as a function from \u211d\u207f to \u211d using (Fin n \u2192 \u211d) \u2192 \u211d, but tc_1 includes many additional properties (continuity, differentiability, set L definition) that are not mentioned in the natural language condition.', 'The natural language describes X(t) as a general path in \u211d\u207f, but the Lean formalization restricts it to a specific linear interpolation between two fixed points X1 and X2. This is much more restrictive than a general path.', 'The natural language defines h(t) = f(X(t)) for a general path X(t), but the Lean version defines h specifically as f applied to a linear combination (1-t)\u2022X1 + t\u2022X2. This is a very specific case rather than the general composition described in the natural language.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Our hypotheses imply that the function\n$$\nh(t)=f(\\mathbf{X}(t))\n$$\nis continuous on $[0,1]$ and differentiable on $(0,1)$.", "statement": "We assume:\n\u2022 $f$ is continuous and differentiable on the line segment $L$ [tc_1].\n\u2022 $\\mathbf{X}(t)$ parameterizes $L$ for $t \\in [0,1]$ [def_1].\n\u2022 $h(t) = f(\\mathbf{X}(t))$ [def_2].\nTherefore, we conclude:\n\u2022 The function $h(t)$ is continuous on the interval $[0,1]$ and differentiable on $(0,1)$ [l1].", "dependencies": ["tc_1", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (h : \u211d \u2192 \u211d)\n  (tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousAt f X1 \u2227 ContinuousAt f X2 \u2227 DifferentiableOn \u211d f L)\n  (def_1 : \u2200 t : \u211d, t \u2208 [0,1] \u2192 ((1 - t) \u2022 X1 + t \u2022 X2) \u2208 L)\n  (h_def : \u2200 t : \u211d, t \u2208 [0,1] \u2192 h t = f (((1 - t) \u2022 X1) + (t \u2022 X2))) :\n  ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (h : \u211d \u2192 \u211d)\n  (tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, t \u2208 Set.Icc 0 1 \u2227 x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousOn f L \u2227 DifferentiableOn \u211d f L)\n  (def_1 : \u2200 t : \u211d, t \u2208 Set.Icc 0 1 \u2192 ((1 - t) \u2022 X1 + t \u2022 X2) \u2208 L)\n  (h_def : \u2200 t : \u211d, t \u2208 Set.Icc 0 1 \u2192 h t = f ((1 - t) \u2022 X1 + t \u2022 X2)) :\n  ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n  constructor\n  \u00b7 apply ContinuousOn.comp tc_1.2.1\n    \u00b7 exact fun t ht => def_1 t ht\n    \u00b7 refine continuousOn_id.smul continuousOn_const |>.add (continuousOn_const.sub continuousOn_id |>.smul continuousOn_const)\n  \u00b7 apply DifferentiableOn.comp tc_1.2.2\n    \u00b7 exact fun t ht => def_1 t (Set.Ioo_subset_Icc_self ht)\n    \u00b7 refine (differentiableOn_id.const_smul _).add ((differentiableOn_const _).sub differentiableOn_id |>.smul _)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 4, "endLine": 12, "endColumn": 36, "data": "tactic 'apply' failed, failed to unify\n  ContinuousOn (f \u2218 ?m.2950) ?m.2951\nwith\n  ContinuousOn h (Set.Icc 0 1)\ncase left\nn : \u2115\nX1 X2 : Fin n \u2192 \u211d\nL : Set (Fin n \u2192 \u211d)\nf : (Fin n \u2192 \u211d) \u2192 \u211d\nh : \u211d \u2192 \u211d\ntc_1 : L = {x | \u2203 t \u2208 Set.Icc 0 1, x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousOn f L \u2227 DifferentiableOn \u211d f L\ndef_1 : \u2200 t \u2208 Set.Icc 0 1, (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L\nh_def : \u2200 t \u2208 Set.Icc 0 1, h t = f ((1 - t) \u2022 X1 + t \u2022 X2)\n\u22a2 ContinuousOn h (Set.Icc 0 1)"}, {"line": 15, "column": 4, "endLine": 15, "endColumn": 40, "data": "tactic 'apply' failed, failed to unify\n  DifferentiableOn \u211d (f \u2218 ?m.3697) ?m.3698\nwith\n  DifferentiableOn \u211d h (Set.Ioo 0 1)\ncase right\nn : \u2115\nX1 X2 : Fin n \u2192 \u211d\nL : Set (Fin n \u2192 \u211d)\nf : (Fin n \u2192 \u211d) \u2192 \u211d\nh : \u211d \u2192 \u211d\ntc_1 : L = {x | \u2203 t \u2208 Set.Icc 0 1, x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousOn f L \u2227 DifferentiableOn \u211d f L\ndef_1 : \u2200 t \u2208 Set.Icc 0 1, (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L\nh_def : \u2200 t \u2208 Set.Icc 0 1, h t = f ((1 - t) \u2022 X1 + t \u2022 X2)\n\u22a2 DifferentiableOn \u211d h (Set.Ioo 0 1)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The continuity assumption for f is significantly weakened in the Lean formalization. Natural language requires f to be continuous on the entire line segment L, but Lean only provides continuity at endpoints X1 and X2. This makes the formalization logically insufficient to prove the stated conclusion.", "The parameterization of the line segment L is correctly captured, representing the line segment between X1 and X2 with parameter t \u2208 [0,1].", "The definition of h(t) as the composition f(\ud835\udc17(t)) is correctly formalized with the explicit parameterization substituted.", "The conclusion about h(t) being continuous on [0,1] and differentiable on (0,1) is perfectly captured using the appropriate Lean notation for closed and open intervals.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The continuity assumption for f is significantly weakened in the Lean formalization. Natural language requires f to be continuous on the entire line segment L, but Lean only provides continuity at endpoints X1 and X2. This makes the formalization logically insufficient to prove the stated conclusion.', 'The parameterization of the line segment L is correctly captured, representing the line segment between X1 and X2 with parameter t \u2208 [0,1].', 'The definition of h(t) as the composition f(\ud835\udc17(t)) is correctly formalized with the explicit parameterization substituted.', 'The conclusion about h(t) being continuous on [0,1] and differentiable on (0,1) is perfectly captured using the appropriate Lean notation for closed and open intervals.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since\n$$\nx_i(t)=tx_{i2}+(1-t)x_{i1},\n$$\n\\eqref{eq:5.4.20} implies that\n$$\nh'(t)=\\sum_{i=1}^n f_{x_i}(\\mathbf{X}(t))(x_{i2}-x_{i1}),\\quad 0<t<1.\n$$", "statement": "We assume:\n\u2022 $f$ is differentiable on $L$ with partial derivatives $f_{x_i}$ [tc_1].\n\u2022 $\\mathbf{X}(t) = (1-t)\\mathbf{X}_1 + t\\mathbf{X}_2$ [def_1].\n\u2022 $h(t) = f(\\mathbf{X}(t))$ [def_2].\nTherefore, we conclude:\n\u2022 By the multivariable chain rule, the derivative of $h(t)$ for $t \\in (0,1)$ is $h'(t) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}(t))(x_{i2}-x_{i1})$ [l2].", "dependencies": ["tc_1", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d) ) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : DifferentiableOn \u211d f L)\n  (def_1 : \u2200 t : \u211d, (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L)\n  (h : \u211d \u2192 \u211d) (def_2 : \u2200 t : \u211d, h t = f ((1 - t) \u2022 X1 + t \u2022 X2)) :\n  \u2200 t : \u211d, t \u2208 Ioo 0 1 \u2192 HasDerivAt h (\u2211 i : Fin n, partialD f (fun x : (Fin n \u2192 \u211d) => x i) ((1 - t) \u2022 X1 + t \u2022 X2) * (X2 i - X1 i)) t := by\nsorry", "lean_pass": false, "error_msg": [{"line": 10, "column": 15, "endLine": 10, "endColumn": 22, "data": "function expected at\n  Ioo\nterm has type\n  ?m.1549"}, {"line": 10, "column": 52, "endLine": 10, "endColumn": 115, "data": "function expected at\n  partialD\nterm has type\n  ?m.4511"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d) ) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : DifferentiableOn \u211d f L)\n  (def_1 : \u2200 t : \u211d, (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L)\n  (h : \u211d \u2192 \u211d) (def_2 : \u2200 t : \u211d, h t = f ((1 - t) \u2022 X1 + t \u2022 X2)) :\n  \u2200 t : \u211d, t \u2208 Set.Ioo 0 1 \u2192 HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f ((1 - t) \u2022 X1 + t \u2022 X2)) (Pi.single i (X2 i - X1 i))) t := by\n  intro t ht\n  have hX : DifferentiableAt \u211d (fun t' => (1 - t') \u2022 X1 + t' \u2022 X2) t := by\n    apply DifferentiableAt.add\n    \u00b7 apply DifferentiableAt.smul\n      \u00b7 exact differentiableAt_id'.sub (differentiableAt_const 1)\n      \u00b7 exact differentiableAt_const X1\n    \u00b7 apply DifferentiableAt.smul\n      \u00b7 exact differentiableAt_id'\n      \u00b7 exact differentiableAt_const X2\n  have hf : DifferentiableAt \u211d f ((1 - t) \u2022 X1 + t \u2022 X2) := by\n    apply DifferentiableOn.differentiableAt tc_1 (def_1 t)\n    exact mem_nhds_iff.mpr \u27e8Set.Ioo 0 1, Set.Ioo_subset_Icc_self, isOpen_Ioo, ht\u27e9\n  rw [def_2]\n  exact hasDerivAt_comp_iff'.mp (HasFDerivAt.comp_hasDerivAt t hf.hasFDerivAt hX.hasDerivAt)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 14, "endLine": 15, "endColumn": 65, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 40, "endLine": 15, "endColumn": 64, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 40, "endLine": 15, "endColumn": 64, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 14, "endLine": 15, "endColumn": 65, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 14, "endLine": 15, "endColumn": 65, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 8, "endLine": 15, "endColumn": 65, "data": "type mismatch\n  DifferentiableAt.sub differentiableAt_id' (differentiableAt_const 1)\nhas type\n  DifferentiableAt ?m.9804 (fun y => y - 1) ?m.9812 : Prop\nbut is expected to have type\n  DifferentiableAt \u211d (HSub.hSub 1) t : Prop"}, {"line": 21, "column": 49, "endLine": 21, "endColumn": 58, "data": "application type mismatch\n  DifferentiableOn.differentiableAt tc_1 (def_1 t)\nargument\n  def_1 t\nhas type\n  (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L : Prop\nbut is expected to have type\n  L \u2208 \ud835\udcdd ?m.16669 : Prop"}, {"line": 22, "column": 4, "endLine": 22, "endColumn": 81, "data": "no goals to be solved"}, {"line": 23, "column": 6, "endLine": 23, "endColumn": 11, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  h ?t\nn : \u2115\nX1 X2 : Fin n \u2192 \u211d\nL : Set (Fin n \u2192 \u211d)\nf : (Fin n \u2192 \u211d) \u2192 \u211d\ntc_1 : DifferentiableOn \u211d f L\ndef_1 : \u2200 (t : \u211d), (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L\nh : \u211d \u2192 \u211d\ndef_2 : \u2200 (t : \u211d), h t = f ((1 - t) \u2022 X1 + t \u2022 X2)\nt : \u211d\nht : t \u2208 Set.Ioo 0 1\nhX : DifferentiableAt \u211d (fun t' => (1 - t') \u2022 X1 + t' \u2022 X2) t\nhf : DifferentiableAt \u211d f ((1 - t) \u2022 X1 + t \u2022 X2)\n\u22a2 HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f ((1 - t) \u2022 X1 + t \u2022 X2)) (Pi.single i (X2 i - X1 i))) t"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "From the mean value theorem for functions of one variable\n(Theorem~\\ref{thmtype:2.3.11}),\n$$\nh(1)-h(0)=h'(t_0)\n$$\nfor some $t_0\\in (0,1)$.", "statement": "We assume:\n\u2022 $h(t)$ is continuous on $[0,1]$ and differentiable on $(0,1)$ [l1].\n\u2022 The Mean Value Theorem holds for single-variable functions [def_mvt].\nTherefore, we conclude:\n\u2022 There exists some $t_0 \\in (0,1)$ such that $h(1) - h(0) = (1-0)h'(t_0) = h'(t_0)$ [l3].", "dependencies": ["l1", "def_mvt"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (h : \u211d \u2192 \u211d)\n  (l1 : ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1))\n  (def_mvt : \u2200 (g : \u211d \u2192 \u211d) (a b : \u211d), ContinuousOn g (Set.Icc a b) \u2192 DifferentiableOn \u211d g (Set.Ioo a b) \u2192 \u2203 c : \u211d, c \u2208 Set.Ioo a b \u2227 g b - g a = (b - a) * (deriv g c)) :\n  \u2203 t_0 : \u211d, t_0 \u2208 Set.Ioo 0 1 \u2227 h 1 - h 0 = (1 - 0) * deriv h t_0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (h : \u211d \u2192 \u211d)\n  (l1 : ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1))\n  (def_mvt : \u2200 (g : \u211d \u2192 \u211d) (a b : \u211d), ContinuousOn g (Set.Icc a b) \u2192 DifferentiableOn \u211d g (Set.Ioo a b) \u2192 \u2203 c : \u211d, c \u2208 Set.Ioo a b \u2227 g b - g a = (b - a) * (deriv g c)) :\n  \u2203 t_0 : \u211d, t_0 \u2208 Set.Ioo 0 1 \u2227 h 1 - h 0 = (1 - 0) * deriv h t_0 := by\n  exact def_mvt h 0 1 l1.left l1.right", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The continuity assumption is correctly formalized using ContinuousOn with the appropriate closed interval Set.Icc 0 1.", "The differentiability assumption is correctly formalized using DifferentiableOn with the appropriate open interval Set.Ioo 0 1.", "The Mean Value Theorem assumption is properly formalized with the correct universal quantification and logical structure, capturing the essence of MVT for single-variable functions.", "The existence claim for t_0 in the open interval (0,1) is correctly captured using existential quantification and Set.Ioo 0 1.", "The conclusion equation is mathematically equivalent to the natural language version. The Lean keeps (1-0) unexpanded while natural language shows the simplification, but both represent the same mathematical relationship."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since $h(1)=f(\\mathbf{X}_2)$ and\n$h(0)=f(\\mathbf{X}_1)$", "statement": "We assume:\n\u2022 $\\mathbf{X}(t) = (1-t)\\mathbf{X}_1 + t\\mathbf{X}_2$ [def_1].\n\u2022 $h(t) = f(\\mathbf{X}(t))$ [def_2].\nTherefore, we conclude:\n\u2022 At the endpoints, $h(0) = f(\\mathbf{X}(0)) = f(\\mathbf{X}_1)$ and $h(1) = f(\\mathbf{X}(1)) = f(\\mathbf{X}_2)$ [l4].", "dependencies": ["def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (def_1 : \u2200 t : \u211d, ((1 - t) \u2022 X1 + t \u2022 X2) = ((1 - t) \u2022 X1 + t \u2022 X2)) -- This definition is problematic as it does not define X(t) but is self-referential\n  (def_2 : \u2200 t : \u211d, (t \u2208 [0,1] \u2192 (f ((1 - t) \u2022 X1 + t \u2022 X2)) = (f ((1 - t) \u2022 X1 + t \u2022 X2)))) : -- Similar issue as def_1\n  (f (X1) = f (X1)) \u2227 (f (X2) = f (X2)) := by -- These are tautologies. The original goal needs to be derived using the definitions.\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (f : (Fin n \u2192 \u211d) \u2192 \u211d) :\n  f (X1) = f ((1 - 0) \u2022 X1 + 0 \u2022 X2) \u2227 f (X2) = f ((1 - 1) \u2022 X1 + 1 \u2022 X2) := by\n  constructor\n  \u00b7 simp\n  \u00b7 simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The definition def_1 is self-referential and doesn't actually define X(t) as a function. It should be something like 'let X := fun t => (1 - t) \u2022 X1 + t \u2022 X2'", "The definition def_2 is also self-referential and doesn't define h(t). It should define h in terms of X(t) and f. The domain restriction [0,1] is also not mentioned in the natural language", "The conclusion reduces to tautologies (f(X1) = f(X1) \u2227 f(X2) = f(X2)) rather than the meaningful endpoint evaluations described in the natural language. It should show h(0) = f(X1) and h(1) = f(X2)", "The overall logical structure fails to capture the definitional reasoning of the natural language. The broken definitions cannot support deriving the intended conclusions about endpoint evaluations"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The definition def_1 is self-referential and doesn't actually define X(t) as a function. It should be something like 'let X := fun t => (1 - t) \u2022 X1 + t \u2022 X2'\", \"The definition def_2 is also self-referential and doesn't define h(t). It should define h in terms of X(t) and f. The domain restriction [0,1] is also not mentioned in the natural language\", 'The conclusion reduces to tautologies (f(X1) = f(X1) \u2227 f(X2) = f(X2)) rather than the meaningful endpoint evaluations described in the natural language. It should show h(0) = f(X1) and h(1) = f(X2)', 'The overall logical structure fails to capture the definitional reasoning of the natural language. The broken definitions cannot support deriving the intended conclusions about endpoint evaluations']"}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "=(d_{\\mathbf{X}_0}f)(\\mathbf{X}_2\n-\\mathbf{X}_1)", "statement": "Definition:\n\u2022 The differential of a function $f$ at a point $\\mathbf{X}_0$, applied to a vector $\\mathbf{V} = (v_1, \\dots, v_n)$, is given by $(d_{\\mathbf{X}_0}f)(\\mathbf{V}) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}_0) v_i$ [def_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} {\u03b1 : Type*} [Fintype (Fin n)] [DecidableEq (Fin n)] [Real.InnerProductSpace \u03b1]\nvariable (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 V : Fin n \u2192 \u211d)\nvariable (def_3 : (d_X\u2080 f) V = \u2211 i : Fin n, (partialFDeriv f i) X\u2080 * (V i))", "lean_pass": false, "error_msg": [{"line": 5, "column": 70, "endLine": 5, "endColumn": 94, "data": "unknown constant 'Real.InnerProductSpace'"}, {"line": 7, "column": 19, "endLine": 7, "endColumn": 25, "data": "function expected at\n  d_X\u2080\nterm has type\n  ?m.62"}, {"line": 7, "column": 45, "endLine": 7, "endColumn": 62, "data": "function expected at\n  partialFDeriv\nterm has type\n  ?m.407"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "Since $h(1)=f(\\mathbf{X}_2)$ and\n$h(0)=f(\\mathbf{X}_1)$, this implies \\eqref{eq:5.4.21} with\n$\\mathbf{X}_0=\\mathbf{X}(t_0)$.", "statement": "We assume:\n\u2022 There exists $t_0 \\in (0,1)$ such that $h(1) - h(0) = h'(t_0)$ [l3].\n\u2022 $h(0) = f(\\mathbf{X}_1)$ and $h(1) = f(\\mathbf{X}_2)$ [l4].\n\u2022 The derivative is $h'(t) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}(t))(x_{i2}-x_{i1})$ [l2].\n\u2022 The line is $\\mathbf{X}(t) = (1-t)\\mathbf{X}_1 + t\\mathbf{X}_2$ [def_1].\n\u2022 The differential is $(d_{\\mathbf{X}_0}f)(\\mathbf{V}) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}_0) v_i$ [def_3].\nTherefore, we conclude:\n\u2022 There exists a point $\\mathbf{X}_0 = \\mathbf{X}(t_0)$ on the line segment $L$ distinct from $\\mathbf{X}_1$ and $\\mathbf{X}_2$ such that $f(\\mathbf{X}_2) - f(\\mathbf{X}_1) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}_0)(x_{i2}-x_{i1})$ and this sum is equal to $(d_{\\mathbf{X}_0}f)(\\mathbf{X}_2 - \\mathbf{X}_1)$ [ts_1].", "dependencies": ["def_1", "l2", "l3", "l4", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = t \u2022 X2 + (1 - t) \u2022 X1} \u2227 ContinuousOn f L \u2227 DifferentiableOn \u211d f L)\n  (def_1 : \u2200 t : \u211d, t \u2208 [0,1] \u2192 ((1 - t) \u2022 X1 + t \u2022 X2) \u2208 L)\n  (l2 : \u2200 (h : \u211d \u2192 \u211d) (X : \u211d \u2192 (Fin n \u2192 \u211d)), (\u2200 t : \u211d, X t = (1-t) \u2022 X1 + t \u2022 X2) \u2192 (\u2200 t : \u211d, h t = f (X t)) \u2192 (\u2200 t \u2208 Set.Ioo 0 1, HasFDerivAt h ((fun t_val => \u2211 i : Fin n, (partialFDeriv f (X t_val) i) * (X2 i - X1 i)) t) t))\n  (l3 : \u2203 t_0 : \u211d, t_0 \u2208 Set.Ioo 0 1 \u2227 (f ((1 - 1) \u2022 X1 + 1 \u2022 X2) - f ((1 - 0) \u2022 X1 + 0 \u2022 X2)) = ((1 - 0) * (\u2211 i : Fin n, (partialFDeriv f ((1 - t_0) \u2022 X1 + t_0 \u2022 X2) i) * (X2 i - X1 i))))\n  (l4 : f X1 = f X1 \u2227 f X2 = f X2)\n  (def_3 : \u2200 (X0 : Fin n \u2192 \u211d) (V : Fin n \u2192 \u211d), (hasUnbundledDifferentialAt f X0 V) = (\u2211 i : Fin n, (partialFDeriv f X0 i) * (V i))) :\n  \u2203 X_0 : Fin n \u2192 \u211d, (X_0 \u2208 L \u2227 X_0 \u2260 X1 \u2227 X_0 \u2260 X2) \u2227 (f X2 - f X1 = \u2211 i : Fin n, (partialFDeriv f X_0 i) * (X2 i - X1 i)) \u2227 ((\u2211 i : Fin n, (partialFDeriv f X_0 i) * (X2 i - X1 i)) = (hasUnbundledDifferentialAt f X_0 (X2 - X1))) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 174, "endLine": 9, "endColumn": 201, "data": "function expected at\n  partialFDeriv\nterm has type\n  ?m.5033"}, {"line": 10, "column": 123, "endLine": 10, "endColumn": 168, "data": "function expected at\n  partialFDeriv\nterm has type\n  ?m.5033"}, {"line": 12, "column": 48, "endLine": 12, "endColumn": 81, "data": "function expected at\n  hasUnbundledDifferentialAt\nterm has type\n  ?m.13921"}, {"line": 12, "column": 100, "endLine": 12, "endColumn": 120, "data": "function expected at\n  partialFDeriv\nterm has type\n  ?m.5033"}, {"line": 13, "column": 84, "endLine": 13, "endColumn": 105, "data": "function expected at\n  partialFDeriv\nterm has type\n  ?m.5033"}, {"line": 13, "column": 142, "endLine": 13, "endColumn": 163, "data": "function expected at\n  partialFDeriv\nterm has type\n  ?m.5033"}, {"line": 13, "column": 185, "endLine": 13, "endColumn": 227, "data": "function expected at\n  hasUnbundledDifferentialAt\nterm has type\n  ?m.13921"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (X1 X2 : Fin n \u2192 \u211d) (L : Set (Fin n \u2192 \u211d)) (f : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : L = {x : (Fin n \u2192 \u211d) | \u2203 t : \u211d, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = (1 - t) \u2022 X1 + t \u2022 X2} \u2227 ContinuousOn f L \u2227 DifferentiableOn \u211d f L)\n  (def_1 : \u2200 t : \u211d, t \u2208 [0,1] \u2192 ((1 - t) \u2022 X1 + t \u2022 X2) \u2208 L)\n  (l2 : \u2200 (h : \u211d \u2192 \u211d) (X : \u211d \u2192 (Fin n \u2192 \u211d)), (\u2200 t : \u211d, X t = (1-t) \u2022 X1 + t \u2022 X2) \u2192 (\u2200 t : \u211d, h t = f (X t)) \u2192 (\u2200 t \u2208 Set.Ioo 0 1, HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t) (Pi.single i 1)) * (X2 i - X1 i)) t))\n  (l3 : \u2203 t_0 : \u211d, t_0 \u2208 Set.Ioo 0 1 \u2227 (f X2 - f X1) = \u2211 i : Fin n, (fderiv \u211d f ((1 - t_0) \u2022 X1 + t_0 \u2022 X2) (Pi.single i 1)) * (X2 i - X1 i))\n  (l4 : f X1 = f X1 \u2227 f X2 = f X2)\n  (def_3 : \u2200 (X0 : Fin n \u2192 \u211d) (V : Fin n \u2192 \u211d), fderiv \u211d f X0 V = \u2211 i : Fin n, (fderiv \u211d f X0 (Pi.single i 1)) * (V i)) :\n  \u2203 X_0 : Fin n \u2192 \u211d, (X_0 \u2208 L \u2227 X_0 \u2260 X1 \u2227 X_0 \u2260 X2) \u2227 (f X2 - f X1 = \u2211 i : Fin n, (fderiv \u211d f X_0 (Pi.single i 1)) * (X2 i - X1 i)) \u2227 ((\u2211 i : Fin n, (fderiv \u211d f X_0 (Pi.single i 1)) * (X2 i - X1 i)) = fderiv \u211d f X_0 (X2 - X1)) := by\n  obtain \u27e8t\u2080, ht\u2080, h\u27e9 := l3\n  use (1 - t\u2080) \u2022 X1 + t\u2080 \u2022 X2\n  refine \u27e8\u27e8?_, ?_, ?_\u27e9, \u27e8?_, ?_\u27e9\u27e9\n  \u00b7 simp [tc_1.1, t\u2080, ht\u2080.1, ht\u2080.2]\n  \u00b7 intro hX0\n    have : t\u2080 = 0 := by\n      simp [smul_sub, sub_smul] at hX0\n      linear_combination hX0\n    exact ht\u2080.1.ne' this\n  \u00b7 intro hX0\n    have : t\u2080 = 1 := by\n      simp [smul_sub, sub_smul] at hX0\n      linear_combination hX0\n    exact ht\u2080.2.ne this\n  \u00b7 exact h\n  \u00b7 rw [def_3]\n    simp only [Pi.sub_apply]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 4, "endLine": 17, "endColumn": 35, "data": "invalid argument, variable is not a proposition or let-declaration"}, {"line": 17, "column": 2, "endLine": 17, "endColumn": 35, "data": "unsolved goals\ncase h.refine_1\nn : \u2115\nX1 X2 : Fin n \u2192 \u211d\nL : Set (Fin n \u2192 \u211d)\nf : (Fin n \u2192 \u211d) \u2192 \u211d\ntc_1 : L = {x | \u2203 t, 0 \u2264 t \u2227 t \u2264 1 \u2227 x = (1 - t) \u2022 X1 + t \u2022 X2} \u2227 ContinuousOn f L \u2227 DifferentiableOn \u211d f L\ndef_1 : \u2200 t \u2208 [0, 1], (1 - t) \u2022 X1 + t \u2022 X2 \u2208 L\nl2 :\n  \u2200 (h : \u211d \u2192 \u211d) (X : \u211d \u2192 Fin n \u2192 \u211d),\n    (\u2200 (t : \u211d), X t = (1 - t) \u2022 X1 + t \u2022 X2) \u2192\n      (\u2200 (t : \u211d), h t = f (X t)) \u2192\n        \u2200 t \u2208 Set.Ioo 0 1, HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X2 i - X1 i)) t\nl4 : f X1 = f X1 \u2227 f X2 = f X2\ndef_3 : \u2200 (X0 V : Fin n \u2192 \u211d), (fderiv \u211d f X0) V = \u2211 i : Fin n, (fderiv \u211d f X0) (Pi.single i 1) * V i\nt\u2080 : \u211d\nht\u2080 : t\u2080 \u2208 Set.Ioo 0 1\nh : f X2 - f X1 = \u2211 i : Fin n, (fderiv \u211d f ((1 - t\u2080) \u2022 X1 + t\u2080 \u2022 X2)) (Pi.single i 1) * (X2 i - X1 i)\n\u22a2 \u2203 t, 0 \u2264 t \u2227 t \u2264 1 \u2227 (1 - t\u2080) \u2022 X1 + t\u2080 \u2022 X2 = (1 - t) \u2022 X1 + t \u2022 X2"}, {"line": 21, "column": 6, "endLine": 21, "endColumn": 28, "data": "type mismatch\n  Mathlib.Tactic.LinearCombination.eq_of_eq hX0 ?a\u271d\nhas type\n  ?m.18783 = ?m.18785 : Prop\nbut is expected to have type\n  t\u2080 = 0 : Prop"}, {"line": 26, "column": 6, "endLine": 26, "endColumn": 28, "data": "type mismatch\n  Mathlib.Tactic.LinearCombination.eq_of_eq hX0 ?a\u271d\nhas type\n  ?m.19962 = ?m.19964 : Prop\nbut is expected to have type\n  t\u2080 = 1 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_mvt", "label": "def_mvt", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_mvt", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    