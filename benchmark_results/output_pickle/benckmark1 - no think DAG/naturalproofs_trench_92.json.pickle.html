
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: A point $\overline{x}$ is a limit
point of a set $S$ if and only if there is a sequence $\{x_n\}$ of points
in $S$ such that $x_n
e\overline{x}$ for $n\ge 1,$ and
$$
\lim_{n	o\infty}x_n=\overline{x}.
$$

Proof: For sufficiency, suppose that the stated condition holds.
Then, for each $\epsilon>0$, there is an integer $N$ such
that $0<|x_n-x|<\epsilon$ if $n\ge N$. Therefore, every
$\epsilon$-neighborhood of $\overline{x}$ contains infinitely many
points of $S$. This means that $\overline{x}$ is a limit point of $S$.
For necessity, let $\overline{x}$ be a limit point of $S$. Then,
for every integer $n\ge1$,
the interval  $(\overline{x}-1/n,\overline{x}+1/n)$
contains
a point $x_n\ (
e\overline{x})$ in $S$. Since
$|x_m-\overline{x}|\le1/n$ if $m\ge n$, $\lim_{n	o\infty}x_n=
\overline{x}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "For sufficiency, suppose that the stated condition holds.", "statement": "Premise:\n\u2022 There is a sequence $\\{x_n\\}_{n\\geq 1}$ of points in a set $S$ such that $x_n\ne\\overline{x}$ for all $n\\ge 1,$ and $\\lim_{n\\to\\infty}x_n=\\overline{x}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n(tc_1 : \u2203 (x : \u2115 \u2192 \u03b1), (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the existence of a sequence with domain \u2115 (natural numbers) where each term for n \u2265 1 is in set S. The existential quantifier and the condition \u2200 n \u2265 1, x n \u2208 S perfectly match the mathematical statement.", "The Lean condition x n \u2260 x_bar within the universal quantification \u2200 n \u2265 1 exactly matches the natural language condition that x_n \u2260 x\u0304 for all n \u2265 1.", "The Lean formalization uses Filter.Tendsto x Filter.atTop (nhds x_bar) which is the standard way to express lim_{n\u2192\u221e} x_n = x\u0304 in Mathlib. This is a perfect match for the limit condition."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Then, for each $\\epsilon>0$, there is an integer $N$ such that $0<|x_n-x|<\\epsilon$ if $n\\ge N$.", "statement": "We assume:\n\u2022 There is a sequence $\\{x_n\\}_{n\\geq 1}$ of points in a set $S$ such that $x_n\ne\\overline{x}$ for all $n\\ge 1,$ and $\\lim_{n\\to\\infty}x_n=\\overline{x}$ [tc_1].\nTherefore, we conclude:\n\u2022 For each $\\epsilon>0$, there exists an integer $N$ such that for all $n\\ge N$, we have $0<|x_n-\\overline{x}|<\\epsilon$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (tc_1 : \u2203 (x : \u2115 \u2192 \u03b1), (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, 0 < dist (Classical.choose tc_1 n) x_bar \u2227 dist (Classical.choose tc_1 n) x_bar < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (tc_1 : \u2203 (x : \u2115 \u2192 \u03b1), (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, 0 < dist (Classical.choose tc_1 n) x_bar \u2227 dist (Classical.choose tc_1 n) x_bar < \u03b5 := by\n  intro \u03b5 h\u03b5\n  let x := Classical.choose tc_1\n  have hx : (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar) := Classical.choose_spec tc_1\n  rcases Metric.tendsto_atTop.1 hx.2 \u03b5 h\u03b5 with \u27e8N, hN\u27e9\n  use max N 1\n  intro n hn\n  have hn' : n \u2265 N := le_of_max_le_left hn\n  have hn1 : n \u2265 1 := le_of_max_le_right hn\n  have hneq : x n \u2260 x_bar := (hx.1 n hn1).right\n  have hdist : dist (x n) x_bar < \u03b5 := hN n hn'\n  constructor\n  \u00b7 exact dist_pos.mpr hneq\n  \u00b7 exact hdist", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The premise establishes a sequence in set S with terms distinct from x_bar that converges to x_bar, and the conclusion properly formalizes the epsilon-delta definition with the additional positivity constraint. The use of general metric spaces and Classical.choose are appropriate technical choices that don't change the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Therefore, every $\\epsilon$-neighborhood of $\\overline{x}$ contains infinitely many points of $S$.", "statement": "We assume:\n\u2022 The sequence $\\{x_n\\}$ is in the set $S$ [tc_1].\n\u2022 For each $\\epsilon>0$, there exists an integer $N$ such that for all $n\\ge N$, we have $0<|x_n-\\overline{x}|<\\epsilon$ [l1].\nTherefore, we conclude:\n\u2022 Every $\\epsilon$-neighborhood of $\\overline{x}$ (the set of points $y$ with $|y - \\overline{x}| < \\epsilon$) contains infinitely many points of $S$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (tc_1 : \u2203 (x : \u2115 \u2192 \u03b1), (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, 0 < dist (Classical.choose tc_1 n) x_bar \u2227 dist (Classical.choose tc_1 n) x_bar < \u03b5) :\n  \u2200 \u03b5 > 0, Set.Infinite ({y : \u03b1 | dist y x_bar < \u03b5} \u2229 S) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (tc_1 : \u2203 (x : \u2115 \u2192 \u03b1), (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, 0 < dist (Classical.choose tc_1 n) x_bar \u2227 dist (Classical.choose tc_1 n) x_bar < \u03b5) :\n  \u2200 \u03b5 > 0, Set.Infinite ({y : \u03b1 | dist y x_bar < \u03b5} \u2229 S) := by\n  intro \u03b5 h\u03b5\n  let x := Classical.choose tc_1\n  have hx : \u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar := (Classical.choose_spec tc_1).1\n  have hlim : Tendsto x atTop (\ud835\udcdd x_bar) := (Classical.choose_spec tc_1).2\n  obtain \u27e8N, hN\u27e9 := l1 \u03b5 h\u03b5\n  have inj : \u2200 m n \u2265 N, x m = x n \u2192 m = n := by\n    intro m n hm hn heq\n    have hdist := hN m hm\n    have hdist' := hN n hn\n    rw [heq] at hdist'\n    exact lt_irrefl (dist (x n) x_bar) (lt_of_lt_of_le hdist.1 hdist'.2)\n  have hrange : Set.Infinite (Set.range (fun n => x (n + N))) := by\n    apply Set.infinite_range_of_injective\n    intro m n heq\n    exact Nat.add_left_cancel (inj (m + N) (n + N) (Nat.le_add_right _ _) (Nat.le_add_right _ _) heq)\n  apply Set.Infinite.mono _ hrange\n  intro y hy\n  obtain \u27e8n, rfl\u27e9 := hy\n  refine \u27e8x (n + N), \u27e8?_, hx (n + N) (Nat.le_add_left _ _).1\u27e9, rfl\u27e9\n  exact (hN (n + N) (Nat.le_add_right _ _)).2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 18, "endLine": 15, "endColumn": 20, "data": "unexpected token '\u2265'; expected ','"}, {"line": 9, "column": 60, "endLine": 15, "endColumn": 18, "data": "unsolved goals\ncase inj\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nS : Set \u03b1\nx_bar : \u03b1\ntc_1 : \u2203 x, (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Tendsto x atTop (\ud835\udcdd x_bar)\nl1 :\n  \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, 0 < Dist.dist (Classical.choose tc_1 n) x_bar \u2227 Dist.dist (Classical.choose tc_1 n) x_bar < \u03b5\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nx : \u2115 \u2192 \u03b1 := Classical.choose tc_1\nhx : \u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar\nhlim : Tendsto x atTop (\ud835\udcdd x_bar)\nN : \u2115\nhN : \u2200 n \u2265 N, 0 < Dist.dist (Classical.choose tc_1 n) x_bar \u2227 Dist.dist (Classical.choose tc_1 n) x_bar < \u03b5\n\u22a2 (m : ?m.3909) \u2192 ?m.3915 m \u2192 sorry\n\ncase intro\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nS : Set \u03b1\nx_bar : \u03b1\ntc_1 : \u2203 x, (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Tendsto x atTop (\ud835\udcdd x_bar)\nl1 :\n  \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, 0 < Dist.dist (Classical.choose tc_1 n) x_bar \u2227 Dist.dist (Classical.choose tc_1 n) x_bar < \u03b5\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nx : \u2115 \u2192 \u03b1 := Classical.choose tc_1\nhx : \u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar\nhlim : Tendsto x atTop (\ud835\udcdd x_bar)\nN : \u2115\nhN : \u2200 n \u2265 N, 0 < Dist.dist (Classical.choose tc_1 n) x_bar \u2227 Dist.dist (Classical.choose tc_1 n) x_bar < \u03b5\ninj : (m : ?m.3909) \u2192 ?m.3915 m \u2192 sorry\n\u22a2 ({y | Dist.dist y x_bar < \u03b5} \u2229 S).Infinite"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence membership is correctly formalized, though it includes additional convergence information and distinctness conditions not explicitly mentioned in the natural language. These additions are mathematically consistent and provide necessary context.", "The epsilon-delta condition is accurately translated using dist function and Classical.choose to extract the sequence. The logical structure perfectly matches the natural language statement.", "The conclusion about \u03b5-neighborhoods containing infinitely many points is correctly formalized using set intersection and Set.Infinite predicate, perfectly capturing the intended meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  {\u03b1 : Type*} [MetricSpace \u03b1] [DecidableEq \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (tc_1 : \u2203 (x : \u2115 \u2192 \u03b1), (\u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar) \u2227 Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, 0 < dist (Classical.choose tc_1 n) x_bar \u2227 dist (Classical.choose tc_1 n) x_bar < \u03b5) :\n  \u2203 \u03b5 > 0, \u00acSet.Infinite ({y : \u03b1 | dist y x_bar < \u03b5} \u2229 S) := by\n  let x := Classical.choose tc_1\n  have hx : \u2200 n \u2265 1, x n \u2208 S \u2227 x n \u2260 x_bar := (Classical.choose_spec tc_1).1\n  have hlim : Filter.Tendsto x Filter.atTop (nhds x_bar) := (Classical.choose_spec tc_1).2\n  use 1, zero_lt_one\n  intro hinf\n  have : \u2203 N : \u2115, \u2200 n \u2265 N, x n \u2209 {y | dist y x_bar < 1} \u2229 S := by\n    by_contra h\n    push_neg at h\n    have : \u2200 N, \u2203 n \u2265 N, x n \u2208 {y | dist y x_bar < 1} \u2229 S := by\n      intro N\n      exact h N\n    choose f hf using this\n    have : \u2200 N, f N \u2265 N \u2227 x (f N) \u2208 {y | dist y x_bar < 1} \u2229 S := hf\n    clear hf\n    have : \u2200 N, f N \u2265 N \u2227 dist (x (f N)) x_bar < 1 \u2227 x (f N) \u2208 S := by\n      intro N\n      simp only [Set.mem_setOf_eq, Set.mem_inter_iff] at (this N)\n      exact \u27e8(this N).1, (this N).2.1, (this N).2.2\u27e9\n    obtain \u27e8n, hn, hdist, hnS\u27e9 := this 1\n    have := hx n (by linarith [hn])\n    exact this.2 (dist_eq_zero.mp (le_antisymm hdist (dist_pos.mpr this.2).le))\n  exact hinf.finite.not_infinite (Set.finite_of_not_infinite this)"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "This means that $\\overline{x}$ is a limit point of $S$.", "statement": "We assume:\n\u2022 Every $\\epsilon$-neighborhood of $\\overline{x}$ contains infinitely many points of $S$ [l2].\nTherefore, we conclude:\n\u2022 The point $\\overline{x}$ is a limit point of the set $S$ [ts_1].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (l2 : \u2200 \u03b5 > 0, Set.Infinite ({y : \u03b1 | dist y x_bar < \u03b5} \u2229 S)) :\n  Metric.isLimitPoint x_bar S := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 2, "endLine": 8, "endColumn": 21, "data": "unknown identifier 'Metric.isLimitPoint'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} [MetricSpace \u03b1] (S : Set \u03b1) (x_bar : \u03b1)\n  (l2 : \u2200 \u03b5 > 0, Set.Infinite ({y : \u03b1 | dist y x_bar < \u03b5} \u2229 S)) :\n  ClusterPt x_bar (\ud835\udcdf S) := by\n  rw [clusterPt_iff]\n  intro U hU\n  rcases Metric.mem_nhds_iff.1 hU with \u27e8\u03b5, h\u03b5, hball\u27e9\n  have := l2 \u03b5 h\u03b5\n  simp only [Set.Infinite] at this\n  rcases this with \u27e8y, \u27e8hy, hyS\u27e9\u27e9\n  exact \u27e8y, hball hy, hyS\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 19, "endLine": 14, "endColumn": 33, "data": "rcases tactic failed: this : ({y | Dist.dist y x_bar < \u03b5} \u2229 S).Finite \u2192 False is not an inductive datatype"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}, "tc_2": {"id": "tc_2", "natural_language": "For necessity, let $\\overline{x}$ be a limit point of $S$.", "statement": "Premise:\n\u2022 The point $\\overline{x}$ is a limit point of the set $S$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03b1 : Type*} [TopologicalSpace \u03b1] (x_bar : \u03b1) (S : Set \u03b1)\n(tc_2 : x_bar \u2208 closure (S \\ {x_bar}))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning of 'x_bar is a limit point of set S' using the topologically equivalent condition 'x_bar \u2208 closure (S \\ {x_bar})'. The additional type declarations and variable specifications in Lean are necessary mathematical context not explicitly stated in natural language but are logically consistent."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l3": {"id": "l3", "natural_language": "Then, for every integer $n\\ge1$, the interval  $(\\overline{x}-1/n,\\overline{x}+1/n)$ contains a point $x_n\\ (\\ne\\overline{x})$ in $S$.", "statement": "We assume:\n\u2022 The point $\\overline{x}$ is a limit point of the set $S$ [tc_2].\nTherefore, we conclude:\n\u2022 For every integer $n\\ge1$, we can choose a point $x_n$ from the set $S$ such that $x_n \\ne \\overline{x}$ and $|x_n - \\overline{x}| < 1/n$ [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1] [MetricSpace \u03b1] (x_bar : \u03b1) (S : Set \u03b1)\n  (tc_2 : x_bar \u2208 closure (S \\ {x_bar})) :\n  \u2200 n : \u2115, \u2203 x_n : \u03b1, x_n \u2208 S \u2227 x_n \u2260 x_bar \u2227 dist x_n x_bar < 1 / (n : \u211d) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03b1 : Type*} [MetricSpace \u03b1] (x_bar : \u03b1) (S : Set \u03b1)\n  (tc_2 : x_bar \u2208 closure (S \\ {x_bar})) :\n  \u2200 n : \u2115, \u2203 x_n : \u03b1, x_n \u2208 S \u2227 x_n \u2260 x_bar \u2227 dist x_n x_bar < 1 / (n + 1 : \u211d) := by\n  intro n\n  have h := (Metric.mem_closure_iff.1 tc_2) (1 / (n + 1 : \u211d)) (by positivity)\n  obtain \u27e8x_n, \u27e8hx_nS, hx_n_ne\u27e9, hdist\u27e9 := h\n  refine \u27e8x_n, hx_nS, fun h \u21a6 hx_n_ne (by simp [h]), ?_\u27e9\n  rwa [dist_comm] at hdist", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 7, "endLine": 13, "endColumn": 16, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  Nat.dist ?n ?m\ncase intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nx_bar : \u03b1\nS : Set \u03b1\ntc_2 : x_bar \u2208 closure (S \\ {x_bar})\nn : \u2115\nx_n : \u03b1\nhdist : Dist.dist x_bar x_n < 1 / (\u2191n + 1)\nhx_nS : x_n \u2208 S\nhx_n_ne : x_n \u2209 {x_bar}\n\u22a2 Dist.dist x_n x_bar < 1 / (\u2191n + 1)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The limit point assumption is correctly formalized using closure of S minus the singleton set, which is mathematically equivalent to the natural language definition.", "The conclusion correctly captures the existence of points in S with the required distance property, but uses \u2115 (which includes 0) instead of restricting to n\u22651 as stated in natural language. This creates a technical issue when n=0, though the mathematical intent for positive n is preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The limit point assumption is correctly formalized using closure of S minus the singleton set, which is mathematically equivalent to the natural language definition.', 'The conclusion correctly captures the existence of points in S with the required distance property, but uses \u2115 (which includes 0) instead of restricting to n\u22651 as stated in natural language. This creates a technical issue when n=0, though the mathematical intent for positive n is preserved.']"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Since $|x_m-\\overline{x}|\\le1/n$ if $m\\ge n$, $\\lim_{n\\to\\infty}x_n= \\overline{x}$.", "statement": "We assume:\n\u2022 We have a sequence $\\{x_n\\}_{n \\ge 1}$ where for every integer $n\\ge1$, $x_n \\in S$, $x_n \\ne \\overline{x}$, and $|x_n - \\overline{x}| < 1/n$ [l3].\nTherefore, we conclude:\n\u2022 There exists a sequence $\\{x_n\\}_{n\\geq 1}$ of points in $S$ such that $x_n\\ne\\overline{x}$ for all $n\\ge 1,$ and $\\lim_{n\\to\\infty}x_n=\\overline{x}$ [ts_2].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {\u03b1 : Type*} [TopologicalSpace \u03b1] [MetricSpace \u03b1] (x_bar : \u03b1) (S : Set \u03b1)\n  (l3 : \u2200 n : \u2115, \u2203 x_n : \u03b1, x_n \u2208 S \u2227 x_n \u2260 x_bar \u2227 dist x_n x_bar < 1 / (n : \u211d)) :\n  \u2203 (x_n : \u2115 \u2192 \u03b1), (\u2200 n : \u2115, x_n n \u2208 S \u2227 x_n n \u2260 x_bar) \u2227 (Tendsto x_n atTop (\ud835\udcdd x_bar)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {\u03b1 : Type*} [TopologicalSpace \u03b1] [MetricSpace \u03b1] (x_bar : \u03b1) (S : Set \u03b1)\n  (l3 : \u2200 n : \u2115, \u2203 x_n : \u03b1, x_n \u2208 S \u2227 x_n \u2260 x_bar \u2227 dist x_n x_bar < 1 / (n : \u211d)) :\n  \u2203 (x_n : \u2115 \u2192 \u03b1), (\u2200 n : \u2115, x_n n \u2208 S \u2227 x_n n \u2260 x_bar) \u2227 (Tendsto x_n atTop (\ud835\udcdd x_bar)) := by\n  choose x_n hx_n using l3\n  use x_n\n  constructor\n  \u00b7 intro n\n    exact \u27e8(hx_n n).1, (hx_n n).2.1\u27e9\n  \u00b7 rw [Metric.tendsto_nhds]\n    intro \u03b5 h\u03b5\n    rcases exists_nat_gt (1 / \u03b5) with \u27e8N, hN\u27e9\n    use N\n    intro n hn\n    have h : 1 / (n : \u211d) \u2264 1 / N := by\n      apply one_div_le_one_div_of_le\n      \u00b7 exact Nat.cast_pos.mpr (Nat.zero_lt_of_lt hn)\n      \u00b7 exact Nat.cast_le.mpr hn\n    have h' : dist (x_n n) x_bar < \u03b5 := by\n      apply lt_of_lt_of_le (hx_n n).2.2\n      apply lt_of_le_of_lt h\n      exact one_div_lt (Nat.cast_pos.mpr (Nat.zero_lt_of_lt hn)) h\u03b5\n    exact h'", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 8, "endLine": 14, "endColumn": 27, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  Tendsto ?m.1561 ?m.1560 (\ud835\udcdd ?m.1562)\ncase h.right\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MetricSpace \u03b1\nx_bar : \u03b1\nS : Set \u03b1\nx_n : \u2115 \u2192 \u03b1\nhx_n : \u2200 (n : \u2115), x_n n \u2208 S \u2227 x_n n \u2260 x_bar \u2227 Dist.dist (x_n n) x_bar < 1 / \u2191n\n\u22a2 Tendsto x_n atTop (\ud835\udcdd x_bar)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise structure correctly captures the natural language assumption using appropriate quantifiers", "Domain membership condition is exactly preserved", "Non-equality condition is faithfully represented", "Distance constraint properly uses metric space distance function, equivalent to absolute value notation", "Conclusion structure appropriately asserts existence of a sequence function", "All sequence properties from natural language are captured in the conjunction", "Limit condition is properly formalized using Lean's topological limit notation", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter Metric\n\nlemma neg_ts_2\n  {\u03b1 : Type*} [TopologicalSpace \u03b1] [MetricSpace \u03b1] (x_bar : \u03b1) (S : Set \u03b1)\n  (l3 : \u2200 n : \u2115, \u2203 x_n : \u03b1, x_n \u2208 S \u2227 x_n \u2260 x_bar \u2227 dist x_n x_bar < 1 / (n : \u211d)) :\n  \u00ac \u2203 (x_n : \u2115 \u2192 \u03b1), (\u2200 n : \u2115, x_n n \u2208 S \u2227 x_n n \u2260 x_bar) \u2227 (Tendsto x_n atTop (\ud835\udcdd x_bar)) := by\n  intro h\n  rcases h with \u27e8x_n, h\u2081, h\u2082\u27e9\n  have : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, dist (x_n n) x_bar < \u03b5 := by\n    intro \u03b5 h\u03b5\n    rcases Metric.tendsto_atTop.mp h\u2082 \u03b5 h\u03b5 with \u27e8N, hN\u27e9\n    exact \u27e8N, fun n hn \u21a6 hN n hn\u27e9\n  have : \u2200 n : \u2115, \u2203 x : \u03b1, x \u2208 S \u2227 x \u2260 x_bar \u2227 dist x x_bar < 1 / (n : \u211d) := l3\n  choose f hf using this\n  let g : \u2115 \u2192 \u03b1 := fun n \u21a6 f n\n  have hg : \u2200 n : \u2115, g n \u2208 S \u2227 g n \u2260 x_bar \u2227 dist (g n) x_bar < 1 / (n : \u211d) := hf\n  have : Tendsto g atTop (\ud835\udcdd x_bar) := by\n    rw [Metric.tendsto_atTop]\n    intro \u03b5 h\u03b5\n    rcases exists_nat_gt (1 / \u03b5) with \u27e8N, hN\u27e9\n    refine \u27e8N, fun n hn \u21a6 ?_\u27e9\n    have : 1 / (n : \u211d) \u2264 1 / N := by\n      apply one_div_le_one_div_of_le\n      \u00b7 exact Nat.cast_pos.mpr (Nat.pos_of_gt hn)\n      \u00b7 exact Nat.cast_le.mpr hn\n    linarith [hg n].2.2\n  have : \u2203 (x_n : \u2115 \u2192 \u03b1), (\u2200 n : \u2115, x_n n \u2208 S \u2227 x_n n \u2260 x_bar) \u2227 Tendsto x_n atTop (\ud835\udcdd x_bar) := \u27e8g, fun n \u21a6 \u27e8(hg n).1, (hg n).2.1\u27e9, this\u27e9\n  contradiction"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    