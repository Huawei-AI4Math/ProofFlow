
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Suppose that  $u_1,$ $u_2,$ \dots$,$ $u_n$ and $v_1,$ $v_2,$ \dots$,$ $v_n$
are nonnegative  numbers and $p>1.$ Then
\begin{equation} \label{eq:8.1.8}
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/p}
\le\left(\sum_{i=1}^n u_i^p\right)^{1/p}
+\left(\sum_{i=1}^n v_i^p\right)^{1/p}.
\end{equation}

Proof: Again, let $q=p/(p-1)$. We write
\begin{equation} \label{eq:8.1.9}
\sum_{i=1}^n(u_i+v_i)^p=\sum_{i=1}^n u_i(u_i+v_i)^{p-1}
+\sum_{i=1}^n v_i(u_i+v_i)^{p-1}.
\end{equation}
From H\"older's inequality with $\mu_i=u_i$ and
$
u_i=(u_i+v_i)^{p-1}$,
\begin{equation} \label{eq:8.1.10}
\sum_{i=1}^n u_i(u_i+v_i)^{p-1}\le
\left(\sum_{i=1}^n u_i^p\right)^{1/p}
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/q},
\end{equation}
since $q(p-1)=p$. Similarly,
$$
\sum_{i=1}^n v_i(u_i+v_i)^{p-1}\le
\left(\sum_{i=1}^n v_i^p\right)^{1/p}
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/q}.
$$
This, \eqref{eq:8.1.9}, and \eqref{eq:8.1.10} imply that
$$
\sum_{i=1}^n(u_i+v_i)^p
\le\left[\left(\sum_{i=1}^n u_i^p\right)^{1/p}
+\left(\sum_{i=1}^n v_i^p\right)^{1/p}\right]
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/q}.
$$

ewpage

oindent
Since $1-1/q=1/p$, this implies \eqref{eq:8.1.8}, which is
known as {\it Minkowski's inequality\/}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "u_1, u_2, \\dots, u_n and v_1, v_2, \\dots, v_n are nonnegative numbers", "statement": "Premise:\n\u2022 Let n be a natural number. u and v are sequences of n nonnegative real numbers, denoted u_i and v_i for i from 1 to n [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (n : \u2115)\n  (u v : (Fin n) \u2192 \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration (n : \u2115) perfectly matches the condition that n is a natural number", "The Lean type (Fin n) \u2192 \u211d correctly represents a sequence of n real numbers, where Fin n represents indices from 0 to n-1, which is equivalent to the mathematical notation of n elements", "Same as condition 2, the Lean formalization correctly represents v as a sequence of n real numbers", "The Lean constraint (\u2200 i : Fin n, 0 \u2264 u i) perfectly captures that all elements u_i are nonnegative. The indexing difference (Fin n uses 0 to n-1 vs mathematical 1 to n) is a standard representation difference that doesn't affect the logical meaning", "The Lean constraint (\u2200 i : Fin n, 0 \u2264 v i) perfectly captures that all elements v_i are nonnegative, with the same indexing consideration as condition 4"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "p>1", "statement": "Premise:\n\u2022 p is a real number such that p > 1 [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p : \u211d)\n(tc_2 : p > 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (p : \u211d)' correctly captures that p is a real number", "The Lean hypothesis '(tc_2 : p > 1)' correctly captures the condition p > 1, with tc_2 being just a label name", "Both the natural language and Lean formalization contain no derived conclusions, only premise conditions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Again, let q=p/(p-1).", "statement": "We assume:\n\u2022 p is a real number such that p > 1 [tc_2].\nDefinition:\n\u2022 Let q be a real number defined as q = p / (p-1) [def_1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p : \u211d)\n(tc_2 : p > 1)\n(def_1 : q = p / (p - 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that p is a real number with the constraint p > 1, matching the natural language condition exactly.", "The Lean definition of q as p / (p - 1) exactly matches the mathematical definition given in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "We write\n\\begin{equation} \\label{eq:8.1.9}\n\\sum_{i=1}^n(u_i+v_i)^p=\\sum_{i=1}^n u_i(u_i+v_i)^{p-1}\n+\\sum_{i=1}^n v_i(u_i+v_i)^{p-1}.\n\\end{equation}", "statement": "We assume:\n\u2022 Let n be a natural number. u and v are sequences of n nonnegative real numbers [tc_1].\n\u2022 p is a real number such that p > 1 [tc_2].\nTherefore, we conclude:\n\u2022 \u2211_{i=1}^n (u_i+v_i)^p = \u2211_{i=1}^n u_i(u_i+v_i)^(p-1) + \u2211_{i=1}^n v_i(u_i+v_i)^(p-1) [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1) :\n  \u2211 i : Fin n, (u i + v i) ^ p = (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1)) + (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1) :\n  \u2211 i : Fin n, (u i + v i) ^ p = (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1)) + (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)) := by\n  simp_rw [\u2190 mul_add, add_mul, \u2190 Real.rpow_add_one (by linarith [tc_1.1 i, tc_1.2 i] : 0 \u2264 u i + v i), \n    sub_add_cancel]\n  rfl", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 11, "endLine": 10, "endColumn": 20, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly capture the natural language description. The use of Fin n for indexing is the standard Lean equivalent of 1-to-n indexing in mathematics.", "All constraints (nonnegativity of sequences, p > 1) are accurately formalized in Lean.", "The main mathematical equation is perfectly translated, with equivalent summation notation and identical algebraic expressions.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l1 :\n  \u2203 (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p : \u211d),\n    (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i) \u2227\n    p > 1 \u2227\n    \u2211 i : Fin n, (u i + v i) ^ p \u2260 (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1)) + (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)) := by\n  use 2, fun _ => 1, fun _ => 1, 2\n  constructor\n  \u00b7 intro i; simp\n  constructor\n  \u00b7 intro i; simp\n  constructor\n  \u00b7 norm_num\n  \u00b7 simp [Fin.sum_univ_two, pow_two]\n    ring_nf\n    norm_num"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "since q(p-1)=p", "statement": "We assume:\n\u2022 For p > 1, q is defined as q = p / (p-1) [def_1].\nTherefore, we conclude:\n\u2022 q * (p - 1) = p [l2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (p : \u211d) (q : \u211d)\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1)) :\n  q * (p - 1) = p := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (p : \u211d) (q : \u211d)\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1)) :\n  q * (p - 1) = p := by\n  rw [def_1]\n  field_simp [(ne_of_gt (sub_pos.mpr tc_2))]\n  ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 2, "endLine": 12, "endColumn": 6, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical and logical content from the natural language. The variables p and q are properly declared as real numbers, the condition p > 1 is included as a hypothesis, the definition q = p/(p-1) is stated exactly as given, and the conclusion q * (p-1) = p is the goal to be proved. The logical structure properly reflects that this is a theorem to be derived from the given assumptions.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  (p : \u211d) (q : \u211d)\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1)) :\n  \u00ac(q * (p - 1) = p) := by\n  rw [def_1]\n  field_simp [sub_ne_zero_of_gt tc_2]\n  norm_num"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "From H\"older's inequality with $\\mu_i=u_i$ and\n$\\nu_i=(u_i+v_i)^{p-1}$,\n\\begin{equation} \\label{eq:8.1.10}\n\\sum_{i=1}^n u_i(u_i+v_i)^{p-1}\\le\n\\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}\n\\left(\\sum_{i=1}^n(u_i+v_i)^p\\right)^{1/q},\n\\end{equation}", "statement": "We assume:\n\u2022 u and v are sequences of n nonnegative real numbers [tc_1].\n\u2022 For p > 1, q is defined as q = p / (p-1) [def_1].\n\u2022 q * (p - 1) = p [l2].\nTherefore, we conclude:\n\u2022 \u2211_{i=1}^n u_i * (u_i+v_i)^(p-1) \u2264 (\u2211_{i=1}^n u_i^p)^(1/p) * (\u2211_{i=1}^n (u_i+v_i)^p)^(1/q) [l3].", "dependencies": ["tc_1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115)\n  (u v : (Fin n) \u2192 \u211d)\n  (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p) :\n  \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115)\n  (u v : (Fin n) \u2192 \u211d)\n  (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p) :\n  \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n  have hpq : 1 / p + 1 / q = 1 := by\n    rw [def_1, div_div, \u2190 add_div, l2, div_self]\n    exact ne_of_gt (sub_pos_of_lt tc_2)\n  have hq_pos : 0 < q := by\n    rw [def_1]\n    refine div_pos (by linarith [tc_2]) (sub_pos_of_lt tc_2)\n  have h_sum_nonneg : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 u i + v i := by\n    intro i\n    exact \u27e8tc_1.1 i, add_nonneg (tc_1.1 i) (tc_1.2 i)\u27e9\n  refine le_trans (Finset.sum_le_sum (fun i _ => ?_)) (inner_le_Lp_mul_Lq _ _ _ hpq)\n  \u00b7 exact mul_le_mul_of_nonneg_left (rpow_le_rpow (h_sum_nonneg i).1 (le_add_of_nonneg_right (tc_1.2 i)) (le_of_lt (sub_pos_of_lt tc_2))) (h_sum_nonneg i).1\n  \u00b7 intro i\n    exact (h_sum_nonneg i).1\n  \u00b7 intro i\n    exact (h_sum_nonneg i).2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture sequences of nonnegative real numbers using Lean's function types and explicit nonnegativity constraints", "The constraint p > 1 is properly formalized", "The definition q = p/(p-1) is exactly translated", "The relationship q*(p-1) = p is perfectly matched", "The main inequality is correctly formalized with appropriate Lean notation for finite sums and exponentiation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Similarly,\n$$\n\\sum_{i=1}^n v_i(u_i+v_i)^{p-1}\\le\n\\left(\\sum_{i=1}^n v_i^p\\right)^{1/p}\n\\left(\\sum_{i=1}^n(u_i+v_i)^p\\right)^{1/q}.\n$$", "statement": "We assume:\n\u2022 u and v are sequences of n nonnegative real numbers [tc_1].\n\u2022 For p > 1, q is defined as q = p / (p-1) [def_1].\n\u2022 q * (p - 1) = p [l2].\nTherefore, we conclude:\n\u2022 \u2211_{i=1}^n v_i * (u_i+v_i)^(p-1) \u2264 (\u2211_{i=1}^n v_i^p)^(1/p) * (\u2211_{i=1}^n (u_i+v_i)^p)^(1/q) [l4].", "dependencies": ["tc_1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (u v : (Fin n) \u2192 \u211d)\n  (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p) :\n  \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (u v : (Fin n) \u2192 \u211d)\n  (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p) :\n  \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n  have hp : 0 < p := by linarith\n  have hq : q > 0 := by\n    rw [def_1]\n    apply div_pos hp\n    linarith\n  have hpq : 1 / p + 1 / q = 1 := by\n    rw [def_1]\n    field_simp [hp.ne', (sub_pos.mpr tc_2).ne']\n    linear_combination l2\n  have h_sum_nonneg : \u2200 i, 0 \u2264 (u i + v i) ^ (p - 1) := fun i \u21a6 by\n    apply rpow_nonneg\n    exact add_nonneg (tc_1.1 i) (tc_1.2 i)\n  have h_sum_nonneg' : \u2200 i, 0 \u2264 u i + v i := fun i \u21a6 add_nonneg (tc_1.1 i) (tc_1.2 i)\n  have h_sum_nonneg'' : \u2200 i, 0 \u2264 v i := tc_1.2\n  refine' le_trans (\u2211 i, v i * (u i + v i) ^ (p - 1)) _ _ _\n  \u00b7 apply Finset.sum_le_sum\n    intro i _\n    apply mul_le_mul_of_nonneg_left _ (tc_1.2 i)\n    apply rpow_le_rpow (tc_1.2 i) (le_add_of_nonneg_left (tc_1.1 i)) (by linarith)\n  \u00b7 apply Real.inner_le_Lp_mul_Lq _ _ hpq\n    intro i; exact h_sum_nonneg'' i\n    intro i; exact rpow_nonneg (h_sum_nonneg' i) p", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 22, "column": 4, "endLine": 22, "endColumn": 25, "data": "no goals to be solved"}, {"line": 28, "column": 10, "endLine": 28, "endColumn": 59, "data": "function expected at\n  le_trans ?m.12773 ?m.12774\nterm has type\n  ?m.11277 \u2264 ?m.11279"}, {"line": 28, "column": 19, "endLine": 28, "endColumn": 53, "data": "application type mismatch\n  le_trans (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1))\nargument\n  \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)\nhas type\n  \u211d : Type\nbut is expected to have type\n  ?m.11277 \u2264 ?m.11278 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequences u and v are correctly formalized as functions from Fin n to \u211d with appropriate nonnegativity constraints", "The constraint p > 1 is directly and correctly captured", "The definition q = p / (p - 1) is exactly preserved in the Lean formalization", "The relationship q * (p - 1) = p is identically represented", "The main inequality is correctly formalized using Lean's standard finite sum notation, which properly represents the mathematical summation", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  (n : \u2115)\n  (u v : (Fin n) \u2192 \u211d)\n  (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p) :\n  \u2203 u v : Fin n \u2192 \u211d, (\u2200 i, 0 \u2264 u i) \u2227 (\u2200 i, 0 \u2264 v i) \u2227 p > 1 \u2227 q = p / (p - 1) \u2227 q * (p - 1) = p \u2227\n    \u00ac (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)) := by\n  use 0, fun _ => 1\n  use fun _ => 1, fun _ => 1\n  constructor\n  \u00b7 intro i; norm_num\n  constructor\n  \u00b7 intro i; norm_num\n  constructor\n  \u00b7 norm_num\n  constructor\n  \u00b7 norm_num\n  constructor\n  \u00b7 norm_num\n  \u00b7 simp\n    norm_num"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This, \\eqref{eq:8.1.9}, and \\eqref{eq:8.1.10} imply that\n$$\n\\sum_{i=1}^n(u_i+v_i)^p\n\\le\\left[\\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}\n+\\left(\\sum_{i=1}^n v_i^p\\right)^{1/p}\\right]\n\\left(\\sum_{i=1}^n(u_i+v_i)^p\\right)^{1/q}.\n$$", "statement": "We assume:\n\u2022 \u2211_{i=1}^n (u_i+v_i)^p = \u2211_{i=1}^n u_i(u_i+v_i)^(p-1) + \u2211_{i=1}^n v_i(u_i+v_i)^(p-1) [l1].\n\u2022 \u2211_{i=1}^n u_i * (u_i+v_i)^(p-1) \u2264 (\u2211_{i=1}^n u_i^p)^(1/p) * (\u2211_{i=1}^n (u_i+v_i)^p)^(1/q) [l3].\n\u2022 \u2211_{i=1}^n v_i * (u_i+v_i)^(p-1) \u2264 (\u2211_{i=1}^n v_i^p)^(1/p) * (\u2211_{i=1}^n (u_i+v_i)^p)^(1/q) [l4].\nTherefore, we conclude:\n\u2022 \u2211_{i=1}^n (u_i+v_i)^p \u2264 [ (\u2211_{i=1}^n u_i^p)^(1/p) + (\u2211_{i=1}^n v_i^p)^(1/p) ] * (\u2211_{i=1}^n (u_i+v_i)^p)^(1/q) [l5].", "dependencies": ["l1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p)\n  (l1 : \u2211 i : Fin n, (u i + v i) ^ p = (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1)) + (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)))\n  (l3 : \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q))\n  (l4 : \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)) :\n  \u2211 i : Fin n, (u i + v i) ^ p \u2264 ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p q : \u211d)\n  (tc_1 : (\u2200 i : Fin n, 0 \u2264 u i) \u2227 (\u2200 i : Fin n, 0 \u2264 v i))\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1))\n  (l2 : q * (p - 1) = p)\n  (l1 : \u2211 i : Fin n, (u i + v i) ^ p = (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1)) + (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)))\n  (l3 : \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q))\n  (l4 : \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)) :\n  \u2211 i : Fin n, (u i + v i) ^ p \u2264 ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n  rw [l1]\n  have h_sum_nonneg : 0 \u2264 \u2211 i : Fin n, (u i + v i) ^ p := by\n    apply sum_nonneg\n    intro i\n    apply pow_nonneg\n    exact add_nonneg (tc_1.1 i) (tc_1.2 i)\n  rcases le_iff_eq_or_lt.mp h_sum_nonneg with h | h\n  \u00b7 simp [h]\n  \u00b7 have h' : (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) > 0 := by\n      apply rpow_pos_of_pos h\n    rw [\u2190 mul_right_inj' (ne_of_gt h')]\n    transitivity (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1)) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)\n    \u00b7 rw [\u2190 l1]\n    \u00b7 transitivity (\u2211 i : Fin n, u i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) +\n        (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\n      \u00b7 apply add_le_add l3 l4\n      \u00b7 rw [add_mul]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 10, "endLine": 17, "endColumn": 20, "data": "unknown identifier 'sum_nonneg'"}, {"line": 18, "column": 4, "endLine": 18, "endColumn": 11, "data": "no goals to be solved"}, {"line": 22, "column": 2, "endLine": 22, "endColumn": 12, "data": "unsolved goals\ncase inl\nn : \u2115\nu v : Fin n \u2192 \u211d\np q : \u211d\ntc_1 : (\u2200 (i : Fin n), 0 \u2264 u i) \u2227 \u2200 (i : Fin n), 0 \u2264 v i\ntc_2 : p > 1\ndef_1 : q = p / (p - 1)\nl2 : q * (p - 1) = p\nl1 : \u2211 i : Fin n, (u i + v i) ^ p = \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)\nl3 :\n  \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nl4 :\n  \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nh_sum_nonneg : 0 \u2264 \u2211 i : Fin n, (u i + v i) ^ p\nh : 0 = \u2211 i : Fin n, (u i + v i) ^ p\n\u22a2 \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264\n    ((\u2211 i : Fin n, u i ^ p) ^ p\u207b\u00b9 + (\u2211 i : Fin n, v i ^ p) ^ p\u207b\u00b9) *\n      (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)) ^ q\u207b\u00b9"}, {"line": 25, "column": 8, "endLine": 25, "endColumn": 38, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.18437 = ?m.18438\ncase inr\nn : \u2115\nu v : Fin n \u2192 \u211d\np q : \u211d\ntc_1 : (\u2200 (i : Fin n), 0 \u2264 u i) \u2227 \u2200 (i : Fin n), 0 \u2264 v i\ntc_2 : p > 1\ndef_1 : q = p / (p - 1)\nl2 : q * (p - 1) = p\nl1 : \u2211 i : Fin n, (u i + v i) ^ p = \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)\nl3 :\n  \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nl4 :\n  \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, v i ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nh_sum_nonneg : 0 \u2264 \u2211 i : Fin n, (u i + v i) ^ p\nh : 0 < \u2211 i : Fin n, (u i + v i) ^ p\nh' : (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) > 0\n\u22a2 \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264\n    ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) *\n      (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1)) ^ (1 / q)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Function signatures correctly translate the mathematical sequences to Lean functions from Fin n to reals", "Non-negativity conditions are appropriately added as they are necessary for the mathematical validity of the operations", "The constraint p > 1 is correctly included as it's standard for this type of inequality", "The conjugate exponent relationship between p and q is properly formalized with both the definition and the equivalent constraint", "Equation l1 is perfectly translated with correct summation syntax and mathematical operations", "Inequality l3 is accurately formalized with proper H\u00f6lder-type inequality structure", "Inequality l4 is correctly translated, maintaining the same structure as l3 but for the v terms", "The conclusion l5 perfectly captures the final Minkowski-type inequality with proper parenthesization and mathematical structure", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib.Analysis.MeanInequalities\nimport Mathlib.Analysis.SpecialFunctions.Pow.NNReal\n\nopen BigOperators NNReal\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (n : \u2115) (u v : Fin n \u2192 \u211d\u22650) (p q : \u211d\u22650)\n  (hp : 1 < p) (hq : q = p / (p - 1))\n  (hl1 : \u2211 i, (u i + v i) ^ p = \u2211 i, u i * (u i + v i) ^ (p - 1) + \u2211 i, v i * (u i + v i) ^ (p - 1))\n  (hl3 : \u2211 i, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i, u i ^ p) ^ (1 / p) * (\u2211 i, (u i + v i) ^ p) ^ (1 / q))\n  (hl4 : \u2211 i, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i, v i ^ p) ^ (1 / p) * (\u2211 i, (u i + v i) ^ p) ^ (1 / q)) :\n  \u00ac (\u2211 i, (u i + v i) ^ p \u2264 ((\u2211 i, u i ^ p) ^ (1 / p) + (\u2211 i, v i ^ p) ^ (1 / p)) * (\u2211 i, (u i + v i) ^ p) ^ (1 / q)) := by\n  intro h\n  let S := \u2211 i, (u i + v i) ^ p\n  have hS : 0 < S := by\n    by_contra H\n    push_neg at H\n    have hS0 : S = 0 := le_antisymm H (sum_nonneg fun i \u21a6 by positivity)\n    have : \u2200 i, u i = 0 \u2227 v i = 0 := by\n      intro i\n      have := sum_eq_zero_iff_of_nonneg.1 hS0 i\n      simp [rpow_eq_zero_iff, add_eq_zero_iff, u i, v i] at this\n      exact \u27e8this.1, this.2\u27e9\n    simp [this] at hl1\n    simp [this] at hS0\n    have : (0 : \u211d\u22650) ^ (1 / p) = 0 := by simp [hp.ne']\n    simp [this] at h\n    linarith\n  have hq' : 1 / q = 1 - 1 / p := by\n    rw [hq, div_eq_mul_inv, inv_div, sub_eq_add_neg, neg_div]\n  have := calc\n    S = _ := hl1\n    _ \u2264 _ := add_le_add hl3 hl4\n    _ = ((\u2211 i, u i ^ p) ^ (1 / p) + (\u2211 i, v i ^ p) ^ (1 / p)) * S ^ (1 / q) := by ring\n  have := le_antisymm h this\n  rw [\u2190 mul_right_inj' (pow_ne_zero (1 / q) hS.ne'), \u2190 mul_assoc, \u2190 rpow_add hS, hq',\n      add_sub_cancel'_right, rpow_one] at this\n  have hup : 0 < \u2211 i, u i ^ p := by\n    by_contra H\n    have := sum_eq_zero_iff.1 (le_antisymm H (sum_nonneg fun i \u21a6 by positivity))\n    have : \u2200 i, u i = 0 := fun i \u21a6 pow_eq_zero (this i)\n    simp [this] at hl1 h\n    linarith\n  have hvp : 0 < \u2211 i, v i ^ p := by\n    by_contra H\n    have := sum_eq_zero_iff.1 (le_antisymm H (sum_nonneg fun i \u21a6 by positivity))\n    have : \u2200 i, v i = 0 := fun i \u21a6 pow_eq_zero (this i)\n    simp [this] at hl1 h\n    linarith\n  have : (\u2211 i, u i ^ p) ^ (1 / p) + (\u2211 i, v i ^ p) ^ (1 / p) = S ^ (1 / p) := by\n    rw [\u2190 this]\n    ring\n  have := Minkowski_sum_le hup hvp hp\n  rw [this] at hl3 hl4\n  linarith"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since 1-1/q=1/p", "statement": "We assume:\n\u2022 For p > 1, q is defined as q = p / (p-1) [def_1].\nTherefore, we conclude:\n\u2022 1 - 1/q = 1/p [l6].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (p q : \u211d)\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1)) :\n  1 - 1 / q = 1 / p := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (p q : \u211d)\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1)) :\n  1 - 1 / q = 1 / p := by\n  have hp : p - 1 \u2260 0 := by linarith\n  rw [def_1]\n  field_simp [hp]\n  ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 2, "endLine": 13, "endColumn": 6, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The assumption p > 1 is properly encoded as tc_2, the definition q = p/(p-1) is accurately represented as def_1, and the conclusion 1 - 1/q = 1/p is exactly stated as the lemma goal. The additional type declarations (p q : \u211d) are appropriate mathematical details that don't contradict the natural language but rather make the formalization more precise.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l6\n  (p q : \u211d)\n  (tc_2 : p > 1)\n  (def_1 : q = p / (p - 1)) :\n  \u00ac (1 - 1 / q = 1 / p) := by\n  intro h\n  have : p \u2260 1 := by linarith\n  rw [def_1] at h\n  have : (p - 1) \u2260 0 := by linarith\n  field_simp at h\n  rw [eq_comm, div_eq_div_iff] at h\n  field_simp at h\n  linear_combination h"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "this implies \\eqref{eq:8.1.8}", "statement": "We assume:\n\u2022 \u2211_{i=1}^n (u_i+v_i)^p \u2264 [ (\u2211_{i=1}^n u_i^p)^(1/p) + (\u2211_{i=1}^n v_i^p)^(1/p) ] * (\u2211_{i=1}^n (u_i+v_i)^p)^(1/q) [l5].\n\u2022 1 - 1/q = 1/p [l6].\nTherefore, we conclude:\n\u2022 (\u2211_{i=1}^n (u_i+v_i)^p)^(1/p) \u2264 (\u2211_{i=1}^n u_i^p)^(1/p) + (\u2211_{i=1}^n v_i^p)^(1/p) [ts_1].", "dependencies": ["l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p q : \u211d)\n  (l5 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q))\n  (l6 : 1 - 1 / q = 1 / p) :\n  (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p q : \u211d)\n  (l5 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q))\n  (l6 : 1 - 1 / q = 1 / p) :\n  (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p) := by\n  let S := \u2211 i : Fin n, (u i + v i) ^ p\n  by_cases hS0 : S = 0\n  \u00b7 simp [hS0]\n    have hp0 : p \u2260 0 := by\n      intro hp\n      rw [hp, div_zero] at l6\n      linarith\n    rw [zero_rpow hp0]\n    apply add_nonneg\n    \u00b7 apply rpow_nonneg\n      exact sum_nonneg (fun i _ => by positivity)\n    \u00b7 apply rpow_nonneg\n      exact sum_nonneg (fun i _ => by positivity)\n  \u00b7 have hpq : p + q = p * q := by\n      rw [\u2190 l6]\n      field_simp\n      ring\n    have hSpos : 0 < S := by\n      apply lt_of_le_of_ne\n      \u00b7 exact sum_nonneg (fun i _ => by positivity)\n      \u00b7 exact hS0.symm\n    rw [\u2190 mul_right_inj' (ne_of_gt hSpos), \u2190 rpow_add (ne_of_gt hSpos), hpq]\n    simp only [one_div, rpow_one]\n    exact l5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 6, "endLine": 16, "endColumn": 14, "data": "linarith failed to find a contradiction\nn : \u2115\nu v : Fin n \u2192 \u211d\np q : \u211d\nl5 :\n  \u2211 i : Fin n, (u i + v i) ^ p \u2264\n    ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nl6 : 1 - 1 / q = 0\nS : \u211d := \u2211 i : Fin n, (u i + v i) ^ p\nhS0 : S = 0\nhp : p = 0\n\u22a2 False failed"}, {"line": 17, "column": 8, "endLine": 17, "endColumn": 21, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  0 ^ p\ncase pos\nn : \u2115\nu v : Fin n \u2192 \u211d\np q : \u211d\nl5 :\n  \u2211 i : Fin n, (u i + v i) ^ p \u2264\n    ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nl6 : 1 - 1 / q = 1 / p\nS : \u211d := \u2211 i : Fin n, (u i + v i) ^ p\nhS0 : S = 0\nhp0 : p \u2260 0\n\u22a2 (\u2211 i : Fin n, (u i + v i) ^ p) ^ p\u207b\u00b9 \u2264 (\u2211 i : Fin n, u i ^ p) ^ p\u207b\u00b9 + (\u2211 i : Fin n, v i ^ p) ^ p\u207b\u00b9"}, {"line": 24, "column": 10, "endLine": 24, "endColumn": 14, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  1 / p\nn : \u2115\nu v : Fin n \u2192 \u211d\np q : \u211d\nl5 :\n  \u2211 i : Fin n, (u i + v i) ^ p \u2264\n    ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nl6 : 1 - 1 / q = 1 / p\nS : \u211d := \u2211 i : Fin n, (u i + v i) ^ p\nhS0 : \u00acS = 0\n\u22a2 p + q = p * q"}, {"line": 29, "column": 14, "endLine": 29, "endColumn": 24, "data": "unknown identifier 'sum_nonneg'"}, {"line": 30, "column": 14, "endLine": 30, "endColumn": 22, "data": "invalid field 'symm', the environment does not contain 'Not.symm'\n  hS0\nhas type\n  \u00acS = 0"}, {"line": 30, "column": 14, "endLine": 30, "endColumn": 22, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  hS0\nhas type\n  S = 0 \u2192 False"}, {"line": 31, "column": 8, "endLine": 31, "endColumn": 41, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.13741 = ?m.13742\ncase neg\nn : \u2115\nu v : Fin n \u2192 \u211d\np q : \u211d\nl5 :\n  \u2211 i : Fin n, (u i + v i) ^ p \u2264\n    ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q)\nl6 : 1 - 1 / q = 1 / p\nS : \u211d := \u2211 i : Fin n, (u i + v i) ^ p\nhS0 : \u00acS = 0\nhpq : p + q = p * q\nhSpos : 0 < S\n\u22a2 (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type declarations correctly capture the mathematical objects: n as a natural number, u and v as functions from finite sets to reals, and p,q as real parameters.", "Assumption l5 is perfectly translated from mathematical notation to Lean syntax, preserving the exact inequality structure.", "Assumption l6 correctly captures the relationship between p and q that is essential for the proof.", "The conclusion ts_1 is an exact translation of the triangle inequality statement from natural language to Lean.", "The overall logical structure correctly represents the theorem statement: given the two assumptions, prove the conclusion. The Lean formalization completely captures all mathematical content from the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  (n : \u2115) (u v : (Fin n) \u2192 \u211d) (p q : \u211d)\n  (l5 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q))\n  (l6 : 1 - 1 / q = 1 / p) :\n  \u00ac((\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) := by\n  refine not_le_of_gt ?_\n  let n := 1\n  let p := 1\n  let q := 1/2\n  let u : Fin n \u2192 \u211d := fun _ => 1\n  let v : Fin n \u2192 \u211d := fun _ => 1\n  have l6 : 1 - 1 / q = 1 / p := by norm_num\n  have l5 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 ((\u2211 i : Fin n, u i ^ p) ^ (1 / p) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p)) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n    simp [u, v, p, q]\n    norm_num\n  simp [u, v, p, q]\n  norm_num"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    