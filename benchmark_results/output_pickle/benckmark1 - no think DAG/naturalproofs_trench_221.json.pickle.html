
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}\in\R^n$ and $p_2>p_1\ge1,$ then
\begin{equation} \label{eq:8.1.12}
\|\mathbf{X}\|_{p_2}\le\|\mathbf{X}\|_{p_1};
\end{equation}
moreover,
\begin{equation} \label{eq:8.1.13}
\lim_{p	o\infty}\|\mathbf{X}\|_{p}=\max\set{|x_i|}{1\le i\le n}.
\end{equation}

Proof: Let $u_1$, $u_2$, \dots, $u_n$  be
nonnegative and $M=\max\set{u_i}{1\le i\le n}$. Define
$$
\sigma(p)=\left(\sum_{i=1}^n u_i^p\right)^{1/p}.
$$
Since $u_i/\sigma(p)\le1$ and $p_2>p_1$,
$$
\left(\frac{u_i}{\sigma(p_2)}\right)^{p_1}\ge
\left(\frac{u_i}{\sigma(p_2)}\right)^{p_2};
$$
 therefore,
$$
\frac{\sigma(p_1)}{\sigma(p_2)}
=\left(\sum_{i=1}^n\left(\frac{
u_i}{\sigma(p_2)}\right)^{p_1}\right)^{1/p_1}
\ge\left(\sum_{i=1}^n\left(\frac{
u_i}{\sigma(p_2)}\right)^{p_2}\right)^{1/p_1}=1,
$$
so $\sigma(p_1)\ge\sigma(p_2)$.
Since $M\le\sigma(p)\le Mn^{1/p}$,
$\lim_{p	o\infty}\sigma(p)= M$.
Letting  $u_i=|x_i|$  yields \eqref{eq:8.1.12} and \eqref{eq:8.1.13}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X}\\in\\R^n$", "statement": "Premise:\n\u2022 $\\mathbf{X}$ is a vector in $\\R^n$ with components $x_i$ for $i=1, ..., n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X : euclidean_space \u211d (Fin n)) (x : Fin n \u2192 \u211d)\n(tc_1 : \u2200 i, x i = X i)", "lean_pass": false, "error_msg": [{"line": 5, "column": 22, "endLine": 5, "endColumn": 47, "data": "function expected at\n  euclidean_space\nterm has type\n  ?m.5"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "and $p_2>p_1\\ge1,$", "statement": "Premise:\n\u2022 $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p1 p2 : \u211d)\n(tc_2 : p2 > p1 \u2227 p1 \u2265 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The mathematical meaning is identical - both declare p1 and p2 as real numbers. The only difference is variable naming convention: the natural language uses subscript notation (p_1, p_2) while Lean uses p1, p2. This is a minor notational difference that doesn't affect the logical content.", "The Lean formalization perfectly captures the compound inequality. The natural language states p_2 > p_1 \u2265 1, and Lean expresses this as p2 > p1 \u2227 p1 \u2265 1, which is logically equivalent. The conjunction (\u2227) correctly separates the two inequality conditions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The mathematical meaning is identical - both declare p1 and p2 as real numbers. The only difference is variable naming convention: the natural language uses subscript notation (p_1, p_2) while Lean uses p1, p2. This is a minor notational difference that doesn't affect the logical content.\", 'The Lean formalization perfectly captures the compound inequality. The natural language states p_2 > p_1 \u2265 1, and Lean expresses this as p2 > p1 \u2227 p1 \u2265 1, which is logically equivalent. The conjunction (\u2227) correctly separates the two inequality conditions.']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $u_1$, $u_2$, \\dots, $u_n$  be nonnegative and $M=\\max\\set{u_i}{1\\le i\\le n}$.", "statement": "Definition:\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers [def_1a].\n\u2022 Let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1b].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115} (u : Fin n \u2192 \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_1b : M = (Finset.univ.image u).sup id)", "lean_pass": false, "error_msg": [{"line": 8, "column": 16, "endLine": 8, "endColumn": 44, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "Define\n$$\n\\sigma(p)=\\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}.\n$$", "statement": "Definition:\n\u2022 For $p \\ge 1$ and for a sequence of non-negative numbers $u_1, ..., u_n$ [def_1a], define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ [def_2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (hp : 1 \u2264 p)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_2 : (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p) = (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition p \u2265 1 is correctly captured as (hp : 1 \u2264 p) in Lean", "The sequence of non-negative numbers u\u2081, ..., u\u2099 is properly formalized as (u : Fin n \u2192 \u211d) with the non-negativity constraint (def_1a : \u2200 i, 0 \u2264 u i)", "The natural language defines \u03c3(p) as a function equal to the given expression, but the Lean formalization only states a tautology A = A without actually defining \u03c3 as a function. The Lean code is missing the actual definition of \u03c3(p) and instead provides a trivial equality statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition p \u2265 1 is correctly captured as (hp : 1 \u2264 p) in Lean', 'The sequence of non-negative numbers u\u2081, ..., u\u2099 is properly formalized as (u : Fin n \u2192 \u211d) with the non-negativity constraint (def_1a : \u2200 i, 0 \u2264 u i)', 'The natural language defines \u03c3(p) as a function equal to the given expression, but the Lean formalization only states a tautology A = A without actually defining \u03c3 as a function. The Lean code is missing the actual definition of \u03c3(p) and instead provides a trivial equality statement']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Since $u_i/\\sigma(p_2)\\le1$", "statement": "We assume:\n\u2022 Let $u_1, ..., u_n$ be nonnegative numbers [def_1a].\n\u2022 For $p \\ge 1$, $\\sigma(p) = (\\sum_{i=1}^n u_i^p)^{1/p}$ [def_2].\n\u2022 $p_2 \\ge 1$ [tc_2].\nTherefore, we conclude:\n\u2022 For each $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1].", "dependencies": ["def_1", "def_2", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_2 : \u2200 (p : \u211d) (hp : 1 \u2264 p), (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p))\n  (tc_2 : p2 \u2265 1) :\n  \u2200 i : Fin n, u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)) \u2264 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_2 : \u2200 (p : \u211d) (hp : 1 \u2264 p), (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p))\n  (tc_2 : p2 \u2265 1) :\n  \u2200 i : Fin n, u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)) \u2264 1 := by\n  intro i\n  let \u03c3 := (\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)\n  have h\u03c3 : 0 \u2264 \u03c3 := by\n    apply rpow_nonneg\n    apply sum_nonneg\n    intro k\n    apply rpow_nonneg (def_1a k)\n  by_cases h\u03c30 : \u03c3 = 0\n  \u00b7 simp [h\u03c30]\n    exact def_1a i\n  \u00b7 have h\u03c3_pos : 0 < \u03c3 := lt_of_le_of_ne h\u03c3 h\u03c30.symm\n    rw [div_le_iff h\u03c3_pos]\n    trans (\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)\n    \u00b7 apply rpow_le_rpow (def_1a i) (le_of_eq rfl) tc_2\n    \u00b7 simp only [rpow_one]\n      apply le_self_rpow_of_pos (def_1a i) tc_2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 10, "endLine": 17, "endColumn": 20, "data": "unknown identifier 'sum_nonneg'"}, {"line": 18, "column": 4, "endLine": 18, "endColumn": 11, "data": "no goals to be solved"}, {"line": 22, "column": 4, "endLine": 22, "endColumn": 18, "data": "type mismatch\n  def_1a i\nhas type\n  0 \u2264 u i : Prop\nbut is expected to have type\n  u i / (\u2211 k : Fin n, u k ^ p2) ^ p2\u207b\u00b9 \u2264 1 : Prop"}, {"line": 23, "column": 45, "endLine": 23, "endColumn": 53, "data": "invalid field 'symm', the environment does not contain 'Not.symm'\n  h\u03c30\nhas type\n  \u00ac\u03c3 = 0"}, {"line": 23, "column": 45, "endLine": 23, "endColumn": 53, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  h\u03c30\nhas type\n  \u03c3 = 0 \u2192 False"}, {"line": 26, "column": 6, "endLine": 26, "endColumn": 55, "data": "tactic 'apply' failed, failed to unify\n  u i ^ ?m.11973 \u2264 u i ^ ?m.11973\nwith\n  u i \u2264 (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)\nn : \u2115\nu : Fin n \u2192 \u211d\np2 : \u211d\ndef_1a : \u2200 (i : Fin n), 0 \u2264 u i\ndef_2 : \u2200 (p : \u211d), 1 \u2264 p \u2192 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\ntc_2 : p2 \u2265 1\ni : Fin n\n\u03c3 : \u211d := (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)\nh\u03c3 : 0 \u2264 \u03c3\nh\u03c30 : \u00ac\u03c3 = 0\nh\u03c3_pos : 0 < \u03c3\n\u22a2 u i \u2264 (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)"}, {"line": 27, "column": 6, "endLine": 27, "endColumn": 26, "data": "simp made no progress"}, {"line": 26, "column": 51, "endLine": 26, "endColumn": 55, "data": "application type mismatch\n  rpow_le_rpow (def_1a i) (le_of_eq rfl) tc_2\nargument\n  tc_2\nhas type\n  p2 \u2265 1 : Prop\nbut is expected to have type\n  0 \u2264 ?m.11973 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variable declarations correctly capture nonnegative real numbers u\u2081,...,u\u2099 using Fin n \u2192 \u211d with nonnegativity constraints.", "The definition def_2 is a tautology (A = A) that provides no meaningful information about \u03c3(p). The natural language defines \u03c3(p) as a specific function, but the Lean code doesn't actually define \u03c3 at all - it just states that some expression equals itself.", "The constraint p\u2082 \u2265 1 is correctly translated as tc_2 : p2 \u2265 1.", "The conclusion correctly translates the mathematical meaning, but instead of using the defined \u03c3(p\u2082), it directly expands to the sum expression. This is semantically equivalent but structurally different from the natural language which references \u03c3(p\u2082).", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable declarations correctly capture nonnegative real numbers u\u2081,...,u\u2099 using Fin n \u2192 \u211d with nonnegativity constraints.', \"The definition def_2 is a tautology (A = A) that provides no meaningful information about \u03c3(p). The natural language defines \u03c3(p) as a specific function, but the Lean code doesn't actually define \u03c3 at all - it just states that some expression equals itself.\", 'The constraint p\u2082 \u2265 1 is correctly translated as tc_2 : p2 \u2265 1.', 'The conclusion correctly translates the mathematical meaning, but instead of using the defined \u03c3(p\u2082), it directly expands to the sum expression. This is semantically equivalent but structurally different from the natural language which references \u03c3(p\u2082).']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "and $p_2>p_1$,\n$$\n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\ge\n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2};\n$$", "statement": "We assume:\n\u2022 $p_2 > p_1 \\ge 1$ [tc_2].\n\u2022 For each $i$, $u_i / \\sigma(p_2) \\le 1$ [l1].\n\u2022 The numbers $u_i$ are non-negative [def_1a].\nTherefore, we conclude:\n\u2022 For each $i$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2].", "dependencies": ["def_1", "l1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p1 p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (tc_2 : p2 > p1 \u2227 p1 \u2265 1)\n  (l1 : \u2200 i : Fin n, u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)) \u2264 1) :\n  \u2200 i : Fin n, (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p1 \u2265 (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p1 p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (tc_2 : p2 > p1 \u2227 p1 \u2265 1)\n  (l1 : \u2200 i : Fin n, u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)) \u2264 1) :\n  \u2200 i : Fin n, (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p1 \u2265 (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p2 := by\n  intro i\n  let \u03c3 := (\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)\n  have h\u03c3 : 0 \u2264 \u03c3 := by\n    apply rpow_nonneg\n    exact Finset.sum_nonneg fun k _ => pow_nonneg (def_1a k) p2\n  have hx : 0 \u2264 u i / \u03c3 := by\n    apply div_nonneg (def_1a i) h\u03c3\n  have hle : u i / \u03c3 \u2264 1 := l1 i\n  exact pow_le_pow_of_le_one hx hle (le_of_lt tc_2.left)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 61, "endLine": 17, "endColumn": 63, "data": "application type mismatch\n  pow_nonneg (def_1a k) p2\nargument\n  p2\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}, {"line": 21, "column": 46, "endLine": 21, "endColumn": 55, "data": "application type mismatch\n  le_of_lt tc_2.left\nargument\n  tc_2.left\nhas type\n  p2 > p1 : Prop\nbut is expected to have type\n  ?m.4059 < ?m.4060 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variable declarations correctly capture the mathematical objects: finite index set, real-valued sequence, and real parameters.", "The condition 'p2 > p1 \u2227 p1 \u2265 1' perfectly matches 'p\u2082 > p\u2081 \u2265 1' from natural language.", "The assumption about non-negativity of u_i is correctly formalized as '\u2200 i, 0 \u2264 u i'.", "The constraint 'u_i / \u03c3(p\u2082) \u2264 1' is properly formalized with \u03c3(p\u2082) interpreted as the \u2113^p\u2082 norm, which is the standard mathematical interpretation in this context.", "The conclusion correctly formalizes the inequality between the p\u2081-th and p\u2082-th powers of the normalized terms, maintaining the same mathematical relationship as stated in natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p1 p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (tc_2 : p2 > p1 \u2227 p1 \u2265 1)\n  (l1 : \u2200 i : Fin n, u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)) \u2264 1) :\n  \u2203 i : Fin n, (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p1 < (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p2 := by\n  let \u03c3 := (\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2)\n  have h\u03c3 : 0 \u2264 \u03c3 := by\n    apply Real.rpow_nonneg\n    exact Finset.sum_nonneg fun k _ => Real.rpow_nonneg (def_1a k) p2\n  cases n with\n  | zero => \n    simp [\u03c3]\n    exact False.elim (by simp [\u03c3] at l1)\n  | succ n =>\n    let i : Fin (n + 1) := \u27e80, by simp\u27e9\n    use i\n    have hui : 0 \u2264 u i := def_1a i\n    have hdiv : u i / \u03c3 \u2264 1 := l1 i\n    have hdiv_pos : 0 < u i / \u03c3 := by\n      apply div_pos (lt_of_le_of_ne (def_1a i) (Ne.symm (by simp [hui, \u03c3]))) \n             (lt_of_le_of_ne h\u03c3 (Ne.symm (by simp [h\u03c3, \u03c3])))\n    have h : (u i / \u03c3) ^ p1 < (u i / \u03c3) ^ p2 := by\n      apply Real.rpow_lt_rpow_of_exponent_gt hdiv_pos.le hdiv tc_2.1\n    exact h"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "therefore,\n$$\n\\frac{\\sigma(p_1)}{\\sigma(p_2)}\n=\\left(\\sum_{i=1}^n\\left(\\frac{\nu_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1}\n\\ge\\left(\\sum_{i=1}^n\\left(\\frac{\nu_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1}=1,\n$$\nso $\\sigma(p_1)\\ge\\sigma(p_2)$.", "statement": "We assume:\n\u2022 $p_2 > p_1 \\ge 1$ [tc_2].\n\u2022 For all $i$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2].\n\u2022 $\\sigma(p) = (\\sum_{i=1}^n u_i^p)^{1/p}$ [def_2].\nTherefore, we conclude:\n\u2022 $\\sigma(p_1) \\ge \\sigma(p_2)$ [l3].", "dependencies": ["l2", "def_2", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p1 p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (tc_2 : p2 > p1 \u2227 p1 \u2265 1)\n  (l2 : \u2200 i : Fin n, (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p1 \u2265 (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p2)\n  (def_2 : (\u2200 (p : \u211d), (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p) = (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p))) :\n  (Finset.univ.sum fun i => (u i) ^ p1) ^ (1 / p1) \u2265 (Finset.univ.sum fun i => (u i) ^ p2) ^ (1 / p2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p1 p2 : \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (tc_2 : p2 > p1 \u2227 p1 \u2265 1)\n  (l2 : \u2200 i : Fin n, (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p1 \u2265 (u i / ((\u2211 k : Fin n, (u k) ^ p2) ^ (1 / p2))) ^ p2) :\n  (Finset.univ.sum fun i => (u i) ^ p1) ^ (1 / p1) \u2265 (Finset.univ.sum fun i => (u i) ^ p2) ^ (1 / p2) := by\n  let \u03c3 (p : \u211d) := (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\n  have h\u03c3_pos : 0 < \u03c3 p2 := by\n    apply rpow_pos_of_pos\n    apply sum_pos\n    \u00b7 intro i\n      apply rpow_nonneg (def_1a i)\n    \u00b7 use 0\n      simp [def_1a]\n  have h : \u2200 i, (u i / \u03c3 p2) ^ p1 \u2265 (u i / \u03c3 p2) ^ p2 := by\n    intro i\n    simp [\u03c3]\n    exact l2 i\n  have h' : \u2200 i, u i ^ p1 * (\u03c3 p2) ^ (p1 - p2) \u2265 u i ^ p2 := by\n    intro i\n    have := h i\n    rw [div_rpow (def_1a i) (le_of_lt h\u03c3_pos), div_rpow (def_1a i) (le_of_lt h\u03c3_pos)] at this\n    simp [rpow_sub h\u03c3_pos] at this\n    exact this\n  have h'' : (\u2211 i, u i ^ p1) * (\u03c3 p2) ^ (p1 - p2) \u2265 \u2211 i, u i ^ p2 := by\n    apply Finset.sum_le_sum\n    intro i _\n    exact h' i\n  rw [\u2190 rpow_mul (sum_nonneg (fun i _ => rpow_nonneg (def_1a i) p1)), \u2190 rpow_mul (sum_nonneg (fun i _ => rpow_nonneg (def_1a i) p2))]\n  simp [\u03c3]\n  rw [mul_comm, \u2190 rpow_add (sum_pos (fun i _ => rpow_nonneg (def_1a i) p1) \u27e80, by simp [def_1a]\u27e9)]\n  have : p1 - p2 + p1 = p1 - (p2 - p1) := by ring\n  rw [this]\n  apply rpow_le_rpow (sum_nonneg (fun i _ => rpow_nonneg (def_1a i) p1)) h'' (le_of_lt (sub_pos.mpr tc_2.left))", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 10, "endLine": 16, "endColumn": 17, "data": "unknown identifier 'sum_pos'"}, {"line": 17, "column": 4, "endLine": 18, "endColumn": 34, "data": "no goals to be solved"}, {"line": 24, "column": 4, "endLine": 24, "endColumn": 14, "data": "type mismatch\n  l2 i\nhas type\n  (u i / (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)) ^ p1 \u2265 (u i / (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)) ^ p2 : Prop\nbut is expected to have type\n  (u i / (\u2211 i : Fin n, u i ^ p2) ^ p2\u207b\u00b9) ^ p2 \u2264 (u i / (\u2211 i : Fin n, u i ^ p2) ^ p2\u207b\u00b9) ^ p1 : Prop"}, {"line": 30, "column": 4, "endLine": 30, "endColumn": 14, "data": "type mismatch\n  this\nhas type\n  u i ^ p2 / \u03c3 p2 ^ p2 \u2264 u i ^ p1 / \u03c3 p2 ^ p1 : Prop\nbut is expected to have type\n  u i ^ p1 * \u03c3 p2 ^ (p1 - p2) \u2265 u i ^ p2 : Prop"}, {"line": 32, "column": 4, "endLine": 32, "endColumn": 27, "data": "tactic 'apply' failed, failed to unify\n  \u2211 i \u2208 ?s, ?f i \u2264 \u2211 i \u2208 ?s, ?g i\nwith\n  (\u2211 i : Fin n, u i ^ p1) * \u03c3 p2 ^ (p1 - p2) \u2265 \u2211 i : Fin n, u i ^ p2\nn : \u2115\nu : Fin n \u2192 \u211d\np1 p2 : \u211d\ndef_1a : \u2200 (i : Fin n), 0 \u2264 u i\ntc_2 : p2 > p1 \u2227 p1 \u2265 1\nl2 : \u2200 (i : Fin n), (u i / (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)) ^ p1 \u2265 (u i / (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)) ^ p2\n\u03c3 : \u211d \u2192 \u211d := fun p => (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nh\u03c3_pos : 0 < \u03c3 p2\nh : \u2200 (i : Fin n), (u i / \u03c3 p2) ^ p1 \u2265 (u i / \u03c3 p2) ^ p2\nh' : \u2200 (i : Fin n), u i ^ p1 * \u03c3 p2 ^ (p1 - p2) \u2265 u i ^ p2\n\u22a2 (\u2211 i : Fin n, u i ^ p1) * \u03c3 p2 ^ (p1 - p2) \u2265 \u2211 i : Fin n, u i ^ p2"}, {"line": 35, "column": 18, "endLine": 35, "endColumn": 28, "data": "unknown identifier 'sum_nonneg'"}, {"line": 35, "column": 6, "endLine": 35, "endColumn": 68, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (?m.25734 ^ ?y) ^ ?z\nn : \u2115\nu : Fin n \u2192 \u211d\np1 p2 : \u211d\ndef_1a : \u2200 (i : Fin n), 0 \u2264 u i\ntc_2 : p2 > p1 \u2227 p1 \u2265 1\nl2 : \u2200 (i : Fin n), (u i / (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)) ^ p1 \u2265 (u i / (\u2211 k : Fin n, u k ^ p2) ^ (1 / p2)) ^ p2\n\u03c3 : \u211d \u2192 \u211d := fun p => (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nh\u03c3_pos : 0 < \u03c3 p2\nh : \u2200 (i : Fin n), (u i / \u03c3 p2) ^ p1 \u2265 (u i / \u03c3 p2) ^ p2\nh' : \u2200 (i : Fin n), u i ^ p1 * \u03c3 p2 ^ (p1 - p2) \u2265 u i ^ p2\nh'' : (\u2211 i : Fin n, u i ^ p1) * \u03c3 p2 ^ (p1 - p2) \u2265 \u2211 i : Fin n, u i ^ p2\n\u22a2 (\u2211 i : Fin n, u i ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, u i ^ p2) ^ (1 / p2)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations are semantically equivalent. The use of Fin n instead of 1-based indexing and p1/p2 instead of p_1/p_2 are standard notational adaptations.", "The constraint p2 > p1 \u2227 p1 \u2265 1 perfectly captures p_2 > p_1 \u2265 1.", "The def_2 assumption is a tautology that doesn't define \u03c3(p). It should define a function \u03c3 or at least state what \u03c3(p) equals, but instead states that an expression equals itself.", "The assumption l2 correctly captures the mathematical content by directly substituting the definition of \u03c3(p_2).", "The conclusion correctly represents \u03c3(p_1) \u2265 \u03c3(p_2) by substituting the definitions directly.", "The additional non-negativity constraint def_1a is mathematically reasonable and doesn't contradict the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations are semantically equivalent. The use of Fin n instead of 1-based indexing and p1/p2 instead of p_1/p_2 are standard notational adaptations.', 'The constraint p2 > p1 \u2227 p1 \u2265 1 perfectly captures p_2 > p_1 \u2265 1.', \"The def_2 assumption is a tautology that doesn't define \u03c3(p). It should define a function \u03c3 or at least state what \u03c3(p) equals, but instead states that an expression equals itself.\", 'The assumption l2 correctly captures the mathematical content by directly substituting the definition of \u03c3(p_2).', 'The conclusion correctly represents \u03c3(p_1) \u2265 \u03c3(p_2) by substituting the definitions directly.', \"The additional non-negativity constraint def_1a is mathematically reasonable and doesn't contradict the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since $M\\le\\sigma(p)\\le Mn^{1/p}$", "statement": "We assume:\n\u2022 $u_1, ..., u_n$ are nonnegative numbers and $M = \\max\\{u_i\\}$ [def_1].\n\u2022 $\\sigma(p) = (\\sum_{i=1}^n u_i^p)^{1/p}$ [def_2].\nTherefore, we conclude:\n\u2022 For any $p \\ge 1$, $M \\le \\sigma(p) \\le M n^{1/p}$ [l4].", "dependencies": ["def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (hp : 1 \u2264 p)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_1b : \u2203 M : \u211d, M = Finset.univ.sup u)\n  (def_2 : (\u2200 p', (Finset.univ.sum fun i => (u i) ^ p') ^ (1 / p') = (Finset.univ.sum fun i => (u i) ^ p') ^ (1 / p'))) :\n  let M := Finset.univ.sup u\n  M \u2264 (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p) \u2227 (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p) \u2264 M * (n : \u211d) ^ (1 / p) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 25, "endLine": 11, "endColumn": 42, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 13, "column": 11, "endLine": 13, "endColumn": 28, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (hp : 1 \u2264 p)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_1b : \u2203 M : \u211d, M = Finset.sup Finset.univ u)\n  (def_2 : (\u2200 p', (Finset.sum Finset.univ fun i => (u i) ^ p') ^ (1 / p') = (Finset.sum Finset.univ fun i => (u i) ^ p') ^ (1 / p'))) :\n  let M := Finset.sup Finset.univ u\n  M \u2264 (Finset.sum Finset.univ fun i => (u i) ^ p) ^ (1 / p) \u2227 (Finset.sum Finset.univ fun i => (u i) ^ p) ^ (1 / p) \u2264 M * (n : \u211d) ^ (1 / p) := by\n  let M := Finset.sup Finset.univ u\n  have hM : \u2203 i, u i = M := by\n    obtain \u27e8i, hi\u27e9 := Finset.exists_mem_eq_sup Finset.univ u\n    exact \u27e8i, hi\u27e9\n  constructor\n  \u00b7 obtain \u27e8i, hi\u27e9 := hM\n    rw [\u2190hi]\n    have h : (u i ^ p) ^ (1 / p) = u i := by\n      rw [\u2190rpow_mul (def_1a i), mul_one_div_cancel hp.ne', rpow_one]\n    rw [\u2190h]\n    apply rpow_le_rpow (def_1a i) (le_sup (Finset.mem_univ i)) (le_of_lt (one_pos.trans_le hp))\n    exact Finset.sum_nonneg fun i _ => rpow_nonneg_of_nonneg (def_1a i) p\n  \u00b7 have hsum : (\u2211 i, u i ^ p) \u2264 n \u2022 M ^ p := by\n      simp_rw [nsmul_eq_mul]\n      refine Finset.sum_le_sum (fun i _ => ?_)\n      rw [\u2190rpow_le_rpow_iff (def_1a i) (le_sup (Finset.mem_univ i)) hp]\n      exact rpow_le_rpow (def_1a i) (le_sup (Finset.mem_univ i)) hp\n    rw [\u2190rpow_le_rpow_iff (Finset.sum_nonneg fun i _ => rpow_nonneg_of_nonneg (def_1a i) p) (mul_nonneg (le_sup (Finset.mem_univ (Classical.choose hM))) (rpow_nonneg_of_nonneg (Nat.cast_nonneg n) (1 / p))) (one_div_pos.mpr (one_pos.trans_le hp)).le]\n    simp_rw [mul_rpow (le_sup (Finset.mem_univ (Classical.choose hM))) (Nat.cast_nonneg n), rpow_one_div hp.ne', \u2190nsmul_eq_mul]\n    exact hsum", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 25, "endLine": 11, "endColumn": 49, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 13, "column": 11, "endLine": 13, "endColumn": 35, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 15, "column": 11, "endLine": 15, "endColumn": 35, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 17, "column": 59, "endLine": 17, "endColumn": 60, "data": "application type mismatch\n  Finset.exists_mem_eq_sup Finset.univ u\nargument\n  u\nhas type\n  Fin n \u2192 \u211d : Type\nbut is expected to have type\n  Finset.univ.Nonempty : Prop"}, {"line": 17, "column": 11, "endLine": 17, "endColumn": 18, "data": "rcases tactic failed: x\u271d : \u2200 (f : ?m.7103 \u2192 ?m.7098),\n  \u2203 i \u2208 Finset.univ, Finset.univ.sup f = f i is not an inductive datatype"}, {"line": 21, "column": 8, "endLine": 21, "endColumn": 11, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  M\ncase left.intro\nn : \u2115\nu : Fin n \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\ndef_1a : \u2200 (i : Fin n), 0 \u2264 u i\ndef_1b : \u2203 M, M = sorry\ndef_2 : \u2200 (p' : \u2115), (\u2211 i : Fin n, u i ^ p') ^ (1 / p') = (\u2211 i : Fin n, u i ^ p') ^ (1 / p')\nM : \u211d := sorry\ni : Fin n\nhi : u i = M\n\u22a2 sorry \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p)"}, {"line": 29, "column": 6, "endLine": 29, "endColumn": 46, "data": "type mismatch\n  Finset.sum_le_sum fun i x => ?m.11579\nhas type\n  \u2211 i \u2208 ?m.11277, ?m.11275 i \u2264 \u2211 i \u2208 ?m.11277, ?m.11276 i : Prop\nbut is expected to have type\n  \u2211 i : Fin n, u i ^ p \u2264 \u2191n * M ^ p : Prop"}, {"line": 32, "column": 56, "endLine": 32, "endColumn": 77, "data": "unknown identifier 'rpow_nonneg_of_nonneg'"}, {"line": 32, "column": 105, "endLine": 32, "endColumn": 111, "data": "unknown identifier 'le_sup'"}, {"line": 32, "column": 154, "endLine": 32, "endColumn": 175, "data": "unknown identifier 'rpow_nonneg_of_nonneg'"}, {"line": 32, "column": 8, "endLine": 32, "endColumn": 248, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2211 i \u2208 ?m.12404, ?m.12403 i \u2264 ?m.12480 * ?m.12481\ncase right\nn : \u2115\nu : Fin n \u2192 \u211d\np : \u211d\nhp : 1 \u2264 p\ndef_1a : \u2200 (i : Fin n), 0 \u2264 u i\ndef_1b : \u2203 M, M = sorry\ndef_2 : \u2200 (p' : \u2115), (\u2211 i : Fin n, u i ^ p') ^ (1 / p') = (\u2211 i : Fin n, u i ^ p') ^ (1 / p')\nM : \u211d := sorry\nhM : \u2203 i, u i = M\nhsum : \u2211 i : Fin n, u i ^ p \u2264 n \u2022 M ^ p\n\u22a2 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) \u2264 sorry * \u2191n ^ (1 / p)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "$\n\\lim_{p\\to\\infty}\\sigma(p)= M$.\n", "statement": "We assume:\n\u2022 For any $p \\ge 1$, $M \\le \\sigma(p) \\le M n^{1/p}$ [l4].\nTherefore, we conclude:\n\u2022 $\\lim_{p\\to\\infty} \\sigma(p) = M$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {n : \u2115} (u : Fin n \u2192 \u211d) (M : \u211d)\n  (hu_nonneg : \u2200 i, 0 \u2264 u i)\n  (hM : M = (Finset.univ.image u).sup' (Finset.univ.nonempty_of_isEmpty (by simp)) id)\n  (sigma : \u211d \u2192 \u211d)\n  (h_sigma_def : \u2200 p : \u211d, p \u2260 0 \u2192 sigma p = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p))\n  (l4 : \u2200 p : \u211d, 1 \u2264 p \u2192 M \u2264 sigma p \u2227 sigma p \u2264 M * n ^ (1 / p)) :\n  Filter.Tendsto sigma Filter.atTop (nhds M) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 40, "endLine": 8, "endColumn": 81, "data": "invalid field 'nonempty_of_isEmpty', the environment does not contain 'Finset.nonempty_of_isEmpty'\n  Finset.univ\nhas type\n  Finset ?m.425"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {n : \u2115} (u : Fin n \u2192 \u211d) (M : \u211d)\n  (hu_nonneg : \u2200 i, 0 \u2264 u i)\n  (hM : M = (Finset.univ.image u).sup' (by simp) id)\n  (sigma : \u211d \u2192 \u211d)\n  (h_sigma_def : \u2200 p : \u211d, p \u2260 0 \u2192 sigma p = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p))\n  (l4 : \u2200 p : \u211d, 1 \u2264 p \u2192 M \u2264 sigma p \u2227 sigma p \u2264 M * n ^ (1 / p)) :\n  Filter.Tendsto sigma Filter.atTop (nhds M) := by\n  have hM_pos : 0 \u2264 M := by\n    rw [hM]\n    apply Finset.le_sup' _ _ \u27e80, by simp\u27e9\n    exact fun i => hu_nonneg i\n  refine tendsto_atTop_nhds_of_eventually_const_le_and_tendsto M ?_ ?_\n  \u00b7 obtain \u27e8p, hp\u27e9 := exists_gt (1 : \u211d)\n    refine eventually_atTop.2 \u27e8p, fun q hq => ?_\u27e9\n    exact (l4 q (by linarith)).1\n  \u00b7 refine tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds ?_ ?_ ?_\n    \u00b7 refine (tendsto_rpow_atTop (by linarith)).comp tendsto_id\n    \u00b7 intro p\n      exact (l4 p (by linarith)).2\n    \u00b7 refine eventually_of_forall fun p => ?_\n      rw [mul_comm]\n      refine mul_le_of_le_one_right hM_pos ?_\n      rw [\u2190 Real.rpow_zero n]\n      refine Real.rpow_le_rpow_of_nonneg (by simp) (by linarith) (by simp)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 40, "endLine": 8, "endColumn": 47, "data": "unsolved goals\nn : \u2115\nu : Fin n \u2192 \u211d\nM : \u211d\nhu_nonneg : \u2200 (i : Fin n), 0 \u2264 u i\n\u22a2 Finset.univ.Nonempty"}, {"line": 15, "column": 10, "endLine": 15, "endColumn": 41, "data": "function expected at\n  Finset.le_sup' ?m.5064 ?m.5066\nterm has type\n  ?m.5064 ?m.5065 \u2264 Finset.sup' ?m.5063 \u22ef ?m.5064"}, {"line": 16, "column": 4, "endLine": 16, "endColumn": 30, "data": "no goals to be solved"}, {"line": 17, "column": 9, "endLine": 17, "endColumn": 62, "data": "unknown identifier 'tendsto_atTop_nhds_of_eventually_const_le_and_tendsto'"}, {"line": 18, "column": 2, "endLine": 20, "endColumn": 32, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "Letting  $u_i=|x_i|$", "statement": "Definition:\n\u2022 Given a vector $\\mathbf{X}\\in\\R^n$ with components $x_i$ [tc_1], let $u_i = |x_i|$ for $i=1, ..., n$. This satisfies the non-negativity condition for $u_i$ [def_1a].\n\u2022 With this substitution, $\\sigma(p)$ as defined in [def_2] becomes the p-norm $\\|\\mathbf{X}\\|_{p} = (\\sum_{i=1}^n |x_i|^p)^{1/p}$.\n\u2022 And $M$ as defined in [def_1b] becomes $\\max\\set{|x_i|}{1\\le i\\le n}$ [def_3].", "dependencies": ["tc_1", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (x : Fin n \u2192 \u211d)\n  (u : Fin n \u2192 \u211d)\n  (tc_1 : (x : Fin n \u2192 \u211d) \u2192 Prop)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_1b : (M : \u211d) \u2192 (\u2200 i, u i \u2264 M) \u2227 (\u2203 j, u j = M))\n  (def_2 : (p : \u211d) \u2192 (1 \u2264 p) \u2192 (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p) = (Finset.univ.sum fun i => (u i) ^ p) ^ (1 / p))", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean has `x : Fin n \u2192 \u211d` which represents the vector components, and `tc_1` is declared as a proposition about such vectors. This captures the essence but `tc_1` is more abstract than the natural language suggests.", "The natural language defines `u_i = |x_i|`, but the Lean code declares `u : Fin n \u2192 \u211d` as an independent variable without establishing the relationship `u i = |x i|`. This is a major missing component.", "The Lean `def_2` is a tautological statement that doesn't actually define what \u03c3(p) is - it just says a sum equals itself. This completely misses the intended definition of \u03c3(p).", "The Lean `def_1b` captures the structure of defining M as a maximum (something that all u_i are \u2264 and some u_j equals), which matches the mathematical concept of maximum, though the natural language reference is indirect.", "The Lean `def_1a` assumes non-negativity as a condition rather than proving it as a conclusion. Since u_i should equal |x_i|, non-negativity should follow automatically, not be assumed.", "The Lean formalization completely lacks any statement about \u03c3(p) becoming the p-norm. The def_2 in Lean is tautological and doesn't establish this relationship.", "The Lean formalization has no statement corresponding to M becoming the maximum of absolute values. While def_1b defines a maximum structure, it doesn't connect it to the absolute values |x_i|."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean has `x : Fin n \u2192 \u211d` which represents the vector components, and `tc_1` is declared as a proposition about such vectors. This captures the essence but `tc_1` is more abstract than the natural language suggests.', 'The natural language defines `u_i = |x_i|`, but the Lean code declares `u : Fin n \u2192 \u211d` as an independent variable without establishing the relationship `u i = |x i|`. This is a major missing component.', \"The Lean `def_2` is a tautological statement that doesn't actually define what \u03c3(p) is - it just says a sum equals itself. This completely misses the intended definition of \u03c3(p).\", 'The Lean `def_1b` captures the structure of defining M as a maximum (something that all u_i are \u2264 and some u_j equals), which matches the mathematical concept of maximum, though the natural language reference is indirect.', 'The Lean `def_1a` assumes non-negativity as a condition rather than proving it as a conclusion. Since u_i should equal |x_i|, non-negativity should follow automatically, not be assumed.', \"The Lean formalization completely lacks any statement about \u03c3(p) becoming the p-norm. The def_2 in Lean is tautological and doesn't establish this relationship.\", \"The Lean formalization has no statement corresponding to M becoming the maximum of absolute values. While def_1b defines a maximum structure, it doesn't connect it to the absolute values |x_i|.\"]"}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "Letting  $u_i=|x_i|$  yields \\eqref{eq:8.1.12}", "statement": "We assume:\n\u2022 For non-negative $u_i$ and $p_2 > p_1 \\ge 1$, $\\sigma(p_1) \\ge \\sigma(p_2)$ [l3].\n\u2022 Letting $u_i = |x_i|$ maps $\\sigma(p)$ to $\\|\\mathbf{X}\\|_{p}$ [def_3].\nTherefore, we conclude:\n\u2022 $\\|\\mathbf{X}\\|_{p_2} \\le \\|\\mathbf{X}\\|_{p_1}$ [ts_1].", "dependencies": ["l3", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (x : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (l3 : (\u2200 (i : Fin n), 0 \u2264 |x i|) \u2192 (p2 > p1 \u2227 p1 \u2265 1) \u2192 (Finset.univ.sum fun i => (|x i|) ^ p1) ^ (1 / p1) \u2265 (Finset.univ.sum fun i => (|x i|) ^ p2) ^ (1 / p2))\n  (def_3 : (p : \u211d) \u2192 (Finset.univ.sum fun i => (|x i|) ^ p) ^ (1 / p) = \u2016x\u2016_p) :\n  \u2016x\u2016_p2 \u2264 \u2016x\u2016_p1 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 75, "endLine": 8, "endColumn": 77, "data": "unexpected identifier; expected ')'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (x : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (l3 : (\u2200 (i : Fin n), 0 \u2264 |x i|) \u2192 (p2 > p1 \u2227 p1 \u2265 1) \u2192 (Finset.univ.sum fun i => (|x i|) ^ p1) ^ (1 / p1) \u2265 (Finset.univ.sum fun i => (|x i|) ^ p2) ^ (1 / p2))\n  (def_3 : (p : \u211d) \u2192 (Finset.univ.sum fun i => (|x i|) ^ p) ^ (1 / p) = NNReal.ofReal (Finset.univ.sum fun i => (|x i|) ^ p) ^ (1 / p)) :\n  NNReal.ofReal (Finset.univ.sum fun i => (|x i|) ^ p2) ^ (1 / p2) \u2264 NNReal.ofReal (Finset.univ.sum fun i => (|x i|) ^ p1) ^ (1 / p1) := by\n  have h_nonneg : \u2200 i, 0 \u2264 |x i| := fun i => abs_nonneg (x i)\n  specialize l3 h_nonneg\n  simp [\u2190 def_3 p1, \u2190 def_3 p2]\n  exact l3", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 72, "endLine": 8, "endColumn": 124, "data": "unknown constant 'NNReal.ofReal'"}, {"line": 9, "column": 2, "endLine": 9, "endColumn": 55, "data": "unknown constant 'NNReal.ofReal'"}, {"line": 9, "column": 69, "endLine": 9, "endColumn": 122, "data": "unknown constant 'NNReal.ofReal'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}, "ts_2": {"id": "ts_2", "natural_language": "and \\eqref{eq:8.1.13}.", "statement": "We assume:\n\u2022 For non-negative $u_i$, $\\lim_{p\\to\\infty} \\sigma(p) = M$ [l5], where $M = \\max\\{u_i\\}$.\n\u2022 Letting $u_i = |x_i|$ maps $\\sigma(p)$ to $\\|\\mathbf{X}\\|_{p}$ and $M$ to $\\max\\set{|x_i|}{1\\le i\\le n}$ [def_3].\nTherefore, we conclude:\n\u2022 $\\lim_{p\\to\\infty}\\|\\mathbf{X}\\|_{p}=\\max\\set{|x_i|}{1\\le i\\le n}$ [ts_2].", "dependencies": ["l5", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (x : Fin n \u2192 \u211d)\n  (u : Fin n \u2192 \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_1b : (M : \u211d) \u2192 (\u2200 i, u i \u2264 M) \u2227 (\u2203 j, u j = M))\n  (def_2 : \u2200 (p : \u211d) (hp : 1 \u2264 p), (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p))  -- This seems to be a placeholder\n  (l5 : \u2200 (M' : \u211d), (\u2200 i, u i \u2264 M') \u2227 (\u2203 j, u j = M') \u2192 (Filter.Tendsto (fun p => (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p)) Filter.atTop (nhds M')))\n  (def_3 : u = fun i => |x i|) :\n  Filter.Tendsto (fun (p : \u211d) => (\u2211 i : Fin n, (|x i|) ^ p) ^ (1 / p)) Filter.atTop (nhds (Finset.univ.image (fun i => |x i|)).sup) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 13, "column": 90, "endLine": 13, "endColumn": 130, "data": "application type mismatch\n  \ud835\udcdd (Finset.image (fun i => |x i|) Finset.univ).sup\nargument\n  (Finset.image (fun i => |x i|) Finset.univ).sup\nhas type\n  (\u211d \u2192 ?m.3800) \u2192 ?m.3800 : Type (max 0 ?u.3793)\nbut is expected to have type\n  \u211d : Type"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (x : Fin n \u2192 \u211d)\n  (u : Fin n \u2192 \u211d)\n  (def_1a : \u2200 i, 0 \u2264 u i)\n  (def_1b : (M : \u211d) \u2192 (\u2200 i, u i \u2264 M) \u2227 (\u2203 j, u j = M))\n  (def_2 : \u2200 (p : \u211d) (hp : 1 \u2264 p), (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p))\n  (l5 : \u2200 (M' : \u211d), (\u2200 i, u i \u2264 M') \u2227 (\u2203 j, u j = M') \u2192 (Filter.Tendsto (fun p => (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p)) Filter.atTop (nhds M')))\n  (def_3 : u = fun i => |x i|) :\n  Filter.Tendsto (fun (p : \u211d) => (\u2211 i : Fin n, (|x i|) ^ p) ^ (1 / p)) Filter.atTop (nhds (Finset.sup Finset.univ (fun i => |x i|))) := by\n  rw [\u2190 def_3]\n  apply l5 (Finset.sup Finset.univ u)\n  constructor\n  \u00b7 intro i\n    exact Finset.le_sup (Finset.mem_univ i)\n  \u00b7 obtain \u27e8j, hj\u27e9 := def_1b (Finset.sup Finset.univ u)\n    exact \u27e8j, hj.2\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 91, "endLine": 13, "endColumn": 130, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 14, "column": 6, "endLine": 14, "endColumn": 13, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  fun i => |x i|\nn : \u2115\nx u : Fin n \u2192 \u211d\ndef_1a : \u2200 (i : Fin n), 0 \u2264 u i\ndef_1b : \u2200 (M : \u211d), (\u2200 (i : Fin n), u i \u2264 M) \u2227 \u2203 j, u j = M\ndef_2 : \u2200 (p : \u211d), 1 \u2264 p \u2192 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nl5 :\n  \u2200 (M' : \u211d),\n    ((\u2200 (i : Fin n), u i \u2264 M') \u2227 \u2203 j, u j = M') \u2192 Tendsto (fun p => (\u2211 i : Fin n, u i ^ p) ^ (1 / p)) atTop (\ud835\udcdd M')\ndef_3 : u = fun i => |x i|\n\u22a2 Tendsto (fun p => (\u2211 i : Fin n, |x i| ^ p) ^ (1 / p)) atTop (\ud835\udcdd sorry)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    