
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=5$ and the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, $a_n = 2^{n-1}+3^{n-1}$.

Proof: We will prove this by strong mathematical induction on $n$. First, for the base cases, we need to verify the formula holds for $n=1$ and $n=2$. For $n=1$, we are given $a_1=2$. The formula gives $a_1=2^{1-1}+3^{1-1}=2^0+3^0=1+1=2$. This holds. For $n=2$, we are given $a_2=5$. The formula gives $a_2=2^{2-1}+3^{2-1}=2^1+3^1=2+3=5$. This also holds. Now, for the inductive step, we assume the statement is true for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{j-1}+3^{j-1}$ for $1 \leq j \leq k$. We want to show the statement is true for $k+1$, i.e., $a_{k+1}=2^{k}+3^{k}$. From the recurrence relation, we have $a_{k+1}=5a_k-6a_{k-1}$. By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$. So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$. We expand this: $5 \cdot 2^{k-1} + 5 \cdot 3^{k-1} - 6 \cdot 2^{k-2} - 6 \cdot 3^{k-2}$. We can rewrite the coefficients. $5 \cdot 2^{k-1} = (2+3) \cdot 2^{k-1} = 2 \cdot 2^{k-1} + 3 \cdot 2^{k-1} = 2^k + 3 \cdot 2^{k-1}$. No, that's not right. $5 \cdot 2^{k-1} = 5 \cdot 2^{k-2} \cdot 2 = 10 \cdot 2^{k-2}$. We have $a_{k+1}=10 \cdot 2^{k-2} + 15 \cdot 3^{k-2} - 6 \cdot 2^{k-2} - 6 \cdot 3^{k-2}$. Combining like terms gives $(10-6) \cdot 2^{k-2} + (15-6) \cdot 3^{k-2} = 4 \cdot 2^{k-2} + 9 \cdot 3^{k-2}$. We can simplify this further: $4 \cdot 2^{k-2} = 2^2 \cdot 2^{k-2} = 2^k$. And $9 \cdot 3^{k-2} = 3^2 \cdot 3^{k-2} = 3^k$. Thus, $a_{k+1}=2^k+3^k$. This matches the formula for $n=k+1$. By the principle of strong mathematical induction, the statement is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=5$ and the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 (a_n) is a sequence of integers for n \u2265 1, defined by a\u2081=2, a\u2082=5, and a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2124)\n(tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'a : \u2115 \u2192 \u2124' perfectly captures that (a_n) is a sequence of integers for n \u2265 1, as \u2115 represents natural numbers starting from 1 in this context and \u2124 represents integers", "The Lean condition 'a 1 = 2' exactly matches the natural language condition 'a\u2081 = 2'", "The Lean condition 'a 2 = 5' exactly matches the natural language condition 'a\u2082 = 5'", "The Lean condition '\u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2)' perfectly captures the recurrence relation 'a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3'", "The Lean formalization implicitly captures that the sequence is completely defined by providing the exact conditions needed for unique determination. While not explicitly stated as a conclusion, the mathematical meaning is preserved through the complete specification of initial conditions and recurrence relation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, we are given $a_1=2$. The formula gives $a_1=2^{1-1}+3^{1-1}=2^0+3^0=1+1=2$. This holds.", "statement": "We assume:\n\u2022 The sequence (a_n) is defined by a\u2081=2, a\u2082=5, and a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3 [tc_1].\nTherefore, we conclude:\n\u2022 a\u2081 = 2\u00b9\u207b\u00b9 + 3\u00b9\u207b\u00b9 [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 1 = 2^(1 - 1) + 3^(1 - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 1 = 2^(1 - 1) + 3^(1 - 1) := by\n  have h1 := tc_1.1\n  rw [h1]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly formalized with proper initial conditions and recurrence relation. The type declaration (\u2115 \u2192 \u2124) appropriately represents the sequence.", "The conclusion statement is accurately translated, with correct exponentiation notation and the logical connection to the premise maintained through the lemma structure."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we are given $a_2=5$. The formula gives $a_2=2^{2-1}+3^{2-1}=2^1+3^1=2+3=5$. This also holds.", "statement": "We assume:\n\u2022 The sequence (a_n) is defined by a\u2081=2, a\u2082=5, and a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3 [tc_1].\nTherefore, we conclude:\n\u2022 a\u2082 = 2\u00b2\u207b\u00b9 + 3\u00b2\u207b\u00b9 [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 2 = 2^(2 - 1) + 3^(2 - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 2 = 2^(2 - 1) + 3^(2 - 1) := by\n  have \u27e8_, h2, _\u27e9 := tc_1\n  rw [h2]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is correctly formalized in Lean, capturing all the mathematical details from the natural language.", "The conclusion statement a\u2082 = 2\u00b2\u207b\u00b9 + 3\u00b2\u207b\u00b9 is accurately translated to Lean syntax with proper exponentiation notation.", "The logical structure correctly represents the natural language reasoning, with the sequence definition as hypothesis and the equality as the conclusion to be proved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now, for the inductive step, we assume the statement is true for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{j-1}+3^{j-1}$ for $1 \\leq j \\leq k$.", "statement": "Definition:\n\u2022 For the inductive step, fix an integer k \u2265 2 and assume the Inductive Hypothesis (IH): a_j = 2\u02b2\u207b\u00b9 + 3\u02b2\u207b\u00b9 holds for all integers j such that 1 \u2264 j \u2264 k [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (j - 1) + 3 ^ (j - 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies k as an integer, but Lean uses natural numbers (\u2115). Since k \u2265 2, this doesn't affect the mathematical meaning as all relevant values are positive, but it's a type difference.", "The Lean formalization perfectly captures the inductive hypothesis with the same mathematical formula and range conditions.", "The conclusion about establishing the inductive step framework is implicitly captured by the Lean variable declarations, which set up exactly what's needed for an inductive proof step."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relation, we have $a_{k+1}=5a_k-6a_{k-1}$.", "statement": "We assume:\n\u2022 (a_n) is a sequence defined by a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3 [tc_1].\n\u2022 k is an integer such that k \u2265 2 [def_1].\nTherefore, we conclude:\n\u2022 a_{k+1} = 5a_k - 6a_{k-1} [l3].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (def_1 : k \u2265 2) :\n  a (k + 1) = 5 * a k - 6 * a (k - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (tc_1 : a 1 = 2 \u2227 a 2 = 5 \u2227 \u2200 n \u2265 3, a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (def_1 : k \u2265 2) :\n  a (k + 1) = 5 * a k - 6 * a (k - 1) := by\n  have hk : k + 1 \u2265 3 := by linarith\n  rw [tc_1.2.2 (k + 1) hk]\n  simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the essential logical and mathematical meaning from the natural language. While it includes additional initial conditions (a\u2081 = 2, a\u2082 = 5) not mentioned in the natural language, these are extra logically consistent details that don't contradict the given information. The recurrence relation, constraint on k, and conclusion are all properly formalized. The type restriction of k from integers to natural numbers is acceptable given the constraint k \u2265 2."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$. So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$.", "statement": "We assume:\n\u2022 a_{k+1} = 5a_k - 6a_{k-1} [l3].\n\u2022 The Inductive Hypothesis (IH): a_j = 2\u02b2\u207b\u00b9 + 3\u02b2\u207b\u00b9 for all integers j such that 1 \u2264 j \u2264 k, where k \u2265 2 [def_1].\nTherefore, we conclude:\n\u2022 a_{k+1} = 5(2\u1d4f\u207b\u00b9 + 3\u1d4f\u207b\u00b9) - 6(2\u1d4f\u207b\u00b2 + 3\u1d4f\u207b\u00b2) [l4].", "dependencies": ["l3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l3 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (j - 1) + 3 ^ (j - 1)) :\n  a (k + 1) = 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l3 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2 ^ (j - 1) + 3 ^ (j - 1)) :\n  a (k + 1) = 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) := by\n  rw [l3]\n  have hk1 : 1 \u2264 k \u2227 k \u2264 k := by\n    constructor\n    \u00b7 exact Nat.one_le_of_lt hk\n    \u00b7 exact le_refl k\n  have hk2 : 1 \u2264 k - 1 \u2227 k - 1 \u2264 k := by\n    constructor\n    \u00b7 exact Nat.le_sub_one_of_lt hk\n    \u00b7 exact Nat.sub_le k 1\n  rw [def_1 k hk1, def_1 (k - 1) hk2]\n  simp [Nat.sub_sub]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The recurrence relation a_{k+1} = 5a_k - 6a_{k-1} is captured exactly in the Lean hypothesis l3.", "The inductive hypothesis with its universal quantification over the range 1 \u2264 j \u2264 k and the constraint k \u2265 2 are perfectly formalized in def_1 and hk.", "The conclusion formula is translated exactly, with proper operator precedence and exponentiation notation.", "The logical structure from assumptions to conclusion is properly captured as a lemma with hypotheses leading to the goal.", "Variable types are appropriately chosen - using natural numbers for sequence indices is mathematically sound and more precise than the general 'integers' mentioned in natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$. ... We have $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$.", "statement": "We assume:\n\u2022 a_{k+1} = 5(2\u1d4f\u207b\u00b9 + 3\u1d4f\u207b\u00b9) - 6(2\u1d4f\u207b\u00b2 + 3\u1d4f\u207b\u00b2) [l4].\nTherefore, we conclude:\n\u2022 a_{k+1} = 10 \u22c5 2\u1d4f\u207b\u00b2 + 15 \u22c5 3\u1d4f\u207b\u00b2 - 6 \u22c5 2\u1d4f\u207b\u00b2 - 6 \u22c5 3\u1d4f\u207b\u00b2 [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l4 : a (k + 1) = 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2))) :\n  a (k + 1) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l4 : a (k + 1) = 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2))) :\n  a (k + 1) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) := by\n  rw [l4]\n  have h1 : k - 1 = (k - 2) + 1 := by omega\n  rw [h1, pow_add, pow_add, pow_one, pow_one]\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l4 in Lean perfectly captures the mathematical equation from the natural language premise, with correct translation of notation from subscripts and superscripts to Lean syntax.", "The conclusion in Lean exactly matches the expanded form shown in the natural language, correctly representing the algebraic manipulation.", "The logical structure is properly maintained - the Lean lemma correctly shows that the conclusion follows from the assumption l4.", "The additional type declarations and constraint hk : k \u2265 2 are mathematically sound additions that don't contradict the natural language but provide necessary context for the formal proof."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Combining like terms gives $(10-6) \\cdot 2^{k-2} + (15-6) \\cdot 3^{k-2} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$.", "statement": "We assume:\n\u2022 a_{k+1} = 10 \u22c5 2\u1d4f\u207b\u00b2 + 15 \u22c5 3\u1d4f\u207b\u00b2 - 6 \u22c5 2\u1d4f\u207b\u00b2 - 6 \u22c5 3\u1d4f\u207b\u00b2 [l5].\nTherefore, we conclude:\n\u2022 a_{k+1} = 4 \u22c5 2\u1d4f\u207b\u00b2 + 9 \u22c5 3\u1d4f\u207b\u00b2 [l6].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : a (k + 1) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2)) :\n  a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : a (k + 1) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2)) :\n  a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) := by\n  rw [l5]\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Function and variable declarations are appropriately formalized with explicit types that match the mathematical context", "The constraint k \u2265 2 is properly captured as an explicit hypothesis, which is mathematically necessary for the exponents k-2 to be well-defined", "The premise l5 is exactly translated with correct mathematical operations and precedence", "The conclusion l6 is precisely formalized with the correct simplified algebraic expression", "The logical flow from assumption to conclusion is properly structured as a Lean lemma with appropriate hypothesis and goal"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "We can simplify this further: $4 \\cdot 2^{k-2} = 2^2 \\cdot 2^{k-2} = 2^k$. And $9 \\cdot 3^{k-2} = 3^2 \\cdot 3^{k-2} = 3^k$. Thus, $a_{k+1}=2^k+3^k$.", "statement": "We assume:\n\u2022 a_{k+1} = 4 \u22c5 2\u1d4f\u207b\u00b2 + 9 \u22c5 3\u1d4f\u207b\u00b2 [l6].\nTherefore, we conclude:\n\u2022 a_{k+1} = 2\u1d4f + 3\u1d4f [l7].", "dependencies": ["l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l6 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2)) :\n  a (k + 1) = 2 ^ k + 3 ^ k := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l6 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2)) :\n  a (k + 1) = 2 ^ k + 3 ^ k := by\n  rw [l6]\n  have h1 : 4 * 2 ^ (k - 2) = 2 ^ k := by\n    rw [\u2190 mul_assoc, \u2190 pow_add]\n    congr 1\n    rw [Nat.sub_add_cancel hk]\n  have h2 : 9 * 3 ^ (k - 2) = 3 ^ k := by\n    rw [\u2190 mul_assoc, \u2190 pow_add]\n    congr 1\n    rw [Nat.sub_add_cancel hk]\n  rw [h1, h2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 8, "endLine": 13, "endColumn": 19, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a * (?b * ?c)\na : \u2115 \u2192 \u211d\nk : \u2115\nhk : k \u2265 2\nl6 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2)\n\u22a2 4 * 2 ^ (k - 2) = 2 ^ k"}, {"line": 17, "column": 8, "endLine": 17, "endColumn": 19, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a * (?b * ?c)\na : \u2115 \u2192 \u211d\nk : \u2115\nhk : k \u2265 2\nl6 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2)\nh1 : 4 * 2 ^ (k - 2) = 2 ^ k\n\u22a2 9 * 3 ^ (k - 2) = 3 ^ k"}, {"line": 20, "column": 6, "endLine": 20, "endColumn": 8, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  4 * 2 ^ (k - 2)\na : \u2115 \u2192 \u211d\nk : \u2115\nhk : k \u2265 2\nl6 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2)\nh1 : 4 * 2 ^ (k - 2) = 2 ^ k\nh2 : 9 * 3 ^ (k - 2) = 3 ^ k\n\u22a2 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) = 2 ^ k + 3 ^ k"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumption/premise is correctly formalized with the exact same mathematical expression using appropriate Lean syntax for exponentiation and arithmetic operations.", "The conclusion is correctly formalized with the target expression that should be proven equivalent to the premise.", "The additional constraint k \u2265 2 is mathematically necessary (though not explicitly stated in natural language) to ensure the exponents k-2 are non-negative, which is required for natural number exponentiation in Lean.", "The overall structure correctly captures the logical flow from assumption to conclusion, and the mathematical relationship between the premise and conclusion is valid.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l7\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l6 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2)) :\n  \u00ac(a (k + 1) = 2 ^ k + 3 ^ k) := by\n  intro h\n  rw [\u2190 l6] at h\n  generalize hp : k - 2 = p\n  rw [hp] at hk h\n  have hk' : p + 2 = k := by omega\n  rw [hk'] at h\n  simp at h\n  ring_nf at h\n  have : 3 ^ p * 3 ^ p \u2260 0 := by exact pow_ne_zero _ (by norm_num)\n  field_simp at h\n  norm_num at h\n  linarith"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of strong mathematical induction, the statement is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 For n=1, a\u2081 = 2\u00b9\u207b\u00b9 + 3\u00b9\u207b\u00b9 [l1].\n\u2022 For n=2, a\u2082 = 2\u00b2\u207b\u00b9 + 3\u00b2\u207b\u00b9 [l2].\n\u2022 For any integer k \u2265 2, the assumption that a_j = 2\u02b2\u207b\u00b9 + 3\u02b2\u207b\u00b9 for all 1 \u2264 j \u2264 k implies that a_{k+1} = 2\u1d4f + 3\u1d4f [l7].\nTherefore, we conclude:\n\u2022 For all integers n \u2265 1, a_n = 2\u207f\u207b\u00b9 + 3\u207f\u207b\u00b9 [ts_1].", "dependencies": ["l1", "l2", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u2124)\n  (l1 : a 1 = 2^(1 - 1) + 3^(1 - 1))\n  (l2 : a 2 = 2^(2 - 1) + 3^(2 - 1))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) \u2192 a (k + 1) = 2^k + 3^k) :\n  \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2^(n - 1) + 3^(n - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u2124)\n  (l1 : a 1 = 2^(1 - 1) + 3^(1 - 1))\n  (l2 : a 2 = 2^(2 - 1) + 3^(2 - 1))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) \u2192 a (k + 1) = 2^k + 3^k) :\n  \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2^(n - 1) + 3^(n - 1) := by\n  intro n hn\n  induction' n using Nat.strong_induction_on with n ih\n  cases' n with n\n  \u00b7 cases hn\n  cases' n with n\n  \u00b7 exact l1\n  cases' n with n\n  \u00b7 exact l2\n  have hk : n + 2 \u2265 2 := by linarith\n  apply l7 _ hk\n  intro j hj\n  have hj1 : 1 \u2264 j := hj.1\n  have hj2 : j \u2264 n + 2 := hj.2\n  have hjn : j < n + 3 := by linarith\n  exact ih j hjn hj1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Base case l1 is correctly formalized with identical mathematical content", "Base case l2 is correctly formalized with identical mathematical content", "Inductive step l7 perfectly captures the logical structure: universal quantification over k\u22652, implication from inductive hypothesis to conclusion", "Conclusion ts_1 correctly states the final result with proper quantification and constraint", "Overall structure properly represents this as a proof by strong induction, with all assumptions and conclusion correctly formalized"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    