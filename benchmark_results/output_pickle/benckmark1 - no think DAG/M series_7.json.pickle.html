
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = \frac{n+1}{2n+1}$. Then for all integers $n \geq 1$, the inequality $\frac{1}{2} < a_n \leq \frac{2}{3}$ holds.

Proof: First, we prove the left-hand side of the inequality, $\frac{1}{2} < a_n$. We are given $a_n = \frac{n+1}{2n+1}$. To show $\frac{1}{2} < \frac{n+1}{2n+1}$, we can cross-multiply since both denominators are positive for $n \geq 1$. This gives us $1(2n+1) < 2(n+1)$, which simplifies to $2n+1 < 2n+2$. Subtracting $2n$ from both sides gives $1 < 2$, which is a true statement. Therefore, $\frac{1}{2} < a_n$ holds for all $n \geq 1$. Next, we prove the right-hand side of the inequality, $a_n \leq \frac{2}{3}$. We need to show that $\frac{n+1}{2n+1} \leq \frac{2}{3}$. Again, we can cross-multiply to get $3(n+1) \leq 2(2n+1)$. This simplifies to $3n+3 \leq 4n+2$. Subtracting $3n$ and $2$ from both sides gives $1 \leq n$. This is true for all integers $n \geq 1$. Since both parts of the inequality hold, the full inequality $\frac{1}{2} < a_n \leq \frac{2}{3}$ is proven.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = \\frac{n+1}{2n+1}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer n, $a_n = \\frac{n+1}{2n+1}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, a n = (n + 1) / (2 * n + 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures that (a_n) is a sequence of real numbers using the type \u2115 \u2192 \u211d", "The natural language specifies 'for any integer n' while Lean uses 'for any natural number n'. Since sequences are typically indexed by natural numbers and the formula makes sense for natural numbers, this is a minor domain restriction that doesn't change the mathematical meaning significantly", "The conclusion that the sequence is well-defined with the explicit formula is implicitly captured in the Lean formalization through the explicit definition"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "for all integers $n \\geq 1$", "statement": "Premise:\n\u2022 $n$ is an integer such that $n \\geq 1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2124)\n(tc_2 : n \u2265 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean variable declaration (n : \u2124) correctly captures that n is an integer", "The Lean constraint (tc_2 : n \u2265 1) exactly matches the mathematical condition n \u2265 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "since both denominators are positive for $n \\geq 1$.", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\geq 1$ [tc_2].\nTherefore, we conclude:\n\u2022 The denominator $2n+1$ is positive [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2124)\n  (tc_2 : n \u2265 1) :\n  (2 * n + 1 : \u211d) > 0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2124)\n  (tc_2 : n \u2265 1) :\n  (2 * n + 1 : \u211d) > 0 := by\n  have h : (n : \u211d) \u2265 1 := by exact_mod_cast tc_2\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The variable declaration (n as integer), the assumption (n \u2265 1), and the conclusion (2n+1 is positive) all match perfectly. The type annotation (: \u211d) is an appropriate mathematical detail that doesn't contradict the natural language. The reference to '2n+1' as a 'denominator' in the natural language provides context but doesn't change the mathematical statement being proven."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "To show $\\frac{1}{2} < \\frac{n+1}{2n+1}$, we can cross-multiply since both denominators are positive for $n \\geq 1$. This gives us $1(2n+1) < 2(n+1)$", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\geq 1$ [tc_2].\n\u2022 The denominator $2n+1$ is positive [l1].\nTherefore, we conclude:\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ holds if and only if $2n+1 < 2(n+1)$ [l2].", "dependencies": ["tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2124)\n  (tc_2 : n \u2265 1)\n  (l1 : (2 * n + 1 : \u211d) > 0) :\n  (1 / 2 : \u211d) < (n + 1) / (2 * n + 1) \u2194 (2 * n + 1 : \u211d) < 2 * (n + 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2124)\n  (tc_2 : n \u2265 1)\n  (l1 : (2 * n + 1 : \u211d) > 0) :\n  (1 / 2 : \u211d) < (n + 1) / (2 * n + 1) \u2194 (2 * n + 1 : \u211d) < 2 * (n + 1) := by\n  rw [div_lt_div_right l1]\n  simp only [mul_lt_mul_right, mul_div_cancel, one_mul, mul_one, cast_add, cast_mul, cast_two]\n  exact lt_of_lt_of_eq (by rfl) (by ring)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 6, "endLine": 10, "endColumn": 25, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.858 / (2 * \u2191n + 1) < ?m.859 / (2 * \u2191n + 1)\nn : \u2124\ntc_2 : n \u2265 1\nl1 : 2 * \u2191n + 1 > 0\n\u22a2 1 / 2 < (\u2191n + 1) / (2 * \u2191n + 1) \u2194 2 * \u2191n + 1 < 2 * (\u2191n + 1)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly and completely captures all components from the natural language. The variable declaration (n as integer \u2265 1), the positivity assumption for the denominator (2n+1 > 0), and the main biconditional statement comparing the fraction inequality with the cross-multiplied inequality are all accurately represented. The type annotations ensuring operations occur in real numbers are mathematically appropriate and don't contradict the natural language statement.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2_neg\n  (n : \u2124)\n  (tc_2 : n \u2265 1)\n  (l1 : (2 * n + 1 : \u211d) > 0) :\n  \u00ac((1 / 2 : \u211d) < (n + 1) / (2 * n + 1) \u2194 (2 * n + 1 : \u211d) < 2 * (n + 1)) := by\n  simp only [not_iff]\n  constructor\n  \u00b7 intro h\n    have h1 : (1 / 2 : \u211d) < (n + 1) / (2 * n + 1) := by\n      rw [\u2190mul_lt_mul_right (zero_lt_two' \u211d)]\n      simp only [one_div, inv_mul_eq_div, div_lt_div_right l1]\n      norm_cast\n      linarith\n    have h2 : \u00ac(2 * n + 1 : \u211d) < 2 * (n + 1) := by\n      norm_cast\n      linarith\n    exact h2 (h.1 h1)\n  \u00b7 intro h\n    have h1 : (2 * n + 1 : \u211d) < 2 * (n + 1) := by\n      norm_cast\n      linarith\n    have h2 : \u00ac(1 / 2 : \u211d) < (n + 1) / (2 * n + 1) := by\n      intro h'\n      exact (h.2 h') h1\n    exact h2 (h.2 h1)"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "which simplifies to $2n+1 < 2n+2$. Subtracting $2n$ from both sides gives $1 < 2$, which is a true statement.", "statement": "We assume:\n\u2022 $n$ is an integer [tc_2].\nTherefore, we conclude:\n\u2022 The inequality $2n+1 < 2(n+1)$ holds if and only if $1 < 2$ [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2124)\n  (tc_2 : n \u2265 1) :\n  (2 * n + 1 < 2 * (n + 1)) \u2194 (1 < 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2124) :\n  (2 * n + 1 < 2 * (n + 1)) \u2194 (1 < 2) := by\n  simp [mul_add, add_lt_add_iff_left]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The variable declaration correctly captures n as an integer in both versions.", "The natural language describes tc_2 as just stating 'n is an integer', but the Lean formalization shows tc_2 as the constraint 'n \u2265 1'. This is a significant additional mathematical condition that is not mentioned in the natural language description.", "The main biconditional statement is perfectly captured: the inequality 2n+1 < 2(n+1) if and only if 1 < 2, with identical mathematical meaning in both versions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable declaration correctly captures n as an integer in both versions.', \"The natural language describes tc_2 as just stating 'n is an integer', but the Lean formalization shows tc_2 as the constraint 'n \u2265 1'. This is a significant additional mathematical condition that is not mentioned in the natural language description.\", 'The main biconditional statement is perfectly captured: the inequality 2n+1 < 2(n+1) if and only if 1 < 2, with identical mathematical meaning in both versions.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Therefore, $\\frac{1}{2} < a_n$ holds for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer n, $a_n = \\frac{n+1}{2n+1}$ [tc_1].\n\u2022 $n$ is an integer such that $n \\geq 1$ [tc_2].\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ holds if and only if $2n+1 < 2(n+1)$ [l2].\n\u2022 The inequality $2n+1 < 2(n+1)$ holds if and only if $1 < 2$ [l3].\nTherefore, we conclude:\n\u2022 $\\frac{1}{2} < a_n$ [l4].", "dependencies": ["tc_1", "tc_2", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (n : \u2115)\n  (tc_1 : \u2200 k : \u2115, a k = (k + 1) / (2 * k + 1))\n  (tc_2 : n \u2265 1)\n  (l2 : (1 / 2 : \u211d) < (n + 1) / (2 * n + 1) \u2194 (2 * n + 1 : \u211d) < 2 * (n + 1))\n  (l3 : (2 * n + 1 < 2 * (n + 1)) \u2194 (1 < 2)) :\n  (1 / 2 : \u211d) < a n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (n : \u2115)\n  (tc_1 : \u2200 k : \u2115, a k = (k + 1) / (2 * k + 1))\n  (tc_2 : n \u2265 1)\n  (l2 : (1 / 2 : \u211d) < (n + 1) / (2 * n + 1) \u2194 (2 * n + 1 : \u211d) < 2 * (n + 1))\n  (l3 : (2 * n + 1 < 2 * (n + 1)) \u2194 (1 < 2)) :\n  (1 / 2 : \u211d) < a n := by\n  rw [tc_1]\n  rw [l2]\n  simp only [Nat.cast_add, Nat.cast_mul, Nat.cast_one]\n  rw [l3]\n  norm_num", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 2, "endLine": 15, "endColumn": 54, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition uses natural numbers (\u2115) instead of integers as stated in natural language, but this is acceptable since n \u2265 1 makes them equivalent in this context.", "The constraint n \u2265 1 is correctly captured.", "The first equivalence is correctly formalized with appropriate type annotations.", "There is a type inconsistency in l3. The left side involves natural number arithmetic while the right side is a simple numeric comparison, creating a type mismatch that wasn't present in the natural language where both sides should be comparable inequalities.", "The conclusion correctly states the desired inequality, though the connection to tc_1 could be more explicit.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition uses natural numbers (\u2115) instead of integers as stated in natural language, but this is acceptable since n \u2265 1 makes them equivalent in this context.', 'The constraint n \u2265 1 is correctly captured.', 'The first equivalence is correctly formalized with appropriate type annotations.', \"There is a type inconsistency in l3. The left side involves natural number arithmetic while the right side is a simple numeric comparison, creating a type mismatch that wasn't present in the natural language where both sides should be comparable inequalities.\", 'The conclusion correctly states the desired inequality, though the connection to tc_1 could be more explicit.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Again, we can cross-multiply to get $3(n+1) \\leq 2(2n+1)$.", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\geq 1$ [tc_2].\n\u2022 The denominator $2n+1$ is positive [l1].\nTherefore, we conclude:\n\u2022 The inequality $\\frac{n+1}{2n+1} \\leq \\frac{2}{3}$ holds if and only if $3(n+1) \\leq 2(2n+1)$ [l5].", "dependencies": ["tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2124)\n  (tc_2 : n \u2265 1)\n  (l1 : (2 * n + 1 : \u211d) > 0) :\n  (n + 1 : \u211d) / (2 * n + 1) \u2264 (2 : \u211d) / 3 \u2194 (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2124)\n  (tc_2 : n \u2265 1)\n  (l1 : (2 * n + 1 : \u211d) > 0) :\n  (n + 1 : \u211d) / (2 * n + 1) \u2264 (2 : \u211d) / 3 \u2194 (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1) := by\n  have h : (0 : \u211d) < 3 := by norm_num\n  rw [div_le_div_iff _ h]\n  \u00b7 simp\n  \u00b7 exact l1", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 4, "endLine": 12, "endColumn": 8, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization accurately captures all mathematical content from the natural language. The variable declaration, constraints, and main equivalence statement are correctly translated. The explicit real number type casting is appropriate for the mathematical operations involved and doesn't contradict the natural language meaning. The logical structure properly represents the assumptions and conclusion relationship.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (n : \u2124)\n  (tc_2 : n \u2265 1)\n  (l1 : (2 * n + 1 : \u211d) > 0) :\n  \u00ac((n + 1 : \u211d) / (2 * n + 1) \u2264 (2 : \u211d) / 3 \u2194 (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1)) := by\n  intro h\n  have h1 : (1 + 1 : \u211d) / (2 * 1 + 1) \u2264 (2 : \u211d) / 3 \u2194 (3 : \u211d) * (1 + 1) \u2264 (2 : \u211d) * (2 * 1 + 1) := by\n    specialize h (n := 1)\n    \u00b7 norm_num\n    \u00b7 norm_num\n    exact h\n  simp at h1\n  have h2 : (2 : \u211d) / 3 \u2264 (2 : \u211d) / 3 \u2194 (6 : \u211d) \u2264 (6 : \u211d) := h1\n  simp at h2\n  exact h2"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "This simplifies to $3n+3 \\leq 4n+2$. Subtracting $3n$ and $2$ from both sides gives $1 \\leq n$.", "statement": "We assume:\n\u2022 $n$ is an integer [tc_2].\nTherefore, we conclude:\n\u2022 The inequality $3(n+1) \\leq 2(2n+1)$ is equivalent to $1 \\leq n$ [l6].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (n : \u2124)\n  (tc_2 : n \u2265 1) :\n  3 * (n + 1) \u2264 2 * (2 * n + 1) \u2194 1 \u2264 n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (n : \u2124)\n  (tc_2 : n \u2265 1) :\n  3 * (n + 1) \u2264 2 * (2 * n + 1) \u2194 1 \u2264 n := by\n  constructor\n  \u00b7 intro h\n    rw [mul_add, mul_add] at h\n    simp at h\n    linarith\n  \u00b7 intro h\n    rw [mul_add, mul_add]\n    simp\n    linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization introduces an additional assumption 'tc_2 : n \u2265 1' that fundamentally changes the logical structure. The natural language presents a general equivalence for any integer n, while the Lean version assumes the right-hand side of the equivalence (1 \u2264 n) as a premise, making it a different and much weaker statement. This transforms what should be a general theorem into a conditional statement with a trivial conclusion."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization introduces an additional assumption 'tc_2 : n \u2265 1' that fundamentally changes the logical structure. The natural language presents a general equivalence for any integer n, while the Lean version assumes the right-hand side of the equivalence (1 \u2264 n) as a premise, making it a different and much weaker statement. This transforms what should be a general theorem into a conditional statement with a trivial conclusion.\"]"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "This is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer n, $a_n = \\frac{n+1}{2n+1}$ [tc_1].\n\u2022 $n$ is an integer such that $n \\geq 1$ [tc_2].\n\u2022 The inequality $\\frac{n+1}{2n+1} \\leq \\frac{2}{3}$ holds if and only if $3(n+1) \\leq 2(2n+1)$ [l5].\n\u2022 The inequality $3(n+1) \\leq 2(2n+1)$ is equivalent to $1 \\leq n$ [l6].\nTherefore, we conclude:\n\u2022 $a_n \\leq \\frac{2}{3}$ [l7].", "dependencies": ["tc_1", "tc_2", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u211d)\n  (n : \u2124)\n  (tc_1 : \u2200 n_ : \u2115, a n_ = (n_ + 1) / (2 * n_ + 1))\n  (tc_2 : n \u2265 1)\n  (l5 : (n + 1 : \u211d) / (2 * n + 1) \u2264 (2 : \u211d) / 3 \u2194 (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1))\n  (l6 : (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1) \u2194 (1 : \u211d) \u2264 (n : \u211d)) :\n  a (n.toNat) \u2264 (2 : \u211d) / 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u211d)\n  (n : \u2124)\n  (tc_1 : \u2200 n_ : \u2115, a n_ = (n_ + 1) / (2 * n_ + 1))\n  (tc_2 : n \u2265 1)\n  (l5 : (n + 1 : \u211d) / (2 * n + 1) \u2264 (2 : \u211d) / 3 \u2194 (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1))\n  (l6 : (3 : \u211d) * (n + 1) \u2264 (2 : \u211d) * (2 * n + 1) \u2194 (1 : \u211d) \u2264 (n : \u211d)) :\n  a (n.toNat) \u2264 (2 : \u211d) / 3 := by\n  rw [tc_1]\n  simp only [Int.toNat_of_nonneg (Int.le_of_lt (by linarith))]\n  rw [l5]\n  rw [l6]\n  exact_mod_cast tc_2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 2, "endLine": 14, "endColumn": 62, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition has a type mismatch - natural language defines it for integers while Lean defines it for natural numbers only. This creates a structural difference in how the sequence domain is represented.", "The constraint n \u2265 1 is correctly captured in both natural language and Lean formalization.", "The first equivalence statement is perfectly translated, with proper type annotations in Lean.", "The second equivalence statement is accurately formalized with appropriate type coercions.", "The conclusion has a minor inconsistency due to the use of n.toNat, which is necessitated by the type mismatch in the sequence definition. The logical meaning is preserved but the structural representation differs from the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['The sequence definition has a type mismatch - natural language defines it for integers while Lean defines it for natural numbers only. This creates a structural difference in how the sequence domain is represented.', 'The constraint n \u2265 1 is correctly captured in both natural language and Lean formalization.', 'The first equivalence statement is perfectly translated, with proper type annotations in Lean.', 'The second equivalence statement is accurately formalized with appropriate type coercions.', 'The conclusion has a minor inconsistency due to the use of n.toNat, which is necessitated by the type mismatch in the sequence definition. The logical meaning is preserved but the structural representation differs from the natural language.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since both parts of the inequality hold, the full inequality $\\frac{1}{2} < a_n \\leq \\frac{2}{3}$ is proven.", "statement": "We assume:\n\u2022 For the sequence $a_n$ and for $n \\geq 1$, we have $\\frac{1}{2} < a_n$ [l4].\n\u2022 For the sequence $a_n$ and for $n \\geq 1$, we have $a_n \\leq \\frac{2}{3}$ [l7].\nTherefore, we conclude:\n\u2022 $\\frac{1}{2} < a_n \\leq \\frac{2}{3}$ [ts_1].", "dependencies": ["l4", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d) (n : \u2115)\n  (l4 : (1 / 2 : \u211d) < a n)\n  (l7 : a n \u2264 (2 : \u211d) / 3) :\n  (1 / 2 : \u211d) < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d) (n : \u2115)\n  (l4 : (1 / 2 : \u211d) < a n)\n  (l7 : a n \u2264 (2 : \u211d) / 3) :\n  (1 / 2 : \u211d) < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\n  exact \u27e8l4, l7\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence declaration and domain specification are correctly formalized, with the sequence typed as \u2115 \u2192 \u211d", "The first inequality assumption l4 is perfectly captured with correct mathematical notation", "The second inequality assumption l7 is accurately represented", "The conclusion correctly combines both inequalities using logical conjunction, preserving the exact mathematical meaning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    