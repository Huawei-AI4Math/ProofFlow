
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = \frac{1}{n(n+1)}$ for all $n \in \mathbb{N}$. Let the series be $\sum_{n=1}^{\infty} a_n$. The sum of this series is $1$.

Proof: The term $a_n$ can be expressed using partial fraction decomposition. We can write $\frac{1}{n(n+1)} = \frac{A}{n} + \frac{B}{n+1}$. To find $A$ and $B$, we set $1 = A(n+1) + B(n)$. By setting $n=0$, we find $1 = A(1) + B(0)$, so $A=1$. By setting $n=-1$, we find $1 = A(0) + B(-1)$, so $1 = -B$, which means $B=-1$. Therefore, $a_n = \frac{1}{n} - \frac{1}{n+1}$. The partial sum of the series is $S_N = \sum_{n=1}^N a_n = \sum_{n=1}^N (\frac{1}{n} - \frac{1}{n+1})$. This is a telescoping sum. Expanding the sum, we get $S_N = (\frac{1}{1} - \frac{1}{2}) + (\frac{1}{2} - \frac{1}{3}) + (\frac{1}{3} - \frac{1}{4}) + \dots + (\frac{1}{N} - \frac{1}{N+1})$. The intermediate terms cancel out, leaving $S_N = 1 - \frac{1}{N+1}$. The sum of the series is the limit of the partial sums as $N$ approaches infinity. Thus, $\sum_{n=1}^{\infty} a_n = \lim_{N 	o \infty} S_N = \lim_{N 	o \infty} (1 - \frac{1}{N+1})$. Since $\lim_{N 	o \infty} \frac{1}{N+1} = 0$, the sum of the series is $1 - 0 = 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = \\frac{1}{n(n+1)}$ for all $n \\in \\mathbb{N}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers such that $a_n = \\frac{1}{n(n+1)}$ for all $n \\in \\mathbb{N}$ (natural numbers starting from 1) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization `variable (a : \u2115 \u2192 \u211d)` perfectly captures the natural language statement that $(a_n)$ is a sequence of real numbers.", "The mathematical content is identical, but there's a structural difference in how the domain is specified. The natural language clarifies 'natural numbers starting from 1' while Lean explicitly adds the condition `n \u2265 1` to account for Lean's natural numbers starting from 0. Both capture the same mathematical meaning but with slightly different approaches."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization `variable (a : \u2115 \u2192 \u211d)` perfectly captures the natural language statement that $(a_n)$ is a sequence of real numbers.', \"The mathematical content is identical, but there's a structural difference in how the domain is specified. The natural language clarifies 'natural numbers starting from 1' while Lean explicitly adds the condition `n \u2265 1` to account for Lean's natural numbers starting from 0. Both capture the same mathematical meaning but with slightly different approaches.\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "We can write $\\frac{1}{n(n+1)} = \\frac{A}{n} + \\frac{B}{n+1}$. To find $A$ and $B$, we set $1 = A(n+1) + B(n)$", "statement": "We assume:\n\u2022 The expression for the sequence term is $a_n = \\frac{1}{n(n+1)}$ [tc_1].\nTherefore, we conclude:\n\u2022 There exist constants A and B such that $\\frac{1}{n(n+1)} = \\frac{A}{n} + \\frac{B}{n+1}$, which by clearing denominators implies the polynomial identity $1 = A(n+1) + B(n)$ holds for all $n$ where the expression is defined [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1))) :\n  \u2203 A B : \u211d, (\u2200 n : \u2115, n \u2265 1 \u2192 1 / (n * (n + 1)) = A / n + B / (n + 1)) \u2227 (\u2200 n : \u211d, 1 = A * (n + 1) + B * n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1))) :\n  \u2203 A B : \u211d, (\u2200 n : \u2115, n \u2265 1 \u2192 1 / (n * (n + 1)) = A / n + B / (n + 1)) \u2227 (\u2200 n : \u211d, 1 = A * (n + 1) + B * n) := by\n  use 1, -1\n  constructor\n  \u00b7 intro n hn\n    rw [div_add_div]\n    \u00b7 field_simp [hn.ne', (Nat.succ_pos n).ne']\n      ring\n    \u00b7 exact hn.ne'\n    \u00b7 exact Nat.succ_ne_zero n\n  \u00b7 intro n\n    ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 18, "endLine": 13, "endColumn": 24, "data": "invalid field 'ne'', the environment does not contain 'GE.ge.ne''\n  hn\nhas type\n  n \u2265 1"}, {"line": 13, "column": 18, "endLine": 13, "endColumn": 24, "data": "invalid field 'ne'', the environment does not contain 'LE.le.ne''\n  hn\nhas type\n  1 \u2264 n"}, {"line": 13, "column": 18, "endLine": 13, "endColumn": 24, "data": "invalid field 'ne'', the environment does not contain 'Nat.le.ne''\n  hn\nhas type\n  Nat.le 1 n"}, {"line": 14, "column": 6, "endLine": 14, "endColumn": 10, "data": "no goals to be solved"}, {"line": 15, "column": 12, "endLine": 15, "endColumn": 18, "data": "invalid field 'ne'', the environment does not contain 'GE.ge.ne''\n  hn\nhas type\n  n \u2265 1"}, {"line": 15, "column": 12, "endLine": 15, "endColumn": 18, "data": "invalid field 'ne'', the environment does not contain 'LE.le.ne''\n  hn\nhas type\n  1 \u2264 n"}, {"line": 15, "column": 12, "endLine": 15, "endColumn": 18, "data": "invalid field 'ne'', the environment does not contain 'Nat.le.ne''\n  hn\nhas type\n  Nat.le 1 n"}, {"line": 16, "column": 6, "endLine": 16, "endColumn": 30, "data": "type mismatch\n  succ_ne_zero n\nhas type\n  n.succ \u2260 0 : Prop\nbut is expected to have type\n  \u2191n + 1 \u2260 0 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition is correctly formalized with appropriate domain restriction n \u2265 1.", "The existence of constants A and B with the partial fraction decomposition is accurately captured.", "The polynomial identity has a major inconsistency: the natural language suggests it holds 'for all n where the expression is defined' (implying n \u2265 1 natural numbers), but the Lean formalization extends this to all real numbers (\u2200 n : \u211d), which is mathematically much stronger and changes the logical meaning significantly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition is correctly formalized with appropriate domain restriction n \u2265 1.', 'The existence of constants A and B with the partial fraction decomposition is accurately captured.', \"The polynomial identity has a major inconsistency: the natural language suggests it holds 'for all n where the expression is defined' (implying n \u2265 1 natural numbers), but the Lean formalization extends this to all real numbers (\u2200 n : \u211d), which is mathematically much stronger and changes the logical meaning significantly.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By setting $n=0$, we find $1 = A(1) + B(0)$, so $A=1$.", "statement": "We assume:\n\u2022 The polynomial identity $1 = A(n+1) + B(n)$ holds [l1].\nTherefore, we conclude:\n\u2022 $A=1$ [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (A B : \u211d)\n  (l1 : \u2200 n : \u211d, 1 = A * (n + 1) + B * n) :\n  A = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (A B : \u211d)\n  (l1 : \u2200 n : \u211d, 1 = A * (n + 1) + B * n) :\n  A = 1 := by\n  have h0 := l1 (-1)\n  simp at h0\n  have h1 := l1 0\n  simp at h1\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premise is correctly formalized. The natural language states a polynomial identity that holds for all n, and the Lean formalization captures this with the universal quantifier \u2200 n : \u211d. The mathematical expression 1 = A(n+1) + B(n) is accurately translated to 1 = A * (n + 1) + B * n with explicit multiplication operators.", "The conclusion is correctly formalized. Both the natural language and Lean formalization state that A = 1 follows from the premise. The 'sorry' is just a placeholder for the proof and doesn't affect the logical structure of the statement.", "The type specifications are appropriate additions. While the natural language doesn't explicitly specify types, declaring A, B, and n as real numbers (\u211d) is mathematically sound and necessary for the Lean formalization. This is consistent with treating the identity as a polynomial equation over reals."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "By setting $n=-1$, we find $1 = A(0) + B(-1)$, so $1 = -B$, which means $B=-1$.", "statement": "We assume:\n\u2022 The polynomial identity $1 = A(n+1) + B(n)$ holds [l1].\nTherefore, we conclude:\n\u2022 $B=-1$ [l3].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (A B : \u211d)\n  (l1 : \u2200 n : \u211d, 1 = A * (n + 1) + B * n) :\n  B = -1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (A B : \u211d)\n  (l1 : \u2200 n : \u211d, 1 = A * (n + 1) + B * n) :\n  B = -1 := by\n  have h1 := l1 0\n  simp at h1\n  have h2 := l1 (-1)\n  simp at h2\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all aspects of the natural language statement. The polynomial identity is properly formalized with a universal quantifier over real numbers, which correctly interprets the mathematical meaning of 'polynomial identity'. The conclusion B = -1 is identical in both versions. The explicit type declarations for A and B as real numbers in Lean are consistent with standard mathematical interpretation and represent acceptable additional detail that doesn't contradict the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Therefore, $a_n = \\frac{1}{n} - \\frac{1}{n+1}$.", "statement": "We assume:\n\u2022 $a_n = \\frac{1}{n(n+1)}$ [tc_1]\n\u2022 This can be written as $\\frac{1}{n(n+1)} = \\frac{A}{n} + \\frac{B}{n+1}$ [l1]\n\u2022 $A=1$ [l2]\n\u2022 $B=-1$ [l3]\nTherefore, we conclude:\n\u2022 $a_n = \\frac{1}{n} - \\frac{1}{n+1}$ [l4].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1)))\n  (l1 : \u2203 A B : \u211d, (\u2200 n : \u2115, n \u2265 1 \u2192 1 / (n * (n + 1)) = A / n + B / (n + 1)) \u2227 (\u2200 n : \u211d, 1 = A * (n + 1) + B * n))\n  (l2 : (Classical.choose l1).fst = 1)\n  (l3 : (Classical.choose (Classical.choose_spec l1).snd).snd = -1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / n - 1 / (n + 1) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 8, "endLine": 9, "endColumn": 33, "data": "invalid field 'fst', the environment does not contain 'Real.fst'\n  Classical.choose l1\nhas type\n  \u211d"}, {"line": 10, "column": 8, "endLine": 10, "endColumn": 61, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Classical.choose ?m.3634\nhas type\n  ?m.3596"}, {"line": 10, "column": 26, "endLine": 10, "endColumn": 56, "data": "application type mismatch\n  Classical.choose \u22ef\nargument\n  Exists.snd ?m.3619\nhas type\n  ?m.3610 \u22ef : Prop\nbut is expected to have type\n  \u2203 x, ?m.3597 x : Prop"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1)))\n  (l1 : \u2203 A B : \u211d, (\u2200 n : \u2115, n \u2265 1 \u2192 1 / (n * (n + 1)) = A / n + B / (n + 1)) \u2227 (\u2200 n : \u211d, 1 = A * (n + 1) + B * n))\n  (l2 : (Classical.choose l1) = 1)\n  (l3 : Classical.choose (Classical.choose_spec l1).2 = -1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / n - 1 / (n + 1) := by\n  intro n hn\n  rw [tc_1 n hn]\n  have \u27e8A, B, h\u27e9 := l1\n  have h1 := h.1 n hn\n  have h2 := h.2 n\n  rw [l2] at h1 h2\n  rw [l3] at h1 h2\n  simp at h1\n  rw [sub_eq_add_neg, \u2190 neg_div] at h1\n  exact h1", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 25, "endLine": 10, "endColumn": 53, "data": "application type mismatch\n  Classical.choose \u22ef\nargument\n  (Classical.choose_spec l1).2\nhas type\n  (\u2200 n \u2265 1, 1 / (\u2191n * (\u2191n + 1)) = Classical.choose l1 / \u2191n + \u22ef.1 / (\u2191n + 1)) \u2227\n    \u2200 (n : \u211d), 1 = Classical.choose l1 * (n + 1) + \u22ef.1 * n : Prop\nbut is expected to have type\n  \u2203 x, ?m.1651 x : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "The partial sum of the series is $S_N = \\sum_{n=1}^N a_n$", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence [tc_1].\nDefinition:\n\u2022 The N-th partial sum of the series is defined as $S_N = \\sum_{n=1}^N a_n$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1)))\n\ndef def_1 (N : \u2115) : \u211d :=\n  \u2211 n in Finset.range (N + 1) \\ {0}, a n", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language only states that (a_n) is a sequence, but the Lean formalization adds a specific constraint that a_n = 1/(n*(n+1)) for n \u2265 1. This introduces a major logical component not present in the natural language statement.", "The Lean definition correctly captures the N-th partial sum as the sum from n=1 to N. The expression 'Finset.range (N + 1) \\ {0}' gives exactly the set {1, 2, ..., N}, which matches the mathematical definition."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language only states that (a_n) is a sequence, but the Lean formalization adds a specific constraint that a_n = 1/(n*(n+1)) for n \u2265 1. This introduces a major logical component not present in the natural language statement.', \"The Lean definition correctly captures the N-th partial sum as the sum from n=1 to N. The expression 'Finset.range (N + 1) \\\\ {0}' gives exactly the set {1, 2, ..., N}, which matches the mathematical definition.\"]"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "This is a telescoping sum. Expanding the sum, we get $S_N = (\\frac{1}{1} - \\frac{1}{2}) + (\\frac{1}{2} - \\frac{1}{3}) + (\\frac{1}{3} - \\frac{1}{4}) + \\dots + (\\frac{1}{N} - \\frac{1}{N+1})$. The intermediate terms cancel out, leaving $S_N = 1 - \\frac{1}{N+1}$.", "statement": "We assume:\n\u2022 The N-th partial sum is $S_N = \\sum_{n=1}^N a_n$ [def_1]\n\u2022 $a_n = \\frac{1}{n} - \\frac{1}{n+1}$ [l4]\nTherefore, we conclude:\n\u2022 The partial sum simplifies to $S_N = 1 - \\frac{1}{N+1}$ [l5].", "dependencies": ["def_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d) (N : \u2115)\n  (def_1 : \u2200 N_val : \u2115, (\u2211 n in Finset.range (N_val + 1) \\ {0}, a n) = (\u2211 n in Finset.range (N_val + 1) \\ {0}, a n))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / n - 1 / (n + 1)) :\n  (\u2211 n in Finset.range (N + 1) \\ {0}, a n) = 1 - 1 / (N + 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d) (N : \u2115)\n  (def_1 : \u2200 N_val : \u2115, (\u2211 n in Finset.range (N_val + 1) \\ {0}, a n) = (\u2211 n in Finset.range (N_val + 1) \\ {0}, a n))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / n - 1 / (n + 1)) :\n  (\u2211 n in Finset.range (N + 1) \\ {0}, a n) = 1 - 1 / (N + 1) := by\n  induction N with\n  | zero =>\n      simp [Finset.range_succ, Finset.range_zero, Finset.sdiff_singleton_eq_self]\n      rw [l4 1 (by simp)]\n      field_simp\n  | succ N ih =>\n      rw [Finset.range_succ, Finset.sum_sdiff (Finset.range_subset.2 (le_succ _))]\n      simp only [Finset.sdiff_singleton_eq_self (Finset.not_mem_range_self.2 (lt_succ_self _))]\n      rw [ih, l4 (N + 1) (Nat.succ_pos N), add_sub]\n      field_simp\n      ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 10, "endLine": 13, "endColumn": 24, "data": "no goals to be solved"}, {"line": 16, "column": 29, "endLine": 16, "endColumn": 81, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2211 x \u2208 Finset.range (succ ?m.2633) \\ Finset.range ?m.2633, ?m.2616 x + \u2211 x \u2208 Finset.range ?m.2633, ?m.2616 x\ncase succ\na : \u2115 \u2192 \u211d\ndef_1 : \u2200 (N_val : \u2115), \u2211 n \u2208 Finset.range (N_val + 1) \\ {0}, a n = \u2211 n \u2208 Finset.range (N_val + 1) \\ {0}, a n\nl4 : \u2200 n \u2265 1, a n = 1 / \u2191n - 1 / (\u2191n + 1)\nN : \u2115\nih : \u2211 n \u2208 Finset.range (N + 1) \\ {0}, a n = 1 - 1 / (\u2191N + 1)\n\u22a2 \u2211 n \u2208 insert (N + 1) (Finset.range (N + 1)) \\ {0}, a n = 1 - 1 / (\u2191(N + 1) + 1)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The definition def_1 is a meaningless tautology (X = X) that fails to capture the natural language definition of S_N as a specific sum. The natural language establishes S_N as notation for the partial sum, but the Lean formalization provides no such definition.", "The sequence definition l4 correctly captures the mathematical formula with an appropriate additional constraint n \u2265 1 to ensure the formula is well-defined.", "The conclusion correctly represents the telescoping sum result, with the explicit sum notation being mathematically equivalent to the S_N notation used in natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The definition def_1 is a meaningless tautology (X = X) that fails to capture the natural language definition of S_N as a specific sum. The natural language establishes S_N as notation for the partial sum, but the Lean formalization provides no such definition.', 'The sequence definition l4 correctly captures the mathematical formula with an appropriate additional constraint n \u2265 1 to ensure the formula is well-defined.', 'The conclusion correctly represents the telescoping sum result, with the explicit sum notation being mathematically equivalent to the S_N notation used in natural language.']"}, "solved_negation": null, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "The sum of the series is the limit of the partial sums as $N$ approaches infinity.", "statement": "We assume:\n\u2022 The sequence is $(a_n)$ [tc_1]\n\u2022 The partial sums are $(S_N)$ [def_1]\nDefinition:\n\u2022 The sum of the series is defined as the limit of its partial sums: $\\sum_{n=1}^{\\infty} a_n = \\lim_{N \\to \\infty} S_N$ [def_2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n * (n + 1)))\n(def_1 : \u2115 \u2192 \u211d)\n(h_def_1 : \u2200 N : \u2115, def_1 N = \u2211 n in Finset.range (N + 1) \\ {0}, a n)\n(def_2 : Tendsto def_1 atTop (nhds (\u2211' (n : \u2115), a n)))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes a general sequence (a_n), but the Lean formalization constrains tc_1 to be a specific formula: a n = 1 / (n * (n + 1)) for n \u2265 1. This introduces a contradicting logical component by making the sequence specific rather than general.", "The Lean formalization correctly captures the concept of partial sums. The definition def_1 N = \u2211 n in Finset.range (N + 1) \\ {0}, a n properly represents partial sums from n=1 to N, which matches the mathematical meaning of (S_N).", "The Lean formalization correctly captures the definition of an infinite series. The statement 'Tendsto def_1 atTop (nhds (\u2211' (n : \u2115), a n))' properly expresses that the partial sums def_1 tend to the infinite sum, which is equivalent to the mathematical statement \u2211_{n=1}^\u221e a_n = lim_{N\u2192\u221e} S_N."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language describes a general sequence (a_n), but the Lean formalization constrains tc_1 to be a specific formula: a n = 1 / (n * (n + 1)) for n \u2265 1. This introduces a contradicting logical component by making the sequence specific rather than general.', 'The Lean formalization correctly captures the concept of partial sums. The definition def_1 N = \u2211 n in Finset.range (N + 1) \\\\ {0}, a n properly represents partial sums from n=1 to N, which matches the mathematical meaning of (S_N).', \"The Lean formalization correctly captures the definition of an infinite series. The statement 'Tendsto def_1 atTop (nhds (\u2211' (n : \u2115), a n))' properly expresses that the partial sums def_1 tend to the infinite sum, which is equivalent to the mathematical statement \u2211_{n=1}^\u221e a_n = lim_{N\u2192\u221e} S_N.\"]"}, "type": "definition"}, "l6": {"id": "l6", "natural_language": "Since $\\lim_{N \\to \\infty} \\frac{1}{N+1} = 0$", "statement": "We assume:\n\u2022 (Standard calculus knowledge about limits)\nTherefore, we conclude:\n\u2022 $\\lim_{N \\to \\infty} \\frac{1}{N+1} = 0$ [l6].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6 :\n  Filter.Tendsto (fun N : \u2115 \u21a6 1 / (N + 1)) Filter.atTop (nhds 0) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6 :\n  Filter.Tendsto (fun N : \u2115 \u21a6 1 / (N + 1)) Filter.atTop (nhds 0) := by\n  simp only [one_div]\n  apply tendsto_inv_atTop_zero.comp\n  rw [\u2190Filter.comap_coe_nat_atTop]\n  exact tendsto_atTop_add_const_right _ _ tendsto_id", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 2, "endLine": 7, "endColumn": 21, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the limit statement using Filter.Tendsto, which is the standard way to express limits in Lean. The function (1 / (N + 1)), the behavior at infinity (Filter.atTop), and convergence to 0 (nhds 0) all accurately represent the mathematical content. The lemma name l6 also matches the natural language label.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l6 :\n  \u00acFilter.Tendsto (fun N : \u2115 \u21a6 1 / (N + 1)) Filter.atTop (nhds 0) := by\n  rw [Metric.tendsto_atTop]\n  push_neg\n  use 1\n  constructor\n  \u00b7 norm_num\n  \u00b7 intro N\n    use N\n    constructor\n    \u00b7 simp\n    \u00b7 simp [dist_eq, abs_div, abs_one, abs_of_pos (Nat.cast_pos.mpr (Nat.succ_pos N))]\n      apply div_lt_one\n      \u00b7 exact Nat.cast_pos.mpr (Nat.succ_pos N)\n      \u00b7 exact Nat.cast_lt.mpr (Nat.lt_succ_self N)"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "the sum of the series is $1 - 0 = 1$.", "statement": "We assume:\n\u2022 The sum of the series is $\\sum_{n=1}^{\\infty} a_n = \\lim_{N \\to \\infty} S_N$ [def_2]\n\u2022 The partial sum is $S_N = 1 - \\frac{1}{N+1}$ [l5]\n\u2022 $\\lim_{N \\to \\infty} \\frac{1}{N+1} = 0$ [l6]\nTherefore, we conclude:\n\u2022 $\\sum_{n=1}^{\\infty} a_n = 1$ [ts_1].", "dependencies": ["def_2", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d) (def_1 : \u2115 \u2192 \u211d)\n  (def_2 : Tendsto def_1 atTop (nhds (\u2211' (n : \u2115), a n)))\n  (l5 : \u2200 N : \u2115, (\u2211 n in Finset.range (N + 1) \\ {0}, a n) = 1 - 1 / (N + 1))\n  (l6 : Tendsto (fun N : \u2115 \u21a6 1 / (N + 1)) atTop (nhds 0)) :\n  (\u2211' (n : \u2115), a n) = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d) (def_1 : \u2115 \u2192 \u211d)\n  (def_2 : Tendsto def_1 atTop (nhds (\u2211' (n : \u2115), a n)))\n  (l5 : \u2200 N : \u2115, def_1 N = 1 - 1 / (N + 1))\n  (l6 : Tendsto (fun N : \u2115 \u21a6 1 / (N + 1)) atTop (nhds 0)) :\n  (\u2211' (n : \u2115), a n) = 1 := by\n  have h : Tendsto (fun N => 1 - 1 / (N + 1)) atTop (\ud835\udcdd (1 - 0)) := by\n    apply Tendsto.sub_const\n    exact l6\n  rw [sub_zero] at h\n  exact tendsto_nhds_unique def_2 h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 4, "endLine": 12, "endColumn": 27, "data": "failed to synthesize\n  ContinuousSub \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 14, "column": 6, "endLine": 14, "endColumn": 14, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a - 0\na def_1 : \u2115 \u2192 \u211d\ndef_2 : Tendsto def_1 atTop (\ud835\udcdd (\u2211' (n : \u2115), a n))\nl5 : \u2200 (N : \u2115), def_1 N = 1 - 1 / (\u2191N + 1)\nl6 : Tendsto (fun N => 1 / (N + 1)) atTop (\ud835\udcdd 0)\nh : Tendsto (fun N => 1 - 1 / (N + 1)) atTop (\ud835\udcdd (1 - 0))\n\u22a2 \u2211' (n : \u2115), a n = 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language defines the series sum as the limit of S_N, but the Lean formalization uses 'def_1' which is not connected to the partial sum S_N. This breaks the logical connection between the series definition and partial sums.", "The partial sum definition is semantically equivalent but uses different structural representation. Natural language uses S_N notation while Lean uses explicit finite sum with range exclusion, though both represent the same mathematical concept.", "The limit statement is correctly formalized using Lean's Tendsto notation, perfectly capturing the mathematical meaning.", "The conclusion correctly states that the infinite series equals 1, matching the natural language exactly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language defines the series sum as the limit of S_N, but the Lean formalization uses 'def_1' which is not connected to the partial sum S_N. This breaks the logical connection between the series definition and partial sums.\", 'The partial sum definition is semantically equivalent but uses different structural representation. Natural language uses S_N notation while Lean uses explicit finite sum with range exclusion, though both represent the same mathematical concept.', \"The limit statement is correctly formalized using Lean's Tendsto notation, perfectly capturing the mathematical meaning.\", 'The conclusion correctly states that the infinite series equals 1, matching the natural language exactly.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    