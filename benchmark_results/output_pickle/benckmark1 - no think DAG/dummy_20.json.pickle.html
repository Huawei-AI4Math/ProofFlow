
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: (a) Union of open sets is open. (b) Intersection of closed sets is closed.

Proof: (a) Let G be a collection of open sets, S = ∪G. If x₀ ∈ S, then x₀ ∈ some open G₀, so ∃ ε-nbhd in G₀ ⊆ S ⇒ S open. (b) If F is a collection of closed sets, T = ∩F ⇒ Tᶜ = ∪Fᶜ. Each Fᶜ open ⇒ Tᶜ open ⇒ T closed.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let G be a collection of open sets", "statement": "Premise:\n\u2022 Let G be a collection of open sets in a metric space (X, d) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {\u03b1 : Type*} [MetricSpace \u03b1]\n  (G : Set (Set \u03b1))\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language uses (X, d) notation for the metric space while Lean uses \u03b1 with MetricSpace typeclass. This is a notational difference but semantically equivalent - both establish a metric space structure.", "G being a collection of sets is correctly captured by 'Set (Set \u03b1)' in Lean, representing a collection of subsets of the metric space.", "The condition that all sets in G are open is perfectly captured by '\u2200 s \u2208 G, IsOpen s' which states that for every set s in collection G, s is open."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "S = \u222aG", "statement": "We assume:\n\u2022 Let G be a collection of open sets in a metric space (X, d) [tc_1].\nDefinition:\n\u2022 Let S be the union of the sets in G, i.e., S = \u222a_{g \u2208 G} g [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {\u03b1 : Type*} [MetricSpace \u03b1]\n  (G : Set (Set \u03b1))\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (S : Set \u03b1)\n  (def_1 : S = \u22c3 s \u2208 G, s)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that G is a collection of open sets in a metric space. The metric space is established with `{\u03b1 : Type*} [MetricSpace \u03b1]`, G is defined as `(G : Set (Set \u03b1))` (a collection of sets), and the condition that all sets in G are open is captured by `(tc_1 : \u2200 s \u2208 G, IsOpen s)`. The variable names differ (\u03b1 instead of X, d), but this is semantically equivalent.", "The Lean formalization `(def_1 : S = \u22c3 s \u2208 G, s)` perfectly matches the mathematical definition S = \u222a_{g \u2208 G} g. The notation `\u22c3 s \u2208 G, s` is Lean's way of expressing the union over all sets s in the collection G, which is exactly what the mathematical notation represents."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If x\u2080 \u2208 S, then x\u2080 \u2208 some open G\u2080, so \u2203 \u03b5-nbhd in G\u2080 \u2286 S", "statement": "We assume:\n\u2022 Let G be a collection of open sets in a metric space (X, d) [tc_1].\n\u2022 Let S be the union of the sets in G, i.e., S = \u222a_{g \u2208 G} g [def_1].\n\u2022 Let x\u2080 be an arbitrary point in S.\nTherefore, we conclude:\n\u2022 There exists an \u03b5 > 0 such that the open ball B(x\u2080, \u03b5) is a subset of S [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 : Type*} [MetricSpace \u03b1]\n  (G : Set (Set \u03b1))\n  (x\u2080 : \u03b1)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (S : Set \u03b1)\n  (def_1 : S = \u22c3 s \u2208 G, s)\n  (hx\u2080S : x\u2080 \u2208 S) :\n  \u2203 \u03b5 > 0, Metric.ball x\u2080 \u03b5 \u2286 S := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 : Type*} [MetricSpace \u03b1]\n  (G : Set (Set \u03b1))\n  (x\u2080 : \u03b1)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (S : Set \u03b1)\n  (def_1 : S = \u22c3 s \u2208 G, s)\n  (hx\u2080S : x\u2080 \u2208 S) :\n  \u2203 \u03b5 > 0, Metric.ball x\u2080 \u03b5 \u2286 S := by\n  rw [def_1] at hx\u2080S\n  simp only [Set.mem_iUnion] at hx\u2080S\n  obtain \u27e8s, hs\u2081, hs\u2082\u27e9 := hx\u2080S\n  specialize tc_1 s hs\u2081\n  rw [Metric.isOpen_iff] at tc_1\n  specialize tc_1 x\u2080 hs\u2082\n  obtain \u27e8\u03b5, h\u03b5\u2081, h\u03b5\u2082\u27e9 := tc_1\n  use \u03b5, h\u03b5\u2081\n  rw [def_1]\n  exact Set.subset_iUnion\u2082_of_subset s hs\u2081 h\u03b5\u2082", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The metric space setup is correctly formalized with \u03b1 as the type and MetricSpace \u03b1 as the instance. G is properly declared as a collection (Set) of sets (Set \u03b1).", "The condition that all sets in G are open is correctly captured by the universal quantification \u2200 s \u2208 G, IsOpen s.", "The union definition is accurately formalized using Lean's indexed union notation \u22c3 s \u2208 G, s, which precisely matches the mathematical notation \u222a_{g \u2208 G} g.", "The point x\u2080 is properly declared as an element of type \u03b1, and the condition that it belongs to S is correctly expressed as hx\u2080S : x\u2080 \u2208 S.", "The conclusion is perfectly formalized with the existential quantification \u2203 \u03b5 > 0 capturing both the existence and positivity of \u03b5, and Metric.ball x\u2080 \u03b5 \u2286 S correctly expressing the subset relationship."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "\u21d2 S open.", "statement": "We assume:\n\u2022 Let S be the union of a collection of open sets G [def_1, tc_1].\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5 > 0 such that the open ball B(x\u2080, \u03b5) is a subset of S [l1].\nTherefore, we conclude:\n\u2022 S is an open set [ts_1].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} [MetricSpace \u03b1]\n  (G : Set (Set \u03b1))\n  (S : Set \u03b1)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3 s \u2208 G, s)\n  (l1 : \u2200 (x\u2080 : \u03b1), x\u2080 \u2208 S \u2192 (\u2203 \u03b5 > 0, Metric.ball x\u2080 \u03b5 \u2286 S)) :\n  IsOpen S := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} [MetricSpace \u03b1]\n  (G : Set (Set \u03b1))\n  (S : Set \u03b1)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3 s \u2208 G, s)\n  (l1 : \u2200 (x\u2080 : \u03b1), x\u2080 \u2208 S \u2192 (\u2203 \u03b5 > 0, Metric.ball x\u2080 \u03b5 \u2286 S)) :\n  IsOpen S := by\n  rw [isOpen_iff_mem_nhds]\n  intro x\u2080 hx\u2080\n  rcases l1 x\u2080 hx\u2080 with \u27e8\u03b5, h\u03b5, h\u27e9\n  exact mem_nhds_iff.2 \u27e8Metric.ball x\u2080 \u03b5, h, Metric.isOpen_ball, Metric.mem_ball_self h\u03b5\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The collection G of open sets and the union definition S = \u22c3 s \u2208 G, s are correctly formalized. The type declarations and openness conditions properly capture the natural language description.", "The open ball condition is accurately translated using existential quantification over \u03b5 > 0 and subset relation. The metric ball notation correctly represents the open ball B(x\u2080, \u03b5).", "The conclusion that S is an open set is properly represented as IsOpen S, which is the standard way to express openness in Lean's topology library."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "tc_2": {"id": "tc_2", "natural_language": "If F is a collection of closed sets", "statement": "Premise:\n\u2022 Let F be a collection of closed sets in a topological space X [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (tc_2 : \u2200 S \u2208 F, IsClosed S)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures that F is a collection of closed sets through the combination of F being a Set (Set X) and the condition tc_2 ensuring all elements are closed", "The Lean formalization correctly establishes X as a topological space with the TopologicalSpace X typeclass instance", "In the natural language, tc_2 refers to the topology on X, but in Lean, tc_2 is the name of the condition stating that all sets in F are closed. The semantic meaning is preserved but the naming convention differs from the natural language description"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_2": {"id": "def_2", "natural_language": "T = \u2229F", "statement": "We assume:\n\u2022 Let F be a collection of closed sets in a topological space X [tc_2].\nDefinition:\n\u2022 Let T be the intersection of the sets in F, i.e., T = \u2229_{f \u2208 F} f [def_2].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (tc_2 : \u2200 S \u2208 F, IsClosed S)\n  (def_2 : \u22c2\u2080 F = \u22c2 f \u2208 F, f)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that F is a collection of closed sets in topological space X through the combination of `(F : Set (Set X))` and `(tc_2 : \u2200 S \u2208 F, IsClosed S)`", "The natural language defines T = \u2229_{f \u2208 F} f, but the Lean code uses `def_2 : \u22c2\u2080 F = \u22c2 f \u2208 F, f` which is a tautological statement about set intersection notation rather than defining a variable T. There is no variable T defined in the Lean code", "The conclusion states that T is the intersection of sets in F, but since T is not defined as a variable in the Lean formalization, this conclusion cannot be represented. The Lean code only contains a definitional equivalence between two intersection notations"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that F is a collection of closed sets in topological space X through the combination of `(F : Set (Set X))` and `(tc_2 : \u2200 S \u2208 F, IsClosed S)`', 'The natural language defines T = \u2229_{f \u2208 F} f, but the Lean code uses `def_2 : \u22c2\u2080 F = \u22c2 f \u2208 F, f` which is a tautological statement about set intersection notation rather than defining a variable T. There is no variable T defined in the Lean code', 'The conclusion states that T is the intersection of sets in F, but since T is not defined as a variable in the Lean formalization, this conclusion cannot be represented. The Lean code only contains a definitional equivalence between two intersection notations']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "T\u1d9c = \u222aF\u1d9c", "statement": "We assume:\n\u2022 Let T be the intersection of a collection of sets F, i.e., T = \u2229_{f \u2208 F} f [def_2].\nTherefore, we conclude:\n\u2022 The complement of T, T\u1d9c, is equal to the union of the complements of the sets in F: T\u1d9c = \u222a_{f \u2208 F} f\u1d9c [l2].", "dependencies": ["def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (def_2 : \u22c2\u2080 F = \u22c2 f \u2208 F, f) :\n  (\u22c2\u2080 F)\u1d9c = \u22c3 f \u2208 F, f\u1d9c := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (def_2 : \u22c2\u2080 F = \u22c2 f \u2208 F, f) :\n  (\u22c2\u2080 F)\u1d9c = \u22c3 f \u2208 F, f\u1d9c := by\n  ext x\n  simp only [mem_compl_iff, mem_sInter, mem_iInter, mem_iUnion]\n  constructor\n  \u00b7 intro h\n    push_neg at h\n    exact h\n  \u00b7 intro h\n    push_neg\n    exact h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 13, "endLine": 11, "endColumn": 26, "data": "unknown identifier 'mem_compl_iff'"}, {"line": 11, "column": 28, "endLine": 11, "endColumn": 38, "data": "unknown identifier 'mem_sInter'"}, {"line": 11, "column": 40, "endLine": 11, "endColumn": 50, "data": "unknown identifier 'mem_iInter'"}, {"line": 11, "column": 52, "endLine": 11, "endColumn": 62, "data": "unknown identifier 'mem_iUnion'"}, {"line": 11, "column": 2, "endLine": 11, "endColumn": 63, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise is correctly captured. The Lean formalization uses \u22c2\u2080 F (set intersection) and \u22c2 f \u2208 F, f (indexed intersection) which correctly represents the mathematical concept of intersection over a collection of sets F.", "The conclusion is perfectly captured. The Lean formalization (\u22c2\u2080 F)\u1d9c = \u22c3 f \u2208 F, f\u1d9c correctly represents the complement of the intersection equals the union of complements, which is exactly De Morgan's law as stated in natural language.", "There's a minor structural difference: the natural language introduces T as an explicit variable for the intersection, while Lean directly uses \u22c2\u2080 F throughout. This doesn't change the logical meaning but represents a slight notational difference in how the same mathematical concept is expressed.", "The mathematical relationship (De Morgan's law) is perfectly preserved. Both versions state that the complement of an intersection equals the union of the complements, maintaining complete logical equivalence.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.75 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2 :\n  \u00ac \u2200 {X : Type*} [TopologicalSpace X] (F : Set (Set X)),\n    (\u22c2\u2080 F = \u22c2 f \u2208 F, f) \u2192 (\u22c2\u2080 F)\u1d9c = \u22c3 f \u2208 F, f\u1d9c := by\n  intro h\n  let X := Unit\n  let F : Set (Set X) := {\u22a4}\n  have def_2 : \u22c2\u2080 F = \u22c2 f \u2208 F, f := rfl\n  have h' := h def_2\n  simp at h'\n  have : (\u22a4 : Set X)\u1d9c = \u2205 := by simp\n  rw [this] at h'\n  simp at h'\n  contradiction"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Each F\u1d9c open", "statement": "We assume:\n\u2022 Let F be a collection of closed sets in a topological space X [tc_2].\nTherefore, we conclude:\n\u2022 For each set f \u2208 F, its complement f\u1d9c is an open set [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (tc_2 : \u2200 S \u2208 F, IsClosed S) :\n  \u2200 f \u2208 F, IsOpen f\u1d9c := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (tc_2 : \u2200 S \u2208 F, IsClosed S) :\n  \u2200 f \u2208 F, IsOpen f\u1d9c := by\n  intro f hf\n  exact (tc_2 f hf).isOpen_compl", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the topological space X and collection F as a set of sets. The type declarations are appropriate mathematical formalizations of the natural language concepts.", "The assumption tc_2 perfectly translates the natural language statement that F is a collection of closed sets into the formal statement that every set S in F satisfies IsClosed S.", "The conclusion in Lean exactly matches the natural language: for every set f that belongs to F, the complement f\u1d9c is open (IsOpen f\u1d9c). This is a direct and complete formalization of the stated conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "T\u1d9c open", "statement": "We assume:\n\u2022 The set T\u1d9c is the union of the collection of sets {f\u1d9c | f \u2208 F} [l2].\n\u2022 Each set f\u1d9c in the collection {f\u1d9c | f \u2208 F} is open [l3].\n\u2022 The union of any collection of open sets is an open set [ts_1].\nTherefore, we conclude:\n\u2022 T\u1d9c is an open set [l4].", "dependencies": ["l2", "l3", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (T : Set X)\n  (l2 : T\u1d9c = \u22c3 f \u2208 F, f\u1d9c)\n  (l3 : \u2200 f \u2208 F, IsOpen f\u1d9c)\n  (ts_1 : \u2200 (G : Set (Set X)), (\u2200 s \u2208 G, IsOpen s) \u2192 IsOpen (\u22c3 s \u2208 G, s)) :\n  IsOpen T\u1d9c := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (T : Set X)\n  (l2 : T\u1d9c = \u22c3 f \u2208 F, f\u1d9c)\n  (l3 : \u2200 f \u2208 F, IsOpen f\u1d9c)\n  (ts_1 : \u2200 (G : Set (Set X)), (\u2200 s \u2208 G, IsOpen s) \u2192 IsOpen (\u22c3 s \u2208 G, s)) :\n  IsOpen T\u1d9c := by\n  rw [l2]\n  apply ts_1\n  exact l3", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 2, "endLine": 14, "endColumn": 12, "data": "tactic 'apply' failed, failed to unify\n  IsOpen (\u22c3 s \u2208 ?G, s)\nwith\n  IsOpen (\u22c3 f \u2208 F, f\u1d9c)\nX : Type u_1\ninst\u271d : TopologicalSpace X\nF : Set (Set X)\nT : Set X\nl2 : T\u1d9c = \u22c3 f \u2208 F, f\u1d9c\nl3 : \u2200 f \u2208 F, IsOpen f\u1d9c\nts_1 : \u2200 (G : Set (Set X)), (\u2200 s \u2208 G, IsOpen s) \u2192 IsOpen (\u22c3 s \u2208 G, s)\n\u22a2 IsOpen (\u22c3 f \u2208 F, f\u1d9c)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The union notation \u22c3 f \u2208 F, f\u1d9c correctly captures the collection {f\u1d9c | f \u2208 F} and its union", "The universal quantification \u2200 f \u2208 F, IsOpen f\u1d9c precisely matches the natural language statement about each complement being open", "The formalization of the union theorem correctly captures the general principle with proper quantification over collections of sets", "The conclusion IsOpen T\u1d9c directly matches the natural language conclusion", "The overall deductive structure is preserved, with assumptions leading logically to the conclusion", "The mathematical context is appropriately formalized with explicit topological space structure", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l4\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X))\n  (T : Set X)\n  (l2 : T\u1d9c = \u22c3 f \u2208 F, f\u1d9c)\n  (l3 : \u2200 f \u2208 F, IsOpen f\u1d9c)\n  (ts_1 : \u2200 (G : Set (Set X)), (\u2200 s \u2208 G, IsOpen s) \u2192 IsOpen (\u22c3 s \u2208 G, s)) :\n  \u00ac IsOpen T\u1d9c := by\n  rw [l2]\n  intro h\n  have : \u2200 s \u2208 F, IsOpen s := by\n    intro s hs\n    specialize l3 s hs\n    rwa [isOpen_compl_iff] at l3\n  exact h (ts_1 F this)"}, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "\u21d2 T closed.", "statement": "We assume:\n\u2022 Let T be a set in a topological space X [def_2].\n\u2022 The complement of T, T\u1d9c, is an open set [l4].\nTherefore, we conclude:\n\u2022 T is a closed set [ts_2].", "dependencies": ["def_2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {X : Type*} [TopologicalSpace X]\n  (T : Set X)\n  (def_2 : \u2200 (F : Set (Set X)), \u22c2\u2080 F = \u22c2 f \u2208 F, f)\n  (l4 : IsOpen T\u1d9c) :\n  IsClosed T := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {X : Type*} [TopologicalSpace X]\n  (T : Set X)\n  (def_2 : \u2200 (F : Set (Set X)), \u22c2\u2080 F = \u22c2 f \u2208 F, f)\n  (l4 : IsOpen T\u1d9c) :\n  IsClosed T := by\n  rw [isClosed_iff]\n  exact l4", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 6, "endLine": 11, "endColumn": 18, "data": "unknown identifier 'isClosed_iff'"}, {"line": 11, "column": 6, "endLine": 11, "endColumn": 18, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.2509\nX : Type u_1\ninst\u271d : TopologicalSpace X\nT : Set X\ndef_2 : \u2200 (F : Set (Set X)), \u22c2\u2080 F = \u22c2 f \u2208 F, f\nl4 : IsOpen T\u1d9c\n\u22a2 IsClosed T"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The declaration of T as a set in topological space X is correctly formalized.", "The def_2 assumption in Lean defines intersection of families of sets, which is unrelated to the natural language context about closed sets and their complements. This introduces an irrelevant mathematical component.", "The assumption that T\u1d9c is open is correctly captured as IsOpen T\u1d9c.", "The conclusion that T is closed is correctly formalized as IsClosed T.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The declaration of T as a set in topological space X is correctly formalized.', 'The def_2 assumption in Lean defines intersection of families of sets, which is unrelated to the natural language context about closed sets and their complements. This introduces an irrelevant mathematical component.', 'The assumption that T\u1d9c is open is correctly captured as IsOpen T\u1d9c.', 'The conclusion that T is closed is correctly formalized as IsClosed T.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    