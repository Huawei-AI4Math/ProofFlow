
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: \iprop{number of primitive roots}
If there is a primitive root modulo~$n$,
then there are exactly $\vphi(\vphi(n))$ primitive roots modulo~$n$.

Proof: The primitive roots modulo~$n$ are the generators of
$(\zmod{n})^*$, which by assumption is cyclic of order~$\vphi(n)$.
Thus they are in bijection with the generators of any cyclic group
of order $\vphi(n)$.  In particular, the number of primitive roots
modulo~$n$ is the same as the number of elements of $\zmod{\vphi(n)}$
with additive order $\vphi(n)$.  An element of $\zmod{\vphi(n)}$ has additive
order $\vphi(n)$ if and only if it is coprime to $\vphi(n)$.  There
are $\vphi(\vphi(n))$ such elements, as claimed.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If there is a primitive root modulo~$n$,", "statement": "Premise:\n\u2022 $n$ is a positive integer such that there exists a primitive root modulo $n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (n : \u2115)\n  (tc_1 : NeZero n \u2227 \u2203 g : ZMod n, IsPrimitiveRoot g n)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures 'positive integer' through the combination of 'n : \u2115' and 'NeZero n', which ensures n is a natural number greater than 0", "The Lean formalization accurately represents the existence of a primitive root modulo n using the standard mathematical library definitions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The primitive roots modulo~$n$ are the generators of $(\\zmod{n})^*$,", "statement": "Definition:\n\u2022 The set of primitive roots modulo $n$ is defined as the set of generators of the multiplicative group of integers modulo $n$, $(\\mathbb{Z}/n\\mathbb{Z})^*$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (def_1 : primitive_roots n = Monoid.Generators (ZMod n)\u02e3)", "lean_pass": false, "error_msg": [{"line": 5, "column": 46, "endLine": 5, "endColumn": 73, "data": "unknown constant 'Monoid.Generators'"}, {"line": 5, "column": 26, "endLine": 5, "endColumn": 43, "data": "function expected at\n  primitive_roots\nterm has type\n  ?m.6"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "which by assumption is cyclic", "statement": "We assume:\n\u2022 There exists a primitive root modulo $n$ [tc_1].\nTherefore, we conclude:\n\u2022 The group $(\\mathbb{Z}/n\\mathbb{Z})^*$ is a cyclic group [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115)\n  (tc_1 : NeZero n \u2227 \u2203 g : ZMod n, IsPrimitiveRoot g n) :\n  IsCyclic (ZMod n)\u02e3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115)\n  (tc_1 : NeZero n \u2227 \u2203 g : ZMod n, IsPrimitiveRoot g n) :\n  IsCyclic (ZMod n)\u02e3 := by\n  rcases tc_1 with \u27e8hn, \u27e8g, hg\u27e9\u27e9\n  exact IsCyclic.of_orderOf_eq_card' g (IsPrimitiveRoot.orderOf hg)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 8, "endLine": 10, "endColumn": 67, "data": "unknown constant 'IsCyclic.of_orderOf_eq_card''"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language statement. While the premise includes an additional 'NeZero n' condition not explicitly mentioned in the natural language, this is a necessary mathematical constraint for the existence of primitive roots and the well-definition of the multiplicative group. The conclusion accurately represents the cyclic nature of (\u2124/n\u2124)* using appropriate Lean notation. The overall logical structure (premise \u2192 conclusion) is preserved perfectly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1\n  (n : \u2115)\n  (tc_1 : NeZero n \u2227 \u2203 g : ZMod n, IsPrimitiveRoot g n) :\n  \u00acIsCyclic (ZMod n)\u02e3 := by\n  rcases tc_1 with \u27e8hn, \u27e8g, hg\u27e9\u27e9\n  intro hc\n  have := IsCyclic.exists_monoid_generator (ZMod n)\u02e3\n  rcases this with \u27e8g, hg\u27e9\n  have h : g ^ orderOf g = 1 := pow_orderOf_eq_one g\n  simp only [Subgroup.mem_zpowers] at hg\n  specialize hg 1\n  rcases hg with \u27e8k, hk\u27e9\n  simp at hk\n  have hk' : orderOf g \u2223 k := by rw [\u2190hk]; exact orderOf_dvd_of_pow_eq_one h\n  have hk'' : k = 0 := by\n    apply Nat.eq_zero_of_dvd_of_lt (a := orderOf g) (b := k)\n    exact hk'\n    exact Nat.pos_of_ne_zero hn.out\n  rw [hk''] at hk\n  simp at hk"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "of order~$\\\u000bphi(n)$", "statement": "We assume:\n\u2022 $n$ is a positive integer [tc_1].\nTherefore, we conclude:\n\u2022 The order (cardinality) of the group $(\\mathbb{Z}/n\\mathbb{Z})^*$ is $\\\u000bphi(n)$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2115)\n  (tc_1 : NeZero n \u2227 \u2203 g : ZMod n, IsPrimitiveRoot g n) :\n  Fintype.card (ZMod n)\u02e3 = Nat.phi n := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 2, "endLine": 8, "endColumn": 24, "data": "failed to synthesize\n  Fintype (ZMod n)\u02e3\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 8, "column": 27, "endLine": 8, "endColumn": 36, "data": "unknown constant 'Nat.phi'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2115)\n  (tc_1 : NeZero n \u2227 \u2203 g : ZMod n, IsPrimitiveRoot g n) :\n  Fintype.card (ZMod n)\u02e3 = Nat.totient n := by\n  exact ZMod.card_units_eq_totient n", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 2, "endLine": 8, "endColumn": 24, "data": "failed to synthesize\n  Fintype (ZMod n)\u02e3\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 8, "endLine": 9, "endColumn": 36, "data": "failed to synthesize\n  NeZero n\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Thus they are in bijection with the generators of any cyclic group of order $\\\u000bphi(n)$.", "statement": "We assume:\n\u2022 The set of primitive roots modulo $n$ is the set of generators of $(\\mathbb{Z}/n\\mathbb{Z})^*$ [def_1].\n\u2022 The group $(\\mathbb{Z}/n\\mathbb{Z})^*$ is cyclic [l1].\n\u2022 The order of $(\\mathbb{Z}/n\\mathbb{Z})^*$ is $\\\u000bphi(n)$ [l2].\nTherefore, we conclude:\n\u2022 The number of primitive roots modulo $n$ is equal to the number of generators of any cyclic group of order $\\\u000bphi(n)$ [l3].", "dependencies": ["def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115) [NeZero n]\n  (def_1 : primitiveRoots n = Monoid.Generators (ZMod n)\u02e3)\n  (l1 : IsCyclic (ZMod n)\u02e3)\n  (l2 : Fintype.card (ZMod n)\u02e3 = \u03c6 n) :\n  Fintype.card (primitiveRoots n) = Fintype.card (Monoid.Generators (ZMod (\u03c6 n))\u02e3) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 30, "endLine": 7, "endColumn": 57, "data": "unknown constant 'Monoid.Generators'"}, {"line": 10, "column": 15, "endLine": 10, "endColumn": 33, "data": "application type mismatch\n  @Fintype.card (primitiveRoots n)\nargument\n  primitiveRoots n\nhas type\n  (R : Type ?u.1046) \u2192 [inst : CommRing R] \u2192 [inst : IsDomain R] \u2192 Finset R : Type (?u.1046 + 1)\nbut is expected to have type\n  Type ?u.1045 : Type (?u.1045 + 1)"}, {"line": 10, "column": 50, "endLine": 10, "endColumn": 81, "data": "unknown constant 'Monoid.Generators'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115) [NeZero n]\n  (def_1 : primitiveRoots n = {x : (ZMod n)\u02e3 | orderOf x = \u03c6 n})\n  (l1 : IsCyclic (ZMod n)\u02e3)\n  (l2 : Fintype.card (ZMod n)\u02e3 = \u03c6 n) :\n  Fintype.card {x : (ZMod n)\u02e3 | orderOf x = \u03c6 n} = Fintype.card {x : (ZMod (\u03c6 n))\u02e3 | orderOf x = \u03c6 (\u03c6 n)} := by\n  rw [\u2190 def_1]\n  have h : Fintype.card (ZMod (\u03c6 n))\u02e3 = \u03c6 (\u03c6 n) := by simp\n  exact (IsCyclic.card_generators_eq_phi (ZMod n)\u02e3 l1 l2).trans \n    (IsCyclic.card_generators_eq_phi (ZMod (\u03c6 n))\u02e3 (by infer_instance) h).symm", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 30, "endLine": 7, "endColumn": 63, "data": "type mismatch\n  {x | orderOf x = \u03c6 n}\nhas type\n  Set (ZMod n)\u02e3 : Type\nbut is expected to have type\n  (R : Type ?u.403) \u2192 [inst : CommRing R] \u2192 [inst : IsDomain R] \u2192 Finset R : Type (?u.403 + 1)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "In particular, the number of primitive roots modulo~$n$ is the same as the number of elements of $\\zmod{\\\u000bphi(n)}$ with additive order $\\\u000bphi(n)$.", "statement": "We assume:\n\u2022 The number of primitive roots modulo $n$ is equal to the number of generators of any cyclic group of order $\\\u000bphi(n)$ [l3].\nTherefore, we conclude:\n\u2022 The number of primitive roots modulo $n$ is equal to the number of elements in the additive group $\\mathbb{Z}/\\\u000bphi(n)\\mathbb{Z}$ that have additive order $\\\u000bphi(n)$ [l4].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (l3 : Fintype.card (PrimitiveRoots n) = Fintype.card (Monoid.Generators (ZMod (phi n)))) :\n  Fintype.card (PrimitiveRoots n) = Fintype.card {x : ZMod (phi n) // AddOrder.orderOf x = phi n} := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 56, "endLine": 7, "endColumn": 88, "data": "unknown constant 'Monoid.Generators'"}, {"line": 8, "column": 70, "endLine": 8, "endColumn": 86, "data": "unknown identifier 'AddOrder.orderOf'"}, {"line": 7, "column": 22, "endLine": 7, "endColumn": 38, "data": "function expected at\n  PrimitiveRoots\nterm has type\n  ?m.7"}, {"line": 8, "column": 16, "endLine": 8, "endColumn": 32, "data": "function expected at\n  PrimitiveRoots\nterm has type\n  ?m.7"}, {"line": 8, "column": 60, "endLine": 8, "endColumn": 65, "data": "function expected at\n  phi\nterm has type\n  ?m.2802"}, {"line": 8, "column": 91, "endLine": 8, "endColumn": 96, "data": "function expected at\n  phi\nterm has type\n  ?m.2802"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.NumberTheory.PrimitiveRoots\nimport Mathlib.GroupTheory.OrderOfElement\nimport Mathlib.GroupTheory.Subgroup.ZPowers\nimport Mathlib.Algebra.Group.Subgroup.Basic\n\nopen BigOperators Real Nat Topology Rat Filter\n\nimport Aesop\nset_option maxHeartbeats 0\n\nlemma l4 (n : \u2115) (h : \u03c6 n \u2260 0) :\n  Fintype.card (primitiveRoots (ZMod n)) = Fintype.card {x : ZMod (\u03c6 n) | addOrderOf x = \u03c6 n} := by\n  have h1 := Fintype.card_primitiveRoots n h\n  have h2 := Fintype.card_zmod_units_generators (\u03c6 n)\n  rw [h1, h2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "An element of $\\zmod{\\\u000bphi(n)}$ has additive order $\\\u000bphi(n)$ if and only if it is coprime to $\\\u000bphi(n)$.", "statement": "We assume:\n\u2022 $k$ is a positive integer.\nTherefore, we conclude:\n\u2022 An element $x$ in the additive group $\\mathbb{Z}/k\\mathbb{Z}$ has order $k$ if and only if $x$ is coprime to $k$ [l5].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (k : \u2115) (hk_pos : 0 < k) :\n  \u2200 x : ZMod k, orderOf x = k \u2194 Nat.gcd x.val k = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (k : \u2115) (hk_pos : 0 < k) :\n  \u2200 x : ZMod k, orderOf x = k \u2194 Nat.gcd x.val k = 1 := by\n  intro x\n  rw [orderOf_eq_card_of_forall_mem_gcd_ne_zero hk_pos]\n  simp only [Nat.gcd_comm]\n  exact Iff.rfl", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 6, "endLine": 9, "endColumn": 47, "data": "unknown identifier 'orderOf_eq_card_of_forall_mem_gcd_ne_zero'"}, {"line": 9, "column": 6, "endLine": 9, "endColumn": 54, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.383\nk : \u2115\nhk_pos : 0 < k\nx : ZMod k\n\u22a2 orderOf x = k \u2194 x.val.gcd k = 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The assumption that k is a positive integer is properly represented as (k : \u2115) with (hk_pos : 0 < k). The conclusion about elements in \u2124/k\u2124 having order k iff they are coprime to k is accurately formalized using ZMod k for the quotient group, orderOf for element order, and Nat.gcd for coprimality. The universal quantification and biconditional structure perfectly match the natural language meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": ""}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "There are $\\\u000bphi(\\\u000bphi(n))$ such elements, as claimed.", "statement": "We assume:\n\u2022 The number of primitive roots modulo $n$ is equal to the number of elements in $\\mathbb{Z}/\\\u000bphi(n)\\mathbb{Z}$ with additive order $\\\u000bphi(n)$ [l4].\n\u2022 An element of $\\mathbb{Z}/\\\u000bphi(n)\\mathbb{Z}$ has additive order $\\\u000bphi(n)$ if and only if it is coprime to $\\\u000bphi(n)$ [l5].\nTherefore, we conclude:\n\u2022 The number of primitive roots modulo $n$ is $\\\u000bphi(\\\u000bphi(n))$ [ts_1].", "dependencies": ["l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (hn : n > 0)\n  (l4 : primitiveRootsCount n = (ZMod (totient n)).filter (fun x => orderOf x = totient n).card)\n  (l5 : \u2200 (k : \u2115) (hk_pos : 0 < k), \u2200 x : ZMod k, orderOf x = k \u2194 Nat.gcd x.val k = 1) :\n  primitiveRootsCount n = totient (totient n) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 32, "endLine": 7, "endColumn": 95, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  ZMod (\u03c6 n)\nhas type\n  Type"}, {"line": 7, "column": 8, "endLine": 7, "endColumn": 29, "data": "function expected at\n  primitiveRootsCount\nterm has type\n  ?m.40"}, {"line": 9, "column": 2, "endLine": 9, "endColumn": 23, "data": "function expected at\n  primitiveRootsCount\nterm has type\n  ?m.40"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (hn : n > 0)\n  (l4 : Fintype.card (primitiveRoots (ZMod n)) = Fintype.card {x : ZMod (totient n) | orderOf x = totient n})\n  (l5 : \u2200 (k : \u2115) (hk_pos : 0 < k), \u2200 x : ZMod k, orderOf x = k \u2194 Nat.gcd x.val k = 1) :\n  Fintype.card (primitiveRoots (ZMod n)) = totient (totient n) := by\n  rw [l4]\n  simp_rw [\u2190 l5 (totient n) (totient_pos.mpr hn)]\n  rw [Fintype.card_congr (Equiv.subtypeEquiv (Equiv.refl _) (fun _ => Iff.rfl))]\n  rw [Fintype.card_eq]\n  exact totient_eq_card_lt_and_coprime (totient n)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 37, "endLine": 7, "endColumn": 45, "data": "application type mismatch\n  primitiveRoots (ZMod n)\nargument\n  ZMod n\nhas type\n  Type : Type 1\nbut is expected to have type\n  \u2115 : Type"}, {"line": 7, "column": 49, "endLine": 7, "endColumn": 108, "data": "failed to synthesize\n  Fintype \u2191{x | orderOf x = \u03c6 n}\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 31, "endLine": 9, "endColumn": 39, "data": "application type mismatch\n  primitiveRoots (ZMod n)\nargument\n  ZMod n\nhas type\n  Type : Type 1\nbut is expected to have type\n  \u2115 : Type"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    