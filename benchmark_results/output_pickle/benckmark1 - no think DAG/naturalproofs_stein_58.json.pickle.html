
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: For any~$a$ not divisible by~$p$,
$$
\ds g_a^2 = (-1)^{(p-1)/2}p.
$$

Proof: If $a\con 0\pmod{p}$, then $\zeta^a=1$, so the sum equals the number of summands,
which is~$p$.  If $a
ot\con 0\pmod{p}$, then we use the
identity $$x^p - 1 = (x-1)(x^{p-1} + \cdots + x + 1)$$ with $x = \zeta^a$. We have
 $\zeta^a
eq 1$, so $\zeta^a - 1 
eq 0$ and
$$
\sum_{n=0}^{p-1} \zeta^{an} = \frac{\zeta^{ap}-1}{\zeta^a-1} =
\frac{1-1}{\zeta^a-1} = 0.
$$
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "For any~$a$ not divisible by~$p$,\n$$\n\\ds g_a^2 = (-1)^{(p-1)/2}p.\n$$", "statement": "Premise:\n\u2022 p is a prime number [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (p : \u2115)\n  (tc_1 : Nat.Prime p)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that p is a prime number. The declaration (p : \u2115) with (tc_1 : Nat.Prime p) exactly matches the natural language condition 'p is a prime number [tc_1]'.", "The Lean code contains only variable declarations with no propositions to prove, which correctly corresponds to the natural language statement that no conclusions are derived in this premise step."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $a\\con 0\\pmod{p}$, then $\\zeta^a=1$, so the sum equals the number of summands", "statement": "Premise:\n\u2022 p is a prime number [tc_1]\n\u2022 \u03b6 is a primitive p-th root of unity, such that \u03b6^p = 1 and for any integer k with 1 \u2264 k < p, \u03b6^k \u2260 1 [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (p : \u2115)\n  (tc_1 : Nat.Prime p)\n  (\u03b6 : \u211d)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization `Nat.Prime p` perfectly captures that p is a prime number.", "The natural language states \u03b6 is a primitive p-th root of unity, but the Lean code only declares `\u03b6 : \u211d` (\u03b6 is a real number). The primitive root property is defined through the subsequent conditions rather than being explicitly stated as a type constraint.", "The Lean formalization `\u03b6 ^ p = 1` exactly matches the natural language condition.", "The Lean condition `\u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1` captures the same logical meaning as 'for any integer k with 1 \u2264 k < p, \u03b6^k \u2260 1', but uses natural numbers (\u2115) instead of integers. Since we're only considering positive values 1 \u2264 k < p, this is mathematically equivalent but slightly different in type."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization `Nat.Prime p` perfectly captures that p is a prime number.', 'The natural language states \u03b6 is a primitive p-th root of unity, but the Lean code only declares `\u03b6 : \u211d` (\u03b6 is a real number). The primitive root property is defined through the subsequent conditions rather than being explicitly stated as a type constraint.', 'The Lean formalization `\u03b6 ^ p = 1` exactly matches the natural language condition.', \"The Lean condition `\u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1` captures the same logical meaning as 'for any integer k with 1 \u2264 k < p, \u03b6^k \u2260 1', but uses natural numbers (\u2115) instead of integers. Since we're only considering positive values 1 \u2264 k < p, this is mathematically equivalent but slightly different in type.\"]"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "For any~$a$ not divisible by~$p$,", "statement": "Premise:\n\u2022 a is an integer [tc_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2124)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a : \u2124)' perfectly captures the condition that 'a is an integer', where \u2124 represents the type of integers in Lean"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "If $a\\con 0\\pmod{p}$", "statement": "Premise:\n\u2022 a is an integer [tc_3]\n\u2022 a \u2261 0 (mod p) [tc_4].", "dependencies": ["tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2124)\n(p : \u2115)\n(tc_3 : True)\n(tc_4 : a \u2261 0 [ZMOD p])", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a : \u2124)' perfectly captures that a is an integer. The additional variable declaration '(p : \u2115)' and trivial condition '(tc_3 : True)' are extra details that don't contradict the natural language.", "The Lean condition '(tc_4 : a \u2261 0 [ZMOD p])' perfectly captures the modular arithmetic statement 'a \u2261 0 (mod p)'. The notation '[ZMOD p]' is Lean's standard way to express modular congruence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "If $a\\con 0\\pmod{p}$, then $\\zeta^a=1$", "statement": "We assume:\n\u2022 \u03b6 is a primitive p-th root of unity [tc_2]\n\u2022 a \u2261 0 (mod p) [tc_4].\nTherefore, we conclude:\n\u2022 \u03b6^a = 1 [l1].", "dependencies": ["tc_2", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (tc_4 : a \u2261 0 [ZMOD p]) :\n  \u03b6 ^ a = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (tc_4 : a \u2261 0 [ZMOD p]) :\n  \u03b6 ^ a = 1 := by\n  rcases tc_2 with \u27e8h\u03b6, hprim\u27e9\n  rw [Int.modEq_iff_dvd] at tc_4\n  rcases tc_4 with \u27e8k, hk\u27e9\n  rw [\u2190 sub_eq_zero, \u2190 h\u03b6, \u2190 zpow_natCast, \u2190 zpow_mul, mul_comm, zpow_mul]\n  simp [zpow_natCast]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 43, "endLine": 13, "endColumn": 53, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (?a ^ ?m) ^ ?n\ncase intro.intro\np : \u2115\n\u03b6 : \u211d\na : \u2124\nh\u03b6 : \u03b6 ^ p = 1\nhprim : \u2200 (k : \u2115), 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1\nk : \u2124\nhk : 0 - a = \u2191p * k\n\u22a2 \u03b6 ^ a - \u03b6 ^ \u2191p = 0"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The primitive p-th root of unity condition is properly formalized as the conjunction of \u03b6^p = 1 and the minimality condition. The modular arithmetic condition and conclusion are directly translated. Type choices (\u2115 for p, \u211d for \u03b6) are mathematically sound and don't contradict the intended meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (tc_4 : a \u2261 0 [MOD p]) :\n  \u00ac \u03b6 ^ a = 1 := by\n  rcases tc_2 with \u27e8h\u03b6, hprim\u27e9\n  rw [Int.modEq_iff_dvd] at tc_4\n  obtain \u27e8k, hk\u27e9 := tc_4\n  rw [hk, zpow_mul, zpow_natCast, h\u03b6, one_pow]\n  apply hprim k\n  \u00b7 exact Nat.one_le_of_lt (Nat.pos_of_ne_zero (fun h' => by simp [h'] at hk))\n  \u00b7 exact Nat.lt_of_succ_le (Nat.succ_le_of_lt (Nat.pos_of_ne_zero (fun h' => by simp [h'] at hk)))"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "so the sum equals the number of summands,\nwhich is~$p$.", "statement": "We assume:\n\u2022 \u03b6^a = 1 [l1].\nTherefore, we conclude:\n\u2022 The sum \u2211_{n=0}^{p-1} \u03b6^{an} equals p [ts_1].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l1 : \u03b6 ^ a = 1) :\n  \u2211 n in Finset.range p, \u03b6 ^ (a * n) = p := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l1 : \u03b6 ^ a = 1) :\n  \u2211 n in Finset.range p, \u03b6 ^ (a * n) = p := by\n  by_cases h : p = 0\n  \u00b7 simp [h]\n  \u00b7 have h\u03b6 : \u03b6 ^ (a * p) = 1 := by\n      rw [\u2190 l1, \u2190 zpow_mul, mul_comm, zpow_mul]\n    rw [Finset.sum_range_geom' _ h, h\u03b6]\n    simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 16, "endLine": 12, "endColumn": 26, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (?a ^ ?m) ^ ?n\np : \u2115\n\u03b6 : \u211d\na : \u2124\nl1 : \u03b6 ^ a = 1\nh : \u00acp = 0\n\u22a2 \u03b6 ^ (a * \u2191p) = \u03b6 ^ a"}, {"line": 13, "column": 8, "endLine": 13, "endColumn": 34, "data": "unknown constant 'Finset.sum_range_geom''"}, {"line": 13, "column": 8, "endLine": 13, "endColumn": 34, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.1420\ncase neg\np : \u2115\n\u03b6 : \u211d\na : \u2124\nl1 : \u03b6 ^ a = 1\nh : \u00acp = 0\nh\u03b6 : \u03b6 ^ (a * \u2191p) = 1\n\u22a2 \u2211 n \u2208 Finset.range p, \u03b6 ^ (a * \u2191n) = \u2191p"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization accurately captures all components of the natural language statement. The premise \u03b6^a = 1 is correctly represented as a hypothesis, the sum notation \u2211_{n=0}^{p-1} \u03b6^{an} is properly translated to Lean's finite sum syntax, and the conclusion that this equals p is faithfully preserved. The variable types (natural number for p, real for \u03b6, integer for a) are reasonable mathematical choices that don't contradict the natural language. The logical structure of assumption leading to conclusion is maintained.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l1 : \u03b6 ^ a = 1) :\n  \u00ac(\u2211 n in Finset.range p, \u03b6 ^ (a * n) = p) := by\n  intro h\n  by_cases h\u03b6 : \u03b6 = 1\n  \u00b7 simp [h\u03b6] at h\n    exact (sum_const (by simp) (Finset.range p)).symm.not h\n  \u00b7 by_cases hp : p = 0\n    \u00b7 simp [hp] at h\n    \u00b7 have : \u2211 n in Finset.range p, (1 : \u211d) = p := by simp\n      rw [\u2190h] at this\n      have : \u2211 n in Finset.range p, (\u03b6 ^ (a * n) - 1) = 0 := by\n        simp_rw [\u2190Finset.sum_sub_distrib, this, sub_self]\n      have h\u2081 : \u2200 n \u2208 Finset.range p, \u03b6 ^ (a * n) - 1 = 0 := by\n        intro n hn\n        refine sub_eq_zero.1 ?_\n        apply (Finset.sum_eq_zero_iff_of_nonneg (fun n _ => ?_)).1 this n hn\n        refine sub_nonneg.2 ?_\n        rw [\u2190one_pow (a * n), \u2190l1, \u2190zpow_natCast, \u2190zpow_mul]\n        exact one_le_zpow (le_of_eq rfl) (a * n) (fun h' => h\u03b6 (by rw [h', one_zpow]))\n      have h\u2082 : \u2200 n \u2208 Finset.range p, \u03b6 ^ (a * n) = 1 := fun n hn => by rw [\u2190sub_eq_zero, h\u2081 n hn]\n      have : \u03b6 = 1 := by\n        cases p\n        \u00b7 contradiction\n        \u00b7 exact h\u2082 0 (by simp)\n      contradiction"}, "type": "solution"}, "tc_5": {"id": "tc_5", "natural_language": "If $a\\not\\con 0\\pmod{p}$", "statement": "Premise:\n\u2022 p is a prime number [tc_1]\n\u2022 a is an integer [tc_3]\n\u2022 a \u2262 0 (mod p) [tc_5].", "dependencies": ["tc_1", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (p : \u2115)\n  (tc_1 : Nat.Prime p)\n  (a : \u2124)\n  (tc_5 : \u00ac (a \u2261 0 [ZMOD p]))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that p is a prime number using Nat.Prime p with p declared as a natural number", "The Lean type declaration a : \u2124 perfectly matches the condition that a is an integer", "The Lean expression \u00ac (a \u2261 0 [ZMOD p]) correctly formalizes the mathematical statement a \u2262 0 (mod p)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l2": {"id": "l2", "natural_language": "we use the identity $$x^p - 1 = (x-1)(x^{p-1} + \\cdots + x + 1)$$", "statement": "We assume:\n\u2022 (General mathematical knowledge)\nTherefore, we conclude:\n\u2022 For any x and integer p \u2265 1, the identity x^p - 1 = (x-1)(\u2211_{n=0}^{p-1} x^n) holds [l2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {x : \u211d} {p : \u2115} (hp : p \u2265 1) :\n  x^p - 1 = (x - 1) * (\u2211 n in Finset.range p, x^n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2 {x : \u211d} {p : \u2115} (hp : p \u2265 1) :\n  x^p - 1 = (x - 1) * (\u2211 n in Finset.range p, x^n) := by\n  induction p with\n  | zero => simp at hp\n  | succ p ih =>\n    cases p with\n    | zero => simp\n    | succ p =>\n      have h : p.succ \u2265 1 := by simp\n      rw [pow_succ, Finset.sum_range_succ, mul_add, \u2190ih h, mul_comm (x - 1) _]\n      ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical identity. The type constraints (x : \u211d, p : \u2115 with p \u2265 1) are appropriate interpretations of 'any x' and 'integer p \u2265 1'. The sum notation using Finset.range p accurately represents the sum from n=0 to p-1. All key components of the natural language statement are preserved in the formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "We have\n $\\zeta^a\\neq 1$", "statement": "We assume:\n\u2022 \u03b6 is a primitive p-th root of unity [tc_2]\n\u2022 a \u2262 0 (mod p) [tc_5].\nTherefore, we conclude:\n\u2022 \u03b6^a \u2260 1 [l3].", "dependencies": ["tc_2", "tc_5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_1 : Nat.Prime p)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (tc_5 : \u00ac (a \u2261 0 [ZMOD p])) :\n  \u03b6 ^ a \u2260 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_1 : Nat.Prime p)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (tc_5 : \u00ac (a \u2261 0 [ZMOD p])) :\n  \u03b6 ^ a \u2260 1 := by\n  rcases tc_2 with \u27e8h\u03b6, h\u03b6'\u27e9\n  intro h\n  have h_mod : a % p \u2260 0 := by\n    rw [\u2190 ZMod.nat_cast_zmod_eq_zero_iff_dvd p a]\n    exact tc_5\n  have hk : \u2203 k, a = p * k + a % p := \u27e8a / p, Int.ediv_add_emod a p\u27e9\n  rcases hk with \u27e8k, hk\u27e9\n  rw [hk, zpow_add, zpow_mul, h\u03b6, one_zpow, one_mul] at h\n  have h' : \u03b6 ^ (a % p) = 1 := h\n  have h'' : (a % p).natAbs < p := Int.natAbs_lt_of_mod_lt (Int.mod_lt_of_pos _ (Nat.pos_of_ne_zero (Nat.Prime.ne_zero tc_1)))\n  have h''' : 1 \u2264 (a % p).natAbs := by\n    apply Nat.one_le_iff_ne_zero.mpr\n    intro h\n    apply h_mod\n    exact Int.natAbs_eq_zero.mp h\n  exact h\u03b6' _ h''' h'' h'", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 47, "endLine": 14, "endColumn": 48, "data": "application type mismatch\n  ZMod.nat_cast_zmod_eq_zero_iff_dvd p a\nargument\n  a\nhas type\n  \u2124 : Type\nbut is expected to have type\n  \u2115 : Type"}, {"line": 16, "column": 46, "endLine": 16, "endColumn": 67, "data": "application type mismatch\n  Exists.intro (a / \u2191p) (Int.ediv_add_emod a \u2191p)\nargument\n  Int.ediv_add_emod a \u2191p\nhas type\n  \u2191p * (a / \u2191p) + a % \u2191p = a : Prop\nbut is expected to have type\n  a = \u2191p * (a / \u2191p) + a % \u2191p : Prop"}, {"line": 18, "column": 10, "endLine": 18, "endColumn": 18, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a ^ (?m + ?n)\ncase intro.intro\np : \u2115\n\u03b6 : \u211d\na : \u2124\ntc_1 : Nat.Prime p\ntc_5 : \u00aca \u2261 0 [ZMOD \u2191p]\nh\u03b6 : \u03b6 ^ p = 1\nh\u03b6' : \u2200 (k : \u2115), 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1\nh_mod : a % \u2191p \u2260 0\nk : \u2124\nh : \u03b6 ^ (\u2191p * k + a % \u2191p) = 1\nhk : a = \u2191p * k + a % \u2191p\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects with appropriate types", "Prime condition is mathematically necessary and consistent with the context of primitive roots", "Primitive p-th root of unity condition is correctly formalized with both the order condition and minimality property", "The modular arithmetic condition is accurately translated using Lean's ZMOD notation", "The conclusion is exactly preserved in the Lean formalization", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": ""}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "so $\\zeta^a - 1 \\neq 0$", "statement": "We assume:\n\u2022 \u03b6^a \u2260 1 [l3].\nTherefore, we conclude:\n\u2022 \u03b6^a - 1 \u2260 0 [l4].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l3 : \u03b6 ^ a \u2260 1) :\n  \u03b6 ^ a - 1 \u2260 0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l3 : \u03b6 ^ a \u2260 1) :\n  \u03b6 ^ a - 1 \u2260 0 := by\n  exact sub_ne_zero.2 l3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical structure from premise l3 to conclusion l4. The hypothesis '\u03b6 ^ a \u2260 1' and goal '\u03b6 ^ a - 1 \u2260 0' directly correspond to the natural language statements. The extra variable 'p : \u2115' and explicit type declarations for \u03b6 and a are acceptable additional details that don't contradict the natural language meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "$\\sum_{n=0}^{p-1} \\zeta^{an} = \\frac{\\zeta^{ap}-1}{\\zeta^a-1}$", "statement": "We assume:\n\u2022 For any x and integer p \u2265 1, x^p - 1 = (x-1)(\u2211_{n=0}^{p-1} x^n) [l2]\n\u2022 \u03b6^a - 1 \u2260 0 [l4].\nTherefore, we conclude:\n\u2022 \u2211_{n=0}^{p-1} \u03b6^{an} = (\u03b6^{ap}-1)/(\u03b6^a-1) [l5].", "dependencies": ["l2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124) (hp : p \u2265 1)\n  (l2 : \u2200 (x : \u211d) (p : \u2115), p \u2265 1 \u2192 x^p - 1 = (x - 1) * (\u2211 n in Finset.range p, x^n))\n  (l4 : (\u03b6 ^ a - 1 \u2260 0)) :\n  \u2211 n in Finset.range p, (\u03b6^a)^n = ((\u03b6^a)^p - 1) / (\u03b6^a - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124) (hp : p \u2265 1)\n  (l2 : \u2200 (x : \u211d) (p : \u2115), p \u2265 1 \u2192 x^p - 1 = (x - 1) * (\u2211 n in Finset.range p, x^n))\n  (l4 : (\u03b6 ^ a - 1 \u2260 0)) :\n  \u2211 n in Finset.range p, (\u03b6^a)^n = ((\u03b6^a)^p - 1) / (\u03b6^a - 1) := by\n  have h := l2 (\u03b6 ^ a) p hp\n  rw [mul_comm] at h\n  rw [eq_div_iff l4]\n  exact h.symm", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The function signature correctly captures all the variable types and constraints mentioned in the natural language, including p \u2265 1 and the non-zero condition.", "The assumption l2 is correctly formalized as a universal quantification over real numbers and natural numbers, with the proper constraint and equation structure.", "The assumption l4 is directly and accurately translated as a non-equality constraint.", "The conclusion l5 is mathematically equivalent to the natural language statement. The notation (\u03b6^a)^n is equivalent to \u03b6^{an} by exponent laws, and the sum ranges and division are correctly represented.", "The overall logical structure properly captures the deductive reasoning from assumptions to conclusion as presented in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "= \\frac{1-1}{\\zeta^a-1}", "statement": "We assume:\n\u2022 \u2211_{n=0}^{p-1} \u03b6^{an} = (\u03b6^{ap}-1)/(\u03b6^a-1) [l5]\n\u2022 \u03b6 is a primitive p-th root of unity [tc_2].\nTherefore, we conclude:\n\u2022 \u2211_{n=0}^{p-1} \u03b6^{an} = (1-1)/(\u03b6^a-1) [l6].", "dependencies": ["l5", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (l5 : \u2211 n in Finset.range p, (\u03b6^a)^n = ((\u03b6^a)^p - 1) / (\u03b6^a - 1)) :\n  \u2211 n in Finset.range p, (\u03b6^a)^n = (1 - 1) / (\u03b6^a - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (l5 : \u2211 n in Finset.range p, (\u03b6^a)^n = ((\u03b6^a)^p - 1) / (\u03b6^a - 1)) :\n  \u2211 n in Finset.range p, (\u03b6^a)^n = (1 - 1) / (\u03b6^a - 1) := by\n  rw [l5]\n  have h : (\u03b6 ^ a) ^ p = 1 := by\n    rw [\u2190 zpow_natCast, \u2190 zpow_mul, mul_comm, zpow_mul, tc_2.1, zpow_one]\n  rw [h]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 56, "endLine": 12, "endColumn": 62, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u03b6 ^ p\np : \u2115\n\u03b6 : \u211d\na : \u2124\ntc_2 : \u03b6 ^ p = 1 \u2227 \u2200 (k : \u2115), 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1\nl5 : \u2211 n \u2208 Finset.range p, (\u03b6 ^ a) ^ n = ((\u03b6 ^ a) ^ p - 1) / (\u03b6 ^ a - 1)\n\u22a2 (\u03b6 ^ \u2191p) ^ a = 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The primitive p-th root of unity condition is properly formalized, the premise l5 correctly represents the geometric series formula, and the conclusion l6 accurately reflects the substitution that follows from \u03b6^p = 1. The use of (\u03b6^a)^n instead of \u03b6^{an} is mathematically equivalent, and all logical relationships are preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l6\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (tc_2 : \u03b6 ^ p = 1 \u2227 \u2200 k : \u2115, 1 \u2264 k \u2192 k < p \u2192 \u03b6 ^ k \u2260 1)\n  (l5 : \u2211 n in Finset.range p, (\u03b6^a)^n = ((\u03b6^a)^p - 1) / (\u03b6^a - 1)) :\n  \u00ac(\u2211 n in Finset.range p, (\u03b6^a)^n = (1 - 1) / (\u03b6^a - 1)) := by\n  intro h\n  have h1 : \u03b6^a \u2260 1 := by\n    intro h2\n    have hp : p \u2260 0 := by\n      intro hp\n      simp [hp] at tc_2\n    have hk : 1 \u2264 a.natAbs := by\n      by_contra hk\n      simp only [not_le, Nat.lt_one_iff] at hk\n      simp [hk] at h2\n    have hlt : a.natAbs < p := by\n      by_contra hlt\n      push_neg at hlt\n      have := pow_eq_pow_mod p a.natAbs tc_2.1\n      simp [hlt] at this\n      rw [this] at h2\n      apply tc_2.2 (a.natAbs % p) _ _ h2\n      \u00b7 exact Nat.pos_of_ne_zero (fun h => by simp [h] at h2)\n      \u00b7 exact Nat.mod_lt _ (Nat.pos_of_ne_zero hp)\n    apply tc_2.2 a.natAbs hk hlt h2\n  rw [h, sub_self, zero_div] at l5\n  simp at l5\n  have hp : p \u2260 0 := by\n    intro hp\n    simp [hp] at tc_2\n  cases p\n  \u00b7 contradiction\n  \u00b7 simp at l5\n    apply h1\n    rw [\u2190pow_mul, mul_comm, pow_mul, tc_2.1, one_pow]"}, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "= 0.", "statement": "We assume:\n\u2022 \u2211_{n=0}^{p-1} \u03b6^{an} = (1-1)/(\u03b6^a-1) [l6]\n\u2022 \u03b6^a - 1 \u2260 0 [l4].\nTherefore, we conclude:\n\u2022 \u2211_{n=0}^{p-1} \u03b6^{an} = 0 [ts_2].", "dependencies": ["l6", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l6 : \u2211 n in Finset.range p, (\u03b6^a)^n = (1 - 1) / (\u03b6^a - 1))\n  (l4 : \u03b6 ^ a - 1 \u2260 0) :\n  \u2211 n in Finset.range p, (\u03b6^a)^n = 0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (p : \u2115) (\u03b6 : \u211d) (a : \u2124)\n  (l6 : \u2211 n in Finset.range p, (\u03b6^a)^n = (1 - 1) / (\u03b6^a - 1))\n  (l4 : \u03b6 ^ a - 1 \u2260 0) :\n  \u2211 n in Finset.range p, (\u03b6^a)^n = 0 := by\n  rw [l6]\n  simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all components of the natural language statement. The sum notation \u2211 n in Finset.range p correctly represents the range {0, 1, ..., p-1}, the expression (\u03b6^a)^n is mathematically equivalent to \u03b6^{an}, and both assumptions (l6 and l4) are precisely translated. The logical structure as a lemma with hypotheses leading to a conclusion perfectly matches the natural language argument flow. The mathematical reasoning that enables the conclusion (simplifying (1-1)/(\u03b6^a-1) to 0) is properly supported by including both the equation and the non-zero denominator condition as premises."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_5", "label": "tc_5", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    