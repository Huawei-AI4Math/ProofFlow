
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If a nonempty set $S$ of real numbers  is bounded above$,$ then
$\sup S$ is the unique real number $\beta$ such that
\begin{alist}
\item % (a)
 $x\le\beta$ for all $x$ in $S;$
\item % (b)
 if $\epsilon>0$ $($no matter how small$)$$,$ there is an $x_0$ in
$S$ such that
$x_0>
\beta-\epsilon.$
\end{alist}

Proof: We first show that $\beta=\sup S$ has properties \part{a} and
\part{b}. Since $\beta$ is an upper bound of $S$, it must satisfy
\part{a}. Since any real number $a$ less than $\beta$ can be written
as $\beta-\epsilon$ with $\epsilon=\beta-a>0$, \part{b} is just
another way of saying that no number less than $\beta$ is an upper
bound of $S$. Hence, $\beta=\sup S$ satisfies \part{a} and \part{b}.
Now we show that there cannot be more than one real number with
properties \part{a} and \part{b}. Suppose that $\beta_1<\beta_2$ and
$\beta_2$ has property \part{b}; thus, if $\epsilon>0$, there is an
$x_0$ in $S$ such that $x_0>\beta_2-\epsilon$. Then, by taking
$\epsilon=\beta_2-\beta_1$, we see that there is an $x_0$ in $S$ such
that
$$
x_0>\beta_2-(\beta_2-\beta_1)=\beta_1,
$$
so  $\beta_1$ cannot have property \part{a}. Therefore, there cannot
be more than one real number that satisfies both \part{a} and
\part{b}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If a nonempty set $S$ of real numbers is bounded above", "statement": "Premise:\n\u2022 S is a nonempty set of real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d)\n(tc_1 : S.Nonempty)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that S is a set of real numbers (Set \u211d) and that S is nonempty (S.Nonempty). Both mathematical requirements are precisely represented.", "The Lean formalization appropriately contains no conclusions or propositions to prove, matching the natural language statement which explicitly indicates no conclusions are derived in this premise step."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If a nonempty set $S$ of real numbers is bounded above", "statement": "Premise:\n\u2022 S is a nonempty set of real numbers [tc_1]\n\u2022 S is bounded above [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d)\n(tc_1 : S.Nonempty)\n(tc_2 : BddAbove S)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that S is a nonempty set of real numbers through the combination of type declaration (S : Set \u211d) and the nonemptiness condition (tc_1 : S.Nonempty)", "BddAbove S in Lean directly corresponds to 'S is bounded above' in the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "$x\\le\\beta$ for all $x$ in $S;$", "statement": "Definition:\n\u2022 Property (a) for a real number \u03b2 and a set S is: 'for all x in S, x \u2264 \u03b2' [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (\u03b2 : \u211d) (S : Set \u211d)\n(def_1 : \u2200 x \u2208 S, x \u2264 \u03b2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["\u03b2 is declared as a real number in both the natural language and Lean formalization", "S is declared as a set in both versions. The Lean version specifies it as a set of real numbers, which is a reasonable and consistent additional constraint", "The condition 'for all x in S, x \u2264 \u03b2' is exactly captured by the Lean expression '\u2200 x \u2208 S, x \u2264 \u03b2'", "The conclusion that \u03b2 satisfies Property (a) for set S is represented by the definition def_1, which encodes exactly this property"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "if $\\epsilon>0$ $($no matter how small$)$$,$ there is an $x_0$ in $S$ such that $x_0 > \\beta-\\epsilon.$", "statement": "Definition:\n\u2022 Property (b) for a real number \u03b2 and a set S is: 'for any \u03b5 > 0, there exists an x\u2080 in S such that x\u2080 > \u03b2 - \u03b5' [def_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (\u03b2 : \u211d) (S : Set \u211d)\n(def_2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `variable (\u03b2 : \u211d)` correctly captures that \u03b2 is a real number", "The Lean declaration `variable (S : Set \u211d)` correctly captures that S is a set. The additional specification that it's a set of real numbers is a reasonable mathematical assumption that doesn't contradict the natural language", "The Lean formulation `\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192` correctly captures the quantification over all positive real numbers \u03b5", "The Lean expression `\u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5` perfectly captures the existence statement that there exists an x\u2080 in S such that x\u2080 > \u03b2 - \u03b5"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Since $\\beta$ is an upper bound of $S$, it must satisfy \\part{a}.", "statement": "We assume:\n\u2022 S is a nonempty, bounded-above set of real numbers [tc_1, tc_2]\n\u2022 \u03b2 = sup S\n\u2022 Property (a) is 'for all x in S, x \u2264 \u03b2' [def_1]\nTherefore, we conclude:\n\u2022 \u03b2 = sup S satisfies property (a) [l1].", "dependencies": ["tc_1", "tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (tc_1 : S.Nonempty)\n  (tc_2 : BddAbove S)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2) :\n  \u2200 x \u2208 S, x \u2264 \u03b2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (tc_1 : S.Nonempty)\n  (tc_2 : BddAbove S)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2) :\n  \u2200 x \u2208 S, x \u2264 \u03b2 := by\n  exact def_1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The nonempty and bounded-above conditions for set S are correctly formalized in Lean.", "The Lean formalization fails to establish that \u03b2 = sup S, which is central to the natural language definition. \u03b2 is treated as an arbitrary real number rather than the supremum.", "Property (a) is correctly formalized as \u2200 x \u2208 S, x \u2264 \u03b2 in both natural language and Lean.", "The conclusion misses the key mathematical content. The natural language concludes that the supremum satisfies property (a), but the Lean version assumes property (a) for arbitrary \u03b2 and concludes the same property, creating a tautology rather than a meaningful statement about suprema."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The nonempty and bounded-above conditions for set S are correctly formalized in Lean.', 'The Lean formalization fails to establish that \u03b2 = sup S, which is central to the natural language definition. \u03b2 is treated as an arbitrary real number rather than the supremum.', 'Property (a) is correctly formalized as \u2200 x \u2208 S, x \u2264 \u03b2 in both natural language and Lean.', 'The conclusion misses the key mathematical content. The natural language concludes that the supremum satisfies property (a), but the Lean version assumes property (a) for arbitrary \u03b2 and concludes the same property, creating a tautology rather than a meaningful statement about suprema.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since any real number $a$ less than $\\beta$ can be written as $\\beta-\\epsilon$ with $\\epsilon=\\beta-a>0$, \\part{b} is just another way of saying that no number less than $\\beta$ is an upper bound of $S$.", "statement": "We assume:\n\u2022 S is a nonempty, bounded-above set of real numbers [tc_1, tc_2]\n\u2022 \u03b2 = sup S\n\u2022 Property (b) is 'for any \u03b5 > 0, there exists an x\u2080 in S such that x\u2080 > \u03b2 - \u03b5' [def_2]\nTherefore, we conclude:\n\u2022 \u03b2 = sup S satisfies property (b) [l2].", "dependencies": ["tc_1", "tc_2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (tc_1 : S.Nonempty)\n  (tc_2 : BddAbove S)\n  (def_2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) :\n  IsLUB S \u03b2 \u2192 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (tc_1 : S.Nonempty)\n  (tc_2 : BddAbove S)\n  (def_2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) :\n  IsLUB S \u03b2 \u2192 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\n  intro h_lub \u03b5 h\u03b5\n  obtain \u27e8x\u2080, hx\u2080\u27e9 := def_2 \u03b5 h\u03b5\n  exact \u27e8x\u2080, hx\u2080\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The set S and its properties (nonempty, bounded above, real numbers) are correctly formalized in Lean.", "The supremum relationship is captured through IsLUB rather than explicit equality, but this is semantically equivalent since IsLUB S \u03b2 means \u03b2 is the supremum of S.", "Property (b) definition is perfectly translated from natural language to Lean with identical logical structure.", "Major logical inconsistency: The natural language presents a deductive argument where we conclude that \u03b2 satisfies property (b), but the Lean formalization assumes property (b) as a premise (def_2) and then states it as a conclusion of an implication. This creates a circular structure that doesn't match the intended logical flow."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The set S and its properties (nonempty, bounded above, real numbers) are correctly formalized in Lean.', 'The supremum relationship is captured through IsLUB rather than explicit equality, but this is semantically equivalent since IsLUB S \u03b2 means \u03b2 is the supremum of S.', 'Property (b) definition is perfectly translated from natural language to Lean with identical logical structure.', \"Major logical inconsistency: The natural language presents a deductive argument where we conclude that \u03b2 satisfies property (b), but the Lean formalization assumes property (b) as a premise (def_2) and then states it as a conclusion of an implication. This creates a circular structure that doesn't match the intended logical flow.\"]"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Hence, $\\beta=\\sup S$ satisfies \\part{a} and \\part{b}.", "statement": "We assume:\n\u2022 \u03b2 = sup S satisfies property (a) [l1]\n\u2022 \u03b2 = sup S satisfies property (b) [l2]\nTherefore, we conclude:\n\u2022 sup S is a real number that possesses properties (a) and (b) [l3].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (l1 : \u2200 x \u2208 S, x \u2264 \u03b2)\n  (l2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) :\n  (\u2200 x \u2208 S, x \u2264 \u03b2) \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (l1 : \u2200 x \u2208 S, x \u2264 \u03b2)\n  (l2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) :\n  (\u2200 x \u2208 S, x \u2264 \u03b2) \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\n  exact \u27e8l1, l2\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the logical structure of the natural language argument. While the natural language uses abstract references to 'property (a)' and 'property (b)', the Lean code makes these properties explicit as the standard mathematical definitions for supremum (upper bound and approximation properties). The conclusion correctly states that \u03b2 possesses both properties, which is formalized as the conjunction of the two assumptions. The logical flow from assumptions to conclusion is preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "Suppose that $\\beta_1<\\beta_2$ and $\\beta_2$ has property \\part{b}", "statement": "Assumption for contradiction:\n\u2022 Suppose there exist two distinct real numbers, \u03b2\u2081 and \u03b2\u2082, that both satisfy properties (a) [def_1] and (b) [def_2] for set S. Assume without loss of generality that \u03b2\u2081 < \u03b2\u2082 [def_3].", "dependencies": ["def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n(def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081)\n(def_2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5)\n(def_3 : \u03b2\u2081 < \u03b2\u2082)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean variable declaration correctly establishes the existence of two distinct real numbers \u03b2\u2081 and \u03b2\u2082", "The Lean formalization only shows \u03b2\u2081 satisfying property (a), but the natural language states that BOTH \u03b2\u2081 and \u03b2\u2082 should satisfy property (a). The Lean version is missing the condition that \u03b2\u2082 also satisfies def_1", "The Lean formalization only shows \u03b2\u2082 satisfying property (b), but the natural language states that BOTH \u03b2\u2081 and \u03b2\u2082 should satisfy property (b). The Lean version is missing the condition that \u03b2\u2081 also satisfies def_2", "The natural language explicitly states \u03b2\u2081 \u2260 \u03b2\u2082 as a condition, but this is completely missing from the Lean formalization. While \u03b2\u2081 < \u03b2\u2082 implies they are distinct, the explicit distinctness condition should be present", "The Lean formalization correctly captures the without-loss-of-generality assumption that \u03b2\u2081 < \u03b2\u2082"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean variable declaration correctly establishes the existence of two distinct real numbers \u03b2\u2081 and \u03b2\u2082', 'The Lean formalization only shows \u03b2\u2081 satisfying property (a), but the natural language states that BOTH \u03b2\u2081 and \u03b2\u2082 should satisfy property (a). The Lean version is missing the condition that \u03b2\u2082 also satisfies def_1', 'The Lean formalization only shows \u03b2\u2082 satisfying property (b), but the natural language states that BOTH \u03b2\u2081 and \u03b2\u2082 should satisfy property (b). The Lean version is missing the condition that \u03b2\u2081 also satisfies def_2', 'The natural language explicitly states \u03b2\u2081 \u2260 \u03b2\u2082 as a condition, but this is completely missing from the Lean formalization. While \u03b2\u2081 < \u03b2\u2082 implies they are distinct, the explicit distinctness condition should be present', 'The Lean formalization correctly captures the without-loss-of-generality assumption that \u03b2\u2081 < \u03b2\u2082']"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "Then, by taking $\\epsilon=\\beta_2-\\beta_1$, we see that there is an $x_0$ in $S$ such that\n$$\nx_0>\\beta_2-(\\beta_2-\\beta_1)=\\beta_1,\n$$", "statement": "We assume:\n\u2022 There exist two distinct real numbers, \u03b2\u2081 and \u03b2\u2082, satisfying properties (a) and (b), with \u03b2\u2081 < \u03b2\u2082 [def_3]\nTherefore, we conclude:\n\u2022 There exists an element x\u2080 in S such that x\u2080 > \u03b2\u2081 [l4].", "dependencies": ["def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081)\n  (def_2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5)\n  (def_3 : \u03b2\u2081 < \u03b2\u2082) :\n  \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081)\n  (def_2 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5)\n  (def_3 : \u03b2\u2081 < \u03b2\u2082) :\n  \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 := by\n  have h : \u03b2\u2082 - \u03b2\u2081 > 0 := by linarith\n  obtain \u27e8x\u2080, hx\u2080\u27e9 := def_2 (\u03b2\u2082 - \u03b2\u2081) h\n  obtain \u27e8hxS, hx\u27e9 := hx\u2080\n  use x\u2080, hxS\n  linarith [def_1 x\u2080 hxS]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The declaration of \u03b2\u2081 and \u03b2\u2082 as real numbers with \u03b2\u2081 < \u03b2\u2082 is correctly captured in the Lean formalization.", "The conclusion about existence of x\u2080 in S with x\u2080 > \u03b2\u2081 is perfectly translated to Lean syntax.", "The implicit properties (a) and (b) referenced in natural language are appropriately formalized as def_1 and def_2 in Lean.", "The set S is properly declared and used consistently in both versions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "so  $\\beta_1$ cannot have property \\part{a}.", "statement": "We assume:\n\u2022 There exists an element x\u2080 in S such that x\u2080 > \u03b2\u2081 [l4]\n\u2022 Property (a) for \u03b2\u2081 states that for all x in S, x \u2264 \u03b2\u2081 [def_1]\nTherefore, we conclude:\n\u2022 The statement 'there exists x\u2080 in S such that x\u2080 > \u03b2\u2081' contradicts property (a) for \u03b2\u2081, so \u03b2\u2081 cannot have property (a) [l5].", "dependencies": ["l4", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (S : Set \u211d) (\u03b2\u2081 : \u211d)\n  (l4 : \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081) :\n  False := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (S : Set \u211d) (\u03b2\u2081 : \u211d)\n  (l4 : \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081) :\n  False := by\n  obtain \u27e8x\u2080, hx\u2080, h\u27e9 := l4\n  have := def_1 x\u2080 hx\u2080\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumptions and premises are captured exactly in the Lean formalization with the same logical content and appropriate labels.", "The contradiction conclusion is properly represented as 'False' in Lean, which is the standard formal logic equivalent of showing a contradiction.", "All mathematical objects (real numbers, sets, inequalities) are correctly formalized with appropriate Lean types and operators.", "The proof structure correctly sets up the same logical contradiction that the natural language describes."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Therefore, there cannot be more than one real number that satisfies both \\part{a} and \\part{b}.", "statement": "We assume:\n\u2022 The assumption of two distinct numbers \u03b2\u2081<\u03b2\u2082 satisfying properties (a) and (b) [def_3] leads to the conclusion that \u03b2\u2081 cannot satisfy property (a) [l5], a contradiction.\nTherefore, we conclude:\n\u2022 There is at most one real number that satisfies both properties (a) and (b) [l6].", "dependencies": ["def_3", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081)\n  (def_3 : \u03b2\u2081 < \u03b2\u2082)\n  (l5 : (\u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 False) :\n  \u2203! (\u03b2 : \u211d), (\u2200 x \u2208 S, x \u2264 \u03b2) \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081)\n  (def_3 : \u03b2\u2081 < \u03b2\u2082)\n  (l5 : (\u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 False) :\n  \u2203! (\u03b2 : \u211d), (\u2200 x \u2208 S, x \u2264 \u03b2) \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\n  refine \u27e8\u03b2\u2081, \u27e8def_1, fun \u03b5 h\u03b5 => ?_\u27e9, fun y hy => ?_\u27e9\n  \u00b7 by_contra h\n    push_neg at h\n    have h\u03b2 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081 - \u03b5 := h\n    have h\u03b5\u03b2 := sub_lt_self \u03b2\u2081 h\u03b5\n    exact l5 (Exists.intro \u03b2\u2082 \u27e8by linarith, by linarith\u27e9) h\u03b2\n  \u00b7 obtain \u27e8h_le, h_ub\u27e9 := hy\n    by_cases h : y = \u03b2\u2081\n    \u00b7 exact h\n    \u00b7 by_cases h_lt : y < \u03b2\u2081\n      \u00b7 have : \u2203 x\u2080 \u2208 S, x\u2080 > y - (\u03b2\u2081 - y) := h_ub (\u03b2\u2081 - y) (by linarith)\n        obtain \u27e8x\u2080, hx\u2080, hx\u2080'\u27e9 := this\n        have := h_le x\u2080 hx\u2080\n        linarith\n      \u00b7 push_neg at h_lt\n        have : \u2200 x \u2208 S, x \u2264 \u03b2\u2081 := by\n          intro x hx\n          exact le_trans (h_le x hx) (le_of_lt h_lt)\n        exact (l5 \u27e8y, by linarith, h_lt\u27e9 this).elim", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 58, "endLine": 16, "endColumn": 60, "data": "application type mismatch\n  l5 (Exists.intro \u03b2\u2082 \u27e8?m.1838, ?m.1839\u27e9) h\u03b2\nargument\n  h\u03b2\nhas type\n  \u2200 x \u2208 S, x \u2264 \u03b2\u2081 - \u03b5 : Prop\nbut is expected to have type\n  \u2200 x \u2208 S, x \u2264 \u03b2\u2081 : Prop"}, {"line": 16, "column": 34, "endLine": 16, "endColumn": 42, "data": "linarith failed to find a contradiction\nS : Set \u211d\n\u03b2\u2081 \u03b2\u2082 : \u211d\ndef_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081\ndef_3 : \u03b2\u2081 < \u03b2\u2082\nl5 : (\u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 False\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh : \u2200 x\u2080 \u2208 S, x\u2080 \u2264 \u03b2\u2081 - \u03b5\nh\u03b2 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081 - \u03b5\nh\u03b5\u03b2 : \u03b2\u2081 - \u03b5 < \u03b2\u2081\n\u22a2 False failed"}, {"line": 24, "column": 8, "endLine": 24, "endColumn": 16, "data": "linarith failed to find a contradiction\ncase pos.intro.intro.h1.h\nS : Set \u211d\n\u03b2\u2081 \u03b2\u2082 : \u211d\ndef_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081\ndef_3 : \u03b2\u2081 < \u03b2\u2082\nl5 : (\u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 False\ny : \u211d\nh_le : \u2200 x \u2208 S, x \u2264 y\nh_ub : \u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > y - \u03b5\nh : \u00acy = \u03b2\u2081\nh_lt : y < \u03b2\u2081\nx\u2080 : \u211d\nhx\u2080 : x\u2080 \u2208 S\nhx\u2080' : x\u2080 > y - (\u03b2\u2081 - y)\nthis : x\u2080 \u2264 y\na\u271d : y < \u03b2\u2081\n\u22a2 False failed"}, {"line": 28, "column": 47, "endLine": 28, "endColumn": 51, "data": "application type mismatch\n  le_of_lt h_lt\nargument\n  h_lt\nhas type\n  \u03b2\u2081 \u2264 y : Prop\nbut is expected to have type\n  y < \u03b2\u2081 : Prop"}, {"line": 29, "column": 35, "endLine": 29, "endColumn": 39, "data": "application type mismatch\n  \u27e8?m.4573, h_lt\u27e9\nargument\n  h_lt\nhas type\n  \u03b2\u2081 \u2264 y : Prop\nbut is expected to have type\n  y > \u03b2\u2081 : Prop"}, {"line": 29, "column": 25, "endLine": 29, "endColumn": 33, "data": "linarith failed to find a contradiction\nS : Set \u211d\n\u03b2\u2081 \u03b2\u2082 : \u211d\ndef_1 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081\ndef_3 : \u03b2\u2081 < \u03b2\u2082\nl5 : (\u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 False\ny : \u211d\nh_le : \u2200 x \u2208 S, x \u2264 y\nh_ub : \u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > y - \u03b5\nh : \u00acy = \u03b2\u2081\nh_lt : \u03b2\u2081 \u2264 y\nthis : \u2200 x \u2208 S, x \u2264 \u03b2\u2081\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the contradiction structure, though the specific formulation of l5 is an interpretation of the natural language description rather than an exact translation.", "The properties (a) and (b) are reasonably interpreted in the Lean code as upper bound and supremum-like properties, which aligns with the mathematical context.", "The natural language states 'at most one' while the Lean proves 'exactly one' (\u2203!). This is a stronger conclusion than what's stated in the natural language.", "The overall logical structure of assumption leading to contradiction leading to uniqueness conclusion is preserved in the Lean formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the contradiction structure, though the specific formulation of l5 is an interpretation of the natural language description rather than an exact translation.', 'The properties (a) and (b) are reasonably interpreted in the Lean code as upper bound and supremum-like properties, which aligns with the mathematical context.', \"The natural language states 'at most one' while the Lean proves 'exactly one' (\u2203!). This is a stronger conclusion than what's stated in the natural language.\", 'The overall logical structure of assumption leading to contradiction leading to uniqueness conclusion is preserved in the Lean formalization.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, there cannot be more than one real number that satisfies both \\part{a} and \\part{b}.", "statement": "We assume:\n\u2022 sup S is a real number that possesses properties (a) and (b) [l3]\n\u2022 There is at most one real number that satisfies both properties (a) and (b) [l6]\nTherefore, we conclude:\n\u2022 sup S is the unique real number that satisfies properties (a) and (b) [ts_1].", "dependencies": ["l3", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (l3 : (\u2200 x \u2208 S, x \u2264 \u03b2) \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5))\n  (l6 : \u2203! (\u03b2' : \u211d), (\u2200 x \u2208 S, x \u2264 \u03b2') \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2' - \u03b5)) :\n  \u2203! (\u03b2' : \u211d), (\u2200 x \u2208 S, x \u2264 \u03b2') \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2' - \u03b5) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (l3 : (\u2200 x \u2208 S, x \u2264 \u03b2) \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5))\n  (l6 : \u2203! (\u03b2' : \u211d), (\u2200 x \u2208 S, x \u2264 \u03b2') \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2' - \u03b5)) :\n  \u2203! (\u03b2' : \u211d), (\u2200 x \u2208 S, x \u2264 \u03b2') \u2227 (\u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2' - \u03b5) := by\n  exact l6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The premise l3 correctly captures that \u03b2 (representing sup S) satisfies both properties: being an upper bound and having the least upper bound property. The formalization accurately represents properties (a) and (b).", "The premise l6 states there exists a unique real number with the properties, but the natural language says 'at most one'. The difference between 'exactly one exists' (\u2203!) and 'at most one exists' is significant - the latter allows for the possibility that no such number exists.", "The conclusion ts_1 correctly formalizes the statement that there is a unique real number satisfying both properties (a) and (b).", "The logical structure is fundamentally flawed. The natural language presents a deductive argument where we conclude uniqueness from the combination of existence (l3) and at-most-one-ness (l6). However, the Lean formalization makes the conclusion identical to one of the premises (l6), creating a trivial tautology rather than a meaningful deduction."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The premise l3 correctly captures that \u03b2 (representing sup S) satisfies both properties: being an upper bound and having the least upper bound property. The formalization accurately represents properties (a) and (b).', \"The premise l6 states there exists a unique real number with the properties, but the natural language says 'at most one'. The difference between 'exactly one exists' (\u2203!) and 'at most one exists' is significant - the latter allows for the possibility that no such number exists.\", 'The conclusion ts_1 correctly formalizes the statement that there is a unique real number satisfying both properties (a) and (b).', 'The logical structure is fundamentally flawed. The natural language presents a deductive argument where we conclude uniqueness from the combination of existence (l3) and at-most-one-ness (l6). However, the Lean formalization makes the conclusion identical to one of the premises (l6), creating a trivial tautology rather than a meaningful deduction.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    