
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $f$ be defined on a closed interval $[a,b]$ containing
$\overline{x}.$ Then $f$ is continuous at $\overline{x}$
$($from the right if $\overline{x}=a,$ from the left if
$\overline{x}=b$$)$ if and only if
\begin{equation}\label{eq:4.2.6}
\lim_{n	o\infty} f(x_n)=f(\overline{x})
\end{equation}
whenever $\{x_n\}$ is a sequence of points in $[a,b]$ such that
\begin{equation}\label{eq:4.2.7}
\lim_{n	o\infty} x_n=\overline{x}.
\end{equation}

Proof: Assume that $a<\overline{x}<b$; only minor changes in the proof
are needed if $\overline{x}=a$ or $\overline{x}=b$. First, suppose that
$f$ is continuous at $\overline{x}$ and $\{x_n\}$ is a sequence of
points in $[a,b]$ satisfying \eqref{eq:4.2.7}. If $\epsilon>0$, there is a
$\delta> 0$ such that
\begin{equation} \label{eq:4.2.8}
|f(x)-f(\overline{x})|<\epsilon\mbox{\quad if\quad} |x-\overline{x}|
<\delta.
\end{equation}
From \eqref{eq:4.2.7}, there is an integer $N$ such that
$|x_n-\overline{x}|<\delta$
 if $n\ge N$. This and \eqref{eq:4.2.8} imply that
$|f(x_n)-f(\overline{x})|<\epsilon$ if $n\ge N$. This implies
\eqref{eq:4.2.6}, which shows that the stated condition is necessary.
For sufficiency, suppose that $f$ is discontinuous at $\overline{x}$.
Then there is an $\epsilon_0>0$ such that, for each positive integer
$n$, there is a point $x_n$ that satisfies the inequality
$$
|x_n-\overline{x}|<\frac{1}{ n}
$$

ewpage

oindent
while
$$
|f(x_n)-f(\overline{x})|\ge\epsilon_0.
$$
The sequence $\{x_n\}$ therefore satisfies \eqref{eq:4.2.7}, but not
\eqref{eq:4.2.6}. Hence,  the stated condition cannot hold if $f$ is
discontinuous at $\overline{x}$. This proves sufficiency.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f$ be defined on a closed interval $[a,b]$ containing $\\overline{x}.$", "statement": "Premise:\n\u2022 f is a function defined on a closed interval $[a,b]$ and $\\overline{x} \\in [a,b]$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (f : \u211d \u2192 \u211d)\n  (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states f is defined on [a,b], but Lean declares f as a function from all reals to reals (\u211d \u2192 \u211d). While this is more general and doesn't contradict the natural language, it doesn't capture the specific domain restriction to [a,b].", "The Lean condition tc_1 perfectly captures that x_bar \u2208 [a,b] using the mathematical definition a \u2264 x_bar \u2227 x_bar \u2264 b.", "The Lean introduces an additional condition tc_2 about neighborhoods that is not mentioned in the natural language at all. This adds a topological constraint that wasn't present in the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states f is defined on [a,b], but Lean declares f as a function from all reals to reals (\u211d \u2192 \u211d). While this is more general and doesn't contradict the natural language, it doesn't capture the specific domain restriction to [a,b].\", 'The Lean condition tc_1 perfectly captures that x_bar \u2208 [a,b] using the mathematical definition a \u2264 x_bar \u2227 x_bar \u2264 b.', \"The Lean introduces an additional condition tc_2 about neighborhoods that is not mentioned in the natural language at all. This adds a topological constraint that wasn't present in the original statement.\"]"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "suppose that $f$ is continuous at $\\overline{x}$", "statement": "Definition:\n\u2022 Assume f is continuous at $\\overline{x}$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (f : \u211d \u2192 \u211d)\n  (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (def_1 : ContinuousAt f x_bar)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the main condition that f is continuous at x_bar. The additional variables and constraints (a, b, and the condition that x_bar is between them) are extra details not mentioned in the natural language, but they don't contradict the statement and are logically consistent additions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "and $\\{x_n\\}$ is a sequence of points in $[a,b]$ satisfying \\eqref{eq:4.2.7}.", "statement": "Definition:\n\u2022 Assume $\\{x_n\\}$ is a sequence of points in $[a,b]$ such that $\\lim_{n\\to\\infty} x_n=\\overline{x}$ [def_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (f : \u211d \u2192 \u211d)\n  (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n  (x : \u2115 \u2192 \u211d)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states that the sequence {x_n} is in [a,b], meaning each term x_n \u2208 [a,b]. However, the Lean formalization only declares x : \u2115 \u2192 \u211d without constraining the sequence values to be in [a,b]. The Lean code has tc_1 and tc_2 which constrain the limit point x_bar to be in [a,b] and establish neighborhood properties, but there's no constraint that the sequence terms themselves lie in [a,b].", "The Lean formalization perfectly captures the limit condition using Filter.Tendsto x Filter.atTop (nhds x_bar), which is the standard mathematical formalization of lim_{n\u2192\u221e} x_n = x\u0304.", "The Lean code correctly establishes this as def_2, matching the natural language reference to [def_2]."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states that the sequence {x_n} is in [a,b], meaning each term x_n \u2208 [a,b]. However, the Lean formalization only declares x : \u2115 \u2192 \u211d without constraining the sequence values to be in [a,b]. The Lean code has tc_1 and tc_2 which constrain the limit point x_bar to be in [a,b] and establish neighborhood properties, but there's no constraint that the sequence terms themselves lie in [a,b].\", 'The Lean formalization perfectly captures the limit condition using Filter.Tendsto x Filter.atTop (nhds x_bar), which is the standard mathematical formalization of lim_{n\u2192\u221e} x_n = x\u0304.', 'The Lean code correctly establishes this as def_2, matching the natural language reference to [def_2].']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If $\\epsilon>0$, there is a $\\delta> 0$ such that\n$|f(x)-f(\\overline{x})|<\\epsilon\\mbox{\\quad if\\quad} |x-\\overline{x}| <\\delta.$", "statement": "We assume:\n\u2022 f is a function defined on a closed interval $[a,b]$ and $\\overline{x} \\in [a,b]$ [tc_1]\n\u2022 f is continuous at $\\overline{x}$ [def_1]\nTherefore, we conclude:\n\u2022 For any $\\epsilon > 0$, there exists a $\\delta > 0$ such that for any $x \\in [a,b]$, if $|x - \\overline{x}| < \\delta$, then $|f(x) - f(\\overline{x})| < \\epsilon$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (def_1 : ContinuousAt f x_bar) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x \u2208 Set.Icc a b, |x - x_bar| < \u03b4 \u2192 |f x - f x_bar| < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (def_1 : ContinuousAt f x_bar) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x \u2208 Set.Icc a b, |x - x_bar| < \u03b4 \u2192 |f x - f x_bar| < \u03b5 := by\n  intro \u03b5 h\u03b5\n  rcases Metric.continuousAt_iff.mp def_1 \u03b5 h\u03b5 with \u27e8\u03b4, h\u03b4_pos, h\u03b4\u27e9\n  refine \u27e8\u03b4, h\u03b4_pos, fun x hx hx' => ?_\u27e9\n  apply h\u03b4\n  exact hx'", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies f is defined on [a,b] but Lean defines f : \u211d \u2192 \u211d (on all reals). However, this is a common and acceptable formalization practice that doesn't affect the mathematical meaning since the domain restriction is properly handled where needed.", "The continuity assumption is perfectly captured using Lean's ContinuousAt predicate.", "The epsilon-delta conclusion is excellently formalized with correct quantifier structure, interval notation (Set.Icc a b), and logical implications."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From \\eqref{eq:4.2.7}, there is an integer $N$ such that\n$|x_n-\\overline{x}|<\\delta$ if $n\\ge N$.", "statement": "We assume:\n\u2022 $\\{x_n\\}$ is a sequence of points in $[a,b]$ such that $\\lim_{n\\to\\infty} x_n=\\overline{x}$ [def_2]\n\u2022 A positive $\\delta$ is given (from the definition of continuity of f) [l1]\nTherefore, we conclude:\n\u2022 For the given $\\delta > 0$, there exists an integer $N$ such that if $n \\ge N$, then $|x_n - \\overline{x}| < \\delta$ [l2].", "dependencies": ["def_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n  (x : \u2115 \u2192 \u211d)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x_1 \u2208 Set.Icc a b, |x_1 - x_bar| < \u03b4 \u2192 |f x_1 - f x_bar| < \u03b5) :\n  \u2200 \u03b4 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |x n - x_bar| < \u03b4 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n  (x : \u2115 \u2192 \u211d)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x_1 \u2208 Set.Icc a b, |x_1 - x_bar| < \u03b4 \u2192 |f x_1 - f x_bar| < \u03b5) :\n  \u2200 \u03b4 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |x n - x_bar| < \u03b4 := by\n  intro \u03b4 h\u03b4\n  have h := Metric.tendsto_atTop.1 def_2 \u03b4 h\u03b4\n  exact h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The sequence convergence is correctly formalized, but the constraint that the sequence points lie in [a,b] is missing from the Lean formalization.", "The Lean formalization includes the full continuity definition of f, while the natural language only mentions 'a positive \u03b4 is given'. The continuity context appears to be explanatory rather than a formal assumption.", "The conclusion is perfectly captured - the quantification structure and the inequality condition match exactly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The sequence convergence is correctly formalized, but the constraint that the sequence points lie in [a,b] is missing from the Lean formalization.', \"The Lean formalization includes the full continuity definition of f, while the natural language only mentions 'a positive \u03b4 is given'. The continuity context appears to be explanatory rather than a formal assumption.\", 'The conclusion is perfectly captured - the quantification structure and the inequality condition match exactly.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "This and \\eqref{eq:4.2.8} imply that\n$|f(x_n)-f(\\overline{x})|<\\epsilon$ if $n\\ge N$.", "statement": "We assume:\n\u2022 For any $\\epsilon > 0$, there exists a $\\delta > 0$ such that for any $x \\in [a,b]$, if $|x - \\overline{x}| < \\delta$, then $|f(x) - f(\\overline{x})| < \\epsilon$ [l1]\n\u2022 For this $\\delta$, there exists an integer $N$ such that if $n \\ge N$, then $|x_n - \\overline{x}| < \\delta$ [l2]\nTherefore, we conclude:\n\u2022 For any $\\epsilon > 0$, there exists an integer $N$ such that if $n \\ge N$, then $|f(x_n) - f(\\overline{x})| < \\epsilon$ [l3].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n  (x : \u2115 \u2192 \u211d)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x_1 \u2208 Set.Icc a b, |x_1 - x_bar| < \u03b4 \u2192 |f x_1 - f x_bar| < \u03b5)\n  (l2 : \u2200 \u03b4 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |x n - x_bar| < \u03b4) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |f (x n) - f x_bar| < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n  (x : \u2115 \u2192 \u211d)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x_1 \u2208 Set.Icc a b, |x_1 - x_bar| < \u03b4 \u2192 |f x_1 - f x_bar| < \u03b5)\n  (l2 : \u2200 \u03b4 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |x n - x_bar| < \u03b4) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |f (x n) - f x_bar| < \u03b5 := by\n  intro \u03b5 h\u03b5\n  obtain \u27e8\u03b4, h\u03b4, h\u27e9 := l1 \u03b5 h\u03b5\n  obtain \u27e8N, hN\u27e9 := l2 \u03b4 h\u03b4\n  use N\n  intro n hn\n  have hx : x n \u2208 Set.Icc a b := by\n    have hmem : \u2200\u1da0 n in atTop, x n \u2208 Set.Icc a b := by\n      rw [Filter.tendsto_def] at def_2\n      exact def_2 (Set.Icc a b) tc_2\n    exact Filter.Eventually.andThen hmem (by simp) n\n  exact h (x n) hx (hN n hn)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 23, "column": 10, "endLine": 23, "endColumn": 52, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Filter.Eventually\nhas type\n  (?m.2546 \u2192 Prop) \u2192 Filter ?m.2546 \u2192 Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Function and variable declarations correctly capture all mathematical objects mentioned in the natural language", "Domain constraint properly formalizes the implicit assumption that x\u0304 \u2208 [a,b]", "Assumption l1 is perfectly translated with correct quantifier structure and interval notation", "Assumption l2 has a minor difference: natural language refers to 'this \u03b4' (specific \u03b4 from l1) while Lean quantifies over all \u03b4 > 0. However, this is a stronger, more standard formulation that captures sequence convergence", "Conclusion l3 perfectly matches the natural language statement in both structure and mathematical meaning", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3 :\n  \u2203 (f : \u211d \u2192 \u211d) (a b x_bar : \u211d) (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b) (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n    (x : \u2115 \u2192 \u211d) (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n    (l1 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x_1 \u2208 Set.Icc a b, |x_1 - x_bar| < \u03b4 \u2192 |f x_1 - f x_bar| < \u03b5)\n    (l2 : \u2200 \u03b4 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |x n - x_bar| < \u03b4),\n    \u2203 \u03b5 > 0, \u2200 N : \u2115, \u2203 n \u2265 N, |f (x n) - f x_bar| \u2265 \u03b5 := by\n  let x_bar := 0\n  let f : \u211d \u2192 \u211d := fun x => if x = x_bar then 0 else 1\n  let a := -1\n  let b := 1\n  have tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b := by norm_num\n  have tc_2 : Set.Icc a b \u2208 nhds x_bar := by\n    apply Icc_mem_nhds <;> norm_num\n  let x : \u2115 \u2192 \u211d := fun n => 1 / (n + 1)\n  have def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar) := by\n    rw [tendsto_nhds]\n    intro \u03b5 h\u03b5\n    use \u23081/\u03b5\u2309\u208a\n    intro n hn\n    simp [x, dist_eq_norm]\n    have : 1 / (n + 1 : \u211d) \u2264 1 / (\u23081/\u03b5\u2309\u208a + 1 : \u211d) := by\n      apply one_div_le_one_div_of_le <;> positivity\n    rw [abs_of_pos (by positivity)]\n    refine lt_of_le_of_lt this ?_\n    refine lt_of_lt_of_le (inv_pos.mpr h\u03b5) (Nat.ceil_lt_add_one (by positivity))\n  have l1 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x_1 \u2208 Set.Icc a b, |x_1 - x_bar| < \u03b4 \u2192 |f x_1 - f x_bar| < \u03b5 := by\n    intro \u03b5 h\u03b5\n    use 1, zero_lt_one\n    intro x_1 _ hx\n    simp [f]\n    split_ifs with h\n    \u00b7 simp [h]; exact h\u03b5\n    \u00b7 simp only [one_ne_zero, not_false_eq_true]\n  have l2 : \u2200 \u03b4 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |x n - x_bar| < \u03b4 := by\n    intro \u03b4 h\u03b4\n    rcases def_2 h\u03b4 with \u27e8N, hN\u27e9\n    exact \u27e8N, fun n hn => hN n hn\u27e9\n  use f, a, b, x_bar, tc_1, tc_2, x, def_2, l1, l2\n  use 1, zero_lt_one\n  intro N\n  use N\n  constructor\n  \u00b7 exact le_refl N\n  \u00b7 simp [f]\n    split_ifs with h\n    \u00b7 exfalso\n      simp [x] at h\n      have : 1 / (N + 1 : \u211d) = 0 := by linarith\n      exact (one_div_ne_zero (Nat.cast_add_one_pos N)).ne this\n    \u00b7 norm_num"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "This implies\n\\eqref{eq:4.2.6}, which shows that the stated condition is necessary.", "statement": "We assume:\n\u2022 f is continuous at $\\overline{x}$ [def_1]\n\u2022 $\\{x_n\\}$ is a sequence of points in $[a,b]$ such that $\\lim_{n\\to\\infty} x_n=\\overline{x}$ [def_2]\n\u2022 For any $\\epsilon > 0$, there exists an integer $N$ such that if $n \\ge N$, then $|f(x_n) - f(\\overline{x})| < \\epsilon$ [l3]\nTherefore, we conclude:\n\u2022 $\\lim_{n\\to\\infty} f(x_n)=f(\\overline{x})$ [ts_1].", "dependencies": ["def_1", "def_2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d) (x : \u2115 \u2192 \u211d)\n  (def_1 : ContinuousAt f x_bar)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l3 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |f (x n) - f x_bar| < \u03b5) :\n  Filter.Tendsto (f \u2218 x) Filter.atTop (nhds (f x_bar)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d) (x : \u2115 \u2192 \u211d)\n  (def_1 : ContinuousAt f x_bar)\n  (def_2 : Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l3 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, |f (x n) - f x_bar| < \u03b5) :\n  Filter.Tendsto (f \u2218 x) Filter.atTop (nhds (f x_bar)) := by\n  rw [Metric.tendsto_atTop]\n  intro \u03b5 h\u03b5\n  obtain \u27e8N, hN\u27e9 := l3 \u03b5 h\u03b5\n  use N\n  intro n hn\n  simp only [Function.comp_apply]\n  exact hN n hn", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.8, "semantic_feedback": ["Function and variable declarations correctly capture the mathematical objects mentioned in the natural language.", "The continuity assumption is perfectly formalized using Lean's ContinuousAt predicate.", "The sequence convergence is correctly formalized, but the constraint that sequence points lie in [a,b] is missing from the Lean formalization.", "The epsilon-delta condition is perfectly translated with exact correspondence to the natural language statement.", "The conclusion correctly formalizes the limit using function composition and filter-based convergence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "def_3": {"id": "def_3", "natural_language": "For sufficiency, suppose that $f$ is discontinuous at $\\overline{x}$.", "statement": "Definition:\n\u2022 Assume f is discontinuous at $\\overline{x}$ [def_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (f : \u211d \u2192 \u211d)\n  (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (tc_2 : Set.Icc a b \u2208 nhds x_bar)\n  (def_3 : \u00ac ContinuousAt f x_bar)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The core condition 'f is discontinuous at x_bar' is perfectly captured by '\u00ac ContinuousAt f x_bar' in Lean. The additional conditions (tc_1, tc_2) and variable declarations in Lean are extra details not mentioned in the natural language, but this is acceptable as they don't contradict the natural language statement and may be part of a larger context."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "Then there is an $\\epsilon_0>0$ such that, for each positive integer\n$n$, there is a point $x_n$ that satisfies the inequality\n$$\n|x_n-\\overline{x}|<\\frac{1}{ n}\n$$\nwhile\n$$\n|f(x_n)-f(\\overline{x})|\\ge\\epsilon_0.\n$$", "statement": "We assume:\n\u2022 f is a function defined on a closed interval $[a,b]$ and $\\overline{x} \\in [a,b]$ [tc_1]\n\u2022 f is discontinuous at $\\overline{x}$ [def_3]\nTherefore, we conclude:\n\u2022 There exists an $\\epsilon_0 > 0$ and a sequence $\\{x_n\\}$ in $[a,b]$ such that for every positive integer n, $|x_n - \\overline{x}| < 1/n$ and $|f(x_n) - f(\\overline{x})| \\ge \\epsilon_0$ [l4].", "dependencies": ["tc_1", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (def_3 : \u00ac ContinuousAt f x_bar) :\n  \u2203 \u03b5\u2080 > 0, \u2203 (x : \u2115 \u2192 \u211d), (\u2200 n, x n \u2208 Set.Icc a b) \u2227 (\u2200 n, |x n - x_bar| < 1 / n) \u2227 (\u2200 n, |f (x n) - f x_bar| \u2265 \u03b5\u2080) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (def_3 : \u00ac ContinuousAt f x_bar) :\n  \u2203 \u03b5\u2080 > 0, \u2203 (x : \u2115 \u2192 \u211d), (\u2200 n, x n \u2208 Set.Icc a b) \u2227 (\u2200 n, |x n - x_bar| < 1 / n) \u2227 (\u2200 n, |f (x n) - f x_bar| \u2265 \u03b5\u2080) := by\n  rw [ContinuousAt] at def_3\n  simp only [tendsto_nhds_iff, not_forall, not_exists, not_lt] at def_3\n  obtain \u27e8\u03b5\u2080, h\u03b5\u2080, h\u27e9 := def_3\n  have h' : \u2200 (n : \u2115), \u2203 y, y \u2208 Set.Icc a b \u2227 |y - x_bar| < 1 / (n + 1) \u2227 \u03b5\u2080 \u2264 |f y - f x_bar| := by\n    intro n\n    have : (0 : \u211d) < 1 / (n + 1) := by positivity\n    have h_nhds : Metric.ball x_bar (1 / (n + 1)) \u2208 \ud835\udcdd x_bar := Metric.ball_mem_nhds x_bar this\n    obtain \u27e8y, hy\u27e9 := h (1 / (n + 1)) this\n    refine \u27e8y, ?_, ?_, ?_\u27e9\n    \u00b7 have h1 : x_bar \u2208 Set.Icc a b := \u27e8tc_1.1, tc_1.2\u27e9\n      refine \u27e8max a (min y b), min_le_of_le_max ?_ (le_min ?_ ?_)\u27e9\n      all_goals { linarith }\n    \u00b7 simp only [Metric.mem_ball, dist_eq] at hy\n      exact hy.1\n    \u00b7 exact hy.2.le\n  choose x hx using h'\n  refine \u27e8\u03b5\u2080, h\u03b5\u2080, x, ?_, ?_, ?_\u27e9\n  \u00b7 intro n\n    exact (hx n).1\n  \u00b7 intro n\n    exact (hx n).2.1\n  \u00b7 intro n\n    exact (hx n).2.2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 13, "endLine": 11, "endColumn": 29, "data": "unknown identifier 'tendsto_nhds_iff'"}, {"line": 11, "column": 2, "endLine": 11, "endColumn": 71, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language states f is defined on [a,b], but Lean defines f as \u211d \u2192 \u211d. While this doesn't affect the logical validity, it's a structural difference from the natural language specification.", "Discontinuity is correctly expressed as \u00ac ContinuousAt f x_bar, which perfectly captures the natural language meaning.", "The existential quantification structure and sequence constraints are correctly formalized with proper set membership notation.", "The distance condition |x n - x_bar| < 1 / n is perfectly translated from the natural language.", "The function value separation condition is correctly formalized with the same inequality structure.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  (f : \u211d \u2192 \u211d) (a b x_bar : \u211d)\n  (tc_1 : a \u2264 x_bar \u2227 x_bar \u2264 b)\n  (def_3 : \u00ac ContinuousAt f x_bar) :\n  \u2200 \u03b5\u2080 > 0, \u2200 (x : \u2115 \u2192 \u211d), (\u2200 n, x n \u2208 Set.Icc a b) \u2192 (\u2200 n, |x n - x_bar| < 1 / n) \u2192 \u2203 n, |f (x n) - f x_bar| < \u03b5\u2080 := by\n  intro \u03b5\u2080 h\u03b5\u2080 x hx\u2081 hx\u2082\n  by_contra h\n  push_neg at h\n  have : ContinuousAt f x_bar := by\n    rw [ContinuousAt, Metric.continuousAt_iff]\n    intro \u03b5 h\u03b5\n    have h_tendsto : Tendsto x atTop (\ud835\udcdd x_bar) := by\n      rw [Metric.tendsto_atTop]\n      intro \u03b4 h\u03b4\n      obtain \u27e8N, hN\u27e9 := exists_nat_gt (1/\u03b4)\n      refine \u27e8N, fun n hn => ?_\u27e9\n      have := hx\u2082 n\n      rw [dist_eq_norm] at this \u22a2\n      simp only [sub_zero] at this \u22a2\n      refine lt_of_lt_of_le this ?_\n      refine inv_le_of_inv_le h\u03b4 ?_\n      exact_mod_cast hn\n    rw [Metric.tendsto_atTop] at h_tendsto\n    specialize h_tendsto \u03b5 h\u03b5\n    obtain \u27e8N, hN\u27e9 := h_tendsto\n    specialize h N\n    specialize hN N (le_refl N)\n    simp only [dist_eq_norm] at hN\n    linarith [hN, h]\n  contradiction"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "The sequence $\\{x_n\\}$ therefore satisfies \\eqref{eq:4.2.7}", "statement": "We assume:\n\u2022 A sequence $\\{x_n\\}$ exists such that for every positive integer n, $|x_n - \\overline{x}| < 1/n$ [l4]\nTherefore, we conclude:\n\u2022 $\\lim_{n\\to\\infty} x_n=\\overline{x}$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (x_bar : \u211d) (x : \u2115 \u2192 \u211d)\n  (l4 : \u2200 n, |x n - x_bar| < 1 / n) :\n  Filter.Tendsto x Filter.atTop (nhds x_bar) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (x_bar : \u211d) (x : \u2115 \u2192 \u211d)\n  (l4 : \u2200 n, |x n - x_bar| < 1 / n) :\n  Filter.Tendsto x Filter.atTop (nhds x_bar) := by\n  rw [Metric.tendsto_atTop]\n  intro \u03b5 h\u03b5\n  let N := Nat.ceil (1 / \u03b5) + 1\n  use N\n  intro n hn\n  have hN : 1 / \u03b5 < N := by\n    rw [\u2190 Nat.cast_add, Nat.cast_one]\n    exact Nat.lt_ceil_add_one (1 / \u03b5)\n  have h : 1 / n \u2264 1 / N := by\n    rw [one_div_le_one_div]\n    \u00b7 exact_mod_cast hn\n    \u00b7 exact_mod_cast Nat.ceil_pos.mpr (div_pos one_pos h\u03b5)\n    \u00b7 exact_mod_cast Nat.ceil_pos.mpr (div_pos one_pos h\u03b5)\n  have h' : 1 / N < \u03b5 := by\n    rw [lt_div_iff h\u03b5, one_mul]\n    exact_mod_cast hN\n  rw [dist_eq]\n  exact lt_of_lt_of_le (l4 n) (le_trans (le_of_lt h) (le_of_lt h'))", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 8, "endLine": 15, "endColumn": 22, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2191?m + \u2191?n\nx_bar : \u211d\nx : \u2115 \u2192 \u211d\nl4 : \u2200 (n : \u2115), |x n - x_bar| < 1 / \u2191n\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nN : \u2115 := \u23081 / \u03b5\u2309\u208a + 1\nn : \u2115\nhn : n \u2265 N\n\u22a2 1 / \u03b5 < \u2191N"}, {"line": 18, "column": 8, "endLine": 18, "endColumn": 26, "data": "ambiguous, possible interpretations \n  _root_.one_div_le_one_div : 0 < ?m.2424 \u2192 0 < ?m.2425 \u2192 (1 / ?m.2424 \u2264 1 / ?m.2425 \u2194 ?m.2425 \u2264 ?m.2424)\n  \n  Nat.one_div_le_one_div : ?m.2435 \u2264 ?m.2436 \u2192 1 / (\u2191?m.2436 + 1) \u2264 1 / (\u2191?m.2435 + 1)"}, {"line": 18, "column": 8, "endLine": 18, "endColumn": 26, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.2476\nx_bar : \u211d\nx : \u2115 \u2192 \u211d\nl4 : \u2200 (n : \u2115), |x n - x_bar| < 1 / \u2191n\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nN : \u2115 := \u23081 / \u03b5\u2309\u208a + 1\nn : \u2115\nhn : n \u2265 N\nhN : 1 / \u03b5 < \u2191N\n\u22a2 1 / n \u2264 1 / N"}, {"line": 23, "column": 8, "endLine": 23, "endColumn": 21, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.3353 < ?m.3354 / \u03b5\nx_bar : \u211d\nx : \u2115 \u2192 \u211d\nl4 : \u2200 (n : \u2115), |x n - x_bar| < 1 / \u2191n\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nN : \u2115 := \u23081 / \u03b5\u2309\u208a + 1\nn : \u2115\nhn : n \u2265 N\nhN : 1 / \u03b5 < \u2191N\nh : 1 / n \u2264 1 / N\n\u22a2 1 / \u2191N < \u03b5"}, {"line": 25, "column": 6, "endLine": 25, "endColumn": 13, "data": "ambiguous, possible interpretations \n  Rat.dist_eq : \u2200 (x y : \u211a), Dist.dist x y = |\u2191x - \u2191y|\n  \n  Nat.dist_eq : \u2200 (x y : \u2115), Dist.dist x y = |\u2191x - \u2191y|\n  \n  Real.dist_eq : \u2200 (x y : \u211d), Dist.dist x y = |x - y|"}, {"line": 25, "column": 6, "endLine": 25, "endColumn": 13, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.3420\ncase h\nx_bar : \u211d\nx : \u2115 \u2192 \u211d\nl4 : \u2200 (n : \u2115), |x n - x_bar| < 1 / \u2191n\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nN : \u2115 := \u23081 / \u03b5\u2309\u208a + 1\nn : \u2115\nhn : n \u2265 N\nhN : 1 / \u03b5 < \u2191N\nh : 1 / n \u2264 1 / N\nh' : 1 / \u2191N < \u03b5\n\u22a2 Dist.dist (x n) x_bar < \u03b5"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise is correctly formalized, but there's a minor difference: the natural language specifies 'positive integer n' while Lean uses 'n : \u2115' which includes 0. However, this doesn't affect the mathematical meaning since the condition at n=0 would be trivially handled.", "The conclusion is perfectly captured using Lean's standard limit notation Filter.Tendsto, which correctly represents the limit statement.", "The logical structure of assumption leading to conclusion is perfectly preserved in the Lean formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (x_bar : \u211d) (x : \u2115 \u2192 \u211d)\n  (l4 : \u2200 n, |x n - x_bar| < 1 / n) :\n  \u00acFilter.Tendsto x Filter.atTop (nhds x_bar) := by\n  intro h\n  have : x = fun _ => x_bar := by\n    ext n\n    have := tendsto_nhds_unique h (tendsto_const_nhds (x := x_bar))\n    rw [\u2190this] at l4\n    have h' : |x n - x_bar| < 1 / n := l4 n\n    have h'' : |x_bar - x_bar| < 1 / n := by simp [l4 n]\n    exact sub_eq_zero.mp (abs_eq_zero.mp (le_antisymm (le_of_lt h') (abs_nonneg _)))\n  have h' : |x_bar - x_bar| < 1 / (1 : \u2115) := by simpa using l4 1\n  simp at h'\n  linarith [h']"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "but not\n\\eqref{eq:4.2.6}.", "statement": "We assume:\n\u2022 There exists an $\\epsilon_0 > 0$ and a sequence $\\{x_n\\}$ such that for every n, $|f(x_n) - f(\\overline{x})| \\ge \\epsilon_0$ [l4]\nTherefore, we conclude:\n\u2022 The sequence $\\{f(x_n)\\}$ does not converge to $f(\\overline{x})$ [l6].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (f : \u211d \u2192 \u211d) (x_bar : \u211d)\n  (l4 : \u2203 \u03b5\u2080 > 0, \u2203 (x : \u2115 \u2192 \u211d), (\u2200 n, |f (x n) - f x_bar| \u2265 \u03b5\u2080)) :\n  \u00ac (Filter.Tendsto (fun n => f (x n)) Filter.atTop (Filter.pure (f x_bar))) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 53, "endLine": 8, "endColumn": 74, "data": "unknown constant 'Filter.pure'"}, {"line": 8, "column": 33, "endLine": 8, "endColumn": 36, "data": "function expected at\n  x\nterm has type\n  ?m.257"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (f : \u211d \u2192 \u211d) (x_bar : \u211d)\n  (l4 : \u2203 \u03b5\u2080 > 0, \u2203 (x : \u2115 \u2192 \u211d), \u2200 n, |f (x n) - f x_bar| \u2265 \u03b5\u2080) :\n  \u00ac (Filter.Tendsto (fun n => f (x n)) Filter.atTop (nhds (f x_bar))) := by\n  rcases l4 with \u27e8\u03b5\u2080, h\u03b5\u2080, x, hx\u27e9\n  intro h\n  rcases (Metric.tendsto_atTop_nhds.1 h \u03b5\u2080 h\u03b5\u2080) with \u27e8N, hN\u27e9\n  specialize hN N (le_refl N)\n  specialize hx N\n  simp only [dist_eq_norm] at hN\n  linarith [hx, hN]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 33, "endLine": 8, "endColumn": 36, "data": "function expected at\n  x\nterm has type\n  ?m.257"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Hence,  the stated condition cannot hold if $f$ is\ndiscontinuous at $\\overline{x}$. This proves sufficiency.", "statement": "We assume:\n\u2022 The assumption that f is discontinuous at $\\overline{x}$ [def_3] leads to the construction of a sequence $\\{x_n\\}$\n\u2022 This sequence satisfies $\\lim_{n\\to\\infty} x_n=\\overline{x}$ [l5]\n\u2022 This same sequence also satisfies that $\\{f(x_n)\\}$ does not converge to $f(\\overline{x})$ [l6]\nTherefore, we conclude:\n\u2022 If f is discontinuous at $\\overline{x}$, then there exists a sequence $\\{x_n\\}$ converging to $\\overline{x}$ for which $\\{f(x_n)\\}$ does not converge to $f(\\overline{x})$. By contraposition, if for every sequence $\\{x_n\\}$ converging to $\\overline{x}$, $\\{f(x_n)\\}$ converges to $f(\\overline{x})$, then $f$ must be continuous at $\\overline{x}$. [ts_2].", "dependencies": ["def_3", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (f : \u211d \u2192 \u211d) (x_bar : \u211d)\n  (def_3 : \u00ac ContinuousAt f x_bar)\n  (l5 : \u2200 (x : \u2115 \u2192 \u211d), (\u2200 n, |x n - x_bar| < 1 / (n + 1)) \u2192 Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l6 : \u2200 (x : \u2115 \u2192 \u211d) (epsilon0 : \u211d), (epsilon0 > 0 \u2227 (\u2200 n, |f (x n) - f x_bar| \u2265 epsilon0)) \u2192 \u00ac Filter.Tendsto (fun n => f (x n)) Filter.atTop (nhds (f x_bar))) :\n  (\u00ac ContinuousAt f x_bar) \u2192 (\u2203 (x_n : \u2115 \u2192 \u211d), (Filter.Tendsto x_n Filter.atTop (nhds x_bar)) \u2227 (\u00ac Filter.Tendsto (fun n => f (x_n n)) Filter.atTop (nhds (f x_bar)))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (f : \u211d \u2192 \u211d) (x_bar : \u211d)\n  (def_3 : \u00ac ContinuousAt f x_bar)\n  (l5 : \u2200 (x : \u2115 \u2192 \u211d), (\u2200 n, |x n - x_bar| < 1 / (n + 1)) \u2192 Filter.Tendsto x Filter.atTop (nhds x_bar))\n  (l6 : \u2200 (x : \u2115 \u2192 \u211d) (epsilon0 : \u211d), (epsilon0 > 0 \u2227 (\u2200 n, |f (x n) - f x_bar| \u2265 epsilon0)) \u2192 \u00ac Filter.Tendsto (fun n => f (x n)) Filter.atTop (nhds (f x_bar))) :\n  (\u00ac ContinuousAt f x_bar) \u2192 (\u2203 (x_n : \u2115 \u2192 \u211d), (Filter.Tendsto x_n Filter.atTop (nhds x_bar)) \u2227 (\u00ac Filter.Tendsto (fun n => f (x_n n)) Filter.atTop (nhds (f x_bar)))) := by\n  intro h\n  rw [ContinuousAt, tendsto_nhds_nhds] at h\n  push_neg at h\n  rcases h with \u27e8\u03b5, h\u03b5, h\u27e9\n  have : \u2200 (n : \u2115), \u2203 (x : \u211d), |x - x_bar| < 1 / (n + 1) \u2227 |f x - f x_bar| \u2265 \u03b5 := by\n    intro n\n    specialize h (1 / (n + 1)) (by positivity)\n    rcases h with \u27e8x, hx\u2081, hx\u2082\u27e9\n    exact \u27e8x, hx\u2081, hx\u2082\u27e9\n  choose x_n hx using this\n  use x_n\n  constructor\n  \u00b7 apply l5 x_n\n    intro n\n    exact (hx n).1\n  \u00b7 apply l6 x_n \u03b5\n    constructor\n    \u00b7 exact h\u03b5\n    \u00b7 intro n\n      exact (hx n).2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 20, "endLine": 12, "endColumn": 37, "data": "unknown identifier 'tendsto_nhds_nhds'"}, {"line": 12, "column": 20, "endLine": 12, "endColumn": 37, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.2502\nf : \u211d \u2192 \u211d\nx_bar : \u211d\ndef_3 : \u00acContinuousAt f x_bar\nl5 : \u2200 (x : \u2115 \u2192 \u211d), (\u2200 (n : \u2115), |x n - x_bar| < 1 / (\u2191n + 1)) \u2192 Tendsto x atTop (\ud835\udcdd x_bar)\nl6 :\n  \u2200 (x : \u2115 \u2192 \u211d) (epsilon0 : \u211d),\n    (epsilon0 > 0 \u2227 \u2200 (n : \u2115), |f (x n) - f x_bar| \u2265 epsilon0) \u2192 \u00acTendsto (fun n => f (x n)) atTop (\ud835\udcdd (f x_bar))\nh : \u00acTendsto f (\ud835\udcdd x_bar) (\ud835\udcdd (f x_bar))\n\u22a2 \u2203 x_n, Tendsto x_n atTop (\ud835\udcdd x_bar) \u2227 \u00acTendsto (fun n => f (x_n n)) atTop (\ud835\udcdd (f x_bar))"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The theorem has a redundant logical structure where discontinuity is both assumed as a hypothesis (def_3) and used as the antecedent of the conclusion. The natural language describes a direct implication, not this nested structure.", "The assumption def_3 correctly captures that f is discontinuous at x_bar using the appropriate Lean notation.", "The natural language refers to 'the sequence' (a specific sequence from the discontinuity assumption), but the Lean formalization makes this a universal statement about all sequences with a particular convergence rate. This fundamentally changes the logical meaning.", "The Lean formalization requires a much stronger condition (existence of epsilon with uniform lower bound) than the natural language requirement of simple non-convergence. Non-convergence can occur in many ways beyond this specific epsilon-based condition.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The theorem has a redundant logical structure where discontinuity is both assumed as a hypothesis (def_3) and used as the antecedent of the conclusion. The natural language describes a direct implication, not this nested structure.', 'The assumption def_3 correctly captures that f is discontinuous at x_bar using the appropriate Lean notation.', \"The natural language refers to 'the sequence' (a specific sequence from the discontinuity assumption), but the Lean formalization makes this a universal statement about all sequences with a particular convergence rate. This fundamentally changes the logical meaning.\", 'The Lean formalization requires a much stronger condition (existence of epsilon with uniform lower bound) than the natural language requirement of simple non-convergence. Non-convergence can occur in many ways beyond this specific epsilon-based condition.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    