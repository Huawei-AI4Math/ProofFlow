
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If a nonempty set S of real numbers is bounded above, then sup S is the unique real number β such that (a) x ≤ β for all x in S; (b) if ε > 0, there is an x₀ in S such that x₀ > β − ε.

Proof: We first show that β = sup S has properties (a) and (b). Since β is an upper bound of S, it satisfies (a). Since any real number a < β can be written as β − ε with ε > 0, (b) just says no number less than β is an upper bound. Now, suppose β₁ < β₂ and β₂ has property (b); taking ε = β₂ − β₁, there’s x₀ in S with x₀ > β₁, so β₁ fails (a). Thus, uniqueness holds.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "a nonempty set S of real numbers", "statement": "Premise:\n\u2022 S is a nonempty set of real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d)\n(tc_1 : S.Nonempty)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. S : Set \u211d establishes S as a set of real numbers, and tc_1 : S.Nonempty establishes that S is nonempty. Both components of 'S is a nonempty set of real numbers' are correctly formalized, and like the natural language, no conclusions are derived."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "is bounded above", "statement": "Premise:\n\u2022 S is a nonempty set of real numbers [tc_1]\n\u2022 S is bounded above [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d)\n(tc_1 : S.Nonempty)\n(tc_2 : BddAbove S)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that S is a nonempty set of real numbers through the type declaration (S : Set \u211d) combined with the condition (tc_1 : S.Nonempty). The separation into type and property is a standard and correct formalization approach.", "The Lean condition (tc_2 : BddAbove S) perfectly matches the natural language condition 'S is bounded above'. BddAbove is the standard Lean/Mathlib formalization of the mathematical concept of being bounded above."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "\u03b2 = sup S", "statement": "Definition:\n\u2022 Given a nonempty set S of real numbers that is bounded above [tc_1, tc_2], its supremum, sup S, exists and is defined as the least upper bound of S. We let \u03b2 = sup S [def_1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d)\n(tc_1 : S.Nonempty)\n(tc_2 : BddAbove S)\n(def_1 : \u2203 \u03b2, IsLUB S \u03b2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that S is a nonempty set of real numbers through (S : Set \u211d) and (tc_1 : S.Nonempty)", "The Lean formalization correctly captures that S is bounded above through (tc_2 : BddAbove S)", "The natural language states that sup S exists as a conclusion, but the Lean formalization treats the existence of a least upper bound as a definition/assumption (def_1) rather than a conclusion that follows from the conditions", "The natural language concludes that sup S is defined as the least upper bound, but the Lean formalization doesn't explicitly define sup S - it only asserts the existence of some \u03b2 that is a least upper bound", "The natural language concludes \u03b2 = sup S, but the Lean formalization doesn't establish this equality - it only states that there exists some \u03b2 that is a least upper bound, without connecting it to sup S"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that S is a nonempty set of real numbers through (S : Set \u211d) and (tc_1 : S.Nonempty)', 'The Lean formalization correctly captures that S is bounded above through (tc_2 : BddAbove S)', 'The natural language states that sup S exists as a conclusion, but the Lean formalization treats the existence of a least upper bound as a definition/assumption (def_1) rather than a conclusion that follows from the conditions', \"The natural language concludes that sup S is defined as the least upper bound, but the Lean formalization doesn't explicitly define sup S - it only asserts the existence of some \u03b2 that is a least upper bound\", \"The natural language concludes \u03b2 = sup S, but the Lean formalization doesn't establish this equality - it only states that there exists some \u03b2 that is a least upper bound, without connecting it to sup S\"]"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "(a) x \u2264 \u03b2 for all x in S", "statement": "Definition:\n\u2022 Property (a) for a real number \u03b2 with respect to a set S is: \u2200 x \u2208 S, x \u2264 \u03b2 [def_2]. This means \u03b2 is an upper bound of S.", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d) (\u03b2 : \u211d)\n(def_2 : \u2200 x \u2208 S, x \u2264 \u03b2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration (\u03b2 : \u211d) perfectly matches the condition that \u03b2 is a real number", "The Lean declaration (S : Set \u211d) matches the condition that S is a set. The additional specification that S contains real numbers is a reasonable mathematical constraint that doesn't contradict the natural language", "The Lean condition (def_2 : \u2200 x \u2208 S, x \u2264 \u03b2) exactly matches the natural language condition \u2200 x \u2208 S, x \u2264 \u03b2", "The conclusion that \u03b2 is an upper bound of S is implicitly captured by the def_2 condition, since that condition is precisely the definition of what it means for \u03b2 to be an upper bound of S"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_3": {"id": "def_3", "natural_language": "(b) if \u03b5 > 0, there is an x\u2080 in S such that x\u2080 > \u03b2 \u2212 \u03b5", "statement": "Definition:\n\u2022 Property (b) for a real number \u03b2 with respect to a set S is: \u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 \u2212 \u03b5 [def_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d) (\u03b2 : \u211d)\n(def_3 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["\u03b2 is declared as a real number in both natural language and Lean", "Natural language says 'S is a set' while Lean specifies 'S : Set \u211d' (set of real numbers). The Lean version is more specific but doesn't contradict the natural language", "Both express the condition that \u03b5 is a positive real number", "Both express the existence of x\u2080 in S such that x\u2080 > \u03b2 - \u03b5", "The Lean formalization captures the complete definition of Property (b) through def_3"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Since \u03b2 is an upper bound of S, it satisfies (a).", "statement": "We assume:\n\u2022 \u03b2 = sup S is the least upper bound of S [def_1].\n\u2022 Property (a) is defined as \u2200 x \u2208 S, x \u2264 \u03b2 [def_2].\nTherefore, we conclude:\n\u2022 \u03b2 = sup S satisfies property (a), as the supremum is by definition an upper bound [l1].", "dependencies": ["def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (def_1 : IsLUB S \u03b2)\n  (def_2 : \u2200 x \u2208 S, x \u2264 \u03b2) :\n  \u2200 x \u2208 S, x \u2264 \u03b2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (def_1 : IsLUB S \u03b2)\n  (def_2 : \u2200 x \u2208 S, x \u2264 \u03b2) :\n  \u2200 x \u2208 S, x \u2264 \u03b2 := by\n  exact def_1.1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states '\u03b2 = sup S' but Lean only has 'IsLUB S \u03b2'. While semantically related, the explicit equality with sup S is missing.", "Property (a) definition matches perfectly between natural language and Lean formalization.", "The logical structure is fundamentally flawed - Lean assumes the conclusion as a premise (def_2) and then tries to prove the same thing as the goal, creating a tautology rather than a meaningful theorem.", "The natural language describes proving a fundamental property of supremums, but the Lean formalization makes this trivial by assuming what should be proven, missing the mathematical content entirely."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states '\u03b2 = sup S' but Lean only has 'IsLUB S \u03b2'. While semantically related, the explicit equality with sup S is missing.\", 'Property (a) definition matches perfectly between natural language and Lean formalization.', 'The logical structure is fundamentally flawed - Lean assumes the conclusion as a premise (def_2) and then tries to prove the same thing as the goal, creating a tautology rather than a meaningful theorem.', 'The natural language describes proving a fundamental property of supremums, but the Lean formalization makes this trivial by assuming what should be proven, missing the mathematical content entirely.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "(b) just says no number less than \u03b2 is an upper bound.", "statement": "We assume:\n\u2022 Property (b) is defined as \u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 \u2212 \u03b5 [def_3].\nTherefore, we conclude:\n\u2022 Property (b) is equivalent to the statement 'for any real number a < \u03b2, a is not an upper bound of S' [l2].", "dependencies": ["def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (def_3 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) :\n  (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) \u2194 (\u2200 (a : \u211d), a < \u03b2 \u2192 \u00ac(\u2200 x \u2208 S, x \u2264 a)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (def_3 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) :\n  (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) \u2194 (\u2200 (a : \u211d), a < \u03b2 \u2192 \u00ac(\u2200 x \u2208 S, x \u2264 a)) := by\n  constructor\n  \u00b7 intro h a ha h'\n    obtain \u27e8x\u2080, hx\u2080, hx\u27e9 := h (\u03b2 - a) (by linarith)\n    specialize h' x\u2080 hx\u2080\n    linarith\n  \u00b7 intro h \u03b5 h\u03b5\n    by_contra h'\n    push_neg at h'\n    specialize h (\u03b2 - \u03b5) (by linarith)\n    apply h\n    intro x hx\n    exact h' x hx", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption def_3 is correctly formalized. The Lean version properly captures the universal quantification over positive real numbers \u03b5 and the existential quantification over elements in S, with the correct inequality x\u2080 > \u03b2 - \u03b5.", "The equivalence statement is correctly formalized. The natural language equivalence is properly expressed as a biconditional (\u2194) in Lean. The right side correctly translates 'a is not an upper bound of S' as \u00ac(\u2200 x \u2208 S, x \u2264 a), which is the standard mathematical definition of what it means for a number to not be an upper bound."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since any real number a < \u03b2 can be written as \u03b2 \u2212 \u03b5 with \u03b5 > 0, (b) just says no number less than \u03b2 is an upper bound.", "statement": "We assume:\n\u2022 \u03b2 = sup S is the least upper bound of S [def_1].\nTherefore, we conclude:\n\u2022 By the definition of 'least' upper bound, no number `a < \u03b2` is an upper bound of S [l3].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {S : Set \u211d} (\u03b2 : \u211d)\n  (def_1 : IsLUB S \u03b2)\n  (a : \u211d) (h_a : a < \u03b2) :\n  \u2203 x\u2080 \u2208 S, x\u2080 > a := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {S : Set \u211d} (\u03b2 : \u211d)\n  (def_1 : IsLUB S \u03b2)\n  (a : \u211d) (h_a : a < \u03b2) :\n  \u2203 x\u2080 \u2208 S, x\u2080 > a := by\n  by_contra h\n  push_neg at h\n  have h' : \u2200 x \u2208 S, x \u2264 a := h\n  apply lt_irrefl \u03b2\n  apply lt_of_le_of_lt _ h_a\n  exact def_1.right h'", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that \u03b2 is the least upper bound of S using IsLUB, which is the standard way to express this concept in Lean/Mathlib.", "The Lean formalization correctly translates 'no number a < \u03b2 is an upper bound of S' into its logically equivalent form '\u2203 x\u2080 \u2208 S, x\u2080 > a'. This is a direct logical equivalence: saying 'a is not an upper bound' is the same as saying 'there exists some element in S that is greater than a'."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since any real number a < \u03b2 can be written as \u03b2 \u2212 \u03b5 with \u03b5 > 0, (b) just says no number less than \u03b2 is an upper bound.", "statement": "We assume:\n\u2022 The statement 'no number less than \u03b2 is an upper bound of S' is equivalent to property (b) [l2].\n\u2022 For \u03b2 = sup S, no number less than \u03b2 is an upper bound of S [l3].\nTherefore, we conclude:\n\u2022 \u03b2 = sup S satisfies property (b) [l4].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (l2 : (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) \u2194 (\u2200 (a : \u211d), a < \u03b2 \u2192 \u00ac(\u2200 x \u2208 S, x \u2264 a)))\n  (l3 : (\u2200 (a : \u211d), a < \u03b2 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > a)) :\n  (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (l2 : (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) \u2194 (\u2200 (a : \u211d), a < \u03b2 \u2192 \u00ac(\u2200 x \u2208 S, x \u2264 a)))\n  (l3 : (\u2200 (a : \u211d), a < \u03b2 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > a)) :\n  (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) := by\n  intro \u03b5 h\u03b5\n  have h := l3 (\u03b2 - \u03b5) (by linarith)\n  exact h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The equivalence statement l2 correctly formalizes the natural language equivalence between property (b) and 'no number less than \u03b2 is an upper bound of S'", "The assumption l3 correctly captures that no number less than \u03b2 is an upper bound, using the logically equivalent formulation that for any a < \u03b2, there exists an element in S greater than a", "The conclusion correctly states that \u03b2 satisfies property (b), which is formalized as the left side of the equivalence", "The overall logical structure properly captures the modus ponens reasoning from the natural language argument"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_4": {"id": "def_4", "natural_language": "Now, suppose \u03b2\u2081 < \u03b2\u2082", "statement": "Definition:\n\u2022 To prove uniqueness, we assume there exist two distinct real numbers, \u03b2\u2081 and \u03b2\u2082, that both satisfy properties (a) and (b) for set S. Without loss of generality, we assume for contradiction that \u03b2\u2081 < \u03b2\u2082 [def_4].", "dependencies": ["def_2", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n(def_2 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081)\n(def_3 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 - \u03b5)\n(def_4 : \u03b2\u2081 < \u03b2\u2082)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean variable declaration correctly establishes \u03b2\u2081 and \u03b2\u2082 as real numbers, matching the natural language condition", "The Lean formalization only shows properties (a) and (b) for \u03b2\u2081, but the natural language states that both \u03b2\u2081 and \u03b2\u2082 satisfy these properties. The properties for \u03b2\u2082 are missing", "The natural language assumes \u03b2\u2081 \u2260 \u03b2\u2082 for contradiction, but the Lean formalization directly assumes the stronger condition \u03b2\u2081 < \u03b2\u2082. The assumption of distinctness (\u2260) is missing", "The Lean formalization \u03b2\u2081 < \u03b2\u2082 matches the conclusion that without loss of generality, \u03b2\u2081 < \u03b2\u2082"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean variable declaration correctly establishes \u03b2\u2081 and \u03b2\u2082 as real numbers, matching the natural language condition', 'The Lean formalization only shows properties (a) and (b) for \u03b2\u2081, but the natural language states that both \u03b2\u2081 and \u03b2\u2082 satisfy these properties. The properties for \u03b2\u2082 are missing', 'The natural language assumes \u03b2\u2081 \u2260 \u03b2\u2082 for contradiction, but the Lean formalization directly assumes the stronger condition \u03b2\u2081 < \u03b2\u2082. The assumption of distinctness (\u2260) is missing', 'The Lean formalization \u03b2\u2081 < \u03b2\u2082 matches the conclusion that without loss of generality, \u03b2\u2081 < \u03b2\u2082']"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "and \u03b2\u2082 has property (b); taking \u03b5 = \u03b2\u2082 \u2212 \u03b2\u2081, there\u2019s x\u2080 in S with x\u2080 > \u03b2\u2081", "statement": "We assume:\n\u2022 \u03b2\u2081 and \u03b2\u2082 both satisfy properties (a) and (b), and \u03b2\u2081 < \u03b2\u2082 [def_4].\n\u2022 Property (b) states that for any \u03b5 > 0, there is an x\u2080 in S such that x\u2080 > \u03b2\u2082 \u2212 \u03b5 [def_3].\nTherefore, we conclude:\n\u2022 By setting \u03b5 = \u03b2\u2082 - \u03b2\u2081, which is positive, and applying property (b) to \u03b2\u2082, there exists an element x\u2080 \u2208 S such that x\u2080 > \u03b2\u2082 - (\u03b2\u2082 - \u03b2\u2081) = \u03b2\u2081 [l5].", "dependencies": ["def_3", "def_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_4 : \u03b2\u2081 < \u03b2\u2082)\n  (def_3_\u03b2\u2082 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5) :\n  \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_4 : \u03b2\u2081 < \u03b2\u2082)\n  (def_3_\u03b2\u2082 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5) :\n  \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 := by\n  have \u03b5_pos : \u03b2\u2082 - \u03b2\u2081 > 0 := sub_pos.mpr def_4\n  obtain \u27e8x\u2080, hx\u2080, hx\u27e9 := def_3_\u03b2\u2082 (\u03b2\u2082 - \u03b2\u2081) \u03b5_pos\n  exact \u27e8x\u2080, hx\u2080, by linarith\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential logical components from the natural language. The premises (def_4 and def_3_\u03b2\u2082) provide exactly what's needed for the mathematical argument described, and the conclusion matches precisely. While the natural language mentions property (a) and doesn't fully specify the context, the Lean code contains all the mathematical content that's actually used in the logical derivation. The argument structure - using the fact that \u03b2\u2081 < \u03b2\u2082 makes \u03b2\u2082 - \u03b2\u2081 a valid positive \u03b5 for applying property (b) - is fully supported by the Lean premises and conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "so \u03b2\u2081 fails (a).", "statement": "We assume:\n\u2022 There exists an element x\u2080 \u2208 S such that x\u2080 > \u03b2\u2081 [l5].\n\u2022 \u03b2\u2081 was assumed to satisfy property (a), which states \u2200 x \u2208 S, x \u2264 \u03b2\u2081 [def_4, def_2].\nTherefore, we conclude:\n\u2022 The existence of such an x\u2080 contradicts property (a) for \u03b2\u2081. Thus, \u03b2\u2081 fails property (a) [l6].", "dependencies": ["def_2", "def_4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (S : Set \u211d) (\u03b2\u2081 : \u211d)\n  (l5 : \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081)\n  (def_4 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081) :\n  False := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (S : Set \u211d) (\u03b2\u2081 : \u211d)\n  (l5 : \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081)\n  (def_4 : \u2200 x \u2208 S, x \u2264 \u03b2\u2081) :\n  False := by\n  obtain \u27e8x\u2080, hx\u2080, h\u27e9 := l5\n  have := def_4 x\u2080 hx\u2080\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumptions from natural language are correctly captured as hypotheses in Lean with identical logical content", "The contradiction conclusion is properly represented as proving False, which is the standard formal logic equivalent", "The logical flow from contradictory assumptions to contradiction is preserved exactly", "Type declarations for S and \u03b2\u2081 add helpful formalization details without altering the mathematical meaning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Thus, uniqueness holds.", "statement": "We assume:\n\u2022 The assumption that there are two distinct numbers \u03b2\u2081 < \u03b2\u2082 satisfying the properties [def_4] leads to a contradiction where \u03b2\u2081 is shown to fail property (a) [l6].\nTherefore, we conclude:\n\u2022 The assumption \u03b2\u2081 < \u03b2\u2082 must be false. By symmetry, \u03b2\u2082 < \u03b2\u2081 is also false. Thus, \u03b2\u2081 = \u03b2\u2082, which establishes that any number satisfying properties (a) and (b) is unique [l7].", "dependencies": ["def_4", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_4_hyp : \u03b2\u2081 < \u03b2\u2082)\n  (l6 : False) :\n  \u03b2\u2081 = \u03b2\u2082 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d)\n  (def_4_hyp : \u03b2\u2081 < \u03b2\u2082)\n  (l6 : False) :\n  \u03b2\u2081 = \u03b2\u2082 := by\n  aesop", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the main logical structure of proof by contradiction (assumption \u03b2\u2081 < \u03b2\u2082, contradiction l6 : False, conclusion \u03b2\u2081 = \u03b2\u2082). However, it lacks explicit representation of some elements mentioned in the natural language: the specific properties [def_4] and property (a) that \u03b2\u2081 fails, and the symmetry argument about \u03b2\u2082 < \u03b2\u2081 also being false. While these may be contextual details handled elsewhere, their absence makes the formalization slightly incomplete compared to the natural language description. The core logical flow is preserved but some explanatory details are missing."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the main logical structure of proof by contradiction (assumption \u03b2\u2081 < \u03b2\u2082, contradiction l6 : False, conclusion \u03b2\u2081 = \u03b2\u2082). However, it lacks explicit representation of some elements mentioned in the natural language: the specific properties [def_4] and property (a) that \u03b2\u2081 fails, and the symmetry argument about \u03b2\u2082 < \u03b2\u2081 also being false. While these may be contextual details handled elsewhere, their absence makes the formalization slightly incomplete compared to the natural language description. The core logical flow is preserved but some explanatory details are missing.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "We first show that \u03b2 = sup S has properties (a) and (b). ... Thus, uniqueness holds.", "statement": "We assume:\n\u2022 For a nonempty, bounded-above set S, sup S satisfies property (a) [l1].\n\u2022 For a nonempty, bounded-above set S, sup S satisfies property (b) [l4].\n\u2022 Any real number \u03b2 that satisfies properties (a) and (b) for set S is unique [l7].\nTherefore, we conclude:\n\u2022 sup S is the unique real number \u03b2 such that (a) x \u2264 \u03b2 for all x in S; and (b) if \u03b5 > 0, there is an x\u2080 in S such that x\u2080 > \u03b2 \u2212 \u03b5 [ts_1].", "dependencies": ["l1", "l4", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (hS_nonempty : S.Nonempty) (hS_bdd_above : BddAbove S)\n  (l1 : \u2200 (S : Set \u211d) (\u03b2 : \u211d), S.Nonempty \u2192 BddAbove S \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2))\n  (l4 : \u2200 (S : Set \u211d) (\u03b2 : \u211d), S.Nonempty \u2192 BddAbove S \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5))\n  (l7 : \u2200 (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d), S.Nonempty \u2192 BddAbove S \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 - \u03b5) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2082) \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5) \u2192 \u03b2\u2081 = \u03b2\u2082) :\n  IsLUB S \u03b2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (S : Set \u211d) (\u03b2 : \u211d)\n  (hS_nonempty : S.Nonempty) (hS_bdd_above : BddAbove S)\n  (l1 : \u2200 (S : Set \u211d) (\u03b2 : \u211d), S.Nonempty \u2192 BddAbove S \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2))\n  (l4 : \u2200 (S : Set \u211d) (\u03b2 : \u211d), S.Nonempty \u2192 BddAbove S \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5) \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2 - \u03b5))\n  (l7 : \u2200 (S : Set \u211d) (\u03b2\u2081 \u03b2\u2082 : \u211d), S.Nonempty \u2192 BddAbove S \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2081) \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2081 - \u03b5) \u2192 (\u2200 x \u2208 S, x \u2264 \u03b2\u2082) \u2192 (\u2200 \u03b5 > 0, \u2203 x\u2080 \u2208 S, x\u2080 > \u03b2\u2082 - \u03b5) \u2192 \u03b2\u2081 = \u03b2\u2082) :\n  IsLUB S \u03b2 := by\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 intro x hx\n    exact l1 S \u03b2 hS_nonempty hS_bdd_above (fun x hx => le_sSup hS_bdd_above hx) x hx\n  \u00b7 intro \u03b5 h\u03b5\n    exact l4 S \u03b2 hS_nonempty hS_bdd_above (fun \u03b5 h\u03b5 => exists_gt_of_lt_sSup hS_nonempty (sSup_le_iff.mp (le_refl (sSup S)) \u03b5 h\u03b5)) \u03b5 h\u03b5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 76, "endLine": 14, "endColumn": 78, "data": "application type mismatch\n  le_sSup hS_bdd_above hx\nargument\n  hx\nhas type\n  x \u2208 S : Prop\nbut is expected to have type\n  \u211d : Type"}, {"line": 16, "column": 55, "endLine": 16, "endColumn": 75, "data": "unknown identifier 'exists_gt_of_lt_sSup'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumptions l1 and l4 are tautologies (P \u2192 P form) and don't capture that sup S specifically satisfies properties (a) and (b). The natural language assumes sup S has these properties, but the Lean code uses meaningless tautological assumptions about arbitrary \u03b2.", "The uniqueness assumption l7 correctly captures that any two real numbers satisfying both properties (a) and (b) must be equal.", "The conclusion is fundamentally wrong - it should establish that sup S satisfies the characterizing properties, but instead concludes IsLUB S \u03b2 for an arbitrary parameter \u03b2 rather than sup S.", "Properties (a) and (b) are correctly formalized with proper quantification and logical structure.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The assumptions l1 and l4 are tautologies (P \u2192 P form) and don't capture that sup S specifically satisfies properties (a) and (b). The natural language assumes sup S has these properties, but the Lean code uses meaningless tautological assumptions about arbitrary \u03b2.\", 'The uniqueness assumption l7 correctly captures that any two real numbers satisfying both properties (a) and (b) must be equal.', 'The conclusion is fundamentally wrong - it should establish that sup S satisfies the characterizing properties, but instead concludes IsLUB S \u03b2 for an arbitrary parameter \u03b2 rather than sup S.', 'Properties (a) and (b) are correctly formalized with proper quantification and logical structure.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_4", "label": "def_4", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    