
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1} = \sqrt{2a_n+3}$. Prove that for all integers $n \geq 1$, the inequality $a_n < 3$ holds.

Proof: We will prove this by mathematical induction on $n$. First, for the base case $n=1$, we are given $a_1=1$. Since $1 < 3$, the inequality holds. Now, for the inductive step, we assume the statement is true for some integer $k \geq 1$, which means $a_k < 3$. We want to show that the statement is true for $k+1$, i.e., $a_{k+1} < 3$. We have the recurrence relation $a_{k+1} = \sqrt{2a_k+3}$. From the inductive hypothesis, we know that $a_k < 3$. We can multiply this inequality by 2 to get $2a_k < 6$. Adding 3 to both sides gives $2a_k+3 < 9$. Taking the square root of both sides gives $\sqrt{2a_k+3} < \sqrt{9}$. This simplifies to $a_{k+1} < 3$. Since the statement is true for $k+1$, by the principle of mathematical induction, the inequality $a_n < 3$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1} = \\sqrt{2a_n+3}$.", "statement": "Premise:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of real numbers defined by $a_1=1$ and the recurrence relation $a_{n+1} = \\sqrt{2a_n+3}$ for all integers $n \\geq 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean variable declaration `a : \u2115 \u2192 \u211d` correctly captures that a is a sequence of real numbers indexed by natural numbers, which corresponds to the mathematical notation $(a_n)_{n \u2265 1}$", "The initial condition `a 1 = 1` in Lean exactly matches the mathematical statement $a_1 = 1$", "The recurrence relation `(\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3))` perfectly captures the mathematical recurrence $a_{n+1} = \\sqrt{2a_n + 3}$ for all integers $n \u2265 1$", "The Lean formalization establishes the sequence as well-defined through the variable declaration and the constraint tc_1, which combines the initial condition and recurrence relation, matching the conclusion that the sequence is well-defined"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, for the base case $n=1$, we are given $a_1=1$. Since $1 < 3$, the inequality holds.", "statement": "We assume:\n\u2022 The first term of the sequence is $a_1=1$ [tc_1].\nTherefore, we conclude:\n\u2022 $a_1 < 3$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3))) :\n  a 1 < 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3))) :\n  a 1 < 3 := by\n  rw [tc_1.1]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language only states that the first term equals 1, but the Lean formalization introduces an additional recurrence relation (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)) that is not mentioned in the natural language. This adds a significant mathematical constraint that changes the logical meaning.", "The conclusion that a 1 < 3 is correctly captured in both the natural language and Lean formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language only states that the first term equals 1, but the Lean formalization introduces an additional recurrence relation (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)) that is not mentioned in the natural language. This adds a significant mathematical constraint that changes the logical meaning.', 'The conclusion that a 1 < 3 is correctly captured in both the natural language and Lean formalization.']"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "for the inductive step, we assume the statement is true for some integer $k \\geq 1$, which means $a_k < 3$.", "statement": "Definition:\n\u2022 For an arbitrary integer $k \\geq 1$, we assume the inductive hypothesis: $a_k < 3$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d) (k : \u2115)\n(def_1 : k \u2265 1 \u2192 a k < 3)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language specifies k as an arbitrary integer \u2265 1, while Lean uses k : \u2115 (natural number). Since k \u2265 1 is enforced in the implication, the effective domain is the same, but there's a slight type difference between integers and natural numbers.", "The Lean formalization correctly captures the conditional nature of the inductive hypothesis: when k \u2265 1, then a k < 3. This perfectly matches the mathematical meaning."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language specifies k as an arbitrary integer \u2265 1, while Lean uses k : \u2115 (natural number). Since k \u2265 1 is enforced in the implication, the effective domain is the same, but there's a slight type difference between integers and natural numbers.\", 'The Lean formalization correctly captures the conditional nature of the inductive hypothesis: when k \u2265 1, then a k < 3. This perfectly matches the mathematical meaning.']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "We can multiply this inequality by 2 to get $2a_k < 6$.", "statement": "We assume:\n\u2022 For some integer $k \\geq 1$, $a_k < 3$ [def_1].\nTherefore, we conclude:\n\u2022 $2a_k < 6$ [l2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (def_1 : k \u2265 1 \u2192 a k < 3) :\n  k \u2265 1 \u2192 2 * a k < 6 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (def_1 : k \u2265 1 \u2192 a k < 3) :\n  k \u2265 1 \u2192 2 * a k < 6 := by\n  intro h\n  have := def_1 h\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable types differ slightly (integers vs natural numbers, unspecified vs real numbers) but are mathematically compatible given the constraints", "The logical structure differs significantly: natural language presents an existential assumption leading to a conclusion, while Lean structures this as a conditional statement for a specific k", "The conclusion in Lean adds an explicit condition 'k \u2265 1' that was implicit in the natural language context", "The core mathematical relationship 2*a_k < 6 following from a_k < 3 is correctly preserved"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable types differ slightly (integers vs natural numbers, unspecified vs real numbers) but are mathematically compatible given the constraints', 'The logical structure differs significantly: natural language presents an existential assumption leading to a conclusion, while Lean structures this as a conditional statement for a specific k', \"The conclusion in Lean adds an explicit condition 'k \u2265 1' that was implicit in the natural language context\", 'The core mathematical relationship 2*a_k < 6 following from a_k < 3 is correctly preserved']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Adding 3 to both sides gives $2a_k+3 < 9$.", "statement": "We assume:\n\u2022 $2a_k < 6$ [l2].\nTherefore, we conclude:\n\u2022 $2a_k+3 < 9$ [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l2 : k \u2265 1 \u2192 2 * a k < 6) :\n  k \u2265 1 \u2192 2 * a k + 3 < 9 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l2 : k \u2265 1 \u2192 2 * a k < 6) :\n  k \u2265 1 \u2192 2 * a k + 3 < 9 := by\n  intro h\n  have := l2 h\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical relationship from the natural language. While it adds the condition 'k \u2265 1' not explicitly mentioned in the natural language, this is an additional mathematical constraint that makes the formalization more precise without contradicting the core logic. The premise '2a_k < 6' and conclusion '2a_k + 3 < 9' are both accurately represented, and the implication structure is preserved. The extra type declarations and conditions fall under acceptable additional details that enhance mathematical rigor."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Taking the square root of both sides gives $\\sqrt{2a_k+3} < \\sqrt{9}$.", "statement": "We assume:\n\u2022 $2a_k+3 < 9$ [l3].\nTherefore, we conclude:\n\u2022 $\\sqrt{2a_k+3} < \\sqrt{9}$ [l4].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l3 : 2 * a k + 3 < 9) :\n  Real.sqrt (2 * a k + 3) < Real.sqrt 9 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l3 : 2 * a k + 3 < 9) :\n  Real.sqrt (2 * a k + 3) < Real.sqrt 9 := by\n  apply Real.sqrt_lt_sqrt\n  linarith [l3]\n  norm_num", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 2, "endLine": 10, "endColumn": 15, "data": "linarith failed to find a contradiction\ncase hx.a\na : \u2115 \u2192 \u211d\nk : \u2115\nl3 : 2 * a k + 3 < 9\na\u271d : 0 > 2 * a k + 3\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly represent the sequence element a_k as function application a k, which is standard in formal mathematics", "The premise 2a_k+3 < 9 is faithfully translated to 2 * a k + 3 < 9 with correct Lean syntax", "The conclusion \u221a(2a_k+3) < \u221a9 is accurately represented using Real.sqrt with proper syntax", "The logical structure from assumption to conclusion is correctly captured as a lemma with hypothesis l3 leading to the stated conclusion", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (l3 : 2 * a k + 3 < 9) :\n  \u00ac (Real.sqrt (2 * a k + 3) < Real.sqrt 9) := by\n  intro h\n  have h1 : 2 * a k + 3 \u2265 0 := by\n    have : a k \u2265 -1.5 := by linarith [l3]\n    linarith\n  have h2 := Real.sqrt_lt_sqrt h1 (by norm_num) h\n  linarith [h2, l3]"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This simplifies to $a_{k+1} < 3$.", "statement": "We assume:\n\u2022 The sequence is defined by the recurrence relation $a_{k+1} = \\sqrt{2a_k+3}$ for $k \\geq 1$ [tc_1].\n\u2022 We have the inequality $\\sqrt{2a_k+3} < \\sqrt{9}$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} < 3$ [l5].", "dependencies": ["tc_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)))\n  (l4 : Real.sqrt (2 * a k + 3) < Real.sqrt 9) :\n  a (k + 1) < 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)))\n  (l4 : Real.sqrt (2 * a k + 3) < Real.sqrt 9) :\n  a (k + 1) < 3 := by\n  cases tc_1 with | intro h1 h2 =>\n  have h : a (k + 1) = Real.sqrt (2 * a k + 3) := by\n    cases k\n    case zero => simp [h1]\n    case succ k' => exact h2 (k' + 1) (by linarith)\n  rw [h]\n  rw [Real.sqrt_lt_sqrt_iff] at l4\n  simp at l4\n  exact l4", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 14, "endLine": 13, "endColumn": 26, "data": "unsolved goals\na : \u2115 \u2192 \u211d\nh1 : a 1 = 1\nh2 : \u2200 n \u2265 1, a (n + 1) = \u221a(2 * a n + 3)\nl4 : \u221a(2 * a 0 + 3) < \u221a9\n\u22a2 1 = \u221a(2 * a 0 + 3)"}, {"line": 17, "column": 2, "endLine": 17, "endColumn": 12, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the logical structure and mathematical content of the natural language. The recurrence relation, inequality assumption, and conclusion are all properly formalized. The addition of the initial condition a 1 = 1 in tc_1 is an extra constraint not mentioned in the natural language, but this is acceptable as it provides additional context without contradicting the stated logic. The inference from sqrt(2*a_k + 3) < sqrt(9) to a_(k+1) < 3 is correctly represented through the lemma structure.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)))\n  (l4 : Real.sqrt (2 * a k + 3) < Real.sqrt 9) :\n  \u00ac (a (k + 1) < 3) := by\n  rw [tc_1.2 k (by linarith)]\n  simp [Real.sqrt_lt_sqrt_iff] at l4\n  have h : 2 * a k + 3 < 9 := by linarith\n  rw [Real.sqrt_lt_sqrt_iff]\n  linarith"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since the statement is true for $k+1$, by the principle of mathematical induction, the inequality $a_n < 3$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The base case of the induction is true: $a_1 < 3$ [l1].\n\u2022 The inductive step is true: assuming $a_k < 3$ for an arbitrary $k \\geq 1$ [def_1] implies that $a_{k+1} < 3$ [l5].\nTherefore, we conclude by the principle of mathematical induction:\n\u2022 For all integers $n \\geq 1$, $a_n < 3$ [ts_1].", "dependencies": ["l1", "l5", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)))\n  (l1 : a 1 < 3)\n  (def_1 : \u2200 (k : \u2115), k \u2265 1 \u2192 a k < 3)\n  (l5 : \u2200 (k : \u2115), k \u2265 1 \u2192 a k < 3 \u2192 a (k + 1) < 3) :\n  \u2200 (n : \u2115), n \u2265 1 \u2192 a n < 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : a 1 = 1 \u2227 (\u2200 n \u2265 1, a (n + 1) = sqrt (2 * a n + 3)))\n  (l1 : a 1 < 3)\n  (def_1 : \u2200 (k : \u2115), k \u2265 1 \u2192 a k < 3)\n  (l5 : \u2200 (k : \u2115), k \u2265 1 \u2192 a k < 3 \u2192 a (k + 1) < 3) :\n  \u2200 (n : \u2115), n \u2265 1 \u2192 a n < 3 := by\n  intro n hn\n  induction n with\n  | zero => simp at hn\n  | succ m hm =>\n    cases m with\n    | zero => exact l1\n    | succ k =>\n      have hk : k + 1 \u2265 1 := by simp\n      have ih := hm hk\n      exact l5 (k + 1) hk ih", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The base case l1 is correctly formalized as a 1 < 3.", "The inductive step has a major logical flaw. While l5 correctly captures the implication structure (a k < 3 \u2192 a (k+1) < 3), def_1 assumes \u2200 k \u2265 1, a k < 3, which is essentially the conclusion we're trying to prove. In proper induction, we should assume the hypothesis for a specific k, not for all k. This makes the argument circular rather than inductive.", "The conclusion ts_1 correctly formalizes 'for all integers n \u2265 1, a_n < 3' as \u2200 (n : \u2115), n \u2265 1 \u2192 a n < 3.", "The additional sequence definition tc_1 provides helpful context not mentioned in natural language but is logically consistent and doesn't contradict the stated premises."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The base case l1 is correctly formalized as a 1 < 3.', \"The inductive step has a major logical flaw. While l5 correctly captures the implication structure (a k < 3 \u2192 a (k+1) < 3), def_1 assumes \u2200 k \u2265 1, a k < 3, which is essentially the conclusion we're trying to prove. In proper induction, we should assume the hypothesis for a specific k, not for all k. This makes the argument circular rather than inductive.\", \"The conclusion ts_1 correctly formalizes 'for all integers n \u2265 1, a_n < 3' as \u2200 (n : \u2115), n \u2265 1 \u2192 a n < 3.\", \"The additional sequence definition tc_1 provides helpful context not mentioned in natural language but is logically consistent and doesn't contradict the stated premises.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    