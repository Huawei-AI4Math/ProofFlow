
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be an integrable random variable on a probability space $(\Omega, \mathcal{F}, P)$, and let $\mathcal{G}_1, \mathcal{G}_2$ be sub-$\sigma$-algebras of $\mathcal{F}$ such that $\mathcal{G}_1 \subseteq \mathcal{G}_2$. Then, we have the tower property $E[E[X | \mathcal{G}_2] | \mathcal{G}_1] = E[X | \mathcal{G}_1]$ almost surely. As a direct consequence, the law of total expectation holds: $E[E[X | \mathcal{G}_2]] = E[X]$.

Proof: Let $Y_1 = E[X | \mathcal{G}_1]$ and $Y_2 = E[X | \mathcal{G}_2]$. To prove the main theorem, we need to show that $Y_1$ is a version of the conditional expectation of $Y_2$ given $\mathcal{G}_1$. This requires verifying the two defining properties of conditional expectation.

First, by the definition of $Y_1 = E[X | \mathcal{G}_1]$, the random variable $Y_1$ is $\mathcal{G}_1$-measurable. This is the first property.

Second, for the integral property, the definition of $Y_1$ also states that for any set $A \in \mathcal{G}_1$, we have $\int_A Y_1 dP = \int_A X dP$. Similarly, from the definition of $Y_2 = E[X | \mathcal{G}_2]$, for any set $B \in \mathcal{G}_2$, we have $\int_B Y_2 dP = \int_B X dP$. 

Now, consider any set $A \in \mathcal{G}_1$. From the given condition that $\mathcal{G}_1 \subseteq \mathcal{G}_2$, it follows that $A$ is also an element of $\mathcal{G}_2$. Since $A \in \mathcal{G}_2$, we can apply the property of $Y_2$ to set $A$, which gives $\int_A Y_2 dP = \int_A X dP$. By comparing this with the integral property of $Y_1$, we see that for any $A \in \mathcal{G}_1$, we have $\int_A Y_1 dP = \int_A Y_2 dP$. 

Since $Y_1$ is $\mathcal{G}_1$-measurable and satisfies $\int_A Y_1 dP = \int_A Y_2 dP$ for all $A \in \mathcal{G}_1$, $Y_1$ is by definition the conditional expectation of $Y_2$ given $\mathcal{G}_1$. Thus, $Y_1 = E[Y_2 | \mathcal{G}_1]$, which means $E[X | \mathcal{G}_1] = E[E[X | \mathcal{G}_2] | \mathcal{G}_1]$ almost surely. This proves the first part of the theorem.

For the second part, recall that for the trivial $\sigma$-algebra $\mathcal{G}_{	ext{trivial}} = \{\emptyset, \Omega\}$, the conditional expectation $E[Y | \mathcal{G}_{	ext{trivial}}]$ is the constant $E[Y]$ for any integrable random variable $Y$. By setting $\mathcal{G}_1$ to be the trivial $\sigma$-algebra $\{\emptyset, \Omega\}$ in the tower property, we get $E[X | \{\emptyset, \Omega\}] = E[E[X | \mathcal{G}_2] | \{\emptyset, \Omega\}]$. Applying the property of conditioning on the trivial $\sigma$-algebra to both sides, we obtain the law of total expectation: $E[X] = E[E[X | \mathcal{G}_2]]$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be an integrable random variable on a probability space $(\\Omega, \\mathcal{F}, P)$", "statement": "Premise:\n\u2022 $X$ is an integrable random variable on a probability space $(\\Omega, \\mathcal{F}, P)$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} {P : MeasureTheory.Measure \u03a9} [MeasureTheory.IsProbabilityMeasure P]\n  (X : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.Integrable X P)", "lean_pass": false, "error_msg": [{"line": 5, "column": 26, "endLine": 5, "endColumn": 49, "data": "failed to synthesize\n  MeasurableSpace \u03a9\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "let $\\mathcal{G}_1, \\mathcal{G}_2$ be sub-$\\sigma$-algebras of $\\mathcal{F}$", "statement": "Premise:\n\u2022 On the probability space $(\\Omega, \\mathcal{F}, P)$ [tc_1], $\\mathcal{G}_1$ and $\\mathcal{G}_2$ are sub-$\\sigma$-algebras of $\\mathcal{F}$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} {_ : MeasurableSpace \u03a9} (P : Measure \u03a9)\n(X : \u03a9 \u2192 \u211d)\n[MeasureTheory.MeasureSpace \u03a9] [IsProbabilityMeasure P]\n(tc_1 : MeasureTheory.Integrable X P)\n(tc_2 : MeasurableSpace.map (fun \u03c9 \u21a6 \u03c9) (\u2131) \u2264 \u2131 \u2227 MeasurableSpace.map (fun \u03c9 \u21a6 \u03c9) (\ud835\udca2\u2081) \u2264 \u2131 \u2227 MeasurableSpace.map (fun \u03c9 \u21a6 \u03c9) (\ud835\udca2\u2082) \u2264 \u2131)", "lean_pass": false, "error_msg": [{"line": 7, "column": 32, "endLine": 7, "endColumn": 54, "data": "invalid binder annotation, type is not a class instance\n  ?m.48\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "$\\mathcal{G}_1 \\subseteq \\mathcal{G}_2$", "statement": "Premise:\n\u2022 $\\mathcal{G}_1$ and $\\mathcal{G}_2$ are sub-$\\sigma$-algebras of $\\mathcal{F}$ [tc_2]\n\u2022 $\\mathcal{G}_1 \\subseteq \\mathcal{G}_2$ [tc_3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} {m0 : MeasurableSpace \u03a9} {P : Measure \u03a9}\nvariable (G1 G2 : MeasurableSpace \u03a9)\n(tc_2 : G1 \u2264 m0 \u2227 G2 \u2264 m0)\n(tc_3 : G1 \u2264 G2)", "lean_pass": false, "error_msg": [{"line": 5, "column": 51, "endLine": 5, "endColumn": 60, "data": "function expected at\n  Measure\nterm has type\n  ?m.9"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $Y_1 = E[X | \\mathcal{G}_1]$", "statement": "Definition:\n\u2022 Let $Y_1$ be the random variable representing the conditional expectation of $X$ given $\\mathcal{G}_1$, i.e., $Y_1 = E[X | \\mathcal{G}_1]$ [def_1]. This is well-defined since $X$ is integrable [tc_1] and $\\mathcal{G}_1$ is a sub-$\\sigma$-algebra [tc_2].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} (P : MeasureTheory.Measure \u03a9)\n  [MeasureTheory.IsProbabilityMeasure P]\n  (X : \u03a9 \u2192 \u211d) (G\u2081 : MeasurableSpace \u03a9)\n  (tc_1 : MeasureTheory.Integrable X P)\n  (tc_2 : G\u2081 \u2264 \u2131)\n  (def_1 : MeasureTheory.condexp G\u2081 X P = Y\u2081)", "lean_pass": false, "error_msg": [{"line": 11, "column": 42, "endLine": 11, "endColumn": 44, "data": "type mismatch\n  Y\u2081\nhas type\n  ?m.4795 : Sort ?u.4794\nbut is expected to have type\n  \u03a9 \u2192 ?m.5166 : Type (max u_1 ?u.5163)"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "and $Y_2 = E[X | \\mathcal{G}_2]$", "statement": "Definition:\n\u2022 Let $Y_2$ be the random variable representing the conditional expectation of $X$ given $\\mathcal{G}_2$, i.e., $Y_2 = E[X | \\mathcal{G}_2]$ [def_2]. This is well-defined since $X$ is integrable [tc_1] and $\\mathcal{G}_2$ is a sub-$\\sigma$-algebra [tc_2].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9}\nvariable\n  (X : \u03a9 \u2192 \u211d)\n  [IsProbabilityMeasure \u03bc]\n  (tc_1 : Measure.Integrable X \u03bc)\n  (G\u2082 : MeasurableSpace \u03a9)\n  (tc_2 : G\u2082 \u2264 \u2131)\n  (def_2 : G\u2082.measurable (\u03bc.condexp X) = G\u2082.measurable (\u03bc.condexp X))", "lean_pass": false, "error_msg": [{"line": 5, "column": 50, "endLine": 5, "endColumn": 59, "data": "function expected at\n  Measure\nterm has type\n  ?m.9"}, {"line": 8, "column": 3, "endLine": 8, "endColumn": 25, "data": "invalid binder annotation, type is not a class instance\n  ?m.905\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "First, by the definition of $Y_1 = E[X | \\mathcal{G}_1]$, the random variable $Y_1$ is $\\mathcal{G}_1$-measurable.", "statement": "We assume:\n\u2022 $Y_1 = E[X | \\mathcal{G}_1]$ [def_1]\nTherefore, we conclude:\n\u2022 By the definition of conditional expectation, the random variable $Y_1$ is $\\mathcal{G}_1$-measurable [l1].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u211d} [IsFiniteMeasure P] [SigmaFinite \u2131 P] [Integrable X P]\n  {G\u2081 : MeasurableSpace \u03a9} [G\u2081 \u2264 \u2131]\n  (def_1 : \u2200 (Y\u2081 : \u03a9 \u2192 \u211d), Y\u2081 = (MeasureTheory.condexp \u211d \u2131 G\u2081 P X)) :\n  MeasureTheory.Measurable G\u2081 (MeasureTheory.condexp \u211d \u2131 G\u2081 P X) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 15, "endLine": 7, "endColumn": 32, "data": "invalid binder annotation, type is not a class instance\n  ?m.42\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic\n\nopen MeasureTheory\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u211d} [IsFiniteMeasure P] [SigmaFinite P] [Integrable X P]\n  {G\u2081 : MeasurableSpace \u03a9} [hG\u2081 : G\u2081 \u2264 \u2039MeasurableSpace \u03a9\u203a] :\n  Measurable G\u2081 (condexp G\u2081 P X) :=\n  condexp_measurable G\u2081 P X", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Second, for the integral property, the definition of $Y_1$ also states that for any set $A \\in \\mathcal{G}_1$, we have $\\int_A Y_1 dP = \\int_A X dP$.", "statement": "We assume:\n\u2022 $Y_1 = E[X | \\mathcal{G}_1]$ [def_1]\nTherefore, we conclude:\n\u2022 By the definition of conditional expectation, for any set $A \\in \\mathcal{G}_1$, we have the integral identity $\\int_A Y_1 dP = \\int_A X dP$ [l2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03a9 : Type*} {A' : Type*} [MeasurableSpace \u03a9] {\u03bc : Measure \u03a9}\n  {X Y1 : \u03a9 \u2192 \u211d} [IsFiniteMeasure \u03bc] [SigmaFinite \u03bc] [MeasureTheory.HasCondExp \u03bc A' (X * \u03bc.rnDeriv (\u03bc.trim A'))]\n  (def_1 : Y1 = MeasureTheory.condExp \u03bc A' X)\n  (A : A') :\n  \u222b x in A, Y1 x \u2202\u03bc = \u222b x in A, X x \u2202\u03bc := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 18, "endLine": 7, "endColumn": 35, "data": "invalid binder annotation, type is not a class instance\n  ?m.59\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter MeasureTheory\n\nlemma l2\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] {\u03bc : Measure \u03a9}\n  {X Y1 : \u03a9 \u2192 \u211d} [IsFiniteMeasure \u03bc] {m : MeasurableSpace \u03a9} (hm : m \u2264 \u22a4)\n  (def_1 : Y1 =\u1d50[\u03bc] condExp \u03bc m X)\n  {A : Set \u03a9} (hA : MeasurableSet[m] A) :\n  \u222b x in A, Y1 x \u2202\u03bc = \u222b x in A, X x \u2202\u03bc := by\n  rw [def_1]\n  exact condExp_ae_eq_condexp \u03bc hm X A hA", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 20, "endLine": 8, "endColumn": 33, "data": "function expected at\n  condExp\nterm has type\n  ?m.805"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Similarly, from the definition of $Y_2 = E[X | \\mathcal{G}_2]$, for any set $B \\in \\mathcal{G}_2$, we have $\\int_B Y_2 dP = \\int_B X dP$.", "statement": "We assume:\n\u2022 $Y_2 = E[X | \\mathcal{G}_2]$ [def_2]\nTherefore, we conclude:\n\u2022 By the definition of conditional expectation, for any set $B \\in \\mathcal{G}_2$, we have the integral identity $\\int_B Y_2 dP = \\int_B X dP$ [l3].", "dependencies": ["def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u211d} [IsFiniteMeasure P] [SigmaFinite (Measure.withDensity P (fun x => ENNReal.ofReal (max 0 X x)))] [SigmaFinite (Measure.withDensity P (fun x => ENNReal.ofReal (max 0 (-X x))))]\n  {G\u2082 : MeasurableSpace \u03a9} [Fact (G\u2082 \u2264 \u2131)]\n  (Y\u2082 : \u03a9 \u2192 \u211d)\n  (def_2 : Y\u2082 = (Measure.integral (P.restrict G\u2082) X).toReal):\n  \u2200 (B : Set \u03a9), MeasurableSet[G\u2082] B \u2192 \u222b \u03c9 in B, Y\u2082 \u03c9 \u2202P = \u222b \u03c9 in B, X \u03c9 \u2202P := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 15, "endLine": 7, "endColumn": 32, "data": "invalid binder annotation, type is not a class instance\n  ?m.42\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u211d} [IsFiniteMeasure P] [SigmaFinite (Measure.withDensity P (fun x => ENNReal.ofReal (max 0 (X x))))] [SigmaFinite (Measure.withDensity P (fun x => ENNReal.ofReal (max 0 (-X x))))]\n  {G\u2082 : MeasurableSpace \u03a9} (hG\u2082 : G\u2082 \u2264 \u2131)\n  (Y\u2082 : \u03a9 \u2192 \u211d)\n  (def_2 : Y\u2082 = fun \u03c9 => (Measure.condexp G\u2082 X \u03c9).toReal) :\n  \u2200 (B : Set \u03a9), MeasurableSet[G\u2082] B \u2192 \u222b \u03c9 in B, Y\u2082 \u03c9 \u2202P = \u222b \u03c9 in B, X \u03c9 \u2202P := by\n  intro B hB\n  simp [def_2]\n  rw [Measure.integral_condexp hG\u2082 X hB]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 15, "endLine": 7, "endColumn": 32, "data": "invalid binder annotation, type is not a class instance\n  ?m.42\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "From the given condition that $\\mathcal{G}_1 \\subseteq \\mathcal{G}_2$, it follows that $A$ is also an element of $\\mathcal{G}_2$.", "statement": "We assume:\n\u2022 $\\mathcal{G}_1 \\subseteq \\mathcal{G}_2$ [tc_3]\nTherefore, we conclude:\n\u2022 For any set $A$, if $A \\in \\mathcal{G}_1$, then $A \\in \\mathcal{G}_2$ [l4].", "dependencies": ["tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {\u03a9 : Type*} {F G1 G2 : Set (Set \u03a9)} [MeasurableSpace \u03a9]\n  (tc_3 : G1 \u2286 G2) :\n  \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 A \u2208 G2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {\u03a9 : Type*} {F G1 G2 : Set (Set \u03a9)} [MeasurableSpace \u03a9]\n  (tc_3 : G1 \u2286 G2) :\n  \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 A \u2208 G2 := by\n  aesop", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects. Extra variables (\u03a9, F, MeasurableSpace) provide additional context without contradicting the natural language.", "The subset assumption G1 \u2286 G2 is perfectly captured with the correct label tc_3.", "The conclusion statement is correctly formalized as a universal quantification with implication, matching the natural language exactly.", "The overall logical structure from assumption to conclusion is preserved correctly in the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Since $A \\in \\mathcal{G}_2$, we can apply the property of $Y_2$ to set $A$, which gives $\\int_A Y_2 dP = \\int_A X dP$.", "statement": "We assume:\n\u2022 For any set $B \\in \\mathcal{G}_2$, we have $\\int_B Y_2 dP = \\int_B X dP$ [l3]\n\u2022 For any set $A$, if $A \\in \\mathcal{G}_1$, then $A \\in \\mathcal{G}_2$ [l4]\nTherefore, we conclude:\n\u2022 For any set $A \\in \\mathcal{G}_1$, we have $\\int_A Y_2 dP = \\int_A X dP$ [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {P : Measure \u03a9} {X Y2 : \u03a9 \u2192 \u211d}\n  {G1 G2 : Set (Set \u03a9)} [hG1 : MeasurableSpace.IsSubsingleton G1] [hG2 : MeasurableSpace.IsSubsingleton G2]\n  (l3 : \u2200 (B : Set \u03a9), B \u2208 G2 \u2192 \u222b x in B, Y2 x \u2202P = \u222b x in B, X x \u2202P)\n  (l4 : \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 A \u2208 G2) :\n  \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 \u222b x in A, Y2 x \u2202P = \u222b x in A, X x \u2202P := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 31, "endLine": 7, "endColumn": 64, "data": "unknown constant 'MeasurableSpace.IsSubsingleton'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.MeasureTheory.Integral.Integrable\nimport Mathlib.MeasureTheory.Integral.Lebesgue\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter MeasureTheory\n\nlemma l5\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] {P : Measure \u03a9} {X Y2 : \u03a9 \u2192 \u211d}\n  {G1 G2 : Set (Set \u03a9)} (l3 : \u2200 (B : Set \u03a9), B \u2208 G2 \u2192 \u222b x in B, Y2 x \u2202P = \u222b x in B, X x \u2202P)\n  (l4 : \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 A \u2208 G2) :\n  \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 \u222b x in A, Y2 x \u2202P = \u222b x in A, X x \u2202P := by\n  intro A hA\n  exact l3 A (l4 A hA)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By comparing this with the integral property of $Y_1$, we see that for any $A \\in \\mathcal{G}_1$, we have $\\int_A Y_1 dP = \\int_A Y_2 dP$.", "statement": "We assume:\n\u2022 For any set $A \\in \\mathcal{G}_1$, we have $\\int_A Y_1 dP = \\int_A X dP$ [l2]\n\u2022 For any set $A \\in \\mathcal{G}_1$, we have $\\int_A Y_2 dP = \\int_A X dP$ [l5]\nTherefore, we conclude:\n\u2022 For any set $A \\in \\mathcal{G}_1$, we have $\\int_A Y_1 dP = \\int_A Y_2 dP$ [l6].", "dependencies": ["l2", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  (X Y1 Y2 : \u03a9 \u2192 \u211d)\n  (G1 : MeasurableSpace \u03a9)\n  [IsSubsingleton (G1 : Set (MeasurableSpace \u03a9))]\n  (l2 : \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 \u222b x in A, Y1 x \u2202P = \u222b x in A, X x \u2202P)\n  (l5 : \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 \u222b x in A, Y2 x \u2202P = \u222b x in A, X x \u2202P) :\n  \u2200 (A : Set \u03a9), A \u2208 G1 \u2192 \u222b x in A, Y1 x \u2202P = \u222b x in A, Y2 x \u2202P := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 3, "endLine": 9, "endColumn": 48, "data": "invalid binder annotation, type is not a class instance\n  ?m.64\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {\u03a9 : Type*} {\u2131 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  (X Y1 Y2 : \u03a9 \u2192 \u211d)\n  (G1 : MeasurableSpace \u03a9)\n  (hY1 : Measurable Y1)\n  (hY2 : Measurable Y2)\n  (l2 : \u2200 (A : Set \u03a9), MeasurableSet[A] \u2192 \u222b x in A, Y1 x \u2202P = \u222b x in A, X x \u2202P)\n  (l5 : \u2200 (A : Set \u03a9), MeasurableSet[A] \u2192 \u222b x in A, Y2 x \u2202P = \u222b x in A, X x \u2202P) :\n  \u2200 (A : Set \u03a9), MeasurableSet[A] \u2192 \u222b x in A, Y1 x \u2202P = \u222b x in A, Y2 x \u2202P := by\n  intro A hA\n  rw [l2 A hA, l5 A hA]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 23, "endLine": 11, "endColumn": 39, "data": "failed to synthesize\n  GetElem (Set ?m.259 \u2192 Prop) (Set \u03a9) ?m.255 ?m.256\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 12, "column": 23, "endLine": 12, "endColumn": 39, "data": "failed to synthesize\n  GetElem (Set ?m.690 \u2192 Prop) (Set \u03a9) ?m.686 ?m.687\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 13, "column": 17, "endLine": 13, "endColumn": 33, "data": "failed to synthesize\n  GetElem (Set ?m.963 \u2192 Prop) (Set \u03a9) ?m.959 ?m.960\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 6, "column": 43, "endLine": 6, "endColumn": 52, "data": "function expected at\n  Measure\nterm has type\n  ?m.9"}, {"line": 11, "column": 23, "endLine": 11, "endColumn": 39, "data": "failed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nMeasure : ?m.9\n\u03a9 : Type u_1\n\u2131 : MeasurableSpace \u03a9\nP : sorry\nX Y1 Y2 : \u03a9 \u2192 \u211d\nG1 : MeasurableSpace \u03a9\nhY1 : Measurable Y1\nhY2 : Measurable Y2\nA : Set \u03a9\n\u22a2 ?m.256 MeasurableSet A"}, {"line": 12, "column": 23, "endLine": 12, "endColumn": 39, "data": "failed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nMeasure : ?m.9\n\u03a9 : Type u_1\n\u2131 : MeasurableSpace \u03a9\nP : sorry\nX Y1 Y2 : \u03a9 \u2192 \u211d\nG1 : MeasurableSpace \u03a9\nhY1 : Measurable Y1\nhY2 : Measurable Y2\nl2 : \u2200 (A : Set \u03a9), sorry \u2192 \u222b (x : \u03a9) in A, Y1 x \u2202?m.432 = \u222b (x : \u03a9) in A, X x \u2202?m.628\nA : Set \u03a9\n\u22a2 ?m.687 MeasurableSet A"}, {"line": 13, "column": 17, "endLine": 13, "endColumn": 33, "data": "failed to prove index is valid, possible solutions:\n  - Use `have`-expressions to prove the index is valid\n  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid\n  - Use `a[i]?` notation instead, result is an `Option` type\n  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid\nMeasure : ?m.9\n\u03a9 : Type u_1\n\u2131 : MeasurableSpace \u03a9\nP : sorry\nX Y1 Y2 : \u03a9 \u2192 \u211d\nG1 : MeasurableSpace \u03a9\nhY1 : Measurable Y1\nhY2 : Measurable Y2\nl2 : \u2200 (A : Set \u03a9), sorry \u2192 \u222b (x : \u03a9) in A, Y1 x \u2202?m.432 = \u222b (x : \u03a9) in A, X x \u2202?m.628\nl5 : \u2200 (A : Set \u03a9), sorry \u2192 \u222b (x : \u03a9) in A, Y2 x \u2202?m.862 = \u222b (x : \u03a9) in A, X x \u2202?m.902\nA : Set \u03a9\n\u22a2 ?m.960 MeasurableSet A"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since $Y_1$ is $\\mathcal{G}_1$-measurable and satisfies $\\int_A Y_1 dP = \\int_A Y_2 dP$ for all $A \\in \\mathcal{G}_1$, $Y_1$ is by definition the conditional expectation of $Y_2$ given $\\mathcal{G}_1$. Thus, $Y_1 = E[Y_2 | \\mathcal{G}_1]$, which means $E[X | \\mathcal{G}_1] = E[E[X | \\mathcal{G}_2] | \\mathcal{G}_1]$ almost surely.", "statement": "We assume:\n\u2022 $X$ is an integrable random variable [tc_1]\n\u2022 $Y_1 = E[X | \\mathcal{G}_1]$ [def_1]\n\u2022 $Y_2 = E[X | \\mathcal{G}_2]$ [def_2]\n\u2022 $Y_1$ is $\\mathcal{G}_1$-measurable [l1]\n\u2022 For any set $A \\in \\mathcal{G}_1$, we have $\\int_A Y_1 dP = \\int_A Y_2 dP$ [l6]\nTherefore, we conclude:\n\u2022 $Y_1$ fulfills the two defining properties of the conditional expectation of $Y_2$ given $\\mathcal{G}_1$. Thus, $Y_1 = E[Y_2 | \\mathcal{G}_1]$ a.s. Substituting the definitions of $Y_1$ and $Y_2$, we get $E[X | \\mathcal{G}_1] = E[E[X | \\mathcal{G}_2] | \\mathcal{G}_1]$ a.s. [ts_1].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03a9 : Type*} {\u03b1 : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03b1] {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u03b1} [IsFiniteMeasure P] [NormedAddCommGroup \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [CompleteSpace \u03b1] [Integrable X P]\n  {\ud835\udca2\u2081 \ud835\udca2\u2082 : MeasurableSpace \u03a9} [IsSubsingleton (\ud835\udca2\u2081 : MeasurableSpace \u03a9)] [IsSubsingleton (\ud835\udca2\u2082 : MeasurableSpace \u03a9)]\n  (tc_1 :  Integrable X P)\n  (def_1 : \u2200 (Y\u2081 : \u03a9 \u2192 \u03b1), Y\u2081 = (MeasureTheory.condexp \ud835\udca2\u2081 X P))\n  (def_2 : \u2200 (Y\u2082 : \u03a9 \u2192 \u03b1), Y\u2082 = (MeasureTheory.condexp \ud835\udca2\u2082 X P))\n  (l1 : Measurable[\ud835\udca2\u2081] (MeasureTheory.condexp \ud835\udca2\u2081 X P))\n  (l6 : \u2200 (A : Set \u03a9), A \u2208 \ud835\udca2\u2081 \u2192 \u222b\u207b \u03c9 in A, \u2016(MeasureTheory.condexp \ud835\udca2\u2081 X P) \u03c9\u2016 \u2202P = \u222b\u207b \u03c9 in A, \u2016(MeasureTheory.condexp \ud835\udca2\u2082 X P) \u03c9\u2016 \u2202P) :\n  (MeasureTheory.condexp \ud835\udca2\u2081 X P) = (MeasureTheory.condexp \ud835\udca2\u2081 (MeasureTheory.condexp \ud835\udca2\u2082 X P) P) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 15, "endLine": 7, "endColumn": 32, "data": "invalid binder annotation, type is not a class instance\n  ?m.60\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03a9 : Type*} {\u03b1 : Type*} [MeasurableSpace \u03a9] [MeasurableSpace \u03b1] {P : Measure \u03a9}\n  {X : \u03a9 \u2192 \u03b1} [IsFiniteMeasure P] [NormedAddCommGroup \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1] [CompleteSpace \u03b1] (hX : Integrable X P)\n  {\ud835\udca2\u2081 \ud835\udca2\u2082 : MeasurableSpace \u03a9} (h\ud835\udca2\u2081 : IsSubsingleton \ud835\udca2\u2081) (h\ud835\udca2\u2082 : IsSubsingleton \ud835\udca2\u2082)\n  (Y\u2081 : \u03a9 \u2192 \u03b1) (Y\u2082 : \u03a9 \u2192 \u03b1) (def_1 : Y\u2081 = MeasureTheory.condexp \ud835\udca2\u2081 P X)\n  (def_2 : Y\u2082 = MeasureTheory.condexp \ud835\udca2\u2082 P X)\n  (l1 : Measurable[\ud835\udca2\u2081] Y\u2081)\n  (l6 : \u2200 (A : Set \u03a9), MeasurableSet[\ud835\udca2\u2081] A \u2192 \u222b\u207b \u03c9 in A, \u2016Y\u2081 \u03c9\u2016 \u2202P = \u222b\u207b \u03c9 in A, \u2016Y\u2082 \u03c9\u2016 \u2202P) :\n  Y\u2081 =\u1d50[P] MeasureTheory.condexp \ud835\udca2\u2081 P Y\u2082 := by\n  rw [def_1, def_2]\n  refine MeasureTheory.condexp_unique \ud835\udca2\u2081 P ?_ ?_\n  \u00b7 exact l1\n  \u00b7 intro A hA\n    rw [\u2190 MeasureTheory.set_lintegral_condexp \ud835\udca2\u2081 P X hA, \u2190 l6 A hA, MeasureTheory.set_lintegral_condexp \ud835\udca2\u2082 P X hA]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 15, "endLine": 7, "endColumn": 32, "data": "invalid binder annotation, type is not a class instance\n  ?m.60\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}, "def_3": {"id": "def_3", "natural_language": "recall that for the trivial $\\sigma$-algebra $\\mathcal{G}_{\\text{trivial}} = \\{\\emptyset, \\Omega\\}$", "statement": "Definition:\n\u2022 Let $\\mathcal{G}_{\\text{trivial}}$ denote the trivial $\\sigma$-algebra, defined as $\\mathcal{G}_{\\text{trivial}} = \\{\\emptyset, \\Omega\\}$ [def_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9}\nvariable (def_3 : {s : Set \u03a9 | s = \u2205 \u2228 s = Set.univ})", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean code defines def_3 as a set comprehension but doesn't explicitly identify it as a \u03c3-algebra or as the trivial \u03c3-algebra. The mathematical content is correct but lacks the conceptual identification as a \u03c3-algebra structure.", "The Lean definition {s : Set \u03a9 | s = \u2205 \u2228 s = Set.univ} is mathematically equivalent to {\u2205, \u03a9}, where Set.univ corresponds to \u03a9 and \u2205 is the empty set."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean code defines def_3 as a set comprehension but doesn't explicitly identify it as a \u03c3-algebra or as the trivial \u03c3-algebra. The mathematical content is correct but lacks the conceptual identification as a \u03c3-algebra structure.\", 'The Lean definition {s : Set \u03a9 | s = \u2205 \u2228 s = Set.univ} is mathematically equivalent to {\u2205, \u03a9}, where Set.univ corresponds to \u03a9 and \u2205 is the empty set.']"}, "type": "definition"}, "l7": {"id": "l7", "natural_language": "the conditional expectation $E[Y | \\mathcal{G}_{\\text{trivial}}]$ is the constant $E[Y]$ for any integrable random variable $Y$.", "statement": "We assume:\n\u2022 Let $Y$ be any integrable random variable on $(\\Omega, \\mathcal{F}, P)$.\n\u2022 $\\mathcal{G}_{\\text{trivial}} = \\{\\emptyset, \\Omega\\}$ [def_3]\nTherefore, we conclude:\n\u2022 $E[Y | \\mathcal{G}_{\\text{trivial}}]$ is equal to the constant random variable $E[Y]$ [l7].", "dependencies": ["def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} [MeasureSpace \u03a9]\n  {Y : \u03a9 \u2192 \u211d} [SigmaAlgebra K]\n  (hY_integrable : Integrable Y (Measure.dirac default))\n  (def_3 : {s : Set \u03a9 | s = \u2205 \u2228 s = Set.univ}) :\n  condExp Y (by exact trivial) = fun _ => \u222b x, Y x \u2202(Measure.dirac default) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 6, "column": 40, "endLine": 6, "endColumn": 54, "data": "invalid binder annotation, type is not a class instance\n  ?m.18\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} [MeasureSpace \u03a9]\n  {Y : \u03a9 \u2192 \u211d} (hY_integrable : Integrable Y)\n  (def_3 : {s : Set \u03a9 | s = \u2205 \u2228 s = Set.univ} = \u22a5) :\n  condExp m\u03a9 Y \u22a5 = fun _ => \u222b x, Y x \u2202(volume : Measure \u03a9) := by\n  simp [condExp, condCovariance, condKernel, condDistrib, condProb]\n  rw [def_3]\n  simp\n  exact hY_integrable.aestronglyMeasurable", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 6, "column": 40, "endLine": 6, "endColumn": 54, "data": "invalid binder annotation, type is not a class instance\n  ?m.18\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "By setting $\\mathcal{G}_1$ to be the trivial $\\sigma$-algebra $\\{\\emptyset, \\Omega\\}$ in the tower property, we get $E[X | \\{\\emptyset, \\Omega\\}] = E[E[X | \\mathcal{G}_2] | \\{\\emptyset, \\Omega\\}]$.", "statement": "We assume:\n\u2022 $E[X | \\mathcal{G}_1] = E[E[X | \\mathcal{G}_2] | \\mathcal{G}_1]$ a.s. [ts_1]\n\u2022 $\\mathcal{G}_{\\text{trivial}} = \\{\\emptyset, \\Omega\\}$ is a sub-$\\sigma$-algebra of $\\mathcal{G}_2$ [tc_2]\nTherefore, we conclude:\n\u2022 By substituting $\\mathcal{G}_1 = \\mathcal{G}_{\\text{trivial}}$ into the tower property, we obtain $E[X | \\mathcal{G}_{\\text{trivial}}] = E[E[X | \\mathcal{G}_2] | \\mathcal{G}_{\\text{trivial}}]$ [l8].", "dependencies": ["ts_1", "tc_2", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  [IsProbabilityMeasure P]\n  (X : \u03a9 \u2192 \u211d) [Mem\u2113\u00b9 X P]\n  (scriptG1 scriptG2 : MeasurableSpace \u03a9)\n  [h_sub_scriptG1 : scriptG1 \u2264 m\u03a9]\n  [h_sub_scriptG2 : scriptG2 \u2264 m\u03a9]\n  (ts_1 : @firstPartialConditionalExpectation_eq_towerOfConditionalExpectations_a_e \u03a9 m\u03a9 P X scriptG1 scriptG2)\n  (def_3 : MeasurableSpace.trivial \u2264 scriptG2) :\n  @firstPartialConditionalExpectation_eq_towerOfConditionalExpectations_a_e \u03a9 m\u03a9 P X MeasurableSpace.trivial scriptG2 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 19, "endLine": 8, "endColumn": 20, "data": "unexpected token '\u00b9'; expected ']'"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} {P : Measure \u03a9}\n  [IsProbabilityMeasure P]\n  (X : \u03a9 \u2192 \u211d) [IsFiniteMeasure P] [Integrable X P]\n  (scriptG1 scriptG2 : MeasurableSpace \u03a9)\n  [h_sub_scriptG1 : MeasurableSpace.IsSubscriptG scriptG1 m\u03a9]\n  [h_sub_scriptG2 : MeasurableSpace.IsSubscriptG scriptG2 m\u03a9]\n  (ts_1 : \u2200 s, MeasurableSet[m\u03a9] s \u2192 (\u222b \u03c9 in s, X \u03c9 \u2202P) = \u222b \u03c9 in s, condExp scriptG2 X P \u03c9 \u2202P)\n  (def_3 : MeasurableSpace.trivial \u2264 scriptG2) :\n  \u2200 s, MeasurableSet[m\u03a9] s \u2192 (\u222b \u03c9 in s, X \u03c9 \u2202P) = \u222b \u03c9 in s, condExp scriptG2 X P \u03c9 \u2202P := by\n  intro s hs\n  rw [ts_1 s hs]\n  simp [condExp, integral_const]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 3, "endLine": 7, "endColumn": 25, "data": "invalid binder annotation, type is not a class instance\n  ?m.34\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Applying the property of conditioning on the trivial $\\sigma$-algebra to both sides, we obtain the law of total expectation: $E[X] = E[E[X | \\mathcal{G}_2]]$.", "statement": "We assume:\n\u2022 $X$ is an integrable random variable [tc_1]\n\u2022 $E[Y | \\mathcal{G}_{\\text{trivial}}] = E[Y]$ for any integrable random variable $Y$ [l7]\n\u2022 $E[X | \\mathcal{G}_{\\text{trivial}}] = E[E[X | \\mathcal{G}_2] | \\mathcal{G}_{\\text{trivial}}]$ [l8]\nTherefore, we conclude:\n\u2022 $E[X] = E[E[X | \\mathcal{G}_2]]$ [ts_2].", "dependencies": ["tc_1", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nopen MeasureTheory ENNReal ProbabilityTheory\n\nlemma ts_2\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} (P : Measure \u03a9)\n  [IsProbabilityMeasure P]\n  {\u03b1 : Type*} [MeasureSpace \u03b1] [MeasurableSpace \u03b1]\n  (X : \u03a9 \u2192 \u03b1) [Measurable X] [Integrable X P]\n  (G2 : MeasurableSpace \u03a9) [Subsingleton (P.trim G2).ae]\n  (tc_1 : Integrable X P)\n  (l7 : \u2200 (Y : \u03a9 \u2192 \u211d) [Measurable Y] [Integrable Y P], condexp (m\u03a9.trivial) Y P = fun _ => \u222b\u207b \u03c9, \u2016Y \u03c9\u2016 \u2202P) -- Simplified l7 for direct use\n  (l8 : condexp (m\u03a9.trivial) X P = condexp (m\u03a9.trivial) (condexp G2 X P) P) :\n  \u222b \u03c9, X \u03c9 \u2202P = \u222b \u03c9, (condexp G2 X P) \u03c9 \u2202P := by\nsorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 15, "endLine": 11, "endColumn": 27, "data": "invalid binder annotation, type is not a class instance\n  Measurable X\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nopen MeasureTheory ENNReal ProbabilityTheory\n\nlemma ts_2\n  {\u03a9 : Type*} {m\u03a9 : MeasurableSpace \u03a9} (P : Measure \u03a9)\n  [IsProbabilityMeasure P]\n  (X : \u03a9 \u2192 \u211d) [Integrable X P]\n  (G2 : MeasurableSpace \u03a9) [hG2 : IsProbabilityMeasure (P.trim G2)]\n  (tc_1 : Integrable X P)\n  (l7 : \u2200 (Y : \u03a9 \u2192 \u211d), Integrable Y P \u2192 condexp m\u03a9 Y P = fun _ => \u222b \u03c9, Y \u03c9 \u2202P)\n  (l8 : condexp m\u03a9 X P = condexp m\u03a9 (condexp G2 X P) P) :\n  \u222b \u03c9, X \u03c9 \u2202P = \u222b \u03c9, (condexp G2 X P) \u03c9 \u2202P := by\n  rw [\u2190 l7 X tc_1, l8, l7 (condexp G2 X P) (integrable_condexp.integrable_norm)]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 15, "endLine": 10, "endColumn": 29, "data": "invalid binder annotation, type is not a class instance\n  Integrable X P\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    