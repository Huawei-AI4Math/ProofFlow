
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $f(z) = \frac{1}{(z-1)(z-3)}$. If the Laurent series for $f(z)$ is centered at $z_0=1$ and is valid for the annulus $0 < |z-1| < 2$, then the series is given by $f(z) = -\frac{1}{2(z-1)} - \sum_{n=0}^{\infty} \frac{(z-1)^n}{2^{n+2}}$.

Proof: First, we perform a partial fraction decomposition of $f(z)$ to get $f(z) = -\frac{1}{2(z-1)} + \frac{1}{2(z-3)}$. For the second term, $\frac{1}{2(z-3)}$, we manipulate it to be centered at $z=1$: $\frac{1}{2(z-3)} = \frac{1}{2((z-1)-2)} = -\frac{1}{4(1 - \frac{z-1}{2})}$. Since the series must be valid for $|z-1|<2$, we have $|\frac{z-1}{2}|<1$, allowing the use of the geometric series formula, which gives $-\frac{1}{4} \sum_{n=0}^{\infty} (\frac{z-1}{2})^n = -\sum_{n=0}^{\infty} \frac{(z-1)^n}{2^{n+2}}$. Finally, combining the first term from the partial fraction decomposition with the series expansion of the second term gives the complete Laurent series: $f(z) = -\frac{1}{2(z-1)} - \sum_{n=0}^{\infty} \frac{(z-1)^n}{2^{n+2}}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f(z) = \\frac{1}{(z-1)(z-3)}$.", "statement": "Premise:\n\u2022 $f$ is a complex function defined as $f(z) = \\frac{1}{(z-1)(z-3)}$ for complex numbers $z$ where the denominator is non-zero [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean declaration `(f : \u2102 \u2192 \u2102)` perfectly captures that f is a complex function", "The Lean formulation uses an implication `(z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3))` which is logically equivalent to the natural language statement but structurally different. The natural language states the formula directly with the implicit understanding that it applies when the denominator is non-zero", "The condition `(z - 1) * (z - 3) \u2260 0` in the Lean implication perfectly matches the natural language requirement that the denominator be non-zero", "The Lean formalization implicitly captures this conclusion through the conditional statement, but doesn't explicitly state the domain restriction. The implication structure means f is only defined by this formula when the denominator is non-zero, which is equivalent but not a direct translation of the conclusion"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean declaration `(f : \u2102 \u2192 \u2102)` perfectly captures that f is a complex function', 'The Lean formulation uses an implication `(z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3))` which is logically equivalent to the natural language statement but structurally different. The natural language states the formula directly with the implicit understanding that it applies when the denominator is non-zero', 'The condition `(z - 1) * (z - 3) \u2260 0` in the Lean implication perfectly matches the natural language requirement that the denominator be non-zero', \"The Lean formalization implicitly captures this conclusion through the conditional statement, but doesn't explicitly state the domain restriction. The implication structure means f is only defined by this formula when the denominator is non-zero, which is equivalent but not a direct translation of the conclusion\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If the Laurent series for $f(z)$ is centered at $z_0=1$ and is valid for the annulus $0 < |z-1| < 2$", "statement": "Premise:\n\u2022 $f(z) = \\frac{1}{(z-1)(z-3)}$ [tc_1]\n\u2022 The Laurent series for $f(z)$ is centered at $z_0=1$ and is valid for the annulus $A = \\{z \\in \\mathbb{C} : 0 < |z-1| < 2\\}$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3)))\n  (tc_2 : IsLaurentSeries f 1 (Metric.ball 1 2 \\ {1}))", "lean_pass": false, "error_msg": [{"line": 8, "column": 10, "endLine": 8, "endColumn": 53, "data": "function expected at\n  IsLaurentSeries\nterm has type\n  ?m.411"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, we perform a partial fraction decomposition of $f(z)$ to get $f(z) = -\\frac{1}{2(z-1)} + \\frac{1}{2(z-3)}$.", "statement": "We assume:\n\u2022 $f(z) = \\frac{1}{(z-1)(z-3)}$ [tc_1]\nTherefore, we conclude:\n\u2022 $f(z) = -\\frac{1}{2(z-1)} + \\frac{1}{2(z-3)}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3))) :\n  \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = - (1 / (2 * (z - 1))) + (1 / (2 * (z - 3))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3))) :\n  \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = - (1 / (2 * (z - 1))) + (1 / (2 * (z - 3))) := by\n  intro z hz\n  rw [tc_1 z hz]\n  field_simp [hz]\n  ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 90, "endLine": 12, "endColumn": 6, "data": "unsolved goals\nf : \u2102 \u2192 \u2102\ntc_1 : \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3))\nz : \u2102\nhz : (z - 1) * (z - 3) \u2260 0\n\u22a2 1 =\n    z * (-2 + z * 2)\u207b\u00b9 * 4 + (-(z * (-6 + z * 2)\u207b\u00b9 * 4) - z ^ 2 * (-2 + z * 2)\u207b\u00b9) +\n        (z ^ 2 * (-6 + z * 2)\u207b\u00b9 - (-2 + z * 2)\u207b\u00b9 * 3) +\n      (-6 + z * 2)\u207b\u00b9 * 3"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function definition in Lean correctly captures the natural language assumption, with the addition of appropriate domain restrictions (non-zero denominator conditions) that are mathematically necessary but implicit in the natural language.", "The conclusion in Lean perfectly matches the natural language statement, expressing the same partial fraction decomposition with consistent domain restrictions applied throughout.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l1\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = 1 / ((z - 1) * (z - 3))) :\n  \u00ac \u2200 (z : \u2102), (z - 1) * (z - 3) \u2260 0 \u2192 f z = - (1 / (2 * (z - 1))) + (1 / (2 * (z - 3))) := by\n  intro h\n  have h2 : f 2 = 1 / ((2 - 1) * (2 - 3)) := tc_1 2 (by norm_num)\n  have h3 : f 2 = - (1 / (2 * (2 - 1))) + (1 / (2 * (2 - 3))) := h 2 (by norm_num)\n  simp at h2 h3\n  field_simp at h2 h3\n  norm_num at h2 h3\n  rw [h3] at h2\n  norm_num at h2"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "$\\frac{1}{2(z-3)} = \\frac{1}{2((z-1)-2)} = -\\frac{1}{4(1 - \\frac{z-1}{2})}$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $z \\neq 3$.\nTherefore, we conclude:\n\u2022 The algebraic identity $\\frac{1}{2(z-3)} = -\\frac{1}{4(1 - \\frac{z-1}{2})}$ holds [l2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (z : \u2102) (hz : z \u2260 3) :\n  (1 / (2 * (z - 3))) = (-1 / (4 * (1 - (z - 1) / 2))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (z : \u2102) (hz : z \u2260 3) :\n  (1 / (2 * (z - 3))) = (-1 / (4 * (1 - (z - 1) / 2))) := by\n  field_simp\n  ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 58, "endLine": 9, "endColumn": 6, "data": "unsolved goals\nz : \u2102\nhz : z \u2260 3\n\u22a2 (-6 + z * 2)\u207b\u00b9 = -((12 - z * 4)\u207b\u00b9 * 2)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all components from the natural language statement. The complex number type declaration, the constraint z \u2260 3, and the algebraic identity are all properly represented. The mathematical expression is accurately translated from mathematical notation to Lean syntax while preserving the exact same algebraic meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l2 :\n    \u2203 (z : \u2102), z \u2260 3 \u2227 (1 / (2 * (z - 3))) \u2260 (-1 / (4 * (1 - (z - 1) / 2))) := by\n  use 4\n  constructor\n  \u00b7 simp\n  \u00b7 field_simp\n    ring_nf\n    norm_num"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since the series must be valid for $|z-1|<2$, we have $|\\frac{z-1}{2}|<1$", "statement": "We assume:\n\u2022 $z$ is a complex number in the annulus $A = \\{z \\in \\mathbb{C} : 0 < |z-1| < 2\\}$ [tc_2]\nTherefore, we conclude:\n\u2022 The inequality $|\\frac{z-1}{2}| < 1$ holds [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (z : \u2102)\n  (tc_2 : 0 < |z - 1| \u2227 |z - 1| < 2) :\n  | (z - 1) / 2 | < 1 := by\nsorry", "lean_pass": false, "error_msg": [], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (z : \u2102)\n  (tc_2 : 0 < |z - 1| \u2227 |z - 1| < 2) :\n  | (z - 1) / 2 | < 1 := by\n  rw [Complex.norm_div]\n  simp only [Complex.norm_two]\n  apply div_lt_one_of_lt (by norm_num) tc_2.2", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "allowing the use of the geometric series formula, which gives $-\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n$", "statement": "We assume:\n\u2022 The identity $\\frac{1}{2(z-3)} = -\\frac{1}{4(1 - \\frac{z-1}{2})}$ holds [l2]\n\u2022 For $z$ in the annulus of convergence, we have $|\\frac{z-1}{2}| < 1$ [l3]\nTherefore, we conclude:\n\u2022 For $z$ in the annulus, $\\frac{1}{2(z-3)} = -\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n$ [l4].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {A : Set \u2102} (z : \u2102) (hz : z \u2208 A) (l2 : 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)))\n  (l3 : Complex.abs ((z - 1) / 2) < 1) :\n  1 / (2 * (z - 3)) = -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {A : Set \u2102} (z : \u2102) (hz : z \u2208 A) (l2 : 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)))\n  (l3 : Complex.abs ((z - 1) / 2) < 1) :\n  1 / (2 * (z - 3)) = -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) := by\n  rw [l2]\n  simp only [mul_div_assoc, div_eq_mul_inv, mul_inv]\n  rw [\u2190 mul_assoc, \u2190 mul_assoc]\n  congr 1\n  have := hasSum_geometric_of_abs_lt_1 l3\n  simp_rw [div_eq_mul_inv] at this\n  exact this.tsum_eq.symm", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 19, "endLine": 11, "endColumn": 30, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a * (?b * ?c)\nA : Set \u2102\nz : \u2102\nhz : z \u2208 A\nl2 : 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2))\nl3 : Complex.abs ((z - 1) / 2) < 1\n\u22a2 -1 * 4\u207b\u00b9 * (1 - (z - 1) * 2\u207b\u00b9)\u207b\u00b9 = -1 * 4\u207b\u00b9 * \u2211' (n : \u2115), ((z - 1) * 2\u207b\u00b9) ^ n"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The mathematical identity l2 is correctly formalized with proper complex arithmetic notation", "The convergence condition l3 accurately captures the absolute value constraint using Complex.abs", "The conclusion l4 properly represents the infinite series using Lean's infinite sum notation", "The variable context appropriately formalizes 'z in the annulus' with set membership, providing necessary mathematical rigor", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  {A : Set \u2102} (z : \u2102) (hz : z \u2208 A) (l2 : 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)))\n  (l3 : Complex.abs ((z - 1) / 2) < 1) :\n  \u00ac (1 / (2 * (z - 3)) = -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n)) := by\n  intro h\n  have h_series : \u2211' (n : \u2115), ((z - 1) / 2) ^ n = 1 / (1 - (z - 1) / 2) := by\n    simp_rw [\u2190 Complex.norm_eq_abs]\n    exact summable_geometric_of_norm_lt_1 l3 |>.tsum_eq\n  rw [h_series] at h\n  rw [l2] at h\n  field_simp at h\n  norm_num at h\n  contradiction"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "= -\\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}.", "statement": "We assume:\n\u2022 We have the series expression $-\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n$ from the previous step [l4]\nTherefore, we conclude:\n\u2022 The identity $-\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n = -\\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$ holds [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (z : \u2102)\n  (l4 : -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) = -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n)) :\n  -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) = - (\u2211' (n : \u2115), ((z - 1) ^ n) / (2 ^ (n + 2))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (z : \u2102) :\n  -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) = - (\u2211' (n : \u2115), ((z - 1) ^ n) / (2 ^ (n + 2))) := by\n  simp_rw [div_pow]\n  congr\n  ext n\n  rw [pow_add, mul_comm (2 ^ n), \u2190div_div]\n  simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 2, "endLine": 10, "endColumn": 7, "data": "no applicable extensionality theorem found for\n  \u2102"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization has a major inconsistency with the natural language. While both state the same mathematical identity, the premise l4 in Lean is a meaningless tautology rather than providing the series expression as claimed in the natural language. More critically, the mathematical identity being claimed is actually false in general - the two sides are not equal for arbitrary complex z. The natural language presents this as a valid conclusion, but the Lean formalization appropriately treats it as something requiring proof (with sorry), suggesting recognition that the identity is not trivially true.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization has a major inconsistency with the natural language. While both state the same mathematical identity, the premise l4 in Lean is a meaningless tautology rather than providing the series expression as claimed in the natural language. More critically, the mathematical identity being claimed is actually false in general - the two sides are not equal for arbitrary complex z. The natural language presents this as a valid conclusion, but the Lean formalization appropriately treats it as something requiring proof (with sorry), suggesting recognition that the identity is not trivially true.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Finally, combining the first term from the partial fraction decomposition with the series expansion of the second term gives the complete Laurent series: $f(z) = -\\frac{1}{2(z-1)} - \\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$.", "statement": "We assume:\n\u2022 $f(z) = -\\frac{1}{2(z-1)} + \\frac{1}{2(z-3)}$ [l1]\n\u2022 For $z$ in the annulus, $\\frac{1}{2(z-3)} = -\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n$ [l4]\n\u2022 The identity $-\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n = -\\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$ holds [l5]\nTherefore, we conclude:\n\u2022 For $z$ in the annulus $0 < |z-1| < 2$, the Laurent series is $f(z) = -\\frac{1}{2(z-1)} - \\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$ [ts_1].", "dependencies": ["l1", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (f : \u2102 \u2192 \u2102) (z : \u2102) (A : Set \u2102)\n  (l1 : (z - 1) * (z - 3) \u2260 0 \u2192 f z = -(1 / (2 * (z - 1))) + (1 / (2 * (z - 3))))\n  (l4 : z \u2208 A \u2192 1 / (2 * (z - 3)) = -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n))\n  (l5 : -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) = -(\u2211' (n : \u2115), ((z - 1) ^ n) / (2 ^ (n + 2)))) :\n  0 < Complex.abs (z - 1) \u2227 Complex.abs (z - 1) < 2 \u2192 f z = - (1 / (2 * (z - 1))) - (\u2211' (n : \u2115), ((z - 1) ^ n) / (2 ^ (n + 2))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (f : \u2102 \u2192 \u2102) (z : \u2102) (A : Set \u2102)\n  (l1 : (z - 1) * (z - 3) \u2260 0 \u2192 f z = -(1 / (2 * (z - 1))) + (1 / (2 * (z - 3))))\n  (l4 : z \u2208 A \u2192 1 / (2 * (z - 3)) = -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n))\n  (l5 : -1 / 4 * (\u2211' (n : \u2115), ((z - 1) / 2) ^ n) = -(\u2211' (n : \u2115), ((z - 1) ^ n) / (2 ^ (n + 2)))) :\n  0 < Complex.abs (z - 1) \u2227 Complex.abs (z - 1) < 2 \u2192 f z = - (1 / (2 * (z - 1))) - (\u2211' (n : \u2115), ((z - 1) ^ n) / (2 ^ (n + 2))) := by\n  intro h\n  have hz : (z - 1) * (z - 3) \u2260 0 := by\n    intro h'\n    cases mul_eq_zero.mp h' with\n    | inl h1 => exact h.1.ne' (Complex.abs_eq_zero.mp (le_antisymm (le_of_lt h.1) (Complex.abs.nonneg _)))\n    | inr h3 => have := h.2; simp [h3] at this; linarith\n  rw [l1 hz]\n  have hA : z \u2208 A := by sorry\n  rw [l4 hA, l5]\n  ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 31, "endLine": 15, "endColumn": 105, "data": "unknown constant 'Complex.abs_eq_zero.mp'"}, {"line": 16, "column": 48, "endLine": 16, "endColumn": 56, "data": "linarith failed to find a contradiction\ncase inr\nf : \u2102 \u2192 \u2102\nz : \u2102\nA : Set \u2102\nl1 : (z - 1) * (z - 3) \u2260 0 \u2192 f z = -(1 / (2 * (z - 1))) + 1 / (2 * (z - 3))\nl4 : z \u2208 A \u2192 1 / (2 * (z - 3)) = -1 / 4 * \u2211' (n : \u2115), ((z - 1) / 2) ^ n\nl5 : -1 / 4 * \u2211' (n : \u2115), ((z - 1) / 2) ^ n = -\u2211' (n : \u2115), (z - 1) ^ n / 2 ^ (n + 2)\nh : 0 < Complex.abs (z - 1) \u2227 Complex.abs (z - 1) < 2\nh' : (z - 1) * (z - 3) = 0\nh3 : z - 3 = 0\nthis : Complex.abs (z - 1) < 2\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function definition is correctly formalized with an appropriate well-definedness condition added.", "The series expansion uses generic set A instead of the specific annulus, creating a disconnect in the logical chain.", "The algebraic identity is perfectly captured in Lean notation.", "The conclusion correctly formalizes the annulus and Laurent series, but doesn't properly connect to the premises due to the A vs annulus mismatch.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The function definition is correctly formalized with an appropriate well-definedness condition added.', 'The series expansion uses generic set A instead of the specific annulus, creating a disconnect in the logical chain.', 'The algebraic identity is perfectly captured in Lean notation.', \"The conclusion correctly formalizes the annulus and Laurent series, but doesn't properly connect to the premises due to the A vs annulus mismatch.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    