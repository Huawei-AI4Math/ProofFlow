
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = 3n^2 - 3n + 1$. Let the partial sum be $S_N = \sum_{n=1}^{N} a_n$. Prove that $S_N = N^3$ for all integers $N \geq 1$.

Proof: We will prove this by induction on $N$. First, for the base case $N=1$, we have $S_1 = a_1$. We calculate $a_1=3(1)^2-3(1)+1 = 3-3+1 = 1$. The formula for the sum gives $1^3=1$. So $S_1 = 1^3$, which holds. Now, for the inductive step, we assume the statement is true for some integer $k \geq 1$, which means $S_k = k^3$. We want to show that the statement is true for $k+1$, i.e., $S_{k+1} = (k+1)^3$. We know that $S_{k+1} = S_k + a_{k+1}$. From the inductive hypothesis, $S_k = k^3$, and we have $a_{k+1} = 3(k+1)^2-3(k+1)+1$. So we need to show that $k^3 + 3(k+1)^2-3(k+1)+1 = (k+1)^3$. We expand the terms on the left side: $3(k+1)^2 = 3(k^2+2k+1) = 3k^2+6k+3$. Also, $-3(k+1) = -3k-3$. So the left side becomes $k^3 + (3k^2+6k+3) + (-3k-3) + 1 = k^3 + 3k^2+3k+1$. The right side is $(k+1)^3 = k^3+3k^2+3k+1$. Since the left side equals the right side, the statement is true for $k+1$. By the principle of mathematical induction, the statement is true for all integers $N \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = 3n^2 - 3n + 1$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer $n \\geq 1$, $a_n = 3n^2 - 3n + 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly represents a sequence of real numbers as a function from natural numbers to real numbers.", "The natural language specifies 'integer n \u2265 1' while Lean uses natural numbers with n \u2265 1. Since natural numbers with n \u2265 1 effectively covers positive integers, the mathematical meaning is preserved, but there's a slight difference in the domain specification."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly represents a sequence of real numbers as a function from natural numbers to real numbers.', \"The natural language specifies 'integer n \u2265 1' while Lean uses natural numbers with n \u2265 1. Since natural numbers with n \u2265 1 effectively covers positive integers, the mathematical meaning is preserved, but there's a slight difference in the domain specification.\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let the partial sum be $S_N = \\sum_{n=1}^{N} a_n$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer $n \\geq 1$, $a_n = 3n^2 - 3n + 1$ [tc_1].\n\u2022 The partial sum $S_N$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for any integer $N \\geq 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1)\n(tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 \u2211 n in Finset.range (N + 1) \\ Finset.range 1, a n = a N + \u2211 n in Finset.range N \\ Finset.range 1, a n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition. The variable declaration `a : \u2115 \u2192 \u211d` establishes a sequence of real numbers, and `tc_1` precisely matches the mathematical formula $a_n = 3n^2 - 3n + 1$ for $n \u2265 1$, with appropriate type casting from natural numbers to reals.", "The Lean formalization does not properly define the partial sum $S_N$. The natural language defines $S_N = \\sum_{n=1}^{N} a_n$, but `tc_2` instead states a recursive relationship $\\sum_{n=1}^{N} a_n = a_N + \\sum_{n=1}^{N-1} a_n$, which is a tautological identity rather than a definition of $S_N$. The Lean code is missing an explicit definition of the partial sum variable $S_N$."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the sequence definition. The variable declaration `a : \u2115 \u2192 \u211d` establishes a sequence of real numbers, and `tc_1` precisely matches the mathematical formula $a_n = 3n^2 - 3n + 1$ for $n \u2265 1$, with appropriate type casting from natural numbers to reals.', 'The Lean formalization does not properly define the partial sum $S_N$. The natural language defines $S_N = \\\\sum_{n=1}^{N} a_n$, but `tc_2` instead states a recursive relationship $\\\\sum_{n=1}^{N} a_n = a_N + \\\\sum_{n=1}^{N-1} a_n$, which is a tautological identity rather than a definition of $S_N$. The Lean code is missing an explicit definition of the partial sum variable $S_N$.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, for the base case $N=1$, we have $S_1 = a_1$.", "statement": "We assume:\n\u2022 The partial sum $S_N$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for any integer $N \\geq 1$ [tc_2].\nTherefore, we conclude:\n\u2022 For N=1, the partial sum is $S_1 = a_1$ [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 \u2211 n in Finset.range (N + 1) \\ Finset.range 1, a n = a N + \u2211 n in Finset.range N \\ Finset.range 1, a n) :\n  (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = a 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 \u2211 n in Finset.range (N + 1) \\ Finset.range 1, a n = a N + \u2211 n in Finset.range N \\ Finset.range 1, a n) :\n  (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = a 1 := by\n  simp [Finset.range_succ, Finset.sum_singleton]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The premise tc_2 formalizes the partial sum definition as a recursive relationship rather than the direct definition S_N = sum from n=1 to N of a_n as stated in natural language. While mathematically equivalent, this is a structural difference from the stated definition.", "The conclusion correctly formalizes that S_1 = a_1 using appropriate Lean notation for the sum from 1 to 1."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The premise tc_2 formalizes the partial sum definition as a recursive relationship rather than the direct definition S_N = sum from n=1 to N of a_n as stated in natural language. While mathematically equivalent, this is a structural difference from the stated definition.', 'The conclusion correctly formalizes that S_1 = a_1 using appropriate Lean notation for the sum from 1 to 1.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "We calculate $a_1=3(1)^2-3(1)+1 = 3-3+1 = 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer $n \\geq 1$, $a_n = 3n^2 - 3n + 1$ [tc_1].\nTherefore, we conclude:\n\u2022 $a_1 = 1$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1) :\n  a 1 = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1) :\n  a 1 = 1 := by\n  have h := tc_1 1 (by simp)\n  simp at h\n  exact h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly formalized. The use of \u2115 with condition n \u2265 1 is equivalent to 'integer n \u2265 1' from the natural language, and the formula is identical.", "The conclusion a 1 = 1 is directly and correctly translated.", "The logical structure of assumption leading to conclusion is properly captured in the lemma format."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "So $S_1 = 1^3$, which holds.", "statement": "We assume:\n\u2022 $S_1 = a_1$ [l1].\n\u2022 $a_1 = 1$ [l2].\nTherefore, we conclude:\n\u2022 The base case holds: $S_1 = 1^3$ [l3].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u211d)\n  (l1 : (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = a 1)\n  (l2 : a 1 = 1) :\n  (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = (1 : \u211d)^3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u211d)\n  (l1 : (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = a 1)\n  (l2 : a 1 = 1) :\n  (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = (1 : \u211d)^3 := by\n  rw [l1, l2]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The premise l1 uses a complex sum notation to represent what appears to be a simple sequence element S_1 = a_1 in natural language. While the sum evaluates correctly to a_1, this introduces unnecessary complexity not present in the original statement.", "The premise l2 perfectly captures a_1 = 1 from the natural language.", "The conclusion maintains consistency with the sum representation from l1, but this creates a structural mismatch with the simpler S_1 = 1^3 statement in natural language. The mathematical meaning is preserved but the representation is more complex than suggested."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The premise l1 uses a complex sum notation to represent what appears to be a simple sequence element S_1 = a_1 in natural language. While the sum evaluates correctly to a_1, this introduces unnecessary complexity not present in the original statement.', 'The premise l2 perfectly captures a_1 = 1 from the natural language.', 'The conclusion maintains consistency with the sum representation from l1, but this creates a structural mismatch with the simpler S_1 = 1^3 statement in natural language. The mathematical meaning is preserved but the representation is more complex than suggested.']"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now, for the inductive step, we assume the statement is true for some integer $k \\geq 1$, which means $S_k = k^3$.", "statement": "Definition:\n\u2022 For the inductive step, we assume for some integer $k \\geq 1$ that $S_k = k^3$ (Inductive Hypothesis) [def_1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1)\n(tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 \u2211 n in Finset.range (N + 1) \\ Finset.range 1, a n = a N + \u2211 n in Finset.range N \\ Finset.range 1, a n)\n(k : \u2115)\n(def_1 : k \u2265 1 \u2192 (Finset.range (k + 1) \\ Finset.range 1).sum a = (k : \u211d)^3)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.4, "semantic_feedback": ["The natural language mentions 'performing an inductive step' but this context is not explicitly captured in the Lean formalization. The Lean code shows the hypothesis but doesn't explicitly state the inductive step context.", "The natural language specifies k as an integer with k \u2265 1, but Lean declares k as a natural number (\u2115). While natural numbers are a subset of integers and this doesn't change the mathematical meaning significantly, it's not a direct translation.", "The natural language has S_k = k^3 as the inductive hypothesis, while Lean has (Finset.range (k + 1) \\ Finset.range 1).sum a = (k : \u211d)^3. The Lean version appears to represent S_k as a sum over a finite set, which is more specific than the abstract S_k in the natural language, but captures the same mathematical relationship."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.4, below threshold 0.6.\nScorer feedback: [\"The natural language mentions 'performing an inductive step' but this context is not explicitly captured in the Lean formalization. The Lean code shows the hypothesis but doesn't explicitly state the inductive step context.\", \"The natural language specifies k as an integer with k \u2265 1, but Lean declares k as a natural number (\u2115). While natural numbers are a subset of integers and this doesn't change the mathematical meaning significantly, it's not a direct translation.\", 'The natural language has S_k = k^3 as the inductive hypothesis, while Lean has (Finset.range (k + 1) \\\\ Finset.range 1).sum a = (k : \u211d)^3. The Lean version appears to represent S_k as a sum over a finite set, which is more specific than the abstract S_k in the natural language, but captures the same mathematical relationship.']"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "We know that $S_{k+1} = S_k + a_{k+1}$.", "statement": "We assume:\n\u2022 The partial sum $S_N$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ [tc_2].\nTherefore, we conclude:\n\u2022 The partial sum follows the recurrence relation $S_{k+1} = S_k + a_{k+1}$ [l4].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 1)\n  (tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 \u2211 n in Finset.range (N + 1) \\ Finset.range 1, a n = a N + \u2211 n in Finset.range N \\ Finset.range 1, a n) :\n  \u2211 n in Finset.range (k + 1 + 1) \\ Finset.range 1, a n = a (k + 1) + \u2211 n in Finset.range (k + 1) \\ Finset.range 1, a n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 1)\n  (tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 \u2211 n in Finset.range (N + 1) \\ Finset.range 1, a n = a N + \u2211 n in Finset.range N \\ Finset.range 1, a n) :\n  \u2211 n in Finset.range (k + 1 + 1) \\ Finset.range 1, a n = a (k + 1) + \u2211 n in Finset.range (k + 1) \\ Finset.range 1, a n := by\n  exact tc_2 (k + 1) (by linarith [hk])", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The premise tc_2 represents a recurrence relation rather than the definition of partial sums as stated in natural language. The definition S_N = sum from n=1 to N of a_n is not explicitly present.", "The recurrence relation S_{k+1} = S_k + a_{k+1} is correctly captured in the Lean goal, with proper handling of the summation notation and equivalent algebraic form.", "The logical structure differs from natural language: instead of deriving a recurrence from a definition, the Lean code applies a general recurrence pattern to a specific case."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The premise tc_2 represents a recurrence relation rather than the definition of partial sums as stated in natural language. The definition S_N = sum from n=1 to N of a_n is not explicitly present.', 'The recurrence relation S_{k+1} = S_k + a_{k+1} is correctly captured in the Lean goal, with proper handling of the summation notation and equivalent algebraic form.', 'The logical structure differs from natural language: instead of deriving a recurrence from a definition, the Lean code applies a general recurrence pattern to a specific case.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "and we have $a_{k+1} = 3(k+1)^2-3(k+1)+1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for any integer $n \\geq 1$, $a_n = 3n^2 - 3n + 1$ [tc_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 3(k+1)^2 - 3(k+1) + 1$ [l5].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1) :\n  a (k + 1) = 3 * (\u2191(k + 1) : \u211d)^2 - 3 * (\u2191(k + 1) : \u211d) + 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d) (k : \u2115)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * (n : \u211d)^2 - 3 * (n : \u211d) + 1) :\n  a (k + 1) = 3 * (\u2191(k + 1) : \u211d)^2 - 3 * (\u2191(k + 1) : \u211d) + 1 := by\n  apply tc_1\n  exact Nat.succ_pos k", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language statement. The sequence definition, formula, and logical conclusion are all properly represented. Technical differences like using natural numbers instead of integers \u22651 and explicit type coercions are appropriate implementation choices that preserve the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "We expand the terms on the left side: $3(k+1)^2 = 3(k^2+2k+1) = 3k^2+6k+3$. Also, $-3(k+1) = -3k-3$. So the left side becomes $k^3 + (3k^2+6k+3) + (-3k-3) + 1 = k^3 + 3k^2+3k+1$.", "statement": "We assume:\n\u2022 k is an integer.\nTherefore, we conclude:\n\u2022 The algebraic identity $k^3 + 3(k+1)^2 - 3(k+1) + 1 = k^3 + 3k^2 + 3k + 1$ holds [l6].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (k : \u2124) :\n  k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (k : \u2124) :\n  k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1 := by\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. The variable k is correctly declared as an integer (\u2124), and the algebraic identity is expressed exactly as stated in the natural language, with only standard notational differences (^ for exponentiation, * for multiplication). The logical structure is preserved - both present this as a mathematical statement to be established."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "The right side is $(k+1)^3 = k^3+3k^2+3k+1$.", "statement": "We assume:\n\u2022 k is an integer.\nTherefore, we conclude:\n\u2022 The binomial expansion identity $(k+1)^3 = k^3 + 3k^2 + 3k + 1$ holds [l7].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (k : \u2124) :\n  (k + 1)^3 = k^3 + 3 * k^2 + 3 * k + 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (k : \u2124) :\n  (k + 1)^3 = k^3 + 3 * k^2 + 3 * k + 1 := by\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. The variable k is correctly declared as an integer (\u2124), and the binomial expansion identity is stated exactly as in the natural language, with only standard mathematical notation differences (^ for exponentiation, * for multiplication). The lemma name l7 corresponds to the reference [l7] in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Since the left side equals the right side, the statement is true for $k+1$.", "statement": "We assume:\n\u2022 $k^3 + 3(k+1)^2 - 3(k+1) + 1 = k^3 + 3k^2 + 3k + 1$ [l6].\n\u2022 $(k+1)^3 = k^3 + 3k^2 + 3k + 1$ [l7].\nTherefore, we conclude:\n\u2022 $k^3 + 3(k+1)^2 - 3(k+1) + 1 = (k+1)^3$ [l8].", "dependencies": ["l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  (k : \u2124)\n  (l6 : k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1)\n  (l7 : (k + 1) ^ 3 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1) :\n  k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = (k + 1) ^ 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  (k : \u2124)\n  (l6 : k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1)\n  (l7 : (k + 1) ^ 3 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1) :\n  k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = (k + 1) ^ 3 := by\n  rw [l6, l7]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The mathematical expressions in the Lean formalization exactly correspond to those in the natural language, with appropriate Lean syntax for arithmetic operations and exponentiation.", "The logical structure is correctly preserved - l6 and l7 are treated as assumptions/hypotheses, and l8 is the conclusion to be proved, matching the 'Therefore, we conclude' reasoning in the natural language.", "The variable k is appropriately typed as an integer, which is a reasonable mathematical interpretation that doesn't contradict the natural language description.", "The proof structure correctly captures the deductive reasoning from premises to conclusion as described in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "Since the left side equals the right side, the statement is true for $k+1$.", "statement": "We assume:\n\u2022 We have the inductive hypothesis $S_k = k^3$ [def_1].\n\u2022 The recurrence relation for the sum is $S_{k+1} = S_k + a_{k+1}$ [l4].\n\u2022 The (k+1)-th term is $a_{k+1} = 3(k+1)^2 - 3(k+1) + 1$ [l5].\n\u2022 The algebraic identity $k^3 + 3(k+1)^2 - 3(k+1) + 1 = (k+1)^3$ holds [l8].\nTherefore, we conclude:\n\u2022 The proposition holds for k+1: $S_{k+1} = (k+1)^3$ [l9].", "dependencies": ["def_1", "l4", "l5", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l9\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 1)\n  (def_1 : k \u2265 1 \u2192 (Finset.range (k + 1) \\ Finset.range 1).sum a = (k : \u211d)^3)\n  (l4 : \u2211 n in Finset.range (k + 1 + 1) \\ Finset.range 1, a n = a (k + 1) + \u2211 n in Finset.range (k + 1) \\ Finset.range 1, a n)\n  (l5 : a (k + 1) = 3 * (\u2191(k + 1) : \u211d)^2 - 3 * (\u2191(k + 1) : \u211d) + 1)\n  (l8 : (k : \u211d)^3 + 3 * (\u2191(k + 1) : \u211d)^2 - 3 * (\u2191(k + 1) : \u211d) + 1 = (\u2191(k + 1) : \u211d)^3) :\n  (Finset.range (k + 1 + 1) \\ Finset.range 1).sum a = (\u2191(k + 1) : \u211d)^3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l9\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 1)\n  (def_1 : k \u2265 1 \u2192 (Finset.range (k + 1) \\ Finset.range 1).sum a = (k : \u211d)^3)\n  (l4 : \u2211 n in Finset.range (k + 1 + 1) \\ Finset.range 1, a n = a (k + 1) + \u2211 n in Finset.range (k + 1) \\ Finset.range 1, a n)\n  (l5 : a (k + 1) = 3 * (\u2191(k + 1) : \u211d)^2 - 3 * (\u2191(k + 1) : \u211d) + 1)\n  (l8 : 3 * (\u2191(k + 1) : \u211d)^2 - 3 * (\u2191(k + 1) : \u211d) + 1 + (k : \u211d)^3 = (\u2191(k + 1) : \u211d)^3) :\n  (Finset.range (k + 1 + 1) \\ Finset.range 1).sum a = (\u2191(k + 1) : \u211d)^3 := by\n  rw [l4, l5, def_1 hk]\n  exact l8", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The inductive hypothesis is correctly formalized using explicit finite set sum notation, with appropriate domain condition k \u2265 1", "The recurrence relation is accurately captured showing S_{k+1} = S_k + a_{k+1} using finite set operations", "The term definition is directly translated with proper type casting from naturals to reals", "The algebraic identity is exactly represented with appropriate type annotations", "The conclusion correctly states the inductive step using the same finite set sum notation established earlier"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of mathematical induction, the statement is true for all integers $N \\geq 1$.", "statement": "We assume:\n\u2022 The base case holds: $S_1 = 1^3$ [l3].\n\u2022 The inductive step holds: for any integer k \u2265 1, if we assume $S_k = k^3$ [def_1], it follows that $S_{k+1} = (k+1)^3$ [l9].\nTherefore, by the principle of mathematical induction, we conclude:\n\u2022 $S_N = N^3$ for all integers $N \\geq 1$ [ts_1].", "dependencies": ["l3", "def_1", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (N : \u2115)\n  (l3 : (\u2211 n in Finset.range (1 + 1) \\ Finset.range 1, a n) = (1 : \u211d)^3)\n  (def_1 : \u2200 k : \u2115, k \u2265 1 \u2192 (Finset.range (k + 1) \\ Finset.range 1).sum a = (k : \u211d)^3)\n  (l9 : \u2200 k : \u2115, k \u2265 1 \u2192 (Finset.range (k + 1 + 1) \\ Finset.range 1).sum a = (\u2191(k + 1) : \u211d)^3) :\n  N \u2265 1 \u2192 (Finset.range (N + 1) \\ Finset.range 1).sum a = (N : \u211d)^3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (N : \u2115)\n  (l3 : (Finset.range (0 + 1 + 1) \\ Finset.range 1).sum a = (0 + 1 : \u211d)^3)\n  (def_1 : \u2200 k : \u2115, k \u2265 1 \u2192 (Finset.range (k + 1) \\ Finset.range 1).sum a = (k : \u211d)^3)\n  (l9 : \u2200 k : \u2115, k \u2265 1 \u2192 (Finset.range (k + 1 + 1) \\ Finset.range 1).sum a = (\u2191(k + 1) : \u211d)^3) :\n  N \u2265 1 \u2192 (Finset.range (N + 1) \\ Finset.range 1).sum a = (N : \u211d)^3 := by\n  intro hN\n  induction' N using Nat.strong_induction_on with m ih\n  cases' m with m\n  \u00b7 contradiction\n  \u00b7 cases' m with m\n    \u00b7 exact l3\n    \u00b7 have h := def_1 (m + 1) (by linarith)\n      have h' := l9 (m + 1) (by linarith)\n      rw [h'] at h\n      exact h'", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 6, "endLine": 17, "endColumn": 14, "data": "type mismatch\n  l3\nhas type\n  (Finset.range (0 + 1 + 1) \\ Finset.range 1).sum a = (0 + 1) ^ 3 : Prop\nbut is expected to have type\n  (Finset.range (0 + 1 + 1) \\ Finset.range 1).sum a = \u2191(0 + 1) ^ 3 : Prop"}, {"line": 20, "column": 10, "endLine": 20, "endColumn": 12, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (Finset.range (m + 1 + 1 + 1) \\ Finset.range 1).sum a\ncase h.succ.succ\na : \u2115 \u2192 \u211d\nl3 : (Finset.range (0 + 1 + 1) \\ Finset.range 1).sum a = (0 + 1) ^ 3\ndef_1 : \u2200 k \u2265 1, (Finset.range (k + 1) \\ Finset.range 1).sum a = \u2191k ^ 3\nl9 : \u2200 k \u2265 1, (Finset.range (k + 1 + 1) \\ Finset.range 1).sum a = \u2191(k + 1) ^ 3\nm : \u2115\nih : \u2200 m_1 < m + 1 + 1, m_1 \u2265 1 \u2192 (Finset.range (m_1 + 1) \\ Finset.range 1).sum a = \u2191m_1 ^ 3\nhN : m + 1 + 1 \u2265 1\nh : (Finset.range (m + 1 + 1) \\ Finset.range 1).sum a = \u2191(m + 1) ^ 3\nh' : (Finset.range (m + 1 + 1 + 1) \\ Finset.range 1).sum a = \u2191(m + 1 + 1) ^ 3\n\u22a2 (Finset.range (m + 1 + 1 + 1) \\ Finset.range 1).sum a = \u2191(m + 1 + 1) ^ 3"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The base case is correctly formalized using the sum notation that represents S_1.", "The inductive hypothesis is properly represented with the correct sum range and condition.", "The inductive step is presented as an independent assumption rather than a consequence of the inductive hypothesis. This breaks the logical structure of mathematical induction where the step should show that assuming the statement for k implies it for k+1.", "The final conclusion correctly captures the universal statement for all N \u2265 1.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The base case is correctly formalized using the sum notation that represents S_1.', 'The inductive hypothesis is properly represented with the correct sum range and condition.', 'The inductive step is presented as an independent assumption rather than a consequence of the inductive hypothesis. This breaks the logical structure of mathematical induction where the step should show that assuming the statement for k implies it for k+1.', 'The final conclusion correctly captures the universal statement for all N \u2265 1.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    