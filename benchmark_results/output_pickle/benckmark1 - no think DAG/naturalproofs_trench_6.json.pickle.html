
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $P_1,$ $P_2, $\dots$,$ $P_n,$ \dots\ be
propositions$,$ one
for each positive integer$,$ such that
\begin{alist}
\item % (a)
 $P_1$ is true$;$
\item % (b)
 for each positive integer $n,$  $P_n$  implies $P_{n+1}.$
\end{alist}
Then $P_n$ is true for each positive integer $n.$

Proof: Let
$$
\mathbb M=\set{n}{n\in \mathbb N\mbox{ and } P_n\mbox{ is
true}}.
$$
From \part{a}, $1\in \mathbb M$, and from \part{b}, $n+1\in \mathbb M$ whenever
$n\in \mathbb M$. Therefore, $\mathbb M=\mathbb N$, by postulate
\part{E}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $P_1,$ $P_2, $,$\\dots,$,$ $P_n,$ \\dots\\ be\npropositions$,$ one\nfor each positive integer$,$ such that\n\\begin{alist}\n\\item % (a)\n $P_1$ is true$;$", "statement": "Premise:\n\u2022 Let $(P_n)_{n \\in \\mathbb{N}}$ be a sequence of propositions indexed by the positive integers $\\mathbb{N} = \\{1, 2, 3, \\dots\\}$.\n\u2022 $P_1$ is true [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (P : \u2115 \u2192 Prop)\n(tc_1 : P 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies indexing by positive integers \u2115 = {1, 2, 3, ...}, while Lean's \u2115 includes 0. However, this doesn't affect the logical meaning since P can still be applied to all positive integers as intended.", "Both express that P_1 (or P 1) is true, which is an exact match.", "Both have no new conclusions derived from the premise alone."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "for each positive integer $n,$  $P_n$  implies $P_{n+1}.$", "statement": "Premise:\n\u2022 For the sequence of propositions $(P_n)_{n \\in \\mathbb{N}}$ over positive integers from [tc_1], it holds that for each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (P : \u2115 \u2192 Prop)\n(tc_1 : P 1)\n(tc_2 : \u2200 n : \u2115, P n \u2192 P (n + 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language refers to 'positive integers' but Lean uses \u2115 (natural numbers including 0). However, since tc_1 establishes P 1 as the base case, this effectively restricts the relevant domain to positive integers in practice. The semantic meaning is preserved.", "The natural language specifies 'positive integer n' while Lean uses 'n : \u2115' (all natural numbers). However, given the context and base case P 1, this difference doesn't affect the logical meaning significantly, as the induction effectively works over positive integers."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language refers to 'positive integers' but Lean uses \u2115 (natural numbers including 0). However, since tc_1 establishes P 1 as the base case, this effectively restricts the relevant domain to positive integers in practice. The semantic meaning is preserved.\", \"The natural language specifies 'positive integer n' while Lean uses 'n : \u2115' (all natural numbers). However, given the context and base case P 1, this difference doesn't affect the logical meaning significantly, as the induction effectively works over positive integers.\"]"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let\n$$\n\\mathbb M=\\set{n}{n\\in \\mathbb N\\mbox{ and } P_n\\mbox{ is\ntrue}}.\n$$", "statement": "Definition:\n\u2022 Given the sequence of propositions $(P_n)_{n \\in \\mathbb{N}}$ over positive integers from [tc_1], we define the set $\\mathbb{M}$ as the set of positive integers $n$ for which the proposition $P_n$ is true: $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (P : \u2115 \u2192 Prop)\n(tc_1 : P 1)\n(def_1 : Set.setOf (fun n : \u2115 => P n))", "lean_pass": false, "error_msg": [{"line": 7, "column": 9, "endLine": 7, "endColumn": 37, "data": "unknown constant 'Set.setOf'"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From \\part{a}, $1\\in \\mathbb M$", "statement": "We assume:\n\u2022 $P_1$ is true [tc_1].\n\u2022 $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$, where $\\mathbb{N}$ are positive integers [def_1].\nTherefore, we conclude:\n\u2022 $1 \\in \\mathbb{M}$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : P 1)\n  (def_1 : Set \u2115 := {n : \u2115 | P n}) :\n  (1 : \u2115) \u2208 def_1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : P 1) :\n  (1 : \u2115) \u2208 {n : \u2115 | P n} := by\n  exact tc_1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical and logical content from the natural language. The predicate P and assumption P 1 are properly represented, the set definition accurately translates the mathematical notation, and the conclusion maintains the same logical relationship. Minor notational differences (P\u2081 vs P 1, \ud835\udd44 vs def_1) do not affect the semantic meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "from \\part{b}, $n+1\\in \\mathbb M$ whenever\n$n\\in \\mathbb M$.", "statement": "We assume:\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_2].\n\u2022 $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$, where $\\mathbb{N}$ are positive integers [def_1].\nTherefore, we conclude:\n\u2022 For any positive integer $n$, if $n \\in \\mathbb{M}$, then $n+1 \\in \\mathbb{M}$ [l2].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (P : \u2115 \u2192 Prop)\n  (tc_2 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n}) :\n  \u2200 n : \u2115, n \u2208 M \u2192 n + 1 \u2208 M := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (P : \u2115 \u2192 Prop)\n  (tc_2 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n}) :\n  \u2200 n : \u2115, n \u2208 M \u2192 n + 1 \u2208 M := by\n  intro n hn\n  rw [def_1] at hn \u22a2\n  exact tc_2 n hn", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption tc_2 correctly captures the implication P_n \u2192 P_{n+1} for all positive integers n", "The definition def_1 accurately formalizes the set M as the collection of all n where P_n holds", "The conclusion l2 properly states that membership in M is preserved under the successor operation", "The overall logical structure correctly uses the given assumptions to establish the conclusion, maintaining the same deductive reasoning as the natural language version"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, $\\mathbb M=\\mathbb N$, by postulate\n\\part{E}.", "statement": "We assume:\n\u2022 $\\mathbb{M}$ is a subset of the positive integers $\\mathbb{N}$ [def_1].\n\u2022 $1 \\in \\mathbb{M}$ [l1].\n\u2022 For any positive integer $n$, if $n \\in \\mathbb{M}$, then $n+1 \\in \\mathbb{M}$ [l2].\nTherefore, we conclude:\n\u2022 $\\mathbb{M} = \\mathbb{N}$ [l3].", "dependencies": ["def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (P : \u2115 \u2192 Prop)\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n})\n  (l1 : (1 : \u2115) \u2208 M)\n  (l2 : \u2200 n : \u2115, n \u2208 M \u2192 n + 1 \u2208 M) :\n  M = Set.univ := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (P : \u2115 \u2192 Prop)\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n})\n  (l1 : (1 : \u2115) \u2208 M)\n  (l2 : \u2200 n : \u2115, n \u2208 M \u2192 n + 1 \u2208 M) :\n  M = Set.univ := by\n  rw [def_1]\n  ext n\n  induction' n with d hd\n  \u00b7 simp [Set.mem_def] at l1\n    rw [\u2190 def_1] at l1\n    exact l1\n  \u00b7 exact l2 d hd", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 8, "endLine": 16, "endColumn": 15, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  {n | P n}\ncase h.zero\nP : \u2115 \u2192 Prop\nM : Set \u2115\ndef_1 : M = {n | P n}\nl2 : \u2200 n \u2208 M, n + 1 \u2208 M\nl1 : M 1\n\u22a2 0 \u2208 {n | P n} \u2194 0 \u2208 Set.univ"}, {"line": 18, "column": 15, "endLine": 18, "endColumn": 17, "data": "application type mismatch\n  l2 d hd\nargument\n  hd\nhas type\n  d \u2208 {n | P n} \u2194 d \u2208 Set.univ : Prop\nbut is expected to have type\n  d \u2208 M : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical induction principle stated in natural language. While it introduces an auxiliary predicate P to define the set M, this is a standard formalization technique that doesn't alter the logical meaning. All key components are present: the subset relationship (through set comprehension), the base case (1 \u2208 M), the inductive step (n \u2208 M \u2192 n+1 \u2208 M), and the conclusion (M = Set.univ representing M = \u2115). The formalization is mathematically equivalent to the natural language statement.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3\n  (P : \u2115 \u2192 Prop)\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n})\n  (l1 : (1 : \u2115) \u2208 M)\n  (l2 : \u2200 n : \u2115, n \u2208 M \u2192 n + 1 \u2208 M) :\n  \u00ac M = Set.univ := by\n  intro h\n  have : (0 : \u2115) \u2208 M := by rw [h]; trivial\n  rw [def_1] at this\n  have : P 0 := this\n  have : (1 : \u2115) \u2208 M := l1\n  have : (0 : \u2115) \u2208 M := l2 0 this\n  contradiction"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, $\\mathbb M=\\mathbb N$, by postulate\n\\part{E}.", "statement": "We assume:\n\u2022 $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$, where $\\mathbb{N}$ represents positive integers [def_1].\n\u2022 $\\mathbb{M} = \\mathbb{N}$ [l3].\nTherefore, we conclude:\n\u2022 $P_n$ is true for each positive integer $n$ [ts_1].", "dependencies": ["def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (P : \u2115 \u2192 Prop)\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n})\n  (l3 : M = Set.univ) :\n  \u2200 n : \u2115, P n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (P : \u2115 \u2192 Prop)\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n})\n  (l3 : M = Set.univ) :\n  \u2200 n : \u2115, P n := by\n  intro n\n  rw [\u2190 def_1, l3]\n  exact Set.mem_univ n", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 6, "endLine": 12, "endColumn": 13, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  {n | P n}\nP : \u2115 \u2192 Prop\nM : Set \u2115\ndef_1 : M = {n | P n}\nl3 : M = Set.univ\nn : \u2115\n\u22a2 P n"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The set definition M = {n : \u2115 | P n} correctly captures the natural language definition of M as the set of positive integers where P_n is true.", "The condition M = Set.univ perfectly translates the assumption that M equals the set of all positive integers, since Set.univ over \u2115 represents exactly this.", "The conclusion \u2200 n : \u2115, P n precisely captures the natural language statement that P_n is true for each positive integer n.", "The overall logical structure and flow from premises to conclusion is perfectly preserved in the Lean formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_ts_1\n  (P : \u2115 \u2192 Prop)\n  (M : Set \u2115)\n  (def_1 : M = {n : \u2115 | P n})\n  (l3 : M = Set.univ) :\n  \u00ac \u2200 n : \u2115, P n := by\n  intro h\n  have : \u00ac P 1 := by\n    have h1 := h 1\n    simp [h1]\n  have : 1 \u2208 M := by rw [l3]; exact Set.mem_univ 1\n  rw [def_1] at this\n  simp at this\n  contradiction"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    