
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Suppose that $\widehat u\in\overline D_f.$ Then
\begin{equation} \label{eq:8.3.3}
\lim_{u	o \widehat u}f(u)=\widehat v
\end{equation}
if and only if
\begin{equation} \label{eq:8.3.4}
\lim_{n	o\infty}f(u_n)=\widehat v
\end{equation}
for every sequence $\{u_n\}$ in $D_f$ such that
\begin{equation} \label{eq:8.3.5}
\lim_{n	o\infty}u_n=\widehat u.
\end{equation}

Proof: Suppose that \eqref{eq:8.3.3} is true, and let $\{u_n\}$  be a sequence in
$D_f$ that satisfies \eqref{eq:8.3.5}. Let $\epsilon>0$ and choose
$\delta>0$  to satisfy \eqref{eq:8.3.1}. From \eqref{eq:8.3.5}, there is
an integer $N$  such that $\rho(u_n,\widehat u)<\delta$ if $n\ge N$.
Therefore, $\sigma(f(u_n),\widehat v)<\epsilon$ if $n\ge N$, which implies
\eqref{eq:8.3.4}.
For the converse, suppose that \eqref{eq:8.3.3} is false.
Then there is an $\epsilon_0>0$  and a sequence $\{u_n\}$
in $D_f$ such that $\rho(u_n,\widehat u)<1/n$ and $\sigma(f(u_n),\widehat
v)\ge\epsilon_0$, so \eqref{eq:8.3.4} is false.
\mbox{}\hfill
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Suppose that $\\widehat u\\in\\overline D_f.$", "statement": "Premise:\n\u2022 Let $(U, \\rho)$ and $(V, \\sigma)$ be metric spaces. Let $f: D_f \\to V$ be a function where $D_f \\subseteq U$. Let $\\widehat u \\in \\overline D_f$ and $\\widehat v \\in V$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that U is a metric space with the MetricSpace typeclass instance", "The Lean formalization correctly captures that V is a metric space with the MetricSpace typeclass instance", "The Lean formalization correctly represents f as a function from D_f to V", "Declaring D_f as Set U in Lean automatically establishes that D_f \u2286 U, which matches the mathematical statement", "The Lean formalization correctly captures that u_hat is in the closure of D_f, with closure being the Lean equivalent of the overline notation for topological closure", "The Lean formalization correctly captures that v_hat is an element of V by declaring it as type V"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Suppose that \\eqref{eq:8.3.3} is true", "statement": "Assumption (for forward implication):\n\u2022 $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)\n  (def_1 : Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat))", "lean_pass": false, "error_msg": [{"line": 12, "column": 40, "endLine": 12, "endColumn": 45, "data": "application type mismatch\n  nhdsWithin u_hat\nargument\n  u_hat\nhas type\n  U : Type u_1\nbut is expected to have type\n  \u2191D_f : Type u_1"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "and let $\\{u_n\\}$  be a sequence in $D_f$ that satisfies \\eqref{eq:8.3.5}.", "statement": "Assumption (for forward implication):\n\u2022 Let $\\{u_n\\}$ be a sequence in $D_f$ such that $\\lim_{n\\to\\infty}u_n=\\widehat u$ [def_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)\n  (u : \u2115 \u2192 U)\n  (def_2 : (\u2200 n, u n \u2208 D_f) \u2227 (Filter.Tendsto u Filter.atTop (nhds u_hat)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that {u_n} is a sequence in D_f through the type declaration (u : \u2115 \u2192 U) and the condition (\u2200 n, u n \u2208 D_f)", "The Lean formalization correctly captures the limit condition using Filter.Tendsto u Filter.atTop (nhds u_hat), which is the standard mathematical formalization of sequence convergence in Lean"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Let $\\epsilon>0$ and choose $\\delta>0$  to satisfy \\eqref{eq:8.3.1}.", "statement": "We assume:\n\u2022 $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$ [def_1].\nTherefore, we conclude:\n\u2022 For any $\\epsilon > 0$, there exists a $\\delta > 0$ such that for any $u \\in D_f$, if $\\rho(u, \\widehat{u}) < \\delta$, then $\\sigma(f(u), \\widehat{v}) < \\epsilon$ [l1].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  {f : \u03b1 \u2192 \u03b2} {D_f : Set \u03b1} {u_hat : \u03b1} {v_hat : \u03b2}\n  (def_1 : Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat)) :\n  \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 (\u03b4 : \u211d), \u03b4 > 0 \u2227 \u2200 (u : \u03b1), u \u2208 D_f \u2192 dist u u_hat < \u03b4 \u2192 dist (f u) v_hat < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  {f : \u03b1 \u2192 \u03b2} {D_f : Set \u03b1} {u_hat : \u03b1} {v_hat : \u03b2}\n  (def_1 : Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat)) :\n  \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 (\u03b4 : \u211d), \u03b4 > 0 \u2227 \u2200 (u : \u03b1), u \u2208 D_f \u2192 dist u u_hat < \u03b4 \u2192 dist (f u) v_hat < \u03b5 := by\n  intro \u03b5 h\u03b5\n  rw [Metric.tendsto_nhdsWithin_nhds] at def_1\n  obtain \u27e8\u03b4, h\u03b4_pos, h\u03b4\u27e9 := def_1 \u03b5 h\u03b5\n  exact \u27e8\u03b4, h\u03b4_pos, fun u hu hdist => h\u03b4 u \u27e8hu, hdist\u27e9\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 41, "endLine": 13, "endColumn": 42, "data": "application type mismatch\n  h\u03b4 u\nargument\n  u\nhas type\n  \u03b1 : Type u_1\nbut is expected to have type\n  u \u2208 D_f : Prop"}, {"line": 13, "column": 43, "endLine": 13, "endColumn": 54, "data": "invalid constructor \u27e8...\u27e9, expected type must be an inductive type \n  Real.lt\u271d (Dist.dist u u_hat) \u03b4"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise is correctly formalized using Filter.Tendsto with nhdsWithin, which accurately captures the limit concept within domain D_f", "The conclusion perfectly captures the epsilon-delta definition with proper quantifier structure and logical implications", "The overall logical flow from assumption to conclusion is correctly represented, and the metric space structures provide the necessary mathematical framework", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  {f : \u03b1 \u2192 \u03b2} {D_f : Set \u03b1} {u_hat : \u03b1} {v_hat : \u03b2}\n  (h : \u00acFilter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat)) :\n  \u2203 (\u03b5 : \u211d), \u03b5 > 0 \u2227 \u2200 (\u03b4 : \u211d), \u03b4 > 0 \u2192 \u2203 (u : \u03b1), u \u2208 D_f \u2227 dist u u_hat < \u03b4 \u2227 \u03b5 \u2264 dist (f u) v_hat := by\n  sorry"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From \\eqref{eq:8.3.5}, there is an integer $N$  such that $\\rho(u_n,\\widehat u)<\\delta$ if $n\\ge N$.", "statement": "We assume:\n\u2022 $\\lim_{n\\to\\infty}u_n=\\widehat u$ [def_2].\n\u2022 A real number $\\delta > 0$ is given.\nTherefore, we conclude:\n\u2022 There exists an integer $N$ such that for all $n \\ge N$, we have $\\rho(u_n, \\widehat{u}) < \\delta$ [l2].", "dependencies": ["def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {U : Type*} [MetricSpace U]\n  (u_hat : U)\n  (u : \u2115 \u2192 U)\n  (delta : \u211d) (hdelta : delta > 0)\n  (def_2 : Filter.Tendsto u Filter.atTop (nhds u_hat)) :\n  \u2203 N : \u2115, \u2200 n \u2265 N, dist (u n) u_hat < delta := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {U : Type*} [MetricSpace U]\n  (u_hat : U)\n  (u : \u2115 \u2192 U)\n  (delta : \u211d) (hdelta : delta > 0)\n  (def_2 : Filter.Tendsto u Filter.atTop (nhds u_hat)) :\n  \u2203 N : \u2115, \u2200 n \u2265 N, dist (u n) u_hat < delta := by\n  rcases Metric.tendsto_atTop.1 def_2 delta hdelta with \u27e8N, hN\u27e9\n  exact \u27e8N, fun n hn => hN n hn\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The convergence assumption is correctly formalized. Filter.Tendsto with atTop and nhds perfectly captures the limit definition in topology/analysis.", "The delta condition is correctly captured with both the type declaration and positivity constraint.", "The conclusion matches perfectly. The use of natural numbers \u2115 instead of integers \u2124 for N is mathematically equivalent since we only need N \u2265 some value. The dist function correctly represents the metric \u03c1.", "The metric space structure is appropriately declared to support the distance function, which aligns with the natural language use of \u03c1 notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, $\\sigma(f(u_n),\\widehat v)<\\epsilon$ if $n\\ge N$", "statement": "We assume:\n\u2022 For a given $\\epsilon > 0$, there exists a $\\delta > 0$ such that for any $u \\in D_f$, if $\\rho(u, \\widehat{u}) < \\delta$, then $\\sigma(f(u), \\widehat{v}) < \\epsilon$ [l1].\n\u2022 For this $\\delta$, there exists an integer $N$ such that for all $n \\ge N$, we have $\\rho(u_n, \\widehat{u}) < \\delta$ [l2].\n\u2022 $\\{u_n\\}$ is a sequence in $D_f$ [def_2].\nTherefore, we conclude:\n\u2022 For the given $\\epsilon > 0$, there exists an integer $N$ such that for all $n \\ge N$, we have $\\sigma(f(u_n), \\widehat{v}) < \\epsilon$ [l3].", "dependencies": ["l1", "l2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (u : \u2115 \u2192 U)\n  (\u03b5 : \u211d) (h\u03b5 : \u03b5 > 0)\n  (l1 : \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 (\u03b4 : \u211d), \u03b4 > 0 \u2227 \u2200 (u_0 : U), u_0 \u2208 D_f \u2192 dist u_0 u_hat < \u03b4 \u2192 dist (f \u27e8u_0, sorry\u27e9) v_hat < \u03b5)\n  (l2 : \u2200 (delta : \u211d), delta > 0 \u2192 \u2203 N : \u2115, \u2200 n \u2265 N, dist (u n) u_hat < delta)\n  (def_2 : \u2200 n, u n \u2208 D_f) :\n  \u2203 N : \u2115, \u2200 n \u2265 N, dist (f \u27e8u n, def_2 n\u27e9) v_hat < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (u : \u2115 \u2192 U)\n  (\u03b5 : \u211d) (h\u03b5 : \u03b5 > 0)\n  (l1 : \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 (\u03b4 : \u211d), \u03b4 > 0 \u2227 \u2200 (u_0 : U), u_0 \u2208 D_f \u2192 dist u_0 u_hat < \u03b4 \u2192 dist (f \u27e8u_0, by assumption\u27e9) v_hat < \u03b5)\n  (l2 : \u2200 (delta : \u211d), delta > 0 \u2192 \u2203 N : \u2115, \u2200 n \u2265 N, dist (u n) u_hat < delta)\n  (def_2 : \u2200 n, u n \u2208 D_f) :\n  \u2203 N : \u2115, \u2200 n \u2265 N, dist (f \u27e8u n, def_2 n\u27e9) v_hat < \u03b5 := by\n  obtain \u27e8\u03b4, h\u03b4, h\u27e9 := l1 \u03b5 h\u03b5\n  obtain \u27e8N, hN\u27e9 := l2 \u03b4 h\u03b4\n  exact \u27e8N, fun n hn => h (u n) (def_2 n) (hN n hn)\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 109, "endLine": 13, "endColumn": 119, "data": "tactic 'assumption' failed\nU : Type u_1\nV : Type u_2\ninst\u271d\u00b9 : MetricSpace U\ninst\u271d : MetricSpace V\nD_f : Set U\nf : \u2191D_f \u2192 V\nu_hat : U\nv_hat : V\nu : \u2115 \u2192 U\n\u03b5\u271d : \u211d\nh\u03b5 : \u03b5\u271d > 0\n\u03b5 \u03b4 : \u211d\nu_0 : U\n\u22a2 u_0 \u2208 D_f"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function domain structure using subset types correctly captures the mathematical meaning of f being defined on D_f \u2286 U", "The continuity-like property [l1] is correctly formalized with proper quantifier structure, despite the technical 'sorry' placeholder", "Assumption [l2] has a major logical inconsistency: the natural language refers to 'this \u03b4' (the specific \u03b4 from l1), but Lean quantifies over all positive \u03b4 values, changing the logical dependency structure", "The sequence domain assumption [def_2] is perfectly captured as \u2200 n, u n \u2208 D_f", "The conclusion [l3] correctly formalizes the existence of N with the proper quantifier structure and distance constraint", "Minor notational difference: natural language uses \u03c1 and \u03c3 for different metrics while Lean uses 'dist' for both, but this is semantically equivalent in the metric space context", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The function domain structure using subset types correctly captures the mathematical meaning of f being defined on D_f \u2286 U', \"The continuity-like property [l1] is correctly formalized with proper quantifier structure, despite the technical 'sorry' placeholder\", \"Assumption [l2] has a major logical inconsistency: the natural language refers to 'this \u03b4' (the specific \u03b4 from l1), but Lean quantifies over all positive \u03b4 values, changing the logical dependency structure\", 'The sequence domain assumption [def_2] is perfectly captured as \u2200 n, u n \u2208 D_f', 'The conclusion [l3] correctly formalizes the existence of N with the proper quantifier structure and distance constraint', \"Minor notational difference: natural language uses \u03c1 and \u03c3 for different metrics while Lean uses 'dist' for both, but this is semantically equivalent in the metric space context\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Suppose that \\eqref{eq:8.3.3} is true, and let $\\{u_n\\}$  be a sequence in\n$D_f$ that satisfies \\eqref{eq:8.3.5}. Let $\\epsilon>0$ and choose\n$\\delta>0$  to satisfy \\eqref{eq:8.3.1}. From \\eqref{eq:8.3.5}, there is\nan integer $N$  such that $\\rho(u_n,\\widehat u)<\\delta$ if $n\\ge N$.\nTherefore, $\\sigma(f(u_n),\\widehat v)<\\epsilon$ if $n\\ge N$, which implies\n\\eqref{eq:8.3.4}.", "statement": "We assume:\n\u2022 We start with the assumption $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$ [def_1].\n\u2022 We take an arbitrary sequence $\\{u_n\\}$ in $D_f$ such that $\\lim_{n\\to\\infty}u_n=\\widehat u$ [def_2].\n\u2022 We have shown that for any $\\epsilon > 0$, an integer $N$ exists such that for $n \\ge N$, $\\sigma(f(u_n), \\widehat{v}) < \\epsilon$ [l3].\nTherefore, we conclude:\n\u2022 If $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$, then for every sequence $\\{u_n\\}$ in $D_f$ such that $\\lim_{n\\to\\infty}u_n=\\widehat u$, we have $\\lim_{n\\to\\infty}f(u_n)=\\widehat v$ [ts_1].", "dependencies": ["def_1", "def_2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)\n  (u : \u2115 \u2192 U)\n  (def_1 : Filter.Tendsto (fun x : U => f \u27e8x, sorry\u27e9) (nhds u_hat) (nhds v_hat))\n  (def_2 : (\u2200 n, u n \u2208 D_f) \u2227 (Filter.Tendsto u Filter.atTop (nhds u_hat)))\n  (l3 : \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 N : \u2115, \u2200 n \u2265 N, dist (f \u27e8u n, (def_2.1 n)\u27e9) v_hat < \u03b5) :\n  Filter.Tendsto (fun n => f \u27e8u n, (def_2.1 n)\u27e9) Filter.atTop (nhds v_hat) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)\n  (u : \u2115 \u2192 U)\n  (def_1 : Filter.Tendsto (fun x : U => f \u27e8x, sorry\u27e9) (nhds u_hat) (nhds v_hat))\n  (def_2 : (\u2200 n, u n \u2208 D_f) \u2227 (Filter.Tendsto u Filter.atTop (nhds u_hat)))\n  (l3 : \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 N : \u2115, \u2200 n \u2265 N, dist (f \u27e8u n, (def_2.1 n)\u27e9) v_hat < \u03b5) :\n  Filter.Tendsto (fun n => f \u27e8u n, (def_2.1 n)\u27e9) Filter.atTop (nhds v_hat) := by\n  rw [Metric.tendsto_atTop]\n  intro \u03b5 h\u03b5\n  obtain \u27e8N, hN\u27e9 := l3 \u03b5 h\u03b5\n  exact \u27e8N, fun n hn => hN n hn\u27e9", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The limit assumption def_1 has the right mathematical meaning but contains a 'sorry' indicating incomplete formalization. The structure correctly uses Filter.Tendsto for limits.", "The sequence assumption def_2 perfectly captures both the domain membership condition and convergence requirement using conjunction and Filter.Tendsto.", "The epsilon-delta condition l3 correctly translates the mathematical statement, properly using dist for the metric and maintaining the logical structure.", "The conclusion ts_1 correctly expresses the sequential limit using Filter.Tendsto, matching the natural language statement's mathematical meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.75 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)\n  (u : \u2115 \u2192 U)\n  (def_1 : Filter.Tendsto (fun x : U => f \u27e8x, sorry\u27e9) (nhds u_hat) (nhds v_hat))\n  (def_2 : (\u2200 n, u n \u2208 D_f) \u2227 (Filter.Tendsto u Filter.atTop (nhds u_hat)))\n  (l3 : \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 \u2203 N : \u2115, \u2200 n \u2265 N, dist (f \u27e8u n, (def_2.1 n)\u27e9) v_hat < \u03b5) :\n  \u00ac Filter.Tendsto (fun n => f \u27e8u n, (def_2.1 n)\u27e9) Filter.atTop (nhds v_hat) := by\n  intro h\n  have : Filter.Tendsto (fun n => f \u27e8u n, (def_2.1 n)\u27e9) Filter.atTop (nhds v_hat) := by\n    rw [Metric.tendsto_atTop]\n    exact l3\n  contradiction"}, "type": "solution"}, "def_3": {"id": "def_3", "natural_language": "For the converse, suppose that \\eqref{eq:8.3.3} is false.", "statement": "Assumption (for contraposition):\n\u2022 $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$ is false [def_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {U V : Type*} [MetricSpace U] [MetricSpace V]\n  (D_f : Set U)\n  (f : D_f \u2192 V)\n  (u_hat : U)\n  (v_hat : V)\n  (tc_1 : u_hat \u2208 closure D_f)\n  (def_3 : \u00ac (Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat)))", "lean_pass": false, "error_msg": [{"line": 12, "column": 43, "endLine": 12, "endColumn": 48, "data": "application type mismatch\n  nhdsWithin u_hat\nargument\n  u_hat\nhas type\n  U : Type u_1\nbut is expected to have type\n  \u2191D_f : Type u_1"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "Then there is an $\\epsilon_0>0$...", "statement": "We assume:\n\u2022 $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$ is false [def_3].\nTherefore, we conclude:\n\u2022 There exists an $\\epsilon_0 > 0$ such that for all $\\delta > 0$, there exists a $u \\in D_f$ such that $\\rho(u, \\widehat{u}) < \\delta$ and $\\sigma(f(u), \\widehat{v}) \\ge \\epsilon_0$ [l4].", "dependencies": ["def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (def_3 : \u00ac (Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat))) :\n  \u2203 \u03b5_0 > 0, \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, dist u u_hat < \u03b4 \u2227 dist (f u) v_hat \u2265 \u03b5_0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (def_3 : \u00ac (Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat))) :\n  \u2203 \u03b5_0 > 0, \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, dist u u_hat < \u03b4 \u2227 dist (f u) v_hat \u2265 \u03b5_0 := by\n  simp only [Filter.Tendsto, Filter.le_def, mem_map, mem_nhds_iff] at def_3\n  push_neg at def_3\n  obtain \u27e8\u03b5\u2080, h\u03b5\u2080, h\u27e9 := def_3\n  use \u03b5\u2080, h\u03b5\u2080\n  intro \u03b4 h\u03b4\n  have h' := h \u03b4 h\u03b4\n  simp only [mem_nhdsWithin_iff, exists_prop, Metric.ball, setOf_subset_setOf] at h'\n  obtain \u27e8u, hu\u2081, hu\u2082\u27e9 := h'\n  exact \u27e8u, hu\u2081, hu\u2082\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 2, "endLine": 13, "endColumn": 13, "data": "type mismatch\n  \u03b5\u2080\nhas type\n  Set \u03b2 : Type u_2\nbut is expected to have type\n  \u211d : Type"}, {"line": 15, "column": 15, "endLine": 15, "endColumn": 16, "data": "application type mismatch\n  h \u03b4\nargument\n  \u03b4\nhas type\n  \u211d : Type\nbut is expected to have type\n  f \u207b\u00b9' \u03b5\u2080 \u2208 \ud835\udcdd[D_f] u_hat : Prop"}, {"line": 9, "column": 78, "endLine": 18, "endColumn": 21, "data": "unsolved goals\ncase right\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : MetricSpace \u03b2\nD_f : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nu_hat : \u03b1\nv_hat : \u03b2\n\u03b5\u2080 : Set \u03b2\nh\u03b5\u2080 : \u2203 t \u2286 \u03b5\u2080, IsOpen t \u2227 v_hat \u2208 t\nh : f \u207b\u00b9' \u03b5\u2080 \u2209 \ud835\udcdd[D_f] u_hat\n\u03b4 : \u211d\nh\u03b4 : \u03b4 > 0\n\u22a2 \u2203 u \u2208 D_f, Dist.dist u u_hat < \u03b4 \u2227 Dist.dist (f u) v_hat \u2265 sorry"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumption that the limit is false is correctly formalized using negation of Filter.Tendsto, which properly captures the mathematical meaning of the limit not existing or not equaling the specified value.", "The conclusion perfectly matches the natural language statement. The existential-universal quantifier structure is identical, and the distance constraints are properly translated from \u03c1/\u03c3 notation to Lean's dist function.", "The overall logical flow from assumption to conclusion is correctly preserved, representing the standard epsilon-delta characterization of limit failure in metric spaces.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (def_3 : \u00ac (Filter.Tendsto f (nhdsWithin u_hat D_f) (nhds v_hat))) :\n  \u00ac (\u2203 \u03b5_0 > 0, \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, dist u u_hat < \u03b4 \u2227 dist (f u) v_hat \u2265 \u03b5_0) := by\n  simp only [Metric.tendsto_nhdsWithin_nhds, not_forall, not_exists, not_lt] at def_3\n  rcases def_3 with \u27e8\u03b5, h\u03b5, h\u27e9\n  intro \u27e8\u03b5', h\u03b5', h'\u27e9\n  have := h \u03b5' h\u03b5'\n  simp [not_forall] at this\n  obtain \u27e8\u03b4, h\u03b4, h\u27e9 := this\n  obtain \u27e8u, hu\u2081, hu\u2082, hu\u2083\u27e9 := h' \u03b4 h\u03b4\n  exact h u hu\u2081 hu\u2082 hu\u2083"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "...and a sequence $\\{u_n\\}$ in $D_f$ such that $\\rho(u_n,\\widehat u)<1/n$ and $\\sigma(f(u_n),\\widehat v)\\ge\\epsilon_0$", "statement": "We assume:\n\u2022 There exists an $\\epsilon_0 > 0$ such that for all $\\delta > 0$, there exists a $u \\in D_f$ s.t. $\\rho(u, \\widehat{u}) < \\delta$ and $\\sigma(f(u), \\widehat{v}) \\ge \\epsilon_0$ [l4].\nTherefore, we conclude:\n\u2022 There exists a sequence $\\{u_n\\}$ in $D_f$ and an $\\epsilon_0 > 0$ such that for all integers $n \\ge 1$, we have $\\rho(u_n, \\widehat{u}) < 1/n$ and $\\sigma(f(u_n), \\widehat{v}) \\ge \\epsilon_0$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (l4 : \u2203 \u03b5_0 > 0, \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, dist u u_hat < \u03b4 \u2227 dist (f u) v_hat \u2265 \u03b5_0) :\n  \u2203 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2227 (\u2203 \u03b5_0 > 0, \u2200 (n : \u2115) (hn : n \u2265 1), dist (u_n n) u_hat < 1 / (n : \u211d) \u2227 dist (f (u_n n)) v_hat \u2265 \u03b5_0) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (l4 : \u2203 \u03b5_0 > 0, \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, dist u u_hat < \u03b4 \u2227 dist (f u) v_hat \u2265 \u03b5_0) :\n  \u2203 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2227 (\u2203 \u03b5_0 > 0, \u2200 (n : \u2115) (hn : n \u2265 1), dist (u_n n) u_hat < 1 / (n : \u211d) \u2227 dist (f (u_n n)) v_hat \u2265 \u03b5_0) := by\n  obtain \u27e8\u03b5\u2080, h\u03b5\u2080, h\u27e9 := l4\n  choose u hu using fun n : \u2115 => h (1/(n+1)) (by positivity)\n  refine \u27e8u, ?_, \u27e8\u03b5\u2080, h\u03b5\u2080, ?_\u27e9\u27e9\n  \u00b7 intro n; exact (hu n).1\n  \u00b7 intro n hn\n    have := (hu n).2\n    constructor\n    \u00b7 rw [dist_eq_norm] at this \u22a2\n      calc dist (u n) u_hat < 1 / (n + 1 : \u211d) := this.1\n      _ \u2264 1 / n := by\n        rw [one_div, one_div]\n        gcongr\n        exact Nat.cast_le.2 (Nat.succ_le_of_lt (Nat.pos_of_ne_zero (Nat.not_eq_zero_of_lt hn)))\n    \u00b7 exact this.2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 10, "endLine": 17, "endColumn": 22, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  Dist.dist ?a ?b\ncase intro.intro.refine_2.left\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : MetricSpace \u03b2\nD_f : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nu_hat : \u03b1\nv_hat : \u03b2\n\u03b5\u2080 : \u211d\nh\u03b5\u2080 : \u03b5\u2080 > 0\nh : \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, Dist.dist u u_hat < \u03b4 \u2227 Dist.dist (f u) v_hat \u2265 \u03b5\u2080\nu : \u2115 \u2192 \u03b1\nhu : \u2200 (n : \u2115), u n \u2208 D_f \u2227 Dist.dist (u n) u_hat < 1 / (\u2191n + 1) \u2227 Dist.dist (f (u n)) v_hat \u2265 \u03b5\u2080\nn : \u2115\nhn : n \u2265 1\nthis : Dist.dist (u n) u_hat < 1 / (\u2191n + 1) \u2227 Dist.dist (f (u n)) v_hat \u2265 \u03b5\u2080\n\u22a2 Dist.dist (u n) u_hat < 1 / \u2191n"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise l4 is correctly formalized - the existential quantification over \u03b5\u2080 > 0, universal quantification over \u03b4 > 0, and the existence of u \u2208 D_f with the required distance properties are all accurately captured.", "The conclusion l5 correctly formalizes the existence of a sequence and \u03b5\u2080 > 0 with the required properties for all n \u2265 1. The distance constraints are properly translated.", "The use of 'dist' for both \u03c1 and \u03c3 is appropriate in Lean's metric space context, and the variable name changes (\u00fb \u2192 u_hat, v\u0302 \u2192 v_hat) are standard notational adaptations that preserve meaning.", "The representation of the sequence as (u_n : \u2115 \u2192 \u03b1) is the standard and correct way to formalize sequences in Lean.", "The constraint that all sequence elements belong to D_f is correctly expressed as (\u2200 n, u_n n \u2208 D_f), which properly captures that the sequence is 'in D_f'.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (l4 : \u2203 \u03b5_0 > 0, \u2200 \u03b4 > 0, \u2203 u \u2208 D_f, dist u u_hat < \u03b4 \u2227 dist (f u) v_hat \u2265 \u03b5_0) :\n  \u00ac \u2203 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2227 (\u2203 \u03b5_0 > 0, \u2200 (n : \u2115) (hn : n \u2265 1), dist (u_n n) u_hat < 1 / (n : \u211d) \u2227 dist (f (u_n n)) v_hat \u2265 \u03b5_0) := by\n  intro h\n  rcases h with \u27e8u_n, h1, \u27e8\u03b5_0, h\u03b50, h2\u27e9\u27e9\n  have h3 : \u2200 \u03b4 > 0, \u2203 n : \u2115, 1 / (n : \u211d) < \u03b4 := by\n    intro \u03b4 h\u03b4\n    obtain \u27e8n, hn\u27e9 := exists_nat_one_div_lt h\u03b4\n    exact \u27e8n + 1, by simp; linarith\u27e9\n  rcases l4 with \u27e8\u03b5_0', h\u03b50', h4\u27e9\n  specialize h4 (\u03b5_0 / 2) (by linarith)\n  rcases h4 with \u27e8u, hu, h5\u27e9\n  specialize h3 (dist u u_hat) (by linarith [h5.1])\n  rcases h3 with \u27e8n, hn\u27e9\n  specialize h2 n (by linarith)\n  have h6 : dist (u_n n) u_hat < dist u u_hat := lt_trans h2.1 hn\n  have h7 : dist u u_hat < \u03b5_0 / 2 := h5.1\n  have h8 : dist (f (u_n n)) v_hat \u2265 \u03b5_0 := h2.2\n  have h9 : dist (f u) v_hat \u2265 \u03b5_0' := h5.2\n  linarith [h\u03b50, h\u03b50', h6, h7, h8, h9]"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "(implied by $\\rho(u_n,\\widehat u)<1/n$)", "statement": "We assume:\n\u2022 A sequence $\\{u_n\\}$ in $D_f$ exists such that for all $n \\ge 1$, $\\rho(u_n, \\widehat{u}) < 1/n$ [l5].\nTherefore, we conclude:\n\u2022 $\\lim_{n\\to\\infty} u_n = \\widehat u$ [l6].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (u_n : \u2115 \u2192 \u03b1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 dist (u_n n) u_hat < 1 / (n : \u211d)) :\n  Filter.Tendsto u_n Filter.atTop (nhds u_hat) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (u_n : \u2115 \u2192 \u03b1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 dist (u_n n) u_hat < 1 / (n : \u211d)) :\n  Filter.Tendsto u_n Filter.atTop (nhds u_hat) := by\n  rw [Metric.tendsto_atTop]\n  intro \u03b5 h\u03b5\n  let N := Nat.ceil (1 / \u03b5) + 1\n  use N\n  intro n hn\n  have hn' : n \u2265 1 := by linarith [Nat.le_of_add_le_right hn]\n  have := l5 n hn'\n  rw [dist_comm] at this\n  refine lt_of_lt_of_le this ?_\n  have : 1 / (n : \u211d) \u2264 1 / (N : \u211d) := by\n    refine one_div_le_one_div_of_le ?_ ?_\n    \u00b7 exact Nat.cast_pos.mpr (Nat.zero_lt_of_lt hn')\n    \u00b7 exact Nat.cast_le.mpr hn\n  refine le_trans this ?_\n  have : (N : \u211d) \u2265 1 / \u03b5 := by\n    exact Nat.le_ceil (1 / \u03b5) \u25b8 Nat.cast_le.mpr (Nat.le_add_left _ _)\n  rw [one_div_le] at this\n  \u00b7 linarith\n  \u00b7 exact Nat.cast_pos.mpr (Nat.zero_lt_of_lt hn')\n  \u00b7 exact h\u03b5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 35, "endLine": 16, "endColumn": 60, "data": "unknown constant 'Nat.le_of_add_le_right'"}, {"line": 18, "column": 6, "endLine": 18, "endColumn": 15, "data": "ambiguous, possible interpretations \n  _root_.dist_comm : \u2200 (x y : ?m.3354), Dist.dist x y = Dist.dist y x\n  \n  Nat.dist_comm : \u2200 (n m : \u2115), n.dist m = m.dist n"}, {"line": 18, "column": 6, "endLine": 18, "endColumn": 15, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.3602\ncase h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ninst\u271d : MetricSpace \u03b2\nD_f : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nu_hat : \u03b1\nv_hat : \u03b2\nu_n : \u2115 \u2192 \u03b1\nl5 : \u2200 n \u2265 1, Dist.dist (u_n n) u_hat < 1 / \u2191n\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nN : \u2115 := \u23081 / \u03b5\u2309\u208a + 1\nn : \u2115\nhn : n \u2265 N\nhn' : n \u2265 1\nthis : Dist.dist (u_n n) u_hat < 1 / \u2191n\n\u22a2 Dist.dist (u_n n) u_hat < \u03b5"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the distance condition \u03c1(u_n, \u00fb) < 1/n using dist (u_n n) u_hat < 1 / (n : \u211d) and properly formalizes the convergence conclusion using Filter.Tendsto. However, it misses the explicit constraint that the sequence {u_n} is in D_f, which should be formalized as \u2200 n, u_n n \u2208 D_f. The extra parameters f and v_hat are acceptable additions that don't contradict the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the distance condition \u03c1(u_n, \u00fb) < 1/n using dist (u_n n) u_hat < 1 / (n : \u211d) and properly formalizes the convergence conclusion using Filter.Tendsto. However, it misses the explicit constraint that the sequence {u_n} is in D_f, which should be formalized as \u2200 n, u_n n \u2208 D_f. The extra parameters f and v_hat are acceptable additions that don't contradict the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "...and $\\sigma(f(u_n),\\widehat v)\\ge\\epsilon_0$, so \\eqref{eq:8.3.4} is false.", "statement": "We assume:\n\u2022 There exists a sequence $\\{f(u_n)\\}$ and an $\\epsilon_0 > 0$ such that for all $n \\ge 1$, $\\sigma(f(u_n), \\widehat{v}) \\ge \\epsilon_0$ [l5].\nTherefore, we conclude:\n\u2022 The statement '$\\lim_{n\\to\\infty} f(u_n) = \\widehat v$' is false [l7].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (l5 : \u2203 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2227 (\u2203 \u03b5_0 > 0, \u2200 (n : \u2115) (hn : n \u2265 1), dist (u_n n) u_hat < 1 / (n : \u211d) \u2227 dist (f (u_n n)) v_hat \u2265 \u03b5_0)) :\n  \u00ac (Filter.Tendsto (fun n => f (l5.fst n)) Filter.atTop (nhds v_hat)) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 33, "endLine": 9, "endColumn": 41, "data": "function expected at\n  Exists.fst ?m.2288\nterm has type\n  ?m.2265"}, {"line": 9, "column": 33, "endLine": 9, "endColumn": 41, "data": "application type mismatch\n  Exists.fst l5\nargument\n  l5\nhas type\n  \u2203 u_n,\n    (\u2200 (n : \u2115), u_n n \u2208 D_f) \u2227\n      \u2203 \u03b5_0 > 0, \u2200 n \u2265 1, Dist.dist (u_n n) u_hat < 1 / \u2191n \u2227 Dist.dist (f (u_n n)) v_hat \u2265 \u03b5_0 : Prop\nbut is expected to have type\n  Exists ?m.2266 : Prop"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (l5 : \u2203 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2227 (\u2203 \u03b5_0 > 0, \u2200 (n : \u2115) (hn : n \u2265 1), dist (u_n n) u_hat < 1 / (n : \u211d) \u2227 dist (f (u_n n)) v_hat \u2265 \u03b5_0)) :\n  \u00ac (Filter.Tendsto (fun n => f (l5.choose n)) Filter.atTop (nhds v_hat)) := by\n  rcases l5 with \u27e8u_n, hu_n, \u03b5_0, h\u03b5_0, h\u27e9\n  intro h_tendsto\n  rcases Metric.tendsto_atTop.1 h_tendsto \u03b5_0 h\u03b5_0 with \u27e8N, hN\u27e9\n  have := h (N + 1) (by linarith)\n  have : dist (f (u_n (N + 1))) v_hat < \u03b5_0 := hN (N + 1) (by linarith)\n  linarith [this.2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 47, "endLine": 14, "endColumn": 71, "data": "type mismatch\n  hN (N + 1) ?m.6534\nhas type\n  Dist.dist (f (\u22ef.choose (N + 1))) v_hat < \u03b5_0 : Prop\nbut is expected to have type\n  Dist.dist (f (u_n (N + 1))) v_hat < \u03b5_0 : Prop"}, {"line": 15, "column": 12, "endLine": 15, "endColumn": 18, "data": "invalid projection, structure expected\n  this\nhas type\n  Dist.dist (f (u_n (N + 1))) v_hat < \u03b5_0"}, {"line": 15, "column": 12, "endLine": 15, "endColumn": 18, "data": "invalid projection, structure expected\n  this\nhas type\n  Real.lt\u271d (Dist.dist (f (u_n (N + 1))) v_hat) \u03b5_0"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "...a sequence $\\{u_n\\}$ in $D_f$ such that $\\rho(u_n,\\widehat u)<1/n$ and $\\sigma(f(u_n),\\widehat v)\\ge\\epsilon_0$, so \\eqref{eq:8.3.4} is false.", "statement": "We assume:\n\u2022 There exists a sequence $\\{u_n\\}$ in $D_f$ [l5].\n\u2022 For this sequence, $\\lim_{n\\to\\infty} u_n = \\widehat u$ [l6].\n\u2022 For this sequence, '$\\lim_{n\\to\\infty} f(u_n) = \\widehat v$' is false [l7].\nTherefore, we conclude:\n\u2022 There exists a sequence $\\{u_n\\}$ in $D_f$ such that $\\lim_{n\\to\\infty}u_n=\\widehat u$ and $\\lim_{n\\to\\infty}f(u_n) \\neq \\widehat v$ [l8].", "dependencies": ["l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (u_n : \u2115 \u2192 \u03b1)\n  (l5 : \u2200 n, u_n n \u2208 D_f)\n  (l6 : Filter.Tendsto u_n Filter.atTop (nhds u_hat))\n  (l7 : \u00ac Filter.Tendsto (fun n => f (u_n n)) Filter.atTop (nhds v_hat)) :\n  \u2203 (u_n' : \u2115 \u2192 \u03b1), (\u2200 n, u_n' n \u2208 D_f) \u2227 (Filter.Tendsto u_n' Filter.atTop (nhds u_hat)) \u2227 (\u00ac Filter.Tendsto (fun n => f (u_n' n)) Filter.atTop (nhds v_hat)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (u_n : \u2115 \u2192 \u03b1)\n  (l5 : \u2200 n, u_n n \u2208 D_f)\n  (l6 : Filter.Tendsto u_n Filter.atTop (nhds u_hat))\n  (l7 : \u00ac Filter.Tendsto (fun n => f (u_n n)) Filter.atTop (nhds v_hat)) :\n  \u2203 (u_n' : \u2115 \u2192 \u03b1), (\u2200 n, u_n' n \u2208 D_f) \u2227 (Filter.Tendsto u_n' Filter.atTop (nhds u_hat)) \u2227 (\u00ac Filter.Tendsto (fun n => f (u_n' n)) Filter.atTop (nhds v_hat)) := by\n  exact \u27e8u_n, l5, l6, l7\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language argument. The sequence membership conditions, convergence properties, and logical structure from assumptions to conclusion are all accurately represented. The use of Filter.Tendsto for limits and negation for the false convergence statement are appropriate mathematical formalizations. The trivial logical step from having a specific sequence to proving existence of such a sequence is preserved in both versions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "For the converse, suppose that \\eqref{eq:8.3.3} is false.\nThen there is an $\\epsilon_0>0$  and a sequence $\\{u_n\\}$\nin $D_f$ such that $\\rho(u_n,\\widehat u)<1/n$ and $\\sigma(f(u_n),\\widehat\nv)\\ge\\epsilon_0$, so \\eqref{eq:8.3.4} is false.", "statement": "We assume:\n\u2022 The assumption that '$\\lim_{u\\to \\widehat u}f(u)=\\widehat v$' is false [def_3] implies that there exists a sequence $\\{u_n\\}$ in $D_f$ such that $\\lim_{n\\to\\infty}u_n=\\widehat u$ but $\\lim_{n\\to\\infty}f(u_n) \\neq \\widehat v$ [l8].\nTherefore, we conclude:\n\u2022 If for every sequence $\\{u_n\\}$ in $D_f$ such that $\\lim_{n\\to\\infty}u_n=\\widehat u$, we have $\\lim_{n\\to\\infty}f(u_n)=\\widehat v$, then $\\lim_{u\\to \\widehat u}f(u)=\\widehat v$ [ts_2].", "dependencies": ["def_3", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (def_3 : \u00ac Filter.Tendsto (fun u => f u) (nhds u_hat) (nhds v_hat))\n  (l8 : \u2203 (u_n' : \u2115 \u2192 \u03b1), (\u2200 n, u_n' n \u2208 D_f) \u2227 (Filter.Tendsto u_n' Filter.atTop (nhds u_hat)) \u2227 (\u00ac Filter.Tendsto (fun n => f (u_n' n)) Filter.atTop (nhds v_hat))) :\n  (\u2200 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2192 (Filter.Tendsto u_n Filter.atTop (nhds u_hat)) \u2192 (Filter.Tendsto (fun n => f (u_n n)) Filter.atTop (nhds v_hat))) \u2192 Filter.Tendsto (fun u => f u) (nhds u_hat) (nhds v_hat) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {\u03b1 \u03b2 : Type*} [MetricSpace \u03b1] [MetricSpace \u03b2]\n  (D_f : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (u_hat : \u03b1) (v_hat : \u03b2)\n  (def_3 : \u00ac Filter.Tendsto (fun u => f u) (nhds u_hat) (nhds v_hat))\n  (l8 : \u2203 (u_n' : \u2115 \u2192 \u03b1), (\u2200 n, u_n' n \u2208 D_f) \u2227 (Filter.Tendsto u_n' Filter.atTop (nhds u_hat)) \u2227 (\u00ac Filter.Tendsto (fun n => f (u_n' n)) Filter.atTop (nhds v_hat))) :\n  (\u2200 (u_n : \u2115 \u2192 \u03b1), (\u2200 n, u_n n \u2208 D_f) \u2192 (Filter.Tendsto u_n Filter.atTop (nhds u_hat)) \u2192 (Filter.Tendsto (fun n => f (u_n n)) Filter.atTop (nhds v_hat))) \u2192 Filter.Tendsto (fun u => f u) (nhds u_hat) (nhds v_hat) := by\n  intro h\n  by_contra hneg\n  rcases l8 with \u27e8u_n', hu_n', hlim, hf\u27e9\n  specialize h u_n' hu_n' hlim\n  contradiction", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The individual components def_3 and l8 correctly capture their natural language counterparts using appropriate Lean/Mathlib notation for limits and sequences.", "The conclusion ts_2 correctly formalizes the sequential characterization of limits in metric spaces.", "The logical structure differs slightly: the natural language presents l8 as derived from def_3, while the Lean formalization treats both as independent premises. However, this doesn't affect the core mathematical meaning of the theorem being proved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    