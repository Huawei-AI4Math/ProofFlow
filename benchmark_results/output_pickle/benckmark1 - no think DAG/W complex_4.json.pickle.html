
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $C$ be the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 2+i$, and let the function to be integrated be $f(z) = \operatorname{Re}(z)$. Then the contour integral $\int_C f(z) dz$ is equal to $2+i$.

Proof: The path $C$ from $z_1=0$ to $z_2=2+i$ can be parameterized by $z(t) = t(2+i)$ for $t \in [0, 1]$. From this, the differential is $dz = (2+i)dt$. The integrand $f(z) = \operatorname{Re}(z)$ becomes $\operatorname{Re}(t(2+i)) = 2t$ along the path. Substituting these into the integral gives $\int_0^1 (2t)(2+i)dt$. Evaluating this integral results in $(2+i) \int_0^1 2t dt = (2+i) [t^2]_0^1 = 2+i$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $C$ be the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 2+i$", "statement": "Premise:\n\u2022 C is the straight-line path in the complex plane from z\u2081 = 0 to z\u2082 = 2+i [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (z1 z2 : \u2102)\n  (tc_1 : z1 = 0 \u2227 z2 = 2 + I)", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition z\u2081 = 0 is correctly captured in the Lean formalization as z1 = 0", "The condition z\u2082 = 2+i is correctly captured in the Lean formalization as z2 = 2 + I (where I represents the imaginary unit)", "The Lean formalization completely omits the definition of the straight-line path C, which is a key component of the natural language statement. The natural language specifically defines C as a path, but the Lean code only defines the endpoints without any mention of the path itself"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition z\u2081 = 0 is correctly captured in the Lean formalization as z1 = 0', 'The condition z\u2082 = 2+i is correctly captured in the Lean formalization as z2 = 2 + I (where I represents the imaginary unit)', 'The Lean formalization completely omits the definition of the straight-line path C, which is a key component of the natural language statement. The natural language specifically defines C as a path, but the Lean code only defines the endpoints without any mention of the path itself']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "let the function to be integrated be $f(z) = \\operatorname{Re}(z)$", "statement": "Premise:\n\u2022 The function to be integrated is f(z) = Re(z) [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (f : \u2102 \u2192 \u2102)\n(tc_2 : \u2200 (z : \u2102), f z = z.re)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the mathematical meaning that f(z) equals the real part of z, but there's a type inconsistency. The natural language f(z) = Re(z) suggests f should map complex numbers to real numbers, but Lean declares f : \u2102 \u2192 \u2102 (complex to complex). While z.re in Lean does give the real part, the function type should be \u2102 \u2192 \u211d to perfectly match the mathematical intent."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization captures the mathematical meaning that f(z) equals the real part of z, but there's a type inconsistency. The natural language f(z) = Re(z) suggests f should map complex numbers to real numbers, but Lean declares f : \u2102 \u2192 \u2102 (complex to complex). While z.re in Lean does give the real part, the function type should be \u2102 \u2192 \u211d to perfectly match the mathematical intent.\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "The path $C$ from $z_1=0$ to $z_2=2+i$ can be parameterized by $z(t) = t(2+i)$ for $t \\in [0, 1]$.", "statement": "We assume:\n\u2022 C is the straight-line path in the complex plane from z\u2081 = 0 to z\u2082 = 2+i [tc_1].\nTherefore, we conclude:\n\u2022 The path C can be parameterized by z(t) = t(2+i) for t \u2208 [0, 1] [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (z1 z2 : \u2102)\n  (tc_1 : z1 = 0 \u2227 z2 = 2 + I) :\n  (fun t : \u211d => t * (z2 - z1) + z1) = (fun t : \u211d => t * (2 + I)) \u2227 ({t : \u211d | 0 \u2264 t \u2227 t \u2264 1}) = Set.Icc 0 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (z1 z2 : \u2102)\n  (tc_1 : z1 = 0 \u2227 z2 = 2 + I) :\n  (fun t : \u211d => t * (z2 - z1) + z1) = (fun t : \u211d => t * (2 + I)) \u2227 ({t : \u211d | 0 \u2264 t \u2227 t \u2264 1}) = Set.Icc 0 1 := by\n  rcases tc_1 with \u27e8rfl, rfl\u27e9\n  simp\n  rfl", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premise is correctly formalized with z1 = 0 and z2 = 2 + I using appropriate Lean syntax for complex numbers.", "The parameterization is correctly captured using the general straight-line formula t*(z2-z1)+z1 which reduces to t*(2+I) when the specific values are substituted. The domain specification t \u2208 [0,1] is also properly formalized using set notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From this, the differential is $dz = (2+i)dt$.", "statement": "We assume:\n\u2022 The path C can be parameterized by z(t) = t(2+i) for t \u2208 [0, 1] [l1].\nTherefore, we conclude:\n\u2022 The derivative of the parameterization with respect to t is z'(t) = 2+i [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (z1 z2 : \u2102)\n  (l1 : (fun t : \u211d => t * (z2 - z1) + z1) = (fun t : \u211d => t * (2 + I)) \u2227 ({t : \u211d | 0 \u2264 t \u2227 t \u2264 1}) = Set.Icc 0 1) :\n  (deriv (fun t : \u211d => t * (2 + I)) : \u211d \u2192 \u2102) = (fun t : \u211d => (2 : \u2102) + I) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 44, "endLine": 7, "endColumn": 70, "data": "type mismatch\n  fun t => t * (2 + I)\nhas type\n  \u211d \u2192 \u211d : Type\nbut is expected to have type\n  \u211d \u2192 \u2102 : Type"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (z1 z2 : \u2102)\n  (l1 : (fun t : \u211d => t * (z2 - z1) + z1) = (fun t : \u211d => (t : \u2102) * (2 + I)) \u2227 ({t : \u211d | 0 \u2264 t \u2227 t \u2264 1}) = Set.Icc 0 1) :\n  (deriv (fun t : \u211d => (t : \u2102) * (2 + I))) = (fun t : \u211d => (2 : \u2102) + I) := by\n  simp only [deriv_mul_const_one, deriv_ofReal, one_mul]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 13, "endLine": 9, "endColumn": 32, "data": "unknown identifier 'deriv_mul_const_one'"}, {"line": 9, "column": 34, "endLine": 9, "endColumn": 46, "data": "unknown identifier 'deriv_ofReal'"}, {"line": 9, "column": 2, "endLine": 9, "endColumn": 56, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "The integrand $f(z) = \\operatorname{Re}(z)$ becomes $\\operatorname{Re}(t(2+i)) = 2t$ along the path.", "statement": "We assume:\n\u2022 The path C is parameterized by z(t) = t(2+i) for t \u2208 [0, 1] [l1].\n\u2022 The function to be integrated is f(z) = Re(z) [tc_2].\nTherefore, we conclude:\n\u2022 Along the path C, the value of the function is f(z(t)) = 2t [l3].", "dependencies": ["l1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (f : \u2102 \u2192 \u2102)\n  (t : \u211d)\n  (l1 : (fun t : \u211d => t * (2 + I)) = (fun t : \u211d => t * (2 + I)))\n  (tc_2 : \u2200 (z : \u2102), f z = z.re) :\n  f (t * (2 + I)) = 2 * t := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (f : \u2102 \u2192 \u2102)\n  (t : \u211d)\n  (l1 : (fun t : \u211d => t * (2 + I)) = (fun t : \u211d => t * (2 + I)))\n  (tc_2 : \u2200 (z : \u2102), f z = z.re) :\n  f (t * (2 + I)) = 2 * t := by\n  simp [tc_2]\n  simp [Complex.mul_re]\n  ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 2, "endLine": 12, "endColumn": 23, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise l1 is a meaningless tautological statement that doesn't actually define or constrain the path parameterization as intended in the natural language.", "The function definition tc_2 correctly captures that f(z) equals the real part of z for all complex numbers z.", "The conclusion correctly represents the composition f(z(t)) = f(t*(2+I)) = 2*t, matching the natural language statement.", "The domain constraint t \u2208 [0, 1] from the natural language is completely missing in the Lean formalization, which is a significant omission for a path integral setup.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The premise l1 is a meaningless tautological statement that doesn't actually define or constrain the path parameterization as intended in the natural language.\", 'The function definition tc_2 correctly captures that f(z) equals the real part of z for all complex numbers z.', 'The conclusion correctly represents the composition f(z(t)) = f(t*(2+I)) = 2*t, matching the natural language statement.', 'The domain constraint t \u2208 [0, 1] from the natural language is completely missing in the Lean formalization, which is a significant omission for a path integral setup.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Substituting these into the integral gives $\\int_0^1 (2t)(2+i)dt$.", "statement": "We assume:\n\u2022 We are evaluating the integral \u222b_C f(z) dz where C is a path from z\u2081=0 to z\u2082=2+i [tc_1] and f(z)=Re(z) [tc_2].\n\u2022 The path C is parameterized by z(t) = t(2+i) for t \u2208 [0, 1] [l1].\n\u2022 The derivative of the parameterization is z'(t) = 2+i [l2].\n\u2022 Along the path C, the value of the function is f(z(t)) = 2t [l3].\nTherefore, we conclude:\n\u2022 The contour integral \u222b_C f(z) dz is equal to the definite integral \u222b_0^1 (2t)(2+i) dt [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (z1 z2 : \u2102) (f : \u2102 \u2192 \u2102)\n  (tc_1 : z1 = 0 \u2227 z2 = 2 + I)\n  (tc_2 : \u2200 (z : \u2102), f z = z.re)\n  (l1 : (fun t : \u211d => t * (z2 - z1) + z1) = (fun t : \u211d => t * (2 + I)) \u2227 ({t : \u211d | 0 \u2264 t \u2227 t \u2264 1}) = Set.Icc 0 1)\n  (l2 : (fun t : \u211d => (deriv (fun s : \u211d => s * (2 + I)) t)) = (fun t : \u211d => (2 + I)))\n  (l3 : \u2200 (t : \u211d), f (t * (2 + I)) = 2 * t) :\n  (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (2 + I)) * (2 + I)) = \u222b (t : \u211d) in (Set.Icc 0 1), (2 * t) * (2 + I) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (z1 z2 : \u2102) (f : \u2102 \u2192 \u2102)\n  (tc_1 : z1 = 0 \u2227 z2 = 2 + I)\n  (tc_2 : \u2200 (z : \u2102), f z = z.re)\n  (l1 : (fun t : \u211d => t * (z2 - z1) + z1) = (fun t : \u211d => t * (2 + I)) \u2227 ({t : \u211d | 0 \u2264 t \u2227 t \u2264 1}) = Set.Icc 0 1)\n  (l2 : (fun t : \u211d => (deriv (fun s : \u211d => s * (2 + I)) t)) = (fun t : \u211d => (2 + I)))\n  (l3 : \u2200 (t : \u211d), f (t * (2 + I)) = 2 * t) :\n  (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (2 + I)) * (2 + I)) = \u222b (t : \u211d) in (Set.Icc 0 1), (2 * t) * (2 + I) := by\n  simp_rw [l3]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["tc_1 correctly captures both endpoint conditions z\u2081=0 and z\u2082=2+i using conjunction", "tc_2 properly formalizes f(z)=Re(z) as a universal quantification over complex numbers", "l1 correctly represents the parameterization z(t)=t(2+i) using the general linear form and properly defines the domain [0,1]", "l2 accurately formalizes the derivative condition z'(t)=2+i using Lean's deriv function", "l3 perfectly captures the function evaluation along the path f(z(t))=2t", "l4 correctly represents the contour integral equality using the standard parameterization formula, with both sides properly expressing the same mathematical relationship"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Evaluating this integral results in $(2+i) \\int_0^1 2t dt = (2+i) [t^2]_0^1 = 2+i$.", "statement": "We assume:\n\u2022 The contour integral \u222b_C f(z) dz is equal to the definite integral \u222b_0^1 (2t)(2+i) dt [l4].\nTherefore, we conclude:\n\u2022 The contour integral \u222b_C f(z) dz = 2+i [ts_1].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (z1 z2 : \u2102) (f : \u2102 \u2192 \u2102)\n  (l4 : (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (z2 - z1) + z1) * (deriv (fun s : \u211d => s * (z2 - z1) + z1) t)) = \u222b (t : \u211d) in (Set.Icc 0 1), (2 * t) * (2 + I)) :\n  (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (z2 - z1) + z1) * (deriv (fun s : \u211d => s * (z2 - z1) + z1) t)) = 2 + I := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (z1 z2 : \u2102) (f : \u2102 \u2192 \u2102)\n  (l4 : (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (z2 - z1) + z1) * (deriv (fun s : \u211d => s * (z2 - z1) + z1) t)) = \u222b (t : \u211d) in (Set.Icc 0 1), (2 * t) * (2 + I)) :\n  (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (z2 - z1) + z1) * (deriv (fun s : \u211d => s * (z2 - z1) + z1) t)) = 2 + I := by\n  rw [l4]\n  simp only [mul_assoc]\n  rw [integral_mul_left]\n  simp only [integral_Icc_zero_to_one_pow, Nat.cast_one, one_add_one_eq_two, mul_one]\n  norm_cast", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 6, "endLine": 11, "endColumn": 23, "data": "unknown identifier 'integral_mul_left'"}, {"line": 11, "column": 6, "endLine": 11, "endColumn": 23, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.6461\nI : \u211d\nz1 z2 : \u2102\nf : \u2102 \u2192 \u2102\nl4 :\n  \u222b (t : \u211d) in Set.Icc 0 1, f (\u2191t * (z2 - z1) + z1) * deriv (fun s => \u2191s * (z2 - z1) + z1) t =\n    \u2191(\u222b (t : \u211d) in Set.Icc 0 1, 2 * t * (2 + I))\n\u22a2 \u2191(\u222b (t : \u211d) in Set.Icc 0 1, 2 * (t * (2 + I))) = 2 + \u2191I"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumption is represented differently - natural language uses abstract contour integral notation while Lean uses explicit parameterized line integral form. However, this is mathematically equivalent and more precise.", "The conclusion correctly captures that the integral equals 2+i (represented as 2 + I in Lean).", "The logical flow from assumption to conclusion is properly preserved in the Lean formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter Complex\n\nlemma neg_ts_1\n  (z1 z2 : \u2102) (f : \u2102 \u2192 \u2102)\n  (l4 : (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (z2 - z1) + z1) * (deriv (fun s : \u211d => s * (z2 - z1) + z1) t)) = \u222b (t : \u211d) in (Set.Icc 0 1), (2 * t) * (2 + I)) :\n  \u00ac (\u222b (t : \u211d) in (Set.Icc 0 1), f (t * (z2 - z1) + z1) * (deriv (fun s : \u211d => s * (z2 - z1) + z1) t)) = 2 + I := by\n  rw [l4]\n  have : deriv (fun s : \u211d => s * (z2 - z1) + z1) = fun _ => (z2 - z1) := by\n    ext x\n    simp [deriv_add_const, deriv_mul_const_left]\n  simp [this]\n  rw [\u2190 integral_mul_const]\n  simp only [mul_assoc]\n  rw [integral_mul_right]\n  norm_num\n  ring"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    