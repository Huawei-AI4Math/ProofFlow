
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $P=\{a_{n_i}\}_1^\infty$ and
$Q=
\{a_{m_j}\}_1^\infty$ are respectively the subsequences of all
positive and
negative terms in a conditionally convergent series $\sum a_n,$ then
\begin{equation} \label{eq:4.3.24}
\sum_{i=1}^\infty a_{n_i}=\infty\mbox{\quad and\quad}\sum_{j=1}^\infty
a_{m_j}=-\infty.
\end{equation}

Proof: If both  series in \eqref{eq:4.3.24} converge, then $\sum
a_n$ converges absolutely, while if one converges and the other
diverges, then $\sum a_n$ diverges to $\infty$ or $-\infty$. Hence,
both must diverge.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $P=\\{a_{n_i}\\}_1^\\infty$ and\n$Q=\n\\{a_{m_j}\\}_1^\\infty$ are respectively the subsequences of all\npositive and\nnegative terms in a conditionally convergent series $\\sum a_n,$", "statement": "Premise:\n\u2022 Let $\\{a_n\\}$ be a sequence of real numbers. Let $P=\\{a_{n_i}\\}_{i=1}^\\infty$ be the subsequence of all positive terms of $\\{a_n\\}$, and $Q=\\{a_{m_j}\\}_{j=1}^\\infty$ be the subsequence of all negative terms of $\\{a_n\\}$. The series $\\sum a_n$ is conditionally convergent, which means that $\\sum_{n=1}^\\infty a_n$ converges to a finite limit, but $\\sum_{n=1}^\\infty |a_n|$ diverges [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(P : \u2115 \u2192 \u211d)\n(Q : \u2115 \u2192 \u211d)\n(n_i m_j : \u2115 \u2192 \u2115)\n(tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.83, "semantic_feedback": ["The Lean formalization correctly captures that a is a sequence of real numbers", "The Lean condition correctly states that P consists of positive terms from the original sequence via indexing function n_i", "The Lean condition correctly states that Q consists of negative terms from the original sequence via indexing function m_j", "The Lean formalization correctly captures convergence to a finite limit using Summable a and the existence of L", "The Lean formalization correctly captures divergence of the absolute series using \u00ac Summable (fun n \u21a6 |a n|)", "The conclusion about conditional convergence is not explicitly stated in Lean but is implicitly captured by the combination of convergence of the series and divergence of the absolute series"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "If both  series in \\eqref{eq:4.3.24} converge, then $\\sum\na_n$ converges absolutely", "statement": "We assume:\n\u2022 Let $\\{a_n\\}$ be a sequence of real numbers, with its subsequence of positive terms being $P=\\{a_{n_i}\\}_{i=1}^\\infty$ and its subsequence of negative terms being $Q=\\{a_{m_j}\\}_{j=1}^\\infty$ [from tc_1].\n\u2022 The series of positive terms converges: $\\sum_{i=1}^\\infty a_{n_i} = L_P$.\n\u2022 The series of negative terms converges: $\\sum_{j=1}^\\infty a_{m_j} = L_Q$.\nTherefore, we conclude:\n\u2022 The series $\\sum a_n$ converges absolutely [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (Q : \u2115 \u2192 \u211d)\n  (n_i m_j : \u2115 \u2192 \u2115)\n  (tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))\n  (hP : Summable P)\n  (hQ : Summable Q) :\n  Summable (fun n \u21a6 |a n|) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (Q : \u2115 \u2192 \u211d)\n  (n_i m_j : \u2115 \u2192 \u2115)\n  (tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))\n  (hP : Summable P)\n  (hQ : Summable Q) :\n  Summable (fun n \u21a6 |a n|) := by\n  have h1 := tc_1.left\n  have h2 := tc_1.right.left\n  have h3 := tc_1.right.right.left\n  have h4 := tc_1.right.right.right\n  have h_pos : \u2200 n, a n > 0 \u2192 \u2203 i, n = n_i i := by\n    intro n hn\n    obtain \u27e8i, hi\u27e9 := Function.surjInv h1 hn\n    exact \u27e8i, hi\u27e9\n  have h_neg : \u2200 n, a n < 0 \u2192 \u2203 j, n = m_j j := by\n    intro n hn\n    obtain \u27e8j, hj\u27e9 := Function.surjInv h2 hn\n    exact \u27e8j, hj\u27e9\n  have h_zero : \u2200 n, a n = 0 \u2192 (\u2200 i, n \u2260 n_i i) \u2227 \u2200 j, n \u2260 m_j j := by\n    intro n hn\n    constructor\n    intro i h\n    rw [h, \u2190 (h1 i).left, hn] at (h1 i).right\n    exact lt_irrefl _ (h1 i).right\n    intro j h\n    rw [h, \u2190 (h2 j).left, hn] at (h2 j).right\n    exact lt_irrefl _ (lt_trans (h2 j).right (by norm_num))\n  apply Summable.of_nonneg_of_le _ _ hP\n  intro n\n  split_ifs with hn hn'\n  exact le_of_lt hn\n  exact le_of_lt (neg_pos.mpr (by rwa [neg_neg]))\n  exact le_refl 0\n  intro n\n  by_cases hn : a n > 0\n  obtain \u27e8i, hi\u27e9 := h_pos n hn\n  rw [hi, abs_of_pos hn, (h1 i).left.symm]\n  by_cases hn' : a n < 0\n  obtain \u27e8j, hj\u27e9 := h_neg n hn'\n  rw [hj, abs_of_neg hn', neg_neg, (h2 j).left.symm]\n  push_neg at hn hn'\n  have hn'' : a n = 0 := le_antisymm hn' hn\n  rw [hn'', abs_zero]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 39, "endLine": 20, "endColumn": 41, "data": "application type mismatch\n  Function.surjInv h1\nargument\n  h1\nhas type\n  \u2200 (i : \u2115), P i = a (n_i i) \u2227 P i > 0 : Prop\nbut is expected to have type\n  Function.Surjective ?m.2153 : Prop"}, {"line": 20, "column": 11, "endLine": 20, "endColumn": 18, "data": "rcases tactic failed: x\u271d : ?m.2151 is not an inductive datatype"}, {"line": 24, "column": 39, "endLine": 24, "endColumn": 41, "data": "application type mismatch\n  Function.surjInv h2\nargument\n  h2\nhas type\n  \u2200 (j : \u2115), Q j = a (m_j j) \u2227 Q j < 0 : Prop\nbut is expected to have type\n  Function.Surjective ?m.2569 : Prop"}, {"line": 24, "column": 11, "endLine": 24, "endColumn": 18, "data": "rcases tactic failed: x\u271d : ?m.2567 is not an inductive datatype"}, {"line": 30, "column": 33, "endLine": 30, "endColumn": 45, "data": "unexpected term '(h1 i).right'; expected single reference to variable"}, {"line": 37, "column": 2, "endLine": 37, "endColumn": 23, "data": "tactic 'split_ifs' failed, no if-then-else conditions to split\na P Q : \u2115 \u2192 \u211d\nn_i m_j : \u2115 \u2192 \u2115\ntc_1 :\n  (\u2200 (i : \u2115), P i = a (n_i i) \u2227 P i > 0) \u2227\n    (\u2200 (j : \u2115), Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L) \u2227 \u00acSummable fun n => |a n|\nhP : Summable P\nhQ : Summable Q\nh1 : \u2200 (i : \u2115), P i = a (n_i i) \u2227 P i > 0\nh2 : \u2200 (j : \u2115), Q j = a (m_j j) \u2227 Q j < 0\nh3 : \u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L\nh4 : \u00acSummable fun n => |a n|\nh_pos : \u2200 (n : \u2115), a n > 0 \u2192 \u2203 i, n = n_i i\nh_neg : \u2200 (n : \u2115), a n < 0 \u2192 \u2203 j, n = m_j j\nh_zero : \u2200 (n : \u2115), a n = 0 \u2192 (\u2200 (i : \u2115), n \u2260 n_i i) \u2227 \u2200 (j : \u2115), n \u2260 m_j j\nn : \u2115\n\u22a2 0 \u2264 |a n|"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization contains a critical logical contradiction. The premise tc_1 includes '\u00ac Summable (fun n \u21a6 |a n|)' which states that the series does NOT converge absolutely, but this directly contradicts the conclusion we're trying to prove. Additionally, tc_1 assumes the original series \u2211a\u2099 converges, which is not stated in the natural language premise. The natural language only assumes convergence of the positive and negative subsequences separately. Furthermore, the formalization doesn't account for the completeness requirement - that every non-zero term appears in either P or Q, which is necessary for the mathematical reasoning to be valid.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization contains a critical logical contradiction. The premise tc_1 includes '\u00ac Summable (fun n \u21a6 |a n|)' which states that the series does NOT converge absolutely, but this directly contradicts the conclusion we're trying to prove. Additionally, tc_1 assumes the original series \u2211a\u2099 converges, which is not stated in the natural language premise. The natural language only assumes convergence of the positive and negative subsequences separately. Furthermore, the formalization doesn't account for the completeness requirement - that every non-zero term appears in either P or Q, which is necessary for the mathematical reasoning to be valid.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "while if one converges and the other\ndiverges, then $\\sum a_n$ diverges to $\\infty$ or $-\\infty$.", "statement": "We assume:\n\u2022 Let $\\{a_n\\}$ be a sequence of real numbers, with its subsequence of positive terms being $P=\\{a_{n_i}\\}_{i=1}^\\infty$ and its subsequence of negative terms being $Q=\\{a_{m_j}\\}_{j=1}^\\infty$ [from tc_1].\n\u2022 One of the series, $\\sum a_{n_i}$ or $\\sum a_{m_j}$, converges to a finite limit, while the other diverges.\nTherefore, we conclude:\n\u2022 The series $\\sum a_n$ diverges to $\\infty$ or $-\\infty$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d) (P : \u2115 \u2192 \u211d) (Q : \u2115 \u2192 \u211d) (n_i m_j : \u2115 \u2192 \u2115)\n  (tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))\n  (hP_converges : Summable P \u2227 \u00ac Summable Q \u2192 \u2203 L : \u211d, (\u2211' (n : \u2115), a n) = L)\n  (hQ_converges : Summable Q \u2227 \u00ac Summable P \u2192 \u2203 L : \u211d, (\u2211' (n : \u2115), a n) = L) :\n  (Summable P \u2227 \u00ac Summable Q \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot)) \u2227\n  (Summable Q \u2227 \u00ac Summable P \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d) (P : \u2115 \u2192 \u211d) (Q : \u2115 \u2192 \u211d) (n_i m_j : \u2115 \u2192 \u2115)\n  (tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))\n  (hP_converges : Summable P \u2227 \u00ac Summable Q \u2192 \u2203 L : \u211d, (\u2211' (n : \u2115), a n) = L)\n  (hQ_converges : Summable Q \u2227 \u00ac Summable P \u2192 \u2203 L : \u211d, (\u2211' (n : \u2115), a n) = L) :\n  (Summable P \u2227 \u00ac Summable Q \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot)) \u2227\n  (Summable Q \u2227 \u00ac Summable P \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot)) := by\n  constructor\n  \u00b7 intro \u27e8hP, hnQ\u27e9\n    obtain \u27e8L, hL\u27e9 := hP_converges \u27e8hP, hnQ\u27e9\n    have hsum_a : Summable a \u2227 \u2211' n, a n = L := tc_1.right.right.left\n    have hpos : Tendsto (fun N => \u2211 n in Finset.range N, P n) atTop (\ud835\udcdd (\u2211' n, P n)) :=\n      Summable.tendsto_sum_nat hP\n    have hneg : Tendsto (fun N => \u2211 n in Finset.range N, Q n) atTop atBot := by\n      refine tendsto_atBot_of_not_summable hnQ ?_\n      intro n\n      exact (tc_1.right.left n).right\n    rw [\u2190hL] at hsum_a\n    left\n    refine tendsto_atTop_of_tendsto_atTop_add hpos hneg ?_\n    intro N\n    simp only [Finset.sum_range_add_sum_range, (tc_1.left _).1, (tc_1.right.left _).1]\n  \u00b7 intro \u27e8hQ, hnP\u27e9\n    obtain \u27e8L, hL\u27e9 := hQ_converges \u27e8hQ, hnP\u27e9\n    have hsum_a : Summable a \u2227 \u2211' n, a n = L := tc_1.right.right.left\n    have hneg : Tendsto (fun N => \u2211 n in Finset.range N, Q n) atTop (\ud835\udcdd (\u2211' n, Q n)) :=\n      Summable.tendsto_sum_nat hQ\n    have hpos : Tendsto (fun N => \u2211 n in Finset.range N, P n) atTop atTop := by\n      refine tendsto_atTop_of_not_summable hnP ?_\n      intro n\n      exact (tc_1.left n).right\n    rw [\u2190hL] at hsum_a\n    right\n    refine tendsto_atBot_of_tendsto_atTop_add hpos hneg ?_\n    intro N\n    simp only [Finset.sum_range_add_sum_range, (tc_1.left _).1, (tc_1.right.left _).1]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 48, "endLine": 15, "endColumn": 69, "data": "type mismatch\n  tc_1.right.right.left\nhas type\n  \u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L : Prop\nbut is expected to have type\n  Summable a \u2227 \u2211' (n : \u2115), a n = L : Prop"}, {"line": 17, "column": 6, "endLine": 17, "endColumn": 33, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Summable\nhas type\n  (?m.3905 \u2192 ?m.3904) \u2192 Prop"}, {"line": 19, "column": 13, "endLine": 19, "endColumn": 42, "data": "unknown identifier 'tendsto_atBot_of_not_summable'"}, {"line": 20, "column": 6, "endLine": 20, "endColumn": 13, "data": "no goals to be solved"}, {"line": 24, "column": 11, "endLine": 24, "endColumn": 45, "data": "unknown identifier 'tendsto_atTop_of_tendsto_atTop_add'"}, {"line": 25, "column": 4, "endLine": 25, "endColumn": 11, "data": "no goals to be solved"}, {"line": 29, "column": 48, "endLine": 29, "endColumn": 69, "data": "type mismatch\n  tc_1.right.right.left\nhas type\n  \u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L : Prop\nbut is expected to have type\n  Summable a \u2227 \u2211' (n : \u2115), a n = L : Prop"}, {"line": 31, "column": 6, "endLine": 31, "endColumn": 33, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Summable\nhas type\n  (?m.8123 \u2192 ?m.8122) \u2192 Prop"}, {"line": 33, "column": 13, "endLine": 33, "endColumn": 42, "data": "unknown identifier 'tendsto_atTop_of_not_summable'"}, {"line": 34, "column": 6, "endLine": 34, "endColumn": 13, "data": "no goals to be solved"}, {"line": 38, "column": 11, "endLine": 38, "endColumn": 45, "data": "unknown identifier 'tendsto_atBot_of_tendsto_atTop_add'"}, {"line": 39, "column": 4, "endLine": 39, "endColumn": 11, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization contains a logical contradiction. The condition tc_1 states that the series \u2211a\u2099 converges to some limit L, but the conclusion claims that under certain conditions, the same series diverges to \u00b1\u221e. A convergent series cannot simultaneously diverge. The natural language seems to describe a general principle about conditionally convergent series, but the Lean formalization incorrectly mixes the assumption of convergence with a conclusion of divergence.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization contains a logical contradiction. The condition tc_1 states that the series \u2211a\u2099 converges to some limit L, but the conclusion claims that under certain conditions, the same series diverges to \u00b1\u221e. A convergent series cannot simultaneously diverge. The natural language seems to describe a general principle about conditionally convergent series, but the Lean formalization incorrectly mixes the assumption of convergence with a conclusion of divergence.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Hence,\nboth must diverge.", "statement": "We assume:\n\u2022 For a series $\\sum a_n$ with positive part $\\sum a_{n_i}$ and negative part $\\sum a_{m_j}$: the series $\\sum a_n$ is conditionally convergent, meaning it converges but not absolutely [tc_1].\n\u2022 If both $\\sum a_{n_i}$ and $\\sum a_{m_j}$ converge, then $\\sum a_n$ converges absolutely [l1].\n\u2022 If one of $\\sum a_{n_i}$ or $\\sum a_{m_j}$ converges and the other diverges, then $\\sum a_n$ diverges to $\\pm\\infty$ [l2].\nTherefore, we conclude:\n\u2022 Both $\\sum a_{n_i}$ and $\\sum a_{m_j}$ must diverge. Since all terms in $\\{a_{n_i}\\}$ are positive, its sum must diverge to $\\infty$. Since all terms in $\\{a_{m_j}\\}$ are negative, its sum must diverge to $-\\infty$ [ts_1].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (Q : \u2115 \u2192 \u211d)\n  (n_i m_j : \u2115 \u2192 \u2115)\n  (tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))\n  (l1 : Summable P \u2192 Summable Q \u2192 Summable (fun n \u21a6 |a n|))\n  (l2 : (Summable P \u2227 \u00ac Summable Q \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot)) \u2227 (Summable Q \u2227 \u00ac Summable P \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot))) :\n  (\u00ac Summable P \u2227 \u00ac Summable Q) \u2227 (Tendsto (fun N => \u2211 n in Finset.range N, P n) atTop atTop) \u2227 (Tendsto (fun N => \u2211 n in Finset.range N, Q n) atTop atBot) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (P : \u2115 \u2192 \u211d)\n  (Q : \u2115 \u2192 \u211d)\n  (n_i m_j : \u2115 \u2192 \u2115)\n  (tc_1 : (\u2200 i, P i = a (n_i i) \u2227 P i > 0) \u2227 (\u2200 j, Q j = a (m_j j) \u2227 Q j < 0) \u2227 (\u2203 L : \u211d, Summable a \u2227 (\u2211' (n : \u2115), a n) = L) \u2227 \u00ac Summable (fun n \u21a6 |a n|))\n  (l1 : Summable P \u2192 Summable Q \u2192 Summable (fun n \u21a6 |a n|))\n  (l2 : (Summable P \u2227 \u00ac Summable Q \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot)) \u2227 (Summable Q \u2227 \u00ac Summable P \u2192 (Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atTop \u2228 Tendsto (fun N => \u2211 n in Finset.range N, a n) atTop atBot))) :\n  (\u00ac Summable P \u2227 \u00ac Summable Q) \u2227 (Tendsto (fun N => \u2211 n in Finset.range N, P n) atTop atTop) \u2227 (Tendsto (fun N => \u2211 n in Finset.range N, Q n) atTop atBot) := by\n  obtain \u27e8hP, hQ, sum_a, not_sum_abs\u27e9 := tc_1\n  constructor\n  \u00b7 constructor\n    \u00b7 intro sumP\n      have := l1 sumP\n      exact not_sum_abs (this (by assumption))\n    \u00b7 intro sumQ\n      have := l1 \u00b7 sumQ\n      exact not_sum_abs (this sumQ)\n  \u00b7 constructor\n    \u00b7 have hP' : \u2200 n, 0 \u2264 P n := fun n => (hP n).2.le\n      have : \u00acSummable P := by\n        intro sumP\n        exact not_sum_abs (l1 sumP (by assumption))\n      exact tendsto_atTop_of_nonneg_of_not_summable hP' this\n    \u00b7 have hQ' : \u2200 n, Q n \u2264 0 := fun n => (hQ n).2.le\n      have : \u00acSummable Q := by\n        intro sumQ\n        exact not_sum_abs (l1 (by assumption) sumQ)\n      exact tendsto_atBot_of_nonpos_of_not_summable hQ' this", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 34, "endLine": 19, "endColumn": 44, "data": "tactic 'assumption' failed\na P Q : \u2115 \u2192 \u211d\nn_i m_j : \u2115 \u2192 \u2115\nl1 : Summable P \u2192 Summable Q \u2192 Summable fun n => |a n|\nl2 :\n  (Summable P \u2227 \u00acSummable Q \u2192\n      Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atTop \u2228\n        Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atBot) \u2227\n    (Summable Q \u2227 \u00acSummable P \u2192\n      Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atTop \u2228\n        Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atBot)\nhP : \u2200 (i : \u2115), P i = a (n_i i) \u2227 P i > 0\nhQ : \u2200 (j : \u2115), Q j = a (m_j j) \u2227 Q j < 0\nsum_a : \u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L\nnot_sum_abs : \u00acSummable fun n => |a n|\nsumP : Summable P\nthis : Summable Q \u2192 Summable fun n => |a n|\n\u22a2 Summable Q"}, {"line": 21, "column": 17, "endLine": 21, "endColumn": 18, "data": "invalid occurrence of `\u00b7` notation, it must be surrounded by parentheses (e.g. `(\u00b7 + 1)`)"}, {"line": 22, "column": 25, "endLine": 22, "endColumn": 34, "data": "function expected at\n  this\nterm has type\n  Summable fun n => |a n|"}, {"line": 27, "column": 39, "endLine": 27, "endColumn": 49, "data": "tactic 'assumption' failed\na P Q : \u2115 \u2192 \u211d\nn_i m_j : \u2115 \u2192 \u2115\nl1 : Summable P \u2192 Summable Q \u2192 Summable fun n => |a n|\nl2 :\n  (Summable P \u2227 \u00acSummable Q \u2192\n      Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atTop \u2228\n        Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atBot) \u2227\n    (Summable Q \u2227 \u00acSummable P \u2192\n      Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atTop \u2228\n        Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atBot)\nhP : \u2200 (i : \u2115), P i = a (n_i i) \u2227 P i > 0\nhQ : \u2200 (j : \u2115), Q j = a (m_j j) \u2227 Q j < 0\nsum_a : \u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L\nnot_sum_abs : \u00acSummable fun n => |a n|\nhP' : \u2200 (n : \u2115), 0 \u2264 P n\nsumP : Summable P\n\u22a2 Summable Q"}, {"line": 28, "column": 12, "endLine": 28, "endColumn": 51, "data": "unknown identifier 'tendsto_atTop_of_nonneg_of_not_summable'"}, {"line": 32, "column": 34, "endLine": 32, "endColumn": 44, "data": "tactic 'assumption' failed\na P Q : \u2115 \u2192 \u211d\nn_i m_j : \u2115 \u2192 \u2115\nl1 : Summable P \u2192 Summable Q \u2192 Summable fun n => |a n|\nl2 :\n  (Summable P \u2227 \u00acSummable Q \u2192\n      Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atTop \u2228\n        Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atBot) \u2227\n    (Summable Q \u2227 \u00acSummable P \u2192\n      Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atTop \u2228\n        Tendsto (fun N => \u2211 n \u2208 Finset.range N, a n) atTop atBot)\nhP : \u2200 (i : \u2115), P i = a (n_i i) \u2227 P i > 0\nhQ : \u2200 (j : \u2115), Q j = a (m_j j) \u2227 Q j < 0\nsum_a : \u2203 L, Summable a \u2227 \u2211' (n : \u2115), a n = L\nnot_sum_abs : \u00acSummable fun n => |a n|\nhQ' : \u2200 (n : \u2115), Q n \u2264 0\nsumQ : Summable Q\n\u22a2 Summable P"}, {"line": 33, "column": 12, "endLine": 33, "endColumn": 51, "data": "unknown identifier 'tendsto_atBot_of_nonpos_of_not_summable'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization fails to capture the logical deduction structure present in the natural language. The natural language presents a theorem where the conclusion follows from the premises, but the Lean code treats this as an independent lemma without establishing the logical connection.", "The formalization doesn't explicitly ensure that the positive and negative parts form a complete decomposition of the original series. The natural language assumes this decomposition is complete and disjoint.", "The index functions n_i and m_j are not constrained to be increasing sequences that partition \u2115, which is the standard interpretation of positive/negative part decomposition in series theory.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization fails to capture the logical deduction structure present in the natural language. The natural language presents a theorem where the conclusion follows from the premises, but the Lean code treats this as an independent lemma without establishing the logical connection.', \"The formalization doesn't explicitly ensure that the positive and negative parts form a complete decomposition of the original series. The natural language assumes this decomposition is complete and disjoint.\", 'The index functions n_i and m_j are not constrained to be increasing sequences that partition \u2115, which is the standard interpretation of positive/negative part decomposition in series theory.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    