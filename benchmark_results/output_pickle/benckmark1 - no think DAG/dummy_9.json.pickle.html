
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $(a_n)$ is an arithmetic sequence with $a_1 = 5$ and $a_3 = 11$, then $a_5 = 17$.

Proof: Since $(a_n)$ is arithmetic, there exists a common difference $d$ such that $a_n = a_1 + (n-1)d$ for all $n$. From the given information, $a_3 = a_1 + 2d$. Substituting the values: $11 = 5 + 2d$, which gives us $2d = 6$, so $d = 3$. Now we can find $a_5 = a_1 + 4d = 5 + 4(3) = 5 + 12 = 17$
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Since $(a_n)$ is arithmetic, there exists a common difference $d$ such that $a_n = a_1 + (n-1)d$ for all $n$.", "statement": "Premise:\n\u2022 $(a_n)$ is an arithmetic sequence, which means there exists a common difference $d$ such that $a_n = a_1 + (n-1)d$ for all integers $n \\ge 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures that (a_n) is an arithmetic sequence through the existence of a common difference d with the appropriate formula", "The mathematical formula and existence statement match perfectly, but there's a minor difference in the domain: the natural language mentions 'integers n \u2265 1' while Lean uses '\u2115' (natural numbers). Since natural numbers \u2265 1 are a subset of integers \u2265 1, this is a minor restriction that doesn't change the essential meaning"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that (a_n) is an arithmetic sequence through the existence of a common difference d with the appropriate formula', \"The mathematical formula and existence statement match perfectly, but there's a minor difference in the domain: the natural language mentions 'integers n \u2265 1' while Lean uses '\u2115' (natural numbers). Since natural numbers \u2265 1 are a subset of integers \u2265 1, this is a minor restriction that doesn't change the essential meaning\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $(a_n)$ is an arithmetic sequence with $a_1 = 5$ and $a_3 = 11$", "statement": "Premise:\n\u2022 For the arithmetic sequence $(a_n)$ defined in [tc_1], we are given that $a_1 = 5$ and $a_3 = 11$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n(tc_2 : a 1 = 5 \u2227 a 3 = 11)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly defines an arithmetic sequence using the standard mathematical definition with a common difference d and the formula a_n = a_1 + (n-1)*d", "The condition a_1 = 5 is exactly captured in the first part of the conjunction in tc_2", "The condition a_3 = 11 is exactly captured in the second part of the conjunction in tc_2"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "From the given information, $a_3 = a_1 + 2d$.", "statement": "We assume:\n\u2022 $(a_n)$ is an arithmetic sequence with the formula $a_n = a_1 + (n-1)d$ for a common difference $d$ [tc_1].\nTherefore, we conclude:\n\u2022 For $n=3$, the formula yields $a_3 = a_1 + (3-1)d = a_1 + 2d$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d) :\n  a 3 = a 1 + 2 * (Classical.choose tc_1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d) :\n  a 3 = a 1 + 2 * (Classical.choose tc_1) := by\n  let d := Classical.choose tc_1\n  have hd : \u2200 n \u2265 1, a n = a 1 + (n - 1) * d := Classical.choose_spec tc_1\n  have h3 : 3 \u2265 1 := by norm_num\n  rw [hd 3 h3]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The arithmetic sequence assumption is correctly formalized using existential quantification over the common difference and universal quantification over valid indices with the proper formula.", "The conclusion for n=3 is correctly represented, with Classical.choose appropriately extracting the common difference from the existential hypothesis, and the arithmetic simplification (3-1)d = 2d properly captured."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Substituting the values: $11 = 5 + 2d$", "statement": "We assume:\n\u2022 $a_1 = 5$ and $a_3 = 11$ [tc_2].\n\u2022 $a_3 = a_1 + 2d$ [l1].\nTherefore, we conclude:\n\u2022 $11 = 5 + 2d$ [l2].", "dependencies": ["tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (tc_2 : a 1 = 5 \u2227 a 3 = 11)\n  (l1 : a 3 = a 1 + 2 * (Classical.choose tc_1)) :\n  11 = 5 + 2 * (Classical.choose tc_1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (tc_2 : a 1 = 5 \u2227 a 3 = 11)\n  (l1 : a 3 = a 1 + 2 * (Classical.choose tc_1)) :\n  11 = 5 + 2 * (Classical.choose tc_1) := by\n  rw [\u2190 tc_2.2, l1, tc_2.1]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 20, "endLine": 11, "endColumn": 26, "data": "tactic 'rewrite' failed, motive is not type correct:\n  fun _a => _a + 2 * Classical.choose tc_1 = 5 + 2 * Classical.choose tc_1\nError: application type mismatch\n  Classical.choose tc_1\nargument\n  tc_1\nhas type\n  \u2203 d, \u2200 n \u2265 1, a n = a 1 + (\u2191n - 1) * d : Prop\nbut is expected to have type\n  \u2203 x, \u2200 n \u2265 1, a n = _a + (\u2191n - 1) * x : Prop\n\nExplanation: The rewrite tactic rewrites an expression 'e' using an equality 'a = b' by the following process. First, it looks for all 'a' in 'e'. Second, it tries to abstract these occurrences of 'a' to create a function 'm := fun _a => ...', called the *motive*, with the property that 'm a' is definitionally equal to 'e'. Third, we observe that 'congrArg' implies that 'm a = m b', which can be used with lemmas such as 'Eq.mpr' to change the goal. However, if 'e' depends on specific properties of 'a', then the motive 'm' might not typecheck.\n\nPossible solutions: use rewrite's 'occs' configuration option to limit which occurrences are rewritten, or use 'simp' or 'conv' mode, which have strategies for certain kinds of dependencies (these tactics can handle proofs and 'Decidable' instances whose types depend on the rewritten term, and 'simp' can apply user-defined '@[congr]' theorems as well).\na : \u2115 \u2192 \u211d\ntc_1 : \u2203 d, \u2200 n \u2265 1, a n = a 1 + (\u2191n - 1) * d\ntc_2 : a 1 = 5 \u2227 a 3 = 11\nl1 : a 3 = a 1 + 2 * Classical.choose tc_1\n\u22a2 a 1 + 2 * Classical.choose tc_1 = 5 + 2 * Classical.choose tc_1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The sequence definition, given values, arithmetic progression formula, and conclusion are all properly represented. The use of Classical.choose to extract the common difference from the existential statement is a valid and semantically equivalent way to represent the variable d from the natural language. The logical flow and mathematical reasoning are preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (tc_2 : a 1 = 5 \u2227 a 3 = 11)\n  (l1 : a 3 = a 1 + 2 * (Classical.choose tc_1)) :\n  \u00ac (11 = 5 + 2 * (Classical.choose tc_1)) := by\n  simp [tc_2, l1]\n  intro h\n  have d := Classical.choose tc_1\n  have hd := Classical.choose_spec tc_1\n  specialize hd 3 (by norm_num)\n  rw [tc_2.1, tc_2.2] at hd\n  have : d = 3 := by linarith [hd, l1]\n  rw [this] at h\n  norm_num at h"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "which gives us $2d = 6$", "statement": "We assume:\n\u2022 $11 = 5 + 2d$ [l2].\nTherefore, we conclude:\n\u2022 $2d = 6$ [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (l2 : 11 = 5 + 2 * (Classical.choose tc_1)) :\n  2 * (Classical.choose tc_1) = 6 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (l2 : 11 = 5 + 2 * (Classical.choose tc_1)) :\n  2 * (Classical.choose tc_1) = 6 := by\n  have h : 11 - 5 = 2 * Classical.choose tc_1 := by rw [l2]; ring\n  rw [\u2190 h]; norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical relationship from the natural language. The assumption '11 = 5 + 2d' is properly represented as hypothesis l2, and the conclusion '2d = 6' is accurately stated as the goal. The use of Classical.choose tc_1 to represent the common difference d is mathematically appropriate, and the additional arithmetic sequence context (tc_1) provides useful mathematical grounding without contradicting the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "so $d = 3$.", "statement": "We assume:\n\u2022 $2d = 6$ [l3].\nTherefore, we conclude:\n\u2022 $d = 3$ [l4].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (l3 : 2 * (Classical.choose tc_1) = 6) :\n  (Classical.choose tc_1) = 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (l3 : 2 * (Classical.choose tc_1) = 6) :\n  (Classical.choose tc_1) = 3 := by\n  rw [\u2190 mul_right_inj' (two_ne_zero' \u211d), l3]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical relationship from the natural language. While it adds context about arithmetic sequences and uses Classical.choose to extract the common difference d, these are consistent mathematical extensions that don't alter the core meaning. The premise '2d = 6' and conclusion 'd = 3' are faithfully represented with the same variable representation throughout."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Now we can find $a_5 = a_1 + 4d$", "statement": "We assume:\n\u2022 $(a_n)$ is an arithmetic sequence with the formula $a_n = a_1 + (n-1)d$ for a common difference $d$ [tc_1].\nTherefore, we conclude:\n\u2022 For $n=5$, the formula yields $a_5 = a_1 + (5-1)d = a_1 + 4d$ [l5].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d) :\n  a 5 = a 1 + 4 * (Classical.choose tc_1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d) :\n  a 5 = a 1 + 4 * (Classical.choose tc_1) := by\n  let d := Classical.choose tc_1\n  have h := Classical.choose_spec tc_1\n  specialize h 5 (by linarith)\n  rw [h]\n  norm_cast", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The arithmetic sequence definition is correctly formalized with existential quantification over the common difference and the proper formula structure.", "The conclusion for n=5 is correctly derived, with proper simplification of (5-1) to 4 and appropriate use of Classical.choose to extract the common difference from the existential statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "$a_5 = a_1 + 4d = 5 + 4(3) = 5 + 12 = 17$.", "statement": "We assume:\n\u2022 $a_1 = 5$ [tc_2].\n\u2022 The common difference is $d=3$ [l4].\n\u2022 The formula for the 5th term is $a_5 = a_1 + 4d$ [l5].\nTherefore, we conclude:\n\u2022 $a_5 = 17$ [ts_1].", "dependencies": ["tc_2", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (tc_2 : a 1 = 5 \u2227 a 3 = 11)\n  (l4 : (Classical.choose tc_1) = 3)\n  (l5 : a 5 = a 1 + 4 * (Classical.choose tc_1)) :\n  a 5 = 17 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (tc_2 : a 1 = 5 \u2227 a 3 = 11)\n  (l4 : (Classical.choose tc_1) = 3)\n  (l5 : a 5 = a 1 + 4 * (Classical.choose tc_1)) :\n  a 5 = 17 := by\n  rw [l5]\n  rw [tc_2.1, l4]\n  norm_num", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 6, "endLine": 13, "endColumn": 12, "data": "tactic 'rewrite' failed, motive is not type correct:\n  fun _a => _a + 4 * Classical.choose tc_1 = 17\nError: application type mismatch\n  Classical.choose tc_1\nargument\n  tc_1\nhas type\n  \u2203 d, \u2200 n \u2265 1, a n = a 1 + (\u2191n - 1) * d : Prop\nbut is expected to have type\n  \u2203 x, \u2200 n \u2265 1, a n = _a + (\u2191n - 1) * x : Prop\n\nExplanation: The rewrite tactic rewrites an expression 'e' using an equality 'a = b' by the following process. First, it looks for all 'a' in 'e'. Second, it tries to abstract these occurrences of 'a' to create a function 'm := fun _a => ...', called the *motive*, with the property that 'm a' is definitionally equal to 'e'. Third, we observe that 'congrArg' implies that 'm a = m b', which can be used with lemmas such as 'Eq.mpr' to change the goal. However, if 'e' depends on specific properties of 'a', then the motive 'm' might not typecheck.\n\nPossible solutions: use rewrite's 'occs' configuration option to limit which occurrences are rewritten, or use 'simp' or 'conv' mode, which have strategies for certain kinds of dependencies (these tactics can handle proofs and 'Decidable' instances whose types depend on the rewritten term, and 'simp' can apply user-defined '@[congr]' theorems as well).\na : \u2115 \u2192 \u211d\ntc_1 : \u2203 d, \u2200 n \u2265 1, a n = a 1 + (\u2191n - 1) * d\ntc_2 : a 1 = 5 \u2227 a 3 = 11\nl4 : Classical.choose tc_1 = 3\nl5 : a 5 = a 1 + 4 * Classical.choose tc_1\n\u22a2 a 1 + 4 * Classical.choose tc_1 = 17"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The arithmetic sequence definition, initial term value, common difference, fifth term formula, and conclusion are all properly represented. The additional constraint a 3 = 11 in tc_2 is mathematically consistent with the given information and represents acceptable extra detail that doesn't contradict the natural language statement.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2203 d : \u211d, \u2200 n : \u2115, n \u2265 1 \u2192 a n = a 1 + (n - 1) * d)\n  (tc_2 : a 1 = 5 \u2227 a 3 = 11)\n  (l4 : (Classical.choose tc_1) = 3)\n  (l5 : a 5 = a 1 + 4 * (Classical.choose tc_1)) :\n  \u00ac a 5 = 17 := by\n  have h : a 1 = 5 := tc_2.1\n  have d : Classical.choose tc_1 = 3 := l4\n  rw [l5, h, d]\n  norm_num"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    