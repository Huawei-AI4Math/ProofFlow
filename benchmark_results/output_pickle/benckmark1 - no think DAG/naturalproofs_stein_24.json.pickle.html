
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If~$R$ is a complete set of residues modulo~$n$ and $a\in\Z$ with
$\gcd(a,n)=1$, then $aR = \{ax : x \in R\}$
is also a complete set of residues modulo~$n$.

We can assume the following statement(s) without a proof. 

If $\gcd(c,n)=1$ and
$$
   ac\con bc\pmod{n},
$$
then $a \con b\pmod{n}$.

Proof: If $ax\con ax'\pmod{n}$ with $x, x'\in R$, then $x\con{}x'\pmod{n}$.
Because $R$ is a complete set of residues, this implies
that $x=x'$.  Thus the elements of
$aR$ have distinct reductions modulo~$n$.
It follows, since $\#aR=n$, that $aR$ is a
complete set of residues modulo~$n$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If R is a complete set of residues modulo n", "statement": "Premise:\n\u2022 R is a complete set of residues modulo n, which implies that R contains n integers and for any two distinct elements x, y \u2208 R, x is not congruent to y modulo n (x <binary data, 2 bytes> y mod n) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (R : Set \u2124)\n(tc_1 : R.card = n \u2227 (\u2200 (x y : \u2124), x \u2208 R \u2192 y \u2208 R \u2192 x \u2260 y \u2192 \u00ac (x \u2261 y [ZMOD n])))", "lean_pass": false, "error_msg": [{"line": 6, "column": 8, "endLine": 6, "endColumn": 14, "data": "invalid field 'card', the environment does not contain 'Set.card'\n  R\nhas type\n  Set \u2124"}, {"line": 6, "column": 8, "endLine": 6, "endColumn": 14, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  R\nhas type\n  \u2124 \u2192 Prop"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "a\u2208Z with gcd(a,n)=1", "statement": "Premise:\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (a : \u2124)\n(tc_2 : Nat.gcd a.natAbs n = 1)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration (a : \u2124) directly corresponds to 'a is an integer'", "The Lean formalization uses a.natAbs to convert the integer a to its absolute value as a natural number, which is the standard way to handle gcd with integers in Lean. This is mathematically equivalent to gcd(a, n) = 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "If gcd(c,n)=1 and\n$$\n   ac\\con bc\\pmod{n},\n$$\nthen a \\con b\\pmod{n}.", "statement": "Definition:\n\u2022 The cancellation law for modular congruence holds: For any integers a, b, c and a positive integer n, if gcd(c, n) = 1 and ac \u2261 bc (mod n), then a \u2261 b (mod n) [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {a b c : \u2124} {n : \u2115}\n(def_1 : \u2200 (a b c : \u2124) (n : \u2115), n > 0 \u2192 Nat.gcd (Int.natAbs c) n = 1 \u2192 (a * c \u2261 b * c [ZMOD n]) \u2192 (a \u2261 b [ZMOD n]))", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The Lean formalization correctly declares a, b, c as integers using \u2124 type", "The Lean formalization correctly captures n as a positive natural number with n > 0 condition", "The Lean uses Nat.gcd (Int.natAbs c) n = 1 instead of just gcd(c, n) = 1. The Int.natAbs takes the absolute value of c before computing gcd. This is mathematically equivalent since gcd(c, n) = gcd(|c|, n), but represents a slight structural difference in how the condition is expressed", "The Lean formalization correctly represents the modular congruence ac \u2261 bc (mod n) using the ZMOD notation", "The Lean formalization correctly represents the conclusion a \u2261 b (mod n) using the ZMOD notation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If ax\\con ax'\\pmod{n} with x, x'\\in R, then x\\con{}x'\\pmod{n}.", "statement": "We assume:\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2].\n\u2022 The cancellation law for modular congruence holds: For any integers k, l, m, if gcd(m, n) = 1 and km \u2261 lm (mod n), then k \u2261 l (mod n) [def_1].\nTherefore, we conclude:\n\u2022 For any integers x, x' \u2208 R, if ax \u2261 ax' (mod n), then x \u2261 x' (mod n) [l1].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115) (a : \u2124)\n  (tc_2 : Nat.gcd a.natAbs n = 1)\n  (def_1 : \u2200 (a b c : \u2124) (n : \u2115), n > 0 \u2192 Nat.gcd (Int.natAbs c) n = 1 \u2192 (a * c \u2261 b * c [ZMOD n]) \u2192 (a \u2261 b [ZMOD n])) :\n  \u2200 (x x' : \u2124), a * x \u2261 a * x' [ZMOD n] \u2192 x \u2261 x' [ZMOD n] := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (n : \u2115) (a : \u2124)\n  (tc_2 : Nat.gcd a.natAbs n = 1)\n  (def_1 : \u2200 (a b c : \u2124) (n : \u2115), n > 0 \u2192 Nat.gcd (Int.natAbs c) n = 1 \u2192 (a * c \u2261 b * c [ZMOD n]) \u2192 (a \u2261 b [ZMOD n])) :\n  \u2200 (x x' : \u2124), a * x \u2261 a * x' [ZMOD n] \u2192 x \u2261 x' [ZMOD n] := by\n  intro x x' h\n  cases n with\n  | zero =>\n    simp [ZMOD, Int.modEq] at h \u22a2\n    exact h\n  | succ n =>\n    apply def_1 x x' a n.succ (Nat.succ_pos n) tc_2\n    rw [mul_comm a x, mul_comm a x']\n    exact h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 9, "endLine": 13, "endColumn": 8, "data": "unsolved goals\ncase zero\na : \u2124\ndef_1 : \u2200 (a b c : \u2124), \u2200 n > 0, c.natAbs.gcd n = 1 \u2192 a * c \u2261 b * c [ZMOD \u2191n] \u2192 a \u2261 b [ZMOD \u2191n]\nx x' : \u2124\ntc_2 : a.natAbs.gcd 0 = 1\nh : a * x \u2261 a * x' [ZMOD \u21910]\n\u22a2 x = x'"}, {"line": 12, "column": 2, "endLine": 13, "endColumn": 8, "data": "alternative 'succ' has not been provided"}, {"line": 13, "column": 9, "endLine": 13, "endColumn": 14, "data": "unexpected token '[ZMOD'; expected command"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly capture that a is an integer", "The gcd condition is correctly formalized using natAbs to handle the integer-to-natural conversion, which is mathematically equivalent", "The cancellation law definition correctly captures the logical structure, with reasonable additional constraint n > 0 and appropriate handling of integer absolute values", "The conclusion matches the logical intent, though there's a minor notation issue in natural language (mentions R instead of integers) that Lean correctly interprets as integers", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.75 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1\n  (n : \u2115) (a : \u2124)\n  (tc_2 : Nat.gcd a.natAbs n = 1)\n  (def_1 : \u2200 (a b c : \u2124) (n : \u2115), n > 0 \u2192 Nat.gcd (Int.natAbs c) n = 1 \u2192 (a * c \u2261 b * c [ZMOD n]) \u2192 (a \u2261 b [ZMOD n])) :\n  \u2203 (x x' : \u2124), a * x \u2261 a * x' [ZMOD n] \u2227 \u00ac (x \u2261 x' [ZMOD n]) := by\n  by_cases hn : n = 0\n  \u00b7 use 0, 1\n    simp [hn]\n    intro h\n    simp at h\n  \u00b7 use 0, 1\n    constructor\n    \u00b7 simp [hn]\n      rw [mul_zero, mul_one]\n      exact Int.ModEq.refl _\n    \u00b7 intro h\n      have := Int.ModEq.eq (by rw [hn]; decide) h\n      simp at this"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Because R is a complete set of residues, this implies that x=x'.", "statement": "We assume:\n\u2022 R is a complete set of residues modulo n, which implies for any x, x' \u2208 R, if x \u2261 x' (mod n), then x = x' [tc_1].\n\u2022 For any integers x, x' \u2208 R, if ax \u2261 ax' (mod n), then x \u2261 x' (mod n) [l1].\nTherefore, we conclude:\n\u2022 For any integers x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (tc_1 : (\u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (x \u2261 x' [ZMOD n]) \u2192 x = x'))\n  (l1 : \u2200 (x x' : \u2124), a * x \u2261 a * x' [ZMOD n] \u2192 x \u2261 x' [ZMOD n]) :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x' := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (tc_1 : (\u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (x \u2261 x' [ZMOD n]) \u2192 x = x'))\n  (l1 : \u2200 (x x' : \u2124), a * x \u2261 a * x' [ZMOD n] \u2192 x \u2261 x' [ZMOD n]) :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x' := by\n  intro x x' hx hx' h\n  apply tc_1 x x' hx hx'\n  apply l1 x x' h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The complete set of residues property tc_1 is correctly formalized with proper membership constraints and logical implication structure.", "The cancellation property l1 is missing the membership constraints 'x \u2208 R' and 'x' \u2208 R' that are explicitly stated in the natural language. The Lean version applies to all integers rather than just elements in R.", "The conclusion l2 correctly captures the final statement with proper membership constraints and logical structure.", "The overall logical flow from assumptions tc_1 and l1 to conclusion l2 is properly structured as a lemma in Lean."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The complete set of residues property tc_1 is correctly formalized with proper membership constraints and logical implication structure.', \"The cancellation property l1 is missing the membership constraints 'x \u2208 R' and 'x' \u2208 R' that are explicitly stated in the natural language. The Lean version applies to all integers rather than just elements in R.\", 'The conclusion l2 correctly captures the final statement with proper membership constraints and logical structure.', 'The overall logical flow from assumptions tc_1 and l1 to conclusion l2 is properly structured as a lemma in Lean.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Thus the elements of aR have distinct reductions modulo n.", "statement": "We assume:\n\u2022 For any integers x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l2].\nTherefore, we conclude:\n\u2022 The elements of the set aR = {ax : x \u2208 R} have distinct reductions modulo n. (This means that for any distinct x, x' \u2208 R, it holds that ax is not congruent to ax' modulo n) [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (l2 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x') :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 x \u2260 x' \u2192 \u00ac (a * x \u2261 a * x' [ZMOD n]) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (l2 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x') :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 x \u2260 x' \u2192 \u00ac (a * x \u2261 a * x' [ZMOD n]) := by\n  intros x x' hx hx' hne h\n  apply hne\n  exact l2 x x' hx hx' h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l2 is correctly formalized. Both the natural language and Lean express the same logical statement: for elements x, x' in R, if their products with 'a' are congruent modulo n, then x equals x'. The Lean uses standard mathematical notation with \u2200, \u2208, \u2192, and \u2261 [ZMOD n] which directly corresponds to the natural language quantifiers, set membership, implication, and modular congruence.", "The conclusion l3 is correctly formalized. The natural language states that elements of aR have distinct reductions modulo n, which is clarified in parentheses as meaning distinct elements x, x' in R produce non-congruent values ax, ax' modulo n. The Lean formalization captures this exactly with the contrapositive form: if x \u2260 x', then ax is not congruent to ax' modulo n.", "The logical relationship between assumption and conclusion is properly maintained. The natural language presents this as a deductive argument (assumption \u2192 conclusion), and the Lean formalization structures this as a lemma where l2 serves as a hypothesis to prove the conclusion l3. This correctly captures the inferential relationship."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "since #aR=n", "statement": "We assume:\n\u2022 R is a complete set of residues modulo n, which implies #R = n [tc_1].\n\u2022 For any integers x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l2].\nTherefore, we conclude:\n\u2022 The cardinality of the set aR = {ax : x \u2208 R} is n (#aR = n) [l4].", "dependencies": ["tc_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (tc_1 : R.Finite \u2227 Nat.card R = n)\n  (l2 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x') :\n  (a \u2022 R).Finite \u2227 Nat.card (a \u2022 R) = n := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 29, "endLine": 9, "endColumn": 34, "data": "failed to synthesize\n  HSMul \u2124 Type ?m.4208\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 3, "endLine": 9, "endColumn": 8, "data": "failed to synthesize\n  HSMul \u2124 (Set \u2124) ?m.9714\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (tc_1 : R.Finite \u2227 Nat.card R = n)\n  (l2 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x') :\n  (a \u2022 R).Finite \u2227 Nat.card (a \u2022 R) = n := by\n  constructor\n  \u00b7 exact Set.Finite.smul a tc_1.1\n  \u00b7 have inj : Set.InjOn (fun x => a * x) R := by\n      intro x hx x' hx' h\n      exact l2 x x' hx hx' (Int.modEq_iff_dvd.1 (by rw [\u2190 Int.modEq_iff_eq_mod] at h; exact h))\n    rw [\u2190 tc_1.2]\n    exact Nat.card_congr (Equiv.Set.imageOfInjOn _ _ inj)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 29, "endLine": 9, "endColumn": 34, "data": "failed to synthesize\n  HSMul \u2124 Type ?m.4208\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 3, "endLine": 9, "endColumn": 8, "data": "failed to synthesize\n  HSMul \u2124 (Set \u2124) ?m.9714\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 26, "endLine": 11, "endColumn": 27, "data": "application type mismatch\n  Set.Finite.smul a\nargument\n  a\nhas type\n  \u2124 : Type\nbut is expected to have type\n  Set.Finite ?m.11050 : Prop"}, {"line": 14, "column": 58, "endLine": 14, "endColumn": 78, "data": "unknown constant 'Int.modEq_iff_eq_mod'"}, {"line": 14, "column": 56, "endLine": 14, "endColumn": 78, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.13123\nn : \u2115\na : \u2124\nR : Set \u2124\ntc_1 : R.Finite \u2227 Nat.card \u2191R = n\nl2 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 a * x \u2261 a * x' [ZMOD \u2191n] \u2192 x = x'\nx : \u2124\nhx : x \u2208 R\nx' : \u2124\nhx' : x' \u2208 R\nh : (fun x => a * x) x = (fun x => a * x) x'\n\u22a2 ?m.13071 \u2261 ?m.13072 [ZMOD ?m.13070]"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "It follows, since #aR=n, that aR is a complete set of residues modulo n.", "statement": "We assume:\n\u2022 The elements of the set aR have distinct reductions modulo n [l3].\n\u2022 The cardinality of the set aR is n (#aR = n) [l4].\nTherefore, we conclude:\n\u2022 The set aR = {ax : x \u2208 R} is a complete set of residues modulo n [ts_1].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (a : \u2124) (R : Set \u2124)\n  (l3 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 x \u2260 x' \u2192 \u00ac (a * x \u2261 a * x' [ZMOD n]))\n  (l4 : (Set.card ((fun x => a * x) '' R)) = n) :\n  IsCompleteResidueSet n ((fun x => a * x) '' R) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 9, "endLine": 8, "endColumn": 41, "data": "unknown constant 'Set.card'"}, {"line": 9, "column": 2, "endLine": 9, "endColumn": 48, "data": "function expected at\n  IsCompleteResidueSet\nterm has type\n  ?m.329"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.Data.ZMod.Basic\nimport Mathlib.Data.Fintype.Card\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (a : \u2124) (R : Set \u2124) [Fintype R]\n  (l3 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 x \u2260 x' \u2192 \u00ac (a * x \u2261 a * x' [ZMOD n]))\n  (l4 : Fintype.card ((fun x => a * x) '' R) = n) :\n  IsCompleteResidueSet ((fun x => a * x) '' R) n := by\n  constructor\n  \u00b7 intro x hx y hy h\n    simp only [Set.mem_image] at hx hy\n    obtain \u27e8x', hx', rfl\u27e9 := hx\n    obtain \u27e8y', hy', rfl\u27e9 := hy\n    exact l3 x' y' hx' hy' h\n  \u00b7 rw [\u2190 l4]\n    exact Set.toFinset_card_of_finite (Set.finite_image _ (Fintype.finite R))", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 2, "endLine": 8, "endColumn": 48, "data": "function expected at\n  IsCompleteResidueSet\nterm has type\n  ?m.730"}, {"line": 9, "column": 2, "endLine": 9, "endColumn": 13, "data": "tactic 'constructor' failed, target is not an inductive datatype\nx\u271d : Sort u_1\nIsCompleteResidueSet : x\u271d\nn : \u2115\na : \u2124\nR : Set \u2124\ninst\u271d : Fintype \u2191R\nl3 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 x \u2260 x' \u2192 \u00aca * x \u2261 a * x' [ZMOD \u2191n]\nl4 : Fintype.card \u2191((fun x => a * x) '' R) = n\n\u22a2 sorry"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    