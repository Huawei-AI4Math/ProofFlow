
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all real numbers $a, b, c, d > 1$, the following inequality holds:
$$ 
\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\leq \\sqrt{(a b+1)(c d+1)}.
$$

Proof: We prove that $\sqrt{a-1}+\sqrt{b-1}+\sqrt{c-1}+\sqrt{d-1}\le\sqrt{(ab+1)(cd+1)}$ for $a,b,c,d>1$. For $x,y>1$ we have $(\sqrt{x-1}+\sqrt{y-1})^2=x+y-2+2\sqrt{(x-1)(y-1)}\le xy$ because $(x-1)(y-1)\ge0$; hence $\sqrt{x-1}+\sqrt{y-1}\le\sqrt{xy}$. Applying this to $(a,b)$ and $(c,d)$ gives $\sqrt{a-1}+\sqrt{b-1}+\sqrt{c-1}+\sqrt{d-1}\le\sqrt{ab}+\sqrt{cd}$. Next, for any $X,Y\ge0$ we have $(X+Y)^2\le (X^2+1)(Y^2+1)$ since the latter minus the former equals $(XY-1)^2\ge0$; thus $X+Y\le\sqrt{(X^2+1)(Y^2+1)}$. Taking $X=\sqrt{ab}$ and $Y=\sqrt{cd}$ yields $\sqrt{ab}+\sqrt{cd}\le\sqrt{(ab+1)(cd+1)}$, and combining the two inequalities gives the desired result.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "for all real numbers $a, b, c, d > 1$", "statement": "Premise:\n\u2022 $a, b, c, d$ are real numbers such that $a > 1$, $b > 1$, $c > 1$, and $d > 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c d : \u211d)\n(tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean variable declaration correctly specifies that a, b, c, d are real numbers (\u211d)", "The condition a > 1 is correctly captured in the conjunction tc_1", "The condition b > 1 is correctly captured in the conjunction tc_1", "The condition c > 1 is correctly captured in the conjunction tc_1", "The condition d > 1 is correctly captured in the conjunction tc_1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $x,y>1$ we have $(\\sqrt{x-1}+\\sqrt{y-1})^2=x+y-2+2\\sqrt{(x-1)(y-1)}\\le xy$ because $(x-1)(y-1)\\ge0$", "statement": "We assume:\n\u2022 $x, y$ are real numbers such that $x > 1$ and $y > 1$.\nTherefore, we conclude:\n\u2022 $(\\sqrt{x-1}+\\sqrt{y-1})^2 \\le xy$ [l1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (x y : \u211d) (hx : x > 1) (hy : y > 1) :\n  (sqrt (x - 1) + sqrt (y - 1))^2 \u2264 x * y := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (x y : \u211d) (hx : x > 1) (hy : y > 1) :\n  (sqrt (x - 1) + sqrt (y - 1))^2 \u2264 x * y := by\n  have hx' : 0 \u2264 x - 1 := by linarith [hx]\n  have hy' : 0 \u2264 y - 1 := by linarith [hy]\n  rw [sq_add]\n  simp only [mul_self_sqrt hx', mul_self_sqrt hy']\n  rw [add_assoc]\n  have : 2 * sqrt (x - 1) * sqrt (y - 1) \u2264 (x - 1) + (y - 1) := by\n    rw [\u2190 two_mul]\n    apply mul_le_add_of_nonneg_left\n    \u00b7 exact sqrt_mul_sqrt_le hx' hy'\n    \u00b7 exact zero_le_two\n  linarith [this]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 6, "endLine": 10, "endColumn": 12, "data": "unknown identifier 'sq_add'"}, {"line": 10, "column": 6, "endLine": 10, "endColumn": 12, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.6709\nx y : \u211d\nhx : x > 1\nhy : y > 1\nhx' : 0 \u2264 x - 1\nhy' : 0 \u2264 y - 1\n\u22a2 (\u221a(x - 1) + \u221a(y - 1)) ^ 2 \u2264 x * y"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations are correctly translated from natural language to Lean type annotations", "The assumptions x > 1 and y > 1 are perfectly captured, with Lean adding standard hypothesis names hx and hy", "The mathematical inequality is identically represented, with only notational differences (sqrt vs \u221a, * vs implicit multiplication, \u2264 vs \\le)", "The overall logical structure of assumptions leading to conclusion is properly formalized as a Lean lemma", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l1 :\n    \u2203 (x y : \u211d), x > 1 \u2227 y > 1 \u2227 \u00ac((sqrt (x - 1) + sqrt (y - 1))^2 \u2264 x * y) := by\n  use 4, 4\n  constructor\n  \u00b7 linarith\n  constructor\n  \u00b7 linarith\n  \u00b7 simp\n    norm_num\n    linarith"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "hence $\\sqrt{x-1}+\\sqrt{y-1}\\le\\sqrt{xy}$", "statement": "We assume:\n\u2022 $x, y$ are real numbers such that $x > 1$ and $y > 1$.\n\u2022 $(\\sqrt{x-1}+\\sqrt{y-1})^2 \\le xy$ [l1].\nTherefore, we conclude:\n\u2022 $\\sqrt{x-1}+\\sqrt{y-1} \\le \\sqrt{xy}$ [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (x y : \u211d) (hx : x > 1) (hy : y > 1)\n  (l1 : (sqrt (x - 1) + sqrt (y - 1))^2 \u2264 x * y) :\n  sqrt (x - 1) + sqrt (y - 1) \u2264 sqrt (x * y) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (x y : \u211d) (hx : x > 1) (hy : y > 1)\n  (l1 : (sqrt (x - 1) + sqrt (y - 1))^2 \u2264 x * y) :\n  sqrt (x - 1) + sqrt (y - 1) \u2264 sqrt (x * y) := by\n  have h\u2081 : 0 \u2264 sqrt (x * y) := sqrt_nonneg _\n  have h\u2082 : 0 \u2264 sqrt (x - 1) + sqrt (y - 1) := add_nonneg (sqrt_nonneg _) (sqrt_nonneg _)\n  rw [\u2190 sqrt_mul h\u2081, mul_self_sqrt h\u2081]\n  exact l1", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 6, "endLine": 11, "endColumn": 19, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u221a\u221a(x * y) * \u221a?y\nx y : \u211d\nhx : x > 1\nhy : y > 1\nl1 : (\u221a(x - 1) + \u221a(y - 1)) ^ 2 \u2264 x * y\nh\u2081 : 0 \u2264 \u221a(x * y)\nh\u2082 : 0 \u2264 \u221a(x - 1) + \u221a(y - 1)\n\u22a2 \u221a(x - 1) + \u221a(y - 1) \u2264 \u221a(x * y)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations and constraints are correctly formalized with appropriate types and hypothesis names", "The premise [l1] is exactly captured with identical mathematical structure and notation", "The conclusion [l2] perfectly matches the natural language mathematical expression", "The logical flow from assumptions to conclusion is properly represented in the lemma structure", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  (x y : \u211d) (hx : x > 1) (hy : y > 1)\n  (l1 : (sqrt (x - 1) + sqrt (y - 1))^2 \u2264 x * y) :\n  \u00ac (sqrt (x - 1) + sqrt (y - 1) \u2264 sqrt (x * y)) := by\n  intro h\n  have h1 : (sqrt (x - 1) + sqrt (y - 1))^2 \u2264 (sqrt (x * y))^2 := by\n    exact pow_le_pow_left (by positivity) h 2\n  have h2 : (sqrt (x * y))^2 = x * y := by\n    exact sq_sqrt (by positivity)\n  rw [h2] at h1\n  have h3 : x * y < (sqrt (x - 1) + sqrt (y - 1))^2 := by\n    apply lt_of_le_of_ne l1\n    intro heq\n    rw [\u2190h2, heq] at h1\n    exact lt_irrefl _ h1\n  exact not_le_of_gt h3 h1"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Applying this to $(a,b)$ and $(c,d)$ gives $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1}\\le\\sqrt{ab}+\\sqrt{cd}$.", "statement": "We assume:\n\u2022 $a, b, c, d$ are real numbers such that $a > 1, b > 1, c > 1, d > 1$ [tc_1].\n\u2022 For any real numbers $x, y > 1$, $\\sqrt{x-1}+\\sqrt{y-1} \\le \\sqrt{xy}$ [l2].\nTherefore, we conclude:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{ab}+\\sqrt{cd}$ [l3].", "dependencies": ["tc_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l2 : \u2200 (x y : \u211d), x > 1 \u2192 y > 1 \u2192 sqrt (x - 1) + sqrt (y - 1) \u2264 sqrt (x * y)) :\n  sqrt (a - 1) + sqrt (b - 1) + sqrt (c - 1) + sqrt (d - 1) \u2264 sqrt (a * b) + sqrt (c * d) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l2 : \u2200 (x y : \u211d), x > 1 \u2192 y > 1 \u2192 sqrt (x - 1) + sqrt (y - 1) \u2264 sqrt (x * y)) :\n  sqrt (a - 1) + sqrt (b - 1) + sqrt (c - 1) + sqrt (d - 1) \u2264 sqrt (a * b) + sqrt (c * d) := by\n  have ha : a > 1 := tc_1.1\n  have hb : b > 1 := tc_1.2.1\n  have hc : c > 1 := tc_1.2.2.1\n  have hd : d > 1 := tc_1.2.2.2\n  have hab := l2 a b ha hb\n  have hcd := l2 c d hc hd\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are semantically identical - both declare four real number variables a, b, c, d.", "The constraints are perfectly captured - the natural language conditions a>1, b>1, c>1, d>1 are exactly represented by the conjunction in Lean.", "The general lemma l2 is perfectly formalized - the universal quantification and mathematical inequality are semantically identical between natural language and Lean.", "The conclusion statement l3 is perfectly matched - the mathematical expression and inequality are identical in both representations.", "The overall logical structure correctly captures the premise-conclusion relationship, with all assumptions properly formalized as hypotheses leading to the goal statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "for any $X,Y\\ge0$ we have $(X+Y)^2\\le (X^2+1)(Y^2+1)$ since the latter minus the former equals $(XY-1)^2\\ge0$", "statement": "We assume:\n\u2022 $X, Y$ are non-negative real numbers.\nTherefore, we conclude:\n\u2022 $(X+Y)^2 \\le (X^2+1)(Y^2+1)$ [l4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y) :\n  (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y) :\n  (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1) := by\n  have h1 : (X + Y)^2 = X^2 + Y^2 + 2 * X * Y := by ring\n  have h2 : (X^2 + 1) * (Y^2 + 1) = X^2 * Y^2 + X^2 + Y^2 + 1 := by ring\n  rw [h1, h2]\n  have h3 : 0 \u2264 (X * Y - 1)^2 := sq_nonneg (X * Y - 1)\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and non-negativity constraints are correctly formalized with appropriate hypothesis names", "The inequality expression is mathematically identical between natural language and Lean formalization", "The logical structure of assumptions leading to conclusion is properly captured in the lemma format"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "thus $X+Y\\le\\sqrt{(X^2+1)(Y^2+1)}$", "statement": "We assume:\n\u2022 $X, Y$ are non-negative real numbers.\n\u2022 $(X+Y)^2 \\le (X^2+1)(Y^2+1)$ [l4].\nTherefore, we conclude:\n\u2022 $X+Y \\le \\sqrt{(X^2+1)(Y^2+1)}$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y)\n  (l4 : (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1)) :\n  X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y)\n  (l4 : (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1)) :\n  X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1)) := by\n  rw [\u2190 Real.sqrt_sq (add_nonneg hX hY)]\n  exact Real.sqrt_le_sqrt l4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and non-negativity assumptions are correctly formalized with appropriate Lean syntax", "The inequality assumption l4 is perfectly captured with standard Lean mathematical notation", "The conclusion l5 correctly uses Real.sqrt and maintains the exact mathematical relationship", "The logical structure properly represents the deductive step from assumption to conclusion as a Lean lemma"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Taking $X=\\sqrt{ab}$ and $Y=\\sqrt{cd}$ yields $\\sqrt{ab}+\\sqrt{cd}\\le\\sqrt{(ab+1)(cd+1)}$", "statement": "We assume:\n\u2022 $a, b, c, d$ are real numbers such that $a > 1, b > 1, c > 1, d > 1$ [tc_1].\n\u2022 For any non-negative real numbers $X, Y$, $X+Y \\le \\sqrt{(X^2+1)(Y^2+1)}$ [l5].\nTherefore, we conclude:\n\u2022 $\\sqrt{ab}+\\sqrt{cd} \\le \\sqrt{(ab+1)(cd+1)}$ [l6].", "dependencies": ["tc_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l5 : \u2200 (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y), X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1))) :\n  Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l5 : \u2200 (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y), X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1))) :\n  Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by\n  have h1 : 0 \u2264 Real.sqrt (a * b) := Real.sqrt_nonneg _\n  have h2 : 0 \u2264 Real.sqrt (c * d) := Real.sqrt_nonneg _\n  have h3 : (Real.sqrt (a * b))^2 = a * b := Real.sq_sqrt (by linarith [tc_1.1, tc_1.2.1])\n  have h4 : (Real.sqrt (c * d))^2 = c * d := Real.sq_sqrt (by linarith [tc_1.2.2.1, tc_1.2.2.2])\n  specialize l5 (Real.sqrt (a * b)) (Real.sqrt (c * d)) h1 h2\n  rw [h3, h4] at l5\n  exact l5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 62, "endLine": 12, "endColumn": 89, "data": "linarith failed to find a contradiction\ncase a\na b c d : \u211d\ntc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1\nl5 : \u2200 (X Y : \u211d), 0 \u2264 X \u2192 0 \u2264 Y \u2192 X + Y \u2264 \u221a((X ^ 2 + 1) * (Y ^ 2 + 1))\nh1 : 0 \u2264 \u221a(a * b)\nh2 : 0 \u2264 \u221a(c * d)\na\u271d : 0 > a * b\n\u22a2 False failed"}, {"line": 13, "column": 62, "endLine": 13, "endColumn": 95, "data": "linarith failed to find a contradiction\ncase a\na b c d : \u211d\ntc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1\nl5 : \u2200 (X Y : \u211d), 0 \u2264 X \u2192 0 \u2264 Y \u2192 X + Y \u2264 \u221a((X ^ 2 + 1) * (Y ^ 2 + 1))\nh1 : 0 \u2264 \u221a(a * b)\nh2 : 0 \u2264 \u221a(c * d)\nh3 : \u221a(a * b) ^ 2 = a * b\na\u271d : 0 > c * d\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations match perfectly - both declare four real number variables a, b, c, d", "Constraint conditions are semantically equivalent - natural language lists four inequalities while Lean combines them with conjunction, but the meaning is identical", "General lemma l5 is perfectly captured - universal quantification, non-negativity constraints, and the inequality relationship all match exactly", "Conclusion statement l6 matches completely - all mathematical expressions and the inequality relationship are correctly formalized", "Logical structure is properly maintained - the assumption-conclusion relationship from natural language is correctly represented in the Lean lemma format", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l6\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l5 : \u2200 (X Y : \u211d) (hX : 0 \u2264 X) (hY : 0 \u2264 Y), X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1))) :\n  \u00ac (Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1))) := by\n  intro h\n  have h1 : Real.sqrt (a * b) ^ 2 = a * b := Real.sq_sqrt (le_of_lt (mul_pos (by linarith [tc_1.1]) (by linarith [tc_1.2.1])))\n  have h2 : Real.sqrt (c * d) ^ 2 = c * d := Real.sq_sqrt (le_of_lt (mul_pos (by linarith [tc_1.2.2.1]) (by linarith [tc_1.2.2.2])))\n  rw [h1, h2] at h\n  exact (l5 (Real.sqrt (a * b)) (Real.sqrt (c * d)) (Real.sqrt_nonneg _) (Real.sqrt_nonneg _)).not_lt h"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "and combining the two inequalities gives the desired result.", "statement": "We assume:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{ab}+\\sqrt{cd}$ [l3].\n\u2022 $\\sqrt{ab}+\\sqrt{cd} \\le \\sqrt{(ab+1)(cd+1)}$ [l6].\nTherefore, we conclude:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{(ab+1)(cd+1)}$ [ts_1].", "dependencies": ["l3", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l3 : sqrt (a - 1) + sqrt (b - 1) + sqrt (c - 1) + sqrt (d - 1) \u2264 sqrt (a * b) + sqrt (c * d))\n  (l6 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1))) :\n  sqrt (a - 1) + sqrt (b - 1) + sqrt (c - 1) + sqrt (d - 1) \u2264 sqrt ((a * b + 1) * (c * d + 1)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a b c d : \u211d)\n  (tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (l3 : sqrt (a - 1) + sqrt (b - 1) + sqrt (c - 1) + sqrt (d - 1) \u2264 sqrt (a * b) + sqrt (c * d))\n  (l6 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1))) :\n  sqrt (a - 1) + sqrt (b - 1) + sqrt (c - 1) + sqrt (d - 1) \u2264 sqrt ((a * b + 1) * (c * d + 1)) := by\n  exact le_trans l3 l6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical expressions, logical relationships, and the transitivity argument from the natural language. The constraint tc_1 appropriately ensures all square roots are well-defined. Minor notational differences (sqrt vs Real.sqrt, explicit multiplication symbols) do not affect the semantic meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    