
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $T(z) = \frac{az+b}{cz+d}$ be a MÃ¶bius transformation with $ad-bc 
eq 0$. If $T(\infty) = -1$, $T(0) = 1$, and $T(1) = i$, then $T(z) = \frac{-z+i}{z+i}$.

Proof: From the condition $T(\infty) = -1$, we deduce $a/c = -1$. We can normalize this by setting $c=1$ and $a=-1$. From the condition $T(0)=1$, we get $b/d = 1$, which implies $b=d$. Using the condition $T(1)=i$ with the substitutions $a=-1$ and $c=1$, we have $\frac{-1+b}{1+d} = i$. Since $b=d$, this becomes $\frac{-1+b}{1+b} = i$, which solves to $b=i$. Substituting the derived values $a=-1, c=1, b=i, d=i$ into the general form yields $T(z) = \frac{-z+i}{z+i}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ð</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $T(z) = \\frac{az+b}{cz+d}$ be a M\u00f6bius transformation with $ad-bc \\neq 0$.", "statement": "Premise:\n\u2022 T(z) is a M\u00f6bius transformation of the form T(z) = (az+b)/(cz+d), where a, b, c, d are complex numbers and ad-bc \u2260 0 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (T : \u2102 \u2192 \u2102)\n  (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures that T(z) is a M\u00f6bius transformation with the form (az+b)/(cz+d) through the universal quantification \u2200 z, T z = (a * z + b) / (c * z + d)", "The Lean formalization correctly declares a, b, c, d as complex numbers using the type \u2102", "The Lean formalization has a * d - b * c \u2260 0 while the natural language states ad - bc \u2260 0. The order of multiplication is different (a * d - b * c vs ad - bc), but since multiplication of complex numbers is commutative, this is mathematically equivalent. This is a minor notational difference rather than a logical inconsistency."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $T(\\infty) = -1$", "statement": "Premise:\n\u2022 T(\u221e) = -1 [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (T : \u211d \u2192 \u211d)\n  (a b c d : \u211d)\n  (T_form : \u2200 z, T z = (a * z + b) / (c * z + d))\n  (tc_2 : Tendsto T atTop (\ud835\udcdd (-1)))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures T(\u221e) = -1 using the mathematically rigorous limit notation `Tendsto T atTop (\ud835\udcdd (-1))`. The additional components in Lean (function type declaration, parameters, and specific rational form) are extra consistent details not mentioned in the natural language, which is acceptable for a 'Perfectly match' rating."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "$T(0) = 1$", "statement": "Premise:\n\u2022 T(0) = 1 [tc_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (T : \u211d \u2192 \u211d)\n  (tc_3 : T 0 = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the condition T(0) = 1 with the label tc_3. The function T is appropriately typed as \u211d \u2192 \u211d, and no conclusions are derived, matching the natural language statement exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "$T(1) = i$", "statement": "Premise:\n\u2022 T(1) = i [tc_4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (T : \u2102 \u2192 \u2102)\n  (a b c d : \u2102)\n  (hT : \u2200 z, T z = (a * z + b) / (c * z + d))\n  (h_ad_bc : a * d - b * c \u2260 0)\n  (h_T_infty : c \u2260 0 \u2227 (a / c) = -1)\n  (h_T_zero : d \u2260 0 \u2227 (b / d) = 1)\n  (tc_4 : T 1 = Complex.I)", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The condition T(1) = i from the natural language perfectly matches tc_4 : T 1 = Complex.I in the Lean code. The Lean formalization contains additional context and conditions not mentioned in the natural language, but this is acceptable as the natural language appears to be stating just one premise from a larger proof context."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "From the condition $T(\\infty) = -1$, we deduce $a/c = -1$.", "statement": "We assume:\n\u2022 T(z) is a M\u00f6bius transformation of the form T(z) = (az+b)/(cz+d) [tc_1]\n\u2022 T(\u221e) = -1 [tc_2]\nTherefore, we conclude:\n\u2022 a/c = -1 [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_2 : Tendsto T atTop (\ud835\udcdd (-1))) :\n  a / c = -1 := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 20, "endLine": 8, "endColumn": 25, "data": "failed to synthesize\n  Preorder \u2102\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_2 : Tendsto T (comap Complex.abs.atTop) (\ud835\udcdd (-1))) :\n  a / c = -1 := by\n  rcases tc_1 with \u27e8hT, hdet\u27e9\n  by_cases hc : c = 0\n  \u00b7 have h1 : a \u2260 0 := by\n      intro ha\n      apply hdet\n      simp [ha, hc]\n    have h2 : d \u2260 0 := by\n      intro hd\n      apply hdet\n      simp [hd, hc]\n    have : Tendsto (fun z => (a * z + b) / (c * z + d)) (comap Complex.abs.atTop) (\ud835\udcdd (-1)) := by\n      simp [hT, tc_2]\n    simp [hc] at this\n    have : Tendsto (fun z => a + b / z) (comap Complex.abs.atTop) (\ud835\udcdd (-1)) := by\n      convert this using 1\n      ext z\n      field_simp\n    have := Tendsto.add_const b (Tendsto.inv_atTop_zero.comp (tendsto_abs_atTop_atTop))\n    simp at this\n    have : a = -1 := by\n      rw [\u2190 tendsto_nhds_unique this]\n      exact tendsto_const_nhds\n    simp [this]\n  \u00b7 have : Tendsto (fun z => (a + b / z) / (c + d / z)) (comap Complex.abs.atTop) (\ud835\udcdd (-1)) := by\n      convert tc_2 using 1\n      ext z\n      field_simp [hT, hc]\n    have h1 : Tendsto (fun z => a + b / z) (comap Complex.abs.atTop) (\ud835\udcdd a) := by\n      exact Tendsto.add_const a (Tendsto.inv_atTop_zero.comp (tendsto_abs_atTop_atTop))\n    have h2 : Tendsto (fun z => c + d / z) (comap Complex.abs.atTop) (\ud835\udcdd c) := by\n      exact Tendsto.add_const c (Tendsto.inv_atTop_zero.comp (tendsto_abs_atTop_atTop))\n    have := Tendsto.div h1 h2 (by simp [hc])\n    rw [tendsto_nhds_unique this]\n    simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 27, "endLine": 8, "endColumn": 44, "data": "invalid field 'atTop', the environment does not contain 'AbsoluteValue.atTop'\n  Complex.abs\nhas type\n  AbsoluteValue \u2102 \u211d"}, {"line": 20, "column": 63, "endLine": 20, "endColumn": 80, "data": "invalid field 'atTop', the environment does not contain 'AbsoluteValue.atTop'\n  Complex.abs\nhas type\n  AbsoluteValue \u2102 \u211d"}, {"line": 21, "column": 6, "endLine": 21, "endColumn": 21, "data": "simp made no progress"}, {"line": 23, "column": 47, "endLine": 23, "endColumn": 64, "data": "invalid field 'atTop', the environment does not contain 'AbsoluteValue.atTop'\n  Complex.abs\nhas type\n  AbsoluteValue \u2102 \u211d"}, {"line": 23, "column": 78, "endLine": 26, "endColumn": 16, "data": "unsolved goals\ncase h.e'_3.h\nT : \u2102 \u2192 \u2102\na b c d : \u2102\ntc_2 : Tendsto T sorry (\ud835\udcdd (-1))\nhT : \u2200 (z : \u2102), T z = (a * z + b) / (c * z + d)\nhdet : a * d - b * c \u2260 0\nhc : c = 0\nh1 : a \u2260 0\nh2 : d \u2260 0\nthis : Tendsto (fun z => (a * z + b) / d) sorry (\ud835\udcdd (-1))\nz : \u2102\n\u22a2 (a + b / z) * d = a * z + b"}, {"line": 27, "column": 33, "endLine": 27, "endColumn": 86, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Tendsto\nhas type\n  (?m.10853 \u2192 ?m.10854) \u2192 Filter ?m.10853 \u2192 Filter ?m.10854 \u2192 Prop"}, {"line": 33, "column": 63, "endLine": 33, "endColumn": 80, "data": "invalid field 'atTop', the environment does not contain 'AbsoluteValue.atTop'\n  Complex.abs\nhas type\n  AbsoluteValue \u2102 \u211d"}, {"line": 33, "column": 94, "endLine": 36, "endColumn": 25, "data": "unsolved goals\ncase h.e'_3.h\nT : \u2102 \u2192 \u2102\na b c d : \u2102\ntc_2 : Tendsto T sorry (\ud835\udcdd (-1))\nhT : \u2200 (z : \u2102), T z = (a * z + b) / (c * z + d)\nhdet : a * d - b * c \u2260 0\nhc : \u00acc = 0\nz : \u2102\n\u22a2 (a + b / z) / (c + d / z) = (a * z + b) / (c * z + d)"}, {"line": 37, "column": 50, "endLine": 37, "endColumn": 67, "data": "invalid field 'atTop', the environment does not contain 'AbsoluteValue.atTop'\n  Complex.abs\nhas type\n  AbsoluteValue \u2102 \u211d"}, {"line": 38, "column": 33, "endLine": 38, "endColumn": 86, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Tendsto\nhas type\n  (?m.32235 \u2192 ?m.32236) \u2192 Filter ?m.32235 \u2192 Filter ?m.32236 \u2192 Prop"}, {"line": 39, "column": 50, "endLine": 39, "endColumn": 67, "data": "invalid field 'atTop', the environment does not contain 'AbsoluteValue.atTop'\n  Complex.abs\nhas type\n  AbsoluteValue \u2102 \u211d"}, {"line": 40, "column": 33, "endLine": 40, "endColumn": 86, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Tendsto\nhas type\n  (?m.35571 \u2192 ?m.35572) \u2192 Filter ?m.35571 \u2192 Filter ?m.35572 \u2192 Prop"}, {"line": 42, "column": 8, "endLine": 42, "endColumn": 32, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.37688\ncase neg\nT : \u2102 \u2192 \u2102\na b c d : \u2102\ntc_2 : Tendsto T sorry (\ud835\udcdd (-1))\nhT : \u2200 (z : \u2102), T z = (a * z + b) / (c * z + d)\nhdet : a * d - b * c \u2260 0\nhc : \u00acc = 0\nthis\u271d : Tendsto (fun z => (a + b / z) / (c + d / z)) sorry (\ud835\udcdd (-1))\nh1 : Tendsto (fun z => a + b / z) sorry (\ud835\udcdd a)\nh2 : Tendsto (fun z => c + d / z) sorry (\ud835\udcdd c)\nthis : Tendsto ((fun z => a + b / z) / fun z => c + d / z) sorry (\ud835\udcdd (a / c))\n\u22a2 a / c = -1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "We can normalize this by setting $c=1$ and $a=-1$.", "statement": "Definition:\n\u2022 Based on the fact that a/c = -1 [l1], we can normalize the coefficients of the M\u00f6bius transformation (which are defined up to a non-zero scalar) by choosing c = 1, which implies a = -1 [def_1].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (a b c d : \u2102)\n  (T : \u2102 \u2192 \u2102)\n  (l1 : a / c = -1)\n  (def_1 : c = 1 \u2227 a = -1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition a/c = -1 is perfectly captured in Lean as (l1 : a / c = -1)", "The Lean formalization doesn't explicitly state that M\u00f6bius transformation coefficients are defined up to a non-zero scalar, but this is contextual information that doesn't affect the logical structure", "In Lean, the choice c = 1 appears as part of def_1 which is stated as a given fact rather than a choice we make. The logical structure treats this as an assumption rather than a normalization decision", "The conclusion a = -1 is present in Lean but bundled together with c = 1 in def_1 as a conjunction rather than being derived as a separate conclusion from the conditions"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition a/c = -1 is perfectly captured in Lean as (l1 : a / c = -1)', \"The Lean formalization doesn't explicitly state that M\u00f6bius transformation coefficients are defined up to a non-zero scalar, but this is contextual information that doesn't affect the logical structure\", 'In Lean, the choice c = 1 appears as part of def_1 which is stated as a given fact rather than a choice we make. The logical structure treats this as an assumption rather than a normalization decision', 'The conclusion a = -1 is present in Lean but bundled together with c = 1 in def_1 as a conjunction rather than being derived as a separate conclusion from the conditions']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "From the condition $T(0)=1$, we get $b/d = 1$, which implies $b=d$.", "statement": "We assume:\n\u2022 T(z) is a M\u00f6bius transformation of the form T(z) = (az+b)/(cz+d) [tc_1]\n\u2022 T(0) = 1 [tc_3]\nTherefore, we conclude:\n\u2022 b = d [l2].", "dependencies": ["tc_1", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (T : \u2102 \u2192 \u2102)\n  (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_3 : T 0 = 1) :\n  b = d := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (T : \u2102 \u2192 \u2102)\n  (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_3 : T 0 = 1) :\n  b = d := by\n  have h := tc_1.1 0\n  simp at h\n  rw [tc_3] at h\n  simp at h\n  field_simp at h\n  linear_combination h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 2, "endLine": 14, "endColumn": 11, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all components from the natural language. The functional form T(z) = (az+b)/(cz+d) is properly represented, the condition T(0) = 1 is exactly translated, and the conclusion b = d is preserved. The additional non-degeneracy condition (a * d - b * c \u2260 0) in the Lean code is mathematically appropriate for defining a proper M\u00f6bius transformation and doesn't contradict the natural language - it's an implicit requirement that makes the formalization more mathematically complete.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  (T : \u2102 \u2192 \u2102)\n  (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_3 : T 0 = 1) :\n  \u00ac (b = d) := by\n  intro h\n  have h0 : T 0 = (a * 0 + b) / (c * 0 + d) := by rw [tc_1.1]\n  simp only [mul_zero, zero_add] at h0\n  rw [tc_3] at h0\n  rw [h] at h0\n  simp only [div_self] at h0\n  have h1 : a * d - b * c = a * d - a * c := by rw [h]\n  simp only [sub_left_inj, mul_eq_mul_left_iff] at h1\n  rcases h1 with (h1 | h1)\n  \u00b7 rw [h1] at tc_1\n    contradiction\n  \u00b7 rw [h1] at h0\n    simp only [one_ne_zero] at h0"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Using the condition $T(1)=i$ with the substitutions $a=-1$ and $c=1$, we have $\\frac{-1+b}{1+d} = i$.", "statement": "We assume:\n\u2022 T(z) is a M\u00f6bius transformation of the form T(z) = (az+b)/(cz+d) [tc_1]\n\u2022 T(1) = i [tc_4]\n\u2022 The coefficients are normalized to a = -1 and c = 1 [def_1]\nTherefore, we conclude:\n\u2022 (-1+b)/(1+d) = i [l3].", "dependencies": ["tc_1", "tc_4", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_4 : T 1 = Complex.I)\n  (def_1 : c = 1 \u2227 a = -1) :\n  (-1 + b) / (1 + d) = Complex.I := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (tc_4 : T 1 = Complex.I)\n  (def_1 : c = 1 \u2227 a = -1) :\n  (-1 + b) / (1 + d) = Complex.I := by\n  have h1 := tc_4\n  rw [tc_1.1, def_1.1, def_1.2] at h1\n  simp at h1\n  exact h1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the M\u00f6bius transformation definition. The natural language mentions the form T(z) = (az+b)/(cz+d), and Lean formalizes this as '\u2200 z, T z = (a * z + b) / (c * z + d)'. The additional condition 'a * d - b * c \u2260 0' in Lean is the standard non-degeneracy condition for M\u00f6bius transformations, which is mathematically necessary and consistent.", "The condition T(1) = i is perfectly translated to 'T 1 = Complex.I', where Complex.I is the standard Lean representation of the imaginary unit.", "The normalization conditions 'a = -1 and c = 1' are correctly formalized as 'c = 1 \u2227 a = -1'. The order difference is semantically irrelevant.", "The conclusion '(-1+b)/(1+d) = i' is accurately represented as '(-1 + b) / (1 + d) = Complex.I', maintaining the exact mathematical relationship."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since $b=d$, this becomes $\\frac{-1+b}{1+b} = i$.", "statement": "We assume:\n\u2022 (-1+b)/(1+d) = i [l3]\n\u2022 b = d [l2]\nTherefore, we conclude:\n\u2022 (-1+b)/(1+b) = i [l4].", "dependencies": ["l3", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (l3 : (-1 + b) / (1 + d) = Complex.I)\n  (l2 : b = d) :\n  (-1 + b) / (1 + b) = Complex.I := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (l3 : (-1 + b) / (1 + d) = Complex.I)\n  (l2 : b = d) :\n  (-1 + b) / (1 + b) = Complex.I := by\n  rw [l2]\n  exact l3", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 2, "endLine": 11, "endColumn": 10, "data": "type mismatch\n  l3\nhas type\n  (-1 + b) / (1 + d) = Complex.I : Prop\nbut is expected to have type\n  (-1 + d) / (1 + d) = Complex.I : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical argument. The premises l2 (b = d) and l3 ((-1+b)/(1+d) = i) logically lead to conclusion l4 ((-1+b)/(1+b) = i) through substitution. The complex number i is properly represented as Complex.I, and all mathematical expressions are accurately translated. The extra variables T and a don't impact the logical correctness of the formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l4\n  (T : \u2102 \u2192 \u2102) (a b c d : \u2102)\n  (l3 : (-1 + b) / (1 + d) = Complex.I)\n  (l2 : b = d) :\n  \u00ac (-1 + b) / (1 + b) = Complex.I := by\n  intro h\n  rw [l2] at l3\n  rw [l2] at h\n  rw [l3] at h\n  rw [\u2190sub_eq_zero] at h\n  have : Complex.I * (1 + b) = Complex.I * (1 + b) := rfl\n  rw [\u2190h] at this\n  simp at this\n  exact Complex.I_ne_zero this"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "which solves to $b=i$.", "statement": "We assume:\n\u2022 (-1+b)/(1+b) = i [l4]\nTherefore, we conclude:\n\u2022 b = i [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (b : \u2102)\n  (l4 : (-1 + b) / (1 + b) = Complex.I) :\n  b = Complex.I := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (b : \u2102)\n  (l4 : (-1 + b) / (1 + b) = Complex.I) :\n  b = Complex.I := by\n  have h : -1 + b = Complex.I * (1 + b) := by\n    rw [\u2190 l4]\n    field_simp\n    ring\n  rw [eq_sub_iff_add_eq, \u2190 add_assoc, \u2190 h]\n  simp only [mul_add, mul_one, Complex.I_mul_I, neg_one_mul, neg_neg, one_mul]\n  rw [add_comm, add_left_inj, \u2190 add_assoc, Complex.I_mul_I, neg_add_self, zero_add]\n  exact (mul_left_inj' (by simp)).mp (by rw [mul_comm, \u2190 h]; simp)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 43, "endLine": 12, "endColumn": 8, "data": "unsolved goals\nb : \u2102\nl4 : (-1 + b) / (1 + b) = Complex.I\n\u22a2 -1 + b = b ^ 2 * (1 + b)\u207b\u00b9 - (1 + b)\u207b\u00b9"}, {"line": 13, "column": 6, "endLine": 13, "endColumn": 23, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.13087 = ?m.13088 - ?m.13089\nb : \u2102\nl4 : (-1 + b) / (1 + b) = Complex.I\nh : -1 + b = Complex.I * (1 + b)\n\u22a2 b = Complex.I"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all aspects of the natural language statement. The variable b is properly typed as complex, the assumption (-1+b)/(1+b) = i is accurately represented with correct complex number notation, and the conclusion b = i is precisely formalized. The logical structure of deriving the conclusion from the premise is properly maintained through the lemma format.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (b : \u2102)\n  (l4 : (-1 + b) / (1 + b) = Complex.I) :\n  \u00ac (b = Complex.I) := by\n  intro h\n  rw [h] at l4\n  have : (-1 + Complex.I) / (1 + Complex.I) = Complex.I := l4\n  field_simp at this\n  norm_num at this\n  contradiction"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since $b=d$, ... which solves to $b=i$.", "statement": "We assume:\n\u2022 b = d [l2]\n\u2022 b = i [l5]\nTherefore, we conclude:\n\u2022 d = i [l6].", "dependencies": ["l2", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (b d i : \u2102)\n  (l2 : b = d)\n  (l5 : b = i) :\n  d = i := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (b d i : \u2102)\n  (l2 : b = d)\n  (l5 : b = i) :\n  d = i := by\n  rw [\u2190 l2, l5]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects, with acceptable addition of complex number types", "First assumption 'b = d [l2]' is perfectly translated to '(l2 : b = d)'", "Second assumption 'b = i [l5]' is perfectly translated to '(l5 : b = i)'", "Conclusion 'd = i [l6]' is perfectly captured as the goal of lemma l6", "The overall logical structure of transitive equality reasoning is preserved exactly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting the derived values $a=-1, c=1, b=i, d=i$ into the general form yields $T(z) = \\frac{-z+i}{z+i}$.", "statement": "We assume:\n\u2022 T(z) has the general form (az+b)/(cz+d) [tc_1]\n\u2022 The coefficients are a = -1 and c = 1 [def_1]\n\u2022 The coefficient b = i [l5]\n\u2022 The coefficient d = i [l6]\nTherefore, we conclude:\n\u2022 T(z) = (-z+i)/(z+i) [ts_1].", "dependencies": ["tc_1", "def_1", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (T : \u2102 \u2192 \u2102) (z : \u2102) (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (def_1 : c = 1 \u2227 a = -1)\n  (l5 : b = Complex.I)\n  (l6 : d = Complex.I) :\n  T z = (-z + Complex.I) / (z + Complex.I) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (T : \u2102 \u2192 \u2102) (z : \u2102) (a b c d : \u2102)\n  (tc_1 : (\u2200 z, T z = (a * z + b) / (c * z + d)) \u2227 (a * d - b * c \u2260 0))\n  (def_1 : c = 1 \u2227 a = -1)\n  (l5 : b = Complex.I)\n  (l6 : d = Complex.I) :\n  T z = (-z + Complex.I) / (z + Complex.I) := by\n  have h1 : \u2200 z, T z = (a * z + b) / (c * z + d) := tc_1.1\n  rw [h1 z, def_1.1, def_1.2, l5, l6]\n  simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The general form is correctly captured. The additional determinant condition (a*d - b*c \u2260 0) is a standard mathematical requirement for M\u00f6bius transformations and represents good mathematical practice.", "All coefficient assignments are correctly formalized with appropriate complex number notation.", "The conclusion is perfectly translated with consistent use of Complex.I for the imaginary unit.", "The deductive structure from assumptions to conclusion is properly maintained in the lemma format.", "The mathematical substitution and simplification logic is correctly represented in both versions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    