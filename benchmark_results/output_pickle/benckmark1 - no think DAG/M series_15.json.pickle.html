
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=1$ and the recurrence relation $a_n = a_{n-1} + a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the inequality $a_n \leq 2^{n-1}$ holds.

Proof: For $n=1$, we have $a_1=1$. The inequality is $1 \leq 2^{1-1}=2^0=1$. This holds. For $n=2$, we have $a_2=1$. The inequality is $1 \leq 2^{2-1}=2^1=2$. This also holds. Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j \leq 2^{j-1}$ for $1 \leq j \leq k$. We must prove the inequality holds for $n=k+1$, i.e., $a_{k+1} \leq 2^{k}$. From the recurrence relation, we have $a_{k+1} = a_k + a_{k-1}$. By the inductive hypothesis, we know that $a_k \leq 2^{k-1}$ and $a_{k-1} \leq 2^{k-2}$. Therefore, we can write $a_{k+1} \leq 2^{k-1} + 2^{k-2}$. Now we simplify the right-hand side: $a_{k+1} \leq 2^{k-2}(2+1) = 3 \cdot 2^{k-2}$. We need to show that $3 \cdot 2^{k-2} \leq 2^k$. Dividing both sides by $2^{k-2}$ gives $3 \leq 2^2=4$. This is true. Thus, $a_{k+1} \leq 2^{k}$. By the principle of **strong mathematical induction**, the inequality $a_n \leq 2^{n-1}$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=1$ and the recurrence relation $a_n = a_{n-1} + a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined by $a_1=1$, $a_2=1$, and $a_n = a_{n-1} + a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2115)\n(tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean condition `a 1 = 1` directly matches the natural language condition $a_1 = 1$", "The Lean condition `a 2 = 1` directly matches the natural language condition $a_2 = 1$", "The Lean condition `\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)` correctly captures the recurrence relation for all natural numbers n \u2265 3, which matches the natural language condition for all integers n \u2265 3 (since we're working with positive indices)", "The Lean declaration `variable (a : \u2115 \u2192 \u2115)` defines the sequence as a function from natural numbers to natural numbers, which correctly captures that the sequence consists of integers (natural numbers are a subset of integers) indexed by natural numbers starting from 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, we have $a_1=1$. The inequality is $1 \\leq 2^{1-1}=2^0=1$. This holds.", "statement": "We assume:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined with $a_1=1$ [tc_1].\nTherefore, we conclude:\n\u2022 The proposition $a_n \\leq 2^{n-1}$ holds for n=1, i.e., $a_1 \\leq 2^{1-1}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2))) :\n  a 1 \u2264 2^(1 - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2))) :\n  a 1 \u2264 2^(1 - 1) := by\n  simp [tc_1.1]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization includes a complete Fibonacci sequence definition (a_2 = 1 and recurrence relation) that is not mentioned in the natural language, which only specifies a_1 = 1. This is a major addition of logical content.", "The conclusion statement a_1 \u2264 2^(1-1) is perfectly captured in both the natural language and Lean formalization.", "The type declaration uses natural numbers (\u2115) instead of integers (\u2124), but this is a minor difference that doesn't affect the logical meaning in this context."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization includes a complete Fibonacci sequence definition (a_2 = 1 and recurrence relation) that is not mentioned in the natural language, which only specifies a_1 = 1. This is a major addition of logical content.', 'The conclusion statement a_1 \u2264 2^(1-1) is perfectly captured in both the natural language and Lean formalization.', \"The type declaration uses natural numbers (\u2115) instead of integers (\u2124), but this is a minor difference that doesn't affect the logical meaning in this context.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we have $a_2=1$. The inequality is $1 \\leq 2^{2-1}=2^1=2$. This also holds.", "statement": "We assume:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined with $a_2=1$ [tc_1].\nTherefore, we conclude:\n\u2022 The proposition $a_n \\leq 2^{n-1}$ holds for n=2, i.e., $a_2 \\leq 2^{2-1}$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2))) :\n  a 2 \u2264 2 ^ (2 - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2))) :\n  a 2 \u2264 2 ^ (2 - 1) := by\n  have h : a 2 = 1 := tc_1.2.1\n  rw [h]\n  simp", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition in tc_1 includes much more information than stated in the natural language. The natural language only mentions a_2=1, but the Lean formalization includes a_1=1 and a complete Fibonacci-like recurrence relation that is not mentioned in the premise.", "The conclusion statement a_2 \u2264 2^(2-1) is perfectly captured in both the natural language and Lean formalization.", "The type declaration uses natural numbers (\u2115) instead of integers (\u2124) as mentioned in natural language, but this is a minor notational difference that doesn't affect the core logic given the context."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition in tc_1 includes much more information than stated in the natural language. The natural language only mentions a_2=1, but the Lean formalization includes a_1=1 and a complete Fibonacci-like recurrence relation that is not mentioned in the premise.', 'The conclusion statement a_2 \u2264 2^(2-1) is perfectly captured in both the natural language and Lean formalization.', \"The type declaration uses natural numbers (\u2115) instead of integers (\u2124) as mentioned in natural language, but this is a minor notational difference that doesn't affect the core logic given the context.\"]"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j \\leq 2^{j-1}$ for $1 \\leq j \\leq k$.", "statement": "Definition:\n\u2022 For the inductive step, we introduce a fixed integer $k \\geq 2$ and assume as the Inductive Hypothesis (IH) that for the sequence $(a_n)$ [tc_1], the inequality $a_j \\leq 2^{j-1}$ holds for all integers $j$ such that $1 \\leq j \\leq k$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2115)\n(tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))\n(k : \u2115) (hk : k \u2265 2)\n(def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The natural language mentions 'integer k \u2265 2' but Lean uses 'k : \u2115' (natural number). While natural numbers are a subset of integers and k \u2265 2 ensures k is positive, this is a slight type difference in representation.", "The Lean formalization correctly captures the sequence definition with the inductive hypothesis reference tc_1, matching the natural language description.", "The Lean def_1 correctly formalizes the consideration of all integers j such that 1 \u2264 j \u2264 k, using the appropriate logical structure.", "The inequality a_j \u2264 2^(j-1) for all j in the specified range is perfectly captured in the Lean def_1 formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relation, we have $a_{k+1} = a_k + a_{k-1}$.", "statement": "We assume:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined by $a_n = a_{n-1} + a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 We consider a fixed integer $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = a_k + a_{k-1}$ [l3].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u2115) (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))\n  (def_1 : k \u2265 2 \u2227 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1))) :\n  a (k + 1) = a k + a (k - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (a : \u2115 \u2192 \u2115) (k : \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))\n  (def_1 : k \u2265 2 \u2227 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1))) :\n  a (k + 1) = a k + a (k - 1) := by\n  have hk : k + 1 \u2265 3 := by linarith\n  rcases tc_1 with \u27e8_, _, h\u27e9\n  exact h (k + 1) hk", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The recurrence relation is correctly captured. The additional initial conditions a(1)=1 and a(2)=1 are extra details not mentioned in natural language but are logically consistent.", "The constraint k\u22652 is correctly captured. The additional bound condition on sequence values is an extra constraint not mentioned in natural language but is logically consistent.", "The conclusion a(k+1) = a(k) + a(k-1) perfectly matches the natural language statement.", "Natural language refers to 'integers' while Lean uses natural numbers (\u2115). This is a minor notational difference that doesn't significantly affect the logical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we know that $a_k \\leq 2^{k-1}$ and $a_{k-1} \\leq 2^{k-2}$.", "statement": "We assume:\n\u2022 The Inductive Hypothesis (IH): for a fixed integer $k \\geq 2$, we have $a_j \\leq 2^{j-1}$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1].\nTherefore, we conclude:\n\u2022 $a_k \\leq 2^{k-1}$ and $a_{k-1} \\leq 2^{k-2}$ [l4].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u2115) (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) :\n  a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (a : \u2115 \u2192 \u2115) (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) :\n  a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2) := by\n  constructor\n  \u00b7 apply def_1 k\n    constructor\n    \u00b7 omega\n    \u00b7 rfl\n  \u00b7 apply def_1 (k - 1)\n    constructor\n    \u00b7 omega\n    \u00b7 omega", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The inductive hypothesis is correctly formalized with proper universal quantification and range constraints", "The conclusion correctly captures both inequalities using conjunction", "The constraint k \u2265 2 is properly included as a hypothesis", "The sequence a is appropriately defined as a function from naturals to naturals", "The logical structure correctly shows that the specific cases follow from the general inductive hypothesis"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, we can write $a_{k+1} \\leq 2^{k-1} + 2^{k-2}$. Now we simplify the right-hand side: $a_{k+1} \\leq 2^{k-2}(2+1) = 3 \\cdot 2^{k-2}$.", "statement": "We assume:\n\u2022 $a_{k+1} = a_k + a_{k-1}$ [l3].\n\u2022 $a_k \\leq 2^{k-1}$ and $a_{k-1} \\leq 2^{k-2}$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} \\leq 3 \\cdot 2^{k-2}$ [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u2115) (k : \u2115)\n  (l3 : a (k + 1) = a k + a (k - 1))\n  (l4 : a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2)) :\n  a (k + 1) \u2264 3 * 2^(k - 2) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (a : \u2115 \u2192 \u2115) (k : \u2115)\n  (l3 : a (k + 1) = a k + a (k - 1))\n  (l4 : a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2)) :\n  a (k + 1) \u2264 3 * 2^(k - 2) := by\n  rw [l3]\n  have hk : 2^(k - 1) = 2 * 2^(k - 2) := by\n    rw [\u2190 pow_succ, Nat.sub_add_cancel (by omega)]\n  rw [hk] at l4\n  apply Nat.add_le_of_le_add\n  simp [l4.left, l4.right]\n  omega", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 8, "endLine": 12, "endColumn": 18, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a ^ ?n * ?a\na : \u2115 \u2192 \u2115\nk : \u2115\nl3 : a (k + 1) = a k + a (k - 1)\nl4 : a k \u2264 2 ^ (k - 1) \u2227 a (k - 1) \u2264 2 ^ (k - 2)\n\u22a2 2 ^ (k - 1) = 2 * 2 ^ (k - 2)"}, {"line": 14, "column": 8, "endLine": 14, "endColumn": 28, "data": "unknown constant 'Nat.add_le_of_le_add'"}, {"line": 15, "column": 2, "endLine": 15, "endColumn": 26, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Function and variable declarations correctly capture the mathematical sequence concept with appropriate types", "Recurrence relation l3 is a direct and accurate translation from mathematical notation to Lean syntax", "Bounds assumptions l4 correctly use conjunction to combine both inequalities with proper exponentiation syntax", "Conclusion l5 accurately represents the target inequality with correct multiplication and exponentiation notation", "Overall logical structure properly models the mathematical reasoning from assumptions to conclusion", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5 :\n  \u2203 (a : \u2115 \u2192 \u2115) (k : \u2115),\n    (a (k + 1) = a k + a (k - 1)) \u2227\n    (a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2)) \u2227\n    \u00ac(a (k + 1) \u2264 3 * 2^(k - 2)) := by\n  let a : \u2115 \u2192 \u2115 := fun n => 2^(n - 1)\n  use a, 3\n  constructor\n  \u00b7 simp [a, Nat.add_sub_assoc (by norm_num), Nat.sub_add_cancel (by norm_num)]\n  \u00b7 constructor\n    \u00b7 constructor\n      \u00b7 simp [a, Nat.pow_le_pow_iff_right (by norm_num)]\n        norm_num\n      \u00b7 simp [a, Nat.pow_le_pow_iff_right (by norm_num)]\n        norm_num\n    \u00b7 simp [a, Nat.add_sub_assoc (by norm_num), Nat.sub_add_cancel (by norm_num)]\n      norm_num"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "We need to show that $3 \\cdot 2^{k-2} \\leq 2^k$. Dividing both sides by $2^{k-2}$ gives $3 \\leq 2^2=4$. This is true.", "statement": "We assume:\n\u2022 We have an integer $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $3 \\cdot 2^{k-2} \\leq 2^k$ [l6].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (k : \u2115) (hk : k \u2265 2) :\n  3 * 2^(k - 2) \u2264 2^k := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (k : \u2115) (hk : k \u2265 2) :\n  3 * 2^(k - 2) \u2264 2^k := by\n  have hk' : 2 \u2264 k := hk\n  rw [\u2190 mul_one (2^k), \u2190 pow_sub' _ hk']\n  simp only [mul_le_mul_left (zero_lt_two' \u2115), pow_sub]\n  norm_num", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 25, "endLine": 9, "endColumn": 33, "data": "unknown identifier 'pow_sub''"}, {"line": 9, "column": 23, "endLine": 9, "endColumn": 39, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.2396\nk : \u2115\nhk : k \u2265 2\nhk' : 2 \u2264 k\n\u22a2 3 * 2 ^ (k - 2) \u2264 2 ^ k * 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language specifies 'integer' while Lean uses natural numbers (\u2115). However, given the constraint k \u2265 2, this represents the same mathematical domain in practice, making this a minor notational difference rather than a logical inconsistency.", "The mathematical inequality 3 * 2^(k-2) \u2264 2^k is perfectly captured in both the natural language and Lean formalization with identical mathematical meaning.", "The logical structure of assumption leading to conclusion is correctly represented in the Lean lemma format, with the hypothesis hk properly constraining k and the goal statement matching the claimed conclusion.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6_neg\n  (k : \u2115) (hk : k \u2265 2) :\n  \u00ac (3 * 2^(k - 2) \u2264 2^k) := by\n  intro h\n  have h2 : 2 \u2265 2 := by rfl\n  have h3 := h (k := 2) h2\n  simp at h3\n  norm_num at h3"}, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Thus, $a_{k+1} \\leq 2^{k}$.", "statement": "We assume:\n\u2022 $a_{k+1} \\leq 3 \\cdot 2^{k-2}$ [l5].\n\u2022 $3 \\cdot 2^{k-2} \\leq 2^k$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1} \\leq 2^k$ [l7].", "dependencies": ["l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u2115) (k : \u2115)\n  (l5 : a (k + 1) \u2264 3 * 2^(k - 2))\n  (l6 : 3 * 2^(k - 2) \u2264 2^k) :\n  a (k + 1) \u2264 2^k := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (a : \u2115 \u2192 \u2115) (k : \u2115)\n  (l5 : a (k + 1) \u2264 3 * 2^(k - 2))\n  (l6 : 3 * 2^(k - 2) \u2264 2^k) :\n  a (k + 1) \u2264 2^k := by\n  exact le_trans l5 l6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The function and variable declarations correctly capture the sequence a and natural number k from the natural language", "Assumption l5 is translated exactly with correct mathematical notation and labeling", "Assumption l6 is translated exactly with correct mathematical notation and labeling", "The conclusion l7 is translated exactly as the goal of the lemma", "The overall logical structure perfectly captures the transitivity reasoning from the natural language proof"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of **strong mathematical induction**, the inequality $a_n \\leq 2^{n-1}$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined as in [tc_1].\n\u2022 The proposition $a_n \\leq 2^{n-1}$ holds for n=1 [l1].\n\u2022 The proposition $a_n \\leq 2^{n-1}$ holds for n=2 [l2].\n\u2022 For any integer $k \\geq 2$, assuming $a_j \\leq 2^{j-1}$ for $1 \\leq j \\leq k$ [def_1] implies $a_{k+1} \\leq 2^k$ [l7].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $a_n \\leq 2^{n-1}$ holds [ts_1].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))\n  (l1 : a 1 \u2264 2^(1 - 1))\n  (l2 : a 2 \u2264 2 ^ (2 - 1))\n  (def_1 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) \u2192 a (k + 1) \u2264 2^k) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))\n  (l1 : a 1 \u2264 2^(1 - 1))\n  (l2 : a 2 \u2264 2 ^ (2 - 1))\n  (def_1 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) \u2192 a (k + 1) \u2264 2^k) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by\n  intro n hn\n  induction n using Nat.strong_induction_on with\n  | ind n ih =>\n    match n with\n    | 0 => simp at hn\n    | 1 => exact l1\n    | 2 => exact l2\n    | k+3 =>\n      have hk : k + 3 \u2265 3 := by omega\n      have hrec := tc_1.right.right (k + 3) hk\n      rw [hrec]\n      have h1 : a (k + 2) \u2264 2 ^ (k + 2 - 1) := by\n        apply ih (k + 2)\n        omega\n        omega\n      have h2 : a (k + 1) \u2264 2 ^ (k + 1 - 1) := by\n        apply ih (k + 1)\n        omega\n        omega\n      rw [Nat.sub_add_cancel (by omega), Nat.sub_add_cancel (by omega)]\n      simp at h1 h2\n      simp [pow_add]\n      linarith [h1, h2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 2, "endLine": 35, "endColumn": 23, "data": "invalid alternative name 'ind', expected 'h'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition tc_1 correctly captures the Fibonacci sequence structure, providing concrete definition where natural language only references it.", "Base cases l1 and l2 perfectly match the natural language statements for n=1 and n=2.", "The inductive step has a structural difference: natural language describes one implication, but Lean separates it into two independent assumptions (def_1 and l7). The logical content is preserved but the structure differs.", "The conclusion ts_1 perfectly captures the universal quantification and inequality from natural language.", "Using natural numbers instead of integers is mathematically appropriate for this context since we're dealing with positive indices and Fibonacci numbers.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  (a : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 1 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)))\n  (l1 : a 1 \u2264 2^(1 - 1))\n  (l2 : a 2 \u2264 2 ^ (2 - 1))\n  (def_1 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)))\n  (l7 : \u2200 (k : \u2115), k \u2265 2 \u2192 (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) \u2192 a (k + 1) \u2264 2^k) :\n  \u00ac \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by\n  simp [not_forall]\n  use 4\n  constructor\n  \u00b7 norm_num\n  \u00b7 have h4 := tc_1.2.2 4 (by norm_num)\n    simp at h4\n    rw [h4]\n    have h3 := tc_1.2.2 3 (by norm_num)\n    simp at h3\n    rw [h3]\n    have h1 := tc_1.1\n    have h2 := tc_1.2.1\n    rw [h1, h2]\n    norm_num\n    linarith"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    