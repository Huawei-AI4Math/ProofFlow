
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\rho$ and $\sigma$ are equivalent  metrics on a set $A,$ then
 $(A,\rho)$ and $(A,\sigma)$ have the same open sets.

Proof: Suppose that \eqref{eq:8.1.18} holds. Let $S$ be an open set in
$(A,\rho)$ and let $x_0\in S$. Then there is an $\epsilon>0$ such
that $x\in S$ if $\rho(x,x_0)<\epsilon$, so the second
inequality in \eqref{eq:8.1.18}
implies  that $x_0\in S$ if $\sigma(x,x_0)\le\epsilon/\beta$.
Therefore, $S$ is open in $(A,\sigma)$.
Conversely, suppose that $S$ is open in $(A,\sigma)$
and let $x_0\in S$. Then there is an $\epsilon>0$ such
that $x\in S$ if $\sigma(x,x_0)<\epsilon$, so the first
inequality in \eqref{eq:8.1.18}
implies  that $x_0\in S$ if $\rho(x,x_0)\le\epsilon\alpha$.
Therefore, $S$ is open in $(A,\rho)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\rho$ and $\\sigma$ are ... metrics on a set $A,$", "statement": "Premise:\n\u2022 A is a set, and $\\rho$ and $\\sigma$ are metrics on A [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {A : Type*} (\u03c1 \u03c3 : MetricSpace A)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Type* in Lean appropriately represents what is informally called a 'set' in the context of metric spaces", "The Lean formalization declares \u03c1 as a MetricSpace structure on A, but the natural language states \u03c1 is a metric (distance function) on A. These are different concepts - MetricSpace A is the entire metric space structure, while a metric would be a function A \u2192 A \u2192 \u211d", "Same issue as with \u03c1 - \u03c3 is declared as a MetricSpace structure rather than a metric function as stated in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"Type* in Lean appropriately represents what is informally called a 'set' in the context of metric spaces\", 'The Lean formalization declares \u03c1 as a MetricSpace structure on A, but the natural language states \u03c1 is a metric (distance function) on A. These are different concepts - MetricSpace A is the entire metric space structure, while a metric would be a function A \u2192 A \u2192 \u211d', 'Same issue as with \u03c1 - \u03c3 is declared as a MetricSpace structure rather than a metric function as stated in the natural language']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Suppose that \\eqref{eq:8.1.18} holds.", "statement": "Premise:\n\u2022 A is a set, and $\\rho$ and $\\sigma$ are metrics on A [tc_1].\n\u2022 $\\rho$ and $\\sigma$ are equivalent, meaning there exist positive constants $\\alpha, \\beta$ such that for all $x,y \\in A$, $\\alpha\\sigma(x,y) \\le \\rho(x,y) \\le \\beta\\sigma(x,y)$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {A : Type*} (\u03c1 \u03c3 : MetricSpace A)\n(tc_2 : \u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3.dist x y \u2264 \u03c1.dist x y \u2227 \u03c1.dist x y \u2264 \u03b2 * \u03c3.dist x y))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The natural language states 'A is a set' but Lean declares 'A : Type*'. In Lean's type theory, Type* is more general than a set, but this is a standard and acceptable formalization choice that captures the same mathematical intent.", "The Lean formalization '\u03c1 \u03c3 : MetricSpace A' correctly captures that both \u03c1 and \u03c3 are metrics on A. In Lean, MetricSpace A provides the metric structure including the distance function.", "Same as above - \u03c3 is correctly formalized as a metric on A.", "The equivalence of metrics is correctly captured by the existence of the constants \u03b1 and \u03b2 with the required inequalities.", "The Lean condition '\u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3.dist x y \u2264 \u03c1.dist x y \u2227 \u03c1.dist x y \u2264 \u03b2 * \u03c3.dist x y)' perfectly matches the natural language requirement, with \u03c3.dist and \u03c1.dist representing the metric functions \u03c3(x,y) and \u03c1(x,y) respectively."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Let $S$ be an open set in $(A,\\rho)$ and let $x_0\\in S$. Then there is an $\\epsilon>0$ such that $x\\in S$ if $\\rho(x,x_0)<\\epsilon$, so the second inequality in \\eqref{eq:8.1.18} implies that $x_0\\in S$ if $\\sigma(x,x_0)\\le\\epsilon/\\beta$. Therefore, $S$ is open in $(A,\\sigma)$.", "statement": "We assume:\n\u2022 The metrics $\\rho$ and $\\sigma$ on set A are equivalent [tc_2].\n\u2022 S is an open set in the metric space $(A, \\rho)$.\nTherefore, we conclude:\n\u2022 S is an open set in the metric space $(A, \\sigma)$ [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {A : Type*} (\u03c1 \u03c3 : MetricSpace A)\n  (tc_2 : \u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3.dist x y \u2264 \u03c1.dist x y \u2227 \u03c1.dist x y \u2264 \u03b2 * \u03c3.dist x y))\n  (h_S_open_rho : IsOpen[\u03c1.toTopologicalSpace] S) (S : Set A) :\n  IsOpen[\u03c3.toTopologicalSpace] S := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 25, "endLine": 8, "endColumn": 45, "data": "invalid field 'toTopologicalSpace', the environment does not contain 'MetricSpace.toTopologicalSpace'\n  \u03c1\nhas type\n  MetricSpace A"}, {"line": 9, "column": 9, "endLine": 9, "endColumn": 29, "data": "invalid field 'toTopologicalSpace', the environment does not contain 'MetricSpace.toTopologicalSpace'\n  \u03c3\nhas type\n  MetricSpace A"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.Topology.MetricSpace.Basic\nimport Mathlib.Topology.Bases\n\nopen Topology\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {A : Type*} [MetricSpace A] (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d)\n  (tc_2 : \u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y))\n  (h_S_open_rho : IsOpen[UniformSpace.toTopologicalSpace (PseudoMetricSpace.toUniformSpace' \u03c1)] S)\n  (S : Set A) :\n  IsOpen[UniformSpace.toTopologicalSpace (PseudoMetricSpace.toUniformSpace' \u03c3)] S := by\n  rcases tc_2 with \u27e8\u03b1, \u03b2, h\u03b1, h\u03b2, h\u27e9\n  rw [MetricSpace.isOpen_iff] at h_S_open_rho \u22a2\n  intro x hx\n  rcases h_S_open_rho x hx with \u27e8\u03b5, h\u03b5, hball\u27e9\n  use \u03b5 / \u03b2, div_pos h\u03b5 h\u03b2\n  intro y hy\n  apply hball\n  have := (h x y).2\n  rw [dist_eq] at *\n  calc \u03c1 x y \u2264 \u03b2 * \u03c3 x y := this\n  _ < \u03b2 * (\u03b5 / \u03b2) := (mul_lt_mul_left h\u03b2).mpr hy\n  _ = \u03b5 := mul_div_cancel' _ (ne_of_gt h\u03b2)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 3, "column": 0, "endLine": 3, "endColumn": 6, "data": "invalid 'import' command, it must be used in the beginning of the file"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Conversely, suppose that $S$ is open in $(A,\\sigma)$ and let $x_0\\in S$. Then there is an $\\epsilon>0$ such that $x\\in S$ if $\\sigma(x,x_0)<\\epsilon$, so the first inequality in \\eqref{eq:8.1.18} implies that $x_0\\in S$ if $\\rho(x,x_0)\\le\\epsilon\\alpha$. Therefore, $S$ is open in $(A,\\rho)$.", "statement": "We assume:\n\u2022 The metrics $\\rho$ and $\\sigma$ on set A are equivalent [tc_2].\n\u2022 S is an open set in the metric space $(A, \\sigma)$.\nTherefore, we conclude:\n\u2022 S is an open set in the metric space $(A, \\rho)$ [l2].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {A : Type*} (\u03c1 \u03c3 : MetricSpace A) (S : Set A)\n  (tc_2 : \u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3.dist x y \u2264 \u03c1.dist x y \u2227 \u03c1.dist x y \u2264 \u03b2 * \u03c3.dist x y))\n  (hS_open_sigma : IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S) :\n  IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {A : Type*} (\u03c1 \u03c3 : MetricSpace A) (S : Set A)\n  (tc_2 : \u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3.dist x y \u2264 \u03c1.dist x y \u2227 \u03c1.dist x y \u2264 \u03b2 * \u03c3.dist x y))\n  (hS_open_sigma : IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S) :\n  IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S := by\n  rcases tc_2 with \u27e8\u03b1, \u03b2, h\u03b1, h\u03b2, h\u27e9\n  rw [Metric.isOpen_iff] at hS_open_sigma \u22a2\n  intro x hx\n  obtain \u27e8\u03b5, h\u03b5, h\u03b5ball\u27e9 := hS_open_sigma x hx\n  use \u03b1 * \u03b5\n  constructor\n  \u00b7 exact mul_pos h\u03b1 h\u03b5\n  \u00b7 intro y hy\n    apply h\u03b5ball\n    rw [Metric.mem_ball] at hy \u22a2\n    have := (h x y).1\n    rw [dist_eq] at hy this \u22a2\n    linarith", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 6, "endLine": 11, "endColumn": 23, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  IsOpen ?m.858\ncase intro.intro.intro.intro\nA : Type u_1\n\u03c1 \u03c3 : MetricSpace A\nS : Set A\nhS_open_sigma : \u2200 x \u2208 S, \u2203 \u03b5 > 0, Metric.ball x \u03b5 \u2286 S\n\u03b1 \u03b2 : \u211d\nh\u03b1 : 0 < \u03b1\nh\u03b2 : 0 < \u03b2\nh : \u2200 (x y : A), \u03b1 * Dist.dist x y \u2264 Dist.dist x y \u2227 Dist.dist x y \u2264 \u03b2 * Dist.dist x y\n\u22a2 IsOpen S"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type and variable declarations correctly capture the mathematical objects mentioned in the natural language.", "The Lean formalization provides the precise mathematical definition of metric equivalence, which correctly formalizes the natural language statement about equivalent metrics.", "The assumption about S being open in the \u03c3 metric space is correctly formalized using the appropriate Lean syntax for open sets in topological spaces induced by metrics.", "The conclusion about S being open in the \u03c1 metric space is correctly expressed as the goal of the lemma.", "The overall logical structure perfectly matches: the Lean lemma captures the theorem statement that equivalent metrics preserve the property of being open, with all assumptions and conclusions properly formalized.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib.Topology.MetricSpace.Basic\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nimport Aesop\n\nlemma not_l2 :\n  \u2203 (A : Type*) (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) (S : Set A),\n    (\u2200 x, \u03c1 x x = 0) \u2227 (\u2200 x y, \u03c1 x y = \u03c1 y x) \u2227 (\u2200 x y z, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z) \u2227\n    (\u2200 x, \u03c3 x x = 0) \u2227 (\u2200 x y, \u03c3 x y = \u03c3 y x) \u2227 (\u2200 x y z, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z) \u2227\n    (\u2203 (\u03b1 \u03b2 : \u211d), 0 < \u03b1 \u2227 0 < \u03b2 \u2227 (\u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y)) \u2227\n    IsOpen[UniformSpace.ofDist \u03c3 (by simp) (by simp [ite_eq_left_iff]) (by simp [ite_eq_left_iff])] S \u2227\n    \u00acIsOpen[UniformSpace.ofDist \u03c1 (by simp) (by simp) (fun x y => abs_sub_comm x y)] S := by\n  let A := \u211d\n  let \u03c1 := fun x y : \u211d => |x - y|\n  let \u03c3 := fun x y : \u211d => if x = y then 0 else 1\n  let S := Set.Ioo (0:\u211d) 1\n  refine \u27e8A, \u03c1, \u03c3, S, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_\u27e9\n  \u00b7 simp [\u03c1]\n  \u00b7 simp [\u03c1]\n  \u00b7 exact fun x y z => abs_sub_le x y z\n  \u00b7 simp [\u03c3]\n  \u00b7 simp [\u03c3, ite_eq_left_iff]\n  \u00b7 intro x y z; by_cases hx : x = y <;> by_cases hy : y = z <;> by_cases hz : x = z <;> simp [\u03c3, hx, hy, hz]\n  \u00b7 refine \u27e81, 2, zero_lt_one, zero_lt_two, fun x y => ?_\u27e9\n    simp [\u03c1, \u03c3]\n    split_ifs with h\n    \u00b7 simp [h]\n    \u00b7 simp [abs_nonneg, one_le_two]\n  \u00b7 rw [Metric.isOpen_iff]\n    intro x hx\n    refine \u27e81, zero_lt_one, fun y hy => ?_\u27e9\n    simp [\u03c3] at hy\n    simp [S] at hx\n    simp [S, hx, hy]\n  \u00b7 rw [Metric.isOpen_iff]\n    push_neg\n    refine \u27e80, by simp [S], fun r hr => ?_\u27e9\n    use -r/2\n    constructor\n    \u00b7 simp [S, abs_of_pos hr, hr]\n    \u00b7 simp [\u03c1]\n      rw [abs_of_pos (half_pos hr), abs_of_pos hr]\n      linarith"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "If $\\rho$ and $\\sigma$ are equivalent metrics on a set $A,$ then $(A,\\rho)$ and $(A,\\sigma)$ have the same open sets.", "statement": "We assume:\n\u2022 For any set S, if S is open in $(A, \\rho)$, then S is open in $(A, \\sigma)$ [l1].\n\u2022 For any set S, if S is open in $(A, \\sigma)$, then S is open in $(A, \\rho)$ [l2].\nTherefore, we conclude:\n\u2022 The collection of open sets of $(A, \\rho)$ is equal to the collection of open sets of $(A, \\sigma)$ [ts_1].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {A : Type*} (\u03c1 \u03c3 : MetricSpace A)\n  (l1 : \u2200 (S : Set A), IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S \u2192 IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S)\n  (l2 : \u2200 (S : Set A), IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S \u2192 IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S) :\n  {S : Set A | IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S} = {S : Set A | IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S} := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {A : Type*} (\u03c1 \u03c3 : MetricSpace A)\n  (l1 : \u2200 (S : Set A), IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S \u2192 IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S)\n  (l2 : \u2200 (S : Set A), IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S \u2192 IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S) :\n  {S : Set A | IsOpen[\u03c1.toUniformSpace.toTopologicalSpace] S} = {S : Set A | IsOpen[\u03c3.toUniformSpace.toTopologicalSpace] S} := by\n  ext S\n  constructor\n  \u00b7 exact l1 S\n  \u00b7 exact l2 S", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all aspects of the natural language statement. The type setup properly represents two metric spaces on the same underlying set, the assumptions l1 and l2 are accurately formalized as universal quantifications over implications about open sets, and the conclusion correctly expresses equality between the collections of open sets. The use of Mathlib's metric space to topological space conversion is appropriate and mathematically sound."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    