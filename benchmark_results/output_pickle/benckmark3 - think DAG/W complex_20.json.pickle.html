
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $z$ be a complex number and $\operatorname{Log}(z)$ denote its principal logarithm. If $\operatorname{Re}(\operatorname{Log}(z)) = \ln(\sqrt{8})$, $\operatorname{Im}(z) = \operatorname{Re}(z)$, and $\operatorname{Re}(z) > 0$, then $z = 2+2i$.

Proof: From the condition $\operatorname{Re}(\operatorname{Log}(z)) = \ln(\sqrt{8})$ and the definition $\operatorname{Re}(\operatorname{Log}(z)) = \ln|z|$, we deduce that $|z| = \sqrt{8}$. Letting $z = x+iy$, this implies $x^2+y^2 = 8$. Using the condition $\operatorname{Im}(z) = \operatorname{Re}(z)$, we substitute $y=x$ into the previous equation to get $x^2+x^2=8$, which simplifies to $x^2=4$. Given that $\operatorname{Re}(z) > 0$, we must have $x>0$, so we take the positive root $x=2$, which in turn implies $y=2$. Therefore, since $z=x+iy$, we conclude that $z = 2+2i$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $z$ be a complex number and $\\operatorname{Log}(z)$ denote its principal logarithm. If $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln(\\sqrt{8})$", "statement": "Premise:\n\u2022 Let z be a complex number and Log(z) denote its principal logarithm.\n\u2022 The real part of the principal logarithm of z is equal to the natural logarithm of the square root of 8: $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln(\\sqrt{8})$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (z : \u2102)\n  (h1 : Complex.re (Complex.log z) = Real.log (Real.sqrt 8))\n  (h2 : Complex.im z = Complex.re z)\n  (h3 : Complex.re z > 0) :\n  z = 2 + 2 * I := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean declaration (z : \u2102) perfectly matches the natural language condition that z is a complex number", "The Lean condition h1 perfectly captures the mathematical statement that Re(Log(z)) = ln(\u221a8), using the appropriate Lean functions for complex logarithm, real part, and real logarithm", "The Lean introduces condition h2 (Complex.im z = Complex.re z) which states that the imaginary part equals the real part. This condition is not mentioned anywhere in the natural language premise", "The Lean introduces condition h3 (Complex.re z > 0) which states that the real part is positive. This condition is not mentioned in the natural language premise", "The Lean includes a conclusion z = 2 + 2 * I, but the natural language explicitly states there are no new conclusions derived in this premise step"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean declaration (z : \u2102) perfectly matches the natural language condition that z is a complex number', 'The Lean condition h1 perfectly captures the mathematical statement that Re(Log(z)) = ln(\u221a8), using the appropriate Lean functions for complex logarithm, real part, and real logarithm', 'The Lean introduces condition h2 (Complex.im z = Complex.re z) which states that the imaginary part equals the real part. This condition is not mentioned anywhere in the natural language premise', 'The Lean introduces condition h3 (Complex.re z > 0) which states that the real part is positive. This condition is not mentioned in the natural language premise', 'The Lean includes a conclusion z = 2 + 2 * I, but the natural language explicitly states there are no new conclusions derived in this premise step']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "$\\operatorname{Im}(z) = \\operatorname{Re}(z)$", "statement": "Premise:\n\u2022 Let z be a complex number [from tc_1].\n\u2022 The imaginary part of z is equal to its real part: $\\operatorname{Im}(z) = \\operatorname{Re}(z)$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(tc_2 : Complex.im z = Complex.re z)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `variable (z : \u2102)` correctly captures that z is a complex number, where \u2102 represents the complex numbers in Lean", "The Lean condition `Complex.im z = Complex.re z` perfectly matches the mathematical statement Im(z) = Re(z), using Lean's standard library functions for imaginary and real parts of complex numbers"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "$\\operatorname{Re}(z) > 0$", "statement": "Premise:\n\u2022 Let z be a complex number [from tc_1].\n\u2022 The real part of z is positive: $\\operatorname{Re}(z) > 0$ [tc_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_3 (z : \u2102) (h : Complex.re z > 0) : Complex.re z > 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean header (z : \u2102) correctly captures that z is a complex number", "The Lean header (h : Complex.re z > 0) correctly captures the condition that the real part of z is positive", "The natural language explicitly states there are no conclusions derived in this premise step, but the Lean formalization has Complex.re z > 0 as a conclusion/proposition. This creates a logical inconsistency between the stated intent and the formalization"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean header (z : \u2102) correctly captures that z is a complex number', 'The Lean header (h : Complex.re z > 0) correctly captures the condition that the real part of z is positive', 'The natural language explicitly states there are no conclusions derived in this premise step, but the Lean formalization has Complex.re z > 0 as a conclusion/proposition. This creates a logical inconsistency between the stated intent and the formalization']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "the definition $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln|z|$", "statement": "Definition:\n\u2022 For any non-zero complex number z, the real part of its principal logarithm is the natural logarithm of its modulus: $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln|z|$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(def_1 : z \u2260 0 \u2192 Complex.re (Complex.log z) = Real.log (Complex.abs z))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that z is a complex number, and the non-zero condition is properly encoded as the hypothesis of the implication in def_1.", "The Lean formalization perfectly translates the mathematical equation: Complex.re corresponds to Re, Complex.log to Log, Real.log to ln, and Complex.abs to the modulus |z|. The implication structure properly encodes that this equality holds when z \u2260 0."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From the condition $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln(\\sqrt{8})$ and the definition $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln|z|$, we deduce that $|z| = \\sqrt{8}$.", "statement": "We assume:\n\u2022 Let z be a complex number such that $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln(\\sqrt{8})$ [tc_1].\n\u2022 For any non-zero complex number z, $\\operatorname{Re}(\\operatorname{Log}(z)) = \\ln|z|$ [def_1].\nTherefore, we conclude:\n\u2022 The modulus of z is $\\sqrt{8}$: $|z| = \\sqrt{8}$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (hz : z \u2260 0)\n           (tc_1 : Complex.re (Complex.log z) = Real.log (Real.sqrt 8))\n           (def_1 : \u2200 w : \u2102, w \u2260 0 \u2192 Complex.re (Complex.log w) = Real.log (Complex.abs w)) :\n           Complex.abs z = Real.sqrt 8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (hz : z \u2260 0)\n           (tc_1 : Complex.re (Complex.log z) = Real.log (Real.sqrt 8))\n           (def_1 : \u2200 w : \u2102, w \u2260 0 \u2192 Complex.re (Complex.log w) = Real.log (Complex.abs w)) :\n           Complex.abs z = Real.sqrt 8 := by\n  have h2 : Complex.re (Complex.log z) = Real.log (Complex.abs z) := by\n    have h2\u2081 : Complex.re (Complex.log z) = Real.log (Complex.abs z) := def_1 z hz\n    exact h2\u2081\n  \n  have h3 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := by\n    have h3\u2081 : Real.log (Complex.abs z) = Complex.re (Complex.log z) := by\n      rw [h2]\n      <;> ring\n    rw [h3\u2081]\n    rw [tc_1]\n    <;>\n    simp_all [Complex.abs, Complex.normSq]\n    <;>\n    ring_nf\n    <;>\n    norm_num\n  \n  have h4 : Complex.abs z = Real.sqrt 8 := by\n    have h4\u2081 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := h3\n    have h4\u2082 : Complex.abs z > 0 := by\n      apply Complex.abs.pos\n      exact hz\n    have h4\u2083 : Real.sqrt 8 > 0 := Real.sqrt_pos.mpr (by norm_num)\n    have h4\u2084 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := h3\n    have h4\u2085 : Complex.abs z = Real.sqrt 8 := by\n      apply Real.log_injOn_pos (Set.mem_Ioi.mpr h4\u2082) (Set.mem_Ioi.mpr h4\u2083)\n      linarith\n    exact h4\u2085\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declaration correctly captures z as a complex number with explicit non-zero condition", "Assumption tc_1 exactly translates the given condition Re(Log(z)) = ln(\u221a8)", "Definition def_1 properly formalizes the general property for any non-zero complex number using universal quantification", "Conclusion correctly states that the absolute value of z equals \u221a8"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "Letting $z = x+iy$", "statement": "Definition:\n\u2022 Let the complex number z be represented by its Cartesian components x and y, where $x = \\operatorname{Re}(z)$ and $y = \\operatorname{Im}(z)$, such that $z = x+iy$ [def_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(def_2 : \u2203 x y : \u211d, z = x + y * Complex.I \u2227 x = z.re \u2227 y = z.im)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean variable declaration correctly specifies z as a complex number", "The existential quantification over real numbers x and y correctly captures the Cartesian components", "z.re in Lean correctly represents the real part Re(z)", "z.im in Lean correctly represents the imaginary part Im(z)", "The equation z = x + y * Complex.I correctly represents z = x + iy with Complex.I being the imaginary unit"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "this implies $x^2+y^2 = 8$.", "statement": "We assume:\n\u2022 The modulus of z is $\\sqrt{8}$: $|z| = \\sqrt{8}$ [l1].\n\u2022 The complex number z is represented as $z = x+iy$ [def_2].\nTherefore, we conclude:\n\u2022 $x^2 + y^2 = 8$ [l2].", "dependencies": ["l1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (z : \u2102) (x y : \u211d)\n  (l1 : Complex.abs z = Real.sqrt 8)\n  (def_2 : z = x + y * Complex.I) :\n  x^2 + y^2 = 8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (z : \u2102) (x y : \u211d)\n  (l1 : Complex.abs z = Real.sqrt 8)\n  (def_2 : z = x + y * Complex.I) :\n  x^2 + y^2 = 8 := by\n  have h2 : Complex.abs z = Real.sqrt (x ^ 2 + y ^ 2) := by\n    rw [def_2]\n    simp [Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq, sq, mul_comm]\n    <;> ring_nf\n    <;> field_simp [Real.sqrt_eq_iff_sq_eq, sq, mul_comm]\n    <;> ring_nf\n    <;> norm_cast\n    <;> simp [Real.sqrt_eq_iff_sq_eq, sq, mul_comm]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h3 : Real.sqrt (x ^ 2 + y ^ 2) = Real.sqrt 8 := by\n    linarith\n  \n  have h4 : x ^ 2 + y ^ 2 = 8 := by\n    have h5 : Real.sqrt (x ^ 2 + y ^ 2) = Real.sqrt 8 := h3\n    have h6 : x ^ 2 + y ^ 2 \u2265 0 := by positivity\n    have h7 : (8 : \u211d) \u2265 0 := by norm_num\n    have h8 : Real.sqrt (x ^ 2 + y ^ 2) ^ 2 = Real.sqrt 8 ^ 2 := by rw [h5]\n    have h9 : Real.sqrt (x ^ 2 + y ^ 2) ^ 2 = x ^ 2 + y ^ 2 := by\n      rw [Real.sq_sqrt] <;> positivity\n    have h10 : Real.sqrt 8 ^ 2 = (8 : \u211d) := by\n      rw [Real.sq_sqrt] <;> norm_num\n    nlinarith\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The modulus condition |z| = \u221a8 is correctly formalized using Complex.abs and Real.sqrt", "The complex number representation z = x + iy is properly translated using Complex.I for the imaginary unit", "The conclusion x\u00b2 + y\u00b2 = 8 is directly and accurately represented", "The overall theorem structure correctly captures the logical relationship between premises and conclusion, with appropriate type declarations for formal verification"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Using the condition $\\operatorname{Im}(z) = \\operatorname{Re}(z)$, we substitute $y=x$ into the previous equation to get $x^2+x^2=8$", "statement": "We assume:\n\u2022 The imaginary part of z is equal to its real part: $\\operatorname{Im}(z) = \\operatorname{Re}(z)$ [tc_2].\n\u2022 $x^2 + y^2 = 8$ [l2].\n\u2022 The complex number z is represented as $z = x+iy$, with $x = \\operatorname{Re}(z)$ and $y = \\operatorname{Im}(z)$ [def_2].\nTherefore, we conclude:\n\u2022 $x^2 + x^2 = 8$ [l3].", "dependencies": ["tc_2", "l2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (z : \u2102) (x y : \u211d)\n  (tc_2 : Complex.im z = Complex.re z)\n  (l2 : x^2 + y^2 = 8)\n  (def_2 : z = x + y * Complex.I) :\n  x^2 + x^2 = 8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (z : \u2102) (x y : \u211d)\n  (tc_2 : Complex.im z = Complex.re z)\n  (l2 : x^2 + y^2 = 8)\n  (def_2 : z = x + y * Complex.I) :\n  x^2 + x^2 = 8 := by\n  have h_re : Complex.re z = x := by\n    rw [def_2]\n    simp [Complex.ext_iff, pow_two]\n    <;> ring_nf\n    <;> simp_all [Complex.ext_iff, pow_two]\n    <;> norm_num\n    <;> linarith\n  \n  have h_im : Complex.im z = y := by\n    rw [def_2]\n    simp [Complex.ext_iff, pow_two]\n    <;> ring_nf\n    <;> simp_all [Complex.ext_iff, pow_two]\n    <;> norm_num\n    <;> linarith\n  \n  have h_y_eq_x : y = x := by\n    have h\u2081 : Complex.im z = Complex.re z := tc_2\n    have h\u2082 : Complex.im z = y := h_im\n    have h\u2083 : Complex.re z = x := h_re\n    linarith\n  \n  have h_main : x^2 + x^2 = 8 := by\n    have h\u2081 : y = x := h_y_eq_x\n    have h\u2082 : x ^ 2 + y ^ 2 = 8 := l2\n    rw [h\u2081] at h\u2082\n    ring_nf at h\u2082 \u22a2\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The condition tc_2 correctly formalizes that the imaginary part equals the real part using Lean's Complex library functions.", "The equation l2 is directly and accurately translated from natural language to Lean.", "The complex number representation def_2 correctly uses Lean's complex number notation with Complex.I for the imaginary unit.", "The conclusion l3 is a direct translation of the mathematical statement, and the logical derivation from the premises is mathematically sound."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "which simplifies to $x^2=4$.", "statement": "We assume:\n\u2022 $x^2 + x^2 = 8$ [l3].\nTherefore, we conclude:\n\u2022 $x^2 = 4$ [l4].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (x : \u211d) (h : x^2 + x^2 = 8) : x^2 = 4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (x : \u211d) (h : x^2 + x^2 = 8) : x^2 = 4 := by\n  have h_main : x^2 = 4 := by\n    have h\u2081 : 2 * x ^ 2 = 8 := by\n      -- Combine like terms in the given equation to get 2 * x ^ 2 = 8\n      linarith\n    -- Solve for x ^ 2 by dividing both sides by 2\n    have h\u2082 : x ^ 2 = 4 := by\n      nlinarith\n    exact h\u2082\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption x\u00b2 + x\u00b2 = 8 is correctly captured as hypothesis h in the Lean formalization", "The conclusion x\u00b2 = 4 is correctly represented as the goal type in the Lean theorem", "The logical inference structure from assumption to conclusion is preserved in the Lean formalization through the theorem statement", "The explicit type declaration (x : \u211d) is an appropriate additional detail that doesn't contradict the natural language and makes the mathematical context precise"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Given that $\\operatorname{Re}(z) > 0$, we must have $x>0$, so we take the positive root $x=2$", "statement": "We assume:\n\u2022 The real part of z is positive: $\\operatorname{Re}(z) > 0$ [tc_3].\n\u2022 $x^2=4$ [l4].\n\u2022 The real part of z is x: $x = \\operatorname{Re}(z)$ [def_2].\nTherefore, we conclude:\n\u2022 $x = 2$ [l5].", "dependencies": ["tc_3", "l4", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (z : \u2102) (x : \u211d) \n  (h1 : Complex.re z > 0)\n  (h2 : x^2 = 4)\n  (h3 : x = Complex.re z) :\n  x = 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (z : \u2102) (x : \u211d) \n  (h1 : Complex.re z > 0)\n  (h2 : x^2 = 4)\n  (h3 : x = Complex.re z) :\n  x = 2 := by\n  have h4 : x = 2 \u2228 x = -2 := by\n    have h4\u2081 : x = 2 \u2228 x = -2 := by\n      have h4\u2082 : x ^ 2 - 4 = 0 := by\n        linarith\n      have h4\u2083 : (x - 2) * (x + 2) = 0 := by\n        linarith\n      have h4\u2084 : x - 2 = 0 \u2228 x + 2 = 0 := by\n        apply eq_zero_or_eq_zero_of_mul_eq_zero h4\u2083\n      cases h4\u2084 with\n      | inl h4\u2084 =>\n        have h4\u2085 : x - 2 = 0 := h4\u2084\n        have h4\u2086 : x = 2 := by linarith\n        exact Or.inl h4\u2086\n      | inr h4\u2084 =>\n        have h4\u2085 : x + 2 = 0 := h4\u2084\n        have h4\u2086 : x = -2 := by linarith\n        exact Or.inr h4\u2086\n    exact h4\u2081\n  \n  have h5 : x > 0 := by\n    have h5\u2081 : x = Complex.re z := h3\n    have h5\u2082 : Complex.re z > 0 := h1\n    linarith\n  \n  have h6 : x = 2 := by\n    cases h4 with\n    | inl h4 =>\n      exact h4\n    | inr h4 =>\n      -- If x = -2, then x \u2264 0, which contradicts h5 : x > 0\n      have h6\u2081 : x = -2 := h4\n      have h6\u2082 : x > 0 := h5\n      linarith\n  \n  exact h6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The theorem signature correctly declares complex number z and real number x with the three stated assumptions as hypotheses", "All three assumptions are accurately translated: positivity of real part, quadratic equation, and equality relationship", "The conclusion 'x = 2' is correctly stated as the theorem goal", "The formalization completely captures the logical structure and mathematical content from the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "which in turn implies $y=2$.", "statement": "We assume:\n\u2022 The imaginary part of z is equal to its real part: $\\operatorname{Im}(z) = \\operatorname{Re}(z)$ [tc_2].\n\u2022 $x = 2$ [l5].\n\u2022 The real part of z is x and the imaginary part is y: $x = \\operatorname{Re}(z), y = \\operatorname{Im}(z)$ [def_2].\nTherefore, we conclude:\n\u2022 $y = 2$ [l6].", "dependencies": ["tc_2", "l5", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (z : \u2102) \n  (x y : \u211d)\n  (tc_2 : Complex.im z = Complex.re z)\n  (l5 : x = 2)\n  (def_2 : z.re = x \u2227 z.im = y) :\n  y = 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (z : \u2102) \n  (x y : \u211d)\n  (tc_2 : Complex.im z = Complex.re z)\n  (l5 : x = 2)\n  (def_2 : z.re = x \u2227 z.im = y) :\n  y = 2 := by\n  have h_re : z.re = 2 := by\n    have h\u2081 : z.re = x := def_2.1\n    have h\u2082 : x = 2 := l5\n    linarith\n  \n  have h_im : z.im = 2 := by\n    have h\u2081 : Complex.im z = Complex.re z := tc_2\n    have h\u2082 : z.re = 2 := h_re\n    have h\u2083 : (z.im : \u211d) = (z.re : \u211d) := by\n      simpa [Complex.ext_iff] using h\u2081\n    have h\u2084 : (z.im : \u211d) = 2 := by\n      rw [h\u2083]\n      norm_cast at h\u2082 \u22a2\n      <;> simp_all [Complex.ext_iff]\n      <;> linarith\n    norm_cast at h\u2084 \u22a2\n    <;> simp_all [Complex.ext_iff]\n    <;> linarith\n  \n  have h_y : y = 2 := by\n    have h\u2081 : z.im = y := def_2.2\n    have h\u2082 : z.im = 2 := h_im\n    linarith\n  \n  exact h_y", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the complex number z and real numbers x, y mentioned in the natural language.", "The assumption tc_2 perfectly translates the condition that imaginary part equals real part.", "The assumption l5 directly captures x = 2.", "The assumption def_2 correctly represents the relationship between x, y and the real/imaginary parts of z, using logically equivalent but reversed equality statements.", "The conclusion y = 2 is correctly stated as the theorem goal.", "The overall logical structure and reasoning flow from assumptions to conclusion is faithfully preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, since $z=x+iy$, we conclude that $z = 2+2i$.", "statement": "We assume:\n\u2022 $x = 2$ [l5].\n\u2022 $y = 2$ [l6].\n\u2022 The complex number z is represented as $z = x + iy$ [def_2].\nTherefore, we conclude:\n\u2022 $z = 2 + 2i$ [ts_1].", "dependencies": ["l5", "l6", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (z : \u2102) \n  (h1 : Complex.re (Complex.log z) = Real.log (Real.sqrt 8))\n  (h2 : Complex.im z = Complex.re z)\n  (h3 : Complex.re z > 0) :\n  z = 2 + 2 * Complex.I := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (z : \u2102) \n  (h1 : Complex.re (Complex.log z) = Real.log (Real.sqrt 8))\n  (h2 : Complex.im z = Complex.re z)\n  (h3 : Complex.re z > 0) :\n  z = 2 + 2 * Complex.I := by\n  have h4 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := by\n    have h4\u2081 : Complex.re (Complex.log z) = Real.log (Complex.abs z) := by\n      -- The real part of the complex logarithm is the natural logarithm of the modulus\n      simp [Complex.log_re]\n      <;>\n      ring_nf\n    rw [h4\u2081] at h1\n    exact h1\n  \n  have h5 : Complex.abs z = Real.sqrt 8 := by\n    have h5\u2081 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := h4\n    have h5\u2082 : Complex.abs z > 0 := by\n      -- Prove that the modulus of z is positive\n      have h5\u2083 : Complex.re z > 0 := h3\n      have h5\u2084 : Complex.abs z = Real.sqrt (z.re * z.re + z.im * z.im) := by\n        simp [Complex.abs, Complex.normSq]\n        <;> ring_nf\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n        <;> ring_nf\n      rw [h5\u2084]\n      have h5\u2085 : Real.sqrt (z.re * z.re + z.im * z.im) > 0 := by\n        apply Real.sqrt_pos_of_pos\n        have h5\u2086 : (z.re : \u211d) > 0 := by exact_mod_cast h3\n        nlinarith [sq_pos_of_pos h5\u2086]\n      exact h5\u2085\n    have h5\u2083 : Real.sqrt 8 > 0 := Real.sqrt_pos.mpr (by norm_num)\n    -- Use the injectivity of the logarithm to deduce that the modulus of z is sqrt(8)\n    have h5\u2084 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := h5\u2081\n    have h5\u2085 : Real.log (Complex.abs z) = Real.log (Real.sqrt 8) := h5\u2084\n    have h5\u2086 : Complex.abs z = Real.sqrt 8 := by\n      apply Real.log_injOn_pos (Set.mem_Ioi.mpr h5\u2082) (Set.mem_Ioi.mpr h5\u2083)\n      linarith\n    exact h5\u2086\n  \n  have h6 : (Complex.abs z) ^ 2 = 8 := by\n    have h6\u2081 : (Complex.abs z) ^ 2 = (Real.sqrt 8) ^ 2 := by rw [h5]\n    rw [h6\u2081]\n    norm_num [Real.sqrt_eq_iff_sq_eq]\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try ring_nf) <;>\n    (try field_simp) <;>\n    (try nlinarith [Real.sqrt_nonneg 8, Real.sq_sqrt (show 0 \u2264 8 by norm_num)])\n  \n  have h7 : (z.re : \u211d) ^ 2 + (z.im : \u211d) ^ 2 = 8 := by\n    have h7\u2081 : (Complex.abs z) ^ 2 = (z.re : \u211d) ^ 2 + (z.im : \u211d) ^ 2 := by\n      -- Use the property that the square of the modulus is the sum of the squares of real and imaginary parts\n      rw [Complex.sq_abs]\n      <;> simp [Complex.normSq]\n      <;> ring_nf\n      <;> norm_cast\n      <;> field_simp [Complex.ext_iff, pow_two]\n      <;> ring_nf\n      <;> norm_num\n      <;> linarith\n    -- Use the previous result to equate the squares of the modulus and the sum of squares\n    linarith\n  \n  have h8 : (z.re : \u211d) ^ 2 + (z.re : \u211d) ^ 2 = 8 := by\n    have h8\u2081 : (z.im : \u211d) = (z.re : \u211d) := by\n      norm_cast at h2 \u22a2\n      <;> simp_all [Complex.ext_iff]\n      <;> linarith\n    have h8\u2082 : (z.re : \u211d) ^ 2 + (z.im : \u211d) ^ 2 = 8 := h7\n    rw [h8\u2081] at h8\u2082\n    ring_nf at h8\u2082 \u22a2\n    <;> linarith\n  \n  have h9 : (z.re : \u211d) ^ 2 = 4 := by\n    have h9\u2081 : (z.re : \u211d) ^ 2 + (z.re : \u211d) ^ 2 = 8 := h8\n    have h9\u2082 : 2 * (z.re : \u211d) ^ 2 = 8 := by linarith\n    have h9\u2083 : (z.re : \u211d) ^ 2 = 4 := by linarith\n    exact h9\u2083\n  \n  have h10 : z.re = 2 := by\n    have h10\u2081 : (z.re : \u211d) ^ 2 = 4 := h9\n    have h10\u2082 : (z.re : \u211d) > 0 := by exact_mod_cast h3\n    have h10\u2083 : (z.re : \u211d) = 2 := by\n      nlinarith\n    exact_mod_cast h10\u2083\n  \n  have h11 : z.im = 2 := by\n    have h11\u2081 : Complex.im z = Complex.re z := h2\n    have h11\u2082 : z.re = 2 := h10\n    have h11\u2083 : (Complex.im z : \u211d) = (Complex.re z : \u211d) := by\n      norm_cast\n      <;> simp_all [Complex.ext_iff]\n      <;> linarith\n    have h11\u2084 : (Complex.im z : \u211d) = 2 := by\n      have h11\u2085 : (Complex.re z : \u211d) = 2 := by\n        norm_cast\n        <;> simp_all [Complex.ext_iff]\n        <;> linarith\n      linarith\n    norm_cast at h11\u2084 \u22a2\n    <;> simp_all [Complex.ext_iff]\n    <;> linarith\n  \n  have h12 : z = 2 + 2 * Complex.I := by\n    have h12\u2081 : z.re = 2 := h10\n    have h12\u2082 : z.im = 2 := h11\n    have h12\u2083 : z = 2 + 2 * Complex.I := by\n      apply Complex.ext <;> simp [h12\u2081, h12\u2082, Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        ring_nf <;>\n        simp_all [Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        linarith\n    exact h12\u2083\n  \n  apply h12", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization represents a completely different mathematical problem than the natural language. The natural language describes a simple substitution where x=2 and y=2 are plugged into z=x+iy, while the Lean formalization involves complex logarithms and constraint equations. Although both conclude z=2+2i, the mathematical reasoning and premises are entirely different, making this a major inconsistency in logical content."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization represents a completely different mathematical problem than the natural language. The natural language describes a simple substitution where x=2 and y=2 are plugged into z=x+iy, while the Lean formalization involves complex logarithms and constraint equations. Although both conclude z=2+2i, the mathematical reasoning and premises are entirely different, making this a major inconsistency in logical content.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    