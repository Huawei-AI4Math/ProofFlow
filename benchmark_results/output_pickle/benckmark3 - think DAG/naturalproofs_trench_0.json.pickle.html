
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $a$ and $b$ are any two real numbers$,$ then
\begin{equation} \label{eq:1.1.3}
|a+b|\le |a|+|b|.
\end{equation}

Proof: There are four possibilities:
\begin{alist}
\item % (a)
If $a\ge0$ and $b\ge0$, then $a+b\ge0$, so
$|a+b|=a+b=|a|+|b|$.
\item % (b)
If $a\le0$ and $b\le0$, then $a+b\le0$, so
$|a+b|=-a+(-b)=|a|+|b|$.
\item % (c)
 If $a \ge 0$ and $b \le 0$, then $a+b=|a|-|b|$.
\item % (d)
 If $a \le 0$  and $b  \ge 0$, then $a+b=-|a|+|b|$.
\end{alist}
Eq.~\ref{eq:1.1.3}
holds in   cases {\bf (c)} and {\bf (d)}, since
\begin{equation}
|a+b|=
\begin{cases}
|a|-|b|& 	ext{ if } |a| \ge |b|,\\
|b|-|a|& 	ext{ if } |b| \ge |a|.
\end{cases}
	ag*{
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $a$ and $b$ are any two real numbers", "statement": "Premise:\n\u2022 a and b are real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u211d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a b : \u211d)' perfectly captures that a and b are real numbers, as \u211d represents the real numbers in Lean"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "If $a\\ge0$ and $b\\ge0$, then $a+b\\ge0$, so $|a+b|=a+b=|a|+|b|$.", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 a \u2265 0\n\u2022 b \u2265 0\nTherefore, we conclude:\n\u2022 |a+b| = |a| + |b| [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b : \u211d) \n  (h1 : a \u2265 0) \n  (h2 : b \u2265 0) : \n  |a + b| = |a| + |b| := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b : \u211d) \n  (h1 : a \u2265 0) \n  (h2 : b \u2265 0) : \n  |a + b| = |a| + |b| := by\n  have h_sum_nonneg : a + b \u2265 0 := by\n    linarith\n  \n  have h_abs_sum : |a + b| = a + b := by\n    rw [abs_of_nonneg h_sum_nonneg]\n    <;>\n    linarith\n  \n  have h_abs_a : |a| = a := by\n    rw [abs_of_nonneg h1]\n    <;>\n    linarith\n  \n  have h_abs_b : |b| = b := by\n    rw [abs_of_nonneg h2]\n    <;>\n    linarith\n  \n  have h_final : |a + b| = |a| + |b| := by\n    rw [h_abs_sum, h_abs_a, h_abs_b]\n    <;>\n    linarith\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly and completely captures all mathematical content from the natural language. The variable declarations (a, b as real numbers), the non-negativity assumptions (a \u2265 0, b \u2265 0), and the conclusion (|a+b| = |a| + |b|) are all faithfully represented. The logical structure of assumptions leading to a conclusion is preserved through the theorem format. Additional implementation details like imports, theorem naming, and proof placeholders do not affect the semantic correspondence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "If $a\\le0$ and $b\\le0$, then $a+b\\le0$, so $|a+b|=-a+(-b)=|a|+|b|$.", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 a \u2264 0\n\u2022 b \u2264 0\nTherefore, we conclude:\n\u2022 |a+b| = |a| + |b| [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b : \u211d) (h1 : a \u2264 0) (h2 : b \u2264 0) : |a + b| = |a| + |b| := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b : \u211d) (h1 : a \u2264 0) (h2 : b \u2264 0) : |a + b| = |a| + |b| := by\n  have h3 : a + b \u2264 0 := by\n    -- Prove that a + b \u2264 0 using the given inequalities a \u2264 0 and b \u2264 0\n    linarith\n  \n  have h4 : |a + b| = -(a + b) := by\n    -- Since a + b \u2264 0, we have |a + b| = -(a + b)\n    rw [abs_of_nonpos h3]\n    <;> linarith\n  \n  have h5 : |a| = -a := by\n    -- Since a \u2264 0, we have |a| = -a\n    rw [abs_of_nonpos h1]\n    <;> linarith\n  \n  have h6 : |b| = -b := by\n    -- Since b \u2264 0, we have |b| = -b\n    rw [abs_of_nonpos h2]\n    <;> linarith\n  \n  have h7 : |a| + |b| = -(a + b) := by\n    -- Substitute |a| and |b| with -a and -b respectively and simplify\n    rw [h5, h6]\n    <;> ring_nf\n    <;> linarith\n  \n  have h8 : |a + b| = |a| + |b| := by\n    -- Substitute |a + b| and |a| + |b| with their simplified forms and conclude the proof\n    linarith\n  \n  exact h8", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The variable declarations (a b : \u211d) correspond to 'a and b are real numbers', the hypotheses (h1 : a \u2264 0) and (h2 : b \u2264 0) capture the assumptions, and the goal |a + b| = |a| + |b| matches the conclusion exactly. The theorem structure appropriately represents the logical flow from premises to conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "If $a \\ge 0$ and $b \\le 0$, then $a+b=|a|-|b|$.", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 a \u2265 0\n\u2022 b \u2264 0\nTherefore, we conclude:\n\u2022 a + b = |a| - |b| [l3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b : \u211d)\n  (tc_1 : a \u2265 0 \u2227 b \u2264 0) :\n  a + b = |a| - |b| := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b : \u211d)\n  (tc_1 : a \u2265 0 \u2227 b \u2264 0) :\n  a + b = |a| - |b| := by\n  have h_abs_a : |a| = a := by\n    have h\u2081 : a \u2265 0 := tc_1.1\n    rw [abs_of_nonneg h\u2081]\n    <;>\n    linarith\n  \n  have h_abs_b : |b| = -b := by\n    have h\u2082 : b \u2264 0 := tc_1.2\n    rw [abs_of_nonpos h\u2082]\n    <;>\n    linarith\n  \n  have h_main : a + b = |a| - |b| := by\n    rw [h_abs_a, h_abs_b]\n    <;>\n    ring_nf\n    <;>\n    linarith\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly specify a and b as real numbers in both versions", "The assumptions are logically equivalent - natural language lists them separately while Lean combines them with conjunction, which is standard practice", "The conclusion a + b = |a| - |b| is identical in both mathematical notation and semantic meaning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "If $a \\le 0$  and $b  \\ge 0$, then $a+b=-|a|+|b|$.", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 a \u2264 0\n\u2022 b \u2265 0\nTherefore, we conclude:\n\u2022 a + b = -|a| + |b| [l4].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a b : \u211d)\n  (h_a : a \u2264 0)\n  (h_b : b \u2265 0)\n  (tc_1 : \u211d) : \n  a + b = -|a| + |b| := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a b : \u211d)\n  (h_a : a \u2264 0)\n  (h_b : b \u2265 0)\n  (tc_1 : \u211d) : \n  a + b = -|a| + |b| := by\n  have h_abs_a : |a| = -a := by\n    rw [abs_of_nonpos h_a]\n    <;> linarith\n  \n  have h_abs_b : |b| = b := by\n    rw [abs_of_nonneg h_b]\n  \n  have h_main : a + b = -|a| + |b| := by\n    rw [h_abs_a, h_abs_b]\n    <;> ring_nf\n    <;> linarith\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The natural language suggests tc_1 is a label/reference for the type constraint that a,b are reals, but Lean treats tc_1 as an unused separate real number variable", "The constraint a \u2264 0 is correctly captured as hypothesis h_a", "The constraint b \u2265 0 is correctly captured as hypothesis h_b", "The conclusion a + b = -|a| + |b| is perfectly represented in both versions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "|a+b|= |a|-|b| if |a| \\ge |b|,", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 (a \u2265 0 and b \u2264 0) or (a \u2264 0 and b \u2265 0)\n\u2022 |a| \u2265 |b|\n\u2022 If a \u2265 0 and b \u2264 0, then a + b = |a| - |b| [l3]\n\u2022 If a \u2264 0 and b \u2265 0, then a + b = -|a| + |b| [l4]\nTherefore, we conclude:\n\u2022 |a+b| = |a| - |b| [l5].", "dependencies": ["tc_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b : \u211d)\n  (h_sign : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0))\n  (h_abs : |a| \u2265 |b|)\n  (l3 : a \u2265 0 \u2227 b \u2264 0 \u2192 a + b = |a| - |b|)\n  (l4 : a \u2264 0 \u2227 b \u2265 0 \u2192 a + b = -|a| + |b|) :\n  |a + b| = |a| - |b| := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b : \u211d)\n  (h_sign : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0))\n  (h_abs : |a| \u2265 |b|)\n  (l3 : a \u2265 0 \u2227 b \u2264 0 \u2192 a + b = |a| - |b|)\n  (l4 : a \u2264 0 \u2227 b \u2265 0 \u2192 a + b = -|a| + |b|) :\n  |a + b| = |a| - |b| := by\n  have h_main : |a + b| = |a| - |b| := by\n    cases h_sign with\n    | inl h =>\n      -- Case: a \u2265 0 and b \u2264 0\n      have h\u2081 : a + b = |a| - |b| := l3 h\n      have h\u2082 : a + b \u2265 0 := by\n        -- Prove that a + b \u2265 0 using |a| \u2265 |b|\n        have h\u2083 : |a| - |b| \u2265 0 := by linarith\n        linarith\n      -- Calculate |a + b|\n      have h\u2083 : |a + b| = a + b := by\n        rw [abs_of_nonneg h\u2082]\n      rw [h\u2083]\n      linarith\n    | inr h =>\n      -- Case: a \u2264 0 and b \u2265 0\n      have h\u2081 : a + b = -|a| + |b| := l4 h\n      have h\u2082 : a + b \u2264 0 := by\n        -- Prove that a + b \u2264 0 using |a| \u2265 |b|\n        have h\u2083 : -|a| + |b| \u2264 0 := by\n          have h\u2084 : |a| \u2265 |b| := h_abs\n          linarith [abs_nonneg a, abs_nonneg b]\n        linarith\n      -- Calculate |a + b|\n      have h\u2083 : |a + b| = -(a + b) := by\n        rw [abs_of_nonpos h\u2082]\n        <;> linarith\n      rw [h\u2083]\n      have h\u2084 : -(a + b) = |a| - |b| := by\n        have h\u2085 : a + b = -|a| + |b| := h\u2081\n        have h\u2086 : -(a + b) = |a| - |b| := by\n          linarith [abs_nonneg a, abs_nonneg b]\n        exact h\u2086\n      linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components from the natural language: variable types (real numbers), the disjunctive sign condition, the absolute value inequality, both conditional statements l3 and l4, and the final conclusion. All logical operators, mathematical expressions, and implications are accurately translated. The theorem statement is mathematically sound and the formalization preserves the complete logical structure of the natural language premise."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "|a+b|= |b|-|a| if |b| \\ge |a|.", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 (a \u2265 0 and b \u2264 0) or (a \u2264 0 and b \u2265 0)\n\u2022 |b| \u2265 |a|\n\u2022 If a \u2265 0 and b \u2264 0, then a + b = |a| - |b| [l3]\n\u2022 If a \u2264 0 and b \u2265 0, then a + b = -|a| + |b| [l4]\nTherefore, we conclude:\n\u2022 |a+b| = |b| - |a| [l6].", "dependencies": ["tc_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b : \u211d)\n  (h_or : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0))\n  (h_ineq : |b| \u2265 |a|)\n  (h_add : (a \u2265 0 \u2227 b \u2264 0 \u2227 a + b = |a| - |b|) \u2228 \n           (a \u2264 0 \u2227 b \u2265 0 \u2227 a + b = -|a| + |b|)) :\n  |a + b| = |b| - |a| := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b : \u211d)\n  (h_or : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0))\n  (h_ineq : |b| \u2265 |a|)\n  (h_add : (a \u2265 0 \u2227 b \u2264 0 \u2227 a + b = |a| - |b|) \u2228 \n           (a \u2264 0 \u2227 b \u2265 0 \u2227 a + b = -|a| + |b|)) :\n  |a + b| = |b| - |a| := by\n  have h_main : |a + b| = |b| - |a| := by\n    cases h_add with\n    | inl h_add_case =>\n      -- Case 1: a \u2265 0, b \u2264 0, and a + b = |a| - |b|\n      have h\u2081 : a \u2265 0 := h_add_case.1\n      have h\u2082 : b \u2264 0 := h_add_case.2.1\n      have h\u2083 : a + b = |a| - |b| := h_add_case.2.2\n      have h\u2084 : a + b \u2264 0 := by\n        -- Prove that a + b \u2264 0 using |b| \u2265 |a|\n        have h\u2084\u2081 : |a| - |b| \u2264 0 := by\n          -- Since |b| \u2265 |a|, |a| - |b| \u2264 0\n          linarith [abs_nonneg a, abs_nonneg b]\n        linarith\n      -- Compute |a + b| = -(a + b) = |b| - |a|\n      have h\u2085 : |a + b| = -(a + b) := by\n        rw [abs_of_nonpos h\u2084]\n        <;> linarith\n      have h\u2086 : -(a + b) = |b| - |a| := by\n        -- Use the given a + b = |a| - |b|\n        have h\u2086\u2081 : a + b = |a| - |b| := h\u2083\n        have h\u2086\u2082 : -(a + b) = -(|a| - |b|) := by linarith\n        have h\u2086\u2083 : -(|a| - |b|) = |b| - |a| := by ring\n        linarith\n      rw [h\u2085, h\u2086]\n    | inr h_add_case =>\n      -- Case 2: a \u2264 0, b \u2265 0, and a + b = -|a| + |b|\n      have h\u2081 : a \u2264 0 := h_add_case.1\n      have h\u2082 : b \u2265 0 := h_add_case.2.1\n      have h\u2083 : a + b = -|a| + |b| := h_add_case.2.2\n      have h\u2084 : a + b \u2265 0 := by\n        -- Prove that a + b \u2265 0 using |b| \u2265 |a|\n        have h\u2084\u2081 : -|a| + |b| \u2265 0 := by\n          -- Since |b| \u2265 |a|, -|a| + |b| \u2265 0\n          linarith [abs_nonneg a, abs_nonneg b]\n        linarith\n      -- Compute |a + b| = a + b = |b| - |a|\n      have h\u2085 : |a + b| = a + b := by\n        rw [abs_of_nonneg h\u2084]\n        <;> linarith\n      have h\u2086 : a + b = |b| - |a| := by\n        -- Use the given a + b = -|a| + |b|\n        have h\u2086\u2081 : a + b = -|a| + |b| := h\u2083\n        have h\u2086\u2082 : -|a| + |b| = |b| - |a| := by ring\n        linarith\n      rw [h\u2085, h\u2086]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations correctly capture that a and b are real numbers.", "The disjunctive case condition perfectly matches the natural language logical structure.", "The magnitude constraint |b| \u2265 |a| is exactly preserved.", "The conditional statements l3 and l4 are incorrectly formalized. The natural language presents them as implications (if-then statements), but the Lean version treats them as direct assertions in a disjunction. This changes the logical meaning from 'if conditions hold then equations follow' to 'one of these cases with equations already satisfied holds'.", "The conclusion |a+b| = |b| - |a| is perfectly captured."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations correctly capture that a and b are real numbers.', 'The disjunctive case condition perfectly matches the natural language logical structure.', 'The magnitude constraint |b| \u2265 |a| is exactly preserved.', \"The conditional statements l3 and l4 are incorrectly formalized. The natural language presents them as implications (if-then statements), but the Lean version treats them as direct assertions in a disjunction. This changes the logical meaning from 'if conditions hold then equations follow' to 'one of these cases with equations already satisfied holds'.\", 'The conclusion |a+b| = |b| - |a| is perfectly captured.']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Eq. |a+b| <= |a|+|b| holds in cases (c) and (d), since |a+b|= ...", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 (a \u2265 0 and b \u2264 0) or (a \u2264 0 and b \u2265 0)\n\u2022 If |a| \u2265 |b|, then |a+b| = |a| - |b| [l5]\n\u2022 If |b| \u2265 |a|, then |a+b| = |b| - |a| [l6]\nTherefore, we conclude:\n\u2022 |a+b| \u2264 |a| + |b| [l7].", "dependencies": ["tc_1", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a b : \u211d)\n  (h_disj : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0))\n  (l5 : |a| \u2265 |b| \u2192 |a + b| = |a| - |b|)\n  (l6 : |b| \u2265 |a| \u2192 |a + b| = |b| - |a|) :\n  |a + b| \u2264 |a| + |b| := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a b : \u211d)\n  (h_disj : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0))\n  (l5 : |a| \u2265 |b| \u2192 |a + b| = |a| - |b|)\n  (l6 : |b| \u2265 |a| \u2192 |a + b| = |b| - |a|) :\n  |a + b| \u2264 |a| + |b| := by\n  have h_main : |a + b| \u2264 |a| + |b| := by\n    by_cases h : |a| \u2265 |b|\n    \u00b7 -- Case 1: |a| \u2265 |b|\n      have h\u2081 : |a + b| = |a| - |b| := l5 h\n      rw [h\u2081]\n      -- Prove |a| - |b| \u2264 |a| + |b|\n      have h\u2082 : |a| - |b| \u2264 |a| + |b| := by\n        -- Since |b| \u2265 0, -|b| \u2264 |b|\n        have h\u2083 : 0 \u2264 |b| := abs_nonneg b\n        linarith [abs_nonneg a]\n      exact h\u2082\n    \u00b7 -- Case 2: \u00ac(|a| \u2265 |b|), which implies |b| \u2265 |a|\n      have h\u2081 : |b| \u2265 |a| := by\n        -- Use the fact that if \u00ac(|a| \u2265 |b|), then |b| > |a|\n        have h\u2082 : \u00ac(|a| \u2265 |b|) := h\n        have h\u2083 : |b| \u2265 |a| := by\n          by_contra h\u2084\n          -- If |b| < |a|, then |a| \u2265 |b|\n          have h\u2085 : |a| > |b| := by\n            -- Since |b| < |a|, we have |a| > |b|\n            have h\u2086 : \u00ac(|b| \u2265 |a|) := h\u2084\n            have h\u2087 : |a| > |b| := by\n              by_cases h\u2088 : |a| \u2265 |b|\n              \u00b7 exfalso\n                -- If |a| \u2265 |b|, this contradicts h\u2082\n                exact h\u2082 h\u2088\n              \u00b7 -- If \u00ac(|a| \u2265 |b|), then |a| < |b|\n                have h\u2089 : |a| < |b| := by\n                  by_contra h\u2081\u2080\n                  -- If |a| \u2265 |b|, this contradicts h\u2088\n                  have h\u2081\u2081 : |a| \u2265 |b| := by linarith\n                  exact h\u2088 h\u2081\u2081\n                linarith\n            exact h\u2087\n          -- If |a| > |b|, then |a| \u2265 |b|\n          have h\u2086 : |a| \u2265 |b| := by linarith\n          exact h\u2082 h\u2086\n        exact h\u2083\n      -- Use l6 to get |a + b| = |b| - |a|\n      have h\u2082 : |a + b| = |b| - |a| := l6 h\u2081\n      rw [h\u2082]\n      -- Prove |b| - |a| \u2264 |a| + |b|\n      have h\u2083 : |b| - |a| \u2264 |a| + |b| := by\n        -- Since |a| \u2265 0, -|a| \u2264 |a|\n        have h\u2084 : 0 \u2264 |a| := abs_nonneg a\n        linarith [abs_nonneg b]\n      exact h\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are correctly translated from natural language to Lean type annotations", "The disjunctive condition is perfectly captured using Lean's logical operators \u2227 and \u2228", "The first conditional statement l5 is correctly formalized as an implication with identical mathematical content", "The second conditional statement l6 is correctly formalized as an implication with identical mathematical content", "The conclusion l7 is perfectly translated as the goal of the theorem", "The overall theorem structure correctly captures the logical flow from assumptions to conclusion as presented in the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "There are four possibilities:\n(a) If $a\\ge0$ and $b\\ge0$, then $a+b\\ge0$, so $|a+b|=a+b=|a|+|b|$.\n(b) If $a\\le0$ and $b\\le0$, then $a+b\\le0$, so $|a+b|=-a+(-b)=|a|+|b|$.\n(c) If $a \\ge 0$ and $b \\le 0$, then $a+b=|a|-|b|$.\n(d) If $a \\le 0$  and $b  \\ge 0$, then $a+b=-|a|+|b|$.\nEq. |a+b| <= |a|+|b| holds in   cases (c) and (d), since |a+b|= ...", "statement": "We assume:\n\u2022 a and b are real numbers [tc_1]\n\u2022 If a \u2265 0 and b \u2265 0, then |a+b| = |a|+|b| [l1]\n\u2022 If a \u2264 0 and b \u2264 0, then |a+b| = |a|+|b| [l2]\n\u2022 If (a \u2265 0 and b \u2264 0) or (a \u2264 0 and b \u2265 0), then |a+b| \u2264 |a|+|b| [l7]\nTherefore, we conclude:\n\u2022 |a+b| \u2264 |a| + |b| [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b : \u211d) \n  (l1 : a \u2265 0 \u2192 b \u2265 0 \u2192 |a + b| = |a| + |b|)\n  (l2 : a \u2264 0 \u2192 b \u2264 0 \u2192 |a + b| = |a| + |b|)\n  (l7 : ((a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0)) \u2192 |a + b| \u2264 |a| + |b|) :\n  |a + b| \u2264 |a| + |b| := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b : \u211d) \n  (l1 : a \u2265 0 \u2192 b \u2265 0 \u2192 |a + b| = |a| + |b|)\n  (l2 : a \u2264 0 \u2192 b \u2264 0 \u2192 |a + b| = |a| + |b|)\n  (l7 : ((a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0)) \u2192 |a + b| \u2264 |a| + |b|) :\n  |a + b| \u2264 |a| + |b| := by\n  have h_main : |a + b| \u2264 |a| + |b| := by\n    by_cases h : a \u2265 0\n    \u00b7 -- Case: a \u2265 0\n      by_cases h' : b \u2265 0\n      \u00b7 -- Subcase: a \u2265 0 and b \u2265 0\n        have h\u2081 : |a + b| = |a| + |b| := l1 h h'\n        have h\u2082 : |a + b| \u2264 |a| + |b| := by linarith\n        exact h\u2082\n      \u00b7 -- Subcase: a \u2265 0 and b < 0\n        have h\u2081 : b \u2264 0 := by\n          by_contra h\u2081\n          -- If b > 0, then b \u2265 0, which contradicts h'\n          have h\u2082 : b > 0 := by linarith\n          have h\u2083 : b \u2265 0 := by linarith\n          contradiction\n        have h\u2082 : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0) := Or.inl \u27e8h, h\u2081\u27e9\n        have h\u2083 : |a + b| \u2264 |a| + |b| := l7 h\u2082\n        exact h\u2083\n    \u00b7 -- Case: a < 0\n      by_cases h' : b \u2264 0\n      \u00b7 -- Subcase: a < 0 and b \u2264 0\n        have h\u2081 : a \u2264 0 := by linarith\n        have h\u2082 : |a + b| = |a| + |b| := l2 h\u2081 h'\n        have h\u2083 : |a + b| \u2264 |a| + |b| := by linarith\n        exact h\u2083\n      \u00b7 -- Subcase: a < 0 and b > 0\n        have h\u2081 : b \u2265 0 := by\n          by_contra h\u2081\n          -- If b < 0, then b \u2264 0, which contradicts h'\n          have h\u2082 : b < 0 := by linarith\n          have h\u2083 : b \u2264 0 := by linarith\n          contradiction\n        have h\u2082 : a \u2264 0 := by linarith\n        have h\u2083 : (a \u2265 0 \u2227 b \u2264 0) \u2228 (a \u2264 0 \u2227 b \u2265 0) := Or.inr \u27e8h\u2082, h\u2081\u27e9\n        have h\u2084 : |a + b| \u2264 |a| + |b| := l7 h\u2083\n        exact h\u2084\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly specify a and b as real numbers using appropriate Lean notation", "Assumption l1 is correctly formalized using curried implication, which is logically equivalent to the natural language conditional with conjunction", "Assumption l2 follows the same correct pattern as l1, with appropriate inequality direction", "Assumption l7 correctly captures the disjunctive condition using Lean's logical operators \u2227 and \u2228", "The conclusion correctly states the triangle inequality that follows from the given assumptions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    