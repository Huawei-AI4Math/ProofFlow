
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $f(z) = \frac{1}{(z-1)(z-3)}$. If the Laurent series for $f(z)$ is centered at $z_0=1$ and is valid for the annulus $0 < |z-1| < 2$, then the series is given by $f(z) = -\frac{1}{2(z-1)} - \sum_{n=0}^{\infty} \frac{(z-1)^n}{2^{n+2}}$.

Proof: First, we perform a partial fraction decomposition of $f(z)$ to get $f(z) = -\frac{1}{2(z-1)} + \frac{1}{2(z-3)}$. For the second term, $\frac{1}{2(z-3)}$, we manipulate it to be centered at $z=1$: $\frac{1}{2(z-3)} = \frac{1}{2((z-1)-2)} = -\frac{1}{4(1 - \frac{z-1}{2})}$. Since the series must be valid for $|z-1|<2$, we have $|\frac{z-1}{2}|<1$, allowing the use of the geometric series formula, which gives $-\frac{1}{4} \sum_{n=0}^{\infty} (\frac{z-1}{2})^n = -\sum_{n=0}^{\infty} \frac{(z-1)^n}{2^{n+2}}$. Finally, combining the first term from the partial fraction decomposition with the series expansion of the second term gives the complete Laurent series: $f(z) = -\frac{1}{2(z-1)} - \sum_{n=0}^{\infty} \frac{(z-1)^n}{2^{n+2}}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f(z) = \\frac{1}{(z-1)(z-3)}$.", "statement": "Premise:\n\u2022 Let $f$ be a complex function defined as $f(z) = \\frac{1}{(z-1)(z-3)}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (f : \u2102 \u2192 \u2102)\n(tc_1 : \u2200 z, f z = 1 / ((z - 1) * (z - 3)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that f is a complex function with the given formula. The type declaration `f : \u2102 \u2192 \u2102` establishes f as a complex function, and `tc_1` provides the exact formula from the natural language.", "The Lean formalization uses `\u2200 z` which suggests f is defined for ALL complex numbers z, but the natural language conclusion explicitly states that f is NOT defined at z = 1 and z = 3. This is a major logical inconsistency since the Lean version doesn't capture the domain restriction that is central to the mathematical meaning."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that f is a complex function with the given formula. The type declaration `f : \u2102 \u2192 \u2102` establishes f as a complex function, and `tc_1` provides the exact formula from the natural language.', \"The Lean formalization uses `\u2200 z` which suggests f is defined for ALL complex numbers z, but the natural language conclusion explicitly states that f is NOT defined at z = 1 and z = 3. This is a major logical inconsistency since the Lean version doesn't capture the domain restriction that is central to the mathematical meaning.\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If the Laurent series for $f(z)$ is centered at $z_0=1$ and is valid for the annulus $0 < |z-1| < 2$", "statement": "Premise:\n\u2022 The Laurent series for the function $f(z) = \\frac{1}{(z-1)(z-3)}$ [tc_1] is centered at $z_0 = 1$ and is valid for the annulus $A = \\{z \\in \\mathbb{C} | 0 < |z-1| < 2\\}$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 \n  (f : \u2102 \u2192 \u2102)\n  (A : Set \u2102)\n  (a : \u2115 \u2192 \u2102) :\n  (\u2200 z, f z = 1 / ((z - 1) * (z - 3))) \u2192\n  (A = {z : \u2102 | 0 < Complex.abs (z - 1) \u2227 Complex.abs (z - 1) < 2}) \u2192\n  (\u2200 z \u2208 A, f z = a 0 / (z - 1) + \u2211' n : \u2115, a (n + 1) * (z - 1) ^ n) \u2192\n  (a 0 = -1/2) \u2192\n  (\u2200 n : \u2115, a (n + 1) = -1 / 2^(n + 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean condition `(\u2200 z, f z = 1 / ((z - 1) * (z - 3)))` perfectly matches the natural language condition $f(z) = \\frac{1}{(z-1)(z-3)}$", "The Lean condition defining set A as `{z : \u2102 | 0 < Complex.abs (z - 1) \u2227 Complex.abs (z - 1) < 2}` perfectly matches the natural language annulus $A = \\{z \\in \\mathbb{C} | 0 < |z-1| < 2\\}$", "The natural language mentions the Laurent series is centered at $z_0 = 1$, but this condition is not explicitly present in the Lean formalization. While the centering can be inferred from the Laurent series form `(z-1)^n`, it's not explicitly stated as a condition", "The natural language conclusion is about existence and convergence of the Laurent series in the annulus, but the Lean formalization assumes the Laurent series representation exists (as a condition) and instead proves specific coefficient values. This is a major shift from proving existence to proving specific coefficients", "The Lean proposition `(\u2200 n : \u2115, a (n + 1) = -1 / 2^(n + 2))` provides specific coefficient values that are not mentioned or concluded in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean condition `(\u2200 z, f z = 1 / ((z - 1) * (z - 3)))` perfectly matches the natural language condition $f(z) = \\\\frac{1}{(z-1)(z-3)}$', 'The Lean condition defining set A as `{z : \u2102 | 0 < Complex.abs (z - 1) \u2227 Complex.abs (z - 1) < 2}` perfectly matches the natural language annulus $A = \\\\{z \\\\in \\\\mathbb{C} | 0 < |z-1| < 2\\\\}$', \"The natural language mentions the Laurent series is centered at $z_0 = 1$, but this condition is not explicitly present in the Lean formalization. While the centering can be inferred from the Laurent series form `(z-1)^n`, it's not explicitly stated as a condition\", 'The natural language conclusion is about existence and convergence of the Laurent series in the annulus, but the Lean formalization assumes the Laurent series representation exists (as a condition) and instead proves specific coefficient values. This is a major shift from proving existence to proving specific coefficients', 'The Lean proposition `(\u2200 n : \u2115, a (n + 1) = -1 / 2^(n + 2))` provides specific coefficient values that are not mentioned or concluded in the natural language statement']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, we perform a partial fraction decomposition of $f(z)$ to get $f(z) = -\\frac{1}{2(z-1)} + \\frac{1}{2(z-3)}$.", "statement": "We assume:\n\u2022 $f(z) = \\frac{1}{(z-1)(z-3)}$ [tc_1].\nTherefore, we conclude:\n\u2022 The partial fraction decomposition of $f(z)$ is $f(z) = -\\frac{1}{2(z-1)} + \\frac{1}{2(z-3)}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 z, f z = 1 / ((z - 1) * (z - 3))) :\n  \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 z, f z = 1 / ((z - 1) * (z - 3))) :\n  \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n  have h1 : False := by\n    have h2 : f (1 : \u2102) = (0 : \u2102) := by\n      rw [tc_1]\n      norm_num [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;>\n      simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_zero]\n      <;>\n      norm_num\n      <;>\n      simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;>\n      norm_num\n      <;>\n      linarith\n    \n    have h3 : (-1 : \u2102) / (2 * ((1 : \u2102) - 1)) + 1 / (2 * ((1 : \u2102) - 3)) = (-1 / 4 : \u2102) := by\n      norm_num [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;>\n      simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_zero]\n      <;>\n      norm_num\n      <;>\n      simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;>\n      norm_num\n      <;>\n      linarith\n    \n    have h4 : f (1 : \u2102) = (-1 : \u2102) / (2 * ((1 : \u2102) - 1)) + 1 / (2 * ((1 : \u2102) - 3)) := by\n      have h5 : \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n        intro z\n        -- This is the original goal, which we are assuming to derive a contradiction.\n        -- In reality, this is false, so we will derive a contradiction from it.\n        have h6 := tc_1 z\n        have h7 := tc_1 (1 : \u2102)\n        have h8 := tc_1 (3 : \u2102)\n        simp [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq] at h6 h7 h8 \u22a2\n        <;>\n        (try norm_num at h6 h7 h8 \u22a2) <;>\n        (try simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]) <;>\n        (try norm_num) <;>\n        (try linarith)\n        <;>\n        (try\n          {\n            field_simp [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq] at *\n            <;>\n            ring_nf at *\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n      exact h5 (1 : \u2102)\n    \n    have h5 : (0 : \u2102) = (-1 / 4 : \u2102) := by\n      calc\n        (0 : \u2102) = f (1 : \u2102) := by rw [h2]\n        _ = (-1 : \u2102) / (2 * ((1 : \u2102) - 1)) + 1 / (2 * ((1 : \u2102) - 3)) := by rw [h4]\n        _ = (-1 / 4 : \u2102) := by rw [h3]\n    \n    norm_num [Complex.ext_iff] at h5\n    <;>\n    (try contradiction) <;>\n    (try linarith)\n  \n  have h2 : \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n    exfalso\n    exact h1\n  \n  exact h2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 37, "column": 69, "endLine": 96, "endColumn": 12, "data": "unsolved goals\nf : \u2102 \u2192 \u2102\nz : \u2102\ntc_1 :\n  \u2200 (z : \u2102),\n    (f z).re =\n        (z.re - 3) / ((z.re - 3) * (z.re - 3) + z.im * z.im) * ((z.re - 1) / ((z.re - 1) * (z.re - 1) + z.im * z.im)) -\n          -z.im / ((z.re - 3) * (z.re - 3) + z.im * z.im) * (-z.im / ((z.re - 1) * (z.re - 1) + z.im * z.im)) \u2227\n      (f z).im =\n        (z.re - 3) / ((z.re - 3) * (z.re - 3) + z.im * z.im) * (-z.im / ((z.re - 1) * (z.re - 1) + z.im * z.im)) +\n          -z.im / ((z.re - 3) * (z.re - 3) + z.im * z.im) * ((z.re - 1) / ((z.re - 1) * (z.re - 1) + z.im * z.im))\nh3 : (1 - 3)\u207b\u00b9 * 2\u207b\u00b9 = -1 / 4\n\u22a2 (z.re - 3) / ((z.re - 3) * (z.re - 3) + z.im * z.im) * ((z.re - 1) / ((z.re - 1) * (z.re - 1) + z.im * z.im)) -\n        -z.im / ((z.re - 3) * (z.re - 3) + z.im * z.im) * (-z.im / ((z.re - 1) * (z.re - 1) + z.im * z.im)) =\n      -(2 * (z.re - 1)) / (2 * (z.re - 1) * (2 * (z.re - 1)) + 2 * z.im * (2 * z.im)) +\n        (z.re - 3) / ((z.re - 3) * (z.re - 3) + z.im * z.im) * (1 / 2) \u2227\n    (z.re - 3) / ((z.re - 3) * (z.re - 3) + z.im * z.im) * (-z.im / ((z.re - 1) * (z.re - 1) + z.im * z.im)) +\n        -z.im / ((z.re - 3) * (z.re - 3) + z.im * z.im) * ((z.re - 1) / ((z.re - 1) * (z.re - 1) + z.im * z.im)) =\n      -(-(2 * z.im) / (2 * (z.re - 1) * (2 * (z.re - 1)) + 2 * z.im * (2 * z.im))) +\n        -z.im / ((z.re - 3) * (z.re - 3) + z.im * z.im) * (1 / 2)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language statement. The function definition via constraint (tc_1), explicit domain specification (\u2102 \u2192 \u2102), and universal quantification are appropriate mathematical formalizations that don't change the core meaning. The partial fraction decomposition equation is exactly preserved in the conclusion.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (f : \u2102 \u2192 \u2102)\n  (tc_1 : \u2200 z, f z = 1 / ((z - 1) * (z - 3))) :\n  \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n  have h : False := by\n    have h\u2081 : f 1 = 0 := by\n      have h\u2082 : f 1 = 1 / ((1 - 1 : \u2102) * (1 - 3 : \u2102)) := by\n        rw [tc_1]\n        <;> simp [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n        <;> norm_num\n      rw [h\u2082]\n      simp [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;> norm_num\n      <;> simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;> norm_num\n    \n    have h\u2082 : (-1 : \u2102) / (2 * (1 - 1 : \u2102)) + 1 / (2 * (1 - 3 : \u2102)) = (-1 / 4 : \u2102) := by\n      norm_num [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;>\n      simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;> norm_num\n      <;>\n      simp_all [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq]\n      <;> norm_num\n    \n    have h\u2083 : (0 : \u2102) \u2260 (-1 / 4 : \u2102) := by\n      intro h\u2083\n      simp [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq] at h\u2083\n      <;> norm_num at h\u2083 <;>\n        (try contradiction) <;>\n        (try linarith)\n    \n    -- Assume the original statement is true and derive a contradiction\n    have h\u2084 : False := by\n      -- Use the original statement to compute f(1)\n      have h\u2085 : \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n        intro z\n        exfalso\n        -- Use the contradiction to prove anything\n        have h\u2086 : False := by\n          have h\u2087 : f 1 = 0 := h\u2081\n          have h\u2088 : (-1 : \u2102) / (2 * (1 - 1 : \u2102)) + 1 / (2 * (1 - 3 : \u2102)) = (-1 / 4 : \u2102) := h\u2082\n          simp [Complex.ext_iff, Complex.div_re, Complex.div_im, Complex.normSq] at h\u2087 h\u2088 \u22a2\n          <;> norm_num at h\u2087 h\u2088 \u22a2 <;>\n            (try contradiction) <;>\n            (try linarith)\n        exact h\u2086\n      have h\u2086 : f 1 = (-1 / 4 : \u2102) := by\n        have h\u2087 := h\u2085 1\n        calc\n          f 1 = -1 / (2 * (1 - 1 : \u2102)) + 1 / (2 * (1 - 3 : \u2102)) := by simpa using h\u2087\n          _ = (-1 / 4 : \u2102) := by rw [h\u2082]\n      have h\u2087 : f 1 = 0 := h\u2081\n      have h\u2088 : (0 : \u2102) \u2260 (-1 / 4 : \u2102) := h\u2083\n      have h\u2089 : (0 : \u2102) = (-1 / 4 : \u2102) := by\n        calc\n          (0 : \u2102) = f 1 := by rw [h\u2087]\n          _ = (-1 / 4 : \u2102) := h\u2086\n      exact h\u2088 h\u2089\n    exact h\u2084\n  \n  have h\u2082 : \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n    exfalso\n    exact h\n  \n  exact h\u2082"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For the second term, $\\frac{1}{2(z-3)}$, we manipulate it to be centered at $z=1$: $\\frac{1}{2(z-3)} = \\frac{1}{2((z-1)-2)} = -\\frac{1}{4(1 - \\frac{z-1}{2})}$.", "statement": "We assume:\n\u2022 (general algebra)\nTherefore, we conclude:\n\u2022 The expression $\\frac{1}{2(z-3)}$ can be rewritten as $-\\frac{1}{4(1 - \\frac{z-1}{2})}$ [l2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (z : \u2102) (hz : z \u2260 1 \u2227 z \u2260 3) :\n  1 / (2 * (z - 3)) = -(1 / (4 * (1 - (z - 1) / 2))) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (z : \u2102) (hz : z \u2260 1 \u2227 z \u2260 3) :\n  1 / (2 * (z - 3)) = -(1 / (4 * (1 - (z - 1) / 2))) := by\n  have h_denom : 4 * (1 - (z - 1) / 2 : \u2102) = -2 * (z - 3) := by\n    ring_nf\n    <;> simp [Complex.ext_iff, pow_two]\n    <;> norm_num\n    <;>\n    (try\n      {\n        constructor <;>\n        (try ring_nf at * <;>\n          simp_all [Complex.ext_iff, pow_two] <;>\n          norm_num <;>\n          linarith)\n      })\n    <;>\n    (try\n      {\n        simp_all [Complex.ext_iff, pow_two]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        ring_nf at *\n        <;> simp_all [Complex.ext_iff, pow_two]\n        <;> norm_num\n        <;> linarith\n      })\n  \n  have h_main : -(1 / (4 * (1 - (z - 1) / 2 : \u2102))) = 1 / (2 * (z - 3)) := by\n    have h1 : z - 3 \u2260 0 := by\n      intro h\n      apply hz.2\n      rw [sub_eq_zero] at h\n      exact h\n    have h2 : 4 * (1 - (z - 1) / 2 : \u2102) \u2260 0 := by\n      rw [h_denom]\n      intro h\n      apply h1\n      simp [sub_eq_zero] at h \u22a2\n      <;>\n      (try simp_all [Complex.ext_iff, pow_two]) <;>\n      (try ring_nf at * <;>\n        simp_all [Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        (try constructor <;> linarith)) <;>\n      (try simp_all [Complex.ext_iff, pow_two]) <;>\n      (try ring_nf at * <;>\n        simp_all [Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        (try constructor <;> linarith))\n    have h3 : -2 * (z - 3) \u2260 0 := by\n      intro h\n      apply h1\n      simp [sub_eq_zero] at h \u22a2\n      <;>\n      (try simp_all [Complex.ext_iff, pow_two]) <;>\n      (try ring_nf at * <;>\n        simp_all [Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        (try constructor <;> linarith)) <;>\n      (try simp_all [Complex.ext_iff, pow_two]) <;>\n      (try ring_nf at * <;>\n        simp_all [Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        (try constructor <;> linarith))\n    calc\n      -(1 / (4 * (1 - (z - 1) / 2 : \u2102))) = -(1 / (-2 * (z - 3))) := by\n        rw [h_denom]\n        <;>\n        simp_all [Complex.ext_iff, pow_two]\n        <;>\n        ring_nf at *\n        <;>\n        simp_all [Complex.ext_iff, pow_two]\n        <;>\n        norm_num\n        <;>\n        (try constructor <;> linarith)\n      _ = 1 / (2 * (z - 3)) := by\n        have h4 : -2 * (z - 3) \u2260 0 := by\n          intro h\n          apply h1\n          simp [sub_eq_zero] at h \u22a2\n          <;>\n          (try simp_all [Complex.ext_iff, pow_two]) <;>\n          (try ring_nf at * <;>\n            simp_all [Complex.ext_iff, pow_two] <;>\n            norm_num <;>\n            (try constructor <;> linarith)) <;>\n          (try simp_all [Complex.ext_iff, pow_two]) <;>\n          (try ring_nf at * <;>\n            simp_all [Complex.ext_iff, pow_two] <;>\n            norm_num <;>\n            (try constructor <;> linarith))\n        -- Simplify the expression using field operations and properties of complex numbers\n        field_simp [h4, h1, sub_eq_zero, Complex.ext_iff, pow_two]\n        <;>\n        ring_nf at * <;>\n        simp_all [Complex.ext_iff, pow_two] <;>\n        norm_num <;>\n        (try constructor <;> linarith) <;>\n        (try {\n          simp_all [Complex.ext_iff, pow_two]\n          <;> norm_num\n          <;>\n          (try constructor <;> linarith)\n        })\n        <;>\n        (try {\n          ring_nf at *\n          <;> simp_all [Complex.ext_iff, pow_two]\n          <;> norm_num\n          <;>\n          (try constructor <;> linarith)\n        })\n  \n  have h_final : 1 / (2 * (z - 3)) = -(1 / (4 * (1 - (z - 1) / 2))) := by\n    rw [h_main]\n    <;>\n    (try simp_all [Complex.ext_iff, pow_two])\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try simp_all [Complex.ext_iff, pow_two])\n    <;>\n    (try norm_num)\n    <;>\n    (try linarith)\n  \n  rw [h_final]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical identity from the natural language. The additional constraints (z \u2260 1 \u2227 z \u2260 3) and explicit complex number typing are mathematically necessary details that enhance the formalization without contradicting the natural language statement. The core algebraic relationship is preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since the series must be valid for $|z-1|<2$, we have $|\\frac{z-1}{2}|<1$", "statement": "We assume:\n\u2022 The series is valid for the annulus where $|z-1| < 2$ [tc_2].\nTherefore, we conclude:\n\u2022 For $z$ in the annulus of convergence, $|\\frac{z-1}{2}| < 1$ [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (z : \u2102) \n  (h : Complex.abs (z - 1) < 2) :\n  Complex.abs ((z - 1) / 2) < 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (z : \u2102) \n  (h : Complex.abs (z - 1) < 2) :\n  Complex.abs ((z - 1) / 2) < 1 := by\n  have h\u2081 : Complex.abs ((z - 1) / 2) = Complex.abs (z - 1) / 2 := by\n    have h\u2082 : Complex.abs ((z - 1) / 2) = Complex.abs ((z - 1) * (1 / 2 : \u2102)) := by\n      norm_num [div_eq_mul_inv]\n      <;>\n      simp [Complex.ext_iff, Complex.abs, Complex.normSq, pow_two]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      field_simp [Real.sqrt_eq_iff_sq_eq]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith\n    rw [h\u2082]\n    have h\u2083 : Complex.abs ((z - 1) * (1 / 2 : \u2102)) = Complex.abs (z - 1) * Complex.abs (1 / 2 : \u2102) := by\n      rw [Complex.abs.map_mul]\n    rw [h\u2083]\n    have h\u2084 : Complex.abs (1 / 2 : \u2102) = 1 / 2 := by\n      simp [Complex.abs, Complex.normSq, pow_two]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      rw [Real.sqrt_eq_iff_sq_eq] <;>\n      norm_num\n    rw [h\u2084]\n    <;>\n    ring_nf\n    <;>\n    field_simp\n    <;>\n    ring_nf\n  \n  have h\u2082 : Complex.abs (z - 1) / 2 < 1 := by\n    have h\u2083 : Complex.abs (z - 1) < 2 := h\n    have h\u2084 : Complex.abs (z - 1) / 2 < 1 := by\n      linarith\n    exact h\u2084\n  \n  have h\u2083 : Complex.abs ((z - 1) / 2) < 1 := by\n    rw [h\u2081]\n    exact h\u2082\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption about the annulus |z-1| < 2 is correctly captured as Complex.abs (z - 1) < 2 in the hypothesis", "The conclusion about |(z-1)/2| < 1 is accurately represented as Complex.abs ((z - 1) / 2) < 1", "The logical implication structure from assumption to conclusion is properly maintained in the theorem formulation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "allowing the use of the geometric series formula, which gives $-\\frac{1}{4} \\sum_{n=0}^{\\infty} (\\frac{z-1}{2})^n = -\\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$.", "statement": "We assume:\n\u2022 For $z$ in the annulus of convergence, $|\\frac{z-1}{2}| < 1$ [l3].\n\u2022 The geometric series formula is $\\frac{1}{1-r} = \\sum_{n=0}^{\\infty} r^n$ for $|r|<1$.\nTherefore, we conclude:\n\u2022 $-\\frac{1}{4(1 - \\frac{z-1}{2})} = -\\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$ [l4].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (z : \u2102) \n  (h : Complex.abs ((z - 1) / 2) < 1)\n  (h_geom : \u2200 r : \u2102, Complex.abs r < 1 \u2192 (1 - r)\u207b\u00b9 = \u2211' n, r ^ n) :\n  -(1 / (4 * (1 - (z - 1) / 2))) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (z : \u2102) \n  (h : Complex.abs ((z - 1) / 2) < 1)\n  (h_geom : \u2200 r : \u2102, Complex.abs r < 1 \u2192 (1 - r)\u207b\u00b9 = \u2211' n, r ^ n) :\n  -(1 / (4 * (1 - (z - 1) / 2))) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n  have h\u2081 : (1 - (z - 1) / 2)\u207b\u00b9 = \u2211' n : \u2115, ((z - 1) / 2 : \u2102) ^ n := by\n    have h\u2082 : Complex.abs ((z - 1) / 2 : \u2102) < 1 := h\n    have h\u2083 : (1 - (z - 1) / 2 : \u2102)\u207b\u00b9 = \u2211' n : \u2115, ((z - 1) / 2 : \u2102) ^ n := by\n      have h\u2084 : (1 - (z - 1) / 2 : \u2102)\u207b\u00b9 = (1 - ((z - 1) / 2 : \u2102))\u207b\u00b9 := by ring_nf\n      rw [h\u2084]\n      have h\u2085 : Complex.abs (((z - 1) / 2 : \u2102)) < 1 := h\u2082\n      have h\u2086 : (1 - ((z - 1) / 2 : \u2102))\u207b\u00b9 = \u2211' n : \u2115, (((z - 1) / 2 : \u2102)) ^ n := by\n        apply h_geom\n        exact h\u2085\n      rw [h\u2086]\n    exact h\u2083\n  \n  have h\u2082 : (1 : \u2102) / 4 * (1 - (z - 1) / 2)\u207b\u00b9 = \u2211' n : \u2115, (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by\n    calc\n      (1 : \u2102) / 4 * (1 - (z - 1) / 2)\u207b\u00b9 = (1 : \u2102) / 4 * \u2211' n : \u2115, ((z - 1) / 2 : \u2102) ^ n := by rw [h\u2081]\n      _ = \u2211' n : \u2115, (1 : \u2102) / 4 * (((z - 1) / 2 : \u2102) ^ n) := by\n        rw [tsum_mul_left]\n      _ = \u2211' n : \u2115, (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by\n        have h\u2083 : \u2200 n : \u2115, (1 : \u2102) / 4 * (((z - 1) / 2 : \u2102) ^ n) = (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by\n          intro n\n          calc\n            (1 : \u2102) / 4 * (((z - 1) / 2 : \u2102) ^ n) = (1 : \u2102) / 4 * (((z - 1) : \u2102) ^ n / 2 ^ n : \u2102) := by\n              calc\n                (1 : \u2102) / 4 * (((z - 1) / 2 : \u2102) ^ n) = (1 : \u2102) / 4 * (((z - 1) : \u2102) / 2 : \u2102) ^ n := by ring_nf\n                _ = (1 : \u2102) / 4 * (((z - 1) : \u2102) ^ n / 2 ^ n : \u2102) := by\n                  rw [show (((z - 1) : \u2102) / 2 : \u2102) ^ n = ((z - 1) : \u2102) ^ n / 2 ^ n by\n                    calc\n                      (((z - 1) : \u2102) / 2 : \u2102) ^ n = ((z - 1) : \u2102) ^ n / 2 ^ n := by\n                        rw [div_pow]\n                        <;> norm_cast\n                        <;> simp [pow_mul]\n                      _ = ((z - 1) : \u2102) ^ n / 2 ^ n := by rfl]\n                  <;> ring_nf\n            _ = (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by\n              calc\n                (1 : \u2102) / 4 * (((z - 1) : \u2102) ^ n / 2 ^ n : \u2102) = ((z - 1) : \u2102) ^ n / (4 * (2 : \u2102) ^ n : \u2102) := by\n                  field_simp [pow_ne_zero]\n                  <;> ring_nf\n                  <;> simp [pow_add, pow_one, mul_assoc]\n                  <;> norm_cast\n                  <;> field_simp [pow_ne_zero]\n                  <;> ring_nf\n                _ = (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by\n                  have h\u2084 : (4 : \u2102) * (2 : \u2102) ^ n = (2 : \u2102) ^ (n + 2) := by\n                    calc\n                      (4 : \u2102) * (2 : \u2102) ^ n = (2 : \u2102) ^ 2 * (2 : \u2102) ^ n := by norm_num\n                      _ = (2 : \u2102) ^ (n + 2) := by\n                        rw [\u2190 pow_add]\n                        <;> ring_nf\n                  rw [h\u2084]\n                  <;> field_simp [pow_ne_zero]\n                  <;> ring_nf\n                  <;> simp [pow_add, pow_one, mul_assoc]\n                  <;> norm_cast\n                  <;> field_simp [pow_ne_zero]\n                  <;> ring_nf\n        calc\n          \u2211' n : \u2115, (1 : \u2102) / 4 * (((z - 1) / 2 : \u2102) ^ n) = \u2211' n : \u2115, ((z - 1 : \u2102) ^ n / 2 ^ (n + 2) : \u2102) := by\n            apply tsum_congr\n            intro n\n            rw [h\u2083 n]\n          _ = \u2211' n : \u2115, (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by simp\n  \n  have h\u2083 : -(1 / (4 * (1 - (z - 1) / 2))) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n    have h\u2084 : (1 : \u2102) / (4 * (1 - (z - 1) / 2)) = (1 : \u2102) / 4 * (1 - (z - 1) / 2)\u207b\u00b9 := by\n      have h\u2085 : (1 - (z - 1) / 2 : \u2102) \u2260 0 := by\n        by_contra h\u2086\n        have h\u2087 : (1 - (z - 1) / 2 : \u2102) = 0 := by simpa using h\u2086\n        have h\u2088 : (z - 1 : \u2102) / 2 = 1 := by\n          have h\u2089 : (1 - (z - 1) / 2 : \u2102) = 0 := h\u2087\n          linear_combination -h\u2089\n        have h\u2089 : Complex.abs ((z - 1 : \u2102) / 2) = 1 := by\n          rw [h\u2088]\n          simp [Complex.abs, Complex.normSq]\n          <;> norm_num\n        have h\u2081\u2080 : Complex.abs ((z - 1 : \u2102) / 2) < 1 := h\n        linarith\n      field_simp [h\u2085]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, pow_two]\n      <;> field_simp [h\u2085]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, pow_two]\n    calc\n      -(1 / (4 * (1 - (z - 1) / 2))) = -((1 : \u2102) / (4 * (1 - (z - 1) / 2))) := by norm_num\n      _ = -((1 : \u2102) / 4 * (1 - (z - 1) / 2)\u207b\u00b9) := by rw [h\u2084]\n      _ = -\u2211' n : \u2115, (z - 1 : \u2102) ^ n / 2 ^ (n + 2) := by\n        rw [h\u2082]\n        <;> simp [tsum_mul_left]\n      _ = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by simp [tsum_mul_left]\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declaration and convergence condition are correctly formalized with appropriate complex number types and absolute value constraint.", "The geometric series formula is accurately represented with proper universal quantification, convergence condition, and series notation.", "The main conclusion equation is mathematically equivalent between natural language and Lean, with appropriate notation for complex arithmetic and infinite series.", "The overall logical structure correctly captures the assumption-conclusion relationship from the natural language proof."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Finally, combining the first term from the partial fraction decomposition with the series expansion of the second term gives the complete Laurent series: $f(z) = -\\frac{1}{2(z-1)} - \\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$.", "statement": "We assume:\n\u2022 $f(z) = -\\frac{1}{2(z-1)} + \\frac{1}{2(z-3)}$ [l1].\n\u2022 $\\frac{1}{2(z-3)} = -\\frac{1}{4(1 - \\frac{z-1}{2})}$ [l2].\n\u2022 $-\\frac{1}{4(1 - \\frac{z-1}{2})} = -\\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$ for $z$ in the annulus of convergence [l4].\nTherefore, we conclude:\n\u2022 $f(z) = -\\frac{1}{2(z-1)} - \\sum_{n=0}^{\\infty} \\frac{(z-1)^n}{2^{n+2}}$ [ts_1].", "dependencies": ["l1", "l2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u2102)\n  (l1 : \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)))\n  (l2 : \u2200 z, z \u2260 1 \u2192 z \u2260 3 \u2192 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)))\n  (l4 : \u2200 z, Complex.abs ((z - 1) / 2) < 1 \u2192 -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) :\n  \u2200 z, Complex.abs ((z - 1) / 2) < 1 \u2192 z \u2260 1 \u2192 z \u2260 3 \u2192 \n    f z = -1 / (2 * (z - 1)) - \u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u2102)\n  (l1 : \u2200 z, f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)))\n  (l2 : \u2200 z, z \u2260 1 \u2192 z \u2260 3 \u2192 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)))\n  (l4 : \u2200 z, Complex.abs ((z - 1) / 2) < 1 \u2192 -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) :\n  \u2200 z, Complex.abs ((z - 1) / 2) < 1 \u2192 z \u2260 1 \u2192 z \u2260 3 \u2192 \n    f z = -1 / (2 * (z - 1)) - \u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n  have h_main : \u2200 (z : \u2102), z \u2260 3 \u2192 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)) := by\n    intro z hz3\n    have h\u2081 : 4 * (1 - (z - 1) / 2 : \u2102) = -2 * (z - 3 : \u2102) := by\n      ring_nf\n      <;> simp [Complex.ext_iff, pow_two]\n      <;> norm_num\n      <;>\n      (try ring_nf) <;>\n      (try simp_all [Complex.ext_iff, pow_two]) <;>\n      (try norm_num) <;>\n      (try linarith)\n      <;>\n      (try\n        {\n          constructor <;>\n          ring_nf at * <;>\n          simp_all [Complex.ext_iff, pow_two] <;>\n          norm_num <;>\n          linarith\n        })\n    have h\u2082 : (2 : \u2102) * (z - 3 : \u2102) \u2260 0 := by\n      intro h\n      apply hz3\n      have h\u2083 : (z - 3 : \u2102) = 0 := by\n        apply mul_left_cancel\u2080 (show (2 : \u2102) \u2260 0 by norm_num)\n        rw [h]\n        <;> simp [Complex.ext_iff]\n      have h\u2084 : z = 3 := by\n        rw [sub_eq_zero] at h\u2083\n        exact h\u2083\n      exact h\u2084\n    have h\u2083 : (4 : \u2102) * (1 - (z - 1 : \u2102) / 2) \u2260 0 := by\n      intro h\n      have h\u2084 : (4 : \u2102) * (1 - (z - 1 : \u2102) / 2) = 0 := h\n      have h\u2085 : (-2 : \u2102) * (z - 3 : \u2102) = 0 := by\n        rw [h\u2081] at h\u2084\n        exact h\u2084\n      have h\u2086 : (z - 3 : \u2102) = 0 := by\n        apply mul_left_cancel\u2080 (show (-2 : \u2102) \u2260 0 by norm_num)\n        rw [h\u2085]\n        <;> simp [Complex.ext_iff]\n      have h\u2087 : z = 3 := by\n        rw [sub_eq_zero] at h\u2086\n        exact h\u2086\n      contradiction\n    calc\n      1 / (2 * (z - 3)) = 1 / (2 * (z - 3)) := rfl\n      _ = -1 / (4 * (1 - (z - 1) / 2)) := by\n        have h\u2084 : (4 : \u2102) * (1 - (z - 1 : \u2102) / 2) = -2 * (z - 3 : \u2102) := by\n          rw [h\u2081]\n        have h\u2085 : 1 / (2 * (z - 3 : \u2102)) = -1 / (4 * (1 - (z - 1 : \u2102) / 2)) := by\n          calc\n            1 / (2 * (z - 3 : \u2102)) = 1 / (2 * (z - 3 : \u2102)) := rfl\n            _ = -1 / (-2 * (z - 3 : \u2102)) := by\n              have h\u2086 : (-2 : \u2102) * (z - 3 : \u2102) \u2260 0 := by\n                intro h\u2087\n                apply h\u2082\n                simp_all [Complex.ext_iff]\n                <;>\n                (try ring_nf at *) <;>\n                (try simp_all [Complex.ext_iff]) <;>\n                (try norm_num at *) <;>\n                (try linarith)\n              field_simp [h\u2082, h\u2086]\n              <;> ring_nf\n              <;> simp_all [Complex.ext_iff]\n              <;> norm_num\n              <;>\n              (try\n                {\n                  constructor <;>\n                  ring_nf at * <;>\n                  simp_all [Complex.ext_iff] <;>\n                  norm_num <;>\n                  linarith\n                })\n            _ = -1 / (4 * (1 - (z - 1 : \u2102) / 2)) := by\n              rw [h\u2081]\n              <;>\n              (try ring_nf) <;>\n              (try simp_all [Complex.ext_iff]) <;>\n              (try norm_num) <;>\n              (try linarith)\n        simpa [Complex.ext_iff] using h\u2085\n  \n  intro z h_abs h_ne_1 h_ne_3\n  have h_f_expr : f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := by\n    rw [l1]\n    <;>\n    (try simp_all) <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try field_simp) <;>\n    (try simp_all [Complex.ext_iff]) <;>\n    (try norm_num) <;>\n    (try linarith)\n  \n  have h_rewrite : 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)) := by\n    have h\u2081 : 1 / (2 * (z - 3)) = -1 / (4 * (1 - (z - 1) / 2)) := by\n      apply h_main\n      <;> assumption\n    exact h\u2081\n  \n  have h_f_expr_2 : f z = -1 / (2 * (z - 1)) - 1 / (4 * (1 - (z - 1) / 2)) := by\n    calc\n      f z = -1 / (2 * (z - 1)) + 1 / (2 * (z - 3)) := h_f_expr\n      _ = -1 / (2 * (z - 1)) + (-1 / (4 * (1 - (z - 1) / 2))) := by\n        rw [h_rewrite]\n        <;>\n        (try simp_all) <;>\n        (try norm_num) <;>\n        (try ring_nf) <;>\n        (try field_simp) <;>\n        (try simp_all [Complex.ext_iff]) <;>\n        (try norm_num) <;>\n        (try linarith)\n      _ = -1 / (2 * (z - 1)) - 1 / (4 * (1 - (z - 1) / 2)) := by\n        ring_nf\n        <;>\n        (try simp_all) <;>\n        (try norm_num) <;>\n        (try ring_nf) <;>\n        (try field_simp) <;>\n        (try simp_all [Complex.ext_iff]) <;>\n        (try norm_num) <;>\n        (try linarith)\n  \n  have h_sum_expr : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n    have h\u2081 : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n      have h\u2082 : Complex.abs ((z - 1) / 2) < 1 := h_abs\n      have h\u2083 : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n        have h\u2084 : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n          have h\u2085 : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n            -- Use the given lemma l4 to directly get the result\n            have h\u2086 : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n              calc\n                -1 / (4 * (1 - (z - 1) / 2)) = -1 / (4 * (1 - (z - 1) / 2)) := rfl\n                _ = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n                  -- Use the given lemma l4 to directly get the result\n                  have h\u2087 : Complex.abs ((z - 1) / 2) < 1 := h_abs\n                  have h\u2088 : -1 / (4 * (1 - (z - 1) / 2)) = -\u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := l4 z h\u2087\n                  rw [h\u2088]\n            exact h\u2086\n          exact h\u2085\n        exact h\u2084\n      exact h\u2083\n    exact h\u2081\n  \n  have h_final : f z = -1 / (2 * (z - 1)) - \u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n    calc\n      f z = -1 / (2 * (z - 1)) - 1 / (4 * (1 - (z - 1) / 2)) := h_f_expr_2\n      _ = -1 / (2 * (z - 1)) - (1 / (4 * (1 - (z - 1) / 2))) := by ring\n      _ = -1 / (2 * (z - 1)) - (-\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) * (-1 : \u2102) := by\n        have h\u2081 : (1 : \u2102) / (4 * (1 - (z - 1) / 2)) = (-\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) * (-1 : \u2102) := by\n          calc\n            (1 : \u2102) / (4 * (1 - (z - 1) / 2)) = -(-1 / (4 * (1 - (z - 1) / 2))) := by\n              ring_nf\n              <;> simp [Complex.ext_iff, pow_two]\n              <;> norm_num\n              <;>\n              (try ring_nf at *) <;>\n              (try simp_all [Complex.ext_iff, pow_two]) <;>\n              (try norm_num) <;>\n              (try linarith)\n            _ = -(-\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) := by\n              rw [h_sum_expr]\n              <;>\n              (try ring_nf at *) <;>\n              (try simp_all [Complex.ext_iff, pow_two]) <;>\n              (try norm_num) <;>\n              (try linarith)\n            _ = (-\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) * (-1 : \u2102) := by\n              ring_nf\n              <;> simp [Complex.ext_iff, pow_two]\n              <;> norm_num\n              <;>\n              (try ring_nf at *) <;>\n              (try simp_all [Complex.ext_iff, pow_two]) <;>\n              (try norm_num) <;>\n              (try linarith)\n        rw [h\u2081]\n        <;> ring_nf\n        <;> simp [Complex.ext_iff, pow_two]\n        <;> norm_num\n        <;>\n        (try ring_nf at *) <;>\n        (try simp_all [Complex.ext_iff, pow_two]) <;>\n        (try norm_num) <;>\n        (try linarith)\n      _ = -1 / (2 * (z - 1)) - \u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n        have h\u2082 : (-\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) * (-1 : \u2102) = \u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by\n          calc\n            (-\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) * (-1 : \u2102) = (\u2211' n, (z - 1) ^ n / 2 ^ (n + 2)) := by\n              ring_nf\n              <;> simp [Complex.ext_iff, pow_two]\n              <;> norm_num\n              <;>\n              (try ring_nf at *) <;>\n              (try simp_all [Complex.ext_iff, pow_two]) <;>\n              (try norm_num) <;>\n              (try linarith)\n            _ = \u2211' n, (z - 1) ^ n / 2 ^ (n + 2) := by rfl\n        rw [h\u2082]\n        <;> ring_nf\n        <;> simp [Complex.ext_iff, pow_two]\n        <;> norm_num\n        <;>\n        (try ring_nf at *) <;>\n        (try simp_all [Complex.ext_iff, pow_two]) <;>\n        (try norm_num) <;>\n        (try linarith)\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The function definition is correctly translated with proper mathematical notation in Lean.", "The algebraic identity is correctly captured, with appropriate additional conditions (z \u2260 1, z \u2260 3) to ensure mathematical validity in formal verification.", "The series expansion is accurately represented, with the convergence condition properly specified as Complex.abs ((z - 1) / 2) < 1, which correctly captures the 'annulus of convergence' mentioned in natural language.", "The final conclusion correctly combines all previous results, with all necessary mathematical conditions included to ensure the theorem statement is well-defined."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    