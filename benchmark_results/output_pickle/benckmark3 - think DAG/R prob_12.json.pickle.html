
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X_1, \dots, X_n$ be a sequence of pairwise uncorrelated random variables. Suppose each variable has the same mean $E[X_i] = \mu$ and the same finite variance $Var(X_i) = \sigma^2$. Let the sample mean be defined as $\bar{X}_n = \frac{1}{n} \sum_{i=1}^n X_i$. Then, the expectation of the sample mean is $E[\bar{X}_n] = \mu$, its variance is $Var(\bar{X}_n) = \frac{\sigma^2}{n}$, and for any $\epsilon > 0$, the probability of deviation from the mean is bounded by $P(|\bar{X}_n - \mu| \ge \epsilon) \le \frac{\sigma^2}{n\epsilon^2}$.

Proof: First, we determine the expectation of the sample mean. Using the definition of $\bar{X}_n$ and the linearity of expectation, we find $E[\bar{X}_n] = E\left[\frac{1}{n} \sum_{i=1}^n X_i\right] = \frac{1}{n} \sum_{i=1}^n E[X_i]$. Since we are given that $E[X_i] = \mu$ for all $i$, this simplifies to $E[\bar{X}_n] = \frac{1}{n} \sum_{i=1}^n \mu = \mu$. 

Next, we compute the variance. From the properties of variance and the definition of $\bar{X}_n$, it follows that $Var(\bar{X}_n) = Var\left(\frac{1}{n} \sum_{i=1}^n X_i\right) = \frac{1}{n^2} Var\left(\sum_{i=1}^n X_i\right)$. As the random variables are pairwise uncorrelated, the variance of their sum is the sum of their variances: $Var\left(\sum_{i=1}^n X_i\right) = \sum_{i=1}^n Var(X_i)$. Therefore, by combining the last two results, we get $Var(\bar{X}_n) = \frac{1}{n^2} \sum_{i=1}^n Var(X_i)$. Using the given condition $Var(X_i) = \sigma^2$, we calculate the final variance: $Var(\bar{X}_n) = \frac{1}{n^2} \sum_{i=1}^n \sigma^2 = \frac{\sigma^2}{n}$.

Finally, we establish the probability bound. We use the principle of Chebyshev's inequality, which states that for any random variable $Y$ with a finite mean $E[Y]$ and finite variance $Var(Y)$, the inequality $P(|Y - E[Y]| \ge \epsilon) \le \frac{Var(Y)}{\epsilon^2}$ holds for any $\epsilon > 0$. By applying this principle to the random variable $Y = \bar{X}_n$ and substituting our previously derived results for its mean and variance, we conclude that $P(|\bar{X}_n - \mu| \ge \epsilon) \le \frac{\sigma^2}{n\epsilon^2}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X_1, \\dots, X_n$ be a sequence of pairwise uncorrelated random variables.", "statement": "Premise:\n\u2022 $X_1, \\dots, X_n$ is a sequence of pairwise uncorrelated random variables [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes pairwise uncorrelated random variables X_1, ..., X_n, but the Lean code defines a deterministic sequence a of positive real numbers. These are fundamentally different mathematical objects - random variables with correlation properties versus deterministic positive real numbers. The Lean formalization completely misses the probabilistic nature and correlation structure of the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language describes pairwise uncorrelated random variables X_1, ..., X_n, but the Lean code defines a deterministic sequence a of positive real numbers. These are fundamentally different mathematical objects - random variables with correlation properties versus deterministic positive real numbers. The Lean formalization completely misses the probabilistic nature and correlation structure of the original statement.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Suppose each variable has the same mean $E[X_i] = \\mu$", "statement": "Premise:\n\u2022 $X_1, \\dots, X_n$ is a sequence of random variables [tc_1]\n\u2022 For each $i$ from 1 to $n$, the mean is $E[X_i] = \\mu$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X : Fin n \u2192 \u211d \u2192 \u211d) (\u03bc : \u211d)\n  (h_mean : \u2200 i : Fin n, \u2200 x : \u211d, X i x = \u03bc)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly represents a sequence of random variables X\u2081, ..., X\u2099 using the type Fin n \u2192 \u211d \u2192 \u211d, which is the standard way to represent random variables in Lean", "The Lean condition states that X i x = \u03bc for all x, meaning each random variable is constant and always equals \u03bc. However, the natural language states E[X_i] = \u03bc, which means the expected value (mean) of each random variable equals \u03bc, not that the random variable itself is constant. This is a major difference - constant random variables vs random variables with a specific expected value"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly represents a sequence of random variables X\u2081, ..., X\u2099 using the type Fin n \u2192 \u211d \u2192 \u211d, which is the standard way to represent random variables in Lean', 'The Lean condition states that X i x = \u03bc for all x, meaning each random variable is constant and always equals \u03bc. However, the natural language states E[X_i] = \u03bc, which means the expected value (mean) of each random variable equals \u03bc, not that the random variable itself is constant. This is a major difference - constant random variables vs random variables with a specific expected value']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "and the same finite variance $Var(X_i) = \\sigma^2$.", "statement": "Premise:\n\u2022 $X_1, \\dots, X_n$ is a sequence of random variables [tc_1]\n\u2022 For each $i$ from 1 to $n$, the variance is finite and given by $Var(X_i) = \\sigma^2$ [tc_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_3 {n : \u2115} (hn : 0 < n) \n  (X : Fin n \u2192 \u211d \u2192 \u211d) (\u03bc \u03c3 : \u211d) (h_positive : 0 < \u03c3)\n  (h_mean : \u2200 i x, X i x = \u03bc + (X i x - \u03bc))\n  (h_variance : \u2200 i, \u222b x, (X i x - \u03bc)^2 = \u03c3^2)\n  (h_uncorrelated : \u2200 i j, i \u2260 j \u2192 \u222b x, (X i x - \u03bc) * (X j x - \u03bc) = 0) :\n  let X_bar : \u211d \u2192 \u211d := fun x => (1 / n : \u211d) * \u2211 i, X i x\n  (\u222b x, X_bar x = \u03bc) \u2227 \n  (\u222b x, (X_bar x - \u03bc)^2 = \u03c3^2 / n) \u2227\n  (\u2200 \u03b5 > 0, (\u03c3^2 / n) / \u03b5^2 \u2264 \u03c3^2 / (n * \u03b5^2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization `X : Fin n \u2192 \u211d \u2192 \u211d` correctly captures a sequence of n random variables, which matches the natural language condition of $X_1, \\dots, X_n$ being a sequence of random variables.", "The Lean condition `h_variance : \u2200 i, \u222b x, (X i x - \u03bc)^2 = \u03c3^2` correctly formalizes the variance condition $Var(X_i) = \u03c3^2$ for each i. The integral notation is the proper mathematical formalization of variance.", "The natural language explicitly states there are no conclusions derived - only initial conditions. However, the Lean theorem contains substantial conclusions about the sample mean $X_{bar}$, its expectation, variance, and an inequality. This introduces logical components that directly contradict the premise that no conclusions are being derived."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization `X : Fin n \u2192 \u211d \u2192 \u211d` correctly captures a sequence of n random variables, which matches the natural language condition of $X_1, \\\\dots, X_n$ being a sequence of random variables.', 'The Lean condition `h_variance : \u2200 i, \u222b x, (X i x - \u03bc)^2 = \u03c3^2` correctly formalizes the variance condition $Var(X_i) = \u03c3^2$ for each i. The integral notation is the proper mathematical formalization of variance.', 'The natural language explicitly states there are no conclusions derived - only initial conditions. However, the Lean theorem contains substantial conclusions about the sample mean $X_{bar}$, its expectation, variance, and an inequality. This introduces logical components that directly contradict the premise that no conclusions are being derived.']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let the sample mean be defined as $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$.", "statement": "We assume:\n\u2022 $X_1, \\dots, X_n$ is a sequence of random variables [tc_1].\nDefinition:\n\u2022 The sample mean is defined as $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (n : \u2115) (hn : 0 < n) (X : Fin n \u2192 \u211d)\n  (\u03bc \u03c3 : \u211d) (h\u03bc : \u2200 i, X i = \u03bc) (h\u03c3 : \u2200 i, (X i - \u03bc)^2 = \u03c3^2) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  -- The expectation of the sample mean is \u03bc\n  sample_mean = \u03bc \u2227\n  -- The variance of the sample mean is \u03c3\u00b2/n  \n  (sample_mean - \u03bc)^2 = \u03c3^2 / (n : \u211d) \u2227\n  -- For any \u03b5 > 0, P(|X\u0304\u2099 - \u03bc| \u2265 \u03b5) \u2264 \u03c3\u00b2/(n\u03b5\u00b2)\n  \u2200 \u03b5 > 0, (if |sample_mean - \u03bc| \u2265 \u03b5 then 1 else 0) \u2264 \u03c3^2 / ((n : \u211d) * \u03b5^2)\n  := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization represents the sequence of random variables as `X : Fin n \u2192 \u211d`, which is a function from finite indices to real numbers. While this captures the mathematical concept of a sequence X\u2081, ..., X\u2099, it doesn't explicitly model the probabilistic nature of random variables - they're treated as deterministic real-valued functions rather than random variables with probability distributions.", "The natural language only asks for a definition of the sample mean, but the Lean theorem goes far beyond this by proving three additional properties: that the sample mean equals \u03bc, that its variance is \u03c3\u00b2/n, and a probability bound. The Lean formalization also introduces extra assumptions (\u03bc, \u03c3, h\u03bc, h\u03c3) that constrain all X_i to equal \u03bc and have the same variance \u03c3\u00b2. This transforms a simple definition into a complex theorem with multiple conclusions not present in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization represents the sequence of random variables as `X : Fin n \u2192 \u211d`, which is a function from finite indices to real numbers. While this captures the mathematical concept of a sequence X\u2081, ..., X\u2099, it doesn't explicitly model the probabilistic nature of random variables - they're treated as deterministic real-valued functions rather than random variables with probability distributions.\", 'The natural language only asks for a definition of the sample mean, but the Lean theorem goes far beyond this by proving three additional properties: that the sample mean equals \u03bc, that its variance is \u03c3\u00b2/n, and a probability bound. The Lean formalization also introduces extra assumptions (\u03bc, \u03c3, h\u03bc, h\u03c3) that constrain all X_i to equal \u03bc and have the same variance \u03c3\u00b2. This transforms a simple definition into a complex theorem with multiple conclusions not present in the natural language.']"}, "type": "definition"}, "tc_4": {"id": "tc_4", "natural_language": "for any $\\epsilon > 0$", "statement": "Premise:\n\u2022 $\\epsilon$ is a real number such that $\\epsilon > 0$ [tc_4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (\u03b5 : \u211d)\n(tc_4 : 0 < \u03b5)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `(\u03b5 : \u211d)` correctly captures that \u03b5 is a real number, matching the natural language condition exactly.", "The Lean condition `(tc_4 : 0 < \u03b5)` is mathematically equivalent to `\u03b5 > 0` from the natural language, representing the same strict positivity constraint."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Using the definition of $\\bar{X}_n$ and the linearity of expectation, we find $E[\\bar{X}_n] = E\\left[\\frac{1}{n} \\sum_{i=1}^n X_i\\right] = \\frac{1}{n} \\sum_{i=1}^n E[X_i]$.", "statement": "We assume:\n\u2022 The sample mean is defined as $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$ [def_1].\nTherefore, we conclude:\n\u2022 $E[\\bar{X}_n] = \\frac{1}{n} \\sum_{i=1}^n E[X_i]$ [l1].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (n : \u2115) (hn : 0 < n) (X : Fin n \u2192 \u211d) (\u03bc : \u211d) \n  (h\u03bc : \u2200 i, X i = \u03bc) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  sample_mean = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (n : \u2115) (hn : 0 < n) (X : Fin n \u2192 \u211d) (\u03bc : \u211d) \n  (h\u03bc : \u2200 i, X i = \u03bc) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  sample_mean = \u03bc := by\n  intro sample_mean\n  have h_sum : (\u2211 i : Fin n, X i) = n * \u03bc := by\n    calc\n      (\u2211 i : Fin n, X i) = \u2211 i : Fin n, \u03bc := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u03bc i]\n      _ = n * \u03bc := by\n        simp [Finset.sum_const, Finset.card_fin]\n        <;> ring\n        <;> field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n        <;> ring\n  \n  have h_main : sample_mean = \u03bc := by\n    dsimp only [sample_mean] at *\n    have h\u2081 : (1 / (n : \u211d)) * (\u2211 i : Fin n, X i) = (1 / (n : \u211d)) * (n * \u03bc) := by\n      rw [h_sum]\n    rw [h\u2081]\n    have h\u2082 : (n : \u211d) \u2260 0 := by\n      exact mod_cast (by linarith)\n    field_simp [h\u2082]\n    <;> ring\n    <;> field_simp [h\u2082]\n    <;> ring\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sample mean definition is correctly formalized - both expressions represent the same mathematical formula for computing the average.", "The natural language discusses expected values of random variables E[X\u0304\u2099] = (1/n)\u2211E[X\u1d62], but the Lean code proves a deterministic equality sample_mean = \u03bc. This misses the core probabilistic content.", "The natural language treats X\u1d62 as random variables in a probabilistic setting, while Lean treats X as deterministic functions with the constraint that all values equal \u03bc. This changes the mathematical context from probabilistic to deterministic."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sample mean definition is correctly formalized - both expressions represent the same mathematical formula for computing the average.', 'The natural language discusses expected values of random variables E[X\u0304\u2099] = (1/n)\u2211E[X\u1d62], but the Lean code proves a deterministic equality sample_mean = \u03bc. This misses the core probabilistic content.', 'The natural language treats X\u1d62 as random variables in a probabilistic setting, while Lean treats X as deterministic functions with the constraint that all values equal \u03bc. This changes the mathematical context from probabilistic to deterministic.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since we are given that $E[X_i] = \\mu$ for all $i$, this simplifies to $E[\\bar{X}_n] = \\frac{1}{n} \\sum_{i=1}^n \\mu = \\mu$.", "statement": "We assume:\n\u2022 For each $i$ from 1 to $n$, the mean is $E[X_i] = \\mu$ [tc_2]\n\u2022 $E[\\bar{X}_n] = \\frac{1}{n} \\sum_{i=1}^n E[X_i]$ [l1].\nTherefore, we conclude:\n\u2022 $E[\\bar{X}_n] = \\mu$ [ts_1].", "dependencies": ["tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {n : \u2115} (hn : 0 < n) \n  (X : Fin n \u2192 \u211d \u2192 \u211d) (\u03bc : \u211d)\n  (h_mean : \u2200 i : Fin n, \u2200 x : \u211d, X i x = \u03bc)\n  (h_l1 : (1 / (n : \u211d)) * (\u2211 i : Fin n, \u03bc) = \u03bc) :\n  (1 / (n : \u211d)) * (\u2211 i : Fin n, \u03bc) = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {n : \u2115} (hn : 0 < n) \n  (X : Fin n \u2192 \u211d \u2192 \u211d) (\u03bc : \u211d)\n  (h_mean : \u2200 i : Fin n, \u2200 x : \u211d, X i x = \u03bc)\n  (h_l1 : (1 / (n : \u211d)) * (\u2211 i : Fin n, \u03bc) = \u03bc) :\n  (1 / (n : \u211d)) * (\u2211 i : Fin n, \u03bc) = \u03bc := by\n  have h_main : (1 / (n : \u211d)) * (\u2211 i : Fin n, \u03bc) = \u03bc := by\n    -- Directly use the given hypothesis h_l1 to conclude the proof.\n    exact h_l1\n  \n  -- The final goal is already achieved by h_main, so we simply use it.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The representation of random variables is fundamentally incorrect. The Lean code defines X_i as constant functions always equal to \u03bc, rather than random variables with expectation \u03bc. This eliminates the probabilistic nature of the problem.", "The linearity of expectation property (l1) is not properly formalized. Instead of stating E[X\u0304_n] = (1/n)\u2211E[X_i], the Lean code directly assumes the final result, making the logical structure circular.", "The expectation operator E[\u00b7] is completely missing from the formalization, which removes the core probabilistic content. The conclusion becomes a trivial arithmetic identity rather than a statement about expected values of random variables."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The representation of random variables is fundamentally incorrect. The Lean code defines X_i as constant functions always equal to \u03bc, rather than random variables with expectation \u03bc. This eliminates the probabilistic nature of the problem.', 'The linearity of expectation property (l1) is not properly formalized. Instead of stating E[X\u0304_n] = (1/n)\u2211E[X_i], the Lean code directly assumes the final result, making the logical structure circular.', 'The expectation operator E[\u00b7] is completely missing from the formalization, which removes the core probabilistic content. The conclusion becomes a trivial arithmetic identity rather than a statement about expected values of random variables.']"}, "solved_negation": null, "type": "solution"}, "l2": {"id": "l2", "natural_language": "From the properties of variance and the definition of $\\bar{X}_n$, it follows that $Var(\\bar{X}_n) = Var\\left(\\frac{1}{n} \\sum_{i=1}^n X_i\\right) = \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i\\right)$.", "statement": "We assume:\n\u2022 The sample mean is defined as $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$ [def_1].\nTherefore, we conclude:\n\u2022 $Var(\\bar{X}_n) = \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i\\right)$ [l2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (hn : 0 < n) (X : Fin n \u2192 \u211d) (\u03bc \u03c3 : \u211d) \n  (h\u03bc : \u2200 i, X i = \u03bc) (h\u03c3 : \u2200 i, (X i - \u03bc)^2 = \u03c3^2)\n  (huncorr : \u2200 i j, i \u2260 j \u2192 (X i - \u03bc) * (X j - \u03bc) = 0) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  (sample_mean - \u03bc)^2 = (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2)\n  := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (hn : 0 < n) (X : Fin n \u2192 \u211d) (\u03bc \u03c3 : \u211d) \n  (h\u03bc : \u2200 i, X i = \u03bc) (h\u03c3 : \u2200 i, (X i - \u03bc)^2 = \u03c3^2)\n  (huncorr : \u2200 i j, i \u2260 j \u2192 (X i - \u03bc) * (X j - \u03bc) = 0) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  (sample_mean - \u03bc)^2 = (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2)\n  := by\n  intro sample_mean\n  have h_sum_X : (\u2211 i : Fin n, X i) = (n : \u211d) * \u03bc := by\n    calc\n      (\u2211 i : Fin n, X i) = \u2211 i : Fin n, \u03bc := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u03bc i]\n      _ = (n : \u211d) * \u03bc := by\n        simp [Finset.sum_const, nsmul_eq_mul]\n        <;> field_simp [hn.ne']\n        <;> ring_nf\n        <;> norm_cast\n        <;> simp [hn]\n        <;> ring_nf\n  \n  have h_sample_mean : sample_mean = \u03bc := by\n    have h\u2081 : sample_mean = (1 / (n : \u211d)) * (\u2211 i : Fin n, X i) := rfl\n    rw [h\u2081]\n    rw [h_sum_X]\n    have h\u2082 : (n : \u211d) \u2260 0 := by\n      norm_cast\n      <;> omega\n    field_simp [h\u2082]\n    <;> ring_nf\n    <;> field_simp [h\u2082]\n    <;> ring_nf\n  \n  have h_left : (sample_mean - \u03bc)^2 = 0 := by\n    rw [h_sample_mean]\n    ring_nf\n    <;> simp [sq]\n    <;> ring_nf\n  \n  have h_sum_sq : (\u2211 i : Fin n, (X i - \u03bc)^2) = 0 := by\n    have h\u2081 : \u2200 i : Fin n, (X i - \u03bc)^2 = 0 := by\n      intro i\n      have h\u2082 : X i = \u03bc := h\u03bc i\n      rw [h\u2082]\n      ring_nf\n      <;> simp [sq]\n      <;> ring_nf\n    calc\n      (\u2211 i : Fin n, (X i - \u03bc)^2) = \u2211 i : Fin n, 0 := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u2081 i]\n      _ = 0 := by simp\n  \n  have h_right : (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2) = 0 := by\n    rw [h_sum_sq]\n    <;> simp [mul_zero]\n    <;> field_simp [pow_ne_zero]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [hn.ne']\n    <;> field_simp [pow_ne_zero]\n    <;> ring_nf\n    <;> norm_num\n  \n  have h_main : (sample_mean - \u03bc)^2 = (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2) := by\n    rw [h_left, h_right]\n    <;> simp\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sample mean definition is correctly captured in Lean, with the mathematical formula properly translated from natural language to formal notation.", "The main conclusion has a major inconsistency. The natural language discusses variance of random variables (Var operator), which involves probability distributions and expected values. However, the Lean formalization treats this as a deterministic algebraic identity using squared deviations. Additionally, the Lean code introduces restrictive assumptions (constant means, constant variances, uncorrelatedness) that fundamentally change the scope from a general variance property to a specific case under strong constraints. This represents a significant departure from the generality implied in the natural language statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sample mean definition is correctly captured in Lean, with the mathematical formula properly translated from natural language to formal notation.', 'The main conclusion has a major inconsistency. The natural language discusses variance of random variables (Var operator), which involves probability distributions and expected values. However, the Lean formalization treats this as a deterministic algebraic identity using squared deviations. Additionally, the Lean code introduces restrictive assumptions (constant means, constant variances, uncorrelatedness) that fundamentally change the scope from a general variance property to a specific case under strong constraints. This represents a significant departure from the generality implied in the natural language statement.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "As the random variables are pairwise uncorrelated, the variance of their sum is the sum of their variances: $Var\\left(\\sum_{i=1}^n X_i\\right) = \\sum_{i=1}^n Var(X_i)$.", "statement": "We assume:\n\u2022 $X_1, \\dots, X_n$ is a sequence of pairwise uncorrelated random variables [tc_1].\nTherefore, we conclude:\n\u2022 $Var\\left(\\sum_{i=1}^n X_i\\right) = \\sum_{i=1}^n Var(X_i)$ [l3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (\u03bc : MeasureTheory.Measure \u03a9) [MeasureTheory.IsProbabilityMeasure \u03bc]\n  (n : \u2115) (X : Fin n \u2192 \u03a9 \u2192 \u211d)\n  (h_integrable : \u2200 i : Fin n, MeasureTheory.Integrable (X i))\n  (h_uncorr : \u2200 i j : Fin n, i \u2260 j \u2192 \n    \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) :\n  \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc)^2 = \n  \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by sorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 31, "endLine": 11, "endColumn": 55, "data": "could not synthesize default value for parameter '\u03bc' using tactics"}, {"line": 11, "column": 31, "endLine": 11, "endColumn": 55, "data": "typeclass instance problem is stuck, it is often due to metavariables\n  MeasureTheory.MeasureSpace ?m.3427"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] [MeasureSpace \u03a9]\n  (\u03bc : MeasureTheory.Measure \u03a9) [MeasureTheory.IsProbabilityMeasure \u03bc]\n  (n : \u2115) (X : Fin n \u2192 \u03a9 \u2192 \u211d)\n  (h_integrable : \u2200 i : Fin n, MeasureTheory.Integrable (X i))\n  (h_sq_integrable : \u2200 i : Fin n, MeasureTheory.Integrable (fun \u03c9 \u21a6 (X i \u03c9)^2))\n  (h_uncorr : \u2200 i j : Fin n, i \u2260 j \u2192 \n    \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) :\n  \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc)^2 = \n  \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n  have h_sum_sq_expansion : \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc = \u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n    have h\u2081 : (\u2211 i : Fin n, X i) = (fun \u03c9 : \u03a9 => \u2211 i : Fin n, X i \u03c9) := by\n      funext \u03c9\n      <;> simp [Finset.sum_congr]\n    have h\u2082 : (\u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc) = \u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := rfl\n    calc\n      \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc = \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc := rfl\n      _ = \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9) * (\u2211 j : Fin n, X j \u03c9) \u2202\u03bc := by\n        congr\n        <;> ext <;> ring\n      _ = \u222b \u03c9, (\u2211 i : Fin n, \u2211 j : Fin n, X i \u03c9 * X j \u03c9) \u2202\u03bc := by\n        have h\u2083 : (\u2211 i : Fin n, X i \u03c9) * (\u2211 j : Fin n, X j \u03c9) = \u2211 i : Fin n, \u2211 j : Fin n, X i \u03c9 * X j \u03c9 := by\n          simp [Finset.sum_mul, Finset.mul_sum]\n          <;> rw [Finset.sum_comm]\n          <;> simp [mul_assoc, mul_comm, mul_left_comm]\n        congr\n        <;> ext <;> rw [h\u2083]\n      _ = \u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n        have h\u2084 : \u222b \u03c9, (\u2211 i : Fin n, \u2211 j : Fin n, X i \u03c9 * X j \u03c9) \u2202\u03bc = \u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n          calc\n            \u222b \u03c9, (\u2211 i : Fin n, \u2211 j : Fin n, X i \u03c9 * X j \u03c9) \u2202\u03bc = \u2211 i : Fin n, \u222b \u03c9, \u2211 j : Fin n, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n              -- Use the linearity of the integral to split the sum over i\n              have h\u2085 : \u222b \u03c9, (\u2211 i : Fin n, \u2211 j : Fin n, X i \u03c9 * X j \u03c9) \u2202\u03bc = \u2211 i : Fin n, \u222b \u03c9, \u2211 j : Fin n, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n                -- Apply the integral of the sum equals the sum of the integrals\n                apply MeasureTheory.integral_finset_sum\n                intro i _\n                have h\u2086 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => \u2211 j : Fin n, X i \u03c9 * X j \u03c9) := by\n                  apply MeasureTheory.Integrable.finset_sum\n                  intro j _\n                  have h\u2087 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                    by_cases h : i = j\n                    \u00b7 -- Case i = j\n                      subst h\n                      have h\u2088 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => (X i \u03c9)^2) := h_sq_integrable i\n                      have h\u2089 : (fun \u03c9 : \u03a9 => (X i \u03c9)^2) = (fun \u03c9 : \u03a9 => X i \u03c9 * X i \u03c9) := by\n                        funext \u03c9\n                        ring\n                      rw [h\u2089] at h\u2088\n                      exact h\u2088\n                    \u00b7 -- Case i \u2260 j\n                      have h\u2088 : \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := h_uncorr i j (by intro h; apply h; simp_all [Fin.ext_iff])\n                      have h\u2089 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                        by_contra h\u2089\n                        have h\u2081\u2080 : \u00acMeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := h\u2089\n                        have h\u2081\u2081 : \u00ac(\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n                          intro h\u2081\u2082\n                          have h\u2081\u2083 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                            -- Use the fact that the integral exists to deduce integrability\n                            have h\u2081\u2084 : \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := h\u2081\u2082\n                            have h\u2081\u2085 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9) := h_integrable i\n                            have h\u2081\u2086 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X j \u03c9) := h_integrable j\n                            -- Use the fact that the product of two integrable functions is integrable on a finite measure space\n                            have h\u2081\u2087 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                              -- Use the fact that the product of two integrable functions is integrable on a finite measure space\n                              exact MeasureTheory.Integrable.mul h\u2081\u2085 h\u2081\u2086\n                            exact h\u2081\u2087\n                          contradiction\n                        contradiction\n                      exact h\u2089\n                  exact h\u2087\n                exact h\u2086\n              exact h\u2085\n            _ = \u2211 i : Fin n, \u222b \u03c9, \u2211 j : Fin n, X i \u03c9 * X j \u03c9 \u2202\u03bc := by rfl\n            _ = \u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n              apply Finset.sum_congr rfl\n              intro i _\n              have h\u2086 : \u222b \u03c9, \u2211 j : Fin n, X i \u03c9 * X j \u03c9 \u2202\u03bc = \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n                -- Use the linearity of the integral to split the sum over j\n                have h\u2087 : \u222b \u03c9, \u2211 j : Fin n, X i \u03c9 * X j \u03c9 \u2202\u03bc = \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc := by\n                  apply MeasureTheory.integral_finset_sum\n                  intro j _\n                  have h\u2088 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                    by_cases h : i = j\n                    \u00b7 -- Case i = j\n                      subst h\n                      have h\u2089 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => (X i \u03c9)^2) := h_sq_integrable i\n                      have h\u2081\u2080 : (fun \u03c9 : \u03a9 => (X i \u03c9)^2) = (fun \u03c9 : \u03a9 => X i \u03c9 * X i \u03c9) := by\n                        funext \u03c9\n                        ring\n                      rw [h\u2081\u2080] at h\u2089\n                      exact h\u2089\n                    \u00b7 -- Case i \u2260 j\n                      have h\u2089 : \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := h_uncorr i j (by intro h; apply h; simp_all [Fin.ext_iff])\n                      have h\u2081\u2080 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                        by_contra h\u2081\u2080\n                        have h\u2081\u2081 : \u00acMeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := h\u2081\u2080\n                        have h\u2081\u2082 : \u00ac(\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n                          intro h\u2081\u2083\n                          have h\u2081\u2084 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                            -- Use the fact that the integral exists to deduce integrability\n                            have h\u2081\u2085 : \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := h\u2081\u2083\n                            have h\u2081\u2086 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9) := h_integrable i\n                            have h\u2081\u2087 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X j \u03c9) := h_integrable j\n                            -- Use the fact that the product of two integrable functions is integrable on a finite measure space\n                            have h\u2081\u2088 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => X i \u03c9 * X j \u03c9) := by\n                              -- Use the fact that the product of two integrable functions is integrable on a finite measure space\n                              exact MeasureTheory.Integrable.mul h\u2081\u2086 h\u2081\u2087\n                            exact h\u2081\u2088\n                          contradiction\n                        contradiction\n                      exact h\u2081\u2080\n                  exact h\u2088\n                exact h\u2087\n              rw [h\u2086]\n              <;> simp [Finset.sum_mul, Finset.mul_sum]\n              <;> rw [Finset.sum_comm]\n              <;> simp [mul_assoc, mul_comm, mul_left_comm]\n          <;> simp_all [Finset.sum_mul, Finset.mul_sum]\n          <;> rw [Finset.sum_comm]\n          <;> simp_all [mul_assoc, mul_comm, mul_left_comm]\n        rw [h\u2084]\n        <;> simp [Finset.sum_mul, Finset.mul_sum]\n        <;> rw [Finset.sum_comm]\n        <;> simp [mul_assoc, mul_comm, mul_left_comm]\n  \n  have h_sum_sq_integral : (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc)^2 = \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := by\n    have h\u2081 : (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc) = \u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc := by\n      -- Prove that the integral of the sum is the sum of the integrals\n      calc\n        (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc) = \u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc := rfl\n        _ = \u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc := by\n          -- Use the linearity of the integral\n          have h\u2082 : \u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc = \u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc := by\n            apply MeasureTheory.integral_finset_sum\n            intro i _\n            exact h_integrable i\n          rw [h\u2082]\n    calc\n      (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc) ^ 2 = (\u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc) ^ 2 := by rw [h\u2081]\n      _ = (\u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc) := by ring\n      _ = \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := by\n        -- Expand the product of sums into a double sum\n        calc\n          (\u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u2211 i : Fin n, \u222b \u03c9, X i \u03c9 \u2202\u03bc) = \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := by\n            simp [Finset.sum_mul, Finset.mul_sum]\n            <;>\n            rw [Finset.sum_comm]\n          _ = \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := by rfl\n  \n  have h_main : \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc)^2 = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n    calc\n      \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc)^2 = (\u2211 i : Fin n, \u2211 j : Fin n, \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc) - (\u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n        rw [h_sum_sq_expansion, h_sum_sq_integral]\n      _ = \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n        simp [Finset.sum_sub_distrib]\n      _ = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n        calc\n          \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 i : Fin n, \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := rfl\n          _ = \u2211 i : Fin n, (\u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) := by simp [Finset.sum_sigma']\n          _ = \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) + \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) := by\n            apply Finset.sum_congr rfl\n            intro i _\n            have h\u2083 : \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) + \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n              have h\u2084 : \u2211 j : Fin n, (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 j in (Finset.univ : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by simp\n              rw [h\u2084]\n              have h\u2085 : \u2211 j in (Finset.univ : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 j in ({i} : Finset (Fin n)) \u222a ((Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n))), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n                congr 1\n                <;> simp [Finset.ext_iff]\n                <;> aesop\n              rw [h\u2085]\n              have h\u2086 : ({i} : Finset (Fin n)) \u2229 ((Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n))) = \u2205 := by\n                simp [Finset.ext_iff]\n                <;> aesop\n              rw [Finset.sum_union] <;> simp_all [Finset.disjoint_left]\n              <;> aesop\n            rw [h\u2083]\n          _ = \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) + \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) := rfl\n          _ = \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) + \u2211 i : Fin n, \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := by\n            simp [Finset.sum_add_distrib]\n          _ = \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) + \u2211 i : Fin n, \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := rfl\n          _ = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n            have h\u2083 : \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n              apply Finset.sum_congr rfl\n              intro i _\n              have h\u2084 : \u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n                calc\n                  \u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u222b \u03c9, X i \u03c9 * X i \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X i \u03c9 \u2202\u03bc) := by\n                    simp [Finset.sum_singleton]\n                    <;> ring_nf\n                  _ = \u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2 := by\n                    have h\u2085 : \u222b \u03c9, X i \u03c9 * X i \u03c9 \u2202\u03bc = \u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc := by\n                      congr\n                      ext \u03c9\n                      <;> ring\n                    have h\u2086 : (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X i \u03c9 \u2202\u03bc) = (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2 := by ring\n                    rw [h\u2085, h\u2086]\n                    <;> ring_nf\n              rw [h\u2084]\n            have h\u2084 : \u2211 i : Fin n, \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = 0 := by\n              have h\u2085 : \u2200 (i : Fin n), \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = 0 := by\n                intro i\n                calc\n                  \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) := rfl\n                  _ = 0 := by\n                    apply Finset.sum_eq_zero\n                    intro j hj\n                    have h\u2086 : j \u2260 i := by\n                      simp only [Finset.mem_sdiff, Finset.mem_singleton] at hj\n                      tauto\n                    have h\u2087 : \u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc = (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc) := by\n                      apply h_uncorr i j h\u2086\n                    rw [h\u2087]\n                    <;> ring_nf\n                    <;> simp_all\n              calc\n                \u2211 i : Fin n, \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 i : Fin n, 0 := by\n                  apply Finset.sum_congr rfl\n                  intro i _\n                  rw [h\u2085 i]\n                _ = 0 := by simp\n            calc\n              \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) + \u2211 i : Fin n, \u2211 j in (Finset.univ : Finset (Fin n)) \\ ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc)) = \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) + 0 := by\n                rw [h\u2084]\n              _ = \u2211 i : Fin n, (\u2211 j in ({i} : Finset (Fin n)), (\u222b \u03c9, X i \u03c9 * X j \u03c9 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc) * (\u222b \u03c9, X j \u03c9 \u2202\u03bc))) := by simp\n              _ = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by rw [h\u2083]\n      _ = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by rfl\n  \n  have h\u2080 : \u222b \u03c9, (\u2211 i : Fin n, X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, \u2211 i : Fin n, X i \u03c9 \u2202\u03bc)^2 = \u2211 i : Fin n, (\u222b \u03c9, (X i \u03c9)^2 \u2202\u03bc - (\u222b \u03c9, X i \u03c9 \u2202\u03bc)^2) := by\n    apply h_main\n  \n  exact h\u2080", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 5, "column": 35, "endLine": 5, "endColumn": 49, "data": "invalid binder annotation, type is not a class instance\n  ?m.18\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Therefore, by combining the last two results, we get $Var(\\bar{X}_n) = \\frac{1}{n^2} \\sum_{i=1}^n Var(X_i)$.", "statement": "We assume:\n\u2022 $Var(\\bar{X}_n) = \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i\\right)$ [l2]\n\u2022 $Var\\left(\\sum_{i=1}^n X_i\\right) = \\sum_{i=1}^n Var(X_i)$ [l3].\nTherefore, we conclude:\n\u2022 $Var(\\bar{X}_n) = \\frac{1}{n^2} \\sum_{i=1}^n Var(X_i)$ [l4].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem sample_mean_variance (n : \u2115) (hn : 0 < n) \n  (X : Fin n \u2192 \u211d) (\u03bc \u03c3 : \u211d) \n  (h\u03bc : \u2200 i, X i = \u03bc) \n  (h\u03c3 : \u2200 i, (X i - \u03bc)^2 = \u03c3^2)\n  (huncorr : \u2200 i j, i \u2260 j \u2192 (X i - \u03bc) * (X j - \u03bc) = 0) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  (sample_mean - \u03bc)^2 = (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2)\n  := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem sample_mean_variance (n : \u2115) (hn : 0 < n) \n  (X : Fin n \u2192 \u211d) (\u03bc \u03c3 : \u211d) \n  (h\u03bc : \u2200 i, X i = \u03bc) \n  (h\u03c3 : \u2200 i, (X i - \u03bc)^2 = \u03c3^2)\n  (huncorr : \u2200 i j, i \u2260 j \u2192 (X i - \u03bc) * (X j - \u03bc) = 0) :\n  let sample_mean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  (sample_mean - \u03bc)^2 = (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2)\n  := by\n  intro sample_mean\n  have h_sum_X : (\u2211 i : Fin n, X i) = (n : \u211d) * \u03bc := by\n    calc\n      (\u2211 i : Fin n, X i) = \u2211 i : Fin n, \u03bc := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u03bc i]\n      _ = (n : \u211d) * \u03bc := by\n        simp [Finset.sum_const, Finset.card_fin]\n        <;> ring_nf\n        <;> field_simp [hn.ne']\n        <;> ring_nf\n  \n  have h_sample_mean : sample_mean = \u03bc := by\n    dsimp [sample_mean]\n    rw [h_sum_X]\n    field_simp [hn.ne']\n    <;> ring_nf\n    <;> field_simp [hn.ne']\n    <;> linarith\n  \n  have h_sample_mean_sq : (sample_mean - \u03bc)^2 = 0 := by\n    rw [h_sample_mean]\n    ring_nf\n    <;> simp [pow_two]\n    <;> ring_nf\n    <;> linarith\n  \n  have h_sum_sq_zero : (\u2211 i : Fin n, (X i - \u03bc)^2) = 0 := by\n    have h\u2081 : \u2200 i : Fin n, (X i - \u03bc)^2 = 0 := by\n      intro i\n      have h\u2082 : X i = \u03bc := h\u03bc i\n      have h\u2083 : (X i - \u03bc)^2 = 0 := by\n        rw [h\u2082]\n        ring_nf\n        <;> simp [pow_two]\n        <;> linarith\n      exact h\u2083\n    calc\n      (\u2211 i : Fin n, (X i - \u03bc)^2) = \u2211 i : Fin n, 0 := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u2081 i]\n      _ = 0 := by simp [Finset.sum_const]\n  \n  have h_rhs_zero : (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2) = 0 := by\n    rw [h_sum_sq_zero]\n    <;> ring_nf\n    <;> simp [hn.ne']\n    <;> field_simp [hn.ne']\n    <;> ring_nf\n    <;> linarith\n  \n  have h_main : (sample_mean - \u03bc)^2 = (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i - \u03bc)^2) := by\n    rw [h_sample_mean_sq, h_rhs_zero]\n    <;> simp_all\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization fundamentally misrepresents the natural language content. The natural language discusses variance properties of random variables and sample means in a probabilistic setting, with explicit assumptions about variance operators (Var(X\u0304\u2099) = (1/n\u00b2)Var(\u2211X\u1d62) and Var(\u2211X\u1d62) = \u2211Var(X\u1d62)). However, the Lean code treats X as deterministic functions with all values equal to \u03bc, completely eliminating the randomness and variance concepts. The assumptions about variance relationships (l2 and l3) are not formalized at all. Instead, the Lean code proves a deterministic relationship about squared deviations under very restrictive conditions that don't capture the probabilistic nature of the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization fundamentally misrepresents the natural language content. The natural language discusses variance properties of random variables and sample means in a probabilistic setting, with explicit assumptions about variance operators (Var(X\u0304\u2099) = (1/n\u00b2)Var(\u2211X\u1d62) and Var(\u2211X\u1d62) = \u2211Var(X\u1d62)). However, the Lean code treats X as deterministic functions with all values equal to \u03bc, completely eliminating the randomness and variance concepts. The assumptions about variance relationships (l2 and l3) are not formalized at all. Instead, the Lean code proves a deterministic relationship about squared deviations under very restrictive conditions that don't capture the probabilistic nature of the original statement.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Using the given condition $Var(X_i) = \\sigma^2$, we calculate the final variance: $Var(\\bar{X}_n) = \\frac{1}{n^2} \\sum_{i=1}^n \\sigma^2 = \\frac{\\sigma^2}{n}$.", "statement": "We assume:\n\u2022 For each $i$ from 1 to $n$, the variance is $Var(X_i) = \\sigma^2$ [tc_3]\n\u2022 $Var(\\bar{X}_n) = \\frac{1}{n^2} \\sum_{i=1}^n Var(X_i)$ [l4].\nTherefore, we conclude:\n\u2022 $Var(\\bar{X}_n) = \\frac{\\sigma^2}{n}$ [ts_2].", "dependencies": ["tc_3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 (n : \u2115) (hn : 0 < n) (\u03c3 : \u211d) \n  (h_sum : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 \n    (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i)^2) = \u03c3^2 / (n : \u211d))\n  (h_variance : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 \n    (\u2211 i : Fin n, (X i)^2) = n * \u03c3^2) :\n  \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 \n    (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i)^2) = \u03c3^2 / (n : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 (n : \u2115) (hn : 0 < n) (\u03c3 : \u211d) \n  (h_sum : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 \n    (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i)^2) = \u03c3^2 / (n : \u211d))\n  (h_variance : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 \n    (\u2211 i : Fin n, (X i)^2) = n * \u03c3^2) :\n  \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 \n    (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i)^2) = \u03c3^2 / (n : \u211d) := by\n  have h_main : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i)^2 = \u03c3^2) \u2192 (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i)^2) = \u03c3^2 / (n : \u211d) := by\n    intro X hX\n    have h\u2081 : (1 / (n : \u211d)^2) * (\u2211 i : Fin n, (X i)^2) = \u03c3^2 / (n : \u211d) := by\n      apply h_sum X hX\n    exact h\u2081\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has major mathematical errors. It misrepresents variance as (X i)^2 = \u03c3^2 instead of properly modeling Var(X_i) = \u03c3^2. The code completely misses the concept of sample mean X\u0304_n, which is central to the natural language statement. The mathematical relationship being proven is fundamentally different from what's described in natural language - the Lean code deals with deterministic constraints on individual values rather than variance properties of random variables and their sample mean. The theorem is also trivial since the conclusion is identical to one of the hypotheses."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has major mathematical errors. It misrepresents variance as (X i)^2 = \u03c3^2 instead of properly modeling Var(X_i) = \u03c3^2. The code completely misses the concept of sample mean X\u0304_n, which is central to the natural language statement. The mathematical relationship being proven is fundamentally different from what's described in natural language - the Lean code deals with deterministic constraints on individual values rather than variance properties of random variables and their sample mean. The theorem is also trivial since the conclusion is identical to one of the hypotheses.\"]"}, "solved_negation": null, "type": "solution"}, "l5": {"id": "l5", "natural_language": "We use the principle of Chebyshev's inequality, which states that for any random variable $Y$ with a finite mean $E[Y]$ and finite variance $Var(Y)$, the inequality $P(|Y - E[Y]| \\ge \\epsilon) \\le \\frac{Var(Y)}{\\epsilon^2}$ holds for any $\\epsilon > 0$.", "statement": "We assume:\n\u2022 Y is a random variable with a finite mean E[Y] and finite variance Var(Y), and \u03b5 > 0.\nTherefore, we conclude:\n\u2022 $P(|Y - E[Y]| \\ge \\epsilon) \\le \\frac{Var(Y)}{\\epsilon^2}$ [l5].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (Y : \u211d \u2192 \u211d) (P : \u211d \u2192 \u211d) (\u03bc \u03c3 : \u211d) (\u03b5 : \u211d) \n  (hP_nonneg : \u2200 x, P x \u2265 0) \n  (hP_sum : \u222b x, P x = 1)\n  (h_mean : \u222b x, Y x * P x = \u03bc)\n  (h_var : \u222b x, (Y x - \u03bc)^2 * P x = \u03c3^2) \n  (h\u03b5 : \u03b5 > 0) :\n  \u222b x, (|Y x - \u03bc| \u2265 \u03b5) * P x \u2264 \u03c3^2 / \u03b5^2 := by sorry", "lean_pass": false, "error_msg": [{"line": 13, "column": 7, "endLine": 13, "endColumn": 28, "data": "failed to synthesize\n  HMul Prop \u211d ?m.2426\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib.MeasureTheory.Integral.Integral\nimport Mathlib.MeasureTheory.Integral.SetIntegral\n\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (Y : \u211d \u2192 \u211d) (P : \u211d \u2192 \u211d) (\u03bc \u03c3 : \u211d) (\u03b5 : \u211d) \n  (hP_nonneg : \u2200 x, P x \u2265 0) \n  (hP_sum : \u222b x, P x = 1)\n  (h_mean : \u222b x, Y x * P x = \u03bc)\n  (h_var : \u222b x, (Y x - \u03bc)^2 * P x = \u03c3^2) \n  (h\u03b5 : \u03b5 > 0) :\n  \u222b x, (|Y x - \u03bc| \u2265 \u03b5) * P x \u2264 \u03c3^2 / \u03b5^2 := by\n  have h_main_ineq : \u2200 (t : \u211d), (if |t - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) \u2264 (t - \u03bc)^2 / \u03b5^2 := by\n    intro t\n    split_ifs with h\n    \u00b7 -- Case: |t - \u03bc| \u2265 \u03b5\n      have h\u2081 : (t - \u03bc) ^ 2 \u2265 \u03b5 ^ 2 := by\n        have h\u2082 : |t - \u03bc| \u2265 \u03b5 := h\n        have h\u2083 : (t - \u03bc) ^ 2 \u2265 \u03b5 ^ 2 := by\n          cases' abs_cases (t - \u03bc) with h\u2084 h\u2084 <;> nlinarith [sq_nonneg (t - \u03bc)]\n        exact h\u2083\n      have h\u2082 : (t - \u03bc : \u211d) ^ 2 / \u03b5 ^ 2 \u2265 1 := by\n        have h\u2083 : (\u03b5 : \u211d) > 0 := by exact_mod_cast h\u03b5\n        have h\u2084 : (\u03b5 : \u211d) ^ 2 > 0 := by positivity\n        have h\u2085 : (t - \u03bc : \u211d) ^ 2 \u2265 \u03b5 ^ 2 := by exact_mod_cast h\u2081\n        have h\u2086 : (t - \u03bc : \u211d) ^ 2 / \u03b5 ^ 2 \u2265 1 := by\n          rw [ge_iff_le]\n          rw [le_div_iff (by positivity)]\n          nlinarith\n        exact h\u2086\n      -- Since (if |t - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) = 1, we need to show 1 \u2264 (t - \u03bc)^2 / \u03b5^2\n      linarith\n    \u00b7 -- Case: |t - \u03bc| < \u03b5\n      have h\u2081 : \u00ac(|t - \u03bc| \u2265 \u03b5) := by simpa using h\n      have h\u2082 : (t - \u03bc : \u211d) ^ 2 / \u03b5 ^ 2 \u2265 0 := by\n        have h\u2083 : (\u03b5 : \u211d) > 0 := by exact_mod_cast h\u03b5\n        have h\u2084 : (\u03b5 : \u211d) ^ 2 > 0 := by positivity\n        have h\u2085 : (t - \u03bc : \u211d) ^ 2 \u2265 0 := by positivity\n        positivity\n      -- Since (if |t - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) = 0, we need to show 0 \u2264 (t - \u03bc)^2 / \u03b5^2\n      linarith\n  \n  have h_pointwise_ineq : \u2200 (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x \u2264 (Y x - \u03bc)^2 / \u03b5^2 * P x := by\n    intro x\n    have h\u2081 : (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) \u2264 (Y x - \u03bc)^2 / \u03b5^2 := h_main_ineq (Y x)\n    have h\u2082 : 0 \u2264 P x := hP_nonneg x\n    have h\u2083 : (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x \u2264 (Y x - \u03bc)^2 / \u03b5^2 * P x := by\n      nlinarith [h\u2081, h\u2082]\n    exact h\u2083\n  \n  have hP_integrable : Integrable P := by\n    have h\u2081 : \u222b x : \u211d, P x = 1 := hP_sum\n    have h\u2082 : Integrable P := by\n      apply integral_integrable\n      <;> simp_all\n    exact h\u2082\n  \n  have h_YsqP_integrable : Integrable (fun x => (Y x - \u03bc)^2 * P x) := by\n    have h\u2081 : \u222b x : \u211d, (Y x - \u03bc)^2 * P x = \u03c3^2 := h_var\n    have h\u2082 : Integrable (fun x : \u211d => (Y x - \u03bc)^2 * P x) := by\n      apply integral_integrable\n      <;> simp_all\n    exact h\u2082\n  \n  have h_rhs_integrable : Integrable (fun x => (Y x - \u03bc)^2 / \u03b5^2 * P x) := by\n    have h\u2081 : Integrable (fun x : \u211d => (Y x - \u03bc)^2 * P x) := h_YsqP_integrable\n    have h\u2082 : (fun x : \u211d => (Y x - \u03bc)^2 / \u03b5^2 * P x) = (fun x : \u211d => (1 / \u03b5 ^ 2 : \u211d) * ((Y x - \u03bc) ^ 2 * P x)) := by\n      funext x\n      ring\n      <;> field_simp [h\u03b5.ne']\n      <;> ring\n    rw [h\u2082]\n    -- Use the fact that multiplying by a constant preserves integrability\n    apply Integrable.mul_left\n    exact h\u2081\n  \n  have h_lhs_integrable : Integrable (fun x => (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x) := by\n    have h\u2081 : \u2200 x : \u211d, 0 \u2264 P x := hP_nonneg\n    have h\u2082 : Integrable P := hP_integrable\n    have h\u2083 : \u2200 x : \u211d, (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x \u2264 P x := by\n      intro x\n      split_ifs with h\n      \u00b7 -- Case: |Y x - \u03bc| \u2265 \u03b5\n        have h\u2084 : (1 : \u211d) * P x \u2264 P x := by\n          nlinarith [h\u2081 x]\n        nlinarith [h\u2081 x]\n      \u00b7 -- Case: |Y x - \u03bc| < \u03b5\n        have h\u2084 : (0 : \u211d) * P x \u2264 P x := by\n          nlinarith [h\u2081 x]\n        nlinarith [h\u2081 x]\n    -- Use the comparison test to show integrability\n    have h\u2084 : Integrable (fun x : \u211d => (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x) := by\n      refine' Integrable.of_nonneg_of_le (fun x => _) (fun x => _) h\u2082\n      \u00b7 -- Show that the function is non-negative\n        split_ifs with h\n        \u00b7 -- Case: |Y x - \u03bc| \u2265 \u03b5\n          nlinarith [h\u2081 x]\n        \u00b7 -- Case: |Y x - \u03bc| < \u03b5\n          nlinarith [h\u2081 x]\n      \u00b7 -- Show that the function is bounded by P x\n        exact h\u2083 x\n    exact h\u2084\n  \n  have h_integral_ineq : \u222b x, (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x \u2264 \u222b x, (Y x - \u03bc)^2 / \u03b5^2 * P x := by\n    have h\u2081 : \u2200 x, (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x \u2264 (Y x - \u03bc)^2 / \u03b5^2 * P x := h_pointwise_ineq\n    have h\u2082 : Integrable (fun x => (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x) := h_lhs_integrable\n    have h\u2083 : Integrable (fun x => (Y x - \u03bc)^2 / \u03b5^2 * P x) := h_rhs_integrable\n    -- Use the fact that the integral of a non-negative function bounded by an integrable function is bounded by the integral of that function\n    have h\u2084 : \u222b x, (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x \u2264 \u222b x, (Y x - \u03bc)^2 / \u03b5^2 * P x := by\n      -- Use the integral_mono lemma to compare the integrals\n      refine' integral_mono h\u2082 h\u2083 _\n      intro x\n      exact h\u2081 x\n    exact h\u2084\n  \n  have h_integral_rhs : \u222b x, (Y x - \u03bc)^2 / \u03b5^2 * P x = (\u222b x, (Y x - \u03bc)^2 * P x) / \u03b5^2 := by\n    have h\u2081 : \u222b x : \u211d, (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x = (\u222b x : \u211d, (Y x - \u03bc) ^ 2 * P x) / \u03b5 ^ 2 := by\n      have h\u2082 : \u222b x : \u211d, (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x = \u222b x : \u211d, (1 / \u03b5 ^ 2 : \u211d) * ((Y x - \u03bc) ^ 2 * P x) := by\n        congr\n        ext x\n        ring_nf\n        <;> field_simp [h\u03b5.ne']\n        <;> ring_nf\n      rw [h\u2082]\n      have h\u2083 : \u222b x : \u211d, (1 / \u03b5 ^ 2 : \u211d) * ((Y x - \u03bc) ^ 2 * P x) = (1 / \u03b5 ^ 2 : \u211d) * \u222b x : \u211d, (Y x - \u03bc) ^ 2 * P x := by\n        -- Use the property of integrals to factor out the constant\n        have h\u2084 : \u222b x : \u211d, (1 / \u03b5 ^ 2 : \u211d) * ((Y x - \u03bc) ^ 2 * P x) = (1 / \u03b5 ^ 2 : \u211d) * \u222b x : \u211d, (Y x - \u03bc) ^ 2 * P x := by\n          -- Use the linearity of the integral to factor out the constant\n          rw [integral_mul_left]\n          <;>\n          (try norm_num) <;>\n          (try simp_all [hP_nonneg]) <;>\n          (try positivity)\n          <;>\n          (try\n            {\n              -- Prove that (Y x - \u03bc)^2 * P x is integrable\n              have h\u2085 : Integrable (fun x : \u211d => (Y x - \u03bc) ^ 2 * P x) := h_YsqP_integrable\n              exact h\u2085\n            })\n          <;>\n          (try\n            {\n              -- Prove that P x is integrable\n              have h\u2085 : Integrable P := hP_integrable\n              exact h\u2085\n            })\n          <;>\n          (try\n            {\n              -- Prove that Y x * P x is integrable\n              have h\u2085 : Integrable (fun x : \u211d => Y x * P x) := by\n                have h\u2086 : \u222b x : \u211d, Y x * P x = \u03bc := h_mean\n                have h\u2087 : Integrable (fun x : \u211d => Y x * P x) := by\n                  apply integral_integrable\n                  <;> simp_all\n                exact h\u2087\n              exact h\u2085\n            })\n        rw [h\u2084]\n      rw [h\u2083]\n      <;> field_simp [h\u03b5.ne']\n      <;> ring_nf\n      <;> simp_all [hP_nonneg]\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try positivity)\n    rw [h\u2081]\n    <;> simp_all [hP_nonneg]\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try positivity)\n  \n  have h_final : \u222b x, (|Y x - \u03bc| \u2265 \u03b5) * P x \u2264 \u03c3^2 / \u03b5^2 := by\n    calc\n      \u222b x, (|Y x - \u03bc| \u2265 \u03b5) * P x = \u222b x, (if |Y x - \u03bc| \u2265 \u03b5 then (1 : \u211d) else 0) * P x := by\n        -- Use the fact that the integral of the indicator function is the same as the integral of the if-then-else expression\n        congr\n        ext x\n        by_cases h : |Y x - \u03bc| \u2265 \u03b5 <;> simp [h]\n        <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try positivity)\n      _ \u2264 \u222b x, (Y x - \u03bc)^2 / \u03b5^2 * P x := h_integral_ineq\n      _ = (\u222b x, (Y x - \u03bc)^2 * P x) / \u03b5^2 := by rw [h_integral_rhs]\n      _ = \u03c3^2 / \u03b5^2 := by\n        have h\u2081 : \u222b x, (Y x - \u03bc)^2 * P x = \u03c3^2 := h_var\n        rw [h\u2081]\n        <;> field_simp [h\u03b5.ne']\n        <;> ring_nf\n        <;> simp_all [hP_nonneg]\n        <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try positivity)\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 7, "endLine": 10, "endColumn": 28, "data": "failed to synthesize\n  HMul Prop \u211d ?m.2426\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 49, "column": 23, "endLine": 49, "endColumn": 33, "data": "unknown identifier 'Integrable'"}, {"line": 51, "column": 14, "endLine": 51, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 52, "column": 12, "endLine": 52, "endColumn": 31, "data": "unknown identifier 'integral_integrable'"}, {"line": 56, "column": 27, "endLine": 56, "endColumn": 37, "data": "unknown identifier 'Integrable'"}, {"line": 58, "column": 14, "endLine": 58, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 59, "column": 12, "endLine": 59, "endColumn": 31, "data": "unknown identifier 'integral_integrable'"}, {"line": 63, "column": 26, "endLine": 63, "endColumn": 36, "data": "unknown identifier 'Integrable'"}, {"line": 64, "column": 14, "endLine": 64, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 70, "column": 8, "endLine": 70, "endColumn": 10, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  fun x => (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nY P : \u211d \u2192 \u211d\n\u03bc \u03c3 \u03b5 : \u211d\nhP_nonneg : \u2200 (x : \u211d), P x \u2265 0\nhP_sum : \u222b (x : \u211d), P x = 1\nh_mean : \u222b (x : \u211d), Y x * P x = \u03bc\nh_var : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x = \u03c3 ^ 2\nh\u03b5 : \u03b5 > 0\nh_main_ineq : \u2200 (t : \u211d), (if |t - \u03bc| \u2265 \u03b5 then 1 else 0) \u2264 (t - \u03bc) ^ 2 / \u03b5 ^ 2\nh_pointwise_ineq : \u2200 (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nhP_integrable : sorry\nh_YsqP_integrable h\u2081 : sorry\nh\u2082 : (fun x => (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x) = fun x => 1 / \u03b5 ^ 2 * ((Y x - \u03bc) ^ 2 * P x)\n\u22a2 sorry"}, {"line": 75, "column": 26, "endLine": 75, "endColumn": 36, "data": "unknown identifier 'Integrable'"}, {"line": 77, "column": 14, "endLine": 77, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 90, "column": 14, "endLine": 90, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 91, "column": 14, "endLine": 91, "endColumn": 40, "data": "unknown identifier 'Integrable.of_nonneg_of_le'"}, {"line": 92, "column": 6, "endLine": 97, "endColumn": 26, "data": "no goals to be solved"}, {"line": 104, "column": 14, "endLine": 104, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 105, "column": 14, "endLine": 105, "endColumn": 24, "data": "unknown identifier 'Integrable'"}, {"line": 109, "column": 14, "endLine": 109, "endColumn": 27, "data": "unknown identifier 'integral_mono'"}, {"line": 110, "column": 6, "endLine": 110, "endColumn": 13, "data": "no goals to be solved"}, {"line": 127, "column": 14, "endLine": 127, "endColumn": 31, "data": "unknown identifier 'integral_mul_left'"}, {"line": 127, "column": 14, "endLine": 127, "endColumn": 31, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.85938\nY P : \u211d \u2192 \u211d\n\u03bc \u03c3 \u03b5 : \u211d\nhP_nonneg : \u2200 (x : \u211d), P x \u2265 0\nhP_sum : \u222b (x : \u211d), P x = 1\nh_mean : \u222b (x : \u211d), Y x * P x = \u03bc\nh_var : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x = \u03c3 ^ 2\nh\u03b5 : \u03b5 > 0\nh_main_ineq : \u2200 (t : \u211d), (if |t - \u03bc| \u2265 \u03b5 then 1 else 0) \u2264 (t - \u03bc) ^ 2 / \u03b5 ^ 2\nh_pointwise_ineq : \u2200 (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nhP_integrable : sorry\nh_YsqP_integrable : sorry\nh_rhs_integrable : sorry\nh_lhs_integrable : sorry\nh_integral_ineq : \u222b (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 \u222b (x : \u211d), (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nh\u2082 : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x = \u222b (x : \u211d), 1 / \u03b5 ^ 2 * ((Y x - \u03bc) ^ 2 * P x)\n\u22a2 \u222b (x : \u211d), 1 / \u03b5 ^ 2 * ((Y x - \u03bc) ^ 2 * P x) = 1 / \u03b5 ^ 2 * \u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x"}, {"line": 174, "column": 22, "endLine": 174, "endColumn": 43, "data": "failed to synthesize\n  HMul Prop \u211d ?m.94050\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 176, "column": 11, "endLine": 176, "endColumn": 32, "data": "failed to synthesize\n  HMul Prop \u211d ?m.96543\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 176, "column": 88, "endLine": 184, "endColumn": 24, "data": "unsolved goals\ncase pos\nY P : \u211d \u2192 \u211d\n\u03bc \u03c3 \u03b5 : \u211d\nhP_nonneg : \u2200 (x : \u211d), P x \u2265 0\nhP_sum : \u222b (x : \u211d), P x = 1\nh_mean : \u222b (x : \u211d), Y x * P x = \u03bc\nh_var : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x = \u03c3 ^ 2\nh\u03b5 : \u03b5 > 0\nh_main_ineq : \u2200 (t : \u211d), (if |t - \u03bc| \u2265 \u03b5 then 1 else 0) \u2264 (t - \u03bc) ^ 2 / \u03b5 ^ 2\nh_pointwise_ineq : \u2200 (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nhP_integrable : sorry\nh_YsqP_integrable : sorry\nh_rhs_integrable : sorry\nh_lhs_integrable : sorry\nh_integral_ineq : \u222b (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 \u222b (x : \u211d), (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nh_integral_rhs : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x = (\u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x) / \u03b5 ^ 2\nx : \u211d\nh : |Y x - \u03bc| \u2265 \u03b5\n\u22a2 sorry = P x\n\ncase neg\nY P : \u211d \u2192 \u211d\n\u03bc \u03c3 \u03b5 : \u211d\nhP_nonneg : \u2200 (x : \u211d), P x \u2265 0\nhP_sum : \u222b (x : \u211d), P x = 1\nh_mean : \u222b (x : \u211d), Y x * P x = \u03bc\nh_var : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x = \u03c3 ^ 2\nh\u03b5 : \u03b5 > 0\nh_main_ineq : \u2200 (t : \u211d), (if |t - \u03bc| \u2265 \u03b5 then 1 else 0) \u2264 (t - \u03bc) ^ 2 / \u03b5 ^ 2\nh_pointwise_ineq : \u2200 (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nhP_integrable : sorry\nh_YsqP_integrable : sorry\nh_rhs_integrable : sorry\nh_lhs_integrable : sorry\nh_integral_ineq : \u222b (x : \u211d), (if |Y x - \u03bc| \u2265 \u03b5 then 1 else 0) * P x \u2264 \u222b (x : \u211d), (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x\nh_integral_rhs : \u222b (x : \u211d), (Y x - \u03bc) ^ 2 / \u03b5 ^ 2 * P x = (\u222b (x : \u211d), (Y x - \u03bc) ^ 2 * P x) / \u03b5 ^ 2\nx : \u211d\nh : \u00ac|Y x - \u03bc| \u2265 \u03b5\n\u22a2 sorry = 0"}], "tries": 4}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_3": {"id": "ts_3", "natural_language": "By applying this principle to the random variable $Y = \\bar{X}_n$ and substituting our previously derived results for its mean and variance, we conclude that $P(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le \\frac{\\sigma^2}{n\\epsilon^2}$.", "statement": "We assume:\n\u2022 $E[\\bar{X}_n] = \\mu$ [ts_1]\n\u2022 $Var(\\bar{X}_n) = \\frac{\\sigma^2}{n}$ [ts_2]\n\u2022 $\\epsilon$ is a real number such that $\\epsilon > 0$ [tc_4]\n\u2022 For any random variable Y with a finite mean E[Y] and finite variance Var(Y), and \u03b5 > 0, the inequality $P(|Y - E[Y]| \\ge \\epsilon) \\le \\frac{Var(Y)}{\\epsilon^2}$ holds [l5].\nTherefore, we conclude:\n\u2022 $P(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le \\frac{\\sigma^2}{n\\epsilon^2}$ [ts_3].", "dependencies": ["ts_1", "ts_2", "tc_4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 \n  {n : \u2115} (hn : 0 < n)\n  (\u03bc \u03c3 : \u211d)\n  (\u03b5 : \u211d) (h_\u03b5 : 0 < \u03b5)\n  (ts_1 : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, X i = \u03bc) \u2192 \n    (1 / (n : \u211d)) * (\u2211 i : Fin n, X i) = \u03bc)\n  (ts_2 : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i - \u03bc)^2 = \u03c3^2) \u2192 \n    ((1 / (n : \u211d)) * (\u2211 i : Fin n, X i) - \u03bc)^2 = \u03c3^2 / (n : \u211d))\n  (l5 : \u2200 (Y : \u211d) (EY VarY : \u211d) (h\u03b5 : 0 < \u03b5),\n    |Y - EY| \u2265 \u03b5 \u2192 (Y - EY)^2 \u2265 \u03b5^2 \u2227 \n    (1 / \u03b5^2) * (Y - EY)^2 \u2264 VarY / \u03b5^2) :\n  \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, X i = \u03bc) \u2192 \n    \u2200 (X_var : Fin n \u2192 \u211d), (\u2200 i, (X_var i)^2 = \u03c3^2) \u2192\n    (1 / \u03b5^2) * (\u03c3^2 / (n : \u211d)) \u2264 \u03c3^2 / (n : \u211d) * (1 / \u03b5^2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 \n  {n : \u2115} (hn : 0 < n)\n  (\u03bc \u03c3 : \u211d)\n  (\u03b5 : \u211d) (h_\u03b5 : 0 < \u03b5)\n  (ts_1 : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, X i = \u03bc) \u2192 \n    (1 / (n : \u211d)) * (\u2211 i : Fin n, X i) = \u03bc)\n  (ts_2 : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, (X i - \u03bc)^2 = \u03c3^2) \u2192 \n    ((1 / (n : \u211d)) * (\u2211 i : Fin n, X i) - \u03bc)^2 = \u03c3^2 / (n : \u211d))\n  (l5 : \u2200 (Y : \u211d) (EY VarY : \u211d) (h\u03b5 : 0 < \u03b5),\n    |Y - EY| \u2265 \u03b5 \u2192 (Y - EY)^2 \u2265 \u03b5^2 \u2227 \n    (1 / \u03b5^2) * (Y - EY)^2 \u2264 VarY / \u03b5^2) :\n  \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, X i = \u03bc) \u2192 \n    \u2200 (X_var : Fin n \u2192 \u211d), (\u2200 i, (X_var i)^2 = \u03c3^2) \u2192\n    (1 / \u03b5^2) * (\u03c3^2 / (n : \u211d)) \u2264 \u03c3^2 / (n : \u211d) * (1 / \u03b5^2) := by\n  have h_main : \u2200 (X : Fin n \u2192 \u211d), (\u2200 i, X i = \u03bc) \u2192 \u2200 (X_var : Fin n \u2192 \u211d), (\u2200 i, (X_var i)^2 = \u03c3^2) \u2192 (1 / \u03b5^2) * (\u03c3^2 / (n : \u211d)) \u2264 \u03c3^2 / (n : \u211d) * (1 / \u03b5^2) := by\n    intro X hX X_var hX_var\n    have h\u2081 : (1 / \u03b5 ^ 2 : \u211d) * (\u03c3 ^ 2 / (n : \u211d)) = (\u03c3 ^ 2 / (n : \u211d)) * (1 / \u03b5 ^ 2 : \u211d) := by\n      ring\n    -- Since the two sides are equal, the inequality follows trivially.\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable setup is reasonable, though the Lean version uses deterministic rather than probabilistic variables.", "ts_1 captures a deterministic version of the expectation property but misses the probabilistic nature of the original statement about expected values.", "ts_2 incorrectly formalizes the variance concept. It relates individual observation variances to a squared deviation rather than properly expressing the variance of the sample mean.", "l5 completely misses the probabilistic nature of Chebyshev's inequality. The original is a probability bound, but the Lean version gives a deterministic implication about squared terms.", "The conclusion ts_3 abandons the probabilistic statement entirely and reduces to a trivial algebraic commutativity property, missing the core probabilistic bound that was supposed to be proven."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable setup is reasonable, though the Lean version uses deterministic rather than probabilistic variables.', 'ts_1 captures a deterministic version of the expectation property but misses the probabilistic nature of the original statement about expected values.', 'ts_2 incorrectly formalizes the variance concept. It relates individual observation variances to a squared deviation rather than properly expressing the variance of the sample mean.', \"l5 completely misses the probabilistic nature of Chebyshev's inequality. The original is a probability bound, but the Lean version gives a deterministic implication about squared terms.\", 'The conclusion ts_3 abandons the probabilistic statement entirely and reduces to a trivial algebraic commutativity property, missing the core probabilistic bound that was supposed to be proven.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_3", "label": "ts_3", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    