
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $C$ be the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 2+i$, and let the function to be integrated be $f(z) = \operatorname{Re}(z)$. Then the contour integral $\int_C f(z) dz$ is equal to $2+i$.

Proof: The path $C$ from $z_1=0$ to $z_2=2+i$ can be parameterized by $z(t) = t(2+i)$ for $t \in [0, 1]$. From this, the differential is $dz = (2+i)dt$. The integrand $f(z) = \operatorname{Re}(z)$ becomes $\operatorname{Re}(t(2+i)) = 2t$ along the path. Substituting these into the integral gives $\int_0^1 (2t)(2+i)dt$. Evaluating this integral results in $(2+i) \int_0^1 2t dt = (2+i) [t^2]_0^1 = 2+i$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $C$ be the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 2+i$, and let the function to be integrated be $f(z) = \\operatorname{Re}(z)$.", "statement": "Premise:\n\u2022 $C$ is the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 2+i$ and the function to be integrated is $f(z) = \\operatorname{Re}(z)$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u222b t in (0 : \u211d)..1, (t \u2022 (2 + I)).re * Complex.abs (2 + I) = 2 + I := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean parameterization t \u2022 (2 + I) for t \u2208 [0,1] correctly represents the straight-line path from 0 to 2+i", "The Lean expression (t \u2022 (2 + I)).re correctly captures the real part function Re(z) applied to points on the path", "The natural language only establishes a premise with no conclusions, but the Lean theorem makes a specific claim that the integral equals 2 + I, which is not stated or derived in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean parameterization t \u2022 (2 + I) for t \u2208 [0,1] correctly represents the straight-line path from 0 to 2+i', 'The Lean expression (t \u2022 (2 + I)).re correctly captures the real part function Re(z) applied to points on the path', 'The natural language only establishes a premise with no conclusions, but the Lean theorem makes a specific claim that the integral equals 2 + I, which is not stated or derived in the natural language']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The path $C$ from $z_1=0$ to $z_2=2+i$ can be parameterized by $z(t) = t(2+i)$ for $t \\in [0, 1]$.", "statement": "We assume:\n\u2022 $C$ is the straight-line path from $z_1 = 0$ to $z_2 = 2+i$ [tc_1]\nDefinition:\n\u2022 The path $C$ is parameterized by $z(t) = t(2+i)$ for $t \\in [0, 1]$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 : \n  \u2203 z : \u211d \u2192 \u2102, \u2200 t \u2208 Set.Icc 0 1, z t = t \u2022 (2 + I) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization does not capture the condition that C is a straight-line path from z\u2081 = 0 to z\u2082 = 2+i. This condition is completely missing from the Lean statement, which only provides the parameterization without establishing the geometric constraint.", "The Lean conclusion perfectly matches the natural language. The existential quantification \u2203 z : \u211d \u2192 \u2102 establishes the parameterization, \u2200 t \u2208 Set.Icc 0 1 correctly represents t \u2208 [0,1], and t \u2022 (2 + I) is the correct Lean representation of t(2+i) using scalar multiplication."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization does not capture the condition that C is a straight-line path from z\u2081 = 0 to z\u2082 = 2+i. This condition is completely missing from the Lean statement, which only provides the parameterization without establishing the geometric constraint.', 'The Lean conclusion perfectly matches the natural language. The existential quantification \u2203 z : \u211d \u2192 \u2102 establishes the parameterization, \u2200 t \u2208 Set.Icc 0 1 correctly represents t \u2208 [0,1], and t \u2022 (2 + I) is the correct Lean representation of t(2+i) using scalar multiplication.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From this, the differential is $dz = (2+i)dt$.", "statement": "We assume:\n\u2022 The path $C$ is parameterized by $z(t) = t(2+i)$ for $t \\in [0, 1]$ [def_1]\nTherefore, we conclude:\n\u2022 The differential associated with the parameterization is $dz = z'(t)dt = (2+i)dt$ [l1].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (z : \u211d \u2192 \u2102) \n  (h_def_1 : \u2200 t \u2208 Set.Icc 0 1, z t = t \u2022 (2 + I)) :\n  \u2200 t \u2208 Set.Icc 0 1, deriv z t = 2 + I := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (z : \u211d \u2192 \u2102) \n  (h_def_1 : \u2200 t \u2208 Set.Icc 0 1, z t = t \u2022 (2 + I)) :\n  \u2200 t \u2208 Set.Icc 0 1, deriv z t = 2 + I := by\n  have h_main : \u2200 (t : \u211d), t \u2208 Set.Ioo 0 1 \u2192 deriv z t = 2 + I := by sorry\n  have h_counterexample : False := by sorry\n  have h_vacuous : \u2200 t \u2208 Set.Icc 0 1, deriv z t = 2 + I := by sorry\n  sorry", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The path parameterization is correctly formalized using scalar multiplication notation and the proper interval representation.", "The differential relationship is correctly captured by expressing the derivative as a constant complex number, which matches the mathematical meaning of dz = (2+i)dt.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem neg_l1 : \u00ac (\u2200 (z : \u211d \u2192 \u2102), (\u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + Complex.I)) \u2192 (\u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + Complex.I)) := by\n  have h_main : \u2203 (z : \u211d \u2192 \u2102), (\u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + Complex.I)) \u2227 (\u2203 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t \u2260 2 + Complex.I) := by\n    use fun t => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1\n    constructor\n    \u00b7 -- Prove that for all t \u2208 [0, 1], z(t) = t \u2022 (2 + I)\n      intro t ht\n      simp [ht]\n      <;>\n      (try norm_num) <;>\n      (try simp_all [Set.Icc, Complex.ext_iff, Complex.I_mul_I]) <;>\n      (try ring_nf) <;>\n      (try norm_num) <;>\n      (try linarith)\n    \u00b7 -- Prove that there exists t \u2208 [0, 1] such that deriv z t \u2260 2 + I\n      have h\u2081 : (0 : \u211d) \u2208 Set.Icc (0 : \u211d) 1 := by\n        exact \u27e8by norm_num, by norm_num\u27e9\n      have h\u2082 : deriv (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 = 0 := by\n        -- Prove that the derivative at 0 is 0 because the function is not continuous at 0\n        have h\u2083 : \u00acContinuousAt (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 := by\n          intro h_cont\n          have h\u2084 : ContinuousAt (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 := h_cont\n          have h\u2085 : Filter.Tendsto (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) (nhds 0) (nhds (if (0 : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then (0 : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) := h\u2084\n          have h\u2086 : (if (0 : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then (0 : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102) = (0 : \u2102) := by\n            norm_num [Set.Icc]\n            <;>\n            (try simp [Complex.ext_iff]) <;>\n            (try norm_num) <;>\n            (try ring_nf) <;>\n            (try simp_all [Complex.ext_iff, Complex.I_mul_I]) <;>\n            (try norm_num)\n          have h\u2087 : Filter.Tendsto (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) (nhds 0) (nhds (0 : \u2102)) := by\n            simpa [h\u2086] using h\u2085\n          -- Consider the sequence t\u2099 = -1/n \u2192 0\u207b\n          have h\u2088 : Filter.Tendsto (fun n : \u2115 => (-1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 0) := by\n            have h\u2089 : Filter.Tendsto (fun n : \u2115 => (-1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 0) := by\n              have h\u2081\u2080 : Filter.Tendsto (fun n : \u2115 => (n + 1 : \u211d)) Filter.atTop Filter.atTop := by\n                apply tendsto_atTop_atTop.mpr\n                intro b\n                use \u2308b\u2309\u208a\n                intro n hn\n                have h\u2081\u2081 : (n : \u211d) \u2265 \u2308b\u2309\u208a := by exact_mod_cast hn\n                have h\u2081\u2082 : (n : \u211d) + 1 \u2265 \u2308b\u2309\u208a + 1 := by linarith\n                have h\u2081\u2083 : (\u2308b\u2309\u208a : \u211d) \u2265 b := by exact_mod_cast Nat.le_ceil b\n                linarith\n              have h\u2081\u2081 : Filter.Tendsto (fun n : \u2115 => (-1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 0) := by\n                have h\u2081\u2082 : Filter.Tendsto (fun n : \u2115 => (n + 1 : \u211d)) Filter.atTop Filter.atTop := h\u2081\u2080\n                have h\u2081\u2083 : Filter.Tendsto (fun n : \u2115 => (-1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 0) := by\n                  convert tendsto_const_nhds.div_atTop h\u2081\u2082 using 1\n                  <;> simp [div_eq_mul_inv]\n                  <;> field_simp\n                  <;> ring\n                  <;> norm_num\n                exact h\u2081\u2083\n              exact h\u2081\u2081\n            exact h\u2089\n          have h\u2089 : Filter.Tendsto (fun n : \u2115 => (if ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) Filter.atTop (nhds (1 : \u2102)) := by\n            have h\u2081\u2080 : Filter.Tendsto (fun n : \u2115 => (1 : \u2102)) Filter.atTop (nhds (1 : \u2102)) := tendsto_const_nhds\n            have h\u2081\u2081 : (fun n : \u2115 => (if ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) = (fun _ => (1 : \u2102)) := by\n              funext n\n              have h\u2081\u2082 : ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) < 0 := by\n                have h\u2081\u2083 : (n : \u211d) \u2265 0 := by positivity\n                have h\u2081\u2084 : ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) < 0 := by\n                  apply div_neg_of_neg_of_pos\n                  \u00b7 norm_num\n                  \u00b7 positivity\n                exact h\u2081\u2084\n              have h\u2081\u2083 : \u00ac((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 := by\n                intro h\u2081\u2084\n                have h\u2081\u2085 : 0 \u2264 (-1 : \u211d) / (n + 1 : \u211d) := by exact h\u2081\u2084.1\n                linarith\n              simp [h\u2081\u2083]\n              <;> norm_num\n            rw [h\u2081\u2081]\n            exact h\u2081\u2080\n          have h\u2081\u2080 : Filter.Tendsto (fun n : \u2115 => (if ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) Filter.atTop (nhds (0 : \u2102)) := by\n            have h\u2081\u2081 : Filter.Tendsto (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) (nhds 0) (nhds (0 : \u2102)) := h\u2087\n            have h\u2081\u2082 : Filter.Tendsto (fun n : \u2115 => (-1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 0) := h\u2088\n            have h\u2081\u2083 : Filter.Tendsto (fun n : \u2115 => (if ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) Filter.atTop (nhds (0 : \u2102)) :=\n              h\u2081\u2081.comp h\u2081\u2082\n            exact h\u2081\u2083\n          have h\u2081\u2081 : (1 : \u2102) \u2260 (0 : \u2102) := by\n            norm_num [Complex.ext_iff]\n          have h\u2081\u2082 : False := by\n            have h\u2081\u2083 : Filter.Tendsto (fun n : \u2115 => (if ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) Filter.atTop (nhds (1 : \u2102)) := h\u2089\n            have h\u2081\u2084 : Filter.Tendsto (fun n : \u2115 => (if ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2208 Set.Icc (0 : \u211d) 1 then ((-1 : \u211d) / (n + 1 : \u211d) : \u211d) \u2022 (2 + Complex.I) else 1 : \u2102)) Filter.atTop (nhds (0 : \u2102)) := h\u2081\u2080\n            have h\u2081\u2085 : (1 : \u2102) = (0 : \u2102) := by\n              apply tendsto_nhds_unique h\u2081\u2083 h\u2081\u2084\n            simp_all [Complex.ext_iff]\n            <;> norm_num at *\n            <;> linarith\n          exact h\u2081\u2082\n        -- Since the function is not continuous at 0, it is not differentiable, so deriv z 0 = 0\n        have h\u2084 : deriv (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 = 0 := by\n          apply deriv_zero_of_not_differentiableAt\n          intro h_diff\n          have h\u2085 : DifferentiableAt \u211d (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 := h_diff\n          have h\u2086 : ContinuousAt (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 := h\u2085.continuousAt\n          exact h\u2083 h\u2086\n        exact h\u2084\n      have h\u2083 : deriv (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 \u2260 2 + Complex.I := by\n        intro h\u2084\n        have h\u2085 : deriv (fun t : \u211d => if t \u2208 Set.Icc (0 : \u211d) 1 then t \u2022 (2 + Complex.I) else 1 : \u211d \u2192 \u2102) 0 = 0 := h\u2082\n        rw [h\u2085] at h\u2084\n        norm_num [Complex.ext_iff, Complex.I_mul_I] at h\u2084 \u22a2\n        <;>\n        (try contradiction) <;>\n        (try linarith)\n      refine' \u27e80, h\u2081, _\u27e9\n      simpa using h\u2083\n  -- Use the main result to prove the negation of the original statement\n  intro h\n  obtain \u27e8z, hz\u2081, t, ht, hz\u2082\u27e9 := h_main\n  have h\u2081 := h z hz\u2081 t ht\n  have h\u2082 : deriv z t \u2260 2 + Complex.I := hz\u2082\n  exact h\u2082 h\u2081"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "The integrand $f(z) = \\operatorname{Re}(z)$ becomes $\\operatorname{Re}(t(2+i)) = 2t$ along the path.", "statement": "We assume:\n\u2022 The function to be integrated is $f(z) = \\operatorname{Re}(z)$ [tc_1]\n\u2022 The path $C$ is parameterized by $z(t) = t(2+i)$ for $t \\in [0, 1]$ [def_1]\nTherefore, we conclude:\n\u2022 Along the path $C$, the integrand evaluates to $f(z(t)) = \\operatorname{Re}(t(2+i)) = 2t$ [l2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (z : \u211d \u2192 \u2102)\n  (f : \u2102 \u2192 \u211d)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (h_f : \u2200 w : \u2102, f w = w.re) :\n  \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (z : \u211d \u2192 \u2102)\n  (f : \u2102 \u2192 \u211d)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + Complex.I))\n  (h_f : \u2200 w : \u2102, f w = w.re) :\n  \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t := by\n  intro t ht\n  have h_zt : z t = (t : \u2102) * (2 + Complex.I) := by\n    have h\u2081 : z t = t \u2022 (2 + Complex.I) := h_z t ht\n    -- Convert scalar multiplication to complex multiplication\n    have h\u2082 : (t : \u2102) \u2022 (2 + Complex.I) = (t : \u2102) * (2 + Complex.I) := by\n      simp [Complex.ext_iff, Complex.ofReal_mul, mul_comm]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, Complex.ofReal_mul, mul_comm]\n      <;> norm_num\n      <;> linarith\n    -- Use the fact that t \u2022 z = (t : \u2102) * z for t : \u211d and z : \u2102\n    calc\n      z t = t \u2022 (2 + Complex.I) := h\u2081\n      _ = (t : \u2102) * (2 + Complex.I) := by\n        -- Prove that t \u2022 (2 + Complex.I) = (t : \u2102) * (2 + Complex.I)\n        simp [Complex.ext_iff, Complex.ofReal_mul, mul_comm] at h\u2082 \u22a2\n        <;>\n        (try norm_num at h\u2082 \u22a2) <;>\n        (try ring_nf at h\u2082 \u22a2) <;>\n        (try simp_all [Complex.ext_iff, Complex.ofReal_mul, mul_comm]) <;>\n        (try norm_num at h\u2082 \u22a2) <;>\n        (try linarith) <;>\n        (try\n          {\n            constructor <;>\n            simp_all [Complex.ext_iff, Complex.ofReal_mul, mul_comm] <;>\n            ring_nf at * <;>\n            norm_num at * <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [Complex.ext_iff, Complex.ofReal_mul, mul_comm]\n            <;>\n            ring_nf at * <;>\n            norm_num at * <;>\n            linarith\n          })\n  \n  have h_re : (z t).re = 2 * t := by\n    rw [h_zt]\n    simp [Complex.ext_iff, Complex.mul_re, Complex.ofReal_mul, Complex.ofReal_add, Complex.I_re, Complex.I_im]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [Complex.ext_iff, Complex.ofReal_mul, Complex.ofReal_add]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_main : f (z t) = 2 * t := by\n    have h1 : f (z t) = (z t).re := by\n      rw [h_f]\n    rw [h1]\n    rw [h_re]\n    <;> simp_all [Complex.ext_iff, Complex.ofReal_mul, Complex.ofReal_add]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly and completely captures all mathematical content from the natural language. The function f is properly defined as the real part function, the path parameterization z(t) = t(2+i) is accurately represented using scalar multiplication notation, the domain [0,1] is correctly specified, and the conclusion f(z(t)) = 2t is properly formalized. All mathematical relationships and logical components from the natural language are preserved in the Lean code."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Substituting these into the integral gives $\\int_0^1 (2t)(2+i)dt$.", "statement": "We assume:\n\u2022 The contour integral to be evaluated is $\\int_C f(z) dz$, where $C$ is the path from 0 to 2+i and $f(z) = \\operatorname{Re}(z)$ [tc_1]\n\u2022 The path $C$ is parameterized by $z(t) = t(2+i)$ for $t \\in [0, 1]$ [def_1]\n\u2022 The differential is $dz = (2+i)dt$ [l1]\n\u2022 Along the path, the integrand is $f(z(t)) = 2t$ [l2]\nTherefore, we conclude:\n\u2022 The contour integral is equal to the definite integral: $\\int_C f(z) dz = \\int_0^1 f(z(t))z'(t)dt = \\int_0^1 (2t)(2+i)dt$ [l3].", "dependencies": ["tc_1", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (f : \u2102 \u2192 \u211d) \n  (z : \u211d \u2192 \u2102)\n  (h_f : \u2200 w : \u2102, f w = w.re)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (l1 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + I)\n  (l2 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t) :\n  \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (f : \u2102 \u2192 \u211d) \n  (z : \u211d \u2192 \u2102)\n  (h_f : \u2200 w : \u2102, f w = w.re)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (l1 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + I)\n  (l2 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t) :\n  \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n  have h_main : \u2200 (t : \u211d), t \u2208 Set.Icc (0 : \u211d) 1 \u2192 (f (z t) * (deriv z t) : \u2102) = ((2 * t : \u211d) * (2 + I) : \u2102) := by\n    intro t ht\n    have h3 : f (z t) = 2 * t := l2 t ht\n    have h4 : deriv z t = 2 + I := l1 t ht\n    have h5 : (f (z t) : \u211d) = 2 * t := by exact_mod_cast h3\n    have h6 : (f (z t) : \u2102) = (2 * t : \u2102) := by\n      norm_cast\n      <;> simp [h5]\n      <;> ring_nf\n      <;> norm_num\n    calc\n      (f (z t) * (deriv z t) : \u2102) = (f (z t) : \u2102) * (deriv z t : \u2102) := by simp [Complex.ext_iff]\n      _ = (2 * t : \u2102) * (deriv z t : \u2102) := by rw [h6]\n      _ = (2 * t : \u2102) * (2 + I : \u2102) := by\n        rw [h4]\n        <;> simp [Complex.ext_iff]\n        <;> norm_num\n      _ = ((2 * t : \u211d) * (2 + I) : \u2102) := by\n        simp [Complex.ext_iff]\n        <;> norm_num\n        <;> ring_nf\n        <;> simp_all [Complex.ext_iff]\n        <;> norm_num\n        <;> linarith\n  \n  have h_zero_le_one : (0 : \u211d) \u2264 (1 : \u211d) := by\n    norm_num\n  \n  have h_main_uIcc : \u2200 (t : \u211d), t \u2208 Set.uIcc (0 : \u211d) (1 : \u211d) \u2192 (f (z t) * (deriv z t) : \u2102) = ((2 * t : \u211d) * (2 + I) : \u2102) := by\n    intro t ht\n    have h\u2081 : 0 \u2264 t \u2227 t \u2264 1 := by\n      -- Use the fact that 0 \u2264 1 to simplify the uIcc condition\n      have h\u2082 : (0 : \u211d) \u2264 (1 : \u211d) := h_zero_le_one\n      simp only [Set.mem_uIcc, h\u2082] at ht\n      -- Since 0 \u2264 1, the condition simplifies to 0 \u2264 t \u2264 1\n      tauto\n    have h\u2082 : t \u2208 Set.Icc (0 : \u211d) (1 : \u211d) := by\n      exact \u27e8h\u2081.1, h\u2081.2\u27e9\n    have h\u2083 : (f (z t) * (deriv z t) : \u2102) = ((2 * t : \u211d) * (2 + I) : \u2102) := h_main t h\u2082\n    exact h\u2083\n  \n  have h_final : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n    have h\u2083 : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I : \u2102) := by\n      -- Use the fact that the integrands are equal on [0, 1] to show the integrals are equal\n      have h\u2084 : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (f (z t) * (deriv z t) : \u2102) := by\n        simp [intervalIntegral.integral_congr]\n      rw [h\u2084]\n      have h\u2085 : \u222b t in (0 : \u211d)..1, (f (z t) * (deriv z t) : \u2102) = \u222b t in (0 : \u211d)..1, ((2 * t : \u211d) * (2 + I) : \u2102) := by\n        -- Use the interval integral congruence lemma to show the integrals are equal\n        have h\u2086 : \u222b t in (0 : \u211d)..1, (f (z t) * (deriv z t) : \u2102) = \u222b t in (0 : \u211d)..1, ((2 * t : \u211d) * (2 + I) : \u2102) := by\n          -- Use the fact that the integrands are equal on [0, 1]\n          refine' intervalIntegral.integral_congr (fun t ht => _)\n          have h\u2087 : t \u2208 Set.uIcc (0 : \u211d) (1 : \u211d) := by\n            simp only [Set.mem_uIcc]\n            constructor <;> (try { linarith [ht.1, ht.2] }) <;> (try { linarith [ht.1, ht.2] })\n          have h\u2088 : (f (z t) * (deriv z t) : \u2102) = ((2 * t : \u211d) * (2 + I) : \u2102) := h_main_uIcc t h\u2087\n          simpa using h\u2088\n        rw [h\u2086]\n      rw [h\u2085]\n      <;> simp [intervalIntegral.integral_congr]\n    -- Simplify the right-hand side to match the goal\n    have h\u2084 : \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I : \u2102) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n      simp [intervalIntegral.integral_congr]\n      <;>\n      simp_all [Complex.ext_iff, mul_comm]\n      <;>\n      norm_num\n      <;>\n      ring_nf\n      <;>\n      simp_all [Complex.ext_iff, mul_comm]\n      <;>\n      norm_num\n      <;>\n      linarith\n    rw [h\u2083, h\u2084]\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 47, "column": 6, "endLine": 47, "endColumn": 11, "data": "tauto failed to solve some goals."}, {"line": 47, "column": 6, "endLine": 47, "endColumn": 11, "data": "unsolved goals\ncase inr.intro.left\nI : \u2102\nf : \u2102 \u2192 \u211d\nz : \u211d \u2192 \u2102\nh_f : \u2200 (w : \u2102), f w = w.re\nh_z : \u2200 t \u2208 Set.Icc 0 1, z t = t \u2022 (2 + I)\nl1 : \u2200 t \u2208 Set.Icc 0 1, deriv z t = 2 + I\nl2 : \u2200 t \u2208 Set.Icc 0 1, f (z t) = 2 * t\nh_main : \u2200 t \u2208 Set.Icc 0 1, \u2191(f (z t)) * deriv z t = \u2191(2 * t) * (2 + I)\nh_zero_le_one : 0 \u2264 1\nt : \u211d\nh\u2082 : 0 \u2264 1\nleft\u271d : 1 \u2264 t\nright\u271d : t \u2264 0\n\u22a2 0 \u2264 t\n\ncase inr.intro.right\nI : \u2102\nf : \u2102 \u2192 \u211d\nz : \u211d \u2192 \u2102\nh_f : \u2200 (w : \u2102), f w = w.re\nh_z : \u2200 t \u2208 Set.Icc 0 1, z t = t \u2022 (2 + I)\nl1 : \u2200 t \u2208 Set.Icc 0 1, deriv z t = 2 + I\nl2 : \u2200 t \u2208 Set.Icc 0 1, f (z t) = 2 * t\nh_main : \u2200 t \u2208 Set.Icc 0 1, \u2191(f (z t)) * deriv z t = \u2191(2 * t) * (2 + I)\nh_zero_le_one : 0 \u2264 1\nt : \u211d\nh\u2082 : 0 \u2264 1\nleft\u271d : 1 \u2264 t\nright\u271d : t \u2264 0\n\u22a2 t \u2264 1"}, {"line": 64, "column": 52, "endLine": 66, "endColumn": 95, "data": "unsolved goals\ncase h\nI : \u2102\nf : \u2102 \u2192 \u211d\nz : \u211d \u2192 \u2102\nh_f : \u2200 (w : \u2102), f w = w.re\nh_z : \u2200 t \u2208 Set.Icc 0 1, z t = t \u2022 (2 + I)\nl1 : \u2200 t \u2208 Set.Icc 0 1, deriv z t = 2 + I\nl2 : \u2200 t \u2208 Set.Icc 0 1, f (z t) = 2 * t\nh_main : \u2200 t \u2208 Set.Icc 0 1, \u2191(f (z t)) * deriv z t = \u2191(2 * t) * (2 + I)\nh_zero_le_one : 0 \u2264 1\nh_main_uIcc : \u2200 t \u2208 Set.uIcc 0 1, \u2191(f (z t)) * deriv z t = \u2191(2 * t) * (2 + I)\nh\u2084 : \u222b (t : \u211d) in 0 ..1, \u2191(f (z t)) * deriv z t = \u222b (t : \u211d) in 0 ..1, \u2191(f (z t)) * deriv z t\nt : \u211d\nht : t \u2208 Set.uIcc 0 1\n\u22a2 0 \u2264 t \u2227 t \u2264 1"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function definition h_f correctly captures f(z) = Re(z) using Lean's complex number real part notation w.re", "The path parameterization h_z correctly represents z(t) = t(2+i) for t \u2208 [0,1] using Lean's scalar multiplication and interval notation", "The derivative condition l1 correctly captures dz = (2+i)dt by stating deriv z t = 2 + I", "The integrand evaluation l2 correctly represents f(z(t)) = 2t along the parameterized path", "The main theorem statement correctly formalizes the contour integral equality, showing the transformation from the general form to the specific integral with the computed values", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (f : \u2102 \u2192 \u211d) \n  (z : \u211d \u2192 \u2102)\n  (h_f : \u2200 w : \u2102, f w = w.re)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (l1 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + I)\n  (l2 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t) :\n  \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n  have h_main : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, (f (z t) : \u2102) * (deriv z t) = (2 * t : \u2102) * (2 + I) := by\n    intro t ht\n    have h3 : (f (z t) : \u2102) = (2 * t : \u211d) := by\n      have h4 : f (z t) = 2 * t := l2 t ht\n      norm_cast\n      <;> simp [h4]\n    have h5 : deriv z t = 2 + I := l1 t ht\n    rw [h3, h5]\n    <;> simp [Complex.ext_iff, mul_comm]\n    <;> ring_nf\n    <;> norm_cast\n    <;> simp [Complex.ext_iff, mul_comm]\n    <;> norm_num\n    <;> linarith [ht.1, ht.2]\n  \n  have h_integral : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n    have h3 : (\u222b t in (0 : \u211d)..1, f (z t) * (deriv z t)) = \u222b t in (0 : \u211d)..1, (f (z t) : \u2102) * (deriv z t) := by\n      simp [intervalIntegral.integral_congr]\n      <;> congr 1 <;> ext t <;> simp [Complex.ext_iff]\n      <;> ring_nf\n      <;> norm_num\n      <;> simp_all [Complex.ext_iff]\n      <;> norm_num\n      <;> linarith\n    have h4 : (\u222b t in (0 : \u211d)..1, (2 * t : \u2102) * (2 + I)) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n      simp [intervalIntegral.integral_congr]\n      <;> congr 1 <;> ext t <;> simp [Complex.ext_iff]\n      <;> ring_nf\n      <;> norm_num\n      <;> simp_all [Complex.ext_iff]\n      <;> norm_num\n      <;> linarith\n    have h5 : \u222b t in (0 : \u211d)..1, (f (z t) : \u2102) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t : \u2102) * (2 + I) := by\n      -- Use the fact that the integrands are equal on [0,1] to show the integrals are equal\n      have h6 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, (f (z t) : \u2102) * (deriv z t) = (2 * t : \u2102) * (2 + I) := h_main\n      have h7 : \u222b t in (0 : \u211d)..1, (f (z t) : \u2102) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t : \u2102) * (2 + I) := by\n        -- Use the fact that the integrands are equal on [0,1]\n        have h8 : (\u222b t in (0 : \u211d)..1, (f (z t) : \u2102) * (deriv z t)) = \u222b t in (0 : \u211d)..1, (2 * t : \u2102) * (2 + I) := by\n          -- Apply the interval integral congruence lemma\n          apply intervalIntegral.integral_congr\n          <;> intro t ht <;>\n            (try norm_num at ht \u22a2) <;>\n            (try simp_all [Set.mem_Icc]) <;>\n            (try\n              {\n                have h9 : t \u2208 Set.Icc (0 : \u211d) 1 := by\n                  constructor <;> linarith [ht.1, ht.2]\n                have h10 := h6 t h9\n                simp_all [Complex.ext_iff]\n                <;> ring_nf at * <;>\n                  norm_num at * <;>\n                  simp_all [Complex.ext_iff] <;>\n                  norm_num <;>\n                  linarith\n              }) <;>\n            (try\n              {\n                simp_all [Complex.ext_iff]\n                <;> ring_nf at * <;>\n                  norm_num at * <;>\n                  simp_all [Complex.ext_iff] <;>\n                  norm_num <;>\n                  linarith\n              })\n        exact h8\n      exact h7\n    calc\n      \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (f (z t) : \u2102) * (deriv z t) := by rw [h3]\n      _ = \u222b t in (0 : \u211d)..1, (2 * t : \u2102) * (2 + I) := by rw [h5]\n      _ = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by rw [h4]\n  exact h_integral"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Evaluating this integral results in $(2+i) \\int_0^1 2t dt = (2+i) [t^2]_0^1 = 2+i$.", "statement": "We assume:\n\u2022 $\\int_C f(z) dz = \\int_0^1 (2t)(2+i)dt$ [l3]\nTherefore, we conclude:\n\u2022 $\\int_C f(z) dz = 2+i$ [ts_1].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u211d) \n  (z : \u211d \u2192 \u2102)\n  (h_f : \u2200 w : \u2102, f w = w.re)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (l1 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + I)\n  (l2 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t)\n  (l3 : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I)) :\n  \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = 2 + I := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u211d) \n  (z : \u211d \u2192 \u2102)\n  (h_f : \u2200 w : \u2102, f w = w.re)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (l1 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + I)\n  (l2 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t)\n  (l3 : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I)) :\n  \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = 2 + I := by\n  have h7 : \u222b t in (0 : \u211d)..(1 : \u211d), (2 * t : \u211d) * (2 + I) = 2 + I := by\n    have h7\u2081 : \u222b t in (0 : \u211d)..(1 : \u211d), (2 * t : \u211d) * (2 + I) = (2 + I : \u2102) * \u222b t in (0 : \u211d)..(1 : \u211d), (2 * t : \u211d) := by\n      -- Factor out the constant (2 + I) from the integral.\n      simp [intervalIntegral.integral_comp_mul_left, mul_comm]\n      <;>\n      simp_all [mul_comm]\n      <;>\n      norm_num\n      <;>\n      ring_nf\n      <;>\n      simp_all [Complex.ext_iff, Complex.I_mul_I, mul_comm]\n      <;>\n      norm_num\n      <;>\n      linarith\n    -- Compute the integral of (2 * t : \u211d) from 0 to 1.\n    have h7\u2082 : (\u222b t in (0 : \u211d)..(1 : \u211d), (2 * t : \u211d)) = (1 : \u211d) := by\n      -- Use the fundamental theorem of calculus to compute the integral.\n      norm_num [mul_comm]\n      <;>\n      simp [intervalIntegral.integral_comp_mul_left]\n      <;>\n      norm_num\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith\n    -- Combine the results to get the final answer.\n    calc\n      \u222b t in (0 : \u211d)..(1 : \u211d), (2 * t : \u211d) * (2 + I) = (2 + I : \u2102) * \u222b t in (0 : \u211d)..(1 : \u211d), (2 * t : \u211d) := by rw [h7\u2081]\n      _ = (2 + I : \u2102) * (1 : \u211d) := by rw [h7\u2082]\n      _ = 2 + I := by\n        simp [Complex.ext_iff, Complex.I_mul_I, mul_comm]\n        <;>\n        norm_num\n        <;>\n        simp_all [Complex.ext_iff, Complex.I_mul_I, mul_comm]\n        <;>\n        norm_num\n        <;>\n        linarith\n  \n  have h8 : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = 2 + I := by\n    calc\n      \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I) := by\n        rw [l3]\n      _ = 2 + I := by\n        -- Use the previously computed integral result\n        have h8\u2081 : \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I) = 2 + I := by\n          simpa using h7\n        simpa using h8\u2081\n  \n  apply h8", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 28, "column": 6, "endLine": 28, "endColumn": 14, "data": "linarith failed to find a contradiction\nI : \u2102\nf : \u2102 \u2192 \u211d\nz : \u211d \u2192 \u2102\nh_f : \u2200 (w : \u2102), f w = w.re\nh_z : \u2200 (t : \u211d), 0 \u2264 t \u2192 t \u2264 1 \u2192 (z t).re = t * 2 + t * I.re \u2227 (z t).im = t * I.im\nl1 : \u2200 (t : \u211d), 0 \u2264 t \u2192 t \u2264 1 \u2192 (deriv z t).re = 2 + I.re \u2227 (deriv z t).im = I.im\nl2 : \u2200 (t : \u211d), 0 \u2264 t \u2192 t \u2264 1 \u2192 t = 0 \u2228 I.re = 0\nl3 :\n  (\u222b (t : \u211d) in 0 ..1, deriv z t * \u2191(z t).re).re =\n      (2 + I.re) * (2 * (\u222b (x : \u211d) in 0 ..1, \u2191x).re) - I.im * (2 * (\u222b (x : \u211d) in 0 ..1, \u2191x).im) \u2227\n    (\u222b (t : \u211d) in 0 ..1, deriv z t * \u2191(z t).re).im =\n      (2 + I.re) * (2 * (\u222b (x : \u211d) in 0 ..1, \u2191x).im) + I.im * (2 * (\u222b (x : \u211d) in 0 ..1, \u2191x).re)\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumption l3 correctly formalizes the premise by representing the line integral \u222b_C f(z) dz in its standard parameterized form \u222b f(z(t)) * z'(t) dt, and equating it to the given parameter integral.", "The theorem goal correctly captures the conclusion that the line integral equals 2+i, using the same parameterized representation as established in the premise.", "The additional hypotheses (h_f, h_z, l1, l2) provide necessary mathematical context that makes the problem well-defined and are consistent with the natural language setup. The overall logical flow from premise to conclusion is preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u211d) \n  (z : \u211d \u2192 \u2102)\n  (h_f : \u2200 w : \u2102, f w = w.re)\n  (h_z : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, z t = t \u2022 (2 + I))\n  (l1 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, deriv z t = 2 + I)\n  (l2 : \u2200 t \u2208 Set.Icc (0 : \u211d) 1, f (z t) = 2 * t)\n  (l3 : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = \u222b t in (0 : \u211d)..1, (2 * t) * (2 + I)) :\n  \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = 2 + I := by\n  have h_I_re : I.re = 0 := by\n    have h\u2084 : (1 : \u211d) \u2208 Set.Icc (0 : \u211d) 1 := by\n      exact \u27e8by norm_num, by norm_num\u27e9\n    have h\u2085 : f (z 1) = 2 * (1 : \u211d) := l2 1 h\u2084\n    have h\u2086 : z 1 = (1 : \u211d) \u2022 (2 + I) := h_z 1 h\u2084\n    have h\u2087 : f (z 1) = (z 1).re := by\n      rw [h_f]\n    have h\u2088 : (z 1).re = (2 + I).re := by\n      rw [h\u2086]\n      simp [Complex.ext_iff, Complex.smul_re, Complex.smul_im, Complex.ofReal_one]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, Complex.smul_re, Complex.smul_im, Complex.ofReal_one]\n      <;> norm_num\n      <;> linarith\n    have h\u2089 : (2 + I : \u2102).re = 2 + I.re := by\n      simp [Complex.ext_iff]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff]\n      <;> norm_num\n      <;> linarith\n    have h\u2081\u2080 : f (z 1) = 2 + I.re := by\n      rw [h\u2087, h\u2088, h\u2089]\n      <;> simp_all [Complex.ext_iff]\n      <;> norm_num\n      <;> linarith\n    have h\u2081\u2081 : (2 : \u211d) + I.re = 2 := by\n      linarith\n    have h\u2081\u2082 : I.re = 0 := by\n      linarith\n    exact h\u2081\u2082\n  \n  have h_main : \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I) = (2 + I : \u2102) := by\n    have h\u2084 : \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I) = (2 + I : \u2102) := by\n      have h\u2085 : \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I) = \u222b t in (0 : \u211d)..1, (\u2191(2 * t : \u211d) : \u2102) * (2 + I : \u2102) := by\n        congr\n        ext t\n        simp [Complex.ext_iff]\n        <;> ring_nf\n        <;> simp_all [Complex.ext_iff]\n        <;> norm_num\n        <;> linarith\n      rw [h\u2085]\n      have h\u2086 : \u222b t in (0 : \u211d)..1, (\u2191(2 * t : \u211d) : \u2102) * (2 + I : \u2102) = (2 + I : \u2102) * \u222b t in (0 : \u211d)..1, (\u2191(2 * t : \u211d) : \u2102) := by\n        -- Factor out the constant (2 + I : \u2102) from the integral\n        simp [intervalIntegral.integral_comp_mul_left (fun t => (2 + I : \u2102) * t)]\n        <;>\n          simp_all [Complex.ext_iff, Complex.I_mul_I]\n        <;>\n          norm_num\n        <;>\n          ring_nf\n        <;>\n          simp_all [Complex.ext_iff, Complex.I_mul_I]\n        <;>\n          norm_num\n        <;>\n          linarith\n      rw [h\u2086]\n      have h\u2087 : \u222b t in (0 : \u211d)..1, (\u2191(2 * t : \u211d) : \u2102) = (1 : \u2102) := by\n        -- Compute the integral of (2 * t : \u211d) from 0 to 1 and coerce it to \u2102\n        have h\u2088 : \u222b t in (0 : \u211d)..1, (\u2191(2 * t : \u211d) : \u2102) = (\u2191(\u222b t in (0 : \u211d)..1, (2 * t : \u211d)) : \u2102) := by\n          simp [intervalIntegral.integral_comp_mul_left]\n          <;>\n            simp_all [Complex.ext_iff, Complex.I_mul_I]\n          <;>\n            norm_num\n          <;>\n            ring_nf\n          <;>\n            simp_all [Complex.ext_iff, Complex.I_mul_I]\n          <;>\n            norm_num\n          <;>\n            linarith\n        rw [h\u2088]\n        -- Compute the integral of (2 * t : \u211d) from 0 to 1\n        have h\u2089 : (\u222b t in (0 : \u211d)..1, (2 * t : \u211d)) = 1 := by\n          norm_num [mul_comm]\n          <;>\n            simp [intervalIntegral.integral_comp_mul_left (fun t => (t : \u211d))]\n          <;>\n            norm_num\n          <;>\n            ring_nf\n          <;>\n            norm_num\n        rw [h\u2089]\n        <;> simp [Complex.ext_iff]\n        <;> norm_num\n      rw [h\u2087]\n      <;> simp [Complex.ext_iff]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff]\n      <;> norm_num\n      <;> linarith\n    exact h\u2084\n  \n  have h_final : \u222b t in (0 : \u211d)..1, f (z t) * (deriv z t) = 2 + I := by\n    calc\n      (\u222b t in (0 : \u211d)..1, f (z t) * (deriv z t)) = \u222b t in (0 : \u211d)..1, (2 * t : \u211d) * (2 + I) := by\n        rw [l3]\n        <;>\n          simp_all [Complex.ext_iff]\n        <;>\n          norm_num\n        <;>\n          linarith\n      _ = (2 + I : \u2102) := by\n        rw [h_main]\n      _ = 2 + I := by\n        simp [Complex.ext_iff]\n        <;>\n          norm_num\n        <;>\n          linarith\n  \n  exact h_final"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    