
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Suppose that  $u_1,$ $u_2,$ \dots$,$ $u_n$ and $v_1,$ $v_2,$ \dots$,$ $v_n$
are nonnegative  numbers and $p>1.$ Then
\begin{equation} \label{eq:8.1.8}
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/p}
\le\left(\sum_{i=1}^n u_i^p\right)^{1/p}
+\left(\sum_{i=1}^n v_i^p\right)^{1/p}.
\end{equation}

Proof: Again, let $q=p/(p-1)$. We write
\begin{equation} \label{eq:8.1.9}
\sum_{i=1}^n(u_i+v_i)^p=\sum_{i=1}^n u_i(u_i+v_i)^{p-1}
+\sum_{i=1}^n v_i(u_i+v_i)^{p-1}.
\end{equation}
From H\"older's inequality with $\mu_i=u_i$ and
$
u_i=(u_i+v_i)^{p-1}$,
\begin{equation} \label{eq:8.1.10}
\sum_{i=1}^n u_i(u_i+v_i)^{p-1}\le
\left(\sum_{i=1}^n u_i^p\right)^{1/p}
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/q},
\end{equation}
since $q(p-1)=p$. Similarly,
$$
\sum_{i=1}^n v_i(u_i+v_i)^{p-1}\le
\left(\sum_{i=1}^n v_i^p\right)^{1/p}
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/q}.
$$
This, \eqref{eq:8.1.9}, and \eqref{eq:8.1.10} imply that
$$
\sum_{i=1}^n(u_i+v_i)^p
\le\left[\left(\sum_{i=1}^n u_i^p\right)^{1/p}
+\left(\sum_{i=1}^n v_i^p\right)^{1/p}\right]
\left(\sum_{i=1}^n(u_i+v_i)^p\right)^{1/q}.
$$

ewpage

oindent
Since $1-1/q=1/p$, this implies \eqref{eq:8.1.8}, which is
known as {\it Minkowski's inequality\/}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "u_1, u_2, \\dots, u_n and v_1, v_2, \\dots, v_n\nare nonnegative  numbers", "statement": "Premise:\n\u2022 $u = (u_i)_{i=1}^n$ and $v = (v_i)_{i=1}^n$ are sequences of $n$ nonnegative real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (u v : Fin n \u2192 \u211d)\n(tc_1 : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `u : Fin n \u2192 \u211d` correctly captures that u is a sequence of n real numbers. The type `Fin n \u2192 \u211d` represents functions from {0, 1, ..., n-1} to real numbers, which is equivalent to a sequence of n real numbers. The nonnegativity is handled separately in tc_1.", "The Lean formalization `v : Fin n \u2192 \u211d` correctly captures that v is a sequence of n real numbers, analogous to u. The nonnegativity constraint is handled in tc_1.", "The condition `tc_1 : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i` includes `0 \u2264 u i` for all i, which perfectly matches the mathematical condition $u_i \u2265 0$ for all $i \u2208 \\{1, 2, ..., n\\}$. Note that Lean uses 0-based indexing (Fin n = {0, 1, ..., n-1}) while the math uses 1-based indexing, but this is a standard and acceptable difference that doesn't affect the logical meaning.", "The condition `tc_1 : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i` includes `0 \u2264 v i` for all i, which perfectly matches the mathematical condition $v_i \u2265 0$ for all $i \u2208 \\{1, 2, ..., n\\}$. The indexing difference is standard and acceptable."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "p>1", "statement": "Premise:\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p : \u211d)\n(hp : p > 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (p : \u211d)' correctly captures that p is a real number", "The Lean hypothesis '(hp : p > 1)' correctly captures the condition that p > 1", "Both the natural language and Lean formalization are premise statements with no derived conclusions, which matches perfectly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "let $q=p/(p-1)$", "statement": "We assume:\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].\nDefinition:\n\u2022 Let $q$ be a real number such that $q = p / (p - 1)$ [def_1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p : \u211d) (q : \u211d)\n(hp : p > 1)\n(hq : q = p / (p - 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly declares p as a real number and states the condition p > 1, which exactly matches the natural language condition.", "The Lean formalization correctly declares q as a real number and defines q = p / (p - 1), which exactly matches the natural language conclusion. The division notation in Lean is equivalent to the fraction notation in mathematics."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "$\\sum_{i=1}^n(u_i+v_i)^p=\\sum_{i=1}^n u_i(u_i+v_i)^{p-1}\n+\\sum_{i=1}^n v_i(u_i+v_i)^{p-1}$.", "statement": "We assume:\n\u2022 $u = (u_i)_{i=1}^n$ and $v = (v_i)_{i=1}^n$ are sequences of $n$ nonnegative real numbers [tc_1].\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].\nTherefore, we conclude:\n\u2022 $\\sum_{i=1}^n(u_i+v_i)^p = \\sum_{i=1}^n u_i(u_i+v_i)^{p-1} + \\sum_{i=1}^n v_i(u_i+v_i)^{p-1}$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (n : \u2115) (u v : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (h_nonneg : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i)\n  (h_p : p > 1) :\n  \u2211 i, (u i + v i)^p = \u2211 i, u i * (u i + v i)^(p-1) + \u2211 i, v i * (u i + v i)^(p-1) := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (n : \u2115) (u v : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (h_nonneg : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i)\n  (h_p : p > 1) :\n  \u2211 i, (u i + v i)^p = \u2211 i, u i * (u i + v i)^(p-1) + \u2211 i, v i * (u i + v i)^(p-1) := by\n  have h_main : \u2200 (i : Fin n), (u i + v i)^p = u i * (u i + v i)^(p-1) + v i * (u i + v i)^(p-1) := by\n    intro i\n    have h\u2081 : (u i + v i) ^ p = (u i + v i) * (u i + v i) ^ (p - 1) := by\n      by_cases h : (u i + v i) = 0\n      \u00b7 -- Case: u i + v i = 0\n        have h\u2082 : u i = 0 := by\n          have h\u2083 : 0 \u2264 u i := (h_nonneg i).1\n          have h\u2084 : 0 \u2264 v i := (h_nonneg i).2\n          linarith\n        have h\u2083 : v i = 0 := by\n          have h\u2084 : 0 \u2264 u i := (h_nonneg i).1\n          have h\u2085 : 0 \u2264 v i := (h_nonneg i).2\n          linarith\n        have h\u2084 : (u i + v i) ^ p = 0 := by\n          rw [h]\n          have h\u2085 : (0 : \u211d) ^ p = 0 := by\n            have h\u2086 : p > 0 := by linarith\n            exact Real.zero_rpow (by linarith)\n          simpa using h\u2085\n        have h\u2085 : (u i + v i) * (u i + v i) ^ (p - 1) = 0 := by\n          rw [h]\n          have h\u2086 : (0 : \u211d) ^ (p - 1) = 0 := by\n            have h\u2087 : p - 1 > 0 := by linarith\n            exact Real.zero_rpow (by linarith)\n          simp [h\u2086]\n        linarith\n      \u00b7 -- Case: u i + v i > 0\n        have h\u2082 : 0 < u i + v i := by\n          by_contra h\u2082\n          have h\u2083 : u i + v i \u2264 0 := by linarith\n          have h\u2084 : u i + v i = 0 := by\n            have h\u2085 : 0 \u2264 u i := (h_nonneg i).1\n            have h\u2086 : 0 \u2264 v i := (h_nonneg i).2\n            linarith\n          contradiction\n        have h\u2083 : (u i + v i) ^ p = (u i + v i) ^ (1 + (p - 1)) := by\n          ring_nf\n          <;>\n          (try norm_num) <;>\n          (try linarith)\n        rw [h\u2083]\n        have h\u2084 : (u i + v i) ^ (1 + (p - 1)) = (u i + v i) ^ (1 : \u211d) * (u i + v i) ^ (p - 1) := by\n          rw [Real.rpow_add (by positivity)]\n          <;> ring_nf\n          <;> simp [h\u2082.ne']\n          <;> field_simp\n          <;> ring_nf\n        rw [h\u2084]\n        have h\u2085 : (u i + v i) ^ (1 : \u211d) = u i + v i := by\n          simp [Real.rpow_one]\n        rw [h\u2085]\n        <;> ring_nf\n    have h\u2082 : (u i + v i) * (u i + v i) ^ (p - 1) = u i * (u i + v i) ^ (p - 1) + v i * (u i + v i) ^ (p - 1) := by\n      ring_nf\n      <;>\n      (try simp_all [h_nonneg]) <;>\n      (try linarith)\n    linarith\n  \n  have h_sum : \u2211 i : Fin n, (u i + v i)^p = \u2211 i : Fin n, (u i * (u i + v i)^(p-1) + v i * (u i + v i)^(p-1)) := by\n    apply Finset.sum_congr rfl\n    intro i _\n    rw [h_main i]\n  \n  have h_sum_split : \u2211 i : Fin n, (u i * (u i + v i)^(p-1) + v i * (u i + v i)^(p-1)) = \u2211 i : Fin n, u i * (u i + v i)^(p-1) + \u2211 i : Fin n, v i * (u i + v i)^(p-1) := by\n    calc\n      \u2211 i : Fin n, (u i * (u i + v i) ^ (p - 1) + v i * (u i + v i) ^ (p - 1)) =\n          \u2211 i : Fin n, (u i * (u i + v i) ^ (p - 1) + v i * (u i + v i) ^ (p - 1)) := rfl\n      _ = \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) := by\n        rw [Finset.sum_add_distrib]\n  \n  have h_final : \u2211 i : Fin n, (u i + v i)^p = \u2211 i : Fin n, u i * (u i + v i)^(p-1) + \u2211 i : Fin n, v i * (u i + v i)^(p-1) := by\n    calc\n      \u2211 i : Fin n, (u i + v i) ^ p = \u2211 i : Fin n, (u i * (u i + v i) ^ (p - 1) + v i * (u i + v i) ^ (p - 1)) := by rw [h_sum]\n      _ = \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) := by rw [h_sum_split]\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations correctly represent sequences of n nonnegative real numbers using Fin n \u2192 \u211d with appropriate nonnegativity constraints", "The parameter p and its constraint p > 1 are accurately formalized", "The main equation is perfectly translated, with summation notation and algebraic expressions matching the natural language exactly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "From H\"older's inequality", "statement": "Definition:\n\u2022 H\u00f6lder's inequality states that for any two sequences of $n$ nonnegative real numbers $x=(x_i)_{i=1}^n$ and $y=(y_i)_{i=1}^n$, and for any real numbers $p, q > 1$ such that $1/p + 1/q = 1$, we have $\\sum_{i=1}^n x_i y_i \\le (\\sum_{i=1}^n x_i^p)^{1/p} (\\sum_{i=1}^n y_i^q)^{1/q}$ [def_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem holder_inequality {n : \u2115} (x y : Fin n \u2192 \u211d) (p q : \u211d)\n  (hx : \u2200 i, 0 \u2264 x i)\n  (hy : \u2200 i, 0 \u2264 y i)\n  (hp : 1 < p)\n  (hq : 1 < q)\n  (hpq : 1/p + 1/q = 1) :\n  \u2211 i : Fin n, x i * y i \u2264 (\u2211 i : Fin n, (x i)^p)^(1/p) * (\u2211 i : Fin n, (y i)^q)^(1/q) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures sequences of n nonnegative real numbers using Fin n \u2192 \u211d with nonnegativity constraints", "The Lean formalization correctly captures p, q > 1 as real numbers", "The Lean formalization exactly matches the constraint 1/p + 1/q = 1", "The Lean formalization perfectly captures H\u00f6lder's inequality with the correct summation notation and inequality"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "since $q(p-1)=p$", "statement": "We assume:\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].\n\u2022 $q = p / (p - 1)$ [def_1].\nTherefore, we conclude:\n\u2022 $q(p-1) = p$ [l2].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (p q : \u211d) (hp : p > 1) (hq : q = p / (p - 1)) : q * (p - 1) = p := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (p q : \u211d) (hp : p > 1) (hq : q = p / (p - 1)) : q * (p - 1) = p := by\n  have h_main : q * (p - 1) = p := by\n    have h\u2081 : p - 1 \u2260 0 := by\n      linarith\n    -- Substitute q = p / (p - 1) into the equation\n    calc\n      q * (p - 1) = (p / (p - 1)) * (p - 1) := by rw [hq]\n      _ = p := by\n        -- Simplify the expression (p / (p - 1)) * (p - 1)\n        field_simp [h\u2081]\n        <;> ring\n        <;> linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The variable declarations, constraints, definition, and conclusion are all properly represented. The explicit typing of q as real is mathematically sound since q is defined as a real expression involving real number p. The logical structure of assumptions leading to a conclusion is preserved through the theorem format."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "From H\"older's inequality with $\\mu_i=u_i$ and\n$\\nu_i=(u_i+v_i)^{p-1}$,\n\n$\\sum_{i=1}^n u_i(u_i+v_i)^{p-1}\\le\n\\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}\n\\left(\\sum_{i=1}^n(u_i+v_i)^p\\right)^{1/q},$\nsince $q(p-1)=p$.", "statement": "We assume:\n\u2022 $u=(u_i)_{i=1}^n$ and $v=(v_i)_{i=1}^n$ are sequences of $n$ nonnegative real numbers [tc_1].\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].\n\u2022 $q = p / (p-1)$ [def_1].\n\u2022 H\u00f6lder's inequality [def_2].\n\u2022 $q(p-1) = p$ [l2].\nTherefore, we conclude:\n\u2022 $\\sum_{i=1}^n u_i(u_i+v_i)^{p-1} \\le (\\sum_{i=1}^n u_i^p)^{1/p} (\\sum_{i=1}^n (u_i+v_i)^p)^{1/q}$ [l3].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {n : \u2115} (u v : Fin n \u2192 \u211d) (p q : \u211d)\n  (hu : \u2200 i, 0 \u2264 u i)\n  (hv : \u2200 i, 0 \u2264 v i)\n  (hp : p > 1)\n  (hq_def : q = p / (p - 1))\n  (hqp : q * (p - 1) = p)\n  (holder_ineq : \u2200 (x y : Fin n \u2192 \u211d), \n    (\u2200 i, 0 \u2264 x i) \u2192 (\u2200 i, 0 \u2264 y i) \u2192 \n    1 < p \u2192 1 < q \u2192 (1/p + 1/q = 1) \u2192\n    \u2211 i : Fin n, x i * y i \u2264 (\u2211 i : Fin n, (x i)^p)^(1/p) * (\u2211 i : Fin n, (y i)^q)^(1/q)) :\n  \u2211 i : Fin n, u i * (u i + v i)^(p - 1) \u2264 \n  (\u2211 i : Fin n, (u i)^p)^(1/p) * (\u2211 i : Fin n, (u i + v i)^p)^(1/q) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {n : \u2115} (u v : Fin n \u2192 \u211d) (p q : \u211d)\n  (hu : \u2200 i, 0 \u2264 u i)\n  (hv : \u2200 i, 0 \u2264 v i)\n  (hp : p > 1)\n  (hq_def : q = p / (p - 1))\n  (hqp : q * (p - 1) = p)\n  (holder_ineq : \u2200 (x y : Fin n \u2192 \u211d), \n    (\u2200 i, 0 \u2264 x i) \u2192 (\u2200 i, 0 \u2264 y i) \u2192 \n    1 < p \u2192 1 < q \u2192 (1/p + 1/q = 1) \u2192\n    \u2211 i : Fin n, x i * y i \u2264 (\u2211 i : Fin n, (x i)^p)^(1/p) * (\u2211 i : Fin n, (y i)^q)^(1/q)) :\n  \u2211 i : Fin n, u i * (u i + v i)^(p - 1) \u2264 \n  (\u2211 i : Fin n, (u i)^p)^(1/p) * (\u2211 i : Fin n, (u i + v i)^p)^(1/q) := by\n  have hq_gt_one : q > 1 := by\n    have h\u2081 : p - 1 > 0 := by linarith\n    have h\u2082 : p / (p - 1) > 1 := by\n      -- Prove that p / (p - 1) > 1 using the fact that p > 1\n      have h\u2083 : 0 < p - 1 := by linarith\n      have h\u2084 : p > p - 1 := by linarith\n      have h\u2085 : p / (p - 1) > 1 := by\n        rw [gt_iff_lt]\n        rw [lt_div_iff h\u2083]\n        nlinarith\n      exact h\u2085\n    -- Use the definition of q to conclude that q > 1\n    rw [hq_def]\n    exact h\u2082\n  \n  have h_inv_pq : 1 / p + 1 / q = 1 := by\n    have h\u2081 : q * (p - 1) = p := hqp\n    have h\u2082 : p > 1 := hp\n    have h\u2083 : p - 1 > 0 := by linarith\n    have h\u2084 : q > 0 := by\n      have h\u2085 : q > 1 := hq_gt_one\n      linarith\n    have h\u2085 : 1 / p + 1 / q = 1 := by\n      have h\u2086 : (p : \u211d) \u2260 0 := by linarith\n      have h\u2087 : (q : \u211d) \u2260 0 := by linarith\n      field_simp [h\u2086, h\u2087] at h\u2081 \u22a2\n      nlinarith [sq_pos_of_pos (sub_pos.mpr h\u2082)]\n    exact h\u2085\n  \n  have h_nonneg_y : \u2200 (i : Fin n), 0 \u2264 (u i + v i) ^ (p - 1) := by\n    intro i\n    have h\u2081 : 0 \u2264 u i := hu i\n    have h\u2082 : 0 \u2264 v i := hv i\n    have h\u2083 : 0 \u2264 u i + v i := by linarith\n    have h\u2084 : p - 1 > 0 := by linarith\n    -- Use the property of real powers to show that the power is non-negative\n    have h\u2085 : 0 \u2264 (u i + v i) ^ (p - 1) := by\n      -- If the base is zero, the power is zero (since p - 1 > 0)\n      by_cases h\u2086 : u i + v i = 0\n      \u00b7 have h\u2087 : (u i + v i : \u211d) = 0 := by exact_mod_cast h\u2086\n        have h\u2088 : (u i + v i : \u211d) ^ (p - 1 : \u211d) = 0 := by\n          rw [h\u2087]\n          have h\u2089 : (p - 1 : \u211d) > 0 := by exact_mod_cast h\u2084\n          have h\u2081\u2080 : (0 : \u211d) ^ (p - 1 : \u211d) = 0 := by\n            apply Real.zero_rpow\n            linarith\n          exact h\u2081\u2080\n        have h\u2089 : 0 \u2264 (u i + v i : \u211d) ^ (p - 1 : \u211d) := by\n          rw [h\u2088]\n          <;> norm_num\n        exact_mod_cast h\u2089\n      \u00b7 -- If the base is positive, the power is positive\n        have h\u2087 : 0 < u i + v i := by\n          contrapose! h\u2086\n          linarith\n        have h\u2088 : 0 < (u i + v i : \u211d) := by exact_mod_cast h\u2087\n        have h\u2089 : 0 < (u i + v i : \u211d) ^ (p - 1 : \u211d) := by\n          apply Real.rpow_pos_of_pos h\u2088 _\n        have h\u2081\u2080 : 0 \u2264 (u i + v i : \u211d) ^ (p - 1 : \u211d) := by linarith\n        exact_mod_cast h\u2081\u2080\n    exact h\u2085\n  \n  have h_sum_yq : (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) = \u2211 i : Fin n, (u i + v i) ^ p := by\n    have h\u2081 : \u2200 (i : Fin n), ((u i + v i) ^ (p - 1)) ^ q = (u i + v i) ^ p := by\n      intro i\n      have h\u2082 : 0 \u2264 u i := hu i\n      have h\u2083 : 0 \u2264 v i := hv i\n      have h\u2084 : 0 \u2264 u i + v i := by linarith\n      have h\u2085 : q * (p - 1) = p := hqp\n      have h\u2086 : (p - 1 : \u211d) > 0 := by\n        have h\u2087 : (p : \u211d) > 1 := by exact_mod_cast hp\n        linarith\n      have h\u2087 : (q : \u211d) > 0 := by\n        have h\u2088 : (q : \u211d) > 1 := by exact_mod_cast hq_gt_one\n        linarith\n      -- Use the property of exponents to simplify the expression\n      by_cases h\u2088 : (u i + v i : \u211d) = 0\n      \u00b7 -- Case: u i + v i = 0\n        have h\u2089 : (u i + v i : \u211d) ^ (p - 1 : \u211d) = 0 := by\n          have h\u2081\u2080 : (p - 1 : \u211d) > 0 := by exact_mod_cast h\u2086\n          have h\u2081\u2081 : (u i + v i : \u211d) = 0 := by exact_mod_cast h\u2088\n          rw [h\u2081\u2081]\n          have h\u2081\u2082 : (0 : \u211d) ^ (p - 1 : \u211d) = 0 := by\n            apply Real.zero_rpow\n            linarith\n          exact h\u2081\u2082\n        have h\u2081\u2080 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ (q : \u211d) = 0 := by\n          rw [h\u2089]\n          have h\u2081\u2081 : (q : \u211d) > 0 := by exact_mod_cast h\u2087\n          have h\u2081\u2082 : (0 : \u211d) ^ (q : \u211d) = 0 := by\n            apply Real.zero_rpow\n            linarith\n          exact h\u2081\u2082\n        have h\u2081\u2081 : (u i + v i : \u211d) ^ (p : \u211d) = 0 := by\n          have h\u2081\u2082 : (u i + v i : \u211d) = 0 := by exact_mod_cast h\u2088\n          rw [h\u2081\u2082]\n          have h\u2081\u2083 : (p : \u211d) > 0 := by\n            have h\u2081\u2084 : (p : \u211d) > 1 := by exact_mod_cast hp\n            linarith\n          have h\u2081\u2084 : (0 : \u211d) ^ (p : \u211d) = 0 := by\n            apply Real.zero_rpow\n            linarith\n          exact h\u2081\u2084\n        -- Simplify both sides to 0\n        have h\u2081\u2082 : ((u i + v i) ^ (p - 1)) ^ q = (u i + v i) ^ p := by\n          norm_cast at h\u2081\u2080 h\u2081\u2081 \u22a2\n          <;> simp_all [h\u2088]\n          <;> norm_num\n          <;> linarith\n        exact h\u2081\u2082\n      \u00b7 -- Case: u i + v i > 0\n        have h\u2089 : 0 < (u i + v i : \u211d) := by\n          have h\u2081\u2080 : 0 \u2264 (u i + v i : \u211d) := by\n            have h\u2081\u2081 : 0 \u2264 (u i : \u211d) := by exact_mod_cast hu i\n            have h\u2081\u2082 : 0 \u2264 (v i : \u211d) := by exact_mod_cast hv i\n            linarith\n          have h\u2081\u2081 : (u i + v i : \u211d) \u2260 0 := by\n            intro h\u2081\u2082\n            apply h\u2088\n            exact_mod_cast h\u2081\u2082\n          contrapose! h\u2081\u2081\n          linarith\n        -- Use the property of exponents to simplify the expression\n        have h\u2081\u2080 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ (q : \u211d) = (u i + v i : \u211d) ^ ((p - 1 : \u211d) * (q : \u211d)) := by\n          rw [\u2190 Real.rpow_mul (le_of_lt h\u2089)]\n          <;> ring_nf\n          <;> field_simp\n          <;> ring_nf\n        have h\u2081\u2081 : (p - 1 : \u211d) * (q : \u211d) = (p : \u211d) := by\n          have h\u2081\u2082 : (q : \u211d) * (p - 1 : \u211d) = (p : \u211d) := by\n            norm_cast at hqp \u22a2\n            <;> linarith\n          linarith\n        have h\u2081\u2082 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ (q : \u211d) = (u i + v i : \u211d) ^ (p : \u211d) := by\n          rw [h\u2081\u2080]\n          rw [h\u2081\u2081]\n          <;> norm_cast\n        -- Simplify both sides\n        have h\u2081\u2083 : ((u i + v i) ^ (p - 1)) ^ q = (u i + v i) ^ p := by\n          norm_cast at h\u2081\u2082 \u22a2\n          <;> simp_all [Real.rpow_def_of_pos]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> linarith\n        exact h\u2081\u2083\n    -- Sum over all i to get the final result\n    calc\n      (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) = \u2211 i : Fin n, (u i + v i) ^ p := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u2081 i]\n      _ = \u2211 i : Fin n, (u i + v i) ^ p := by rfl\n  \n  have h_main : \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n    have h\u2081 : \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) := by\n      have h\u2082 : 1 < (p : \u211d) := by exact_mod_cast hp\n      have h\u2083 : 1 < (q : \u211d) := by exact_mod_cast hq_gt_one\n      have h\u2084 : 1 / (p : \u211d) + 1 / (q : \u211d) = 1 := by\n        have h\u2085 : (1 : \u211d) / p + (1 : \u211d) / q = 1 := h_inv_pq\n        exact_mod_cast h\u2085\n      have h\u2085 : \u2200 (i : Fin n), 0 \u2264 (u i : \u211d) := by\n        intro i\n        exact_mod_cast hu i\n      have h\u2086 : \u2200 (i : Fin n), 0 \u2264 ((u i + v i) ^ (p - 1) : \u211d) := by\n        intro i\n        exact_mod_cast h_nonneg_y i\n      have h\u2087 : \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, ((u i : \u211d) ^ p)) ^ (1 / p) * (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) ^ (1 / q) := by\n        have h\u2088 : \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, ((u i : \u211d) ^ p)) ^ (1 / p) * (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) ^ (1 / q) := by\n          -- Use the H\u00f6lder's inequality provided in the hypothesis\n          have h\u2089 : \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, ((u i : \u211d) ^ p)) ^ (1 / p) * (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) ^ (1 / q) := by\n            -- Apply the H\u00f6lder's inequality\n            have h\u2081\u2080 : \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, ((u i : \u211d) ^ p)) ^ (1 / p) * (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) ^ (1 / q) := by\n              -- Use the H\u00f6lder's inequality provided in the hypothesis\n              have h\u2081\u2081 : \u2200 (i : Fin n), 0 \u2264 (u i : \u211d) := by\n                intro i\n                exact_mod_cast hu i\n              have h\u2081\u2082 : \u2200 (i : Fin n), 0 \u2264 ((u i + v i) ^ (p - 1) : \u211d) := by\n                intro i\n                exact_mod_cast h_nonneg_y i\n              have h\u2081\u2083 : 1 < (p : \u211d) := by exact_mod_cast hp\n              have h\u2081\u2084 : 1 < (q : \u211d) := by exact_mod_cast hq_gt_one\n              have h\u2081\u2085 : (1 : \u211d) / p + (1 : \u211d) / q = 1 := by\n                have h\u2081\u2086 : (1 : \u211d) / p + (1 : \u211d) / q = 1 := h_inv_pq\n                exact_mod_cast h\u2081\u2086\n              -- Apply the H\u00f6lder's inequality\n              have h\u2081\u2086 : \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, ((u i : \u211d) ^ p)) ^ (1 / p) * (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) ^ (1 / q) := by\n                -- Use the H\u00f6lder's inequality provided in the hypothesis\n                exact holder_ineq (fun i => (u i : \u211d)) (fun i => ((u i + v i) ^ (p - 1) : \u211d)) h\u2081\u2081 h\u2081\u2082 h\u2081\u2083 h\u2081\u2084 h\u2081\u2085\n              exact h\u2081\u2086\n            exact h\u2081\u2080\n          exact h\u2089\n        exact h\u2088\n      -- Convert the sum back to the original form\n      have h\u2089 : \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) = \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) := by\n        simp [Finset.sum_congr]\n        <;> norm_cast\n      have h\u2081\u2080 : (\u2211 i : Fin n, ((u i : \u211d) ^ p)) = \u2211 i : Fin n, (u i) ^ p := by\n        simp [Finset.sum_congr]\n        <;> norm_cast\n      have h\u2081\u2081 : (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) = \u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q := by\n        simp [Finset.sum_congr]\n        <;> norm_cast\n      -- Combine all the results to get the final inequality\n      calc\n        \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) = \u2211 i : Fin n, (u i : \u211d) * ((u i + v i) ^ (p - 1) : \u211d) := by\n          simp [Finset.sum_congr]\n          <;> norm_cast\n        _ \u2264 (\u2211 i : Fin n, ((u i : \u211d) ^ p)) ^ (1 / p) * (\u2211 i : Fin n, (((u i + v i) ^ (p - 1) : \u211d) ^ q)) ^ (1 / q) := by\n          exact h\u2087\n        _ = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) := by\n          simp_all [h\u2081\u2080, h\u2081\u2081]\n          <;> norm_cast\n          <;> field_simp\n          <;> ring_nf\n          <;> norm_num\n          <;> linarith\n    -- Use the fact that the sum of ((u_i + v_i)^(p-1))^q is equal to the sum of (u_i + v_i)^p\n    have h\u2082 : (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) = (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n      rw [h_sum_yq]\n      <;>\n      simp_all [Finset.sum_congr]\n      <;>\n      norm_cast\n      <;>\n      field_simp\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith\n    -- Combine the inequalities to get the final result\n    calc\n      \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) := by\n        exact h\u2081\n      _ = (\u2211 i : Fin n, (u i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n        rw [h\u2082]\n        <;>\n        simp_all [Finset.sum_congr]\n        <;>\n        norm_cast\n        <;>\n        field_simp\n        <;>\n        ring_nf\n        <;>\n        norm_num\n        <;>\n        linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequences u and v are correctly formalized as functions from Fin n to \u211d with appropriate nonnegativity constraints", "The condition p > 1 is directly and correctly translated", "The definition q = p/(p-1) is accurately captured", "H\u00f6lder's inequality is properly formalized with all necessary mathematical conditions, including some implicit but required conditions", "The identity q(p-1) = p is correctly stated (multiplication order doesn't affect mathematical meaning)", "The main inequality conclusion is perfectly translated with identical mathematical structure"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Similarly,\n$$\n\\sum_{i=1}^n v_i(u_i+v_i)^{p-1}\\le\n\\left(\\sum_{i=1}^n v_i^p\\right)^{1/p}\n\\left(\\sum_{i=1}^n(u_i+v_i)^p\\right)^{1/q}.\n$$", "statement": "We assume:\n\u2022 $u=(u_i)_{i=1}^n$ and $v=(v_i)_{i=1}^n$ are sequences of $n$ nonnegative real numbers [tc_1].\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].\n\u2022 $q = p / (p-1)$ [def_1].\n\u2022 H\u00f6lder's inequality [def_2].\n\u2022 $q(p-1) = p$ [l2].\nTherefore, we conclude:\n\u2022 $\\sum_{i=1}^n v_i(u_i+v_i)^{p-1} \\le (\\sum_{i=1}^n v_i^p)^{1/p} (\\sum_{i=1}^n (u_i+v_i)^p)^{1/q}$ [l4].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (n : \u2115) \n  (u v : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (hp : p > 1)\n  (q : \u211d)\n  (hq : q = p / (p - 1))\n  (tc_1 : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i)\n  (h\u00f6lder : \u2200 (x y : Fin n \u2192 \u211d) (\u03b1 \u03b2 : \u211d), \n    (\u2200 i, 0 \u2264 x i) \u2192 \n    (\u2200 i, 0 \u2264 y i) \u2192 \n    1 < \u03b1 \u2192 \n    1 < \u03b2 \u2192 \n    1/\u03b1 + 1/\u03b2 = 1 \u2192 \n    \u2211 i : Fin n, x i * y i \u2264 (\u2211 i : Fin n, (x i)^\u03b1)^(1/\u03b1) * (\u2211 i : Fin n, (y i)^\u03b2)^(1/\u03b2))\n  (l2 : q * (p - 1) = p) :\n  \u2211 i : Fin n, v i * (u i + v i)^(p - 1) \u2264 \n  (\u2211 i : Fin n, (v i)^p)^(1/p) * (\u2211 i : Fin n, (u i + v i)^p)^(1/q) := by sorry", "lean_pass": false, "error_msg": [], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (n : \u2115) \n  (u v : Fin n \u2192 \u211d)\n  (p : \u211d)\n  (hp : p > 1)\n  (q : \u211d)\n  (hq : q = p / (p - 1))\n  (tc_1 : \u2200 i, 0 \u2264 u i \u2227 0 \u2264 v i)\n  (h\u00f6lder : \u2200 (x y : Fin n \u2192 \u211d) (\u03b1 \u03b2 : \u211d), \n    (\u2200 i, 0 \u2264 x i) \u2192 \n    (\u2200 i, 0 \u2264 y i) \u2192 \n    1 < \u03b1 \u2192 \n    1 < \u03b2 \u2192 \n    1/\u03b1 + 1/\u03b2 = 1 \u2192 \n    \u2211 i : Fin n, x i * y i \u2264 (\u2211 i : Fin n, (x i)^\u03b1)^(1/\u03b1) * (\u2211 i : Fin n, (y i)^\u03b2)^(1/\u03b2))\n  (l2 : q * (p - 1) = p) :\n  \u2211 i : Fin n, v i * (u i + v i)^(p - 1) \u2264 \n  (\u2211 i : Fin n, (v i)^p)^(1/p) * (\u2211 i : Fin n, (u i + v i)^p)^(1/q) := by\n  have hq_gt_one : q > 1 := by\n    have h\u2081 : p - 1 > 0 := by linarith\n    have h\u2082 : q = p / (p - 1) := hq\n    rw [h\u2082]\n    have h\u2083 : (p : \u211d) / (p - 1) > 1 := by\n      have h\u2084 : 0 < (p - 1 : \u211d) := by linarith\n      have h\u2085 : (p : \u211d) > (p - 1 : \u211d) := by linarith\n      have h\u2086 : (p : \u211d) / (p - 1) > 1 := by\n        rw [gt_iff_lt]\n        rw [lt_div_iff h\u2084]\n        nlinarith\n      exact h\u2086\n    linarith\n  \n  have h_inv_p_add_inv_q : 1 / p + 1 / q = 1 := by\n    have h\u2081 : q = p / (p - 1) := hq\n    have h\u2082 : p - 1 \u2260 0 := by linarith\n    have h\u2083 : 1 / q = (p - 1) / p := by\n      have h\u2084 : q = p / (p - 1) := hq\n      rw [h\u2084]\n      field_simp [h\u2082, sub_ne_zero.mpr (show (p : \u211d) \u2260 1 by linarith)]\n      <;> ring_nf\n      <;> field_simp [h\u2082, sub_ne_zero.mpr (show (p : \u211d) \u2260 1 by linarith)]\n      <;> linarith\n    calc\n      1 / p + 1 / q = 1 / p + (p - 1) / p := by rw [h\u2083]\n      _ = 1 := by\n        have h\u2084 : p \u2260 0 := by linarith\n        field_simp [h\u2084]\n        <;> ring_nf\n        <;> field_simp [h\u2084]\n        <;> linarith\n  \n  have h_main : \u2211 i : Fin n, v i * (u i + v i)^(p - 1) \u2264 (\u2211 i : Fin n, (v i)^p)^(1/p) * (\u2211 i : Fin n, ((u i + v i)^(p - 1))^q)^(1/q) := by\n    have h\u2081 : \u2200 i : Fin n, 0 \u2264 v i := by\n      intro i\n      have h\u2082 := tc_1 i\n      linarith\n    have h\u2082 : \u2200 i : Fin n, 0 \u2264 (u i + v i : \u211d) := by\n      intro i\n      have h\u2083 := tc_1 i\n      linarith\n    have h\u2083 : \u2200 i : Fin n, 0 \u2264 (u i + v i : \u211d) ^ (p - 1 : \u211d) := by\n      intro i\n      have h\u2084 : 0 \u2264 (u i + v i : \u211d) := h\u2082 i\n      have h\u2085 : (p - 1 : \u211d) > 0 := by\n        have h\u2086 : (p : \u211d) > 1 := hp\n        linarith\n      exact Real.rpow_nonneg h\u2084 (p - 1)\n    have h\u2084 : \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (v i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) := by\n      have h\u2085 : 1 < (p : \u211d) := by exact_mod_cast hp\n      have h\u2086 : 1 < (q : \u211d) := by exact_mod_cast hq_gt_one\n      have h\u2087 : 1 / (p : \u211d) + 1 / (q : \u211d) = 1 := by\n        simpa [hq] using h_inv_p_add_inv_q\n      have h\u2088 : \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (v i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) := by\n        have h\u2089 := h\u00f6lder (fun i => v i) (fun i => (u i + v i) ^ (p - 1)) p q h\u2081 h\u2083 (by linarith) (by linarith) (by\n          have h\u2081\u2080 : (1 : \u211d) / p + (1 : \u211d) / q = 1 := by\n            simpa [hq] using h_inv_p_add_inv_q\n          simpa [hq] using h\u2081\u2080)\n        simpa using h\u2089\n      exact h\u2088\n    exact h\u2084\n  \n  have h_sum_y_pow_q : (\u2211 i : Fin n, ((u i + v i)^(p - 1))^q) = \u2211 i : Fin n, (u i + v i)^p := by\n    have h\u2081 : \u2200 i : Fin n, ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ q = (u i + v i : \u211d) ^ p := by\n      intro i\n      have h\u2082 : 0 \u2264 (u i + v i : \u211d) := by\n        have h\u2083 := tc_1 i\n        linarith\n      have h\u2083 : (q : \u211d) * (p - 1 : \u211d) = p := by\n        have h\u2084 : q * (p - 1) = p := l2\n        exact_mod_cast h\u2084\n      have h\u2084 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ q = (u i + v i : \u211d) ^ ((p - 1 : \u211d) * q) := by\n        by_cases h\u2085 : (u i + v i : \u211d) = 0\n        \u00b7 -- Case: u i + v i = 0\n          have h\u2086 : (p - 1 : \u211d) > 0 := by\n            have h\u2087 : (p : \u211d) > 1 := by exact_mod_cast hp\n            linarith\n          have h\u2087 : (q : \u211d) > 0 := by\n            have h\u2088 : (q : \u211d) > 1 := by exact_mod_cast hq_gt_one\n            linarith\n          have h\u2088 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) = 0 := by\n            rw [h\u2085]\n            have h\u2089 : (0 : \u211d) ^ (p - 1 : \u211d) = 0 := by\n              have h\u2081\u2080 : (p - 1 : \u211d) > 0 := by\n                have h\u2081\u2081 : (p : \u211d) > 1 := by exact_mod_cast hp\n                linarith\n              have h\u2081\u2081 : (0 : \u211d) ^ (p - 1 : \u211d) = 0 := by\n                have h\u2081\u2082 : (p - 1 : \u211d) > 0 := by linarith\n                simp [Real.zero_rpow, h\u2081\u2082.ne']\n              exact h\u2081\u2081\n            exact h\u2089\n          have h\u2089 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ q = 0 := by\n            rw [h\u2088]\n            have h\u2081\u2080 : (q : \u211d) > 0 := by\n              have h\u2081\u2081 : (q : \u211d) > 1 := by exact_mod_cast hq_gt_one\n              linarith\n            have h\u2081\u2081 : (0 : \u211d) ^ (q : \u211d) = 0 := by\n              have h\u2081\u2082 : (q : \u211d) > 0 := by linarith\n              simp [Real.zero_rpow, h\u2081\u2082.ne']\n            exact h\u2081\u2081\n          have h\u2081\u2080 : (u i + v i : \u211d) ^ ((p - 1 : \u211d) * q) = 0 := by\n            have h\u2081\u2081 : (u i + v i : \u211d) = 0 := h\u2085\n            rw [h\u2081\u2081]\n            have h\u2081\u2082 : (p - 1 : \u211d) * q > 0 := by\n              have h\u2081\u2083 : (p - 1 : \u211d) > 0 := by\n                have h\u2081\u2084 : (p : \u211d) > 1 := by exact_mod_cast hp\n                linarith\n              have h\u2081\u2084 : (q : \u211d) > 0 := by\n                have h\u2081\u2085 : (q : \u211d) > 1 := by exact_mod_cast hq_gt_one\n                linarith\n              nlinarith\n            have h\u2081\u2083 : (0 : \u211d) ^ ((p - 1 : \u211d) * q) = 0 := by\n              have h\u2081\u2084 : (p - 1 : \u211d) * q > 0 := by linarith\n              simp [Real.zero_rpow, h\u2081\u2084.ne']\n            exact h\u2081\u2083\n          linarith\n        \u00b7 -- Case: u i + v i \u2260 0\n          have h\u2085 : (u i + v i : \u211d) > 0 := by\n            have h\u2086 : 0 \u2264 (u i + v i : \u211d) := by\n              have h\u2087 := tc_1 i\n              linarith\n            contrapose! h\u2085\n            linarith\n          have h\u2086 : ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ q = (u i + v i : \u211d) ^ ((p - 1 : \u211d) * q) := by\n            calc\n              ((u i + v i : \u211d) ^ (p - 1 : \u211d)) ^ q = (u i + v i : \u211d) ^ ((p - 1 : \u211d) * q) := by\n                rw [\u2190 Real.rpow_mul (le_of_lt h\u2085)]\n                <;> ring_nf\n              _ = (u i + v i : \u211d) ^ ((p - 1 : \u211d) * q) := by rfl\n          rw [h\u2086]\n      have h\u2085 : (u i + v i : \u211d) ^ ((p - 1 : \u211d) * q) = (u i + v i : \u211d) ^ (p : \u211d) := by\n        have h\u2086 : (q : \u211d) * (p - 1 : \u211d) = p := by\n          have h\u2087 : q * (p - 1) = p := l2\n          exact_mod_cast h\u2087\n        have h\u2087 : ((p - 1 : \u211d) * q : \u211d) = p := by\n          linarith\n        rw [show ((p - 1 : \u211d) * q : \u211d) = p by linarith]\n        <;>\n        simp [Real.rpow_def_of_pos (by\n          have h\u2088 : 0 < (u i + v i : \u211d) := by\n            have h\u2089 : 0 \u2264 (u i + v i : \u211d) := by\n              have h\u2081\u2080 := tc_1 i\n              linarith\n            by_contra h\u2081\u2080\n            have h\u2081\u2081 : (u i + v i : \u211d) \u2264 0 := by linarith\n            have h\u2081\u2082 : (u i + v i : \u211d) = 0 := by linarith\n            contradiction\n          linarith)]\n        <;>\n        ring_nf\n        <;>\n        simp_all [Real.exp_log]\n        <;>\n        field_simp\n        <;>\n        ring_nf\n        <;>\n        linarith\n      rw [h\u2084, h\u2085]\n      <;>\n      simp [Real.rpow_def_of_pos (by\n        have h\u2086 : 0 < (u i + v i : \u211d) := by\n          have h\u2087 : 0 \u2264 (u i + v i : \u211d) := by\n            have h\u2088 := tc_1 i\n            linarith\n          by_contra h\u2088\n          have h\u2089 : (u i + v i : \u211d) \u2264 0 := by linarith\n          have h\u2081\u2080 : (u i + v i : \u211d) = 0 := by linarith\n          contradiction\n        linarith)]\n      <;>\n      ring_nf\n      <;>\n      simp_all [Real.exp_log]\n      <;>\n      field_simp\n      <;>\n      ring_nf\n      <;>\n      linarith\n    calc\n      (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) = \u2211 i : Fin n, (u i + v i) ^ p := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h\u2081 i]\n      _ = \u2211 i : Fin n, (u i + v i) ^ p := by rfl\n  \n  have h_final : (\u2211 i : Fin n, ((u i + v i)^(p - 1))^q)^(1/q) = (\u2211 i : Fin n, (u i + v i)^p)^(1/q) := by\n    rw [h_sum_y_pow_q]\n    <;>\n    simp_all [Real.rpow_def_of_pos]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h_result : \u2211 i : Fin n, v i * (u i + v i)^(p - 1) \u2264 (\u2211 i : Fin n, (v i)^p)^(1/p) * (\u2211 i : Fin n, (u i + v i)^p)^(1/q) := by\n    calc\n      \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (v i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) := h_main\n      _ = (\u2211 i : Fin n, (v i) ^ p) ^ (1 / p) * (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n        have h\u2081 : (\u2211 i : Fin n, ((u i + v i) ^ (p - 1)) ^ q) ^ (1 / q) = (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / q) := by\n          rw [h_final]\n        rw [h\u2081]\n        <;>\n        simp_all [Real.rpow_def_of_pos]\n        <;>\n        norm_num\n        <;>\n        linarith\n  \n  exact h_result", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This, \\eqref{eq:8.1.9}, and \\eqref{eq:8.1.10} imply that\n$$\n\\sum_{i=1}^n(u_i+v_i)^p\n\\le\\left[\\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}\n+\\left(\\sum_{i=1}^n v_i^p\\right)^{1/p}\\right]\n\\left(\\sum_{i=1}^n(u_i+v_i)^p\\right)^{1/q}.\n$$", "statement": "We assume:\n\u2022 $\\sum_{i=1}^n(u_i+v_i)^p = \\sum_{i=1}^n u_i(u_i+v_i)^{p-1} + \\sum_{i=1}^n v_i(u_i+v_i)^{p-1}$ [l1].\n\u2022 $\\sum_{i=1}^n u_i(u_i+v_i)^{p-1} \\le (\\sum_{i=1}^n u_i^p)^{1/p} (\\sum_{i=1}^n (u_i+v_i)^p)^{1/q}$ [l3].\n\u2022 $\\sum_{i=1}^n v_i(u_i+v_i)^{p-1} \\le (\\sum_{i=1}^n v_i^p)^{1/p} (\\sum_{i=1}^n (u_i+v_i)^p)^{1/q}$ [l4].\nTherefore, we conclude:\n\u2022 $\\sum_{i=1}^n(u_i+v_i)^p \\le \\left[ (\\sum_{i=1}^n u_i^p)^{1/p} + (\\sum_{i=1}^n v_i^p)^{1/p} \\right] (\\sum_{i=1}^n (u_i+v_i)^p)^{1/q}$ [l5].", "dependencies": ["l1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {n : \u2115} (u v : Fin n \u2192 \u211d) (p q : \u211d)\n  (hu : \u2200 i, 0 \u2264 u i)\n  (hv : \u2200 i, 0 \u2264 v i)\n  (hp : p > 1)\n  (hq_def : q = p / (p - 1))\n  (hq_pos : q > 0)\n  (l1 : \u2211 i, (u i + v i)^p = \u2211 i, u i * (u i + v i)^(p-1) + \u2211 i, v i * (u i + v i)^(p-1))\n  (l3 : \u2211 i, u i * (u i + v i)^(p - 1) \u2264 (\u2211 i, (u i)^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q))\n  (l4 : \u2211 i, v i * (u i + v i)^(p - 1) \u2264 (\u2211 i, (v i)^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q)) :\n  (\u2211 i, (u i + v i)^p)^(1/p) \u2264 (\u2211 i, (u i)^p)^(1/p) + (\u2211 i, (v i)^p)^(1/p) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {n : \u2115} (u v : Fin n \u2192 \u211d) (p q : \u211d)\n  (hu : \u2200 i, 0 \u2264 u i)\n  (hv : \u2200 i, 0 \u2264 v i)\n  (hp : p > 1)\n  (hq_def : q = p / (p - 1))\n  (hq_pos : q > 0)\n  (l1 : \u2211 i, (u i + v i)^p = \u2211 i, u i * (u i + v i)^(p-1) + \u2211 i, v i * (u i + v i)^(p-1))\n  (l3 : \u2211 i, u i * (u i + v i)^(p - 1) \u2264 (\u2211 i, (u i)^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q))\n  (l4 : \u2211 i, v i * (u i + v i)^(p - 1) \u2264 (\u2211 i, (v i)^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q)) :\n  (\u2211 i, (u i + v i)^p)^(1/p) \u2264 (\u2211 i, (u i)^p)^(1/p) + (\u2211 i, (v i)^p)^(1/p) := by\n  have h_sum_nonneg : 0 \u2264 \u2211 i : Fin n, (u i + v i)^p := by\n    apply Finset.sum_nonneg\n    intro i _\n    have h\u2081 : 0 \u2264 u i := hu i\n    have h\u2082 : 0 \u2264 v i := hv i\n    have h\u2083 : 0 \u2264 u i + v i := by linarith\n    have h\u2084 : 0 \u2264 (u i + v i) ^ p := by\n      exact Real.rpow_nonneg h\u2083 p\n    exact h\u2084\n  \n  have h_main : (\u2211 i, (u i + v i)^p)^(1/p) \u2264 (\u2211 i, (u i)^p)^(1/p) + (\u2211 i, (v i)^p)^(1/p) := by\n    by_cases h : (\u2211 i : Fin n, (u i + v i) ^ p) = 0\n    \u00b7 -- Case: \u2211 (u_i + v_i)^p = 0\n      have h\u2081 : \u2200 i : Fin n, (u i + v i) ^ p = 0 := by\n        have h\u2082 : \u2211 i : Fin n, (u i + v i) ^ p = 0 := h\n        have h\u2083 : \u2200 i : Fin n, 0 \u2264 (u i + v i) ^ p := by\n          intro i\n          have h\u2084 : 0 \u2264 u i := hu i\n          have h\u2085 : 0 \u2264 v i := hv i\n          have h\u2086 : 0 \u2264 u i + v i := by linarith\n          exact Real.rpow_nonneg h\u2086 p\n        have h\u2084 : \u2200 i : Fin n, (u i + v i) ^ p = 0 := by\n          intro i\n          have h\u2085 : 0 \u2264 (u i + v i) ^ p := h\u2083 i\n          have h\u2086 : \u2211 i : Fin n, (u i + v i) ^ p = 0 := h\u2082\n          have h\u2087 : (u i + v i) ^ p \u2264 0 := by\n            have h\u2088 : (u i + v i) ^ p \u2264 \u2211 i : Fin n, (u i + v i) ^ p := by\n              exact Finset.single_le_sum (fun j _ => h\u2083 j) (Finset.mem_univ i)\n            linarith\n          linarith\n        exact h\u2084\n      have h\u2082 : \u2200 i : Fin n, u i = 0 := by\n        intro i\n        have h\u2083 : (u i + v i) ^ p = 0 := h\u2081 i\n        have h\u2084 : 0 \u2264 u i := hu i\n        have h\u2085 : 0 \u2264 v i := hv i\n        have h\u2086 : 0 \u2264 u i + v i := by linarith\n        have h\u2087 : u i + v i = 0 := by\n          by_contra h\u2088\n          have h\u2089 : 0 < u i + v i := by\n            have h\u2081\u2080 : 0 \u2264 u i + v i := by linarith\n            contrapose! h\u2088\n            linarith\n          have h\u2081\u2080 : (u i + v i) ^ p > 0 := Real.rpow_pos_of_pos h\u2089 p\n          linarith\n        have h\u2088 : u i = 0 := by\n          have h\u2089 : 0 \u2264 u i := hu i\n          have h\u2081\u2080 : 0 \u2264 v i := hv i\n          have h\u2081\u2081 : u i + v i = 0 := h\u2087\n          linarith\n        exact h\u2088\n      have h\u2083 : \u2200 i : Fin n, v i = 0 := by\n        intro i\n        have h\u2084 : (u i + v i) ^ p = 0 := h\u2081 i\n        have h\u2085 : 0 \u2264 u i := hu i\n        have h\u2086 : 0 \u2264 v i := hv i\n        have h\u2087 : 0 \u2264 u i + v i := by linarith\n        have h\u2088 : u i + v i = 0 := by\n          by_contra h\u2089\n          have h\u2081\u2080 : 0 < u i + v i := by\n            have h\u2081\u2081 : 0 \u2264 u i + v i := by linarith\n            contrapose! h\u2089\n            linarith\n          have h\u2081\u2081 : (u i + v i) ^ p > 0 := Real.rpow_pos_of_pos h\u2081\u2080 p\n          linarith\n        have h\u2089 : v i = 0 := by\n          have h\u2081\u2080 : 0 \u2264 u i := hu i\n          have h\u2081\u2081 : 0 \u2264 v i := hv i\n          have h\u2081\u2082 : u i + v i = 0 := h\u2088\n          linarith\n        exact h\u2089\n      have h\u2084 : (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p : \u211d) = 0 := by\n        have h\u2085 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) = 0 := by exact_mod_cast h\n        rw [h\u2085]\n        have h\u2086 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n          have h\u2087 : (1 : \u211d) / p > 0 := by\n            have h\u2088 : p > 1 := hp\n            have h\u2089 : (p : \u211d) > 1 := by exact_mod_cast h\u2088\n            positivity\n          have h\u2088 : (1 : \u211d) / p \u2260 0 := by linarith\n          -- Use the property of real power for zero base\n          have h\u2089 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n            rw [Real.zero_rpow] <;>\n            (try norm_num) <;>\n            (try linarith) <;>\n            (try simp_all) <;>\n            (try field_simp [h\u2088]) <;>\n            (try ring_nf) <;>\n            (try norm_num) <;>\n            (try linarith)\n          exact h\u2089\n        rw [h\u2086]\n      have h\u2085 : (\u2211 i : Fin n, (u i) ^ p : \u211d) = 0 := by\n        have h\u2086 : \u2200 i : Fin n, (u i : \u211d) ^ p = 0 := by\n          intro i\n          have h\u2087 : u i = 0 := h\u2082 i\n          rw [h\u2087]\n          have h\u2088 : (0 : \u211d) ^ p = 0 := by\n            have h\u2089 : p > 0 := by linarith\n            have h\u2081\u2080 : (0 : \u211d) ^ p = 0 := by\n              have h\u2081\u2081 : p \u2260 0 := by linarith\n              simp [h\u2081\u2081, Real.zero_rpow, h\u2089.ne']\n            exact h\u2081\u2080\n          exact h\u2088\n        calc\n          (\u2211 i : Fin n, (u i : \u211d) ^ p) = \u2211 i : Fin n, 0 := by\n            apply Finset.sum_congr rfl\n            intro i _\n            exact h\u2086 i\n          _ = 0 := by simp\n      have h\u2086 : (\u2211 i : Fin n, (v i) ^ p : \u211d) = 0 := by\n        have h\u2087 : \u2200 i : Fin n, (v i : \u211d) ^ p = 0 := by\n          intro i\n          have h\u2088 : v i = 0 := h\u2083 i\n          rw [h\u2088]\n          have h\u2089 : (0 : \u211d) ^ p = 0 := by\n            have h\u2081\u2080 : p > 0 := by linarith\n            have h\u2081\u2081 : (0 : \u211d) ^ p = 0 := by\n              have h\u2081\u2082 : p \u2260 0 := by linarith\n              simp [h\u2081\u2082, Real.zero_rpow, h\u2081\u2080.ne']\n            exact h\u2081\u2081\n          exact h\u2089\n        calc\n          (\u2211 i : Fin n, (v i : \u211d) ^ p) = \u2211 i : Fin n, 0 := by\n            apply Finset.sum_congr rfl\n            intro i _\n            exact h\u2087 i\n          _ = 0 := by simp\n      have h\u2087 : (\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) = 0 := by\n        have h\u2088 : (\u2211 i : Fin n, (u i) ^ p : \u211d) = 0 := h\u2085\n        rw [h\u2088]\n        have h\u2089 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n          have h\u2081\u2080 : (1 : \u211d) / p > 0 := by\n            have h\u2081\u2081 : p > 1 := hp\n            have h\u2081\u2082 : (p : \u211d) > 1 := by exact_mod_cast h\u2081\u2081\n            positivity\n          have h\u2081\u2081 : (1 : \u211d) / p \u2260 0 := by linarith\n          -- Use the property of real power for zero base\n          have h\u2081\u2082 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n            rw [Real.zero_rpow] <;>\n            (try norm_num) <;>\n            (try linarith) <;>\n            (try simp_all) <;>\n            (try field_simp [h\u2081\u2081]) <;>\n            (try ring_nf) <;>\n            (try norm_num) <;>\n            (try linarith)\n          exact h\u2081\u2082\n        rw [h\u2089]\n      have h\u2088 : (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) = 0 := by\n        have h\u2089 : (\u2211 i : Fin n, (v i) ^ p : \u211d) = 0 := h\u2086\n        rw [h\u2089]\n        have h\u2081\u2080 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n          have h\u2081\u2081 : (1 : \u211d) / p > 0 := by\n            have h\u2081\u2082 : p > 1 := hp\n            have h\u2081\u2083 : (p : \u211d) > 1 := by exact_mod_cast h\u2081\u2082\n            positivity\n          have h\u2081\u2082 : (1 : \u211d) / p \u2260 0 := by linarith\n          -- Use the property of real power for zero base\n          have h\u2081\u2083 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n            rw [Real.zero_rpow] <;>\n            (try norm_num) <;>\n            (try linarith) <;>\n            (try simp_all) <;>\n            (try field_simp [h\u2081\u2082]) <;>\n            (try ring_nf) <;>\n            (try norm_num) <;>\n            (try linarith)\n          exact h\u2081\u2083\n        rw [h\u2081\u2080]\n      calc\n        (\u2211 i, (u i + v i) ^ p) ^ (1 / p : \u211d) = 0 := by simpa using h\u2084\n        _ \u2264 0 + 0 := by norm_num\n        _ = (\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) := by\n          rw [h\u2087, h\u2088]\n          <;> simp\n    \u00b7 -- Case: \u2211 (u_i + v_i)^p > 0\n      have h\u2081 : 0 < \u2211 i : Fin n, (u i + v i) ^ p := by\n        by_contra h\u2082\n        have h\u2083 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 0 := by linarith\n        have h\u2084 : \u2211 i : Fin n, (u i + v i) ^ p = 0 := by\n          have h\u2085 : 0 \u2264 \u2211 i : Fin n, (u i + v i) ^ p := h_sum_nonneg\n          linarith\n        contradiction\n      have h\u2082 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) > 0 := by exact_mod_cast h\u2081\n      have h\u2083 : \u2211 i : Fin n, (u i + v i) ^ p = \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) := by\n        simpa using l1\n      have h\u2084 : \u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n        simpa using l3\n      have h\u2085 : \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) \u2264 (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n        simpa using l4\n      have h\u2086 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n        calc\n          (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) = (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) : \u211d) := by\n            rw [h\u2083]\n            <;> simp [Finset.sum_add_distrib]\n          _ \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d)) := by\n            have h\u2087 : (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n              simpa using h\u2084\n            have h\u2088 : (\u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) : \u211d) \u2264 (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n              simpa using h\u2085\n            have h\u2089 : (\u2211 i : Fin n, u i * (u i + v i) ^ (p - 1) + \u2211 i : Fin n, v i * (u i + v i) ^ (p - 1) : \u211d) \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d)) := by\n              linarith\n            simpa [add_assoc] using h\u2089\n          _ = ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n            ring_nf\n            <;> field_simp [Real.rpow_add, Real.rpow_one, mul_assoc]\n            <;> ring_nf\n            <;> simp_all [Finset.sum_add_distrib]\n            <;> linarith\n      have h\u2087 : (1 : \u211d) - 1 / q = 1 / p := by\n        have h\u2088 : q = p / (p - 1) := hq_def\n        have h\u2089 : p - 1 > 0 := by linarith\n        have h\u2081\u2080 : (p : \u211d) > 1 := by exact_mod_cast hp\n        have h\u2081\u2081 : (p : \u211d) - 1 > 0 := by linarith\n        have h\u2081\u2082 : (q : \u211d) = (p : \u211d) / ((p : \u211d) - 1) := by\n          rw [h\u2088]\n          <;> field_simp [h\u2089.ne']\n          <;> ring_nf\n          <;> norm_num\n          <;> linarith\n        have h\u2081\u2083 : (1 : \u211d) / q = (p - 1) / p := by\n          rw [h\u2081\u2082]\n          field_simp [h\u2081\u2081.ne', sub_ne_zero.mpr (by linarith : (p : \u211d) \u2260 1)]\n          <;> ring_nf\n          <;> field_simp [h\u2081\u2081.ne']\n          <;> ring_nf\n          <;> linarith\n        have h\u2081\u2084 : (1 : \u211d) - 1 / q = 1 / p := by\n          rw [h\u2081\u2083]\n          have h\u2081\u2085 : (p : \u211d) > 0 := by linarith\n          field_simp [h\u2081\u2085.ne']\n          <;> ring_nf\n          <;> field_simp [h\u2081\u2085.ne']\n          <;> linarith\n        exact h\u2081\u2084\n      have h\u2088 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) \u2264 (\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) := by\n        have h\u2089 : 0 < (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) := h\u2082\n        have h\u2081\u2080 : 0 < (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n          apply Real.rpow_pos_of_pos h\u2089 _\n        have h\u2081\u2081 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := h\u2086\n        have h\u2081\u2082 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) \u2264 (\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d) := by\n          calc\n            (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) = ((\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d)) := by\n              have h\u2081\u2083 : (1 - 1 / q : \u211d) = 1 - 1 / q := by norm_num\n              have h\u2081\u2084 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) := rfl\n              have h\u2081\u2085 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) > 0 := h\u2082\n              have h\u2081\u2086 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) > 0 := by positivity\n              -- Use the property of exponents to simplify the expression\n              have h\u2081\u2087 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n                have h\u2081\u2088 : (1 - 1 / q : \u211d) = 1 - 1 / q := by norm_num\n                calc\n                  (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n                    rw [Real.rpow_sub (by positivity)] <;>\n                    (try norm_num) <;>\n                    (try linarith) <;>\n                    (try simp_all [Real.rpow_one]) <;>\n                    (try field_simp [h\u2081\u2086.ne']) <;>\n                    (try ring_nf) <;>\n                    (try norm_num) <;>\n                    (try linarith)\n                  _ = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n                    simp [Real.rpow_one]\n                    <;> field_simp [h\u2081\u2086.ne']\n                    <;> ring_nf\n                    <;> norm_num\n                    <;> linarith\n              rw [h\u2081\u2087]\n              <;> field_simp [h\u2081\u2080.ne']\n              <;> ring_nf\n              <;> norm_num\n              <;> linarith\n            _ \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) := by\n              have h\u2081\u2083 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := h\u2086\n              have h\u2081\u2084 : 0 < (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by positivity\n              have h\u2081\u2085 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) \u2264 ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) := by\n                calc\n                  (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) \u2264 (((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d)) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n                    gcongr\n                    <;> simp_all [h\u2081\u2083]\n                  _ = ((\u2211 i : Fin n, (u i) ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, (v i) ^ p : \u211d) ^ (1 / p : \u211d)) := by\n                    field_simp [h\u2081\u2084.ne']\n                    <;> ring_nf\n                    <;> norm_num\n                    <;> linarith\n              linarith\n        have h\u2081\u2083 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) := by\n          have h\u2081\u2084 : (1 : \u211d) - 1 / q = 1 / p := h\u2087\n          calc\n            (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) := rfl\n            _ = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) := by\n              rw [h\u2081\u2084]\n              <;>\n              simp [Real.rpow_sub, Real.rpow_one, h\u2082.le]\n              <;>\n              field_simp [h\u2082.ne']\n              <;>\n              ring_nf\n              <;>\n              norm_num\n              <;>\n              linarith\n        rw [h\u2081\u2083]\n        linarith\n      simpa using h\u2088\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The variable declarations, type specifications, and basic assumptions (non-negativity, p > 1, etc.) correctly capture the mathematical context, with appropriate additional technical details for formal verification.", "The premises l1, l3, and l4 are perfectly translated - l1 captures the algebraic identity exactly, while l3 and l4 correctly represent the H\u00f6lder-type inequalities with proper notation translation from summation to Lean syntax.", "The conclusion has a major inconsistency. The natural language states \u2211(u_i+v_i)^p \u2264 [...](\u2211(u_i+v_i)^p)^(1/q), but the Lean formalization concludes (\u2211(u_i+v_i)^p)^(1/p) \u2264 (...) without the (\u2211(u_i+v_i)^p)^(1/q) factor. The Lean version represents the final Minkowski inequality rather than the intermediate step [l5] described in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable declarations, type specifications, and basic assumptions (non-negativity, p > 1, etc.) correctly capture the mathematical context, with appropriate additional technical details for formal verification.', 'The premises l1, l3, and l4 are perfectly translated - l1 captures the algebraic identity exactly, while l3 and l4 correctly represent the H\u00f6lder-type inequalities with proper notation translation from summation to Lean syntax.', 'The conclusion has a major inconsistency. The natural language states \u2211(u_i+v_i)^p \u2264 [...](\u2211(u_i+v_i)^p)^(1/q), but the Lean formalization concludes (\u2211(u_i+v_i)^p)^(1/p) \u2264 (...) without the (\u2211(u_i+v_i)^p)^(1/q) factor. The Lean version represents the final Minkowski inequality rather than the intermediate step [l5] described in the natural language.']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since $1-1/q=1/p$", "statement": "We assume:\n\u2022 $p$ is a real number such that $p > 1$ [tc_2].\n\u2022 $q = p / (p - 1)$ [def_1].\nTherefore, we conclude:\n\u2022 $1 - 1/q = 1/p$ [l6].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (p q : \u211d) \n  (hp : p > 1)\n  (hq : q = p / (p - 1)) :\n  1 - 1/q = 1/p := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (p q : \u211d) \n  (hp : p > 1)\n  (hq : q = p / (p - 1)) :\n  1 - 1/q = 1/p := by\n  have h\u2081 : p - 1 > 0 := by\n    linarith\n  \n  have h\u2082 : q \u2260 0 := by\n    rw [hq]\n    have h\u2083 : p > 0 := by linarith\n    have h\u2084 : p - 1 \u2260 0 := by linarith\n    have h\u2085 : p / (p - 1) \u2260 0 := by\n      apply div_ne_zero\n      \u00b7 linarith\n      \u00b7 linarith\n    exact h\u2085\n  \n  have h\u2083 : p \u2260 0 := by\n    linarith\n  \n  have h\u2084 : 1 / q = (p - 1) / p := by\n    have h\u2085 : q = p / (p - 1) := hq\n    rw [h\u2085]\n    have h\u2086 : p - 1 \u2260 0 := by linarith\n    have h\u2087 : p \u2260 0 := by linarith\n    field_simp [h\u2086, h\u2087]\n    <;> ring_nf\n    <;> field_simp [h\u2086, h\u2087]\n    <;> ring_nf\n    <;> linarith\n  \n  have h\u2085 : 1 - 1 / q = 1 / p := by\n    rw [h\u2084]\n    have h\u2086 : p \u2260 0 := by linarith\n    field_simp [h\u2086]\n    <;> ring_nf\n    <;> field_simp [h\u2086]\n    <;> linarith\n  \n  rw [h\u2085]\n  <;>\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture that p and q are real numbers, with q being implicitly real in the natural language context", "The constraint p > 1 is perfectly represented as hypothesis hp", "The definition q = p / (p - 1) is exactly captured as hypothesis hq", "The conclusion 1 - 1/q = 1/p is precisely stated as the theorem goal"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since $1-1/q=1/p$, this implies \\eqref{eq:8.1.8}", "statement": "We assume:\n\u2022 $u = (u_i)_{i=1}^n$ and $v = (v_i)_{i=1}^n$ are sequences of $n$ nonnegative real numbers [tc_1].\n\u2022 $\\sum_{i=1}^n(u_i+v_i)^p \\le \\left[ (\\sum_{i=1}^n u_i^p)^{1/p} + (\\sum_{i=1}^n v_i^p)^{1/p} \\right] (\\sum_{i=1}^n (u_i+v_i)^p)^{1/q}$ [l5].\n\u2022 $1 - 1/q = 1/p$ [l6].\nTherefore, we conclude:\n\u2022 $(\\sum_{i=1}^n(u_i+v_i)^p)^{1/p} \\le (\\sum_{i=1}^n u_i^p)^{1/p} + (\\sum_{i=1}^n v_i^p)^{1/p}$ [ts_1].", "dependencies": ["tc_1", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {n : \u2115} (u v : Fin n \u2192 \u211d) (p q : \u211d)\n  (h_nonneg_u : \u2200 i, 0 \u2264 u i)\n  (h_nonneg_v : \u2200 i, 0 \u2264 v i)\n  (h_p_gt_one : p > 1)\n  (h_q_def : q = p / (p - 1))\n  (h_l5 : \u2211 i, (u i + v i)^p \u2264 (\u2211 i, u i^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q) + \n                      (\u2211 i, v i^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q))\n  (h_l6 : 1 - 1/q = 1/p) :\n  (\u2211 i, (u i + v i)^p)^(1/p) \u2264 (\u2211 i, u i^p)^(1/p) + (\u2211 i, v i^p)^(1/p) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {n : \u2115} (u v : Fin n \u2192 \u211d) (p q : \u211d)\n  (h_nonneg_u : \u2200 i, 0 \u2264 u i)\n  (h_nonneg_v : \u2200 i, 0 \u2264 v i)\n  (h_p_gt_one : p > 1)\n  (h_q_def : q = p / (p - 1))\n  (h_l5 : \u2211 i, (u i + v i)^p \u2264 (\u2211 i, u i^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q) + \n                      (\u2211 i, v i^p)^(1/p) * (\u2211 i, (u i + v i)^p)^(1/q))\n  (h_l6 : 1 - 1/q = 1/p) :\n  (\u2211 i, (u i + v i)^p)^(1/p) \u2264 (\u2211 i, u i^p)^(1/p) + (\u2211 i, v i^p)^(1/p) := by\n  have h_sum_nonneg : 0 \u2264 \u2211 i : Fin n, (u i + v i)^p := by\n    apply Finset.sum_nonneg\n    intro i _\n    have h\u2081 : 0 \u2264 u i := h_nonneg_u i\n    have h\u2082 : 0 \u2264 v i := h_nonneg_v i\n    have h\u2083 : 0 \u2264 u i + v i := by linarith\n    have h\u2084 : 0 \u2264 (u i + v i) ^ p := by\n      -- Since u i + v i \u2265 0 and p is a real number, (u i + v i)^p \u2265 0\n      exact Real.rpow_nonneg (by linarith) p\n    exact h\u2084\n  \n  have h_main : (\u2211 i : Fin n, (u i + v i)^p)^(1/p) \u2264 (\u2211 i : Fin n, u i^p)^(1/p) + (\u2211 i : Fin n, v i^p)^(1/p) := by\n    by_cases hS : (\u2211 i : Fin n, (u i + v i) ^ p) = 0\n    \u00b7 -- Case: S = 0\n      have h\u2081 : (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p : \u211d) = 0 := by\n        rw [hS]\n        have h\u2082 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n          have h\u2083 : (1 / p : \u211d) > 0 := by\n            have h\u2084 : (p : \u211d) > 1 := by exact_mod_cast h_p_gt_one\n            have h\u2085 : (1 : \u211d) / p > 0 := by\n              apply div_pos\n              \u00b7 norm_num\n              \u00b7 linarith\n            exact h\u2085\n          -- Since 1/p > 0, 0^(1/p) = 0\n          have h\u2086 : (0 : \u211d) ^ (1 / p : \u211d) = 0 := by\n            exact Real.zero_rpow (by linarith)\n          exact h\u2086\n        exact h\u2082\n      have h\u2082 : (\u2211 i : Fin n, u i ^ p) ^ (1 / p : \u211d) \u2265 0 := by\n        -- Since \u2211 u_i^p \u2265 0 and 1/p > 0, (\u2211 u_i^p)^(1/p) \u2265 0\n        have h\u2083 : 0 \u2264 \u2211 i : Fin n, u i ^ p := by\n          apply Finset.sum_nonneg\n          intro i _\n          have h\u2084 : 0 \u2264 u i := h_nonneg_u i\n          have h\u2085 : 0 \u2264 u i ^ p := by\n            exact Real.rpow_nonneg h\u2084 p\n          exact h\u2085\n        have h\u2084 : (1 / p : \u211d) > 0 := by\n          have h\u2085 : (p : \u211d) > 1 := by exact_mod_cast h_p_gt_one\n          have h\u2086 : (1 : \u211d) / p > 0 := by\n            apply div_pos\n            \u00b7 norm_num\n            \u00b7 linarith\n          exact h\u2086\n        exact Real.rpow_nonneg h\u2083 (1 / p)\n      have h\u2083 : (\u2211 i : Fin n, v i ^ p) ^ (1 / p : \u211d) \u2265 0 := by\n        -- Since \u2211 v_i^p \u2265 0 and 1/p > 0, (\u2211 v_i^p)^(1/p) \u2265 0\n        have h\u2084 : 0 \u2264 \u2211 i : Fin n, v i ^ p := by\n          apply Finset.sum_nonneg\n          intro i _\n          have h\u2085 : 0 \u2264 v i := h_nonneg_v i\n          have h\u2086 : 0 \u2264 v i ^ p := by\n            exact Real.rpow_nonneg h\u2085 p\n          exact h\u2086\n        have h\u2085 : (1 / p : \u211d) > 0 := by\n          have h\u2086 : (p : \u211d) > 1 := by exact_mod_cast h_p_gt_one\n          have h\u2087 : (1 : \u211d) / p > 0 := by\n            apply div_pos\n            \u00b7 norm_num\n            \u00b7 linarith\n          exact h\u2087\n        exact Real.rpow_nonneg h\u2084 (1 / p)\n      -- Combine the results to get the desired inequality\n      have h\u2084 : (\u2211 i : Fin n, (u i + v i) ^ p) ^ (1 / p : \u211d) \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p) ^ (1 / p : \u211d) := by\n        linarith\n      simpa [h\u2081] using h\u2084\n    \u00b7 -- Case: S > 0\n      have h\u2081 : 0 < \u2211 i : Fin n, (u i + v i) ^ p := by\n        by_contra h\n        have h\u2082 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 0 := by linarith\n        have h\u2083 : \u2211 i : Fin n, (u i + v i) ^ p \u2265 0 := h_sum_nonneg\n        have h\u2084 : \u2211 i : Fin n, (u i + v i) ^ p = 0 := by linarith\n        contradiction\n      have h\u2082 : 1 - 1 / q = 1 / p := h_l6\n      have h\u2083 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) > 0 := by exact_mod_cast h\u2081\n      have h\u2084 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n        have h\u2085 : 1 / p = 1 - 1 / q := by\n          linarith\n        have h\u2086 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) > 0 := by positivity\n        have h\u2087 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) := by\n          rw [h\u2085]\n          <;> simp [Real.rpow_sub] <;> field_simp <;> ring_nf\n        have h\u2088 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n          have h\u2089 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) > 0 := by positivity\n          have h\u2081\u2080 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n            rw [Real.rpow_sub (by positivity)]\n            <;> field_simp [Real.rpow_one]\n            <;> ring_nf\n          have h\u2081\u2081 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) := by\n            simp [Real.rpow_one]\n          rw [h\u2081\u2080, h\u2081\u2081]\n          <;> field_simp [h\u2089.ne']\n          <;> ring_nf\n        calc\n          (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 - 1 / q : \u211d) := by rw [h\u2087]\n          _ = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by rw [h\u2088]\n      have h\u2085 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) \u2264 ((\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n        have h\u2086 : \u2211 i : Fin n, (u i + v i) ^ p \u2264 (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n          simpa using h_l5\n        have h\u2087 : (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) = ((\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n          ring\n        linarith\n      have h\u2086 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) \u2264 (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) := by\n        have h\u2087 : 0 < (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n          apply Real.rpow_pos_of_pos\n          exact by positivity\n        have h\u2088 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) \u2264 ((\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := h\u2085\n        have h\u2089 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) \u2264 (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) := by\n          calc\n            (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by rfl\n            _ \u2264 ((\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d)) * (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by\n              gcongr <;> nlinarith\n            _ = (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) := by\n              field_simp [h\u2087.ne']\n              <;> ring_nf\n              <;> field_simp [h\u2087.ne']\n              <;> linarith\n        exact h\u2089\n      have h\u2087 : (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) \u2264 (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) := by\n        calc\n          (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / p : \u211d) = (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) / (\u2211 i : Fin n, (u i + v i) ^ p : \u211d) ^ (1 / q : \u211d) := by rw [h\u2084]\n          _ \u2264 (\u2211 i : Fin n, u i ^ p : \u211d) ^ (1 / p : \u211d) + (\u2211 i : Fin n, v i ^ p : \u211d) ^ (1 / p : \u211d) := by\n            exact h\u2086\n      simpa using h\u2087\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture sequences of nonnegative real numbers using Lean's function notation from Fin n to \u211d with explicit nonnegativity constraints.", "The inequality l5 is correctly formalized. The Lean version factors the expression differently but is mathematically equivalent to the natural language version.", "The relationship l6 (1 - 1/q = 1/p) is exactly preserved in the Lean formalization.", "The conclusion ts_1 is perfectly captured - the Minkowski inequality statement is identical in both versions.", "Additional constraints (p > 1 and q = p/(p-1)) are mathematically necessary for the context and don't contradict the natural language - they provide essential background for the Minkowski inequality proof."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    