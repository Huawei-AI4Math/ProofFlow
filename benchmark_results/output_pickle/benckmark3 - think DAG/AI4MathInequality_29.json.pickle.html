
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $a, b, c$, the following inequality holds:
$$ \sqrt{\\frac{a+b}{c}}+\\sqrt{\\frac{b+c}{a}}+\\sqrt{\\frac{c+a}{b}} \\geq 3\\sqrt{2} $$

Proof: Let $a,b,c>0$. We want to prove $\sqrt{	frac{a+b}{c}}+\sqrt{	frac{b+c}{a}}+\sqrt{	frac{c+a}{b}} \geq 3\sqrt{2}$. Consider the product $(a+b)(b+c)(c+a)$. Since for any $x,y>0$, $x+y \geq 2\sqrt{xy}$, we obtain $a+b \geq 2\sqrt{ab}$, $b+c \geq 2\sqrt{bc}$, and $c+a \geq 2\sqrt{ca}$. Multiplying these inequalities yields $(a+b)(b+c)(c+a) \geq 8abc$. Dividing by $abc>0$, we get $	frac{(a+b)(b+c)(c+a)}{abc} \geq 8$, which is exactly $	frac{a+b}{c}\cdot 	frac{b+c}{a}\cdot 	frac{c+a}{b} \geq 8$. Now let $X=\sqrt{	frac{a+b}{c}},\,Y=\sqrt{	frac{b+c}{a}},\,Z=\sqrt{	frac{c+a}{b}}$. By AMâ€“GM, $X+Y+Z \geq 3\sqrt[3]{XYZ}$. But $$XYZ=\sqrt{	frac{a+b}{c}\cdot 	frac{b+c}{a}\cdot 	frac{c+a}{b}} = \sqrt{	frac{(a+b)(b+c)(c+a)}{abc}}$$, so $X+Y+Z \geq 3\left(	frac{(a+b)(b+c)(c+a)}{abc}ight)^{1/6}$. Since $	frac{(a+b)(b+c)(c+a)}{abc}\geq 8$, it follows that $X+Y+Z \geq 3\cdot 8^{1/6}=3\sqrt{2}$. Therefore, $$ \sqrt{	frac{a+b}{c}}+\sqrt{	frac{b+c}{a}}+\sqrt{	frac{c+a}{b}} \geq 3\sqrt{2} $$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $a,b,c>0$.", "statement": "Premise:\n\u2022 a, b, and c are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition :\n  \u2200 (a b c : \u211d), 0 < a \u2192 0 < b \u2192 0 < c \u2192 \n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, and c are real numbers with the positivity conditions expressed as 0 < a, 0 < b, 0 < c", "The condition a > 0 is perfectly represented as 0 < a in Lean", "The condition b > 0 is perfectly represented as 0 < b in Lean", "The condition c > 0 is perfectly represented as 0 < c in Lean", "The natural language states there are no new derived facts from the premise alone, but the Lean formalization introduces a completely new mathematical inequality involving square roots that was not mentioned in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, and c are real numbers with the positivity conditions expressed as 0 < a, 0 < b, 0 < c', 'The condition a > 0 is perfectly represented as 0 < a in Lean', 'The condition b > 0 is perfectly represented as 0 < b in Lean', 'The condition c > 0 is perfectly represented as 0 < c in Lean', 'The natural language states there are no new derived facts from the premise alone, but the Lean formalization introduces a completely new mathematical inequality involving square roots that was not mentioned in the natural language statement']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since for any $x,y>0$, $x+y \\geq 2\\sqrt{xy}$", "statement": "We assume:\n\u2022 (General knowledge of the AM-GM inequality)\nTherefore, we conclude:\n\u2022 For any positive real numbers x and y, $x+y \\geq 2\\sqrt{xy}$ [l1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (x y : \u211d) (hx : 0 < x) (hy : 0 < y) : x + y \u2265 2 * Real.sqrt (x * y) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (x y : \u211d) (hx : 0 < x) (hy : 0 < y) : x + y \u2265 2 * Real.sqrt (x * y) := by\n  have h_main : (x + y) ^ 2 \u2265 4 * (x * y) := by\n    have h\u2081 : 0 \u2264 (x - y) ^ 2 := sq_nonneg (x - y)\n    nlinarith [sq_nonneg (x - y)]\n  \n  have h_final : x + y \u2265 2 * Real.sqrt (x * y) := by\n    have h\u2082 : 0 \u2264 x * y := mul_nonneg hx.le hy.le\n    have h\u2083 : 0 \u2264 Real.sqrt (x * y) := Real.sqrt_nonneg (x * y)\n    have h\u2084 : 0 \u2264 x + y := by linarith\n    have h\u2085 : (Real.sqrt (x * y)) ^ 2 = x * y := Real.sq_sqrt (by positivity)\n    nlinarith [sq_nonneg (x + y - 2 * Real.sqrt (x * y)),\n      sq_nonneg (x - y), Real.sq_sqrt (by positivity : (0 : \u211d) \u2264 x * y)]\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the AM-GM inequality as stated in natural language. The variables x and y are correctly declared as real numbers with positivity conditions (hx : 0 < x) and (hy : 0 < y). The inequality x + y \u2265 2 * Real.sqrt (x * y) is a direct and accurate translation of x + y \u2265 2\u221a(xy). All mathematical components, logical structure, and conditions are preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "we obtain $a+b \\geq 2\\sqrt{ab}$, $b+c \\geq 2\\sqrt{bc}$, and $c+a \\geq 2\\sqrt{ca}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1]\n\u2022 For any positive real numbers x and y, $x+y \\geq 2\\sqrt{xy}$ [l1]\nTherefore, we conclude:\n\u2022 The following inequalities hold: $a+b \\geq 2\\sqrt{ab}$, $b+c \\geq 2\\sqrt{bc}$, and $c+a \\geq 2\\sqrt{ca}$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (l1 : \u2200 (x y : \u211d), 0 < x \u2192 0 < y \u2192 x + y \u2265 2 * Real.sqrt (x * y)) :\n  (a + b \u2265 2 * Real.sqrt (a * b)) \u2227 \n  (b + c \u2265 2 * Real.sqrt (b * c)) \u2227 \n  (c + a \u2265 2 * Real.sqrt (c * a)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (l1 : \u2200 (x y : \u211d), 0 < x \u2192 0 < y \u2192 x + y \u2265 2 * Real.sqrt (x * y)) :\n  (a + b \u2265 2 * Real.sqrt (a * b)) \u2227 \n  (b + c \u2265 2 * Real.sqrt (b * c)) \u2227 \n  (c + a \u2265 2 * Real.sqrt (c * a)) := by\n  have h_ab : a + b \u2265 2 * Real.sqrt (a * b) := by\n    have h\u2081 : a + b \u2265 2 * Real.sqrt (a * b) := by\n      have h\u2082 : 0 < a := ha\n      have h\u2083 : 0 < b := hb\n      have h\u2084 : 0 < a * b := mul_pos h\u2082 h\u2083\n      -- Use the given inequality with x = a and y = b\n      have h\u2085 : a + b \u2265 2 * Real.sqrt (a * b) := l1 a b h\u2082 h\u2083\n      exact h\u2085\n    exact h\u2081\n  \n  have h_bc : b + c \u2265 2 * Real.sqrt (b * c) := by\n    have h\u2081 : b + c \u2265 2 * Real.sqrt (b * c) := by\n      have h\u2082 : 0 < b := hb\n      have h\u2083 : 0 < c := hc\n      have h\u2084 : 0 < b * c := mul_pos h\u2082 h\u2083\n      -- Use the given inequality with x = b and y = c\n      have h\u2085 : b + c \u2265 2 * Real.sqrt (b * c) := l1 b c h\u2082 h\u2083\n      exact h\u2085\n    exact h\u2081\n  \n  have h_ca : c + a \u2265 2 * Real.sqrt (c * a) := by\n    have h\u2081 : c + a \u2265 2 * Real.sqrt (c * a) := by\n      have h\u2082 : 0 < c := hc\n      have h\u2083 : 0 < a := ha\n      have h\u2084 : 0 < c * a := mul_pos h\u2082 h\u2083\n      -- Use the given inequality with x = c and y = a\n      have h\u2085 : c + a \u2265 2 * Real.sqrt (c * a) := l1 c a h\u2082 h\u2083\n      exact h\u2085\n    exact h\u2081\n  \n  exact \u27e8h_ab, h_bc, h_ca\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate type annotations and inequality conditions.", "The universal quantification and AM-GM inequality assumption is accurately captured with proper logical structure.", "All three conclusion inequalities are correctly represented with proper conjunction and mathematical notation.", "The logical flow from assumptions to conclusion is properly structured as a theorem with hypotheses leading to the goal.", "Mathematical notation is accurately translated to Lean syntax while preserving semantic meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Multiplying these inequalities yields $(a+b)(b+c)(c+a) \\geq 8abc$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1]\n\u2022 The following inequalities hold: $a+b \\geq 2\\sqrt{ab}$, $b+c \\geq 2\\sqrt{bc}$, and $c+a \\geq 2\\sqrt{ca}$ [l2]\nTherefore, we conclude:\n\u2022 $(a+b)(b+c)(c+a) \\geq 8abc$ [l3].", "dependencies": ["tc_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition :\n  \u2200 (a b c : \u211d), 0 < a \u2192 0 < b \u2192 0 < c \u2192 \n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition :\n  \u2200 (a b c : \u211d), 0 < a \u2192 0 < b \u2192 0 < c \u2192 \n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n  intro a b c ha hb hc\n  have h_main : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := by\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < b * c := mul_pos hb hc\n    have h\u2083 : 0 < c * a := mul_pos hc ha\n    have h\u2084 : 0 < a * b * c := by positivity\n    have h\u2085 : 0 < a * b * c * a := by positivity\n    have h\u2086 : 0 < a * b * c * b := by positivity\n    have h\u2087 : 0 < a * b * c * c := by positivity\n    nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),\n      sq_nonneg (a * b - b * c), sq_nonneg (b * c - c * a), sq_nonneg (c * a - a * b)]\n  \n  have h_ratio_product : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8 := by\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < b * c := mul_pos hb hc\n    have h\u2083 : 0 < c * a := mul_pos hc ha\n    have h\u2084 : 0 < a * b * c := by positivity\n    have h\u2085 : 0 < a * b * c * a := by positivity\n    have h\u2086 : 0 < a * b * c * b := by positivity\n    have h\u2087 : 0 < a * b * c * c := by positivity\n    calc\n      ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n        field_simp [ha.ne', hb.ne', hc.ne']\n        <;> ring_nf\n        <;> field_simp [ha.ne', hb.ne', hc.ne']\n        <;> ring_nf\n      _ \u2265 (8 * a * b * c) / (a * b * c) := by\n        gcongr\n        <;> nlinarith\n      _ = 8 := by\n        have h\u2088 : a \u2260 0 := by linarith\n        have h\u2089 : b \u2260 0 := by linarith\n        have h\u2081\u2080 : c \u2260 0 := by linarith\n        field_simp [h\u2088, h\u2089, h\u2081\u2080]\n        <;> ring_nf\n        <;> field_simp [h\u2088, h\u2089, h\u2081\u2080]\n        <;> linarith\n  \n  have h_sqrt_product : Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) \u2265 2 * Real.sqrt 2 := by\n    have h\u2081 : Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) \u2265 Real.sqrt 8 := by\n      apply Real.sqrt_le_sqrt\n      have h\u2082 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8 := h_ratio_product\n      linarith\n    have h\u2082 : Real.sqrt 8 = 2 * Real.sqrt 2 := by\n      have h\u2083 : Real.sqrt 8 = Real.sqrt (2 ^ 2 * 2) := by norm_num\n      rw [h\u2083]\n      have h\u2084 : Real.sqrt (2 ^ 2 * 2) = 2 * Real.sqrt 2 := by\n        rw [Real.sqrt_eq_iff_sq_eq (by positivity) (by positivity)]\n        nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)]\n      rw [h\u2084]\n    linarith\n  \n  have h_product_sqrt : Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) \u2265 2 * Real.sqrt 2 := by\n    have h\u2081 : 0 \u2264 Real.sqrt ((a + b) / c) := Real.sqrt_nonneg _\n    have h\u2082 : 0 \u2264 Real.sqrt ((b + c) / a) := Real.sqrt_nonneg _\n    have h\u2083 : 0 \u2264 Real.sqrt ((c + a) / b) := Real.sqrt_nonneg _\n    have h\u2084 : 0 \u2264 Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) := by positivity\n    have h\u2085 : 0 \u2264 Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) := by positivity\n    have h\u2086 : Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) = Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) := by\n      have h\u2087 : 0 \u2264 (a + b) / c := by positivity\n      have h\u2088 : 0 \u2264 (b + c) / a := by positivity\n      have h\u2089 : 0 \u2264 (c + a) / b := by positivity\n      have h\u2081\u2080 : 0 \u2264 ((a + b) / c) * ((b + c) / a) := by positivity\n      have h\u2081\u2081 : 0 \u2264 ((a + b) / c) * ((b + c) / a) * ((c + a) / b) := by positivity\n      have h\u2081\u2082 : Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) = Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) := by\n        rw [Real.sqrt_mul, Real.sqrt_mul] <;>\n          (try positivity) <;>\n          (try ring_nf) <;>\n          (try field_simp [ha.ne', hb.ne', hc.ne']) <;>\n          (try positivity)\n        <;>\n          nlinarith\n      rw [h\u2081\u2082]\n    rw [h\u2086] at h_sqrt_product\n    linarith\n  \n  have h_sum_cube : (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b))^3 \u2265 (3 * Real.sqrt 2)^3 := by\n    have h\u2081 : 0 \u2264 Real.sqrt ((a + b) / c) := Real.sqrt_nonneg _\n    have h\u2082 : 0 \u2264 Real.sqrt ((b + c) / a) := Real.sqrt_nonneg _\n    have h\u2083 : 0 \u2264 Real.sqrt ((c + a) / b) := Real.sqrt_nonneg _\n    have h\u2084 : 0 \u2264 Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) := by positivity\n    have h\u2085 : 0 \u2264 Real.sqrt ((a + b) / c) * Real.sqrt ((c + a) / b) := by positivity\n    have h\u2086 : 0 \u2264 Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) := by positivity\n    have h\u2087 : Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) \u2265 2 * Real.sqrt 2 := h_product_sqrt\n    have h\u2088 : (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b)) ^ 3 \u2265 27 * (Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b)) := by\n      nlinarith [sq_nonneg (Real.sqrt ((a + b) / c) - Real.sqrt ((b + c) / a)), sq_nonneg (Real.sqrt ((b + c) / a) - Real.sqrt ((c + a) / b)), sq_nonneg (Real.sqrt ((c + a) / b) - Real.sqrt ((a + b) / c)),\n        mul_nonneg h\u2081 h\u2082, mul_nonneg h\u2082 h\u2083, mul_nonneg h\u2083 h\u2081]\n    have h\u2089 : 27 * (Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b)) \u2265 27 * (2 * Real.sqrt 2) := by\n      nlinarith [h\u2087]\n    have h\u2081\u2080 : 27 * (2 * Real.sqrt 2) = (3 * Real.sqrt 2) ^ 3 := by\n      ring_nf\n      <;>\n      nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)]\n    have h\u2081\u2081 : (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b)) ^ 3 \u2265 (3 * Real.sqrt 2) ^ 3 := by\n      calc\n        (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b)) ^ 3 \u2265 27 * (Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b)) := h\u2088\n        _ \u2265 27 * (2 * Real.sqrt 2) := h\u2089\n        _ = (3 * Real.sqrt 2) ^ 3 := by rw [h\u2081\u2080]\n    exact h\u2081\u2081\n  \n  have h_final : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n    have h\u2081 : 0 \u2264 Real.sqrt ((a + b) / c) := Real.sqrt_nonneg _\n    have h\u2082 : 0 \u2264 Real.sqrt ((b + c) / a) := Real.sqrt_nonneg _\n    have h\u2083 : 0 \u2264 Real.sqrt ((c + a) / b) := Real.sqrt_nonneg _\n    have h\u2084 : 0 \u2264 Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) := by linarith\n    have h\u2085 : (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b)) ^ 3 \u2265 (3 * Real.sqrt 2) ^ 3 := h_sum_cube\n    have h\u2086 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n      by_contra h\n      have h\u2087 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) < 3 * Real.sqrt 2 := by linarith\n      have h\u2088 : (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b)) ^ 3 < (3 * Real.sqrt 2) ^ 3 := by\n        have h\u2089 : 0 \u2264 Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) := by linarith\n        have h\u2081\u2080 : 0 \u2264 3 * Real.sqrt 2 := by positivity\n        have h\u2081\u2081 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) < 3 * Real.sqrt 2 := h\u2087\n        have h\u2081\u2082 : (Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b)) ^ 3 < (3 * Real.sqrt 2) ^ 3 := by\n          gcongr <;>\n          (try norm_num) <;>\n          (try linarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)]) <;>\n          (try nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)])\n        exact h\u2081\u2082\n      linarith\n    exact h\u2086\n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization represents a completely different mathematical problem than the natural language description. The natural language describes AM-GM inequalities and their product yielding (a+b)(b+c)(c+a) \u2265 8abc, while the Lean code formalizes an entirely different inequality involving sums of square roots of ratios. The mathematical content, logical structure, and conclusions are unrelated beyond sharing three positive real variables."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization represents a completely different mathematical problem than the natural language description. The natural language describes AM-GM inequalities and their product yielding (a+b)(b+c)(c+a) \u2265 8abc, while the Lean code formalizes an entirely different inequality involving sums of square roots of ratios. The mathematical content, logical structure, and conclusions are unrelated beyond sharing three positive real variables.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Dividing by $abc>0$, we get $\tfrac{(a+b)(b+c)(c+a)}{abc} \\geq 8$, which is exactly $\tfrac{a+b}{c}\\cdot \tfrac{b+c}{a}\\cdot \tfrac{c+a}{b} \\geq 8$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1]\n\u2022 $(a+b)(b+c)(c+a) \\geq 8abc$ [l3]\nTherefore, we conclude:\n\u2022 $\tfrac{a+b}{c}\\cdot \tfrac{b+c}{a}\\cdot \tfrac{c+a}{b} \\geq 8$ [l4].", "dependencies": ["tc_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (l3 : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c) :\n  ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (l3 : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c) :\n  ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8 := by\n  have h_pos : 0 < a * b * c := by\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < a * b * c := mul_pos h\u2081 hc\n    exact h\u2082\n  \n  have h_main : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = (a + b) * (b + c) * (c + a) / (a * b * c) := by\n    have h\u2081 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n      field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring\n      <;> field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring\n    rw [h\u2081]\n    <;> field_simp [ha.ne', hb.ne', hc.ne']\n    <;> ring\n  \n  have h_final : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8 := by\n    rw [h_main]\n    have h\u2081 : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := by\n      -- Use the given inequality to prove the desired result\n      have h\u2082 : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := l3\n      have h\u2083 : 0 < a * b * c := h_pos\n      -- Divide both sides of the inequality by (a * b * c)\n      have h\u2084 : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := by\n        calc\n          (a + b) * (b + c) * (c + a) / (a * b * c) = (a + b) * (b + c) * (c + a) / (a * b * c) := by rfl\n          _ \u2265 (8 * a * b * c) / (a * b * c) := by\n            -- Use the fact that (a + b)(b + c)(c + a) \u2265 8abc\n            gcongr\n            <;> nlinarith\n          _ = 8 := by\n            -- Simplify the right-hand side\n            have h\u2085 : a \u2260 0 := by linarith\n            have h\u2086 : b \u2260 0 := by linarith\n            have h\u2087 : c \u2260 0 := by linarith\n            field_simp [h\u2085, h\u2086, h\u2087]\n            <;> ring_nf\n            <;> field_simp [h\u2085, h\u2086, h\u2087]\n            <;> nlinarith\n      exact h\u2084\n    exact h\u2081\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and positivity constraints are correctly formalized. The Lean code properly declares a, b, c as real numbers and includes the necessary positivity hypotheses.", "The premise inequality (a+b)(b+c)(c+a) \u2265 8abc is accurately translated to Lean syntax with correct operator precedence and structure.", "The conclusion inequality involving the product of fractions is correctly formalized using Lean's division and multiplication operators, maintaining the exact mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now let $X=\\sqrt{\tfrac{a+b}{c}},\\,Y=\\sqrt{\tfrac{b+c}{a}},\\,Z=\\sqrt{\tfrac{c+a}{b}}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1]\nDefinition:\n\u2022 Let X, Y, and Z be positive real numbers defined as $X=\\sqrt{\\frac{a+b}{c}}$, $Y=\\sqrt{\\frac{b+c}{a}}$, and $Z=\\sqrt{\\frac{c+a}{b}}$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\nvariable (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.45, "semantic_feedback": ["The Lean formalization correctly captures that a, b, and c are positive real numbers through the type declarations and positivity conditions ha, hb, hc.", "The Lean formalization correctly defines X = \u221a((a+b)/c), but does not explicitly establish that X is positive. While this can be derived from the positivity of a, b, c, the natural language explicitly states X is a positive real number.", "The Lean formalization correctly defines Y = \u221a((b+c)/a), but does not explicitly establish that Y is positive. While this can be derived from the positivity of a, b, c, the natural language explicitly states Y is a positive real number.", "The Lean formalization correctly defines Z = \u221a((c+a)/b), but does not explicitly establish that Z is positive. While this can be derived from the positivity of a, b, c, the natural language explicitly states Z is a positive real number."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.45, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, and c are positive real numbers through the type declarations and positivity conditions ha, hb, hc.', 'The Lean formalization correctly defines X = \u221a((a+b)/c), but does not explicitly establish that X is positive. While this can be derived from the positivity of a, b, c, the natural language explicitly states X is a positive real number.', 'The Lean formalization correctly defines Y = \u221a((b+c)/a), but does not explicitly establish that Y is positive. While this can be derived from the positivity of a, b, c, the natural language explicitly states Y is a positive real number.', 'The Lean formalization correctly defines Z = \u221a((c+a)/b), but does not explicitly establish that Z is positive. While this can be derived from the positivity of a, b, c, the natural language explicitly states Z is a positive real number.']"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "By AM\u2013GM, $X+Y+Z \\geq 3\\sqrt[3]{XYZ}$.", "statement": "We assume:\n\u2022 Let X, Y, and Z be positive real numbers defined as $X=\\sqrt{\\frac{a+b}{c}}$, $Y=\\sqrt{\\frac{b+c}{a}}$, and $Z=\\sqrt{\\frac{c+a}{b}}$ [def_1]\nTherefore, we conclude:\n\u2022 $X+Y+Z \\geq 3\\sqrt[3]{XYZ}$ [l5].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d) := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d) := by\n  have hX_pos : 0 < X := by\n    rw [hX]\n    apply Real.sqrt_pos_of_pos\n    have h\u2081 : 0 < (a + b) / c := by\n      apply div_pos\n      \u00b7 linarith\n      \u00b7 exact hc\n    exact h\u2081\n  \n  have hY_pos : 0 < Y := by\n    rw [hY]\n    apply Real.sqrt_pos_of_pos\n    have h\u2081 : 0 < (b + c) / a := by\n      apply div_pos\n      \u00b7 linarith\n      \u00b7 exact ha\n    exact h\u2081\n  \n  have hZ_pos : 0 < Z := by\n    rw [hZ]\n    apply Real.sqrt_pos_of_pos\n    have h\u2081 : 0 < (c + a) / b := by\n      apply div_pos\n      \u00b7 linarith\n      \u00b7 exact hb\n    exact h\u2081\n  \n  have hXYZ_pos : 0 < X * Y * Z := by\n    have h\u2081 : 0 < X := hX_pos\n    have h\u2082 : 0 < Y := hY_pos\n    have h\u2083 : 0 < Z := hZ_pos\n    positivity\n  \n  have hAMGM : X * Y * Z \u2264 ((X + Y + Z) / 3) ^ 3 := by\n    have h\u2081 : 0 \u2264 X := by linarith\n    have h\u2082 : 0 \u2264 Y := by linarith\n    have h\u2083 : 0 \u2264 Z := by linarith\n    -- Use the AM-GM inequality for three variables\n    have h\u2084 : X * Y * Z \u2264 ((X + Y + Z) / 3) ^ 3 := by\n      nlinarith [sq_nonneg (X - Y), sq_nonneg (Y - Z), sq_nonneg (Z - X),\n        sq_nonneg (X + Y + Z), sq_nonneg (X + Y - Z), sq_nonneg (X + Z - Y),\n        sq_nonneg (Y + Z - X)]\n    exact h\u2084\n  \n  have h_sum_nonneg : 0 \u2264 (X + Y + Z) / 3 := by\n    have h\u2081 : 0 < X := hX_pos\n    have h\u2082 : 0 < Y := hY_pos\n    have h\u2083 : 0 < Z := hZ_pos\n    have h\u2084 : 0 < X + Y + Z := by linarith\n    linarith\n  \n  have h_rpow_nonneg : 0 \u2264 (X * Y * Z) ^ (1 / 3 : \u211d) := by\n    have h\u2081 : 0 \u2264 X * Y * Z := by\n      have h\u2082 : 0 < X * Y * Z := hXYZ_pos\n      linarith\n    -- Use the property that the real power of a non-negative number is non-negative\n    have h\u2082 : 0 \u2264 (X * Y * Z : \u211d) := by positivity\n    have h\u2083 : 0 \u2264 (1 / 3 : \u211d) := by norm_num\n    -- Use the fact that the real power function preserves non-negativity\n    exact Real.rpow_nonneg h\u2082 (1 / 3 : \u211d)\n  \n  have h_main_ineq : (X + Y + Z) / 3 \u2265 (X * Y * Z) ^ (1 / 3 : \u211d) := by\n    by_contra h\n    -- Assume the contrary: (X + Y + Z)/3 < (X * Y * Z)^(1/3)\n    have h\u2081 : (X + Y + Z) / 3 < (X * Y * Z) ^ (1 / 3 : \u211d) := by linarith\n    -- Cube both sides to eliminate the cube root\n    have h\u2082 : ((X + Y + Z) / 3) ^ 3 < ((X * Y * Z) ^ (1 / 3 : \u211d)) ^ 3 := by\n      -- Use the fact that the cube function is strictly increasing on [0, \u221e)\n      have h\u2083 : 0 \u2264 (X + Y + Z) / 3 := h_sum_nonneg\n      have h\u2084 : 0 \u2264 (X * Y * Z) ^ (1 / 3 : \u211d) := h_rpow_nonneg\n      have h\u2085 : (X + Y + Z) / 3 < (X * Y * Z) ^ (1 / 3 : \u211d) := h\u2081\n      -- Use the property of real powers to cube both sides\n      have h\u2086 : 0 \u2264 (X + Y + Z) / 3 := h_sum_nonneg\n      have h\u2087 : 0 \u2264 (X * Y * Z) ^ (1 / 3 : \u211d) := h_rpow_nonneg\n      -- Use the fact that the cube function is strictly increasing on [0, \u221e)\n      have h\u2088 : ((X + Y + Z) / 3) ^ 3 < ((X * Y * Z) ^ (1 / 3 : \u211d)) ^ 3 := by\n        -- Use the fact that the cube function is strictly increasing on [0, \u221e)\n        have h\u2089 : 0 \u2264 (X + Y + Z) / 3 := h_sum_nonneg\n        have h\u2081\u2080 : 0 \u2264 (X * Y * Z) ^ (1 / 3 : \u211d) := h_rpow_nonneg\n        -- Use the fact that the cube function is strictly increasing on [0, \u221e)\n        have h\u2081\u2081 : (X + Y + Z) / 3 < (X * Y * Z) ^ (1 / 3 : \u211d) := h\u2081\n        -- Use the fact that the cube function is strictly increasing on [0, \u221e)\n        calc\n          ((X + Y + Z) / 3) ^ 3 < ((X * Y * Z) ^ (1 / 3 : \u211d)) ^ 3 := by\n            gcongr\n          _ = ((X * Y * Z) ^ (1 / 3 : \u211d)) ^ 3 := by rfl\n      exact h\u2088\n    -- Simplify the right-hand side\n    have h\u2083 : ((X * Y * Z) ^ (1 / 3 : \u211d)) ^ 3 = X * Y * Z := by\n      have h\u2084 : 0 < X * Y * Z := hXYZ_pos\n      have h\u2085 : 0 < (X * Y * Z : \u211d) := by positivity\n      -- Use the property of real powers\n      have h\u2086 : ((X * Y * Z : \u211d) ^ (1 / 3 : \u211d)) ^ 3 = X * Y * Z := by\n        rw [\u2190 Real.rpow_nat_cast]\n        rw [\u2190 Real.rpow_mul] <;>\n          (try norm_num) <;>\n          (try linarith) <;>\n          (try positivity)\n        <;>\n          norm_num\n      -- Simplify the expression\n      simpa using h\u2086\n    -- Substitute back into the inequality\n    have h\u2084 : ((X + Y + Z) / 3) ^ 3 < X * Y * Z := by\n      linarith\n    -- Contradiction with the AM-GM inequality\n    have h\u2085 : X * Y * Z \u2264 ((X + Y + Z) / 3) ^ 3 := hAMGM\n    linarith\n  \n  have h_final : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := by\n    have h\u2081 : (X + Y + Z) / 3 \u2265 (X * Y * Z) ^ (1 / 3 : \u211d) := h_main_ineq\n    have h\u2082 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := by\n      calc\n        X + Y + Z = 3 * ((X + Y + Z) / 3) := by ring\n        _ \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := by\n          -- Multiply both sides of the inequality by 3\n          have h\u2083 : (X + Y + Z) / 3 \u2265 (X * Y * Z) ^ (1 / 3 : \u211d) := h\u2081\n          nlinarith\n    exact h\u2082\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The positivity constraints are handled appropriately - while X, Y, Z are not explicitly declared positive, their positivity follows from the positivity of a, b, c and the square root definitions", "The variable definitions are mathematically identical between natural language and Lean formalization", "The inequality statement perfectly captures the AM-GM inequality as stated in natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "But $$XYZ=\\sqrt{\tfrac{a+b}{c}\\cdot \tfrac{b+c}{a}\\cdot \tfrac{c+a}{b}} = \\sqrt{\tfrac{(a+b)(b+c)(c+a)}{abc}}$$,", "statement": "We assume:\n\u2022 Let X, Y, and Z be positive real numbers defined as $X=\\sqrt{\\frac{a+b}{c}}$, $Y=\\sqrt{\\frac{b+c}{a}}$, and $Z=\\sqrt{\\frac{c+a}{b}}$ [def_1]\nTherefore, we conclude:\n\u2022 $XYZ = \\sqrt{\\frac{(a+b)(b+c)(c+a)}{abc}}$ [l6].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X * Y * Z = Real.sqrt (((a + b) * (b + c) * (c + a)) / (a * b * c)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X * Y * Z = Real.sqrt (((a + b) * (b + c) * (c + a)) / (a * b * c)) := by\n  have h_pos_abc : 0 < a * b * c := by\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < a * b * c := mul_pos h\u2081 hc\n    exact h\u2082\n  \n  have h_pos_ab : 0 < a + b := by\n    linarith\n  \n  have h_pos_bc : 0 < b + c := by\n    linarith\n  \n  have h_pos_ca : 0 < c + a := by\n    linarith\n  \n  have h_pos_div_1 : 0 \u2264 (a + b) / c := by\n    have h\u2081 : 0 < c := hc\n    have h\u2082 : 0 < a + b := by linarith\n    positivity\n  \n  have h_pos_div_2 : 0 \u2264 (b + c) / a := by\n    have h\u2081 : 0 < a := ha\n    have h\u2082 : 0 < b + c := by linarith\n    positivity\n  \n  have h_pos_div_3 : 0 \u2264 (c + a) / b := by\n    have h\u2081 : 0 < b := hb\n    have h\u2082 : 0 < c + a := by linarith\n    positivity\n  \n  have h_product_sqrt : X * Y * Z = Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) := by\n    have h\u2081 : X = Real.sqrt ((a + b) / c) := hX\n    have h\u2082 : Y = Real.sqrt ((b + c) / a) := hY\n    have h\u2083 : Z = Real.sqrt ((c + a) / b) := hZ\n    rw [h\u2081, h\u2082, h\u2083]\n    have h\u2084 : 0 \u2264 (a + b) / c := h_pos_div_1\n    have h\u2085 : 0 \u2264 (b + c) / a := h_pos_div_2\n    have h\u2086 : 0 \u2264 (c + a) / b := h_pos_div_3\n    have h\u2087 : Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) = Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) := by\n      have h\u2088 : 0 \u2264 (a + b) / c := h_pos_div_1\n      have h\u2089 : 0 \u2264 (b + c) / a := h_pos_div_2\n      have h\u2081\u2080 : 0 \u2264 (c + a) / b := h_pos_div_3\n      have h\u2081\u2081 : 0 \u2264 ((a + b) / c) * ((b + c) / a) := by positivity\n      have h\u2081\u2082 : 0 \u2264 ((a + b) / c) * ((b + c) / a) * ((c + a) / b) := by positivity\n      -- Use the property of square roots to combine them\n      have h\u2081\u2083 : Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) = Real.sqrt (((a + b) / c) * ((b + c) / a)) := by\n        rw [\u2190 Real.sqrt_mul] <;> positivity\n      calc\n        Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) = (Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a)) * Real.sqrt ((c + a) / b) := by ring\n        _ = Real.sqrt (((a + b) / c) * ((b + c) / a)) * Real.sqrt ((c + a) / b) := by rw [h\u2081\u2083]\n        _ = Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) := by\n          have h\u2081\u2084 : 0 \u2264 ((a + b) / c) * ((b + c) / a) := by positivity\n          have h\u2081\u2085 : 0 \u2264 (c + a) / b := h_pos_div_3\n          have h\u2081\u2086 : 0 \u2264 ((a + b) / c) * ((b + c) / a) * ((c + a) / b) := by positivity\n          rw [\u2190 Real.sqrt_mul] <;> positivity\n    rw [h\u2087]\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try field_simp) <;>\n    (try linarith)\n  \n  have h_simplify_product : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n    have h\u2081 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n      field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring_nf\n      <;> field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring_nf\n    rw [h\u2081]\n  \n  have h_final : X * Y * Z = Real.sqrt (((a + b) * (b + c) * (c + a)) / (a * b * c)) := by\n    rw [h_product_sqrt]\n    have h\u2081 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := h_simplify_product\n    rw [h\u2081]\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try field_simp) <;>\n    (try linarith)\n  \n  rw [h_final]\n  <;>\n  (try norm_num) <;>\n  (try ring_nf) <;>\n  (try field_simp) <;>\n  (try linarith)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are correct. The explicit positivity constraints on a, b, c are mathematically necessary and consistent with the context.", "Definition of X matches exactly with the natural language mathematical expression.", "Definition of Y matches exactly with the natural language mathematical expression.", "Definition of Z matches exactly with the natural language mathematical expression.", "The conclusion statement perfectly captures the mathematical relationship stated in natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "so $X+Y+Z \\geq 3\\left(\tfrac{(a+b)(b+c)(c+a)}{abc}ight)^{1/6}$.", "statement": "We assume:\n\u2022 $X+Y+Z \\geq 3\\sqrt[3]{XYZ}$ [l5]\n\u2022 $XYZ = \\sqrt{\\frac{(a+b)(b+c)(c+a)}{abc}}$ [l6]\nTherefore, we conclude:\n\u2022 $X+Y+Z \\geq 3\\left(\\frac{(a+b)(b+c)(c+a)}{abc}\\right)^{1/6}$ [l7].", "dependencies": ["l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l5 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d))\n  (l6 : X * Y * Z = Real.sqrt (((a + b) * (b + c) * (c + a)) / (a * b * c))) :\n  X + Y + Z \u2265 3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l5 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d))\n  (l6 : X * Y * Z = Real.sqrt (((a + b) * (b + c) * (c + a)) / (a * b * c))) :\n  X + Y + Z \u2265 3 * Real.sqrt 2 := by\n  have h_xyz_sq : (X * Y * Z) ^ 2 = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n    have hX2 : X ^ 2 = (a + b) / c := by\n      rw [hX]\n      have h\u2081 : 0 < (a + b) / c := by positivity\n      rw [Real.sq_sqrt (by positivity)]\n      <;> field_simp\n      <;> ring\n    have hY2 : Y ^ 2 = (b + c) / a := by\n      rw [hY]\n      have h\u2081 : 0 < (b + c) / a := by positivity\n      rw [Real.sq_sqrt (by positivity)]\n      <;> field_simp\n      <;> ring\n    have hZ2 : Z ^ 2 = (c + a) / b := by\n      rw [hZ]\n      have h\u2081 : 0 < (c + a) / b := by positivity\n      rw [Real.sq_sqrt (by positivity)]\n      <;> field_simp\n      <;> ring\n    calc\n      (X * Y * Z) ^ 2 = (X ^ 2) * (Y ^ 2) * (Z ^ 2) := by\n        ring_nf\n        <;> field_simp [pow_two]\n        <;> ring_nf\n      _ = ((a + b) / c) * ((b + c) / a) * ((c + a) / b) := by\n        rw [hX2, hY2, hZ2]\n      _ = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n        field_simp [ha.ne', hb.ne', hc.ne']\n        <;> ring_nf\n        <;> field_simp [ha.ne', hb.ne', hc.ne']\n        <;> ring_nf\n  \n  have h_ineq_abc : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := by\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < b * c := mul_pos hb hc\n    have h\u2083 : 0 < c * a := mul_pos hc ha\n    have h\u2084 : 0 < a * b * c := by positivity\n    have h\u2085 : 0 < a * b * c * a := by positivity\n    have h\u2086 : 0 < a * b * c * b := by positivity\n    have h\u2087 : 0 < a * b * c * c := by positivity\n    nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),\n      sq_nonneg (a * b - b * c), sq_nonneg (b * c - c * a), sq_nonneg (c * a - a * b)]\n  \n  have h_xyz_sq_ge_8 : (X * Y * Z) ^ 2 \u2265 8 := by\n    have h\u2081 : (X * Y * Z) ^ 2 = ((a + b) * (b + c) * (c + a)) / (a * b * c) := h_xyz_sq\n    have h\u2082 : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := h_ineq_abc\n    have h\u2083 : 0 < a * b * c := by positivity\n    have h\u2084 : 0 < a := ha\n    have h\u2085 : 0 < b := hb\n    have h\u2086 : 0 < c := hc\n    have h\u2087 : 0 < a * b := by positivity\n    have h\u2088 : 0 < b * c := by positivity\n    have h\u2089 : 0 < c * a := by positivity\n    have h\u2081\u2080 : ((a + b) * (b + c) * (c + a)) / (a * b * c) \u2265 8 := by\n      rw [ge_iff_le]\n      rw [le_div_iff (by positivity)]\n      nlinarith [h\u2082]\n    calc\n      (X * Y * Z) ^ 2 = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by rw [h\u2081]\n      _ \u2265 8 := by linarith\n  \n  have h_xyz_ge_2sqrt2 : X * Y * Z \u2265 2 * Real.sqrt 2 := by\n    have h\u2081 : 0 \u2264 X * Y * Z := by\n      have h\u2082 : 0 \u2264 X := by\n        rw [hX]\n        apply Real.sqrt_nonneg\n      have h\u2083 : 0 \u2264 Y := by\n        rw [hY]\n        apply Real.sqrt_nonneg\n      have h\u2084 : 0 \u2264 Z := by\n        rw [hZ]\n        apply Real.sqrt_nonneg\n      positivity\n    have h\u2082 : (X * Y * Z) ^ 2 \u2265 8 := h_xyz_sq_ge_8\n    have h\u2083 : X * Y * Z \u2265 2 * Real.sqrt 2 := by\n      by_contra h\n      have h\u2084 : X * Y * Z < 2 * Real.sqrt 2 := by linarith\n      have h\u2085 : (X * Y * Z) ^ 2 < (2 * Real.sqrt 2) ^ 2 := by\n        have h\u2086 : 0 \u2264 X * Y * Z := h\u2081\n        have h\u2087 : 0 \u2264 2 * Real.sqrt 2 := by positivity\n        nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)]\n      have h\u2086 : (2 * Real.sqrt 2) ^ 2 = 8 := by\n        nlinarith [Real.sq_sqrt (show 0 \u2264 2 by norm_num)]\n      nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)]\n    exact h\u2083\n  \n  have h_xyz_cbrt_ge_sqrt2 : (X * Y * Z) ^ (1/3 : \u211d) \u2265 Real.sqrt 2 := by\n    have h\u2081 : X * Y * Z \u2265 2 * Real.sqrt 2 := h_xyz_ge_2sqrt2\n    have h\u2082 : 0 < X * Y * Z := by\n      have h\u2083 : 0 < X := by\n        rw [hX]\n        apply Real.sqrt_pos_of_pos\n        positivity\n      have h\u2084 : 0 < Y := by\n        rw [hY]\n        apply Real.sqrt_pos_of_pos\n        positivity\n      have h\u2085 : 0 < Z := by\n        rw [hZ]\n        apply Real.sqrt_pos_of_pos\n        positivity\n      positivity\n    have h\u2083 : (X * Y * Z : \u211d) \u2265 2 * Real.sqrt 2 := by exact_mod_cast h\u2081\n    have h\u2084 : (X * Y * Z : \u211d) > 0 := by positivity\n    -- Use the fact that the cube root function is increasing to show that (X * Y * Z)^(1/3) \u2265 sqrt(2)\n    have h\u2085 : (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) \u2265 Real.sqrt 2 := by\n      -- Use the property of real power functions to compare the cube roots\n      have h\u2085\u2081 : Real.log ((X * Y * Z : \u211d) ^ (1 / 3 : \u211d)) = (1 / 3 : \u211d) * Real.log (X * Y * Z) := by\n        rw [Real.log_rpow (by positivity)]\n      have h\u2085\u2082 : Real.log (Real.sqrt 2) = (1 / 2 : \u211d) * Real.log 2 := by\n        rw [Real.log_sqrt (by positivity)]\n        <;> ring_nf\n        <;> field_simp\n        <;> ring_nf\n      have h\u2085\u2083 : Real.log (X * Y * Z) \u2265 Real.log (2 * Real.sqrt 2) := by\n        apply Real.log_le_log\n        \u00b7 positivity\n        \u00b7 linarith\n      have h\u2085\u2084 : Real.log (2 * Real.sqrt 2) = Real.log 2 + Real.log (Real.sqrt 2) := by\n        have h\u2085\u2084\u2081 : Real.log (2 * Real.sqrt 2) = Real.log 2 + Real.log (Real.sqrt 2) := by\n          rw [Real.log_mul (by positivity) (by positivity)]\n        rw [h\u2085\u2084\u2081]\n      have h\u2085\u2085 : Real.log (Real.sqrt 2) = (1 / 2 : \u211d) * Real.log 2 := by\n        rw [Real.log_sqrt (by positivity)]\n        <;> ring_nf\n        <;> field_simp\n        <;> ring_nf\n      have h\u2085\u2086 : Real.log (2 * Real.sqrt 2) = Real.log 2 + (1 / 2 : \u211d) * Real.log 2 := by\n        rw [h\u2085\u2084, h\u2085\u2085]\n        <;> ring_nf\n      have h\u2085\u2087 : Real.log (2 * Real.sqrt 2) = (3 / 2 : \u211d) * Real.log 2 := by\n        rw [h\u2085\u2086]\n        <;> ring_nf\n        <;> field_simp\n        <;> ring_nf\n      have h\u2085\u2088 : Real.log (X * Y * Z) \u2265 (3 / 2 : \u211d) * Real.log 2 := by\n        linarith\n      have h\u2085\u2089 : (1 / 3 : \u211d) * Real.log (X * Y * Z) \u2265 (1 / 3 : \u211d) * ((3 / 2 : \u211d) * Real.log 2) := by\n        nlinarith\n      have h\u2086\u2080 : (1 / 3 : \u211d) * ((3 / 2 : \u211d) * Real.log 2) = (1 / 2 : \u211d) * Real.log 2 := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n      have h\u2086\u2081 : (1 / 3 : \u211d) * Real.log (X * Y * Z) \u2265 (1 / 2 : \u211d) * Real.log 2 := by\n        linarith\n      have h\u2086\u2082 : Real.log ((X * Y * Z : \u211d) ^ (1 / 3 : \u211d)) \u2265 Real.log (Real.sqrt 2) := by\n        calc\n          Real.log ((X * Y * Z : \u211d) ^ (1 / 3 : \u211d)) = (1 / 3 : \u211d) * Real.log (X * Y * Z) := by\n            rw [h\u2085\u2081]\n          _ \u2265 (1 / 2 : \u211d) * Real.log 2 := by linarith\n          _ = Real.log (Real.sqrt 2) := by\n            have h\u2086\u2083 : Real.log (Real.sqrt 2) = (1 / 2 : \u211d) * Real.log 2 := by\n              rw [Real.log_sqrt (by positivity)]\n              <;> ring_nf\n              <;> field_simp\n              <;> ring_nf\n            linarith\n      -- Use the fact that the logarithm function is increasing to conclude the proof\n      have h\u2086\u2083 : (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) \u2265 Real.sqrt 2 := by\n        by_contra h\n        have h\u2086\u2084 : (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) < Real.sqrt 2 := by linarith\n        have h\u2086\u2085 : Real.log ((X * Y * Z : \u211d) ^ (1 / 3 : \u211d)) < Real.log (Real.sqrt 2) := by\n          apply Real.log_lt_log (by positivity)\n          <;> nlinarith [Real.sqrt_nonneg 2, Real.sq_sqrt (show 0 \u2264 2 by norm_num)]\n        linarith\n      exact h\u2086\u2083\n    exact_mod_cast h\u2085\n  \n  have h_main : X + Y + Z \u2265 3 * Real.sqrt 2 := by\n    have h\u2081 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := l5\n    have h\u2082 : (X * Y * Z) ^ (1 / 3 : \u211d) \u2265 Real.sqrt 2 := h_xyz_cbrt_ge_sqrt2\n    calc\n      X + Y + Z \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := h\u2081\n      _ \u2265 3 * Real.sqrt 2 := by\n        -- Use the fact that (X * Y * Z) ^ (1 / 3 : \u211d) \u2265 Real.sqrt 2 to conclude the proof\n        have h\u2083 : 0 \u2264 (X * Y * Z) ^ (1 / 3 : \u211d) := by\n          -- Prove that (X * Y * Z) ^ (1 / 3 : \u211d) is non-negative\n          have h\u2084 : 0 \u2264 X * Y * Z := by\n            -- Prove that X * Y * Z is non-negative\n            have h\u2085 : 0 \u2264 X := by\n              -- Prove that X is non-negative\n              rw [hX]\n              apply Real.sqrt_nonneg\n            have h\u2086 : 0 \u2264 Y := by\n              -- Prove that Y is non-negative\n              rw [hY]\n              apply Real.sqrt_nonneg\n            have h\u2087 : 0 \u2264 Z := by\n              -- Prove that Z is non-negative\n              rw [hZ]\n              apply Real.sqrt_nonneg\n            positivity\n          -- Use the fact that X * Y * Z is non-negative to prove that (X * Y * Z) ^ (1 / 3 : \u211d) is non-negative\n          have h\u2088 : 0 \u2264 (X * Y * Z : \u211d) := by positivity\n          have h\u2089 : 0 \u2264 (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) := by positivity\n          positivity\n        -- Use linear arithmetic to conclude the proof\n        nlinarith [h\u2082]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations and constraints are appropriately formalized with positive real constraints and specific definitions for X, Y, Z", "Assumption l5 correctly captures X+Y+Z \u2265 3\u221b(XYZ) as X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3)", "Assumption l6 correctly captures XYZ = \u221a((a+b)(b+c)(c+a)/(abc)) in Lean syntax", "The conclusion is fundamentally wrong. The natural language states X+Y+Z \u2265 3((a+b)(b+c)(c+a)/(abc))^(1/6), but the Lean formalization concludes X+Y+Z \u2265 3\u221a2. These are completely different mathematical expressions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations and constraints are appropriately formalized with positive real constraints and specific definitions for X, Y, Z', 'Assumption l5 correctly captures X+Y+Z \u2265 3\u221b(XYZ) as X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3)', 'Assumption l6 correctly captures XYZ = \u221a((a+b)(b+c)(c+a)/(abc)) in Lean syntax', 'The conclusion is fundamentally wrong. The natural language states X+Y+Z \u2265 3((a+b)(b+c)(c+a)/(abc))^(1/6), but the Lean formalization concludes X+Y+Z \u2265 3\u221a2. These are completely different mathematical expressions.']"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Since $\tfrac{(a+b)(b+c)(c+a)}{abc}\\geq 8$, it follows that $X+Y+Z \\geq 3\\cdot 8^{1/6}=3\\sqrt{2}$.", "statement": "We assume:\n\u2022 $\tfrac{a+b}{c}\\cdot \tfrac{b+c}{a}\\cdot \tfrac{c+a}{b} \\geq 8$ [l4]\n\u2022 $X+Y+Z \\geq 3\\left(\\frac{(a+b)(b+c)(c+a)}{abc}\\right)^{1/6}$ [l7]\nTherefore, we conclude:\n\u2022 $X+Y+Z \\geq 3\\sqrt{2}$ [l8].", "dependencies": ["l4", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l4 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8)\n  (l7 : X + Y + Z \u2265 3 * (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1/6 : \u211d)) :\n  X + Y + Z \u2265 3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l4 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) \u2265 8)\n  (l7 : X + Y + Z \u2265 3 * (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1/6 : \u211d)) :\n  X + Y + Z \u2265 3 * Real.sqrt 2 := by\n  have h1 : (Real.sqrt 2 : \u211d) ^ 6 = 8 := by\n    have h1\u2081 : (Real.sqrt 2 : \u211d) ^ 2 = 2 := by\n      rw [Real.sq_sqrt (by positivity)]\n    calc\n      (Real.sqrt 2 : \u211d) ^ 6 = ((Real.sqrt 2 : \u211d) ^ 2) ^ 3 := by ring\n      _ = 2 ^ 3 := by rw [h1\u2081]\n      _ = 8 := by norm_num\n  \n  have h2 : (8 : \u211d) ^ (1 / 6 : \u211d) = Real.sqrt 2 := by\n    have h\u2082\u2081 : Real.sqrt 2 > 0 := Real.sqrt_pos.mpr (by norm_num)\n    have h\u2082\u2082 : (8 : \u211d) > 0 := by norm_num\n    have h\u2082\u2083 : (Real.sqrt 2 : \u211d) ^ 6 = 8 := h1\n    have h\u2082\u2084 : (8 : \u211d) ^ (1 / 6 : \u211d) = Real.sqrt 2 := by\n      -- Use the property of exponents to show that 8^(1/6) = sqrt(2)\n      have h\u2082\u2084\u2081 : Real.log ((8 : \u211d) ^ (1 / 6 : \u211d)) = Real.log (Real.sqrt 2) := by\n        -- Calculate the logarithm of both sides\n        have h\u2082\u2084\u2082 : Real.log ((8 : \u211d) ^ (1 / 6 : \u211d)) = (1 / 6 : \u211d) * Real.log 8 := by\n          rw [Real.log_rpow (by norm_num : (8 : \u211d) > 0)]\n        have h\u2082\u2084\u2083 : Real.log (Real.sqrt 2) = (Real.log 2) / 2 := by\n          rw [Real.log_sqrt (by positivity)]\n          <;> ring\n        have h\u2082\u2084\u2084 : Real.log 8 = 3 * Real.log 2 := by\n          have h\u2082\u2084\u2085 : Real.log 8 = Real.log (2 ^ 3) := by norm_num\n          rw [h\u2082\u2084\u2085]\n          have h\u2082\u2084\u2086 : Real.log (2 ^ 3) = 3 * Real.log 2 := by\n            rw [Real.log_pow] <;> norm_num\n          rw [h\u2082\u2084\u2086]\n        rw [h\u2082\u2084\u2082]\n        have h\u2082\u2084\u2087 : (1 / 6 : \u211d) * Real.log 8 = (1 / 6 : \u211d) * (3 * Real.log 2) := by rw [h\u2082\u2084\u2084]\n        rw [h\u2082\u2084\u2087]\n        have h\u2082\u2084\u2088 : (1 / 6 : \u211d) * (3 * Real.log 2) = (1 / 2 : \u211d) * Real.log 2 := by ring\n        rw [h\u2082\u2084\u2088]\n        have h\u2082\u2084\u2089 : (1 / 2 : \u211d) * Real.log 2 = (Real.log 2) / 2 := by ring\n        rw [h\u2082\u2084\u2089]\n        <;> linarith\n      -- Use the injectivity of the logarithm to conclude the proof\n      have h\u2082\u2085 : (8 : \u211d) ^ (1 / 6 : \u211d) > 0 := by positivity\n      have h\u2082\u2086 : Real.sqrt 2 > 0 := Real.sqrt_pos.mpr (by norm_num)\n      have h\u2082\u2087 : Real.log ((8 : \u211d) ^ (1 / 6 : \u211d)) = Real.log (Real.sqrt 2) := h\u2082\u2084\u2081\n      have h\u2082\u2088 : (8 : \u211d) ^ (1 / 6 : \u211d) = Real.sqrt 2 := by\n        apply Real.log_injOn_pos (Set.mem_Ioi.mpr h\u2082\u2085) (Set.mem_Ioi.mpr h\u2082\u2086)\n        linarith\n      exact h\u2082\u2088\n    exact h\u2082\u2084\n  \n  have h3 : \u2200 (t : \u211d), t \u2265 8 \u2192 t ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := by\n    intro t ht\n    have h3\u2081 : t \u2265 8 := ht\n    have h3\u2082 : (t : \u211d) \u2265 8 := by exact_mod_cast h3\u2081\n    have h3\u2083 : (t : \u211d) > 0 := by linarith\n    have h3\u2084 : (t : \u211d) ^ (1 / 6 : \u211d) \u2265 (8 : \u211d) ^ (1 / 6 : \u211d) := by\n      -- Use the fact that the function `x \u21a6 x^(1/6)` is increasing for `x > 0`\n      have h3\u2085 : (t : \u211d) \u2265 8 := by exact_mod_cast h3\u2081\n      have h3\u2086 : (t : \u211d) > 0 := by linarith\n      have h3\u2087 : (8 : \u211d) > 0 := by norm_num\n      -- Use the property of real power functions\n      have h3\u2088 : (t : \u211d) ^ (1 / 6 : \u211d) \u2265 (8 : \u211d) ^ (1 / 6 : \u211d) := by\n        -- Apply the monotonicity of the function `x \u21a6 x^(1/6)`\n        exact Real.rpow_le_rpow (by linarith) (by linarith) (by norm_num)\n      exact h3\u2088\n    have h3\u2089 : (8 : \u211d) ^ (1 / 6 : \u211d) = Real.sqrt 2 := h2\n    have h3\u2081\u2080 : (t : \u211d) ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := by\n      calc\n        (t : \u211d) ^ (1 / 6 : \u211d) \u2265 (8 : \u211d) ^ (1 / 6 : \u211d) := h3\u2084\n        _ = Real.sqrt 2 := by rw [h3\u2089]\n    exact_mod_cast h3\u2081\u2080\n  \n  have h4 : ((a + b) * (b + c) * (c + a)) / (a * b * c) \u2265 8 := by\n    have h4\u2081 : 0 < a * b * c := by positivity\n    have h4\u2082 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n      field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring\n      <;> field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring\n    have h4\u2083 : ((a + b) * (b + c) * (c + a)) / (a * b * c) \u2265 8 := by\n      linarith\n    exact h4\u2083\n  \n  have h5 : (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := by\n    have h5\u2081 : ((a + b) * (b + c) * (c + a)) / (a * b * c) \u2265 8 := h4\n    have h5\u2082 : (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := by\n      have h5\u2083 : ((a + b) * (b + c) * (c + a)) / (a * b * c) \u2265 8 := h4\n      have h5\u2084 : (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := by\n        -- Use the fact that the function t \u21a6 t^(1/6) is increasing and 8^(1/6) = sqrt(2)\n        have h5\u2085 : \u2200 (t : \u211d), t \u2265 8 \u2192 t ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := h3\n        have h5\u2086 : ((a + b) * (b + c) * (c + a)) / (a * b * c) \u2265 8 := h4\n        have h5\u2087 : (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := h5\u2085 (((a + b) * (b + c) * (c + a)) / (a * b * c)) h5\u2086\n        exact h5\u2087\n      exact h5\u2084\n    exact h5\u2082\n  \n  have h6 : X + Y + Z \u2265 3 * Real.sqrt 2 := by\n    calc\n      X + Y + Z \u2265 3 * (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n        exact l7\n      _ \u2265 3 * Real.sqrt 2 := by\n        have h6\u2081 : (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) \u2265 Real.sqrt 2 := h5\n        have h6\u2082 : 3 * (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) \u2265 3 * Real.sqrt 2 := by\n          -- Multiply both sides of the inequality by 3\n          have h6\u2083 : 0 \u2264 Real.sqrt 2 := Real.sqrt_nonneg 2\n          have h6\u2084 : 0 \u2264 (((a + b) * (b + c) * (c + a)) / (a * b * c)) ^ (1 / 6 : \u211d) := by positivity\n          nlinarith\n        linarith\n  \n  exact h6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the implicit assumptions about positive reals, with explicit positivity constraints that are mathematically necessary.", "The definitions of X, Y, Z as square roots are reasonable mathematical interpretations given the context of the problem, even though not explicitly stated in natural language.", "Assumption l4 is perfectly translated from the natural language fraction product inequality.", "Assumption l7 correctly captures the complex inequality with the sixth root expression.", "The conclusion l8 is accurately formalized as the target inequality to prove."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, $$ \\sqrt{\tfrac{a+b}{c}}+\\sqrt{\tfrac{b+c}{a}}+\\sqrt{\tfrac{c+a}{b}} \\geq 3\\sqrt{2} $$.", "statement": "We assume:\n\u2022 Let X, Y, and Z be positive real numbers defined as $X=\\sqrt{\\frac{a+b}{c}}$, $Y=\\sqrt{\\frac{b+c}{a}}$, and $Z=\\sqrt{\\frac{c+a}{b}}$ [def_1]\n\u2022 $X+Y+Z \\geq 3\\sqrt{2}$ [l8]\nTherefore, we conclude:\n\u2022 $\\sqrt{\\frac{a+b}{c}}+\\sqrt{\\frac{b+c}{a}}+\\sqrt{\\frac{c+a}{b}} \\geq 3\\sqrt{2}$ [ts_1].", "dependencies": ["def_1", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l8 : X + Y + Z \u2265 3 * Real.sqrt 2) :\n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d) \n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a)) \n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l8 : X + Y + Z \u2265 3 * Real.sqrt 2) :\n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n  have h_sum : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) = X + Y + Z := by\n    rw [hX, hY, hZ]\n    <;>\n    ring_nf\n    <;>\n    field_simp [ha.ne', hb.ne', hc.ne']\n    <;>\n    ring_nf\n    <;>\n    norm_num\n  \n  have h_main : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n    have h\u2081 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) = X + Y + Z := h_sum\n    have h\u2082 : X + Y + Z \u2265 3 * Real.sqrt 2 := l8\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects. The positivity of X, Y, Z is implicit but guaranteed by their definitions and the positivity of a, b, c.", "The definitions of X, Y, Z are perfectly translated using Real.sqrt and division operations.", "The assumption l8 is correctly formalized with the same mathematical content.", "The conclusion ts_1 correctly states the target inequality by substituting the definitions back.", "The overall logical structure perfectly matches: given definitions and an assumption, prove the conclusion by substitution."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    