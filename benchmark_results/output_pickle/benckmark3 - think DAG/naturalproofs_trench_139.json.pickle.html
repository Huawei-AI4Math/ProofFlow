
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X},$ $\mathbf{Y},$ and
$\mathbf{Z}$ are members of $\R^n$ and $a$ is a scalar, then
\begin{alist}
\item % (a)
 $|a\mathbf{X}|=|a|\,|\mathbf{X}|.$
\item % (b)
 $|\mathbf{X}|\ge0,$ with equality if and only if $\mathbf{X}=
\mathbf{0}.$
\item % (c)
 $|\mathbf{X}-\mathbf{Y}|\ge0,$ with equality if and only if
$\mathbf{X}=\mathbf{Y}.$
\item % (d)
$\mathbf{X}\cdot\mathbf{Y}=\mathbf{Y}\cdot\mathbf{X}.$
\item % (e)
 $\mathbf{X}\cdot (\mathbf{Y}+\mathbf{Z})=\mathbf{X}\cdot\mathbf{Y}+
\mathbf{X}\cdot\mathbf{Z}.$
\item % (f)
 $(c\mathbf{X})\cdot\mathbf{Y}=\mathbf{X}\cdot (c\mathbf{Y})=
c(\mathbf{X}\cdot\mathbf{Y}).$
\end{alist}

Proof: The line segment is given by
$$
\mathbf{X}=t\mathbf{X}_2+(1-t)\mathbf{X}_1,\quad 0<t<1.
$$
Suppose that $r>0$. If
$$
|\mathbf{X}_1-\mathbf{X}_0|<r,\quad |\mathbf{X}_2-\mathbf{X}_0|<r,
$$
and $0<t<1$, then
\begin{eqnarray*}
|\mathbf{X}-\mathbf{X}_0|\ar=|t\mathbf{X}_2+(1-t)\mathbf{X}_1-t\mathbf{X}_0-(1-t)\mathbf{X}_0|\\
\ar=|t(\mathbf{X}_2-\mathbf{X}_0)+(1-t)\mathbf{X}_1-\mathbf{X}_0)|\\
\ar\le  t|\mathbf{X}_2-\mathbf{X}_0|+(1-t)|\mathbf{X}_1-\mathbf{X}_0|\\
\ar< tr+(1-t)r=r.
\end{eqnarray*}
\vskip-2em
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X},$ $\\mathbf{Y},$ and\n$\\mathbf{Z}$ are members of $\\R^n$", "statement": "Premise:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors (members) of $\\R^n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (X\u2080 X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that X\u2080, X\u2081, X\u2082 are vectors by declaring them as elements of EuclideanSpace, which is the appropriate type for vectors in Lean", "The Lean formalization correctly captures the membership in \u211d\u207f by using EuclideanSpace \u211d (Fin n), which is Lean's standard representation of n-dimensional real vector spaces. The use of Fin n to index the dimensions is the standard way to represent \u211d\u207f in Lean"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Suppose that $r>0$.", "statement": "Premise:\n\u2022 Let $r$ be a scalar such that $r > 0$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (r : \u211d) (tc_2 : r > 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures 'r is a scalar' by declaring r as a real number (\u211d), which is the standard mathematical interpretation of a scalar", "The Lean formalization exactly matches the condition r > 0"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "$$\n|\\mathbf{X}_1-\\mathbf{X}_0|<r,\\quad |\\mathbf{X}_2-\\mathbf{X}_0|<r,\n$$", "statement": "Premise:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in $\\R^n$ satisfying $|\\mathbf{X}_1 - \\mathbf{X}_0| < r$ and $|\\mathbf{X}_2 - \\mathbf{X}_0| < r$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_3 (n : \u2115) (X\u2080 X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n)) (r : \u211d) \n  (hr : r > 0) \n  (h\u2081 : \u2016X\u2081 - X\u2080\u2016 < r) \n  (h\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) \n  (t : \u211d) (ht : 0 < t \u2227 t < 1) :\n  \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly represents vectors in \u211d\u207f using EuclideanSpace \u211d (Fin n), which is the standard Lean representation for finite-dimensional real vector spaces", "The Lean condition \u2016X\u2081 - X\u2080\u2016 < r perfectly matches the natural language |\ud835\udc17\u2081 - \ud835\udc17\u2080| < r, using the appropriate norm notation", "The Lean condition \u2016X\u2082 - X\u2080\u2016 < r perfectly matches the natural language |\ud835\udc17\u2082 - \ud835\udc17\u2080| < r, using the appropriate norm notation", "The Lean formalization introduces additional variables (t : \u211d) (ht : 0 < t \u2227 t < 1) and a conclusion \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r that are completely absent from the natural language premise. The natural language explicitly states there are no conclusions, making this a major inconsistency"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly represents vectors in \u211d\u207f using EuclideanSpace \u211d (Fin n), which is the standard Lean representation for finite-dimensional real vector spaces', 'The Lean condition \u2016X\u2081 - X\u2080\u2016 < r perfectly matches the natural language |\ud835\udc17\u2081 - \ud835\udc17\u2080| < r, using the appropriate norm notation', 'The Lean condition \u2016X\u2082 - X\u2080\u2016 < r perfectly matches the natural language |\ud835\udc17\u2082 - \ud835\udc17\u2080| < r, using the appropriate norm notation', 'The Lean formalization introduces additional variables (t : \u211d) (ht : 0 < t \u2227 t < 1) and a conclusion \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r that are completely absent from the natural language premise. The natural language explicitly states there are no conclusions, making this a major inconsistency']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The line segment is given by\n$$\n\\mathbf{X}=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1,\\quad 0<t<1.\n$$", "statement": "Definition:\n\u2022 A point $\\mathbf{X}$ is on the line segment between $\\mathbf{X}_1$ and $\\mathbf{X}_2$ if $\\mathbf{X}=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some scalar $t$ such that $0<t<1$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef on_line_segment (n : \u2115) (X X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n)) : Prop :=\n  \u2203 t : \u211d, 0 < t \u2227 t < 1 \u2227 X = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081\n\ntheorem distance_bound (n : \u2115) (X X\u2081 X\u2082 X\u2080 : EuclideanSpace \u211d (Fin n)) (r : \u211d) (hr : 0 < r) :\n  on_line_segment n X X\u2081 X\u2082 \u2192\n  \u2016X\u2081 - X\u2080\u2016 < r \u2192\n  \u2016X\u2082 - X\u2080\u2016 < r \u2192\n  \u2016X - X\u2080\u2016 < r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language defines the condition for being on a line segment (X = tX\u2082 + (1-t)X\u2081), but the Lean theorem assumes on_line_segment as a hypothesis rather than defining it", "The natural language has the constraint 0 < t < 1, but the Lean theorem introduces completely different conditions about distances from point X\u2080 with bound r", "The natural language concludes that X is on the line segment, but the Lean theorem concludes a distance bound \u2016X - X\u2080\u2016 < r, which is an entirely different mathematical statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language defines the condition for being on a line segment (X = tX\u2082 + (1-t)X\u2081), but the Lean theorem assumes on_line_segment as a hypothesis rather than defining it', 'The natural language has the constraint 0 < t < 1, but the Lean theorem introduces completely different conditions about distances from point X\u2080 with bound r', 'The natural language concludes that X is on the line segment, but the Lean theorem concludes a distance bound \u2016X - X\u2080\u2016 < r, which is an entirely different mathematical statement']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "|\\mathbf{X}-\\mathbf{X}_0|\\ar=|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|\\n\\ar=|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)\\mathbf{X}_1-\\mathbf{X}_0)|", "statement": "We assume:\n\u2022 $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ are vectors in $\\R^n$ [tc_1].\n\u2022 $\\mathbf{X}=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for $0<t<1$ [def_1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (n : \u2115) (X\u2080 X\u2081 X\u2082 X : EuclideanSpace \u211d (Fin n))\n  (t : \u211d) (ht : 0 < t \u2227 t < 1)\n  (h_on_segment : X = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081) :\n  \u2016X - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (n : \u2115) (X\u2080 X\u2081 X\u2082 X : EuclideanSpace \u211d (Fin n))\n  (t : \u211d) (ht : 0 < t \u2227 t < 1)\n  (h_on_segment : X = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081) :\n  \u2016X - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n  have h1 : X - X\u2080 = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n    calc\n      X - X\u2080 = (t \u2022 X\u2082 + (1 - t) \u2022 X\u2081) - X\u2080 := by rw [h_on_segment]\n      _ = (t \u2022 X\u2082 + (1 - t) \u2022 X\u2081) - X\u2080 := by rfl\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 := by rfl\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (t \u2022 X\u2080 + (1 - t) \u2022 X\u2080) := by\n        have h2 : X\u2080 = t \u2022 X\u2080 + (1 - t) \u2022 X\u2080 := by\n          calc\n            X\u2080 = (t + (1 - t)) \u2022 X\u2080 := by\n              have h3 : (t + (1 - t) : \u211d) = 1 := by ring\n              rw [h3]\n              simp\n            _ = t \u2022 X\u2080 + (1 - t) \u2022 X\u2080 := by\n              rw [add_smul]\n              <;> simp [sub_smul]\n              <;> ring_nf\n              <;> simp_all\n              <;> linarith\n        rw [h2]\n        <;> simp [sub_add_eq_add_sub]\n      _ = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n        calc\n          t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (t \u2022 X\u2080 + (1 - t) \u2022 X\u2080) = (t \u2022 X\u2082 - t \u2022 X\u2080) + ((1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080) := by\n            abel\n          _ = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n            have h3 : t \u2022 X\u2082 - t \u2022 X\u2080 = t \u2022 (X\u2082 - X\u2080) := by\n              rw [\u2190 smul_sub]\n              <;> simp [sub_smul]\n            have h4 : (1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080 = (1 - t) \u2022 (X\u2081 - X\u2080) := by\n              rw [\u2190 smul_sub]\n              <;> simp [sub_smul]\n            rw [h3, h4]\n            <;> simp [add_smul]\n  \n  have h2 : \u2016X - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n    rw [h1]\n  \n  exact h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations correctly capture the mathematical setup. The extra variable X in Lean is necessary and logically consistent with the natural language context.", "The constraint on parameter t is identically expressed in both versions as a real number strictly between 0 and 1.", "The definition of X as a convex combination is correctly formalized using Lean's scalar multiplication operator.", "The conclusion statement perfectly captures the mathematical equality using appropriate Lean notation for norms and scalar operations."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "\\ar\\le  t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|", "statement": "We assume:\n\u2022 $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ are vectors in $\\R^n$ [tc_1].\n\u2022 $t$ is a scalar such that $0<t<1$ [def_1].\n\u2022 We have the expression $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ from the prior step [l1].\nTherefore, we conclude:\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l2].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (n : \u2115) (X\u2080 X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n))\n  (t : \u211d) (ht : 0 < t \u2227 t < 1) :\n  \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (n : \u2115) (X\u2080 X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n))\n  (t : \u211d) (ht : 0 < t \u2227 t < 1) :\n  \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n  have h\u2081 : 0 < 1 - t := by\n    have h\u2081\u2081 : t < 1 := ht.2\n    linarith\n  \n  have h\u2082 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n    -- Apply the triangle inequality to the sum of two vectors\n    calc\n      \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n        -- Use the triangle inequality for norms\n        apply norm_add_le\n      _ = \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by rfl\n  \n  have h\u2083 : \u2016t \u2022 (X\u2082 - X\u2080)\u2016 = t * \u2016X\u2082 - X\u2080\u2016 := by\n    -- Use the property of norms for scalar multiplication\n    have h\u2083\u2081 : \u2016t \u2022 (X\u2082 - X\u2080)\u2016 = |t| * \u2016X\u2082 - X\u2080\u2016 := by\n      rw [norm_smul]\n      <;>\n      simp [Real.norm_eq_abs]\n    rw [h\u2083\u2081]\n    -- Since t > 0, |t| = t\n    have h\u2083\u2082 : |t| = t := by\n      rw [abs_of_nonneg (le_of_lt ht.1)]\n    rw [h\u2083\u2082]\n    <;>\n    ring\n  \n  have h\u2084 : \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 = (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    have h\u2084\u2081 : \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 = |(1 - t : \u211d)| * \u2016X\u2081 - X\u2080\u2016 := by\n      rw [norm_smul]\n      <;> simp [Real.norm_eq_abs]\n    rw [h\u2084\u2081]\n    have h\u2084\u2082 : |(1 - t : \u211d)| = (1 - t : \u211d) := by\n      rw [abs_of_nonneg]\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try nlinarith)\n    rw [h\u2084\u2082]\n    <;>\n    ring\n    <;>\n    linarith\n  \n  have h\u2085 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    calc\n      \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := h\u2082\n      _ = t * \u2016X\u2082 - X\u2080\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by rw [h\u2083]\n      _ = t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by rw [h\u2084]\n  \n  exact h\u2085", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Vector type declarations correctly use EuclideanSpace \u211d (Fin n) to represent vectors in \u211d\u207f, which is the standard Mathlib representation", "Scalar constraint 0 < t \u2227 t < 1 exactly matches the natural language condition 0<t<1", "The main inequality is correctly formalized using proper Lean notation: scalar multiplication (\u2022), vector norms (\u2016\u00b7\u2016), and the inequality structure is preserved exactly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "\\ar< tr+(1-t)r", "statement": "We assume:\n\u2022 $r > 0$ [tc_2].\n\u2022 $|\\mathbf{X}_1 - \\mathbf{X}_0| < r$ and $|\\mathbf{X}_2 - \\mathbf{X}_0| < r$ [tc_3].\n\u2022 $0 < t < 1$ [def_1].\n\u2022 We have the expression $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ from the prior step [l2].\nTherefore, we conclude:\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < tr+(1-t)r$ [l3].", "dependencies": ["tc_2", "tc_3", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {n : \u2115} (X\u2080 X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n)) (r : \u211d) (t : \u211d)\n  (tc_2 : r > 0)\n  (tc_3 : \u2016X\u2081 - X\u2080\u2016 < r \u2227 \u2016X\u2082 - X\u2080\u2016 < r)\n  (def_1 : 0 < t \u2227 t < 1)\n  (l2 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016) :\n  t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {n : \u2115} (X\u2080 X\u2081 X\u2082 : EuclideanSpace \u211d (Fin n)) (r : \u211d) (t : \u211d)\n  (tc_2 : r > 0)\n  (tc_3 : \u2016X\u2081 - X\u2080\u2016 < r \u2227 \u2016X\u2082 - X\u2080\u2016 < r)\n  (def_1 : 0 < t \u2227 t < 1)\n  (l2 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016) :\n  t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n  have h_t_pos : 0 < t := by\n    linarith\n\n  have h_one_minus_t_pos : 0 < 1 - t := by\n    linarith\n\n  have h_t_norm_X2_lt : t * \u2016X\u2082 - X\u2080\u2016 < t * r := by\n    have h\u2081 : \u2016X\u2082 - X\u2080\u2016 < r := tc_3.2\n    have h\u2082 : 0 < t := h_t_pos\n    have h\u2083 : t * \u2016X\u2082 - X\u2080\u2016 < t * r := by\n      -- Since t > 0, multiplying both sides of \u2016X\u2082 - X\u2080\u2016 < r by t preserves the inequality.\n      nlinarith\n    exact h\u2083\n\n  have h_one_minus_t_norm_X1_lt : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := by\n    have h\u2081 : \u2016X\u2081 - X\u2080\u2016 < r := tc_3.1\n    have h\u2082 : 0 < 1 - t := h_one_minus_t_pos\n    have h\u2083 : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := by\n      -- Since 1 - t > 0, multiplying both sides of \u2016X\u2081 - X\u2080\u2016 < r by (1 - t) preserves the inequality.\n      nlinarith\n    exact h\u2083\n\n  have h_main : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n    have h\u2081 : t * \u2016X\u2082 - X\u2080\u2016 < t * r := h_t_norm_X2_lt\n    have h\u2082 : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := h_one_minus_t_norm_X1_lt\n    -- Adding the two inequalities gives the desired result.\n    linarith\n\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.83, "semantic_feedback": ["Variable declarations are mathematically consistent. Lean adds explicit type information for Euclidean space which is appropriate.", "The constraint r > 0 is perfectly captured in both versions.", "Distance constraints are semantically identical. Norm notation \u2016\u00b7\u2016 in Lean is equivalent to absolute value notation |\u00b7| for Euclidean spaces.", "The bounds on t are logically equivalent between 0 < t < 1 and 0 < t \u2227 t < 1.", "Natural language only mentions 'having the expression' from prior step, while Lean provides the triangle inequality relationship. This is a minor structural difference in how the prior result is referenced.", "The conclusion is semantically identical with consistent notation (norm vs absolute value, explicit multiplication symbols)."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "=r.", "statement": "We assume:\n\u2022 $r$ and $t$ are scalars [tc_2, def_1].\nTherefore, we conclude:\n\u2022 $tr+(1-t)r = r$ [l4].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (r t : \u211d) (hr : 0 < r) :\n  t * r + (1 - t) * r = r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (r t : \u211d) (hr : 0 < r) :\n  t * r + (1 - t) * r = r := by\n  have h\u2081 : t * r + (1 - t) * r = t * r + (r - t * r) := by\n    have h\u2081\u2081 : (1 - t) * r = r - t * r := by\n      ring\n    rw [h\u2081\u2081]\n    <;>\n    ring\n    <;>\n    linarith\n  \n  have h\u2082 : t * r + (r - t * r) = r := by\n    ring_nf at h\u2081 \u22a2\n    <;> linarith\n  \n  have h\u2083 : t * r + (1 - t) * r = r := by\n    calc\n      t * r + (1 - t) * r = t * r + (r - t * r) := by rw [h\u2081]\n      _ = r := by rw [h\u2082]\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language statement. The variables r and t are properly typed as real numbers (\u211d), which appropriately represents 'scalars' in this context. The conclusion t * r + (1 - t) * r = r accurately formalizes the algebraic identity tr + (1-t)r = r. The additional constraint hr : 0 < r is an extra condition not mentioned in the natural language, but such additional constraints are acceptable as they don't contradict the original statement and fall under the category of 'extra, logically consistent details.'"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "|\\mathbf{X}-\\mathbf{X}_0|\\ar=|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|\\n\\ar=|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)\\mathbf{X}_1-\\mathbf{X}_0)|\\n\\ar\\le  t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|\\n\\ar< tr+(1-t)r=r.", "statement": "We assume:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l1].\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l2].\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < tr+(1-t)r$ [l3].\n\u2022 $tr+(1-t)r = r$ [l4].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| < r$ [ts_1].", "dependencies": ["l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {n : \u2115} (X\u2080 X\u2081 X\u2082 X : EuclideanSpace \u211d (Fin n))\n  (t r : \u211d) (ht : 0 < t \u2227 t < 1) (hr : 0 < r)\n  (h_on_segment : X = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081)\n  (l1 : \u2016X - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016)\n  (l2 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016)\n  (l3 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r)\n  (l4 : t * r + (1 - t) * r = r) :\n  \u2016X - X\u2080\u2016 < r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {n : \u2115} (X\u2080 X\u2081 X\u2082 X : EuclideanSpace \u211d (Fin n))\n  (t r : \u211d) (ht : 0 < t \u2227 t < 1) (hr : 0 < r)\n  (h_on_segment : X = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081)\n  (l1 : \u2016X - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016)\n  (l2 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016)\n  (l3 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r)\n  (l4 : t * r + (1 - t) * r = r) :\n  \u2016X - X\u2080\u2016 < r := by\n  have h_step1 : \u2016X - X\u2080\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    calc\n      \u2016X - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by rw [l1]\n      _ \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := l2\n  \n  have h_step2 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < r := by\n    have h5 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := l3\n    have h6 : t * r + (1 - t) * r = r := l4\n    linarith\n  \n  have h_final : \u2016X - X\u2080\u2016 < r := by\n    -- Use the transitivity of the less-than relation to combine h_step1 and h_step2\n    have h7 : \u2016X - X\u2080\u2016 < r := by\n      -- Apply the lemma lt_of_le_of_lt to combine the inequalities\n      linarith\n    exact h7\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects. Extra constraints (t \u2208 (0,1), r > 0) and geometric relationship are logically consistent additions not contradicting the natural language.", "Assumption l1 is correctly formalized using norm notation and scalar multiplication, preserving the mathematical meaning.", "Assumption l2 accurately represents the triangle inequality with proper Lean syntax for norms and operations.", "Assumption l3 correctly formalizes the strict inequality with explicit multiplication operators.", "Assumption l4 directly translates the algebraic identity with appropriate Lean notation.", "The conclusion ts_1 perfectly captures the target inequality using norm notation.", "The overall logical flow and proof structure are preserved, with all assumptions leading to the stated conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    