
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all real numbers $a, b, c, d > 1$, the following inequality holds:
$$ 
\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\leq \\sqrt{(a b+1)(c d+1)}.
$$

Proof: We prove that $\sqrt{a-1}+\sqrt{b-1}+\sqrt{c-1}+\sqrt{d-1}\le\sqrt{(ab+1)(cd+1)}$ for $a,b,c,d>1$. For $x,y>1$ we have $(\sqrt{x-1}+\sqrt{y-1})^2=x+y-2+2\sqrt{(x-1)(y-1)}\le xy$ because $(x-1)(y-1)\ge0$; hence $\sqrt{x-1}+\sqrt{y-1}\le\sqrt{xy}$. Applying this to $(a,b)$ and $(c,d)$ gives $\sqrt{a-1}+\sqrt{b-1}+\sqrt{c-1}+\sqrt{d-1}\le\sqrt{ab}+\sqrt{cd}$. Next, for any $X,Y\ge0$ we have $(X+Y)^2\le (X^2+1)(Y^2+1)$ since the latter minus the former equals $(XY-1)^2\ge0$; thus $X+Y\le\sqrt{(X^2+1)(Y^2+1)}$. Taking $X=\sqrt{ab}$ and $Y=\sqrt{cd}$ yields $\sqrt{ab}+\sqrt{cd}\le\sqrt{(ab+1)(cd+1)}$, and combining the two inequalities gives the desired result.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "for all real numbers $a, b, c, d > 1$", "statement": "Premise:\n\u2022 $a, b, c, d$ are real numbers such that $a > 1, b > 1, c > 1, d > 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c d : \u211d)\n(tc_1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a b c d : \u211d)' correctly captures that a, b, c, d are real numbers", "The condition 'a > 1' is correctly captured in the conjunction tc_1", "The condition 'b > 1' is correctly captured in the conjunction tc_1", "The condition 'c > 1' is correctly captured in the conjunction tc_1", "The condition 'd > 1' is correctly captured in the conjunction tc_1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $x,y>1$ we have $(\\sqrt{x-1}+\\sqrt{y-1})^2=x+y-2+2\\sqrt{(x-1)(y-1)}\\le xy$ because $(x-1)(y-1)\\ge0$;", "statement": "We assume:\n\u2022 $x, y$ are real numbers such that $x > 1$ and $y > 1$.\nTherefore, we conclude:\n\u2022 $(\\sqrt{x-1}+\\sqrt{y-1})^2 \\le xy$ [l1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (x y : \u211d) (hx : x > 1) (hy : y > 1) :\n  (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (x y : \u211d) (hx : x > 1) (hy : y > 1) :\n  (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y := by\n  have h\u2081 : 0 < x - 1 := by\n    linarith\n  \n  have h\u2082 : 0 < y - 1 := by\n    linarith\n  \n  have h\u2083 : (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 = (x - 1) + (y - 1) + 2 * Real.sqrt (x - 1) * Real.sqrt (y - 1) := by\n    have h\u2083\u2081 : 0 \u2264 Real.sqrt (x - 1) := Real.sqrt_nonneg (x - 1)\n    have h\u2083\u2082 : 0 \u2264 Real.sqrt (y - 1) := Real.sqrt_nonneg (y - 1)\n    have h\u2083\u2083 : 0 \u2264 Real.sqrt (x - 1) * Real.sqrt (y - 1) := by positivity\n    calc\n      (Real.sqrt (x - 1) + Real.sqrt (y - 1)) ^ 2 = (Real.sqrt (x - 1)) ^ 2 + (Real.sqrt (y - 1)) ^ 2 + 2 * (Real.sqrt (x - 1) * Real.sqrt (y - 1)) := by\n        ring_nf\n        <;>\n        nlinarith [Real.sq_sqrt (show 0 \u2264 x - 1 by linarith), Real.sq_sqrt (show 0 \u2264 y - 1 by linarith)]\n      _ = (x - 1) + (y - 1) + 2 * Real.sqrt (x - 1) * Real.sqrt (y - 1) := by\n        have h\u2083\u2084 : (Real.sqrt (x - 1)) ^ 2 = (x - 1) := by\n          rw [Real.sq_sqrt] <;> linarith\n        have h\u2083\u2085 : (Real.sqrt (y - 1)) ^ 2 = (y - 1) := by\n          rw [Real.sq_sqrt] <;> linarith\n        rw [h\u2083\u2084, h\u2083\u2085]\n        <;> ring_nf\n        <;> nlinarith\n  \n  have h\u2084 : x * y = (x - 1) * (y - 1) + (x - 1) + (y - 1) + 1 := by\n    ring_nf at *\n    <;>\n    (try linarith) <;>\n    (try nlinarith) <;>\n    (try ring_nf) <;>\n    (try nlinarith)\n    <;>\n    linarith\n  \n  have h\u2085 : 2 * Real.sqrt (x - 1) * Real.sqrt (y - 1) \u2264 (x - 1) * (y - 1) + 1 := by\n    have h\u2085\u2081 : 0 \u2264 Real.sqrt (x - 1) := Real.sqrt_nonneg (x - 1)\n    have h\u2085\u2082 : 0 \u2264 Real.sqrt (y - 1) := Real.sqrt_nonneg (y - 1)\n    have h\u2085\u2083 : 0 \u2264 Real.sqrt (x - 1) * Real.sqrt (y - 1) := by positivity\n    have h\u2085\u2084 : 0 \u2264 (x - 1) := by linarith\n    have h\u2085\u2085 : 0 \u2264 (y - 1) := by linarith\n    have h\u2085\u2086 : 0 \u2264 (x - 1) * (y - 1) := by positivity\n    have h\u2085\u2087 : (Real.sqrt (x - 1) * Real.sqrt (y - 1)) ^ 2 = (x - 1) * (y - 1) := by\n      calc\n        (Real.sqrt (x - 1) * Real.sqrt (y - 1)) ^ 2 = (Real.sqrt (x - 1)) ^ 2 * (Real.sqrt (y - 1)) ^ 2 := by ring\n        _ = (x - 1) * (y - 1) := by\n          have h\u2085\u2087\u2081 : (Real.sqrt (x - 1)) ^ 2 = (x - 1) := by\n            rw [Real.sq_sqrt] <;> linarith\n          have h\u2085\u2087\u2082 : (Real.sqrt (y - 1)) ^ 2 = (y - 1) := by\n            rw [Real.sq_sqrt] <;> linarith\n          rw [h\u2085\u2087\u2081, h\u2085\u2087\u2082]\n          <;> ring\n        _ = (x - 1) * (y - 1) := by ring\n    have h\u2085\u2088 : (Real.sqrt (x - 1) * Real.sqrt (y - 1) - 1) ^ 2 \u2265 0 := by\n      nlinarith\n    nlinarith [sq_nonneg (Real.sqrt (x - 1) * Real.sqrt (y - 1) - 1)]\n  \n  have h\u2086 : (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y := by\n    calc\n      (Real.sqrt (x - 1) + Real.sqrt (y - 1)) ^ 2 = (x - 1) + (y - 1) + 2 * Real.sqrt (x - 1) * Real.sqrt (y - 1) := by rw [h\u2083]\n      _ \u2264 (x - 1) + (y - 1) + ((x - 1) * (y - 1) + 1) := by\n        nlinarith [h\u2085]\n      _ = (x - 1) * (y - 1) + (x - 1) + (y - 1) + 1 := by ring\n      _ = x * y := by\n        rw [h\u2084]\n        <;> ring\n        <;>\n        nlinarith\n  \n  exact h\u2086", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. The variable types (real numbers), constraints (x > 1, y > 1), and the inequality (\u221a(x-1) + \u221a(y-1))\u00b2 \u2264 xy are all correctly represented. The additional Lean syntax elements like theorem naming and proof structure are standard formalization requirements and do not affect the mathematical content."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "hence $\\sqrt{x-1}+\\sqrt{y-1}\\le\\sqrt{xy}$.", "statement": "We assume:\n\u2022 For any real numbers $x, y > 1$, we have $(\\sqrt{x-1}+\\sqrt{y-1})^2 \\le xy$ [l1].\nTherefore, we conclude:\n\u2022 For any real numbers $x, y > 1$, $\\sqrt{x-1}+\\sqrt{y-1} \\le \\sqrt{xy}$ [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (x y : \u211d) (hx : x > 1) (hy : y > 1) \n  (h : (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y) :\n  Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2264 Real.sqrt (x * y) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (x y : \u211d) (hx : x > 1) (hy : y > 1) \n  (h : (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y) :\n  Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2264 Real.sqrt (x * y) := by\n  have h_nonneg : Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2265 0 := by\n    have h\u2081 : Real.sqrt (x - 1) \u2265 0 := Real.sqrt_nonneg (x - 1)\n    have h\u2082 : Real.sqrt (y - 1) \u2265 0 := Real.sqrt_nonneg (y - 1)\n    linarith\n  \n  have h_main : Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2264 Real.sqrt (x * y) := by\n    have h\u2081 : 0 \u2264 x * y := by\n      have h\u2082 : 0 < x := by linarith\n      have h\u2083 : 0 < y := by linarith\n      positivity\n    -- Use the lemma `Real.le_sqrt_of_sq_le` to conclude the proof\n    have h\u2082 : (Real.sqrt (x - 1) + Real.sqrt (y - 1)) ^ 2 \u2264 x * y := h\n    have h\u2083 : Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2265 0 := h_nonneg\n    -- Apply the lemma to get the desired inequality\n    have h\u2084 : Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2264 Real.sqrt (x * y) := by\n      apply Real.le_sqrt_of_sq_le\n      <;> nlinarith [Real.sq_sqrt (show 0 \u2264 x * y by positivity)]\n    exact h\u2084\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and domain constraints (x, y > 1) are correctly captured in Lean with appropriate type annotations and hypothesis names.", "The assumption about the squared inequality is perfectly translated, with Real.sqrt correctly representing square roots and the algebraic structure preserved.", "The conclusion inequality is exactly represented in Lean, maintaining the same mathematical relationship between the square roots.", "The logical flow from assumption to conclusion is properly structured as a theorem in Lean, where the premise becomes a hypothesis and the conclusion becomes the goal to prove."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Applying this to $(a,b)$ and $(c,d)$ gives $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1}\\le\\sqrt{ab}+\\sqrt{cd}$.", "statement": "We assume:\n\u2022 $a, b$ are real numbers such that $a > 1, b > 1$ [tc_1]\n\u2022 For any real numbers $x, y > 1$, $\\sqrt{x-1}+\\sqrt{y-1} \\le \\sqrt{xy}$ [l2].\nTherefore, we conclude:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1} \\le \\sqrt{ab}$ [l3].", "dependencies": ["tc_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b : \u211d) \n  (tc_1 : a > 1 \u2227 b > 1) \n  (l2 : \u2200 x y : \u211d, x > 1 \u2192 y > 1 \u2192 Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2264 Real.sqrt (x * y)) :\n  Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b : \u211d) \n  (tc_1 : a > 1 \u2227 b > 1) \n  (l2 : \u2200 x y : \u211d, x > 1 \u2192 y > 1 \u2192 Real.sqrt (x - 1) + Real.sqrt (y - 1) \u2264 Real.sqrt (x * y)) :\n  Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b) := by\n  have h_main : Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b) := by\n    have h\u2081 : a > 1 := tc_1.1\n    have h\u2082 : b > 1 := tc_1.2\n    have h\u2083 : Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b) := l2 a b h\u2081 h\u2082\n    exact h\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and constraints are correctly formalized with proper types and logical conjunction.", "The universal quantification and implication structure perfectly captures the general lemma with all mathematical operations correctly translated.", "The conclusion is an exact mathematical translation of the natural language statement, maintaining the same logical structure and mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Applying this to $(a,b)$ and $(c,d)$ gives $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1}\\le\\sqrt{ab}+\\sqrt{cd}$.", "statement": "We assume:\n\u2022 $c, d$ are real numbers such that $c > 1, d > 1$ [tc_1]\n\u2022 For any real numbers $x, y > 1$, $\\sqrt{x-1}+\\sqrt{y-1} \\le \\sqrt{xy}$ [l2].\nTherefore, we conclude:\n\u2022 $\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{cd}$ [l4].", "dependencies": ["tc_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (c d : \u211d) (hc : c > 1) (hd : d > 1) \n  (l2 : \u2200 x y : \u211d, x > 1 \u2192 y > 1 \u2192 (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y) :\n  Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (c d : \u211d) (hc : c > 1) (hd : d > 1) \n  (l2 : \u2200 x y : \u211d, x > 1 \u2192 y > 1 \u2192 (Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y) :\n  Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d) := by\n  have h_sum_nonneg : Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2265 0 := by\n    have h\u2081 : Real.sqrt (c - 1) \u2265 0 := Real.sqrt_nonneg (c - 1)\n    have h\u2082 : Real.sqrt (d - 1) \u2265 0 := Real.sqrt_nonneg (d - 1)\n    linarith\n  \n  have h_sq_le : (Real.sqrt (c - 1) + Real.sqrt (d - 1))^2 \u2264 c * d := by\n    have h\u2081 : (Real.sqrt (c - 1) + Real.sqrt (d - 1)) ^ 2 \u2264 c * d := by\n      have h\u2082 : (Real.sqrt (c - 1) + Real.sqrt (d - 1)) ^ 2 \u2264 c * d := by\n        -- Use the given lemma l2 to directly get the inequality\n        have h\u2083 : (Real.sqrt (c - 1) + Real.sqrt (d - 1)) ^ 2 \u2264 c * d := l2 c d hc hd\n        exact h\u2083\n      exact h\u2082\n    exact h\u2081\n  \n  have h_main : Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d) := by\n    have h\u2081 : 0 \u2264 Real.sqrt (c - 1) + Real.sqrt (d - 1) := h_sum_nonneg\n    have h\u2082 : (Real.sqrt (c - 1) + Real.sqrt (d - 1)) ^ 2 \u2264 c * d := h_sq_le\n    have h\u2083 : 0 \u2264 c * d := by\n      have h\u2084 : 0 < c := by linarith\n      have h\u2085 : 0 < d := by linarith\n      positivity\n    -- Use the property of square roots to conclude the proof\n    have h\u2084 : Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d) := by\n      apply Real.le_sqrt_of_sq_le\n      <;> nlinarith [Real.sq_sqrt (show 0 \u2264 c * d by positivity)]\n    exact h\u2084\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization has a structural difference in the premise l2. The natural language states '\u221a(x-1) + \u221a(y-1) \u2264 \u221a(xy)' but the Lean code uses '(Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y'. While these are mathematically equivalent when both sides are non-negative, this represents a notational difference that is not a direct translation of the natural language statement. The conclusion l4 correctly matches the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has a structural difference in the premise l2. The natural language states '\u221a(x-1) + \u221a(y-1) \u2264 \u221a(xy)' but the Lean code uses '(Real.sqrt (x - 1) + Real.sqrt (y - 1))^2 \u2264 x * y'. While these are mathematically equivalent when both sides are non-negative, this represents a notational difference that is not a direct translation of the natural language statement. The conclusion l4 correctly matches the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Applying this to $(a,b)$ and $(c,d)$ gives $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1}\\le\\sqrt{ab}+\\sqrt{cd}$.", "statement": "We assume:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1} \\le \\sqrt{ab}$ [l3]\n\u2022 $\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{cd}$ [l4].\nTherefore, we conclude:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{ab}+\\sqrt{cd}$ [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a b c d : \u211d) (ha : a > 1) (hb : b > 1) (hc : c > 1) (hd : d > 1)\n  (l3 : Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b))\n  (l4 : Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d)) :\n  Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a b c d : \u211d) (ha : a > 1) (hb : b > 1) (hc : c > 1) (hd : d > 1)\n  (l3 : Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b))\n  (l4 : Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d)) :\n  Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d) := by\n  have h_main : Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d) := by\n    have h\u2081 : Real.sqrt (a - 1) + Real.sqrt (b - 1) \u2264 Real.sqrt (a * b) := l3\n    have h\u2082 : Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (c * d) := l4\n    -- Add the two inequalities to get the desired result\n    have h\u2083 : Real.sqrt (a - 1) + Real.sqrt (b - 1) + (Real.sqrt (c - 1) + Real.sqrt (d - 1)) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d) := by\n      linarith\n    -- Rearrange the left side to match the goal\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are correctly formalized with appropriate type constraints. The additional constraints (a > 1, b > 1, c > 1, d > 1) are mathematically necessary to ensure all square root expressions are well-defined, which is consistent with the implicit assumptions in the natural language.", "Assumption l3 is translated exactly with perfect correspondence between the mathematical notation and Lean syntax.", "Assumption l4 is translated exactly with perfect correspondence between the mathematical notation and Lean syntax.", "The conclusion l5 is translated exactly, capturing the complete inequality with all four square root terms on the left side and two on the right side.", "The logical structure perfectly captures the inference pattern: given hypotheses l3 and l4, prove conclusion l5. The theorem statement format correctly represents this logical relationship."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "for any $X,Y\\ge0$ we have $(X+Y)^2\\le (X^2+1)(Y^2+1)$ since the latter minus the former equals $(XY-1)^2\\ge0$;", "statement": "We assume:\n\u2022 $X, Y$ are non-negative real numbers.\nTherefore, we conclude:\n\u2022 $(X+Y)^2 \\le (X^2+1)(Y^2+1)$ [l6].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (X Y : \u211d) (hX : X \u2265 0) (hY : Y \u2265 0) :\n  (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (X Y : \u211d) (hX : X \u2265 0) (hY : Y \u2265 0) :\n  (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1) := by\n  have h_main : (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1) := by\n    nlinarith [sq_nonneg (X * Y - 1), sq_nonneg (X - Y), sq_nonneg (X + Y),\n      sq_nonneg (X * Y - X), sq_nonneg (X * Y - Y), mul_nonneg hX hY,\n      sq_nonneg (X * Y), sq_nonneg (X - 1), sq_nonneg (Y - 1)]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The variables are properly typed as real numbers with non-negativity constraints, and the inequality is expressed with mathematically equivalent notation. The logical structure as a theorem with assumptions and conclusion is preserved perfectly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "thus $X+Y\\le\\sqrt{(X^2+1)(Y^2+1)}$.", "statement": "We assume:\n\u2022 For any non-negative real numbers $X, Y$, $(X+Y)^2 \\le (X^2+1)(Y^2+1)$ [l6].\nTherefore, we conclude:\n\u2022 For any non-negative real numbers $X, Y$, $X+Y \\le \\sqrt{(X^2+1)(Y^2+1)}$ [l7].", "dependencies": ["l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (X Y : \u211d) (hX : X \u2265 0) (hY : Y \u2265 0) \n  (h : (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1)) :\n  X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (X Y : \u211d) (hX : X \u2265 0) (hY : Y \u2265 0) \n  (h : (X + Y)^2 \u2264 (X^2 + 1) * (Y^2 + 1)) :\n  X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1)) := by\n  have h_sum_nonneg : X + Y \u2265 0 := by\n    -- Prove that the sum of two non-negative numbers is non-negative.\n    linarith [hX, hY]\n  \n  have h_product_nonneg : (X^2 + 1) * (Y^2 + 1) \u2265 0 := by\n    -- Prove that the product of two non-negative numbers is non-negative.\n    have h\u2081 : X ^ 2 + 1 \u2265 0 := by nlinarith\n    have h\u2082 : Y ^ 2 + 1 \u2265 0 := by nlinarith\n    nlinarith\n  \n  have h_main : X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1)) := by\n    -- Use the lemma `Real.le_sqrt_of_sq_le` to conclude the proof.\n    have h\u2081 : 0 \u2264 X + Y := h_sum_nonneg\n    have h\u2082 : 0 \u2264 (X ^ 2 + 1) * (Y ^ 2 + 1) := h_product_nonneg\n    have h\u2083 : (X + Y) ^ 2 \u2264 (X ^ 2 + 1) * (Y ^ 2 + 1) := h\n    -- Apply the lemma to get the desired inequality.\n    apply Real.le_sqrt_of_sq_le\n    <;> nlinarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations correctly capture 'non-negative real numbers X, Y' with appropriate type annotations and non-negativity constraints.", "The assumption is perfectly translated with the same mathematical inequality, using appropriate Lean syntax for exponentiation and multiplication.", "The conclusion is correctly formalized using Real.sqrt to represent the square root operation, maintaining the exact same inequality.", "The logical structure properly represents the implication from assumption to conclusion as a theorem statement in Lean."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Taking $X=\\sqrt{ab}$ and $Y=\\sqrt{cd}$ yields $\\sqrt{ab}+\\sqrt{cd}\\le\\sqrt{(ab+1)(cd+1)}$,", "statement": "We assume:\n\u2022 $a,b,c,d$ are real numbers greater than 1 [tc_1]\n\u2022 For any non-negative real numbers $X, Y$, $X+Y \\le \\sqrt{(X^2+1)(Y^2+1)}$ [l7].\nTherefore, we conclude:\n\u2022 $\\sqrt{ab}+\\sqrt{cd} \\le \\sqrt{(ab+1)(cd+1)}$ [l8].", "dependencies": ["tc_1", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 (a b c d : \u211d) \n  (h1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (h2 : \u2200 X Y : \u211d, X \u2265 0 \u2192 Y \u2265 0 \u2192 X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1))) :\n  Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 (a b c d : \u211d) \n  (h1 : a > 1 \u2227 b > 1 \u2227 c > 1 \u2227 d > 1)\n  (h2 : \u2200 X Y : \u211d, X \u2265 0 \u2192 Y \u2265 0 \u2192 X + Y \u2264 Real.sqrt ((X^2 + 1) * (Y^2 + 1))) :\n  Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by\n  have h3 : 0 \u2264 Real.sqrt (a * b) := by\n    apply Real.sqrt_nonneg\n  \n  have h4 : 0 \u2264 Real.sqrt (c * d) := by\n    apply Real.sqrt_nonneg\n  \n  have h5 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt (( (Real.sqrt (a * b))^2 + 1 ) * ( (Real.sqrt (c * d))^2 + 1 )) := by\n    have h5\u2081 : 0 \u2264 Real.sqrt (a * b) := h3\n    have h5\u2082 : 0 \u2264 Real.sqrt (c * d) := h4\n    have h5\u2083 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt (( (Real.sqrt (a * b))^2 + 1 ) * ( (Real.sqrt (c * d))^2 + 1 )) := by\n      apply h2\n      <;> assumption\n    exact h5\u2083\n  \n  have h6 : ( (Real.sqrt (a * b))^2 + 1 ) * ( (Real.sqrt (c * d))^2 + 1 ) = (a * b + 1) * (c * d + 1) := by\n    have h6\u2081 : (Real.sqrt (a * b))^2 = a * b := by\n      rw [Real.sq_sqrt (by\n        -- Prove that a * b \u2265 0\n        have h6\u2082 : 0 < a := by linarith\n        have h6\u2083 : 0 < b := by linarith\n        have h6\u2084 : 0 < a * b := by positivity\n        linarith\n      )]\n    have h6\u2082 : (Real.sqrt (c * d))^2 = c * d := by\n      rw [Real.sq_sqrt (by\n        -- Prove that c * d \u2265 0\n        have h6\u2083 : 0 < c := by linarith\n        have h6\u2084 : 0 < d := by linarith\n        have h6\u2085 : 0 < c * d := by positivity\n        linarith\n      )]\n    rw [h6\u2081, h6\u2082]\n    <;> ring\n    <;>\n    (try norm_num)\n    <;>\n    (try linarith)\n  \n  have h7 : Real.sqrt (( (Real.sqrt (a * b))^2 + 1 ) * ( (Real.sqrt (c * d))^2 + 1 )) = Real.sqrt ((a * b + 1) * (c * d + 1)) := by\n    rw [h6]\n    <;>\n    simp [Real.sqrt_eq_iff_sq_eq]\n    <;>\n    ring_nf\n    <;>\n    norm_num\n    <;>\n    (try positivity)\n    <;>\n    (try nlinarith [h1.1, h1.2.1, h1.2.2.1, h1.2.2.2])\n  \n  have h8 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by\n    calc\n      Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt (( (Real.sqrt (a * b))^2 + 1 ) * ( (Real.sqrt (c * d))^2 + 1 )) := h5\n      _ = Real.sqrt ((a * b + 1) * (c * d + 1)) := by rw [h7]\n  \n  exact h8", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and constraints are correctly formalized with proper real number types and conjunction of inequalities", "The universal quantification over non-negative reals with the inequality conclusion accurately captures the mathematical assumption", "The conclusion inequality is perfectly translated with correct square root and arithmetic operations", "The overall logical structure properly represents the theorem format with assumptions leading to conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "and combining the two inequalities gives the desired result.", "statement": "We assume:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{ab}+\\sqrt{cd}$ [l5]\n\u2022 $\\sqrt{ab}+\\sqrt{cd} \\le \\sqrt{(ab+1)(cd+1)}$ [l8].\nTherefore, we conclude:\n\u2022 $\\sqrt{a-1}+\\sqrt{b-1}+\\sqrt{c-1}+\\sqrt{d-1} \\le \\sqrt{(ab+1)(cd+1)}$ [ts_1].", "dependencies": ["l5", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b c d : \u211d) (ha : a > 1) (hb : b > 1) (hc : c > 1) (hd : d > 1)\n  (l5 : Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d))\n  (l8 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1))) :\n  Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b c d : \u211d) (ha : a > 1) (hb : b > 1) (hc : c > 1) (hd : d > 1)\n  (l5 : Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d))\n  (l8 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1))) :\n  Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by\n  have h_main : Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := by\n    -- Use the transitivity of the less than or equal relation to combine l5 and l8\n    have h1 : Real.sqrt (a - 1) + Real.sqrt (b - 1) + Real.sqrt (c - 1) + Real.sqrt (d - 1) \u2264 Real.sqrt (a * b) + Real.sqrt (c * d) := l5\n    have h2 : Real.sqrt (a * b) + Real.sqrt (c * d) \u2264 Real.sqrt ((a * b + 1) * (c * d + 1)) := l8\n    -- Apply the transitivity of \u2264 to get the desired result\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are correctly typed as real numbers. The additional constraints (a>1, b>1, c>1, d>1) are mathematically sound additions that ensure all square root expressions are well-defined over the reals.", "Assumption l5 is perfectly translated from natural language to Lean, capturing the exact mathematical inequality with proper syntax.", "Assumption l8 is perfectly translated from natural language to Lean, capturing the exact mathematical inequality with proper syntax.", "The conclusion ts_1 is perfectly translated, maintaining the exact same mathematical relationship as stated in natural language.", "The overall logical structure correctly captures the transitive reasoning pattern: given l5 and l8 as hypotheses, conclude ts_1. This perfectly matches the natural language logical flow."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    