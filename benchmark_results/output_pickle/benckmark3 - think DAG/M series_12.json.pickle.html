
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$. Let $(b_n)$ be a sequence defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$. Prove that for all integers $n \geq 1$, the inequality $a_n < b_n$ holds.

Proof: First, we find the explicit formulas for the terms of both sequences and then showing the inequality holds. For the sequence $(a_n)$, we have $a_1=1$. For $n=1$, $a_2=3a_1-2=3(1)-2=1$. For $n=2$, $a_3=3a_2-2=3(1)-2=1$. By induction, we can show that $a_n=1$ for all $n \geq 1$. For the sequence $(b_n)$, we have $b_1=3$. We can show that $b_n=2^{n+1}-1$ by induction. For the base case $n=1$, $b_1=2^{1+1}-1=2^2-1=3$ holds. Assume $b_k=2^{k+1}-1$ for some $k \geq 1$. Then $b_{k+1}=2b_k+1=2(2^{k+1}-1)+1=2^{k+2}-2+1=2^{k+2}-1$. So $b_{k+1}=2^{(k+1)+1}-1$ holds. Thus $b_n=2^{n+1}-1$ for all $n \geq 1$. Now we need to prove the inequality $a_n < b_n$. Substituting our explicit formulas, we need to show that $1 < 2^{n+1}-1$. This is equivalent to showing $2 < 2^{n+1}$, which is $1 < 2^n$. This inequality holds for all integers $n \geq 1$. Therefore, the inequality $a_n < b_n$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$.", "statement": "Premise:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of real numbers such that $a_1=1$ and for all $n \\geq 1$, $a_{n+1}=3a_n-2$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'a : \u2115 \u2192 \u211d' correctly captures a sequence of real numbers indexed by natural numbers, which corresponds to the mathematical notation $(a_n)_{n \u2265 1}$", "The Lean condition 'a 1 = 1' directly matches the mathematical statement $a_1 = 1$", "The Lean condition '\u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2' perfectly captures the recurrence relation 'for all $n \u2265 1$, $a_{n+1} = 3a_n - 2$'. The multiplication is written as '3 * a n' instead of '3a_n' but this is just notational difference in Lean syntax"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $(b_n)$ be a sequence defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$.", "statement": "Premise:\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of real numbers such that $b_1=3$ and for all $n \\geq 1$, $b_{n+1}=2b_n+1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (b : \u2115 \u2192 \u211d)\n  (hb_1 : b 1 = 3)\n  (hb_rec : \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `b : \u2115 \u2192 \u211d` correctly captures that b is a sequence of real numbers indexed by natural numbers, which corresponds to $(b_n)_{n \u2265 1}$", "The Lean hypothesis `hb_1 : b 1 = 3` exactly matches the condition $b_1 = 3$", "The Lean hypothesis `hb_rec : \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1` precisely captures the recurrence relation for all $n \u2265 1$", "The Lean formalization implicitly establishes that the sequence is well-defined through the variable declaration and the two hypotheses, which together completely specify the sequence"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For the sequence $(a_n)$, we have $a_1=1$. For $n=1$, $a_2=3a_1-2=3(1)-2=1$. For $n=2$, $a_3=3a_2-2=3(1)-2=1$. By induction, we can show that $a_n=1$ for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of real numbers such that $a_1=1$ and for all $n \\geq 1$, $a_{n+1}=3a_n-2$ [tc_1].\nTherefore, we conclude:\n\u2022 For all $n \\geq 1$, $a_n=1$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 := by\n  have h_base : a 1 = 1 := by\n    exact h.1\n  \n  have h_inductive_step : \u2200 (k : \u2115), k \u2265 1 \u2192 a k = 1 \u2192 a (k + 1) = 1 := by\n    intro k hk h_k\n    have h_rec : a (k + 1) = 3 * a k - 2 := h.2 k hk\n    rw [h_rec]\n    rw [h_k]\n    norm_num\n    <;>\n    linarith\n  \n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 1 := by\n    intro n hn\n    have h\u2081 : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 1 := by\n      intro n hn\n      induction' hn with n hn IH\n      \u00b7 -- Base case: n = 1\n        exact h_base\n      \u00b7 -- Inductive step: assume the statement holds for n, prove for n + 1\n        exact h_inductive_step n hn IH\n    exact h\u2081 n hn\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition, initial condition a\u2081=1, and function type \u2115 \u2192 \u211d correctly capture the natural language specification of a sequence of real numbers.", "The recurrence relation a(n+1) = 3*a(n) - 2 for n \u2265 1 is exactly formalized with proper quantification and domain restriction.", "The conclusion that a\u2099 = 1 for all n \u2265 1 is precisely captured in the theorem statement with correct quantification."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For the base case $n=1$, $b_1=2^{1+1}-1=2^2-1=3$ holds.", "statement": "We assume:\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of real numbers such that $b_1=3$ [tc_2].\nTherefore, we conclude:\n\u2022 The formula $b_n=2^{n+1}-1$ holds for $n=1$ [l2].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 : \n  \u2200 (b : \u2115 \u2192 \u211d), \n  b 1 = 3 \u2192 \n  b 1 = 2^(1+1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 : \n  \u2200 (b : \u2115 \u2192 \u211d), \n  b 1 = 3 \u2192 \n  b 1 = 2^(1+1) - 1 := by\n  intro b h\n  have h\u2081 : (2 : \u211d) ^ (1 + 1) - 1 = (3 : \u211d) := by\n    norm_num\n    <;>\n    simp [pow_succ]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h\u2082 : b 1 = (2 : \u211d) ^ (1 + 1) - 1 := by\n    have h\u2083 : b 1 = (3 : \u211d) := by exact_mod_cast h\n    rw [h\u2083]\n    linarith\n  \n  exact h\u2082", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical structure from natural language. It properly represents the assumption that b_1 = 3 and the conclusion that this satisfies the formula b_n = 2^(n+1) - 1 for n=1. The implication structure matches the 'assume...therefore conclude' pattern in the natural language, and the mathematical content is equivalent (2^(1+1) - 1 = 3)."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Assume $b_k=2^{k+1}-1$ for some $k \\geq 1$. Then $b_{k+1}=2b_k+1=2(2^{k+1}-1)+1=2^{k+2}-2+1=2^{k+2}-1$. So $b_{k+1}=2^{(k+1)+1}-1$ holds.", "statement": "We assume:\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of real numbers such that for all $n \\geq 1$, $b_{n+1}=2b_n+1$ [tc_2].\n\u2022 For some integer $k \\geq 1$, $b_k=2^{k+1}-1$ (Inductive Hypothesis).\nTherefore, we conclude:\n\u2022 $b_{k+1}=2^{(k+1)+1}-1$ [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (b : \u2115 \u2192 \u211d)\n  (hb_rec : \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (k : \u2115) (hk : k \u2265 1) (h_k : b k = 2^(k+1) - 1) :\n  b (k + 1) = 2^((k+1)+1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (b : \u2115 \u2192 \u211d)\n  (hb_rec : \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (k : \u2115) (hk : k \u2265 1) (h_k : b k = (2:\u211d)^(k+1) - 1) :\n  b (k + 1) = (2:\u211d)^((k+1)+1) - 1 := by\n  have h_main : b (k + 1) = (2:\u211d)^((k+1)+1) - 1 := by\n    have h1 : b (k + 1) = 2 * b k + 1 := by\n      have h2 : k \u2265 1 := hk\n      have h3 : b (k + 1) = 2 * b k + 1 := hb_rec k h2\n      exact h3\n    rw [h1]\n    have h4 : b k = (2:\u211d)^(k+1) - 1 := h_k\n    rw [h4]\n    have h5 : (2:\u211d) * ((2:\u211d)^(k+1) - 1 : \u211d) + 1 = (2:\u211d)^((k+1)+1) - 1 := by\n      have h6 : (2:\u211d) * ((2:\u211d)^(k+1) : \u211d) = (2:\u211d)^((k+1)+1) := by\n        calc\n          (2:\u211d) * ((2:\u211d)^(k+1) : \u211d) = (2:\u211d)^1 * (2:\u211d)^(k+1) := by norm_num\n          _ = (2:\u211d)^(1 + (k+1)) := by rw [\u2190 pow_add]\n          _ = (2:\u211d)^((k+1)+1) := by ring_nf\n      calc\n        (2:\u211d) * ((2:\u211d)^(k+1) - 1 : \u211d) + 1 = (2:\u211d) * ((2:\u211d)^(k+1) : \u211d) - 2 + 1 := by ring\n        _ = (2:\u211d)^( (k+1)+1 ) - 2 + 1 := by rw [h6]\n        _ = (2:\u211d)^((k+1)+1) - 1 := by ring\n    rw [h5]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition and recurrence relation are correctly captured. The Lean formalization uses \u2115 \u2192 \u211d to represent the sequence of real numbers indexed by natural numbers, and the recurrence relation b(n+1) = 2*b(n) + 1 for n \u2265 1 is exactly as stated in natural language.", "The inductive hypothesis is perfectly formalized. The natural language states 'for some integer k \u2265 1, b_k = 2^(k+1) - 1', and the Lean code captures this with the parameter k : \u2115, the constraint hk : k \u2265 1, and the hypothesis h_k : b k = 2^(k+1) - 1. Using \u2115 instead of \u2124 is appropriate since k \u2265 1.", "The conclusion is correctly stated. Both the natural language and Lean formalization express that b_{k+1} = 2^{(k+1)+1} - 1, with identical mathematical meaning despite slightly different notation for exponentiation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Thus $b_n=2^{n+1}-1$ for all $n \\geq 1$.", "statement": "We assume:\n\u2022 The formula $b_n=2^{n+1}-1$ holds for $n=1$ [l2].\n\u2022 For any integer $k \\geq 1$, if $b_k=2^{k+1}-1$, then $b_{k+1}=2^{(k+1)+1}-1$ holds [l3].\nTherefore, we conclude:\n\u2022 For all $n \\geq 1$, $b_n=2^{n+1}-1$ [l4].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (b : \u2115 \u2192 \u211d)\n  (l2 : b 1 = 2^(1+1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 1 \u2192 b k = 2^(k+1) - 1 \u2192 b (k + 1) = 2^((k+1)+1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n+1) - 1 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (b : \u2115 \u2192 \u211d)\n  (l2 : b 1 = 2^(1+1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 1 \u2192 b k = 2^(k+1) - 1 \u2192 b (k + 1) = 2^((k+1)+1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n+1) - 1 := by\n  have h_shifted : \u2200 m : \u2115, b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := by\n    intro m\n    induction m with\n    | zero =>\n      -- Base case: m = 0\n      norm_num [l2] at *\n      <;> simp_all [pow_succ]\n      <;> norm_num\n      <;> linarith\n    | succ m ih =>\n      -- Inductive step: assume the statement holds for m, prove for m + 1\n      have h1 : (m + 1 : \u2115) + 1 \u2265 1 := by\n        -- Prove that (m + 1) + 1 \u2265 1\n        norm_num\n        <;> linarith\n      have h2 : b ((m + 1 : \u2115) + 1) = (2 : \u211d)^(((m + 1 : \u2115) + 1) + 1) - 1 := by\n        -- Use the given property l3 to prove the statement for (m + 1) + 1\n        have h3 : b (m + 1 + 1) = (2 : \u211d)^((m + 1 + 1) + 1) - 1 := by\n          have h4 : (m + 1 : \u2115) \u2265 1 := by\n            -- Prove that m + 1 \u2265 1\n            norm_num\n            <;> linarith\n          have h5 : b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := ih\n          have h6 : b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := by simpa using h5\n          have h7 : b (m + 1 + 1) = (2 : \u211d)^((m + 1 + 1) + 1) - 1 := by\n            have h8 : b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := h6\n            have h9 : b (m + 1 + 1) = (2 : \u211d)^((m + 1 + 1) + 1) - 1 := by\n              -- Use the given property l3\n              have h10 : (m + 1 : \u2115) \u2265 1 := h4\n              have h11 : b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := h8\n              have h12 : b (m + 1 + 1) = (2 : \u211d)^((m + 1 + 1) + 1) - 1 := by\n                -- Convert the problem to match l3\n                have h13 : b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := h8\n                have h14 : (m + 1 : \u2115) \u2265 1 := h4\n                have h15 : b (m + 1) = (2 : \u211d)^((m + 1) + 1) - 1 := h8\n                -- Use l3 to get the next term\n                have h16 : b (m + 1 + 1) = (2 : \u211d)^((m + 1 + 1) + 1) - 1 := by\n                  have h17 := l3 (m + 1) (by\n                    -- Prove that m + 1 \u2265 1\n                    norm_num at h4 \u22a2\n                    <;> linarith\n                  ) (by\n                    -- Prove that b (m + 1) = 2 ^ ((m + 1) + 1) - 1\n                    norm_num [pow_add, pow_one, pow_succ] at h8 \u22a2\n                    <;>\n                    (try norm_num at h8 \u22a2) <;>\n                    (try simp_all [pow_add, pow_one, pow_succ]) <;>\n                    (try ring_nf at h8 \u22a2) <;>\n                    (try norm_num at h8 \u22a2) <;>\n                    (try linarith)\n                    <;>\n                    (try\n                      {\n                        simp_all [pow_add, pow_one, pow_succ]\n                        <;>\n                        ring_nf at *\n                        <;>\n                        norm_num at *\n                        <;>\n                        linarith\n                      })\n                  )\n                  -- Simplify the result from l3\n                  norm_num [pow_add, pow_one, pow_succ] at h17 \u22a2\n                  <;>\n                  (try norm_num at h17 \u22a2) <;>\n                  (try simp_all [pow_add, pow_one, pow_succ]) <;>\n                  (try ring_nf at h17 \u22a2) <;>\n                  (try norm_num at h17 \u22a2) <;>\n                  (try linarith)\n                  <;>\n                  (try\n                    {\n                      simp_all [pow_add, pow_one, pow_succ]\n                      <;>\n                      ring_nf at *\n                      <;>\n                      norm_num at *\n                      <;>\n                      linarith\n                    })\n                exact h16\n              exact h12\n            exact h9\n          exact h7\n        -- Simplify the expression to match the goal\n        norm_num at h3 \u22a2\n        <;>\n        (try norm_num at h3 \u22a2) <;>\n        (try simp_all [pow_add, pow_one, pow_succ]) <;>\n        (try ring_nf at h3 \u22a2) <;>\n        (try norm_num at h3 \u22a2) <;>\n        (try linarith)\n        <;>\n        (try\n          {\n            simp_all [pow_add, pow_one, pow_succ]\n            <;>\n            ring_nf at *\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n      -- Simplify the expression to match the goal\n      norm_num at h2 \u22a2\n      <;>\n      (try norm_num at h2 \u22a2) <;>\n      (try simp_all [pow_add, pow_one, pow_succ]) <;>\n      (try ring_nf at h2 \u22a2) <;>\n      (try norm_num at h2 \u22a2) <;>\n      (try linarith)\n      <;>\n      (try\n        {\n          simp_all [pow_add, pow_one, pow_succ]\n          <;>\n          ring_nf at *\n          <;>\n          norm_num at *\n          <;>\n          linarith\n        })\n  \n  have h_main : \u2200 n : \u2115, n \u2265 1 \u2192 b n = (2 : \u211d)^(n + 1) - 1 := by\n    intro n hn\n    have h\u2081 : \u2203 m : \u2115, n = m + 1 := by\n      use n - 1\n      have h\u2082 : n \u2265 1 := hn\n      have h\u2083 : n - 1 + 1 = n := by\n        have h\u2084 : n \u2265 1 := hn\n        omega\n      omega\n    obtain \u27e8m, rfl\u27e9 := h\u2081\n    have h\u2082 := h_shifted m\n    simp [pow_add, pow_one, mul_comm] at h\u2082 \u22a2\n    <;>\n    (try ring_nf at h\u2082 \u22a2) <;>\n    (try norm_num at h\u2082 \u22a2) <;>\n    (try simp_all [pow_add, pow_one, pow_succ]) <;>\n    (try ring_nf at h\u2082 \u22a2) <;>\n    (try norm_num at h\u2082 \u22a2) <;>\n    (try linarith)\n    <;>\n    (try\n      {\n        simp_all [pow_add, pow_one, pow_succ]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n  \n  intro n hn\n  have h\u2081 : b n = (2 : \u211d)^(n + 1) - 1 := h_main n hn\n  have h\u2082 : (2 : \u211d)^(n + 1) - 1 = (2 : \u211d)^(n + 1) - 1 := rfl\n  -- Simplify the expression to match the goal\n  norm_num at h\u2081 \u22a2\n  <;>\n  (try norm_num at h\u2081 \u22a2) <;>\n  (try simp_all [pow_add, pow_one, pow_succ]) <;>\n  (try ring_nf at h\u2081 \u22a2) <;>\n  (try norm_num at h\u2081 \u22a2) <;>\n  (try linarith)\n  <;>\n  (try\n    {\n      simp_all [pow_add, pow_one, pow_succ]\n      <;>\n      ring_nf at *\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    })\n  <;>\n  (try\n    {\n      simp_all [pow_add, pow_one, pow_succ]\n      <;>\n      ring_nf at *\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Base case l2 correctly captures that the formula holds for n=1", "Inductive step l3 perfectly formalizes the implication structure with proper quantification over k\u22651", "Conclusion l4 accurately states the universal result for all n\u22651", "Function type declaration (b : \u2115 \u2192 \u211d) appropriately formalizes the implicit sequence concept from natural language", "Overall structure correctly represents the mathematical induction argument with base case, inductive step, and conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Substituting our explicit formulas, we need to show that $1 < 2^{n+1}-1$.", "statement": "We assume:\n\u2022 For all $n \\geq 1$, $a_n=1$ [l1].\n\u2022 For all $n \\geq 1$, $b_n=2^{n+1}-1$ [l4].\nTherefore, we conclude:\n\u2022 For all $n \\geq 1$, the inequality $a_n < b_n$ is equivalent to the inequality $1 < 2^{n+1}-1$ [l5].", "dependencies": ["l1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a b : \u2115 \u2192 \u211d)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n+1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a b : \u2115 \u2192 \u211d)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n+1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\n  intro n hn\n  have h_a : a n = 1 := by\n    have h\u2081 : a n = 1 := l1 n hn\n    exact h\u2081\n  \n  have h_b : b n = (2 : \u2115)^(n+1) - 1 := by\n    have h\u2082 : b n = (2 : \u2115)^(n+1) - 1 := by\n      have h\u2083 : b n = 2^(n+1) - 1 := l4 n hn\n      norm_cast at h\u2083 \u22a2\n      <;> simp_all [Nat.cast_pow]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> simp_all [Nat.cast_pow]\n      <;> linarith\n    exact h\u2082\n  \n  have h_pow : (2 : \u2115)^(n+1) \u2265 4 := by\n    have h\u2081 : n \u2265 1 := hn\n    have h\u2082 : n + 1 \u2265 2 := by linarith\n    have h\u2083 : (2 : \u2115)^(n+1) \u2265 2^2 := by\n      apply Nat.pow_le_pow_of_le_right\n      \u00b7 norm_num\n      \u00b7 linarith\n    have h\u2084 : 2^2 = 4 := by norm_num\n    linarith\n  \n  have h_b_ge : (b n : \u211d) \u2265 3 := by\n    have h\u2085 : (b n : \u211d) = ((2 : \u2115)^(n+1) : \u211d) - 1 := by\n      have h\u2085\u2081 : b n = (2 : \u2115)^(n+1) - 1 := h_b\n      have h\u2085\u2082 : (b n : \u211d) = ((2 : \u2115)^(n+1) : \u211d) - 1 := by\n        norm_cast at h\u2085\u2081 \u22a2\n        <;> simp_all [h\u2085\u2081]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> simp_all [Nat.cast_pow]\n        <;> linarith\n      exact h\u2085\u2082\n    have h\u2086 : ((2 : \u2115)^(n+1) : \u211d) \u2265 4 := by\n      norm_cast\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try\n        {\n          have h\u2087 : (2 : \u2115)^(n+1) \u2265 4 := h_pow\n          linarith\n        })\n    have h\u2087 : (b n : \u211d) \u2265 3 := by\n      rw [h\u2085]\n      linarith\n    exact h\u2087\n  \n  have h_main : a n < b n := by\n    have h\u2081 : (a n : \u211d) = 1 := by\n      norm_cast\n      <;> simp [h_a]\n    have h\u2082 : (b n : \u211d) \u2265 3 := h_b_ge\n    have h\u2083 : (a n : \u211d) < (b n : \u211d) := by\n      linarith\n    exact_mod_cast h\u2083\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language conclusion [l5] states that 'the inequality a_n < b_n is equivalent to the inequality 1 < 2^(n+1) - 1', which should be formalized as an equivalence statement. However, the Lean formalization directly proves 'a n < b n' rather than proving the equivalence. The Lean code proves that the inequality holds, but completely misses the equivalence structure that is the main point of the natural language conclusion."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language conclusion [l5] states that 'the inequality a_n < b_n is equivalent to the inequality 1 < 2^(n+1) - 1', which should be formalized as an equivalence statement. However, the Lean formalization directly proves 'a n < b n' rather than proving the equivalence. The Lean code proves that the inequality holds, but completely misses the equivalence structure that is the main point of the natural language conclusion.\"]"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "This is equivalent to showing $2 < 2^{n+1}$, which is $1 < 2^n$.", "statement": "We assume:\n\u2022 The inequality $1 < 2^{n+1}-1$ holds for some integer $n \\geq 1$.\nTherefore, we conclude:\n\u2022 The inequality $1 < 2^{n+1}-1$ is equivalent to the inequality $1 < 2^n$ [l6].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (n : \u2115) (hn : n \u2265 1) :\n  (1 < 2^(n+1) - 1) \u2194 (1 < 2^n) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (n : \u2115) (hn : n \u2265 1) :\n  (1 < 2^(n+1) - 1) \u2194 (1 < 2^n) := by\n  have h_main : (1 < 2^(n+1) - 1) \u2194 (1 < 2^n) := by\n    constructor\n    \u00b7 -- Prove the forward direction: 1 < 2^(n+1) - 1 \u2192 1 < 2^n\n      intro h\n      have h\u2081 : 2^(n+1) - 1 > 1 := by omega\n      have h\u2082 : 2^(n+1) > 2 := by\n        have h\u2083 : 2^(n+1) - 1 > 1 := h\u2081\n        have h\u2084 : 2^(n+1) > 2 := by\n          by_contra h\u2085\n          -- If 2^(n+1) \u2264 2, then 2^(n+1) \u2264 2\n          have h\u2086 : 2^(n+1) \u2264 2 := by linarith\n          have h\u2087 : n + 1 \u2264 1 := by\n            by_contra h\u2088\n            have h\u2089 : n + 1 \u2265 2 := by omega\n            have h\u2081\u2080 : 2^(n+1) \u2265 2^2 := by\n              exact pow_le_pow_right (by norm_num) (by omega)\n            have h\u2081\u2081 : 2^(n+1) \u2265 4 := by\n              norm_num at h\u2081\u2080 \u22a2\n              <;> omega\n            omega\n          have h\u2088 : n = 0 := by omega\n          omega\n        exact h\u2084\n      -- Now we know 2^(n+1) > 2, we can deduce 2^n > 1\n      have h\u2083 : 2^n > 1 := by\n        have h\u2084 : 2^(n+1) = 2 * 2^n := by\n          ring_nf\n          <;> simp [pow_succ]\n          <;> ring\n        have h\u2085 : 2^(n+1) > 2 := h\u2082\n        have h\u2086 : 2 * 2^n > 2 := by\n          linarith\n        have h\u2087 : 2^n > 1 := by\n          by_contra h\u2088\n          have h\u2089 : 2^n \u2264 1 := by linarith\n          have h\u2081\u2080 : 2^n = 0 \u2228 2^n = 1 := by\n            have h\u2081\u2081 : 2^n \u2264 1 := by linarith\n            have h\u2081\u2082 : 2^n \u2265 0 := by positivity\n            omega\n          cases h\u2081\u2080 with\n          | inl h\u2081\u2080 =>\n            have h\u2081\u2081 : 2^n = 0 := h\u2081\u2080\n            have h\u2081\u2082 : n \u2265 1 := hn\n            have h\u2081\u2083 : 2^n \u2265 2^1 := by\n              exact pow_le_pow_right (by norm_num) (by omega)\n            have h\u2081\u2084 : 2^n \u2265 2 := by\n              norm_num at h\u2081\u2083 \u22a2\n              <;> omega\n            omega\n          | inr h\u2081\u2080 =>\n            have h\u2081\u2081 : 2^n = 1 := h\u2081\u2080\n            have h\u2081\u2082 : 2 * 2^n = 2 := by\n              rw [h\u2081\u2081]\n              <;> norm_num\n            omega\n        exact h\u2087\n      -- Since 2^n > 1, we have 1 < 2^n\n      omega\n    \u00b7 -- Prove the backward direction: 1 < 2^n \u2192 1 < 2^(n+1) - 1\n      intro h\n      have h\u2081 : 2^n > 1 := by omega\n      have h\u2082 : 2^(n+1) > 2 := by\n        have h\u2083 : 2^(n+1) = 2 * 2^n := by\n          ring_nf\n          <;> simp [pow_succ]\n          <;> ring\n        have h\u2084 : 2 * 2^n > 2 := by\n          have h\u2085 : 2^n > 1 := h\u2081\n          nlinarith\n        linarith\n      have h\u2083 : 2^(n+1) - 1 > 1 := by\n        have h\u2084 : 2^(n+1) > 2 := h\u2082\n        have h\u2085 : 2^(n+1) - 1 > 1 := by\n          omega\n        exact h\u2085\n      omega\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equivalence stated in the natural language, with proper variable constraints and identical mathematical expressions. However, there is a slight structural difference: the natural language presents this as conditional reasoning ('we assume X, therefore conclude Y \u2194 Z') while the Lean formalization states it as a direct biconditional theorem. The mathematical content and logical meaning are essentially the same, but the presentation structure differs slightly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the mathematical equivalence stated in the natural language, with proper variable constraints and identical mathematical expressions. However, there is a slight structural difference: the natural language presents this as conditional reasoning ('we assume X, therefore conclude Y \u2194 Z') while the Lean formalization states it as a direct biconditional theorem. The mathematical content and logical meaning are essentially the same, but the presentation structure differs slightly.\"]"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "This inequality holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $n$ is an integer such that $n \\geq 1$.\nTherefore, we conclude:\n\u2022 The inequality $1 < 2^n$ holds [l7].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (n : \u2115) (h : n \u2265 1) : 1 < 2^n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (n : \u2115) (h : n \u2265 1) : 1 < 2^n := by\n  have h\u2081 : 1 < (2 : \u2115) := by\n    norm_num\n    <;> decide\n  \n  have h\u2082 : 0 < n := by\n    omega\n  \n  have h\u2083 : 1 < 2 ^ n := by\n    -- Use the lemma `Nat.one_lt_pow` to prove that 1 < 2^n\n    have h\u2084 : 1 < (2 : \u2115) ^ n := by\n      apply Nat.one_lt_pow\n      <;> norm_num at h\u2081 \u22a2 <;>\n        (try omega) <;>\n        (try assumption) <;>\n        (try linarith)\n    exact h\u2084\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical structure and mathematical meaning of the natural language statement. While the natural language mentions 'integer' and Lean uses natural numbers (\u2115), this difference is not semantically significant because the constraint n \u2265 1 ensures we're working with the same effective domain (positive integers). The premise (n \u2265 1) and conclusion (1 < 2^n) are captured exactly as stated."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, the inequality $a_n < b_n$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 For all $n \\geq 1$, the inequality $a_n < b_n$ is equivalent to $1 < 2^{n+1}-1$ [l5].\n\u2022 For all $n \\geq 1$, the inequality $1 < 2^{n+1}-1$ is equivalent to $1 < 2^n$ [l6].\n\u2022 For all $n \\geq 1$, the inequality $1 < 2^n$ holds [l7].\nTherefore, we conclude:\n\u2022 The inequality $a_n < b_n$ holds for all integers $n \\geq 1$ [ts_1].", "dependencies": ["l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b : \u2115 \u2192 \u211d)\n  (ha : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (hb : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n+1) - 1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n+1) - 1))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 < 2^(n+1) - 1 \u2194 1 < 2^n))\n  (l7 : \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b : \u2115 \u2192 \u211d)\n  (ha : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (hb : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n+1) - 1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n+1) - 1))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 < 2^(n+1) - 1 \u2194 1 < 2^n))\n  (l7 : \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\n  intro n hn\n  have h1 : 1 < 2^n := by\n    have h1 : 1 < 2 ^ n := l7 n hn\n    exact h1\n  \n  have h2 : 1 < 2^(n+1) - 1 := by\n    have h2 : (1 < 2 ^ (n + 1) - 1 \u2194 1 < 2 ^ n) := l6 n hn\n    have h3 : 1 < 2 ^ n := h1\n    have h4 : 1 < 2 ^ (n + 1) - 1 := by\n      have h5 : 1 < 2 ^ (n + 1) - 1 \u2194 1 < 2 ^ n := l6 n hn\n      have h6 : 1 < 2 ^ n := h3\n      have h7 : 1 < 2 ^ (n + 1) - 1 := by\n        rw [h5] at *\n        exact h6\n      exact h7\n    exact h4\n  \n  have h3 : a n < b n := by\n    have h4 : (a n < b n \u2194 1 < 2 ^ (n + 1) - 1) := l5 n hn\n    have h5 : 1 < 2 ^ (n + 1) - 1 := h2\n    have h6 : a n < b n := by\n      rw [h4] at *\n      exact h5\n    exact h6\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The variable declarations and explicit definitions of a_n and b_n are additional details not mentioned in natural language but are logically consistent and helpful for formalization.", "The equivalence statement l5 is captured exactly as stated in natural language.", "The equivalence statement l6 is captured exactly as stated in natural language.", "The assumption l7 is captured exactly as stated in natural language.", "The conclusion matches the logical meaning, but there's a minor difference: natural language mentions 'integers n \u2265 1' while Lean uses 'natural numbers n \u2265 1'. Since n \u2265 1, this covers the same effective domain."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    