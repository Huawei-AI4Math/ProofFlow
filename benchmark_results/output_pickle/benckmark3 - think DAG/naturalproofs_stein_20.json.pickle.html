
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: For any integers $a$ and $b$, we have
$$
   \gcd(a,b)= \gcd(b,a) = \gcd(\pm a, \pm b) = \gcd(a,b-a) = \gcd(a,b+a).
$$

Proof: We only prove that $\gcd(a,b) = \gcd(a,b-a)$, since the other cases
are proved in a similar way. Suppose $d\mid a$ and
  $d\mid b$, so there exist integers $c_1$ and $c_2$ such that $dc_1 =
  a$ and $dc_2 = b$.  Then $b - a = dc_2 - dc_1 = d(c_2-c_1)$, so
  $d\mid b-a$.  Thus $\gcd(a,b)\leq \gcd(a,b-a)$, since the set over
  which we are taking the max for $\gcd(a,b)$ is a subset of the set
  for $\gcd(a,b-a)$.  The same argument with $a$ replaced by $-a$
  and $b$ replaced by $b-a$, shows that $\gcd(a,b-a)=\gcd(-a,b-a)\leq
  \gcd(-a,b)=\gcd(a,b)$, which proves that $\gcd(a,b)=\gcd(a,b-a)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "For any integers $a$ and $b$", "statement": "Premise:\n\u2022 a and b are integers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u2124)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a b : \u2124)' perfectly captures that a and b are integers, where \u2124 represents the integer type", "Both the natural language and Lean code contain no conclusions - the natural language explicitly states no conclusions are derived, and the Lean code contains only variable declarations with no propositions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Suppose $d\\mid a$ and $d\\mid b$, so there exist integers $c_1$ and $c_2$ such that $dc_1 = a$ and $dc_2 = b$. Then $b - a = dc_2 - dc_1 = d(c_2-c_1)$, so $d\\mid b-a$.", "statement": "We assume:\n\u2022 a, b, and d are integers [tc_1]\n\u2022 d divides a [l1_assump1]\n\u2022 d divides b [l1_assump2]\nTherefore, we conclude:\n\u2022 d divides (b - a) [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b d : \u2124) \n  (h1 : d \u2223 a) \n  (h2 : d \u2223 b) : \n  d \u2223 (b - a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b d : \u2124) \n  (h1 : d \u2223 a) \n  (h2 : d \u2223 b) : \n  d \u2223 (b - a) := by\n  have h_main : d \u2223 (b - a) := by\n    -- Use the property that if a number divides two integers, it divides their difference.\n    have h3 : d \u2223 (b - a) := Int.dvd_sub h2 h1\n    exact h3\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures all components of the natural language statement. All three variables are correctly declared as integers, both divisibility assumptions are properly formalized using the standard divisibility notation, and the conclusion about d dividing (b-a) is exactly represented. The theorem structure appropriately reflects the logical flow from assumptions to conclusion. The mathematical content is completely preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Thus $\\gcd(a,b)\\leq \\gcd(a,b-a)$, since the set over which we are taking the max for $\\gcd(a,b)$ is a subset of the set for $\\gcd(a,b-a)$.", "statement": "We assume:\n\u2022 a and b are integers [tc_1]\n\u2022 For any integer d, if d divides a and d divides b, then d also divides (b-a) [l1]\nTherefore, we conclude:\n\u2022 gcd(a, b) \u2264 gcd(a, b-a) [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b : \u2124)\n  (l1 : \u2200 d : \u2124, d \u2223 a \u2192 d \u2223 b \u2192 d \u2223 (b - a)) :\n  Int.gcd a b \u2264 Int.gcd a (b - a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b : \u2124)\n  (l1 : \u2200 d : \u2124, d \u2223 a \u2192 d \u2223 b \u2192 d \u2223 (b - a)) :\n  Int.gcd a b \u2264 Int.gcd a (b - a) := by\n  have h_main : (Int.gcd a b : \u2115) \u2264 Int.gcd a (b - a) := by\n    have h\u2081 : (Int.gcd a b : \u2115) \u2223 a.natAbs := by\n      exact Int.gcd_dvd_left a b\n    have h\u2082 : (Int.gcd a b : \u2115) \u2223 b.natAbs := by\n      exact Int.gcd_dvd_right a b\n    have h\u2083 : (Int.gcd a b : \u2124) \u2223 a := by\n      exact Int.gcd_dvd_left a b\n    have h\u2084 : (Int.gcd a b : \u2124) \u2223 b := by\n      exact Int.gcd_dvd_right a b\n    have h\u2085 : (Int.gcd a b : \u2124) \u2223 (b - a) := by\n      -- Use the given condition l1 to show that (Int.gcd a b : \u2124) divides (b - a)\n      have h\u2085\u2081 : (Int.gcd a b : \u2124) \u2223 a := by exact Int.gcd_dvd_left a b\n      have h\u2085\u2082 : (Int.gcd a b : \u2124) \u2223 b := by exact Int.gcd_dvd_right a b\n      exact l1 (Int.gcd a b) h\u2085\u2081 h\u2085\u2082\n    have h\u2086 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := by\n      -- Since (Int.gcd a b : \u2124) divides (b - a), its absolute value divides the absolute value of (b - a)\n      have h\u2086\u2081 : (Int.gcd a b : \u2124) \u2223 (b - a) := h\u2085\n      have h\u2086\u2082 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := by\n        exact Int.natCast_dvd_natCast.mp (by\n          simpa [Int.natAbs_dvd_natAbs] using h\u2086\u2081)\n      exact h\u2086\u2082\n    -- Now we know that (Int.gcd a b : \u2115) divides both a.natAbs and (b - a).natAbs\n    -- So it is a common divisor, and thus less than or equal to the gcd of a.natAbs and (b - a).natAbs\n    have h\u2087 : (Int.gcd a b : \u2115) \u2223 Int.gcd a (b - a) := by\n      -- Use the fact that (Int.gcd a b : \u2115) divides both a.natAbs and (b - a).natAbs\n      -- to show that it divides their gcd\n      have h\u2087\u2081 : (Int.gcd a b : \u2115) \u2223 a.natAbs := h\u2081\n      have h\u2087\u2082 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := h\u2086\n      have h\u2087\u2083 : (Int.gcd a b : \u2115) \u2223 Int.gcd a (b - a) := by\n        -- Use the property of gcd that if a number divides both, it divides their gcd\n        have h\u2087\u2084 : (Int.gcd a (b - a) : \u2115) = Nat.gcd a.natAbs (b - a).natAbs := by\n          simp [Int.gcd]\n        rw [h\u2087\u2084]\n        -- Now we need to show that (Int.gcd a b : \u2115) divides Nat.gcd a.natAbs (b - a).natAbs\n        -- This follows from h\u2087\u2081 and h\u2087\u2082 because Nat.gcd a.natAbs (b - a).natAbs is the greatest common divisor\n        exact Nat.dvd_gcd h\u2087\u2081 h\u2087\u2082\n      exact h\u2087\u2083\n    -- Finally, since (Int.gcd a b : \u2115) divides Int.gcd a (b - a), and both are natural numbers,\n    -- we have (Int.gcd a b : \u2115) \u2264 Int.gcd a (b - a)\n    have h\u2088 : (Int.gcd a b : \u2115) \u2264 Int.gcd a (b - a) := by\n      -- Use the fact that if a natural number divides another, it is less than or equal to it\n      have h\u2088\u2081 : (Int.gcd a b : \u2115) \u2223 Int.gcd a (b - a) := h\u2087\n      exact Nat.le_of_dvd (Int.gcd_pos_of_ne_zero_left _ (by\n        by_contra h\n        have h\u2088\u2082 : a = 0 := by\n          simp_all [Int.gcd_eq_zero_iff]\n        have h\u2088\u2083 : (Int.gcd a b : \u2115) = b.natAbs := by\n          simp [h\u2088\u2082, Int.gcd]\n          <;>\n          cases' b with b <;> simp_all [Int.natAbs_ofNat, Int.natAbs_neg]\n          <;>\n          norm_num\n          <;>\n          aesop\n        have h\u2088\u2084 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := h\u2086\n        simp [h\u2088\u2082, h\u2088\u2083] at h\u2088\u2084\n        <;>\n        cases' b with b <;> simp_all [Int.natAbs_ofNat, Int.natAbs_neg, Int.sub_emod]\n        <;>\n        norm_num at h\u2088\u2084 \u22a2 <;>\n        omega\n      )) h\u2088\u2081\n    exact h\u2088\n  \n  -- The main goal is to show that Int.gcd a b \u2264 Int.gcd a (b - a)\n  -- Since h_main already gives us this as a statement about natural numbers,\n  -- we can directly use it to conclude the proof.\n  exact_mod_cast h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 12, "endLine": 10, "endColumn": 32, "data": "function expected at\n  Int.gcd_dvd_left\nterm has type\n  \u2191(Int.gcd ?m.163 ?m.164) \u2223 ?m.163"}, {"line": 12, "column": 12, "endLine": 12, "endColumn": 33, "data": "function expected at\n  Int.gcd_dvd_right\nterm has type\n  \u2191(Int.gcd ?m.214 ?m.215) \u2223 ?m.215"}, {"line": 14, "column": 12, "endLine": 14, "endColumn": 32, "data": "function expected at\n  Int.gcd_dvd_left\nterm has type\n  \u2191(Int.gcd ?m.301 ?m.302) \u2223 ?m.301"}, {"line": 16, "column": 12, "endLine": 16, "endColumn": 33, "data": "function expected at\n  Int.gcd_dvd_right\nterm has type\n  \u2191(Int.gcd ?m.351 ?m.352) \u2223 ?m.352"}, {"line": 19, "column": 51, "endLine": 19, "endColumn": 71, "data": "function expected at\n  Int.gcd_dvd_left\nterm has type\n  \u2191(Int.gcd ?m.435 ?m.436) \u2223 ?m.435"}, {"line": 20, "column": 51, "endLine": 20, "endColumn": 72, "data": "function expected at\n  Int.gcd_dvd_right\nterm has type\n  \u2191(Int.gcd ?m.485 ?m.486) \u2223 ?m.486"}, {"line": 67, "column": 20, "endLine": 67, "endColumn": 23, "data": "unknown identifier 'h\u2088\u2084'"}, {"line": 67, "column": 20, "endLine": 67, "endColumn": 23, "data": "unknown identifier 'h\u2088\u2084'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly translate 'a and b are integers' to (a b : \u2124)", "The conditional premise is accurately formalized using universal quantification and logical implication with divisibility notation", "The conclusion correctly expresses the gcd inequality using appropriate Lean syntax", "The overall logical structure properly translates the assumption-conclusion format into theorem format with hypotheses and goal", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem gcd_sub_le (a b : \u2124) : Int.gcd a b \u2264 Int.gcd a (b - a) := by\n  have h\u2081 : (Int.gcd a b : \u2115) \u2223 a.natAbs := by\n    have h\u2081\u2081 : (Int.gcd a b : \u2115) = Int.natAbs (Int.gcd a b) := by\n      simp [Int.natAbs_ofNat]\n    rw [h\u2081\u2081]\n    -- Use the property that the gcd divides both numbers\n    have h\u2081\u2082 : (Int.gcd a b : \u2124) \u2223 a := Int.gcd_dvd_left a b\n    -- Convert the divisibility in \u2124 to \u2115\n    have h\u2081\u2083 : Int.natAbs (Int.gcd a b) \u2223 a.natAbs := by\n      exact Int.natAbs_dvd_natAbs.mpr h\u2081\u2082\n    exact h\u2081\u2083\n  \n  have h\u2082 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := by\n    have h\u2082\u2081 : (Int.gcd a b : \u2124) \u2223 (b - a : \u2124) := by\n      have h\u2082\u2082 : (Int.gcd a b : \u2124) \u2223 a := Int.gcd_dvd_left a b\n      have h\u2082\u2083 : (Int.gcd a b : \u2124) \u2223 b := Int.gcd_dvd_right a b\n      -- Since gcd(a, b) divides both a and b, it divides any linear combination of a and b.\n      have h\u2082\u2084 : (Int.gcd a b : \u2124) \u2223 (b - a : \u2124) := by\n        -- Use the fact that if a number divides two numbers, it divides their difference.\n        have h\u2082\u2085 : (Int.gcd a b : \u2124) \u2223 (b : \u2124) - a := by\n          exact dvd_sub h\u2082\u2083 h\u2082\u2082\n        simpa using h\u2082\u2085\n      exact h\u2082\u2084\n    -- Convert the divisibility in \u2124 to \u2115\n    have h\u2082\u2082 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := by\n      have h\u2082\u2083 : (Int.gcd a b : \u2115) = Int.natAbs (Int.gcd a b : \u2124) := by\n        simp [Int.natAbs_ofNat]\n      rw [h\u2082\u2083]\n      -- Use the property that if k divides m in \u2124, then |k| divides |m| in \u2115\n      have h\u2082\u2084 : Int.natAbs (Int.gcd a b : \u2124) \u2223 (b - a).natAbs := by\n        exact Int.natAbs_dvd_natAbs.mpr h\u2082\u2081\n      exact h\u2082\u2084\n    exact h\u2082\u2082\n  \n  have h\u2083 : (Int.gcd a b : \u2115) \u2223 Int.gcd a (b - a) := by\n    have h\u2083\u2081 : (Int.gcd a b : \u2115) \u2223 a.natAbs := h\u2081\n    have h\u2083\u2082 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := h\u2082\n    have h\u2083\u2083 : (Int.gcd a b : \u2115) \u2223 Int.gcd a (b - a) := by\n      -- Use the fact that the GCD of a and (b - a) is the same as the GCD of their absolute values\n      have h\u2083\u2084 : (Int.gcd a (b - a) : \u2115) = Nat.gcd a.natAbs (b - a).natAbs := by\n        simp [Int.gcd, Int.natAbs]\n        <;>\n        rfl\n      rw [h\u2083\u2084]\n      -- Since (Int.gcd a b : \u2115) divides both a.natAbs and (b - a).natAbs, it divides their GCD\n      exact Nat.dvd_gcd h\u2083\u2081 h\u2083\u2082\n    exact h\u2083\u2083\n  \n  have h\u2084 : Int.gcd a b \u2264 Int.gcd a (b - a) := by\n    have h\u2084\u2081 : (Int.gcd a b : \u2115) \u2223 (Int.gcd a (b - a) : \u2115) := by\n      simpa [Int.gcd] using h\u2083\n    have h\u2084\u2082 : (Int.gcd a b : \u2115) \u2264 (Int.gcd a (b - a) : \u2115) := by\n      -- Use the fact that if a number divides another, it is less than or equal to it.\n      have h\u2084\u2083 : (Int.gcd a (b - a) : \u2115) \u2260 0 \u2192 (Int.gcd a b : \u2115) \u2264 (Int.gcd a (b - a) : \u2115) := by\n        intro h\u2084\u2084\n        -- If the GCD is not zero, we can directly use the divisibility to get the inequality.\n        have h\u2084\u2085 : (Int.gcd a b : \u2115) \u2223 (Int.gcd a (b - a) : \u2115) := h\u2084\u2081\n        exact Nat.le_of_dvd (by\n          -- Show that the GCD is positive.\n          have h\u2084\u2086 : 0 < (Int.gcd a (b - a) : \u2115) := Nat.pos_of_ne_zero h\u2084\u2084\n          linarith\n          ) h\u2084\u2085\n      by_cases h\u2084\u2084 : (Int.gcd a (b - a) : \u2115) = 0\n      \u00b7 -- If the GCD is zero, both a and (b - a) must be zero.\n        have h\u2084\u2085 : a = 0 := by\n          by_contra h\u2084\u2085\n          have h\u2084\u2086 : (Int.gcd a (b - a) : \u2115) \u2260 0 := by\n            have h\u2084\u2087 : (Int.gcd a (b - a) : \u2115) > 0 := by\n              have h\u2084\u2088 : (Int.gcd a (b - a) : \u2115) = Int.natAbs (Int.gcd a (b - a)) := by simp [Int.natAbs_ofNat]\n              have h\u2084\u2089 : (Int.gcd a (b - a) : \u2124) \u2260 0 := by\n                intro h\u2084\u2089\n                have h\u2085\u2080 : (Int.gcd a (b - a) : \u2124) = 0 := h\u2084\u2089\n                have h\u2085\u2081 : a = 0 := by\n                  have h\u2085\u2082 : (Int.gcd a (b - a) : \u2124) \u2223 a := Int.gcd_dvd_left a (b - a)\n                  have h\u2085\u2083 : (Int.gcd a (b - a) : \u2124) = 0 := h\u2085\u2080\n                  have h\u2085\u2084 : (0 : \u2124) \u2223 a := by simpa [h\u2085\u2083] using h\u2085\u2082\n                  have h\u2085\u2085 : a = 0 := by simpa using h\u2085\u2084\n                  exact h\u2085\u2085\n                contradiction\n              have h\u2085\u2080 : (Int.natAbs (Int.gcd a (b - a)) : \u2115) > 0 := by\n                have h\u2085\u2081 : (Int.gcd a (b - a) : \u2124) \u2260 0 := h\u2084\u2089\n                have h\u2085\u2082 : Int.natAbs (Int.gcd a (b - a)) > 0 := by\n                  apply Int.natAbs_pos.mpr\n                  exact by\n                    contrapose! h\u2085\u2081\n                    simp_all [Int.gcd_eq_zero_iff]\n                    <;>\n                    aesop\n                exact h\u2085\u2082\n              simp_all [Int.natAbs_ofNat]\n              <;>\n              omega\n            omega\n          contradiction\n        have h\u2084\u2086 : (b - a : \u2124) = 0 := by\n          by_contra h\u2084\u2086\n          have h\u2084\u2087 : (Int.gcd a (b - a) : \u2115) \u2260 0 := by\n            have h\u2084\u2088 : (Int.gcd a (b - a) : \u2115) > 0 := by\n              have h\u2084\u2089 : (Int.gcd a (b - a) : \u2115) = Int.natAbs (Int.gcd a (b - a)) := by simp [Int.natAbs_ofNat]\n              have h\u2085\u2080 : (Int.gcd a (b - a) : \u2124) \u2260 0 := by\n                intro h\u2085\u2080\n                have h\u2085\u2081 : (Int.gcd a (b - a) : \u2124) = 0 := h\u2085\u2080\n                have h\u2085\u2082 : (b - a : \u2124) = 0 := by\n                  have h\u2085\u2083 : (Int.gcd a (b - a) : \u2124) \u2223 (b - a : \u2124) := Int.gcd_dvd_right a (b - a)\n                  have h\u2085\u2084 : (Int.gcd a (b - a) : \u2124) = 0 := h\u2085\u2081\n                  have h\u2085\u2085 : (0 : \u2124) \u2223 (b - a : \u2124) := by simpa [h\u2085\u2084] using h\u2085\u2083\n                  have h\u2085\u2086 : (b - a : \u2124) = 0 := by simpa using h\u2085\u2085\n                  exact h\u2085\u2086\n                contradiction\n              have h\u2085\u2081 : (Int.natAbs (Int.gcd a (b - a)) : \u2115) > 0 := by\n                have h\u2085\u2082 : (Int.gcd a (b - a) : \u2124) \u2260 0 := h\u2085\u2080\n                have h\u2085\u2083 : Int.natAbs (Int.gcd a (b - a)) > 0 := by\n                  apply Int.natAbs_pos.mpr\n                  exact by\n                    contrapose! h\u2085\u2082\n                    simp_all [Int.gcd_eq_zero_iff]\n                    <;>\n                    aesop\n                exact h\u2085\u2083\n              simp_all [Int.natAbs_ofNat]\n              <;>\n              omega\n            omega\n          contradiction\n        have h\u2084\u2087 : (Int.gcd a b : \u2115) = 0 := by\n          have h\u2084\u2088 : a = 0 := h\u2084\u2085\n          have h\u2084\u2089 : (b - a : \u2124) = 0 := h\u2084\u2086\n          have h\u2085\u2080 : b = 0 := by\n            have h\u2085\u2081 : (b - a : \u2124) = 0 := h\u2084\u2086\n            have h\u2085\u2082 : a = 0 := h\u2084\u2085\n            have h\u2085\u2083 : (b : \u2124) - a = 0 := by simpa using h\u2085\u2081\n            have h\u2085\u2084 : (b : \u2124) = a := by linarith\n            have h\u2085\u2085 : (b : \u2124) = 0 := by simp [h\u2085\u2082] at h\u2085\u2084 \u22a2 <;> linarith\n            exact_mod_cast h\u2085\u2085\n          have h\u2085\u2081 : (Int.gcd a b : \u2115) = 0 := by\n            simp [h\u2084\u2088, h\u2085\u2080, Int.gcd]\n            <;>\n            rfl\n          exact h\u2085\u2081\n        simp_all\n      \u00b7 -- If the GCD is not zero, we can directly use the divisibility to get the inequality.\n        exact h\u2084\u2083 h\u2084\u2084\n    -- Convert the inequality back to the original type\n    have h\u2084\u2083 : Int.gcd a b \u2264 Int.gcd a (b - a) := by\n      exact_mod_cast h\u2084\u2082\n    exact h\u2084\u2083\n  \n  exact h\u2084"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "$\\gcd(\\pm a, \\pm b)$", "statement": "We assume:\n\u2022 (This is a known property of greatest common divisors.)\nTherefore, we conclude:\n\u2022 For any integers x and y, gcd(x, y) = gcd(-x, y) and gcd(x, y) = gcd(x, -y) [l3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : \u2200 (x y : \u2124), Int.gcd x y = Int.gcd (-x) y \u2227 Int.gcd x y = Int.gcd x (-y) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : \u2200 (x y : \u2124), Int.gcd x y = Int.gcd (-x) y \u2227 Int.gcd x y = Int.gcd x (-y) := by\n  have h_main : \u2200 (x y : \u2124), Int.gcd x y = Int.gcd (-x) y \u2227 Int.gcd x y = Int.gcd x (-y) := by\n    intro x y\n    constructor\n    \u00b7 -- Prove that Int.gcd x y = Int.gcd (-x) y\n      have h\u2081 : Int.gcd (-x) y = Int.gcd x y := by\n        -- Use the property that (-x).natAbs = x.natAbs\n        rw [Int.gcd]\n        rw [Int.gcd]\n        -- Simplify the expression using the absolute value property\n        simp [Int.natAbs_neg, Nat.gcd_comm]\n      -- Use the symmetry of equality to get the desired result\n      linarith\n    \u00b7 -- Prove that Int.gcd x y = Int.gcd x (-y)\n      have h\u2082 : Int.gcd x (-y) = Int.gcd x y := by\n        -- Use the property that (-y).natAbs = y.natAbs\n        rw [Int.gcd]\n        rw [Int.gcd]\n        -- Simplify the expression using the absolute value property\n        simp [Int.natAbs_neg, Nat.gcd_comm]\n      -- Use the symmetry of equality to get the desired result\n      linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. It correctly expresses that for any integers x and y, both gcd(x,y) = gcd(-x,y) and gcd(x,y) = gcd(x,-y) hold simultaneously. The universal quantification, the specific equalities, and the logical conjunction all align precisely with the natural language meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "The same argument with $a$ replaced by $-a$ and $b$ replaced by $b-a$, shows that $\\gcd(a,b-a)=\\gcd(-a,b-a)\\leq \\gcd(-a,b)=\\gcd(a,b)$", "statement": "We assume:\n\u2022 a and b are integers [tc_1]\n\u2022 For any integers x and y, gcd(x, y) = gcd(-x, y) [l3]\nTherefore, we conclude:\n\u2022 gcd(a, b-a) \u2264 gcd(a, b) [l4].", "dependencies": ["tc_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a b : \u2124) (l3 : \u2200 (x y : \u2124), Int.gcd x y = Int.gcd (-x) y) :\n  Int.gcd a (b - a) \u2264 Int.gcd a b := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a b : \u2124) (l3 : \u2200 (x y : \u2124), Int.gcd x y = Int.gcd (-x) y) :\n  Int.gcd a (b - a) \u2264 Int.gcd a b := by\n  have h\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := by\n    have h\u2081\u2081 : (Int.gcd a (b - a) : \u2124) \u2223 a := by\n      apply Int.gcd_dvd_left\n    have h\u2081\u2082 : (Int.gcd a (b - a) : \u2124) \u2223 a := h\u2081\u2081\n    have h\u2081\u2083 : (Int.gcd a (b - a)).natAbs \u2223 a.natAbs := by\n      -- Use the property that if an integer divides another, their natural absolute values also divide\n      exact Int.natAbs_dvd_natAbs.mpr h\u2081\u2082\n    -- Since the gcd is non-negative, its natural absolute value is itself\n    have h\u2081\u2084 : (Int.gcd a (b - a)).natAbs = (Int.gcd a (b - a) : \u2115) := by\n      simp [Int.natAbs_of_nonneg (by\n        -- Prove that the gcd is non-negative\n        have h\u2081\u2084\u2081 : (0 : \u2124) \u2264 Int.gcd a (b - a) := by\n          apply Int.ofNat_zero_le\n        linarith)]\n    -- Substitute the natural absolute value with the gcd itself\n    rw [h\u2081\u2084] at h\u2081\u2083\n    exact h\u2081\u2083\n  \n  have h\u2082 : (Int.gcd a (b - a) : \u2115) \u2223 b.natAbs := by\n    have h\u2082\u2081 : (Int.gcd a (b - a) : \u2124) \u2223 (b - a) := by\n      apply Int.gcd_dvd_right\n    have h\u2082\u2082 : (Int.gcd a (b - a) : \u2124) \u2223 a := by\n      apply Int.gcd_dvd_left\n    have h\u2082\u2083 : (Int.gcd a (b - a) : \u2124) \u2223 b := by\n      -- Since (Int.gcd a (b - a) : \u2124) divides both a and (b - a), it divides their sum, which is b.\n      have h\u2082\u2084 : (Int.gcd a (b - a) : \u2124) \u2223 (a + (b - a)) := by\n        -- Use the fact that if a number divides two numbers, it divides their sum.\n        exact dvd_add h\u2082\u2082 h\u2082\u2081\n      -- Simplify the sum to get b.\n      have h\u2082\u2085 : (a + (b - a) : \u2124) = b := by ring\n      rw [h\u2082\u2085] at h\u2082\u2084\n      exact h\u2082\u2084\n    -- Use the fact that if an integer divides another, their natural absolute values also divide.\n    have h\u2082\u2086 : (Int.gcd a (b - a)).natAbs \u2223 b.natAbs := by\n      exact Int.natAbs_dvd_natAbs.mpr h\u2082\u2083\n    -- Since the gcd is non-negative, its natural absolute value is itself.\n    have h\u2082\u2087 : (Int.gcd a (b - a)).natAbs = (Int.gcd a (b - a) : \u2115) := by\n      simp [Int.natAbs_of_nonneg (by\n        -- Prove that the gcd is non-negative.\n        have h\u2082\u2087\u2081 : (0 : \u2124) \u2264 Int.gcd a (b - a) := by\n          apply Int.ofNat_zero_le\n        linarith)]\n    -- Substitute the natural absolute value with the gcd itself.\n    rw [h\u2082\u2087] at h\u2082\u2086\n    exact h\u2082\u2086\n  \n  have h\u2083 : (Int.gcd a (b - a) : \u2115) \u2223 Nat.gcd a.natAbs b.natAbs := by\n    have h\u2083\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := h\u2081\n    have h\u2083\u2082 : (Int.gcd a (b - a) : \u2115) \u2223 b.natAbs := h\u2082\n    -- Use the property that if a number divides two numbers, it divides their gcd.\n    exact Nat.dvd_gcd h\u2083\u2081 h\u2083\u2082\n  \n  have h\u2084 : Nat.gcd a.natAbs b.natAbs = (Int.gcd a b : \u2115) := by\n    have h\u2084\u2081 : (Int.gcd a b : \u2115) = Nat.gcd a.natAbs b.natAbs := by\n      rfl\n    rw [h\u2084\u2081]\n    <;> simp_all [Int.gcd]\n    <;> norm_cast\n    <;> rfl\n  \n  have h\u2085 : (Int.gcd a (b - a) : \u2115) \u2223 (Int.gcd a b : \u2115) := by\n    have h\u2085\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 Nat.gcd a.natAbs b.natAbs := h\u2083\n    have h\u2085\u2082 : Nat.gcd a.natAbs b.natAbs = (Int.gcd a b : \u2115) := h\u2084\n    rw [h\u2085\u2082] at h\u2085\u2081\n    exact h\u2085\u2081\n  \n  have h\u2086 : Int.gcd a (b - a) \u2264 Int.gcd a b := by\n    have h\u2086\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 (Int.gcd a b : \u2115) := h\u2085\n    have h\u2086\u2082 : (Int.gcd a (b - a) : \u2115) \u2264 (Int.gcd a b : \u2115) := by\n      -- Use the fact that if a natural number divides another, it is less than or equal to it.\n      exact Nat.le_of_dvd (by\n        -- Prove that the gcd of a and b is positive.\n        have h\u2086\u2083 : 0 < (Int.gcd a b : \u2115) := by\n          -- Use the fact that the gcd is always positive unless both a and b are zero.\n          have h\u2086\u2084 : 0 < (Int.gcd a b : \u2115) := by\n            by_contra h\n            have h\u2086\u2085 : (Int.gcd a b : \u2115) = 0 := by\n              omega\n            have h\u2086\u2086 : (Int.gcd a b : \u2124) = 0 := by\n              norm_cast at h\u2086\u2085 \u22a2\n              <;> simp_all\n            have h\u2086\u2087 : a = 0 := by\n              have h\u2086\u2088 : (Int.gcd a b : \u2124) \u2223 a := Int.gcd_dvd_left a b\n              have h\u2086\u2089 : (Int.gcd a b : \u2124) = 0 := by simpa using h\u2086\u2086\n              rw [h\u2086\u2089] at h\u2086\u2088\n              simp at h\u2086\u2088\n              <;> omega\n            have h\u2086\u2088 : b = 0 := by\n              have h\u2086\u2089 : (Int.gcd a b : \u2124) \u2223 b := Int.gcd_dvd_right a b\n              have h\u2086\u2081\u2080 : (Int.gcd a b : \u2124) = 0 := by simpa using h\u2086\u2086\n              rw [h\u2086\u2081\u2080] at h\u2086\u2089\n              simp at h\u2086\u2089\n              <;> omega\n            simp_all [Int.gcd_eq_zero_iff]\n            <;> norm_num\n            <;> aesop\n          exact h\u2086\u2084\n        -- Use the fact that the gcd is positive to conclude the proof.\n        exact by positivity) h\u2086\u2081\n    -- Convert the inequality back to integers.\n    norm_cast at h\u2086\u2082 \u22a2\n    <;> simp_all [Int.gcd]\n    <;> norm_num\n    <;> aesop\n  \n  exact h\u2086", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 15, "endLine": 10, "endColumn": 41, "data": "invalid field 'natAbs', the environment does not contain 'Nat.natAbs'\n  a.gcd (b - a)\nhas type\n  \u2115"}, {"line": 14, "column": 15, "endLine": 14, "endColumn": 41, "data": "invalid field 'natAbs', the environment does not contain 'Nat.natAbs'\n  a.gcd (b - a)\nhas type\n  \u2115"}, {"line": 15, "column": 6, "endLine": 19, "endColumn": 18, "data": "simp made no progress"}, {"line": 39, "column": 15, "endLine": 39, "endColumn": 41, "data": "invalid field 'natAbs', the environment does not contain 'Nat.natAbs'\n  a.gcd (b - a)\nhas type\n  \u2115"}, {"line": 42, "column": 15, "endLine": 42, "endColumn": 41, "data": "invalid field 'natAbs', the environment does not contain 'Nat.natAbs'\n  a.gcd (b - a)\nhas type\n  \u2115"}, {"line": 43, "column": 6, "endLine": 47, "endColumn": 18, "data": "simp made no progress"}, {"line": 88, "column": 50, "endLine": 88, "endColumn": 70, "data": "function expected at\n  Int.gcd_dvd_left\nterm has type\n  \u2191(Int.gcd ?m.5548 ?m.5549) \u2223 ?m.5548"}, {"line": 94, "column": 50, "endLine": 94, "endColumn": 71, "data": "function expected at\n  Int.gcd_dvd_right\nterm has type\n  \u2191(Int.gcd ?m.7624 ?m.7625) \u2223 ?m.7625"}, {"line": 80, "column": 46, "endLine": 101, "endColumn": 21, "data": "unsolved goals\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly capture that a and b are integers", "The lemma l3 is correctly formalized as a universal quantification over integers with the proper gcd equality", "The conclusion l4 correctly represents the inequality between gcd(a, b-a) and gcd(a, b)", "The logical structure properly represents the assumption-conclusion relationship from natural language", "All mathematical operations (subtraction, gcd, inequality) are correctly formalized", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a b : \u2124) (l3 : \u2200 (x y : \u2124), Int.gcd x y = Int.gcd (-x) y) :\n  Int.gcd a (b - a) \u2264 Int.gcd a b := by\n  have h_main : Int.gcd a (b - a) = Int.gcd a b := by\n    have h\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := by\n      have h\u2081\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := by\n        have h\u2081\u2082 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := by\n          -- Prove that gcd(a, b - a) divides a.natAbs\n          have h\u2081\u2083 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := by\n            -- Use the property that gcd(a, b) divides a\n            have h\u2081\u2084 : (Int.gcd a (b - a) : \u2124) \u2223 a := by\n              -- gcd(a, b - a) divides a\n              apply Int.gcd_dvd_left\n            -- Convert the divisibility to natural numbers\n            exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_dvd_natAbs] using h\u2081\u2084)\n          exact h\u2081\u2083\n        exact h\u2081\u2082\n      exact h\u2081\u2081\n    have h\u2082 : (Int.gcd a (b - a) : \u2115) \u2223 (b - a).natAbs := by\n      have h\u2082\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 (b - a).natAbs := by\n        have h\u2082\u2082 : (Int.gcd a (b - a) : \u2115) \u2223 (b - a).natAbs := by\n          -- Prove that gcd(a, b - a) divides (b - a).natAbs\n          have h\u2082\u2083 : (Int.gcd a (b - a) : \u2115) \u2223 (b - a).natAbs := by\n            -- Use the property that gcd(a, b) divides b\n            have h\u2082\u2084 : (Int.gcd a (b - a) : \u2124) \u2223 (b - a) := by\n              -- gcd(a, b - a) divides (b - a)\n              apply Int.gcd_dvd_right\n            -- Convert the divisibility to natural numbers\n            exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_dvd_natAbs] using h\u2082\u2084)\n          exact h\u2082\u2083\n        exact h\u2082\u2082\n      exact h\u2082\u2081\n    have h\u2083 : (Int.gcd a (b - a) : \u2115) \u2223 b.natAbs := by\n      have h\u2083\u2081 : (Int.gcd a (b - a) : \u2124) \u2223 a := by\n        -- gcd(a, b - a) divides a\n        apply Int.gcd_dvd_left\n      have h\u2083\u2082 : (Int.gcd a (b - a) : \u2124) \u2223 (b - a) := by\n        -- gcd(a, b - a) divides (b - a)\n        apply Int.gcd_dvd_right\n      have h\u2083\u2083 : (Int.gcd a (b - a) : \u2124) \u2223 b := by\n        -- gcd(a, b - a) divides b = a + (b - a)\n        have h\u2083\u2084 : (Int.gcd a (b - a) : \u2124) \u2223 a + (b - a) := by\n          -- Since gcd(a, b - a) divides both a and (b - a), it divides their sum\n          exact dvd_add h\u2083\u2081 h\u2083\u2082\n        -- Simplify the sum\n        have h\u2083\u2085 : a + (b - a) = b := by ring\n        rw [h\u2083\u2085] at h\u2083\u2084\n        exact h\u2083\u2084\n      -- Convert the divisibility to natural numbers\n      have h\u2083\u2086 : (Int.gcd a (b - a) : \u2115) \u2223 b.natAbs := by\n        exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_dvd_natAbs] using h\u2083\u2083)\n      exact h\u2083\u2086\n    have h\u2084 : (Int.gcd a (b - a) : \u2115) \u2223 Int.gcd a b := by\n      -- Since gcd(a, b - a) divides both a.natAbs and b.natAbs, it divides their gcd\n      have h\u2084\u2081 : (Int.gcd a (b - a) : \u2115) \u2223 a.natAbs := h\u2081\n      have h\u2084\u2082 : (Int.gcd a (b - a) : \u2115) \u2223 b.natAbs := h\u2083\n      -- Use the property that if a number divides both, it divides their gcd\n      have h\u2084\u2083 : (Int.gcd a (b - a) : \u2115) \u2223 Nat.gcd a.natAbs b.natAbs := Nat.dvd_gcd h\u2084\u2081 h\u2084\u2082\n      -- Since Int.gcd a b = Nat.gcd a.natAbs b.natAbs, we have the result\n      simpa [Int.gcd] using h\u2084\u2083\n    have h\u2085 : (Int.gcd a b : \u2115) \u2223 a.natAbs := by\n      have h\u2085\u2081 : (Int.gcd a b : \u2115) \u2223 a.natAbs := by\n        have h\u2085\u2082 : (Int.gcd a b : \u2115) \u2223 a.natAbs := by\n          -- Prove that gcd(a, b) divides a.natAbs\n          have h\u2085\u2083 : (Int.gcd a b : \u2115) \u2223 a.natAbs := by\n            -- Use the property that gcd(a, b) divides a\n            have h\u2085\u2084 : (Int.gcd a b : \u2124) \u2223 a := by\n              -- gcd(a, b) divides a\n              apply Int.gcd_dvd_left\n            -- Convert the divisibility to natural numbers\n            exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_dvd_natAbs] using h\u2085\u2084)\n          exact h\u2085\u2083\n        exact h\u2085\u2082\n      exact h\u2085\u2081\n    have h\u2086 : (Int.gcd a b : \u2115) \u2223 b.natAbs := by\n      have h\u2086\u2081 : (Int.gcd a b : \u2115) \u2223 b.natAbs := by\n        have h\u2086\u2082 : (Int.gcd a b : \u2115) \u2223 b.natAbs := by\n          -- Prove that gcd(a, b) divides b.natAbs\n          have h\u2086\u2083 : (Int.gcd a b : \u2115) \u2223 b.natAbs := by\n            -- Use the property that gcd(a, b) divides b\n            have h\u2086\u2084 : (Int.gcd a b : \u2124) \u2223 b := by\n              -- gcd(a, b) divides b\n              apply Int.gcd_dvd_right\n            -- Convert the divisibility to natural numbers\n            exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_dvd_natAbs] using h\u2086\u2084)\n          exact h\u2086\u2083\n        exact h\u2086\u2082\n      exact h\u2086\u2081\n    have h\u2087 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := by\n      have h\u2087\u2081 : (Int.gcd a b : \u2124) \u2223 a := by\n        -- gcd(a, b) divides a\n        apply Int.gcd_dvd_left\n      have h\u2087\u2082 : (Int.gcd a b : \u2124) \u2223 b := by\n        -- gcd(a, b) divides b\n        apply Int.gcd_dvd_right\n      have h\u2087\u2083 : (Int.gcd a b : \u2124) \u2223 (b - a) := by\n        -- gcd(a, b) divides (b - a) = b + (-a)\n        have h\u2087\u2084 : (Int.gcd a b : \u2124) \u2223 b + (-a) := by\n          -- Since gcd(a, b) divides both b and a, it divides b + (-a)\n          have h\u2087\u2085 : (Int.gcd a b : \u2124) \u2223 (-a) := by\n            -- Since gcd(a, b) divides a, it divides -a\n            exact dvd_neg.mpr h\u2087\u2081\n          exact dvd_add h\u2087\u2082 h\u2087\u2085\n        -- Simplify the sum\n        have h\u2087\u2086 : b + (-a) = b - a := by ring\n        rw [h\u2087\u2086] at h\u2087\u2084\n        exact h\u2087\u2084\n      -- Convert the divisibility to natural numbers\n      have h\u2087\u2087 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := by\n        exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_dvd_natAbs] using h\u2087\u2083)\n      exact h\u2087\u2087\n    have h\u2088 : (Int.gcd a b : \u2115) \u2223 Int.gcd a (b - a) := by\n      -- Since gcd(a, b) divides both a.natAbs and (b - a).natAbs, it divides their gcd\n      have h\u2088\u2081 : (Int.gcd a b : \u2115) \u2223 a.natAbs := h\u2085\n      have h\u2088\u2082 : (Int.gcd a b : \u2115) \u2223 (b - a).natAbs := h\u2087\n      -- Use the property that if a number divides both, it divides their gcd\n      have h\u2088\u2083 : (Int.gcd a b : \u2115) \u2223 Nat.gcd a.natAbs (b - a).natAbs := Nat.dvd_gcd h\u2088\u2081 h\u2088\u2082\n      -- Since Int.gcd a (b - a) = Nat.gcd a.natAbs (b - a).natAbs, we have the result\n      simpa [Int.gcd] using h\u2088\u2083\n    -- Since both gcd(a, b - a) and gcd(a, b) divide each other, they are equal\n    have h\u2089 : (Int.gcd a (b - a) : \u2115) = (Int.gcd a b : \u2115) := by\n      apply Nat.dvd_antisymm h\u2084 h\u2088\n    -- Convert back to integers\n    norm_cast at h\u2089 \u22a2\n    <;> simp_all [Int.gcd_eq_zero_iff]\n    <;> norm_num\n    <;> aesop\n  \n  have h_final : Int.gcd a (b - a) \u2264 Int.gcd a b := by\n    rw [h_main]\n    <;>\n    simp [le_refl]\n    <;>\n    norm_num\n    <;>\n    aesop\n  \n  exact h_final"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "which proves that $\\gcd(a,b)=\\gcd(a,b-a)$.", "statement": "We assume:\n\u2022 gcd(a, b) \u2264 gcd(a, b-a) [l2]\n\u2022 gcd(a, b-a) \u2264 gcd(a, b) [l4]\nTherefore, we conclude:\n\u2022 gcd(a, b) = gcd(a, b-a) [ts_1].", "dependencies": ["l2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b : \u2124) \n  (l2 : Int.gcd a b \u2264 Int.gcd a (b - a))\n  (l4 : Int.gcd a (b - a) \u2264 Int.gcd a b) :\n  Int.gcd a b = Int.gcd a (b - a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b : \u2124) \n  (l2 : Int.gcd a b \u2264 Int.gcd a (b - a))\n  (l4 : Int.gcd a (b - a) \u2264 Int.gcd a b) :\n  Int.gcd a b = Int.gcd a (b - a) := by\n  have h_main : Int.gcd a b = Int.gcd a (b - a) := by\n    have h\u2081 : (Int.gcd a b : \u2115) \u2264 (Int.gcd a (b - a) : \u2115) := by exact_mod_cast l2\n    have h\u2082 : (Int.gcd a (b - a) : \u2115) \u2264 (Int.gcd a b : \u2115) := by exact_mod_cast l4\n    -- Use the antisymmetry of the \u2264 relation on \u2115 to conclude equality\n    have h\u2083 : (Int.gcd a b : \u2115) = (Int.gcd a (b - a) : \u2115) := by\n      apply le_antisymm h\u2081 h\u2082\n    -- Since the natural numbers are equal, their integer counterparts are also equal\n    exact_mod_cast h\u2083\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. The variables a and b are properly declared as integers (appropriate for gcd operations), both assumptions l2 and l4 are correctly formalized as the respective inequality hypotheses, and the conclusion ts_1 is accurately represented as the equality statement. The logical structure showing that two opposite inequalities imply equality is preserved exactly. The only differences are notational (Int.gcd vs gcd()) and structural (Lean theorem syntax), which do not affect the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    