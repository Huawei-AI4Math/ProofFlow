
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a random variable with mean $E[X] = \mu$. Let $\mathcal{G}$ be a sub-$\sigma$-algebra of the underlying $\sigma$-algebra $\mathcal{F}$. Suppose the conditional expectation of $X$ given $\mathcal{G}$ is $E[X|\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$. The moments of $Y$ are given by $E[Y] = m$ and $E[Y^2] = k$, with $m 
eq 0$. Then, the variance of the conditional expectation is $Var(E[X|\mathcal{G}]) = \mu^2 \left(\frac{k}{m^2} - 1\right)$.

Proof: First, we determine the constant $c$. Using the law of total expectation, $E[E[X|\mathcal{G}]] = E[X]$, and substituting the given expressions, we have $E[cY] = \mu$. This implies $c E[Y] = \mu$, which leads to $cm = \mu$, so we find $c = \frac{\mu}{m}$.
Next, we determine the mean of $E[X|\mathcal{G}]$. By the law of total expectation, $E[E[X|\mathcal{G}]] = E[X]$, which is given as $\mu$.
We then calculate the second moment of $E[X|\mathcal{G}]$. This is $E[(E[X|\mathcal{G}])^2] = E[(cY)^2] = c^2 E[Y^2]$. Substituting the value of $c$ we found and the given value for $E[Y^2]$, we get $(\frac{\mu}{m})^2 k = \frac{\mu^2 k}{m^2}$.
Finally, we compute the variance using the formula $Var(Z) = E[Z^2] - (E[Z])^2$. This gives $Var(E[X|\mathcal{G}]) = \frac{\mu^2 k}{m^2} - \mu^2$, which simplifies to $\mu^2 \left(\frac{k}{m^2} - 1\right)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a random variable with mean $E[X] = \\mu$.", "statement": "Premise:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (X : \u211d \u2192 \u211d) (\u03bc : \u211d)\n(tc_1 : \u2200 x, X x = x) (tc_2 : \u222b x, X x = \u03bc)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean declaration of X as a function from reals to reals appropriately represents a random variable in this mathematical context.", "The constraint tc_1 forces X to be the identity function (X x = x), which is much more restrictive than the natural language statement that simply says X is a random variable. This introduces a major constraint not present in the original statement.", "The Lean formalization uses an integral to represent the expected value E[X] = \u03bc, which is the standard mathematical representation for continuous random variables."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean declaration of X as a function from reals to reals appropriately represents a random variable in this mathematical context.', 'The constraint tc_1 forces X to be the identity function (X x = x), which is much more restrictive than the natural language statement that simply says X is a random variable. This introduces a major constraint not present in the original statement.', 'The Lean formalization uses an integral to represent the expected value E[X] = \u03bc, which is the standard mathematical representation for continuous random variables.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $\\mathcal{G}$ be a sub-$\\sigma$-algebra of the underlying $\\sigma$-algebra $\\mathcal{F}$.", "statement": "Premise:\n\u2022 $\\mathcal{G}$ is a sub-$\\sigma$-algebra of the underlying $\\sigma$-algebra $\\mathcal{F}$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} \n  (F G : MeasurableSpace \u03a9)\n  (h_sub : G \u2264 F)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning. In Lean, MeasurableSpace represents \u03c3-algebras, and the relation G \u2264 F correctly expresses that G is a sub-\u03c3-algebra of F. The additional type declaration {\u03a9 : Type*} is a necessary technical detail that doesn't contradict the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Suppose the conditional expectation of $X$ given $\\mathcal{G}$ is $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$.", "statement": "Premise:\n\u2022 $X$ is a random variable [tc_1].\n\u2022 $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_2].\n\u2022 The conditional expectation of $X$ given $\\mathcal{G}$ is $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_3 \n  (X Y : \u211d \u2192 \u211d)\n  (c \u03bc m k : \u211d)\n  (h_cond_exp : \u2200 x, X x = c * Y x) -- E[X|G] = cY\n  (h_EY : \u222b y, Y y = m) -- E[Y] = m\n  (h_EY2 : \u222b y, (Y y)^2 = k) -- E[Y\u00b2] = k\n  (h_nonzero : m \u2260 0) :\n  -- Var(E[X|G]) = \u03bc\u00b2(k/m\u00b2 - 1)\n  c^2 * k - (c * m)^2 = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["X and Y are correctly represented as random variables (functions from \u211d \u2192 \u211d)", "The Lean theorem completely omits any mention of a sub-\u03c3-algebra \ud835\udca2, which is a key component of the natural language premise", "The Lean uses 'X x = c * Y x' which suggests X equals cY pointwise, but the natural language specifically mentions conditional expectation E[X|\ud835\udca2] = cY. These are fundamentally different mathematical concepts", "The Lean theorem introduces additional conditions (E[Y] = m, E[Y\u00b2] = k, m \u2260 0) that are not mentioned in the natural language premise", "The Lean theorem derives a variance formula conclusion, but the natural language explicitly states there are no conclusions - it's just a premise"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['X and Y are correctly represented as random variables (functions from \u211d \u2192 \u211d)', 'The Lean theorem completely omits any mention of a sub-\u03c3-algebra \ud835\udca2, which is a key component of the natural language premise', \"The Lean uses 'X x = c * Y x' which suggests X equals cY pointwise, but the natural language specifically mentions conditional expectation E[X|\ud835\udca2] = cY. These are fundamentally different mathematical concepts\", 'The Lean theorem introduces additional conditions (E[Y] = m, E[Y\u00b2] = k, m \u2260 0) that are not mentioned in the natural language premise', \"The Lean theorem derives a variance formula conclusion, but the natural language explicitly states there are no conclusions - it's just a premise\"]"}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "The moments of $Y$ are given by $E[Y] = m$ and $E[Y^2] = k$", "statement": "Premise:\n\u2022 $Y$ is a random variable [tc_3].\n\u2022 The moments of $Y$ are given by $E[Y] = m$ and $E[Y^2] = k$ [tc_4].", "dependencies": ["tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (Y : \u211d \u2192 \u211d) (m k : \u211d)\n(tc_4 : \u222b y, Y y = m \u2227 \u222b y, (Y y)^2 = k)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language states Y is a random variable, but Lean defines Y as a function \u211d \u2192 \u211d. While random variables can be represented as measurable functions, the Lean formalization doesn't explicitly capture the probabilistic nature or measurability that defines a random variable.", "The natural language uses expectation notation E[Y] and E[Y\u00b2], but Lean uses integral notation \u222b y, Y y and \u222b y, (Y y)\u00b2. While these are mathematically equivalent for continuous random variables, the notation differs and the Lean version doesn't specify the measure or probability space that would make this a proper expectation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language states Y is a random variable, but Lean defines Y as a function \u211d \u2192 \u211d. While random variables can be represented as measurable functions, the Lean formalization doesn't explicitly capture the probabilistic nature or measurability that defines a random variable.\", \"The natural language uses expectation notation E[Y] and E[Y\u00b2], but Lean uses integral notation \u222b y, Y y and \u222b y, (Y y)\u00b2. While these are mathematically equivalent for continuous random variables, the notation differs and the Lean version doesn't specify the measure or probability space that would make this a proper expectation.\"]"}, "type": "condition"}, "tc_5": {"id": "tc_5", "natural_language": "with $m \\neq 0$.", "statement": "Premise:\n\u2022 $m$ is the mean of a random variable Y [tc_4].\n\u2022 $m \\neq 0$ [tc_5].", "dependencies": ["tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (Y : \u211d \u2192 \u211d) (m k : \u211d)\n(tc_4 : \u222b y, Y y = m \u2227 \u222b y, (Y y)^2 = k)\n(tc_5 : m \u2260 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that m is the mean of Y through \u222b y, Y y = m. The additional constraint \u222b y, (Y y)^2 = k in tc_4 is extra information not mentioned in the natural language, but this is acceptable as it's logically consistent additional detail.", "The Lean formalization exactly matches the natural language condition m \u2260 0."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Using the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$", "statement": "We assume:\n\u2022 $X$ is a random variable [tc_1].\n\u2022 $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_2].\nTherefore, we conclude:\n\u2022 The law of total expectation states $E[E[X|\\mathcal{G}]] = E[X]$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem law_of_total_expectation (X : \u211d \u2192 \u211d) (\u03bc : \u211d) (A : Set \u211d) \n  (hX : \u2200 x \u2208 A, X x = x) \n  (hA : MeasureTheory.volume A = 1)\n  (h\u03bc : \u222b x in A, X x \u2202MeasureTheory.volume = \u03bc) :\n  \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem law_of_total_expectation (X : \u211d \u2192 \u211d) (\u03bc : \u211d) (A : Set \u211d) \n  (hX : \u2200 x \u2208 A, X x = x) \n  (hA : MeasureTheory.volume A = 1)\n  (h\u03bc : \u222b x in A, X x \u2202MeasureTheory.volume = \u03bc) :\n  \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = \u03bc := by\n  have h1 : \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = (\u222b y in A, X y \u2202MeasureTheory.volume) * (MeasureTheory.volume A : \u211d) := by\n    have h\u2081 : \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = (\u222b y in A, X y \u2202MeasureTheory.volume) * (MeasureTheory.volume A : \u211d) := by\n      -- Use the property of integrating a constant function over a set\n      have h\u2082 : \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = (\u222b y in A, X y \u2202MeasureTheory.volume) * (MeasureTheory.volume A : \u211d) := by\n        -- The integral of a constant `c` over a set `A` is `c * volume(A)`\n        have h\u2083 : \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume : \u211d) \u2202MeasureTheory.volume = (\u222b y in A, X y \u2202MeasureTheory.volume : \u211d) * (MeasureTheory.volume A : \u211d) := by\n          -- Use the lemma for the integral of a constant function\n          simp [MeasureTheory.integral_const]\n          <;>\n          (try norm_num) <;>\n          (try simp_all [MeasureTheory.integral_const]) <;>\n          (try ring_nf) <;>\n          (try field_simp) <;>\n          (try linarith)\n        -- Simplify the expression to match the desired form\n        simpa using h\u2083\n      exact h\u2082\n    exact h\u2081\n  \n  have h2 : (\u222b y in A, X y \u2202MeasureTheory.volume) * (MeasureTheory.volume A : \u211d) = \u03bc * (MeasureTheory.volume A : \u211d) := by\n    have h\u2082 : \u222b y in A, X y \u2202MeasureTheory.volume = \u03bc := by\n      -- Use the given hypothesis h\u03bc to substitute the integral with \u03bc\n      have h\u2083 : \u222b x in A, X x \u2202MeasureTheory.volume = \u03bc := h\u03bc\n      -- The integral of X over A is \u03bc, so we can directly use this fact\n      have h\u2084 : \u222b y in A, X y \u2202MeasureTheory.volume = \u03bc := by\n        -- The variable of integration is a dummy variable, so we can rename it\n        simpa using h\u2083\n      exact h\u2084\n    -- Substitute the integral with \u03bc in the expression\n    rw [h\u2082]\n    <;>\n    (try simp_all) <;>\n    (try ring_nf) <;>\n    (try norm_num)\n  \n  have h3 : (MeasureTheory.volume A : \u211d) = 1 := by\n    have h\u2083 : (MeasureTheory.volume A : \u211d) = 1 := by\n      -- Convert the measure to a real number and use the given hypothesis hA\n      have h\u2084 : (MeasureTheory.volume A : \u211d\u22650\u221e) = 1 := by\n        simpa using hA\n      -- Since the measure is 1 in \u211d\u22650\u221e, its real number counterpart is also 1\n      have h\u2085 : (MeasureTheory.volume A : \u211d) = 1 := by\n        -- Use the fact that the coercion from \u211d\u22650\u221e to \u211d is 1 when the value is 1\n        norm_cast at h\u2084 \u22a2\n        <;> simp_all [ENNReal.coe_one]\n        <;> norm_num\n      exact h\u2085\n    exact h\u2083\n  \n  have h4 : \u03bc * (MeasureTheory.volume A : \u211d) = \u03bc := by\n    rw [h3]\n    <;> ring_nf\n    <;> simp_all\n    <;> norm_num\n  \n  have h5 : \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = \u03bc := by\n    calc\n      \u222b x in A, (\u222b y in A, X y \u2202MeasureTheory.volume) \u2202MeasureTheory.volume = (\u222b y in A, X y \u2202MeasureTheory.volume) * (MeasureTheory.volume A : \u211d) := by rw [h1]\n      _ = \u03bc * (MeasureTheory.volume A : \u211d) := by rw [h2]\n      _ = \u03bc := by rw [h4]\n  \n  exact h5", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The random variable X is overly constrained to be the identity function, which doesn't represent a general random variable as stated in natural language", "The sub-\u03c3-algebra \ud835\udca2 is completely missing from the Lean formalization, replaced only with a measurable set A", "Conditional expectation E[X|\ud835\udca2] is not properly formalized - the Lean code uses simple integration over A rather than conditional expectation with respect to a sub-\u03c3-algebra", "The law of total expectation is not correctly captured - the Lean statement is about nested integrals over the same set rather than the relationship between conditional and unconditional expectations", "The overall mathematical framework shifts from general probability theory with \u03c3-algebras to a simplified measure theory setup, missing the core probabilistic concepts", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The random variable X is overly constrained to be the identity function, which doesn't represent a general random variable as stated in natural language\", 'The sub-\u03c3-algebra \ud835\udca2 is completely missing from the Lean formalization, replaced only with a measurable set A', 'Conditional expectation E[X|\ud835\udca2] is not properly formalized - the Lean code uses simple integration over A rather than conditional expectation with respect to a sub-\u03c3-algebra', 'The law of total expectation is not correctly captured - the Lean statement is about nested integrals over the same set rather than the relationship between conditional and unconditional expectations', 'The overall mathematical framework shifts from general probability theory with \u03c3-algebras to a simplified measure theory setup, missing the core probabilistic concepts']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "substituting the given expressions, we have $E[cY] = \\mu$.", "statement": "We assume:\n\u2022 The law of total expectation states $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\n\u2022 The conditional expectation is $E[X|\\mathcal{G}] = cY$ [tc_3].\n\u2022 The mean of $X$ is $E[X] = \\mu$ [tc_1].\nTherefore, we conclude:\n\u2022 $E[cY] = \\mu$ [l2].", "dependencies": ["tc_1", "tc_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem variance_conditional_expectation \n  (X Y : \u211d \u2192 \u211d) \n  (\u03bc m k c : \u211d)\n  (hX_mean : \u222b x, X x = \u03bc)\n  (hY_mean : \u222b y, Y y = m)\n  (hY_second_moment : \u222b y, (Y y)^2 = k)\n  (hY_nonzero : m \u2260 0)\n  (h_cond_exp : \u2200 x, X x = c * Y x) :\n  (\u222b x, (X x)^2) - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem variance_conditional_expectation \n  (X Y : \u211d \u2192 \u211d) \n  (\u03bc m k c : \u211d)\n  (hX_mean : \u222b x, X x = \u03bc)\n  (hY_mean : \u222b y, Y y = m)\n  (hY_second_moment : \u222b y, (Y y)^2 = k)\n  (hY_nonzero : m \u2260 0)\n  (h_cond_exp : \u2200 x, X x = c * Y x) :\n  (\u222b x, (X x)^2) - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n  have h_\u03bc : \u03bc = c * m := by\n    have h\u2081 : \u03bc = c * m := by\n      calc\n        \u03bc = \u222b x, X x := by rw [hX_mean]\n        _ = \u222b x, (c * Y x) := by\n          congr\n          ext x\n          rw [h_cond_exp x]\n        _ = c * \u222b x, Y x := by\n          -- Use the linearity of the integral to factor out the constant c\n          -- This step requires the integrability of Y, which is not directly given.\n          -- However, since \u222b Y x = m is well-defined, Y is integrable.\n          -- We use the fact that the integral of a constant times a function is the constant times the integral of the function.\n          -- This is a property of the integral, and we can use it directly.\n          simp [\u2190 mul_one c, \u2190 intervalIntegral.integral_comp_mul_left (fun x => Y x)]\n          <;>\n          simp_all [mul_comm]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith\n        _ = c * m := by\n          -- Substitute the given value of \u222b Y x\n          rw [hY_mean]\n    exact h\u2081\n  \n  have h_X_sq : (\u222b x, (X x)^2) = c^2 * k := by\n    have h\u2081 : (\u222b x, (X x)^2) = c^2 * k := by\n      calc\n        (\u222b x, (X x)^2) = \u222b x, (c * Y x)^2 := by\n          congr\n          ext x\n          rw [h_cond_exp x]\n          <;> ring_nf\n        _ = \u222b x, (c^2 * (Y x)^2) := by\n          congr\n          ext x\n          ring_nf\n          <;> simp [mul_pow]\n          <;> ring_nf\n        _ = c^2 * \u222b x, (Y x)^2 := by\n          -- Use the linearity of the integral to factor out the constant c^2\n          -- This step requires the integrability of (Y x)^2, which is not directly given.\n          -- However, since \u222b (Y x)^2 = k is well-defined, (Y x)^2 is integrable.\n          -- We use the fact that the integral of a constant times a function is the constant times the integral of the function.\n          -- This is a property of the integral, and we can use it directly.\n          simp [\u2190 mul_one (c ^ 2), \u2190 intervalIntegral.integral_comp_mul_left (fun x => (Y x) ^ 2)]\n          <;>\n          simp_all [mul_comm]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith\n        _ = c^2 * k := by\n          -- Substitute the given value of \u222b (Y x)^2\n          rw [hY_second_moment]\n    exact h\u2081\n  \n  have h_c : c = \u03bc / m := by\n    have h\u2081 : \u03bc = c * m := h_\u03bc\n    have h\u2082 : m \u2260 0 := hY_nonzero\n    -- Solve for c using the equation \u03bc = c * m\n    have h\u2083 : c = \u03bc / m := by\n      have h\u2084 : c * m = \u03bc := by linarith\n      field_simp [h\u2082] at h\u2084 \u22a2\n      <;> nlinarith\n    exact h\u2083\n  \n  have h_main : (\u222b x, (X x)^2) = (\u03bc / m)^2 * k := by\n    calc\n      (\u222b x, (X x)^2) = c^2 * k := h_X_sq\n      _ = (\u03bc / m)^2 * k := by\n        rw [h_c]\n        <;> ring_nf\n        <;> field_simp [hY_nonzero]\n        <;> ring_nf\n  \n  have h_final : (\u222b x, (X x)^2) - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n    have h\u2081 : (\u222b x, (X x)^2) = (\u03bc / m)^2 * k := h_main\n    calc\n      (\u222b x, (X x)^2) - \u03bc ^ 2 = (\u03bc / m) ^ 2 * k - \u03bc ^ 2 := by rw [h\u2081]\n      _ = (\u03bc ^ 2 / m ^ 2) * k - \u03bc ^ 2 := by\n        ring_nf\n        <;> field_simp [hY_nonzero]\n        <;> ring_nf\n      _ = \u03bc ^ 2 * (k / m ^ 2 - 1) := by\n        have h\u2082 : m \u2260 0 := hY_nonzero\n        field_simp [h\u2082]\n        <;> ring_nf\n        <;> field_simp [h\u2082]\n        <;> ring_nf\n        <;> linarith\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 27, "column": 10, "endLine": 27, "endColumn": 86, "data": "tactic 'simp' failed, nested error:\nmaximum recursion depth has been reached\nuse `set_option maxRecDepth <num>` to increase limit\nuse `set_option diagnostics true` to get diagnostic information"}, {"line": 61, "column": 10, "endLine": 61, "endColumn": 98, "data": "tactic 'simp' failed, nested error:\nmaximum recursion depth has been reached\nuse `set_option maxRecDepth <num>` to increase limit\nuse `set_option diagnostics true` to get diagnostic information"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The law of total expectation E[E[X|\ud835\udca2]] = E[X] is completely absent from the Lean formalization, which is a key component of the natural language premise.", "The conditional expectation E[X|\ud835\udca2] = cY in natural language is replaced by a deterministic relationship \u2200 x, X x = c * Y x in Lean, which is a stronger but different mathematical concept.", "The mean assumption E[X] = \u03bc is correctly captured as \u222b x, X x = \u03bc in the Lean formalization.", "The conclusion is completely different - natural language concludes E[cY] = \u03bc while Lean concludes with a variance formula (\u222b x, (X x)^2) - \u03bc^2 = \u03bc^2 * (k / m^2 - 1). These are entirely different mathematical statements solving different problems.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The law of total expectation E[E[X|\ud835\udca2]] = E[X] is completely absent from the Lean formalization, which is a key component of the natural language premise.', 'The conditional expectation E[X|\ud835\udca2] = cY in natural language is replaced by a deterministic relationship \u2200 x, X x = c * Y x in Lean, which is a stronger but different mathematical concept.', 'The mean assumption E[X] = \u03bc is correctly captured as \u222b x, X x = \u03bc in the Lean formalization.', 'The conclusion is completely different - natural language concludes E[cY] = \u03bc while Lean concludes with a variance formula (\u222b x, (X x)^2) - \u03bc^2 = \u03bc^2 * (k / m^2 - 1). These are entirely different mathematical statements solving different problems.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "This implies $c E[Y] = \\mu$", "statement": "We assume:\n\u2022 $E[cY] = \\mu$ [l2].\nTherefore, we conclude:\n\u2022 $c E[Y] = \\mu$ [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (c \u03bc m : \u211d) (Y : \u211d \u2192 \u211d)\n  (h1 : c * m = \u03bc) :\n  c * m = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (c \u03bc m : \u211d) (Y : \u211d \u2192 \u211d)\n  (h1 : c * m = \u03bc) :\n  c * m = \u03bc := by\n  have h2 : c * m = \u03bc := by\n    exact h1\n  \n  exact h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The premise E[cY] = \u03bc is completely missing from the Lean formalization. There is no expectation operator or probability theory representation.", "The conclusion c E[Y] = \u03bc is not properly represented. The variable m appears to be intended as E[Y] but this connection is never established.", "The logical deduction from linearity of expectation is replaced by a trivial tautology c * m = \u03bc \u2192 c * m = \u03bc, which captures none of the mathematical reasoning.", "The formalization lacks the fundamental probability theory concepts (expectation operator, random variables) that are central to the natural language statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The premise E[cY] = \u03bc is completely missing from the Lean formalization. There is no expectation operator or probability theory representation.', 'The conclusion c E[Y] = \u03bc is not properly represented. The variable m appears to be intended as E[Y] but this connection is never established.', 'The logical deduction from linearity of expectation is replaced by a trivial tautology c * m = \u03bc \u2192 c * m = \u03bc, which captures none of the mathematical reasoning.', 'The formalization lacks the fundamental probability theory concepts (expectation operator, random variables) that are central to the natural language statement.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "which leads to $cm = \\mu$", "statement": "We assume:\n\u2022 $c E[Y] = \\mu$ [l3].\n\u2022 The mean of $Y$ is $E[Y] = m$ [tc_4].\nTherefore, we conclude:\n\u2022 $cm = \\mu$ [l4].", "dependencies": ["l3", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (c \u03bc m : \u211d)\n  (h1 : c * m = \u03bc) :\n  c * m = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (c \u03bc m : \u211d)\n  (h1 : c * m = \u03bc) :\n  c * m = \u03bc := by\n  have h2 : c * m = \u03bc := by\n    -- Since h1 directly gives us the required equality, we can just use it.\n    exact h1\n  \n  -- The final goal is exactly h2, so we can directly use it to close the proof.\n  exact h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has a major inconsistency with the natural language. The natural language presents a logical deduction with two premises (c E[Y] = \u03bc and E[Y] = m) leading to a conclusion (cm = \u03bc). However, the Lean code directly assumes the conclusion (c * m = \u03bc) as a hypothesis and then trivially proves the same statement. This misses the key logical component of the substitution reasoning and transforms what should be a meaningful theorem into a tautology."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization has a major inconsistency with the natural language. The natural language presents a logical deduction with two premises (c E[Y] = \u03bc and E[Y] = m) leading to a conclusion (cm = \u03bc). However, the Lean code directly assumes the conclusion (c * m = \u03bc) as a hypothesis and then trivially proves the same statement. This misses the key logical component of the substitution reasoning and transforms what should be a meaningful theorem into a tautology.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "so we find $c = \\frac{\\mu}{m}$.", "statement": "We assume:\n\u2022 $cm = \\mu$ [l4].\n\u2022 $m \\neq 0$ [tc_5].\nTherefore, we conclude:\n\u2022 $c = \\frac{\\mu}{m}$ [l5].", "dependencies": ["l4", "tc_5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (c \u03bc m : \u211d)\n  (l4 : c * m = \u03bc)\n  (tc_5 : m \u2260 0) :\n  c = \u03bc / m := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (c \u03bc m : \u211d)\n  (l4 : c * m = \u03bc)\n  (tc_5 : m \u2260 0) :\n  c = \u03bc / m := by\n  have h_main : c = \u03bc / m := by\n    have h\u2081 : c * m = \u03bc := l4\n    have h\u2082 : c = \u03bc / m := by\n      -- Divide both sides of the equation c * m = \u03bc by m\n      have h\u2083 : c * m / m = \u03bc / m := by\n        rw [h\u2081]\n      -- Simplify the left side: (c * m) / m = c\n      have h\u2084 : c * m / m = c := by\n        field_simp [tc_5]\n        <;> ring\n      -- Substitute back to get c = \u03bc / m\n      linarith\n    exact h\u2082\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture all variables as real numbers with appropriate typing", "The equation c * m = \u03bc correctly formalizes the natural language statement cm = \u03bc with explicit multiplication operator", "The non-zero condition m \u2260 0 is exactly preserved in both notation and meaning", "The conclusion c = \u03bc / m uses identical mathematical notation and represents the same division relationship", "The overall theorem structure properly captures the logical flow from assumptions to conclusion, with all referenced labels (l4, tc_5, l5) appropriately incorporated"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$, which is given as $\\mu$.", "statement": "We assume:\n\u2022 The law of total expectation states $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\n\u2022 The mean of $X$ is $E[X] = \\mu$ [tc_1].\nTherefore, we conclude:\n\u2022 $E[E[X|\\mathcal{G}]] = \\mu$ [l6].", "dependencies": ["l1", "tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (X : \u211d \u2192 \u211d) (\u03bc : \u211d)\n  (l1 : \u2200 (G : SubsigmaAlgebra \u211d), \u222b x, (\u222b y, X y) = \u222b x, X x)\n  (tc_1 : \u222b x, X x = \u03bc) :\n  \u222b x, (\u222b y, X y) = \u03bc := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 15, "endLine": 9, "endColumn": 32, "data": "function expected at\n  SubsigmaAlgebra\nterm has type\n  ?m.10"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nimport MeasureTheory\n\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (X : \u211d \u2192 \u211d) (\u03bc : \u211d)\n  (l1 : \u2200 (G : MeasureTheory.SubsigmaAlgebra \u211d), \u222b x : \u211d, (\u222b y : \u211d, X y) = \u222b x : \u211d, X x)\n  (tc_1 : \u222b x : \u211d, X x = \u03bc) :\n  \u222b x : \u211d, (\u222b y : \u211d, X y) = \u03bc := by\n  have h_step1 : \u222b x : \u211d, (\u222b y : \u211d, X y) = \u222b x : \u211d, X x := by\n    have h\u2081 := l1 (\u22a5 : MeasureTheory.SubsigmaAlgebra \u211d)\n    exact h\u2081\n  \n  have h_step2 : \u222b x : \u211d, (\u222b y : \u211d, X y) = \u03bc := by\n    rw [h_step1]\n    <;> rw [tc_1]\n    <;>\n    (try norm_num) <;>\n    (try simp_all) <;>\n    (try linarith)\n  \n  exact h_step2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 2, "column": 5, "endLine": 2, "endColumn": 17, "data": "unknown namespace 'BigOperators'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "This is $E[(E[X|\\mathcal{G}])^2] = E[(cY)^2] = c^2 E[Y^2]$. Substituting the value of $c$ we found and the given value for $E[Y^2]$, we get $(\\frac{\\mu}{m})^2 k = \\frac{\\mu^2 k}{m^2}$.", "statement": "We assume:\n\u2022 The conditional expectation is $E[X|\\mathcal{G}] = cY$ [tc_3].\n\u2022 The second moment of $Y$ is $E[Y^2] = k$ [tc_4].\n\u2022 The constant $c = \\frac{\\mu}{m}$ [l5].\nTherefore, we conclude:\n\u2022 $E[(E[X|\\mathcal{G}])^2] = \\frac{\\mu^2 k}{m^2}$ [l7].", "dependencies": ["tc_3", "tc_4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (E_X_cond_G E_Y E_Y2 c \u03bc m k : \u211d)\n  (tc_3 : E_X_cond_G = c * E_Y) -- E[X|G] = cY\n  (tc_4 : E_Y2 = k) -- E[Y\u00b2] = k  \n  (l5 : c = \u03bc / m) -- c = \u03bc/m\n  (h_nonzero : m \u2260 0) :\n  E_X_cond_G^2 = \u03bc^2 * k / m^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (E_X_cond_G E_Y E_Y2 c \u03bc m k : \u211d)\n  (tc_3 : E_X_cond_G = c * E_Y)\n  (tc_4 : E_Y2 = k)\n  (l5 : c = \u03bc / m)\n  (h_nonzero : m \u2260 0) :\n  E_X_cond_G^2 = \u03bc^2 * k / m^2 := by\n  have h1 : E_X_cond_G^2 = c^2 * E_Y^2 := by\n    calc\n      E_X_cond_G ^ 2 = (c * E_Y) ^ 2 := by rw [tc_3]\n      _ = c ^ 2 * E_Y ^ 2 := by ring\n  \n  have h2 : c^2 = \u03bc^2 / m^2 := by\n    have h\u2082 : c = \u03bc / m := l5\n    calc\n      c ^ 2 = (\u03bc / m) ^ 2 := by rw [h\u2082]\n      _ = \u03bc ^ 2 / m ^ 2 := by\n        field_simp [h_nonzero]\n        <;> ring_nf\n        <;> field_simp [h_nonzero]\n        <;> ring_nf\n  \n  have h3 : E_X_cond_G^2 = \u03bc^2 / m^2 * E_Y^2 := by\n    calc\n      E_X_cond_G ^ 2 = c ^ 2 * E_Y ^ 2 := by rw [h1]\n      _ = (\u03bc ^ 2 / m ^ 2) * E_Y ^ 2 := by rw [h2]\n      _ = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2 := by ring\n  \n  have h4 : E_X_cond_G ^ 2 = \u03bc ^ 2 * k / m ^ 2 := by\n    have h5 : E_Y = 0 := by\n      by_contra h\n      -- Assume E_Y \u2260 0 and try to find a contradiction.\n      have h6 : E_Y \u2260 0 := h\n      -- Use the fact that E_Y \u2260 0 to try to find a contradiction.\n      have h7 := h3\n      have h8 := h2\n      have h9 := h1\n      have h10 := tc_3\n      have h11 := tc_4\n      have h12 := l5\n      -- Use specific values to find a contradiction.\n      -- For example, set E_Y = 1, c = 1, \u03bc = 1, m = 1, k = 0.\n      -- Then E_X_cond_G = 1, and the conclusion becomes 1 = 0, which is false.\n      -- However, we cannot arbitrarily choose values for the variables.\n      -- The following line is a placeholder to indicate the contradiction.\n      norm_num at *\n      <;>\n      (try contradiction) <;>\n      (try\n        {\n          -- Use specific values to find a contradiction.\n          -- For example, E_Y = 1, c = 1, \u03bc = 1, m = 1, k = 0.\n          exfalso\n          simp_all [pow_two]\n          <;>\n          (try ring_nf at *) <;>\n          (try field_simp [h_nonzero] at *) <;>\n          (try nlinarith)\n        })\n      <;>\n      (try\n        {\n          -- Another attempt to find a contradiction.\n          -- For example, E_Y = 0, c = 1, \u03bc = 1, m = 1, k = 1.\n          exfalso\n          simp_all [pow_two]\n          <;>\n          (try ring_nf at *) <;>\n          (try field_simp [h_nonzero] at *) <;>\n          (try nlinarith)\n        })\n      <;>\n      (try\n        {\n          -- Another attempt to find a contradiction.\n          -- For example, E_Y = 2, c = 1, \u03bc = 1, m = 1, k = 0.\n          exfalso\n          simp_all [pow_two]\n          <;>\n          (try ring_nf at *) <;>\n          (try field_simp [h_nonzero] at *) <;>\n          (try nlinarith)\n        })\n    -- Now we have E_Y = 0.\n    have h6 : E_X_cond_G = 0 := by\n      have h7 : E_X_cond_G = c * E_Y := tc_3\n      rw [h7, h5]\n      ring\n    have h7 : E_X_cond_G ^ 2 = 0 := by\n      rw [h6]\n      <;> ring\n    have h8 : \u03bc ^ 2 * k / m ^ 2 = 0 := by\n      have h9 : E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2 := h3\n      have h10 : E_Y = 0 := h5\n      have h11 : E_X_cond_G ^ 2 = 0 := h7\n      have h12 : \u03bc ^ 2 / m ^ 2 * E_Y ^ 2 = 0 := by\n        rw [h10] at *\n        ring_nf at *\n        <;> simp_all\n        <;> field_simp [h_nonzero] at *\n        <;> ring_nf at *\n        <;> nlinarith\n      have h13 : \u03bc ^ 2 * k / m ^ 2 = 0 := by\n        -- Use the fact that E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2 and E_Y = 0 to deduce \u03bc ^ 2 * k / m ^ 2 = 0.\n        -- This is a placeholder for the actual deduction.\n        exfalso\n        -- Try to find a contradiction if we assume \u03bc ^ 2 * k / m ^ 2 \u2260 0.\n        have h14 := h3\n        have h15 := h2\n        have h16 := h1\n        have h17 := tc_3\n        have h18 := tc_4\n        have h19 := l5\n        norm_num at *\n        <;>\n        (try contradiction) <;>\n        (try\n          {\n            exfalso\n            simp_all [pow_two]\n            <;>\n            (try ring_nf at *) <;>\n            (try field_simp [h_nonzero] at *) <;>\n            (try nlinarith)\n          })\n        <;>\n        (try\n          {\n            exfalso\n            simp_all [pow_two]\n            <;>\n            (try ring_nf at *) <;>\n            (try field_simp [h_nonzero] at *) <;>\n            (try nlinarith)\n          })\n        <;>\n        (try\n          {\n            exfalso\n            simp_all [pow_two]\n            <;>\n            (try ring_nf at *) <;>\n            (try field_simp [h_nonzero] at *) <;>\n            (try nlinarith)\n          })\n      exact h13\n    have h9 : E_X_cond_G ^ 2 = \u03bc ^ 2 * k / m ^ 2 := by\n      linarith\n    exact h9\n  \n  exact h4", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 33, "column": 25, "endLine": 86, "endColumn": 10, "data": "unsolved goals\nE_X_cond_G E_Y E_Y2 c \u03bc m k : \u211d\ntc_3 : E_X_cond_G = c * E_Y\ntc_4 : E_Y2 = k\nl5 : c = \u03bc / m\nh_nonzero : \u00acm = 0\nh1 : E_X_cond_G ^ 2 = c ^ 2 * E_Y ^ 2\nh2 : c ^ 2 = \u03bc ^ 2 / m ^ 2\nh3 : E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2\nh h6 : \u00acE_Y = 0\nh7 : E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2\nh8 : c ^ 2 = \u03bc ^ 2 / m ^ 2\nh9 : E_X_cond_G ^ 2 = c ^ 2 * E_Y ^ 2\nh10 : E_X_cond_G = c * E_Y\nh11 : E_Y2 = k\nh12 : c = \u03bc / m\n\u22a2 False"}, {"line": 106, "column": 42, "endLine": 148, "endColumn": 12, "data": "unsolved goals\nE_X_cond_G E_Y E_Y2 c \u03bc m k : \u211d\ntc_3 : E_X_cond_G = c * E_Y\ntc_4 : E_Y2 = k\nl5 : c = \u03bc / m\nh_nonzero : \u00acm = 0\nh1 : E_X_cond_G ^ 2 = c ^ 2 * E_Y ^ 2\nh2 : c ^ 2 = \u03bc ^ 2 / m ^ 2\nh3 : E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2\nh5 : E_Y = 0\nh6 : E_X_cond_G = 0\nh9 : E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2\nh10 : E_Y = 0\nh14 : E_X_cond_G ^ 2 = \u03bc ^ 2 / m ^ 2 * E_Y ^ 2\nh15 : c ^ 2 = \u03bc ^ 2 / m ^ 2\nh16 : E_X_cond_G ^ 2 = c ^ 2 * E_Y ^ 2\nh17 : E_X_cond_G = c * E_Y\nh18 : E_Y2 = k\nh19 : c = \u03bc / m\nh7 h11 : E_X_cond_G = 0\nh12 : (\u03bc = 0 \u2228 m = 0) \u2228 E_Y = 0\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language states E[X|G] = cY, meaning the conditional expectation equals c times the random variable Y. However, the Lean formalization treats this as E[X|G] = c * E[Y], which is c times the expectation of Y. These are fundamentally different mathematical objects.", "Similar issue: the natural language refers to E[Y\u00b2] (expectation of Y squared), but the Lean uses E_Y2 which based on the pattern appears to represent E[Y]\u00b2 rather than E[Y\u00b2]. The variable naming suggests E_Y would be E[Y], making E_Y2 likely E[Y]\u00b2.", "The constant definition c = \u03bc/m is correctly captured in both representations.", "The conclusion has the same fundamental issue: the natural language asks for E[(E[X|G])\u00b2] which should involve E[X|G] = cY, leading to E[(cY)\u00b2] = c\u00b2E[Y\u00b2]. But the Lean computes (E[X|G])\u00b2 treating E[X|G] as a scalar rather than a random variable.", "The additional non-zero constraint for m is mathematically sound and necessary for the division, even though not explicitly mentioned in the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language states E[X|G] = cY, meaning the conditional expectation equals c times the random variable Y. However, the Lean formalization treats this as E[X|G] = c * E[Y], which is c times the expectation of Y. These are fundamentally different mathematical objects.', 'Similar issue: the natural language refers to E[Y\u00b2] (expectation of Y squared), but the Lean uses E_Y2 which based on the pattern appears to represent E[Y]\u00b2 rather than E[Y\u00b2]. The variable naming suggests E_Y would be E[Y], making E_Y2 likely E[Y]\u00b2.', 'The constant definition c = \u03bc/m is correctly captured in both representations.', 'The conclusion has the same fundamental issue: the natural language asks for E[(E[X|G])\u00b2] which should involve E[X|G] = cY, leading to E[(cY)\u00b2] = c\u00b2E[Y\u00b2]. But the Lean computes (E[X|G])\u00b2 treating E[X|G] as a scalar rather than a random variable.', 'The additional non-zero constraint for m is mathematically sound and necessary for the division, even though not explicitly mentioned in the natural language.']"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "using the formula $Var(Z) = E[Z^2] - (E[Z])^2$.", "statement": "Definition:\n\u2022 For any random variable Z, its variance is given by $Var(Z) = E[Z^2] - (E[Z])^2$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : ProbabilityMeasure \u03a9) \n  (Z : \u03a9 \u2192 \u211d) :\n  let E := fun f => \u222b \u03c9, f \u03c9 \u2202\u03bc\n  let Var := E (fun \u03c9 => (Z \u03c9)^2) - (E Z)^2\n  Var = E (fun \u03c9 => (Z \u03c9)^2) - (E Z)^2 := by sorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 51, "endLine": 7, "endColumn": 71, "data": "function expected at\n  ProbabilityMeasure\nterm has type\n  ?m.9"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "This gives $Var(E[X|\\mathcal{G}]) = \\frac{\\mu^2 k}{m^2} - \\mu^2$, which simplifies to $\\mu^2 \\left(\\frac{k}{m^2} - 1\\right)$.", "statement": "We assume:\n\u2022 The variance formula is $Var(Z) = E[Z^2] - (E[Z])^2$ [def_1].\n\u2022 The mean of the conditional expectation is $E[E[X|\\mathcal{G}]] = \\mu$ [l6].\n\u2022 The second moment of the conditional expectation is $E[(E[X|\\mathcal{G}])^2] = \\frac{\\mu^2 k}{m^2}$ [l7].\nTherefore, we conclude:\n\u2022 $Var(E[X|\\mathcal{G}]) = \\mu^2 \\left(\\frac{k}{m^2} - 1\\right)$ [ts_1].", "dependencies": ["def_1", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (Z : \u211d \u2192 \u211d) (E_Z E_Z2 c \u03bc m k : \u211d)\n  (h_def_1 : E_Z2 - E_Z^2 = Z E_Z2 - (Z E_Z)^2) -- Variance formula: Var(Z) = E[Z\u00b2] - (E[Z])\u00b2\n  (h_l6 : c * m = \u03bc) -- E[E[X|G]] = \u03bc (from E[cY] = cm = \u03bc)\n  (h_l7 : c^2 * k = \u03bc^2 * k / m^2) -- E[(E[X|G])\u00b2] = \u03bc\u00b2k/m\u00b2 (from c\u00b2E[Y\u00b2] = (\u03bc/m)\u00b2k)\n  (h_nonzero : m \u2260 0) :\n  \u03bc^2 * k / m^2 - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (Z : \u211d \u2192 \u211d) (E_Z E_Z2 c \u03bc m k : \u211d)\n  (h_def_1 : E_Z2 - E_Z^2 = Z E_Z2 - (Z E_Z)^2) \n  (h_l6 : c * m = \u03bc) \n  (h_l7 : c^2 * k = \u03bc^2 * k / m^2) \n  (h_nonzero : m \u2260 0) :\n  \u03bc^2 * k / m^2 - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n  have h_main : \u03bc^2 * (k / m^2 - 1) = \u03bc^2 * k / m^2 - \u03bc^2 := by\n    have h\u2081 : \u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2) - \u03bc^2 * 1 := by\n      ring\n    have h\u2082 : \u03bc^2 * (k / m^2) - \u03bc^2 * 1 = \u03bc^2 * k / m^2 - \u03bc^2 := by\n      have h\u2083 : \u03bc^2 * (k / m^2) = \u03bc^2 * k / m^2 := by\n        ring\n      rw [h\u2083]\n      <;> ring\n    linarith\n  \n  have h_final : \u03bc^2 * k / m^2 - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The variance formula formalization is incorrect. 'Z E_Z2 - (Z E_Z)^2' treats Z as a function applied to expectations, rather than expressing Var(Z) in terms of E[Z\u00b2] and E[Z].", "The condition E[E[X|\ud835\udca2]] = \u03bc is replaced with c * m = \u03bc, introducing undefined variables c and m that don't appear in the natural language statement.", "The condition E[(E[X|\ud835\udca2])\u00b2] = \u03bc\u00b2k/m\u00b2 is replaced with c^2 * k = \u03bc^2 * k / m^2, again introducing the undefined variable c and changing the mathematical relationship.", "The conclusion should demonstrate that Var(E[X|\ud835\udca2]) = \u03bc\u00b2(k/m\u00b2 - 1) by applying the variance formula to the given conditions. Instead, the Lean version only proves a basic algebraic identity \u03bc\u00b2k/m\u00b2 - \u03bc\u00b2 = \u03bc\u00b2(k/m\u00b2 - 1), missing the logical connection to the variance formula and conditional expectations."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The variance formula formalization is incorrect. 'Z E_Z2 - (Z E_Z)^2' treats Z as a function applied to expectations, rather than expressing Var(Z) in terms of E[Z\u00b2] and E[Z].\", \"The condition E[E[X|\ud835\udca2]] = \u03bc is replaced with c * m = \u03bc, introducing undefined variables c and m that don't appear in the natural language statement.\", 'The condition E[(E[X|\ud835\udca2])\u00b2] = \u03bc\u00b2k/m\u00b2 is replaced with c^2 * k = \u03bc^2 * k / m^2, again introducing the undefined variable c and changing the mathematical relationship.', 'The conclusion should demonstrate that Var(E[X|\ud835\udca2]) = \u03bc\u00b2(k/m\u00b2 - 1) by applying the variance formula to the given conditions. Instead, the Lean version only proves a basic algebraic identity \u03bc\u00b2k/m\u00b2 - \u03bc\u00b2 = \u03bc\u00b2(k/m\u00b2 - 1), missing the logical connection to the variance formula and conditional expectations.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_5", "label": "tc_5", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    