
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $C$ be the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 1+i$, and let the function to be integrated be $f(z) = z \operatorname{Re}(z)$. Then the contour integral $\int_C f(z) dz$ is equal to $\frac{2i}{3}$.

Proof: The path $C$ from $z_1=0$ to $z_2=1+i$ can be parameterized by $z(t) = t(1+i)$ for $t \in [0, 1]$. From this parameterization, we find the differential $dz = (1+i)dt$. The integrand $f(z) = z \operatorname{Re}(z)$ becomes $f(z(t)) = t(1+i) \operatorname{Re}(t(1+i)) = t^2(1+i)$ along the path. Substituting these into the integral gives $\int_0^1 t^2(1+i) (1+i) dt$. Evaluating this integral results in $(1+i)^2 \int_0^1 t^2 dt = 2i [\frac{t^3}{3}]_0^1 = \frac{2i}{3}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $C$ be the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 1+i$", "statement": "Premise:\n\u2022 $C$ is the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 1+i$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  let C : \u211d \u2192 \u2102 := fun t => t * (1 + I)\n  let f : \u2102 \u2192 \u2102 := fun z => z * z.re\n  \u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I) = 2 * I / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["While the Lean code correctly defines the straight-line path C from 0 to 1+i using the parameterization t*(1+I) for t\u2208[0,1], it introduces significant additional content not present in the natural language. The natural language only establishes the path C as a premise with no conclusions, but the Lean theorem includes a function f and proves a specific integral equation result. This represents a major departure from the stated premise."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['While the Lean code correctly defines the straight-line path C from 0 to 1+i using the parameterization t*(1+I) for t\u2208[0,1], it introduces significant additional content not present in the natural language. The natural language only establishes the path C as a premise with no conclusions, but the Lean theorem includes a function f and proves a specific integral equation result. This represents a major departure from the stated premise.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "let the function to be integrated be $f(z) = z \\operatorname{Re}(z)$", "statement": "Premise:\n\u2022 The function to be integrated is $f(z) = z \\operatorname{Re}(z)$ for $z \\in \\mathbb{C}$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (f : \u2102 \u2192 \u2102)\n(tc_2 : \u2200 z : \u2102, f z = z * Complex.re z)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical definition. The function f is defined as taking a complex number z and returning z multiplied by its real part. The universal quantification \u2200 z : \u2102 in Lean is equivalent to 'for z \u2208 \u2102' in the natural language, and Complex.re z is the standard Lean representation of Re(z)."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The path $C$ from $z_1=0$ to $z_2=1+i$ can be parameterized by $z(t) = t(1+i)$ for $t \\in [0, 1]$.", "statement": "We assume:\n\u2022 $C$ is the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 1+i$ [tc_1].\nDefinition:\n\u2022 The path $C$ is parameterized by $z(t) = t(1+i)$ for $t \\in [0, 1]$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (t : \u211d)\n\ntheorem def_1 : \n  let C : \u211d \u2192 \u2102 := fun t => (t : \u2102) * (1 + I)\n  let f : \u2102 \u2192 \u2102 := fun z => z * z.re\n  \u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I) = 2 * I / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean code does define C correctly as the parameterization t(1+i), which matches the straight-line path from 0 to 1+i. However, this appears only as a local definition within the theorem, not as the main statement being proved.", "The Lean theorem proves a line integral equation that is completely absent from the natural language. The natural language only states the parameterization of the path, while the Lean theorem proves a specific integral computation result."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean code does define C correctly as the parameterization t(1+i), which matches the straight-line path from 0 to 1+i. However, this appears only as a local definition within the theorem, not as the main statement being proved.', 'The Lean theorem proves a line integral equation that is completely absent from the natural language. The natural language only states the parameterization of the path, while the Lean theorem proves a specific integral computation result.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From this parameterization, we find the differential $dz = (1+i)dt$.", "statement": "We assume:\n\u2022 The path C is parameterized by $z(t) = t(1+i)$ for $t \\in [0, 1]$ [def_1].\nTherefore, we conclude:\n\u2022 The derivative of the parameterization is $z'(t) = 1+i$, and the corresponding differential is $dz = (1+i)dt$ [l1].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (t : \u211d) :\n  let z : \u211d \u2192 \u2102 := fun t => (t : \u2102) * (1 + I)\n  deriv z t = 1 + I := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (t : \u211d) :\n  let z : \u211d \u2192 \u2102 := fun t => (t : \u2102) * (1 + I)\n  deriv z t = 1 + I := by\n  intro z\n  have h\u2081 : z = fun t => (t : \u2102) * (1 + I) := rfl\n  have h\u2082 : deriv z t = 1 + I := by\n    have h\u2083 : HasDerivAt z (1 + I) t := by\n      -- Prove that the derivative of z(t) = t(1 + i) is 1 + i\n      have h\u2084 : HasDerivAt (fun t : \u211d => (t : \u2102)) (1 : \u2102) t := by\n        simpa using (hasDerivAt_id t).complex_ofReal\n      -- Use the product rule for differentiation\n      have h\u2085 : HasDerivAt (fun t : \u211d => (t : \u2102) * (1 + I : \u2102)) ((1 : \u2102) * (1 + I : \u2102) + (t : \u2102) * 0) t := by\n        convert HasDerivAt.mul h\u2084 (hasDerivAt_const t (1 + I : \u2102)) using 1 <;>\n          simp [Complex.ext_iff, pow_two] <;>\n          norm_num <;>\n          ring_nf <;>\n          simp_all [Complex.ext_iff] <;>\n          norm_num <;>\n          linarith\n      -- Simplify the expression for the derivative\n      have h\u2086 : ((1 : \u2102) * (1 + I : \u2102) + (t : \u2102) * 0 : \u2102) = 1 + I := by\n        ring_nf\n        <;> simp [Complex.ext_iff]\n        <;> norm_num\n      -- Combine the results\n      convert h\u2085 using 1\n      <;> simp_all [h\u2086]\n    -- Use the fact that the derivative exists to compute it\n    have h\u2087 : deriv z t = 1 + I := by\n      apply HasDerivAt.deriv\n      exact h\u2083\n    exact h\u2087\n  exact h\u2082", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 16, "endLine": 9, "endColumn": 42, "data": "type mismatch\n  fun t => t * (1 + I)\nhas type\n  \u2102 \u2192 \u2102 : Type\nbut is expected to have type\n  \u211d \u2192 \u2102 : Type"}, {"line": 14, "column": 20, "endLine": 14, "endColumn": 52, "data": "invalid field 'complex_ofReal', the environment does not contain 'HasDerivAt.complex_ofReal'\n  hasDerivAt_id t\nhas type\n  HasDerivAt id 1 t"}, {"line": 14, "column": 20, "endLine": 14, "endColumn": 52, "data": "invalid field 'complex_ofReal', the environment does not contain 'HasDerivAtFilter.complex_ofReal'\n  hasDerivAt_id t\nhas type\n  HasDerivAtFilter id 1 t (\ud835\udcdd t)"}, {"line": 14, "column": 20, "endLine": 14, "endColumn": 52, "data": "invalid field 'complex_ofReal', the environment does not contain 'HasFDerivAtFilter.complex_ofReal'\n  hasDerivAt_id t\nhas type\n  HasFDerivAtFilter id (ContinuousLinearMap.smulRight 1 1) t (\ud835\udcdd t)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The parameterization z(t) = t(1+i) is correctly captured in Lean as a function from reals to complex numbers. The domain restriction [0,1] is not explicitly stated but this is acceptable as an additional constraint.", "The derivative calculation z'(t) = 1+i is perfectly captured as 'deriv z t = 1 + I' in the Lean formalization.", "The differential form dz = (1+i)dt is not explicitly present in the Lean code, though it follows directly from the derivative. The Lean formalization focuses on the fundamental derivative relationship rather than the differential notation.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (t : \u211d) :\n  let z : \u211d \u2192 \u2102 := fun t => (t : \u2102) * (1 + I)\n  deriv z t = 1 + I := by\n  intro z\n  have h\u2081 : HasDerivAt z (1 + I : \u2102) t := by\n    have h\u2082 : HasDerivAt (fun t : \u211d => (t : \u2102)) (1 : \u2102) t := by\n      have h\u2083 : Tendsto (fun h : \u211d => ((t + h : \u2102) - (t : \u2102)) / h) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd (1 : \u2102)) := by\n        have h\u2084 : \u2200 (h : \u211d), h \u2260 0 \u2192 ((t + h : \u2102) - (t : \u2102)) / h = (1 : \u2102) := by\n          intro h hh\n          have h\u2085 : ((t + h : \u2102) - (t : \u2102)) / h = (h : \u2102) / h := by\n            ring_nf\n            <;> simp [Complex.ext_iff, Complex.ofReal_add, Complex.ofReal_sub]\n            <;> norm_num\n            <;> field_simp [hh]\n            <;> ring_nf\n          rw [h\u2085]\n          have h\u2086 : (h : \u2102) / h = (1 : \u2102) := by\n            field_simp [hh, Complex.ext_iff, Complex.ofReal_ne_zero]\n            <;> simp_all [Complex.ext_iff, Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_one]\n            <;> norm_num\n            <;> ring_nf\n            <;> simp_all [Complex.ext_iff, Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_one]\n            <;> norm_num\n          rw [h\u2086]\n        have h\u2085 : (fun h : \u211d => ((t + h : \u2102) - (t : \u2102)) / h) =\u1da0[\ud835\udcdd[\u2260] 0] (fun _ => (1 : \u2102)) := by\n          filter_upwards [self_mem_nhdsWithin] with h hh using h\u2084 h hh\n        have h\u2086 : Tendsto (fun _ : \u211d => (1 : \u2102)) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd (1 : \u2102)) := by\n          apply tendsto_const_nhds\n        have h\u2087 : Tendsto (fun h : \u211d => ((t + h : \u2102) - (t : \u2102)) / h) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd (1 : \u2102)) := by\n          apply h\u2086.congr' h\u2085.symm\n        exact h\u2087\n      have h\u2088 : HasDerivAt (fun t : \u211d => (t : \u2102)) (1 : \u2102) t := by\n        convert hasDerivAt_iff_tendsto.mpr h\u2083 using 1 <;>\n          simp [Complex.ext_iff, add_comm]\n        <;>\n          ring_nf\n        <;>\n          norm_num\n      exact h\u2088\n    have h\u2083 : HasDerivAt (fun t : \u211d => (t : \u2102) * (1 + I : \u2102)) (1 * (1 + I : \u2102)) t := by\n      convert h\u2082.mul (hasDerivAt_const t (1 + I : \u2102)) using 1 <;> ring\n    convert h\u2083 using 1 <;> simp [Complex.ext_iff]\n    <;> norm_num\n  have h\u2082 : deriv z t = (1 + I : \u2102) := by\n    apply HasDerivAt.deriv\n    exact h\u2081\n  exact h\u2082"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "The integrand $f(z) = z \\operatorname{Re}(z)$ becomes $f(z(t)) = t(1+i) \\operatorname{Re}(t(1+i)) = t^2(1+i)$ along the path.", "statement": "We assume:\n\u2022 The function to be integrated is $f(z) = z \\operatorname{Re}(z)$ for $z \\in \\mathbb{C}$ [tc_2].\n\u2022 The path C is parameterized by $z(t) = t(1+i)$ for $t \\in [0, 1]$ [def_1].\nTherefore, we conclude:\n\u2022 Along the path C, the integrand becomes $f(z(t)) = t^2(1+i)$ [l2].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (f : \u2102 \u2192 \u2102)\n  (tc_2 : \u2200 z : \u2102, f z = z * z.re)\n  (C : \u211d \u2192 \u2102)\n  (def_1 : \u2200 t : \u211d, C t = (t : \u2102) * (1 + I)) :\n  \u2200 t : \u211d, f (C t) = t^2 * (1 + I) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (f : \u2102 \u2192 \u2102)\n  (tc_2 : \u2200 z : \u2102, f z = z * z.re)\n  (C : \u211d \u2192 \u2102)\n  (def_1 : \u2200 t : \u211d, C t = (t : \u2102) * (1 + Complex.I)) :\n  \u2200 t : \u211d, f (C t) = t^2 * (1 + Complex.I) := by\n  intro t\n  have hC : C t = (t : \u2102) * (1 + Complex.I) := by\n    rw [def_1]\n    <;> simp [Complex.ext_iff]\n    <;> norm_num\n    <;> ring_nf\n    <;> simp [Complex.ext_iff]\n    <;> norm_num\n    <;> linarith\n  \n  have hC_re : (C t).re = t := by\n    rw [hC]\n    simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul,\n      Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im]\n    <;> ring_nf\n    <;> simp_all [Complex.ext_iff, pow_two]\n    <;> norm_num\n    <;> linarith\n  \n  have hC_im : (C t).im = t := by\n    rw [hC]\n    simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul,\n      Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im]\n    <;> ring_nf\n    <;> simp_all [Complex.ext_iff, pow_two]\n    <;> norm_num\n    <;> linarith\n  \n  have h_fCt : f (C t) = (C t) * (C t).re := by\n    have h1 : f (C t) = (C t) * (C t).re := by\n      rw [tc_2]\n      <;>\n      simp [hC_re]\n      <;>\n      ring_nf\n    rw [h1]\n  \n  have h_main : (C t) * (C t).re = (t : \u2102)^2 * (1 + Complex.I) := by\n    rw [hC]\n    simp [hC_re, Complex.ext_iff, pow_two, Complex.mul_re, Complex.mul_im, Complex.ofReal_add,\n      Complex.ofReal_mul, Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> simp_all [Complex.ext_iff, pow_two]\n    <;> norm_num\n    <;>\n    (try\n      {\n        constructor <;>\n        ring_nf <;>\n        norm_num <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        field_simp at * <;>\n        ring_nf at * <;>\n        norm_num at * <;>\n        linarith\n      })\n  \n  have h_final : f (C t) = (t : \u2102)^2 * (1 + Complex.I) := by\n    calc\n      f (C t) = (C t) * (C t).re := h_fCt\n      _ = (t : \u2102) ^ 2 * (1 + Complex.I) := by rw [h_main]\n  \n  -- Convert the final result to the desired form\n  have h_final_real : f (C t) = (t : \u2102)^2 * (1 + Complex.I) := h_final\n  -- Since Lean 4 automatically coerces t^2 to (t : \u2102)^2 when multiplied by a complex number, we can directly use h_final\n  simpa [Complex.ext_iff, pow_two] using h_final_real", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The function definition f(z) = z * Re(z) is correctly captured in Lean as 'f z = z * z.re'. The mathematical meaning is identical.", "The path parameterization is mathematically correct, but the natural language specifies the domain as t \u2208 [0,1] while Lean uses the broader domain \u211d \u2192 \u2102. This is a minor structural difference in domain specification.", "The conclusion about the integrand along the path is perfectly captured. Both express that f(C(t)) = t\u00b2 * (1+i), and this is mathematically verified to be correct."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Substituting these into the integral gives $\\int_0^1 t^2(1+i) (1+i) dt$.", "statement": "We assume:\n\u2022 $C$ is the straight-line path in the complex plane from $z_1 = 0$ to $z_2 = 1+i$ [tc_1].\n\u2022 The function to be integrated is $f(z) = z \\operatorname{Re}(z)$ [tc_2].\n\u2022 The path is parameterized by $z(t)=t(1+i)$ for $t \\in [0,1]$ [def_1].\n\u2022 The derivative of the parameterization is $z'(t) = 1+i$ [l1].\n\u2022 The integrand along the path is $f(z(t)) = t^2(1+i)$ [l2].\nTherefore, we conclude:\n\u2022 The contour integral $\\int_C f(z) dz$ is equal to the definite integral $\\int_0^1 t^2(1+i)^2 dt$ [l3].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (f : \u2102 \u2192 \u2102)\n  (tc_2 : \u2200 z : \u2102, f z = z * Complex.re z)\n  (C : \u211d \u2192 \u2102)\n  (def_1 : \u2200 t : \u211d, C t = t * (1 + I))\n  (l1 : \u2200 t : \u211d, deriv C t = 1 + I)\n  (l2 : \u2200 t : \u211d, f (C t) = t^2 * (1 + I)) :\n  \u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I) = \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + I)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (f : \u2102 \u2192 \u2102)\n  (tc_2 : \u2200 z : \u2102, f z = z * Complex.re z)\n  (C : \u211d \u2192 \u2102)\n  (def_1 : \u2200 t : \u211d, C t = t * (1 + I))\n  (l1 : \u2200 t : \u211d, deriv C t = 1 + I)\n  (l2 : \u2200 t : \u211d, f (C t) = t^2 * (1 + I)) :\n  \u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I) = \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + I)^2 := by\n  have h_main : (\u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I)) = \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + I)^2 := by\n    have h3 : (\u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I)) = \u222b t in (0 : \u211d)..(1 : \u211d), (t^2 * (1 + I)) * (1 + I) := by\n      -- Use the fact that f(C(t)) = t^2 * (1 + I) to rewrite the integrand\n      have h4 : \u2200 t : \u211d, f (C t) * (1 + I) = (t^2 * (1 + I)) * (1 + I) := by\n        intro t\n        rw [l2 t]\n        <;> ring_nf\n      -- Apply the equality of integrands to the integral\n      calc\n        (\u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I)) = \u222b t in (0 : \u211d)..(1 : \u211d), (f (C t) * (1 + I)) := rfl\n        _ = \u222b t in (0 : \u211d)..(1 : \u211d), ((t^2 * (1 + I)) * (1 + I)) := by\n          congr\n          ext t\n          rw [h4 t]\n        _ = \u222b t in (0 : \u211d)..(1 : \u211d), (t^2 * (1 + I)) * (1 + I) := rfl\n    -- Simplify the RHS to match the target expression\n    have h5 : (\u222b t in (0 : \u211d)..(1 : \u211d), (t^2 * (1 + I)) * (1 + I)) = \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + I)^2 := by\n      -- Use the fact that (t^2 * (1 + I)) * (1 + I) = t^2 * (1 + I)^2\n      have h6 : \u2200 t : \u211d, (t^2 * (1 + I)) * (1 + I) = t^2 * (1 + I)^2 := by\n        intro t\n        ring_nf\n        <;> simp [Complex.ext_iff, pow_two, Complex.I_mul_I]\n        <;> norm_num\n        <;> ring_nf\n        <;> simp [Complex.ext_iff, pow_two, Complex.I_mul_I]\n        <;> norm_num\n        <;> simp_all [Complex.ext_iff, pow_two, Complex.I_mul_I]\n        <;> norm_num\n        <;> linarith\n      -- Apply the equality of integrands to the integral\n      calc\n        (\u222b t in (0 : \u211d)..(1 : \u211d), (t^2 * (1 + I)) * (1 + I)) = \u222b t in (0 : \u211d)..(1 : \u211d), ((t^2 * (1 + I)) * (1 + I)) := rfl\n        _ = \u222b t in (0 : \u211d)..(1 : \u211d), (t^2 * (1 + I)^2) := by\n          congr\n          ext t\n          rw [h6 t]\n        _ = \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + I)^2 := rfl\n    -- Combine the results to get the final equality\n    calc\n      (\u222b t in (0 : \u211d)..(1 : \u211d), f (C t) * (1 + I)) = \u222b t in (0 : \u211d)..(1 : \u211d), (t^2 * (1 + I)) * (1 + I) := h3\n      _ = \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + I)^2 := h5\n  \n  -- The final result follows directly from h_main\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The function definition tc_2 correctly formalizes f(z) = z Re(z) using Complex.re for the real part.", "The path parameterization def_1 correctly captures z(t) = t(1+i), with the domain [0,1] appropriately handled in the integral bounds.", "The derivative l1 correctly formalizes z'(t) = 1+i using Lean's deriv function.", "The integrand l2 correctly captures f(z(t)) = t\u00b2(1+i).", "The main theorem correctly formalizes the contour integral equality, with the left side properly representing the parameterized contour integral f(z(t))\u00b7z'(t) and the right side showing the simplified form t\u00b2(1+i)\u00b2."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Evaluating this integral results in $(1+i)^2 \\int_0^1 t^2 dt = 2i [\\frac{t^3}{3}]_0^1 = \\frac{2i}{3}$.", "statement": "We assume:\n\u2022 The contour integral is equal to the definite integral $\\int_C f(z) dz = \\int_0^1 t^2(1+i)^2 dt$ [l3].\nTherefore, we conclude:\n\u2022 $\\int_C f(z) dz = \\frac{2i}{3}$ [ts_1].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u2102)\n  (C : \u211d \u2192 \u2102)\n  (l3 : \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + Complex.I)^2 = (2 * Complex.I) / 3) :\n  \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + Complex.I)^2 = (2 * Complex.I) / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (f : \u2102 \u2192 \u2102)\n  (C : \u211d \u2192 \u2102)\n  (l3 : \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + Complex.I)^2 = (2 * Complex.I) / 3) :\n  \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + Complex.I)^2 = (2 * Complex.I) / 3 := by\n  have h_main : \u222b t in (0 : \u211d)..(1 : \u211d), t^2 * (1 + Complex.I)^2 = (2 * Complex.I) / 3 := by\n    exact l3\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The assumption l3 in Lean directly states that the definite integral equals (2*Complex.I)/3, but the natural language describes l3 as establishing an equality between a contour integral \u222b_C f(z) dz and the definite integral \u222b_0^1 t^2(1+i)^2 dt. The contour integral is completely missing from the Lean formalization.", "The conclusion in Lean is identical to the assumption l3, making it trivially true. However, the natural language describes concluding that the contour integral \u222b_C f(z) dz equals 2i/3, which should follow from combining the equality in l3 with the evaluation of the definite integral. The logical structure and the contour integral component are both missing."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The assumption l3 in Lean directly states that the definite integral equals (2*Complex.I)/3, but the natural language describes l3 as establishing an equality between a contour integral \u222b_C f(z) dz and the definite integral \u222b_0^1 t^2(1+i)^2 dt. The contour integral is completely missing from the Lean formalization.', 'The conclusion in Lean is identical to the assumption l3, making it trivially true. However, the natural language describes concluding that the contour integral \u222b_C f(z) dz equals 2i/3, which should follow from combining the equality in l3 with the evaluation of the definite integral. The logical structure and the contour integral component are both missing.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    