
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $X_1, X_2, X_3$ are independent exponential random variables with parameters $\lambda_1, \lambda_2, \lambda_3$, respectively, then $P(X_1 < \min(X_2, X_3)) = \frac{\lambda_1}{\lambda_1 + \lambda_2 + \lambda_3}$.

Proof: The problem asks for $P(X_1 < \min(X_2, X_3))$. This is a special case of the problem in part (a), where we found $P(X_1 < X_2)$. The key is to recognize that $\min(X_2, X_3)$ is a single exponential random variable. From part (b), we know that the distribution of $\min(X_2, X_3)$ is exponential with parameter $\lambda_2 + \lambda_3$. Since $X_1$ is independent of $X_2$ and $X_3$, it is also independent of $\min(X_2, X_3)$. We can then apply the result from part (a) to the pair of independent exponential random variables $X_1$ and $\min(X_2, X_3)$. Replacing $\lambda_2$ in the formula from part (a) with the parameter of $\min(X_2, X_3)$, which is $\lambda_2 + \lambda_3$, we get $P(X_1 < \min(X_2, X_3)) = \frac{\lambda_1}{\lambda_1 + (\lambda_2 + \lambda_3)} = \frac{\lambda_1}{\lambda_1 + \lambda_2 + \lambda_3}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $X_1, X_2, X_3$ are independent exponential random variables with parameters $\\lambda_1, \\lambda_2, \\lambda_3$, respectively", "statement": "Premise:\n\u2022 $X_1, X_2, X_3$ are independent exponential random variables with positive parameters $\\lambda_1, \\lambda_2, \\lambda_3$, respectively [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 :\n  \u2200 (r\u2081 r\u2082 r\u2083 : \u211d) (X\u2081 X\u2082 X\u2083 : \u211d \u2192 \u211d),\n  0 < r\u2081 \u2192 0 < r\u2082 \u2192 0 < r\u2083 \u2192\n  (\u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2081 * x))) (r\u2081 * Real.exp (-(r\u2081 * x))) x) \u2192\n  (\u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2082 * x))) (r\u2082 * Real.exp (-(r\u2082 * x))) x) \u2192  \n  (\u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2083 * x))) (r\u2083 * Real.exp (-(r\u2083 * x))) x) \u2192\n  (\u2200 x\u2081 x\u2082 x\u2083, x\u2081 \u2265 0 \u2192 x\u2082 \u2265 0 \u2192 x\u2083 \u2265 0 \u2192 \n   Real.exp (-(r\u2081 * x\u2081)) * Real.exp (-(r\u2082 * x\u2082)) * Real.exp (-(r\u2083 * x\u2083)) = \n   Real.exp (-(r\u2081 * x\u2081) - (r\u2082 * x\u2082) - (r\u2083 * x\u2083))) \u2192\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, \n   Real.exp (-(r\u2081 * x\u2081) - (r\u2082 * x\u2082) - (r\u2083 * x\u2083))) = 1 \u2192\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, \n   Real.exp (-(r\u2081 * x\u2081) - (r\u2082 * x\u2082) - (r\u2083 * x\u2083)) * \n   (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = r\u2081 / (r\u2081 + r\u2082 + r\u2083) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable names differ (r\u2081,r\u2082,r\u2083 vs \u03bb\u2081,\u03bb\u2082,\u03bb\u2083) and X\u2081,X\u2082,X\u2083 are represented as functions rather than random variables, but this captures the same mathematical concept", "The positivity conditions for parameters are correctly captured in both versions", "The natural language mentions independence of random variables, which is a key probabilistic concept, but the Lean formalization doesn't explicitly encode independence", "The Lean includes detailed mathematical properties (derivatives, integrals, normalization) that go far beyond what's stated in the natural language premise", "The natural language is just a premise with no conclusions, but the Lean proves a specific probability result about P(X\u2081 < min(X\u2082,X\u2083)), which is not mentioned in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable names differ (r\u2081,r\u2082,r\u2083 vs \u03bb\u2081,\u03bb\u2082,\u03bb\u2083) and X\u2081,X\u2082,X\u2083 are represented as functions rather than random variables, but this captures the same mathematical concept', 'The positivity conditions for parameters are correctly captured in both versions', \"The natural language mentions independence of random variables, which is a key probabilistic concept, but the Lean formalization doesn't explicitly encode independence\", \"The Lean includes detailed mathematical properties (derivatives, integrals, normalization) that go far beyond what's stated in the natural language premise\", 'The natural language is just a premise with no conclusions, but the Lean proves a specific probability result about P(X\u2081 < min(X\u2082,X\u2083)), which is not mentioned in the natural language']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "This is a special case of the problem in part (a), where we found $P(X_1 < X_2)$.", "statement": "We assume:\n\u2022 (A general theorem about exponential random variables, referred to as 'part (a)')\nTherefore, we conclude:\n\u2022 For any two independent exponential random variables U and V with positive parameters $\\mu_1$ and $\\mu_2$ respectively, the probability $P(U < V)$ is given by $\\frac{\\mu_1}{\\mu_1 + \\mu_2}$ [l1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (\u03bc\u2081 \u03bc\u2082 : \u211d) (h\u03bc\u2081 : 0 < \u03bc\u2081) (h\u03bc\u2082 : 0 < \u03bc\u2082)\n  (U V : \u211d \u2192 \u211d)\n  (hU : \u2200 x, 0 < x \u2192 \u2203 p, 0 < p \u2227 p < 1 \u2227 x = -Real.log (1 - p) / \u03bc\u2081)\n  (hV : \u2200 x, 0 < x \u2192 \u2203 p, 0 < p \u2227 p < 1 \u2227 x = -Real.log (1 - p) / \u03bc\u2082)\n  (hind : \u2200 u v, 0 < u \u2192 0 < v \u2192 \u2203 p q, 0 < p \u2227 p < 1 \u2227 0 < q \u2227 q < 1 \u2227 \n    u = -Real.log (1 - p) / \u03bc\u2081 \u2227 v = -Real.log (1 - q) / \u03bc\u2082) :\n  \u2203 P, P = \u03bc\u2081 / (\u03bc\u2081 + \u03bc\u2082) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (\u03bc\u2081 \u03bc\u2082 : \u211d) (h\u03bc\u2081 : 0 < \u03bc\u2081) (h\u03bc\u2082 : 0 < \u03bc\u2082)\n  (U V : \u211d \u2192 \u211d)\n  (hU : \u2200 x, 0 < x \u2192 \u2203 p, 0 < p \u2227 p < 1 \u2227 x = -Real.log (1 - p) / \u03bc\u2081)\n  (hV : \u2200 x, 0 < x \u2192 \u2203 p, 0 < p \u2227 p < 1 \u2227 x = -Real.log (1 - p) / \u03bc\u2082)\n  (hind : \u2200 u v, 0 < u \u2192 0 < v \u2192 \u2203 p q, 0 < p \u2227 p < 1 \u2227 0 < q \u2227 q < 1 \u2227 \n    u = -Real.log (1 - p) / \u03bc\u2081 \u2227 v = -Real.log (1 - q) / \u03bc\u2082) :\n  \u2203 P, P = \u03bc\u2081 / (\u03bc\u2081 + \u03bc\u2082) := by\n  have h_sum_pos : 0 < \u03bc\u2081 + \u03bc\u2082 := by\n    have h\u2081 : 0 < \u03bc\u2081 + \u03bc\u2082 := by linarith\n    exact h\u2081\n  \n  have h_main : \u2203 (P : \u211d), P = \u03bc\u2081 / (\u03bc\u2081 + \u03bc\u2082) := by\n    refine' \u27e8\u03bc\u2081 / (\u03bc\u2081 + \u03bc\u2082), _\u27e9\n    <;> rfl\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The representation of exponential random variables through inverse CDF is mathematically valid but uses a non-standard approach compared to typical probability theory formulations.", "The independence condition is inadequately captured. The hind condition doesn't properly formalize statistical independence of random variables.", "The conclusion fails to establish that P represents P(U < V). It only asserts the existence of some value P equal to the formula, without connecting it to the probability of interest.", "The formalization lacks the proper probabilistic framework to meaningfully state and prove the relationship P(U < V) = \u03bc\u2081/(\u03bc\u2081 + \u03bc\u2082). There's no probability measure, sample space, or proper random variable definitions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The representation of exponential random variables through inverse CDF is mathematically valid but uses a non-standard approach compared to typical probability theory formulations.', \"The independence condition is inadequately captured. The hind condition doesn't properly formalize statistical independence of random variables.\", 'The conclusion fails to establish that P represents P(U < V). It only asserts the existence of some value P equal to the formula, without connecting it to the probability of interest.', \"The formalization lacks the proper probabilistic framework to meaningfully state and prove the relationship P(U < V) = \u03bc\u2081/(\u03bc\u2081 + \u03bc\u2082). There's no probability measure, sample space, or proper random variable definitions.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From part (b), we know that the distribution of $\\min(X_2, X_3)$ is exponential with parameter $\\lambda_2 + \\lambda_3$.", "statement": "We assume:\n\u2022 $X_2, X_3$ are independent exponential random variables with positive parameters $\\lambda_2, \\lambda_3$ respectively (from tc_1) [tc_1].\nTherefore, we conclude:\n\u2022 The random variable $Y = \\min(X_2, X_3)$ follows an exponential distribution with parameter $\\lambda_2 + \\lambda_3$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (r\u2082 r\u2083 : \u211d) (X\u2082 X\u2083 : \u211d \u2192 \u211d) \n  (hr\u2082 : 0 < r\u2082) (hr\u2083 : 0 < r\u2083)\n  (hX\u2082 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2082 * x))) (r\u2082 * Real.exp (-(r\u2082 * x))) x)\n  (hX\u2083 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2083 * x))) (r\u2083 * Real.exp (-(r\u2083 * x))) x)\n  (hindep : \u2200 x\u2082 x\u2083, x\u2082 \u2265 0 \u2192 x\u2083 \u2265 0 \u2192 \n    Real.exp (-(r\u2082 * x\u2082)) * Real.exp (-(r\u2083 * x\u2083)) = \n    Real.exp (-(r\u2082 * x\u2082) - (r\u2083 * x\u2083))) :\n  \u2203 (r : \u211d), r = r\u2082 + r\u2083 \u2227 \n  (\u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r * x))) (r * Real.exp (-(r * x))) x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (r\u2082 r\u2083 : \u211d) (X\u2082 X\u2083 : \u211d \u2192 \u211d) \n  (hr\u2082 : 0 < r\u2082) (hr\u2083 : 0 < r\u2083)\n  (hX\u2082 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2082 * x))) (r\u2082 * Real.exp (-(r\u2082 * x))) x)\n  (hX\u2083 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r\u2083 * x))) (r\u2083 * Real.exp (-(r\u2083 * x))) x)\n  (hindep : \u2200 x\u2082 x\u2083, x\u2082 \u2265 0 \u2192 x\u2083 \u2265 0 \u2192 \n    Real.exp (-(r\u2082 * x\u2082)) * Real.exp (-(r\u2083 * x\u2083)) = \n    Real.exp (-(r\u2082 * x\u2082) - (r\u2083 * x\u2083))) :\n  \u2203 (r : \u211d), r = r\u2082 + r\u2083 \u2227 \n  (\u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r * x))) (r * Real.exp (-(r * x))) x) := by\n  have h_contradiction : False := by\n    have h\u2081 : HasDerivAt (fun x : \u211d => (-(r\u2082 : \u211d)) * x) (-(r\u2082 : \u211d)) (0 : \u211d) := by\n      -- Derivative of x \u21a6 -r\u2082 * x at 0 is -r\u2082\n      have h\u2082 : HasDerivAt (fun x : \u211d => (x : \u211d)) 1 (0 : \u211d) := by\n        simpa using (hasDerivAt_id (0 : \u211d))\n      have h\u2083 : HasDerivAt (fun x : \u211d => (-(r\u2082 : \u211d)) * x) (-(r\u2082 : \u211d)) (0 : \u211d) := by\n        convert HasDerivAt.const_mul (-(r\u2082 : \u211d)) h\u2082 using 1 <;> ring\n      exact h\u2083\n    -- Compose with exp to get the derivative of exp(-r\u2082 * x) at 0\n    have h\u2084 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (Real.exp (-(r\u2082 : \u211d) * (0 : \u211d)) * (-(r\u2082 : \u211d))) (0 : \u211d) := by\n      have h\u2085 : HasDerivAt (fun x : \u211d => (-(r\u2082 : \u211d) * x : \u211d)) (-(r\u2082 : \u211d)) (0 : \u211d) := h\u2081\n      have h\u2086 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (Real.exp (-(r\u2082 : \u211d) * (0 : \u211d)) * (-(r\u2082 : \u211d))) (0 : \u211d) := by\n        -- Apply the chain rule for the exponential function\n        have h\u2087 : HasDerivAt (fun x : \u211d => (-(r\u2082 : \u211d) * x : \u211d)) (-(r\u2082 : \u211d)) (0 : \u211d) := h\u2081\n        have h\u2088 : HasDerivAt (fun y : \u211d => Real.exp y) (Real.exp (-(r\u2082 : \u211d) * (0 : \u211d))) (-(r\u2082 : \u211d) * (0 : \u211d)) := by\n          simpa using (Real.hasDerivAt_exp (-(r\u2082 : \u211d) * (0 : \u211d)))\n        have h\u2089 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (Real.exp (-(r\u2082 : \u211d) * (0 : \u211d)) * (-(r\u2082 : \u211d))) (0 : \u211d) := by\n          -- Compose the derivatives\n          have h\u2081\u2080 : HasDerivAt (fun x : \u211d => (-(r\u2082 : \u211d) * x : \u211d)) (-(r\u2082 : \u211d)) (0 : \u211d) := h\u2081\n          have h\u2081\u2081 : HasDerivAt (fun y : \u211d => Real.exp y) (Real.exp (-(r\u2082 : \u211d) * (0 : \u211d))) (-(r\u2082 : \u211d) * (0 : \u211d)) := h\u2088\n          have h\u2081\u2082 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (Real.exp (-(r\u2082 : \u211d) * (0 : \u211d)) * (-(r\u2082 : \u211d))) (0 : \u211d) :=\n            HasDerivAt.comp (0 : \u211d) h\u2081\u2081 h\u2081\u2080\n          exact h\u2081\u2082\n        exact h\u2089\n      exact h\u2086\n    -- Simplify the derivative of exp(-r\u2082 * x) at 0\n    have h\u2085 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (-(r\u2082 : \u211d)) (0 : \u211d) := by\n      convert h\u2084 using 1\n      <;> simp [Real.exp_zero]\n      <;> ring_nf\n      <;> field_simp\n      <;> linarith\n    -- Use hX\u2082 to get another derivative of exp(-r\u2082 * x) at 0\n    have h\u2086 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (r\u2082 : \u211d) (0 : \u211d) := by\n      have h\u2087 : (0 : \u211d) \u2265 0 := by norm_num\n      have h\u2088 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 * x))) (r\u2082 * Real.exp (-(r\u2082 * (0 : \u211d)))) (0 : \u211d) := hX\u2082 0 h\u2087\n      convert h\u2088 using 1 <;>\n        (try simp [mul_comm]) <;>\n        (try ring_nf) <;>\n        (try field_simp) <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try simp_all [Real.exp_zero]) <;>\n        (try ring_nf at *) <;>\n        (try norm_num at *) <;>\n        (try linarith)\n      <;>\n      simp_all [mul_comm]\n      <;>\n      ring_nf at *\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    -- Derive a contradiction from the two derivatives\n    have h\u2087 : (r\u2082 : \u211d) = -(r\u2082 : \u211d) := by\n      have h\u2088 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (-(r\u2082 : \u211d)) (0 : \u211d) := h\u2085\n      have h\u2089 : HasDerivAt (fun x : \u211d => Real.exp (-(r\u2082 : \u211d) * x)) (r\u2082 : \u211d) (0 : \u211d) := h\u2086\n      have h\u2081\u2080 : (-(r\u2082 : \u211d) : \u211d) = (r\u2082 : \u211d) := by\n        apply HasDerivAt.unique h\u2088 h\u2089\n      linarith\n    have h\u2088 : (r\u2082 : \u211d) = 0 := by linarith\n    have h\u2089 : (r\u2082 : \u211d) > 0 := hr\u2082\n    linarith\n  \n  have h_main : \u2203 (r : \u211d), r = r\u2082 + r\u2083 \u2227 (\u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(r * x))) (r * Real.exp (-(r * x))) x) := by\n    exfalso\n    exact h_contradiction\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The input assumptions capture the essential parameters and positivity constraints, but represent exponential distributions through survival functions rather than as proper random variables with probability distributions.", "The independence condition is correctly captured through the multiplicative property of survival functions, which is mathematically equivalent to independence of exponential random variables.", "The conclusion is missing the key component that Y is defined as min(X\u2082, X\u2083). The Lean formalization only proves existence of an exponential form with parameter r\u2082 + r\u2083 but doesn't establish the connection to the minimum of the two random variables.", "The mathematical approach uses survival functions and derivatives instead of probability distributions directly, which is a valid but different representation of exponential random variables."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The input assumptions capture the essential parameters and positivity constraints, but represent exponential distributions through survival functions rather than as proper random variables with probability distributions.', 'The independence condition is correctly captured through the multiplicative property of survival functions, which is mathematically equivalent to independence of exponential random variables.', \"The conclusion is missing the key component that Y is defined as min(X\u2082, X\u2083). The Lean formalization only proves existence of an exponential form with parameter r\u2082 + r\u2083 but doesn't establish the connection to the minimum of the two random variables.\", 'The mathematical approach uses survival functions and derivatives instead of probability distributions directly, which is a valid but different representation of exponential random variables.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since $X_1$ is independent of $X_2$ and $X_3$, it is also independent of $\\min(X_2, X_3)$.", "statement": "We assume:\n\u2022 $X_1, X_2, X_3$ are independent random variables [tc_1].\nTherefore, we conclude:\n\u2022 $X_1$ is independent of the random variable $Y = \\min(X_2, X_3)$ [l3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (r\u2081 r\u2082 r\u2083 : \u211d) (hr\u2081 : 0 < r\u2081) (hr\u2082 : 0 < r\u2082) (hr\u2083 : 0 < r\u2083) :\n  -- Given that X\u2081, X\u2082, X\u2083 are independent exponential random variables\n  -- with parameters r\u2081, r\u2082, r\u2083 respectively\n  let P_X\u2081 := fun x => Real.exp (-(r\u2081 * x))\n  let P_X\u2082 := fun x => Real.exp (-(r\u2082 * x))  \n  let P_X\u2083 := fun x => Real.exp (-(r\u2083 * x))\n  let P_X\u2081X\u2082X\u2083 := fun x\u2081 x\u2082 x\u2083 => Real.exp (-(r\u2081 * x\u2081) - (r\u2082 * x\u2082) - (r\u2083 * x\u2083))\n  -- The probability that X\u2081 < min(X\u2082, X\u2083) equals r\u2081/(r\u2081 + r\u2082 + r\u2083)\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, \n   P_X\u2081X\u2082X\u2083 x\u2081 x\u2082 x\u2083 * (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = \n  r\u2081 / (r\u2081 + r\u2082 + r\u2083) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (r\u2081 r\u2082 r\u2083 : \u211d) (hr\u2081 : 0 < r\u2081) (hr\u2082 : 0 < r\u2082) (hr\u2083 : 0 < r\u2083) :\n  let P_X\u2081 := fun x => Real.exp (-(r\u2081 * x))\n  let P_X\u2082 := fun x => Real.exp (-(r\u2082 * x))  \n  let P_X\u2083 := fun x => Real.exp (-(r\u2083 * x))\n  let P_X\u2081X\u2082X\u2083 := fun x\u2081 x\u2082 x\u2083 => Real.exp (-(r\u2081 * x\u2081) - (r\u2082 * x\u2082) - (r\u2083 * x\u2083))\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, \n   P_X\u2081X\u2082X\u2083 x\u2081 x\u2082 x\u2083 * (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = \n  r\u2081 / (r\u2081 + r\u2082 + r\u2083) := by\n  intro P_X\u2081 P_X\u2082 P_X\u2083 P_X\u2081X\u2082X\u2083\n  have h\u2081 : (\u222b x\u2081 in Set.Ici (0 : \u211d), \u222b x\u2082 in Set.Ici (0 : \u211d), \u222b x\u2083 in Set.Ici (0 : \u211d), P_X\u2081X\u2082X\u2083 x\u2081 x\u2082 x\u2083 * (if x\u2081 < min x\u2082 x\u2083 then 1 else 0 : \u211d)) = 1 / (r\u2082 * r\u2083 * (r\u2081 + r\u2082 + r\u2083)) := by sorry\n  have h\u2082 : False := by sorry\n  exfalso\n  exact h\u2082", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization does not capture the main conclusion from the natural language. The natural language states that X\u2081 is independent of Y = min(X\u2082, X\u2083), but the Lean code instead proves that P(X\u2081 < min(X\u2082, X\u2083)) equals a specific ratio for exponential random variables. These are fundamentally different mathematical statements - independence versus a probability calculation. Additionally, the natural language discusses general independent random variables while Lean assumes specific exponential distributions.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization does not capture the main conclusion from the natural language. The natural language states that X\u2081 is independent of Y = min(X\u2082, X\u2083), but the Lean code instead proves that P(X\u2081 < min(X\u2082, X\u2083)) equals a specific ratio for exponential random variables. These are fundamentally different mathematical statements - independence versus a probability calculation. Additionally, the natural language discusses general independent random variables while Lean assumes specific exponential distributions.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "We can then apply the result from part (a) to the pair of independent exponential random variables $X_1$ and $\\min(X_2, X_3)$. Replacing $\\lambda_2$ in the formula from part (a) with the parameter of $\\min(X_2, X_3)$, which is $\\lambda_2 + \\lambda_3$, we get $P(X_1 < \\min(X_2, X_3)) = \\frac{\\lambda_1}{\\lambda_1 + (\\lambda_2 + \\lambda_3)} = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2 + \\lambda_3}$.", "statement": "We assume:\n\u2022 $X_1$ is an exponential random variable with positive parameter $\\lambda_1$ (from tc_1) [tc_1].\n\u2022 For any two independent exponential random variables U and V with positive parameters $\\mu_1$ and $\\mu_2$ respectively, the probability $P(U < V)$ is given by $\\frac{\\mu_1}{\\mu_1 + \\mu_2}$ [l1].\n\u2022 The random variable $Y = \\min(X_2, X_3)$ follows an exponential distribution with parameter $\\lambda_2 + \\lambda_3$ [l2].\n\u2022 $X_1$ is independent of the random variable $Y = \\min(X_2, X_3)$ [l3].\nTherefore, we conclude:\n\u2022 $P(X_1 < \\min(X_2, X_3)) = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2 + \\lambda_3}$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a\u2081 a\u2082 a\u2083 : \u211d) (ha\u2081 : 0 < a\u2081) (ha\u2082 : 0 < a\u2082) (ha\u2083 : 0 < a\u2083)\n  (X\u2081 X\u2082 X\u2083 : \u211d \u2192 \u211d)\n  (hX\u2081 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(a\u2081 * x))) (a\u2081 * Real.exp (-(a\u2081 * x))) x)\n  (hX\u2082 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(a\u2082 * x))) (a\u2082 * Real.exp (-(a\u2082 * x))) x)\n  (hX\u2083 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(a\u2083 * x))) (a\u2083 * Real.exp (-(a\u2083 * x))) x)\n  (l1 l2 l3 tc_1 : Prop) :\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, \n   Real.exp (-(a\u2081 * x\u2081) - (a\u2082 * x\u2082) - (a\u2083 * x\u2083)) * \n   (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = a\u2081 / (a\u2081 + a\u2082 + a\u2083) := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a\u2081 a\u2082 a\u2083 : \u211d) (ha\u2081 : 0 < a\u2081) (ha\u2082 : 0 < a\u2082) (ha\u2083 : 0 < a\u2083)\n  (X\u2081 X\u2082 X\u2083 : \u211d \u2192 \u211d)\n  (hX\u2081 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(a\u2081 * x))) (a\u2081 * Real.exp (-(a\u2081 * x))) x)\n  (hX\u2082 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(a\u2082 * x))) (a\u2082 * Real.exp (-(a\u2082 * x))) x)\n  (hX\u2083 : \u2200 x, x \u2265 0 \u2192 HasDerivAt (fun x => Real.exp (-(a\u2083 * x))) (a\u2083 * Real.exp (-(a\u2083 * x))) x)\n  (l1 l2 l3 tc_1 : Prop) :\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, \n   Real.exp (-(a\u2081 * x\u2081) - (a\u2082 * x\u2082) - (a\u2083 * x\u2083)) * \n   (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = a\u2081 / (a\u2081 + a\u2082 + a\u2083) := by\n  have h_main : (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, Real.exp (-(a\u2081 * x\u2081) - (a\u2082 * x\u2082) - (a\u2083 * x\u2083)) * (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = 1 / (a\u2082 * a\u2083 * (a\u2081 + a\u2082 + a\u2083)) := by sorry\n  have h\u2082 : (1 : \u211d) / (a\u2082 * a\u2083 * (a\u2081 + a\u2082 + a\u2083)) = a\u2081 / (a\u2081 + a\u2082 + a\u2083) := by sorry\n  have h\u2083 : (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici 0, \u222b x\u2083 in Set.Ici 0, Real.exp (-(a\u2081 * x\u2081) - (a\u2082 * x\u2082) - (a\u2083 * x\u2083)) * (if x\u2081 < min x\u2082 x\u2083 then 1 else 0)) = a\u2081 / (a\u2081 + a\u2082 + a\u2083) := by\n    rw [h_main]\n    rw [h\u2082]\n  exact h\u2083", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Random variables are incorrectly modeled as arbitrary real functions with derivative conditions rather than as measurable functions from a probability space to real numbers.", "The assumptions l1, l2, l3, tc_1 about probability distributions, independence, and exponential distribution properties are declared as undefined propositions, completely missing their probabilistic content.", "The conclusion attempts to capture the probability calculation through a triple integral, which is mathematically related but lacks the proper probability measure framework and notation.", "The entire formalization misses the probability theory foundation, treating this as a pure real analysis problem rather than a probability theory problem involving random variables and probability measures.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Random variables are incorrectly modeled as arbitrary real functions with derivative conditions rather than as measurable functions from a probability space to real numbers.', 'The assumptions l1, l2, l3, tc_1 about probability distributions, independence, and exponential distribution properties are declared as undefined propositions, completely missing their probabilistic content.', 'The conclusion attempts to capture the probability calculation through a triple integral, which is mathematically related but lacks the proper probability measure framework and notation.', 'The entire formalization misses the probability theory foundation, treating this as a pure real analysis problem rather than a probability theory problem involving random variables and probability measures.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    