
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $a, b, c$ such that $a+b+c=3$, the following inequality holds: $a b c+\\frac{12}{a b+b c+a c} \\geq 5$.

Proof: Let $a, b, c$ be positive real numbers with $a+b+c=3$. To prove $abc + rac{12}{ab+bc+ca} \ge 5$, note that $abc \ge rac{4(ab+bc+ca)}{3} - 3$ for positive $a,b,c$ with sum 3. Setting $X = ab+bc+ca$, the inequality becomes $rac{4X}{3}-3 + rac{12}{X} \ge 5$, which simplifies to $rac{4X}{3} + rac{12}{X} - 8 \ge 0$. Multiplying by $3X$ gives $4(X-3)^2 \ge 0$, which is always true. Hence, $abc + rac{12}{ab+bc+ca} \ge 5$, with equality when $a=b=c=1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $a, b, c$ be positive real numbers with $a+b+c=3$.", "statement": "Premise:\n\u2022 $a, b, c$ are positive real numbers and $a+b+c=3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3) :\n  a * b * c + 12 / (a * b + b * c + a * c) \u2265 5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c are positive real numbers through type declaration and positivity constraints", "The sum condition a + b + c = 3 is exactly matched in the Lean formalization", "The natural language states this is just a premise with no conclusions, but the Lean formalization includes a specific inequality conclusion that was not mentioned in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c are positive real numbers through type declaration and positivity constraints', 'The sum condition a + b + c = 3 is exactly matched in the Lean formalization', 'The natural language states this is just a premise with no conclusions, but the Lean formalization includes a specific inequality conclusion that was not mentioned in the natural language statement']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Setting $X = ab+bc+ca$", "statement": "We assume:\n\u2022 $a,b,c$ are positive real numbers with $a+b+c=3$ [tc_1].\nDefinition:\n\u2022 Let $X$ be a real number such that $X = ab+bc+ca$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 :\n  \u2200 (a b c : \u211d), \n    (0 < a \u2227 0 < b \u2227 0 < c \u2227 a + b + c = 3) \u2192\n    let X := a * b + b * c + a * c\n    X > 0 \u2227 12 / X + a * b * c \u2265 5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c are positive real numbers through the type declaration and positivity conditions", "The Lean formalization exactly matches the sum condition a + b + c = 3", "While the Lean code does define X = ab + bc + ca as stated, it introduces additional conclusions (X > 0 and 12/X + abc \u2265 5) that are not present in the natural language statement. The natural language only defines X, but the Lean theorem proves additional properties about X that contradict the simple definitional nature of the original statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c are positive real numbers through the type declaration and positivity conditions', 'The Lean formalization exactly matches the sum condition a + b + c = 3', 'While the Lean code does define X = ab + bc + ca as stated, it introduces additional conclusions (X > 0 and 12/X + abc \u2265 5) that are not present in the natural language statement. The natural language only defines X, but the Lean theorem proves additional properties about X that contradict the simple definitional nature of the original statement']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "note that $abc \\ge \frac{4(ab+bc+ca)}{3} - 3$ for positive $a,b,c$ with sum 3.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers and $a+b+c=3$ [tc_1].\nTherefore, we conclude:\n\u2022 $abc \\ge \frac{4(ab+bc+ca)}{3} - 3$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3) :\n  a * b * c \u2265 (4 * (a * b + b * c + a * c)) / 3 - 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3) :\n  a * b * c \u2265 (4 * (a * b + b * c + a * c)) / 3 - 3 := by\n  have h_schur : a^3 + b^3 + c^3 + 3 * a * b * c \u2265 a^2 * (b + c) + b^2 * (a + c) + c^2 * (a + b) := by\n    nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),\n      mul_nonneg ha.le hb.le, mul_nonneg hb.le hc.le, mul_nonneg hc.le ha.le,\n      mul_nonneg (sq_nonneg (a - b)) ha.le, mul_nonneg (sq_nonneg (b - c)) hb.le,\n      mul_nonneg (sq_nonneg (c - a)) hc.le, mul_nonneg (sq_nonneg (a - b)) hb.le,\n      mul_nonneg (sq_nonneg (b - c)) hc.le, mul_nonneg (sq_nonneg (c - a)) ha.le]\n  \n  have h_sum_sq : a^2 * (b + c) + b^2 * (a + c) + c^2 * (a + b) = (a + b + c) * (a * b + b * c + a * c) - 3 * a * b * c := by\n    have h1 : a^2 * (b + c) + b^2 * (a + c) + c^2 * (a + b) = a^2 * b + a^2 * c + b^2 * a + b^2 * c + c^2 * a + c^2 * b := by\n      ring\n    have h2 : (a + b + c) * (a * b + b * c + a * c) - 3 * a * b * c = a^2 * b + a^2 * c + b^2 * a + b^2 * c + c^2 * a + c^2 * b := by\n      ring_nf\n      <;>\n      nlinarith [ha, hb, hc]\n    linarith\n  \n  have h_main : 27 + 9 * (a * b * c) \u2265 4 * (a + b + c) * (a * b + b * c + a * c) := by\n    have h1 : a ^ 3 + b ^ 3 + c ^ 3 + 3 * a * b * c \u2265 a ^ 2 * (b + c) + b ^ 2 * (a + c) + c ^ 2 * (a + b) := h_schur\n    have h2 : a ^ 2 * (b + c) + b ^ 2 * (a + c) + c ^ 2 * (a + b) = (a + b + c) * (a * b + b * c + a * c) - 3 * a * b * c := h_sum_sq\n    have h3 : (a + b + c) ^ 3 = a ^ 3 + b ^ 3 + c ^ 3 + 3 * (a + b + c) * (a * b + b * c + a * c) - 3 * a * b * c := by\n      ring\n    have h4 : (a + b + c) ^ 3 = 27 := by\n      rw [h_sum]\n      <;> norm_num\n    have h5 : a ^ 3 + b ^ 3 + c ^ 3 = 27 - 3 * (a + b + c) * (a * b + b * c + a * c) + 3 * a * b * c := by\n      linarith\n    have h6 : 27 - 3 * (a + b + c) * (a * b + b * c + a * c) + 3 * a * b * c + 3 * a * b * c \u2265 (a + b + c) * (a * b + b * c + a * c) - 3 * a * b * c := by\n      linarith\n    have h7 : 27 + 9 * (a * b * c) \u2265 4 * (a + b + c) * (a * b + b * c + a * c) := by\n      nlinarith [h_sum]\n    exact h7\n  \n  have h_final : a * b * c \u2265 (4 * (a * b + b * c + a * c)) / 3 - 3 := by\n    have h\u2081 : 27 + 9 * (a * b * c) \u2265 4 * (a + b + c) * (a * b + b * c + a * c) := h_main\n    have h\u2082 : a + b + c = 3 := h_sum\n    have h\u2083 : 27 + 9 * (a * b * c) \u2265 4 * 3 * (a * b + b * c + a * c) := by\n      calc\n        27 + 9 * (a * b * c) \u2265 4 * (a + b + c) * (a * b + b * c + a * c) := h\u2081\n        _ = 4 * 3 * (a * b + b * c + a * c) := by rw [h\u2082]\n    have h\u2084 : 27 + 9 * (a * b * c) \u2265 12 * (a * b + b * c + a * c) := by\n      linarith\n    have h\u2085 : 9 * (a * b * c) \u2265 12 * (a * b + b * c + a * c) - 27 := by\n      linarith\n    have h\u2086 : 3 * (a * b * c) \u2265 4 * (a * b + b * c + a * c) - 9 := by\n      linarith\n    have h\u2087 : a * b * c \u2265 (4 * (a * b + b * c + a * c)) / 3 - 3 := by\n      linarith\n    exact h\u2087\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate type annotations and strict inequality constraints.", "The sum constraint a+b+c=3 is exactly preserved in the Lean formalization.", "The main inequality is correctly translated with proper operator precedence and mathematical notation conversion from natural language to Lean syntax.", "The logical structure properly captures the assumption-conclusion relationship using Lean's theorem format with hypotheses and goal."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Let $a, b, c$ be positive real numbers", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1].\n\u2022 Let $X = ab+bc+ca$ [def_1].\nTherefore, we conclude:\n\u2022 $X > 0$ [l2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3)\n  (X : \u211d) (hX : X = a * b + b * c + a * c) :\n  X > 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3)\n  (X : \u211d) (hX : X = a * b + b * c + a * c) :\n  X > 0 := by\n  have h_ab_pos : 0 < a * b := by\n    -- Prove that the product of two positive numbers is positive\n    have h : 0 < a * b := mul_pos ha hb\n    exact h\n  \n  have h_bc_pos : 0 < b * c := by\n    -- Prove that the product of two positive numbers is positive\n    have h : 0 < b * c := mul_pos hb hc\n    exact h\n  \n  have h_ca_pos : 0 < a * c := by\n    -- Prove that the product of two positive numbers is positive\n    have h : 0 < a * c := mul_pos ha hc\n    exact h\n  \n  have h_sum_pos : 0 < a * b + b * c + a * c := by\n    -- Since all terms are positive, their sum is also positive\n    have h\u2081 : 0 < a * b := h_ab_pos\n    have h\u2082 : 0 < b * c := h_bc_pos\n    have h\u2083 : 0 < a * c := h_ca_pos\n    -- Summing positive terms gives a positive result\n    have h\u2084 : 0 < a * b + b * c := by linarith\n    have h\u2085 : 0 < a * b + b * c + a * c := by linarith\n    exact h\u2085\n  \n  have h_X_pos : X > 0 := by\n    -- Substitute the expression for X into the inequality\n    rw [hX]\n    -- Since a*b + b*c + a*c is positive, X is positive\n    linarith\n  \n  exact h_X_pos", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations (a b c : \u211d) correctly represent the real numbers a, b, c", "Positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) correctly capture that a, b, c are positive real numbers", "The constraint (h_sum : a + b + c = 3) introduces an additional mathematical condition that is not mentioned anywhere in the natural language premise. This is a major inconsistency as it adds a substantive mathematical constraint not present in the original problem", "The definition (hX : X = a * b + b * c + a * c) correctly captures X = ab+bc+ca from the natural language", "The conclusion X > 0 correctly represents the stated conclusion"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations (a b c : \u211d) correctly represent the real numbers a, b, c', 'Positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) correctly capture that a, b, c are positive real numbers', 'The constraint (h_sum : a + b + c = 3) introduces an additional mathematical condition that is not mentioned anywhere in the natural language premise. This is a major inconsistency as it adds a substantive mathematical constraint not present in the original problem', 'The definition (hX : X = a * b + b * c + a * c) correctly captures X = ab+bc+ca from the natural language', 'The conclusion X > 0 correctly represents the stated conclusion']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "$4(X-3)^2 \\ge 0$, which is always true.", "statement": "We assume:\n\u2022 Let $X$ be a real number defined as $X = ab+bc+ca$ [def_1].\nTherefore, we conclude:\n\u2022 $4(X-3)^2 \\ge 0$ [l3].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_sum : a + b + c = 3)\n  (X : \u211d) (hX : X = a * b + b * c + a * c) :\n  4 * (X - 3)^2 \u2265 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_sum : a + b + c = 3)\n  (X : \u211d) (hX : X = a * b + b * c + a * c) :\n  4 * (X - 3)^2 \u2265 0 := by\n  have h1 : (X - 3)^2 \u2265 0 := by\n    nlinarith [sq_nonneg (X - 3)]\n  \n  have h2 : 4 * (X - 3)^2 \u2265 0 := by\n    have h3 : (4 : \u211d) \u2265 0 := by norm_num\n    nlinarith\n  \n  exact h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The definition of X as ab+bc+ca is correctly captured in Lean with proper variable declarations.", "The Lean formalization includes additional constraints (positivity and sum condition) not mentioned in natural language, but these are extra conditions that don't contradict the original statement.", "The conclusion 4(X-3)\u00b2 \u2265 0 is perfectly translated to Lean syntax with identical mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "which simplifies to $\\frac{4X}{3} + \\frac{12}{X} - 8 \\ge 0$. Multiplying by $3X$ gives $4(X-3)^2 \\ge 0$.", "statement": "We assume:\n\u2022 Let $X$ be a real number defined as $X = ab+bc+ca$ [def_1].\n\u2022 $X > 0$ [l2].\n\u2022 $4(X-3)^2 \\ge 0$ [l3].\nTherefore, we conclude:\n\u2022 $\\frac{4X}{3} + \\frac{12}{X} - 8 \\ge 0$ [l4].", "dependencies": ["l2", "l3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (X : \u211d) \n  (hX_pos : X > 0) \n  (hX_sq : 4 * (X - 3)^2 \u2265 0) \n  (hX_def : \u2203 (a b c : \u211d), X = a * b + b * c + c * a) :\n  4 * X / 3 + 12 / X - 8 \u2265 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (X : \u211d) \n  (hX_pos : X > 0) \n  (hX_sq : 4 * (X - 3)^2 \u2265 0) \n  (hX_def : \u2203 (a b c : \u211d), X = a * b + b * c + c * a) :\n  4 * X / 3 + 12 / X - 8 \u2265 0 := by\n  have h_main : 4 * X / 3 + 12 / X - 8 = 4 * (X - 3)^2 / (3 * X) := by\n    have h\u2081 : 4 * X / 3 + 12 / X - 8 = (4 * X ^ 2 + 36 - 24 * X) / (3 * X) := by\n      have h\u2081\u2080 : X \u2260 0 := by linarith\n      field_simp [h\u2081\u2080]\n      ring\n      <;> field_simp [h\u2081\u2080]\n      <;> ring\n    have h\u2082 : 4 * (X - 3) ^ 2 / (3 * X) = (4 * X ^ 2 + 36 - 24 * X) / (3 * X) := by\n      have h\u2082\u2080 : X \u2260 0 := by linarith\n      have h\u2082\u2081 : 4 * (X - 3) ^ 2 = 4 * X ^ 2 + 36 - 24 * X := by\n        ring\n      rw [h\u2082\u2081]\n      <;> field_simp [h\u2082\u2080]\n      <;> ring\n    linarith\n  \n  have h_nonneg : 4 * (X - 3)^2 / (3 * X) \u2265 0 := by\n    have h\u2081 : (X - 3) ^ 2 \u2265 0 := by\n      nlinarith\n    have h\u2082 : 4 * (X - 3) ^ 2 \u2265 0 := by\n      nlinarith\n    have h\u2083 : 3 * X > 0 := by\n      nlinarith\n    have h\u2084 : 4 * (X - 3) ^ 2 / (3 * X) \u2265 0 := by\n      apply div_nonneg\n      \u00b7 nlinarith\n      \u00b7 nlinarith\n    exact h\u2084\n  \n  have h_final : 4 * X / 3 + 12 / X - 8 \u2265 0 := by\n    rw [h_main]\n    exact h_nonneg\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declaration and definition are correctly captured. The existential quantification properly represents the definition of X as a sum of products.", "The positivity condition X > 0 is perfectly translated.", "The constraint 4(X-3)\u00b2 \u2265 0 is accurately represented in Lean notation.", "The conclusion inequality is correctly formalized with equivalent mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "the inequality becomes $\\frac{4X}{3}-3 + \\frac{12}{X} \\ge 5$, which simplifies to $\\frac{4X}{3} + \\frac{12}{X} - 8 \\ge 0$.", "statement": "We assume:\n\u2022 $\\frac{4X}{3} + \\frac{12}{X} - 8 \\ge 0$ [l4].\nTherefore, we conclude:\n\u2022 $\\frac{4X}{3} - 3 + \\frac{12}{X} \\ge 5$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (X : \u211d) \n  (hX_pos : X > 0)\n  (l4 : 4 * X / 3 + 12 / X - 8 \u2265 0) :\n  4 * X / 3 - 3 + 12 / X \u2265 5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (X : \u211d) \n  (hX_pos : X > 0)\n  (l4 : 4 * X / 3 + 12 / X - 8 \u2265 0) :\n  4 * X / 3 - 3 + 12 / X \u2265 5 := by\n  have h\u2081 : 4 * X / 3 + 12 / X \u2265 8 := by\n    have h\u2081\u2080 : 4 * X / 3 + 12 / X - 8 \u2265 0 := l4\n    linarith\n  \n  have h\u2082 : 4 * X / 3 - 3 + 12 / X = (4 * X / 3 + 12 / X) - 3 := by\n    ring_nf\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try field_simp [hX_pos.ne']) <;>\n    (try ring_nf) <;>\n    (try nlinarith)\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (X - 3)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (X + 3)]\n      })\n  \n  have h\u2083 : (4 * X / 3 + 12 / X) - 3 \u2265 5 := by\n    have h\u2083\u2081 : 4 * X / 3 + 12 / X \u2265 8 := h\u2081\n    linarith\n  \n  have h\u2084 : 4 * X / 3 - 3 + 12 / X \u2265 5 := by\n    linarith\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical logic from the natural language. The premise and conclusion are accurately translated, and the additional condition X > 0 is a reasonable mathematical requirement for the expressions to be well-defined, even though not explicitly stated in the natural language. The logical relationship between the premise and conclusion is preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Hence, $abc + \\frac{12}{ab+bc+ca} \\ge 5$.", "statement": "We assume:\n\u2022 $a,b,c$ are positive real numbers with $a+b+c=3$ [tc_1].\n\u2022 Let $X = ab+bc+ca$ [def_1].\n\u2022 $abc \\ge \\frac{4(ab+bc+ca)}{3} - 3$ [l1].\n\u2022 $\\frac{4X}{3} - 3 + \\frac{12}{X} \\ge 5$ [l5].\nTherefore, we conclude:\n\u2022 $abc + \\frac{12}{ab+bc+ca} \\ge 5$ [ts_1].", "dependencies": ["tc_1", "def_1", "l1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3)\n  (X : \u211d) (hX_def : X = a * b + b * c + a * c)\n  (hX_pos : 0 < X)\n  (l1 : a * b * c \u2265 (4 * X) / 3 - 3)\n  (l5 : (4 * X) / 3 - 3 + 12 / X \u2265 5) :\n  a * b * c + 12 / X \u2265 5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 3)\n  (X : \u211d) (hX_def : X = a * b + b * c + a * c)\n  (hX_pos : 0 < X)\n  (l1 : a * b * c \u2265 (4 * X) / 3 - 3)\n  (l5 : (4 * X) / 3 - 3 + 12 / X \u2265 5) :\n  a * b * c + 12 / X \u2265 5 := by\n  have h_main : a * b * c + 12 / X \u2265 (4 * X) / 3 - 3 + 12 / X := by\n    have h2 : a * b * c + 12 / X \u2265 ((4 * X) / 3 - 3) + 12 / X := by\n      -- Add 12/X to both sides of l1\n      have h3 : a * b * c \u2265 (4 * X) / 3 - 3 := l1\n      have h4 : 12 / X = 12 / X := rfl\n      -- Use linear arithmetic to add the inequalities\n      have h5 : a * b * c + 12 / X \u2265 ((4 * X) / 3 - 3) + 12 / X := by\n        linarith\n      exact h5\n    -- Simplify the right-hand side\n    have h6 : ((4 * X) / 3 - 3) + 12 / X = (4 * X) / 3 - 3 + 12 / X := by ring\n    linarith\n  \n  have h_final : a * b * c + 12 / X \u2265 5 := by\n    have h2 : a * b * c + 12 / X \u2265 (4 * X) / 3 - 3 + 12 / X := h_main\n    have h3 : (4 * X) / 3 - 3 + 12 / X \u2265 5 := l5\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variables and constraints are correctly formalized with proper type declarations and positivity conditions", "Definition of X correctly captures the symmetric sum ab+bc+ca using Lean multiplication notation", "The additional constraint hX_pos : 0 < X is a logical consequence of the given conditions and represents acceptable additional detail", "Assumption l1 is perfectly translated using the defined variable X", "Assumption l5 is perfectly translated with correct operator precedence and notation", "The conclusion correctly uses X in place of ab+bc+ca, maintaining semantic equivalence with the natural language statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    