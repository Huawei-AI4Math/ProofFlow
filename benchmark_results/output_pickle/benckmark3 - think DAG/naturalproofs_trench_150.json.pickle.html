
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $f$ be a real-valued function defined on a subset of $\R^n,$
 and let the
vector-valued function $\mathbf{G}=(g_1,g_2, \dots,g_n)$ be defined on a
domain $D_\mathbf{G}$ in $\R^m.$ Let the set
$$
T=\set{\mathbf{U}}{\mathbf{U}\in D_{\mathbf{G}}\mbox{\quad and \quad}
\mathbf{G}(\mathbf{U})\in D_f}
$$
$($Figure~\ref{figure:5.2.3}$)$,
 be
nonempty$,$ and define the real-valued composite function
$$
h=f\circ\mathbf{G}
$$
on $T$ by
$$
h(\mathbf{U})=f(\mathbf{G}(\mathbf{U})),\quad \mathbf{U}\in T.
$$
Now suppose that  $\mathbf{U}_0$ is in $T$ and is a limit point of $T,$
$\mathbf{G}$ is continuous at $\mathbf{U}_0,$ and $f$ is continuous at
$\mathbf{X}_0=\mathbf{G}(\mathbf{U}_0).$ Then $h$ is continuous at
$\mathbf{U}_0.$

Proof: Suppose that  $\epsilon>0$. Since $f$ is continuous at
$\mathbf{X}_0=\mathbf{G}(\mathbf{U}_0)$, there is an $\epsilon_1>0$
such that
\begin{equation}\label{eq:5.2.17}
|f(\mathbf{X})-f(\mathbf{G}(\mathbf{U}_0))|<\epsilon
\end{equation}
if
\begin{equation}\label{eq:5.2.18}
|\mathbf{X}-\mathbf{G}(\mathbf{U}_0)|<\epsilon_1\mbox{\quad and\quad}
\mathbf{X}\in D_f.
\end{equation}
Since $\mathbf{G}$ is continuous at $\mathbf{U}_0$, there is a $\delta>0$
such that
$$
|\mathbf{G}(\mathbf{U})-\mathbf{G}(\mathbf{U}_0)|<\epsilon_1
\mbox{\quad if\quad} |\mathbf{U}-\mathbf{U}_0|<
\delta\mbox{\quad and\quad}\mathbf{U}\in D_\mathbf{G}.
$$
By taking $\mathbf{X}=\mathbf{G}(\mathbf{U})$ in \eqref{eq:5.2.17} and
\eqref{eq:5.2.18}, we see that
$$
|h(\mathbf{U})-h(\mathbf{U}_0)|=|f(\mathbf{G}(\mathbf{U})
-f(\mathbf{G}(\mathbf{U}_0))|<\epsilon
$$
if
$$
|\mathbf{U}-\mathbf{U}_0|<\delta\mbox{\quad and\quad}\mathbf{U}\in T.
$$
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f$ be a real-valued function defined on a subset of $\\R^n,$ and let the vector-valued function $\\mathbf{G}=(g_1,g_2, \\dots,g_n)$ be defined on a domain $D_\\mathbf{G}$ in $\\R^m.$", "statement": "Premise:\n\u2022 f is a real-valued function defined on a domain D_f \u2286 \u211d^n, and G is a vector-valued function defined on a domain D_G \u2286 \u211d^m [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem composite_function_continuity \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (hU0_limit : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U, \u2016U - U_0\u2016 < \u03b4 \u2192 \u2016G U - G U_0\u2016 < \u03b5)\n  (hG_cont : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U, \u2016U - U_0\u2016 < \u03b4 \u2192 \u2016G U - G U_0\u2016 < \u03b5)\n  (hf_cont : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 X, \u2016X - G U_0\u2016 < \u03b4 \u2192 |f X - f (G U_0)| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language mentions f is defined on a domain D_f \u2286 \u211d^n, but the Lean formalization defines f as a total function (Fin n \u2192 \u211d) \u2192 \u211d without explicitly restricting to a subdomain. However, the Lean version includes additional continuity conditions not mentioned in the natural language premise.", "The Lean formalization correctly captures G as a vector-valued function from \u211d^m to \u211d^n, which matches the natural language description of G being vector-valued on domain D_G \u2286 \u211d^m. The Lean version uses (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d) which is the standard way to represent this in Lean."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The natural language mentions f is defined on a domain D_f \u2286 \u211d^n, but the Lean formalization defines f as a total function (Fin n \u2192 \u211d) \u2192 \u211d without explicitly restricting to a subdomain. However, the Lean version includes additional continuity conditions not mentioned in the natural language premise.', 'The Lean formalization correctly captures G as a vector-valued function from \u211d^m to \u211d^n, which matches the natural language description of G being vector-valued on domain D_G \u2286 \u211d^m. The Lean version uses (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d) which is the standard way to represent this in Lean.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let the set $T=\\set{\\mathbf{U}}{\\mathbf{U}\\in D_{\\mathbf{G}}\\mbox{\\quad and \\quad} \\mathbf{G}(\\mathbf{U})\\in D_f}$, be nonempty, and define the real-valued composite function $h=f\\circ\\mathbf{G}$ on $T$ by $h(\\mathbf{U})=f(\\mathbf{G}(\\mathbf{U})),\\quad \\mathbf{U}\\in T.$", "statement": "Premise:\n\u2022 Given f and G as in [tc_1], the set T = {U \u2208 D_G | G(U) \u2208 D_f} is non-empty, and the composite function h on T is defined by h(U) = f(G(U)) [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem composite_function_continuity \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d))\n  (D_f : Set (Fin n \u2192 \u211d))\n  (T : Set (Fin m \u2192 \u211d))\n  (hT : T = {U \u2208 D_G | G U \u2208 D_f})\n  (hU0_in_T : U_0 \u2208 T)\n  (hG_cont : \u2200 U \u2208 T, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 T, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 T, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean provides specific type signatures for f and G as functions between finite-dimensional real vector spaces, while the natural language only references [tc_1] without specifying the exact nature of f and G. This is a reasonable interpretation but adds specificity not present in the natural language.", "The set T definition matches exactly between natural language and Lean formalization.", "Both express that T is non-empty - natural language states it directly, Lean expresses it by asserting existence of U_0 \u2208 T.", "The natural language simply states that h is defined on T by h(U) = f(G(U)), but the Lean adds continuity assumptions for both G and f that are not mentioned in the natural language conditions.", "The natural language conclusion is about the existence of the composite function h, but the Lean conclusion is about the continuity of the composite function f(G(U)). These are fundamentally different mathematical statements - existence versus continuity."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean provides specific type signatures for f and G as functions between finite-dimensional real vector spaces, while the natural language only references [tc_1] without specifying the exact nature of f and G. This is a reasonable interpretation but adds specificity not present in the natural language.', 'The set T definition matches exactly between natural language and Lean formalization.', 'Both express that T is non-empty - natural language states it directly, Lean expresses it by asserting existence of U_0 \u2208 T.', 'The natural language simply states that h is defined on T by h(U) = f(G(U)), but the Lean adds continuity assumptions for both G and f that are not mentioned in the natural language conditions.', 'The natural language conclusion is about the existence of the composite function h, but the Lean conclusion is about the continuity of the composite function f(G(U)). These are fundamentally different mathematical statements - existence versus continuity.']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Now suppose that  $\\mathbf{U}_0$ is in $T$ and is a limit point of $T,$ $\\mathbf{G}$ is continuous at $\\mathbf{U}_0,$ and $f$ is continuous at $\\mathbf{X}_0=\\mathbf{G}(\\mathbf{U}_0).$", "statement": "Premise:\n\u2022 Given the setting in [tc_1] and [tc_2], U\u2080 is a point in T and a limit point of T. G is continuous at U\u2080. f is continuous at X\u2080 = G(U\u2080) [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n m : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (U_0 : Fin m \u2192 \u211d)\n\nvariable (D_G : Set (Fin m \u2192 \u211d)) (D_f : Set (Fin n \u2192 \u211d))\nvariable (T : Set (Fin m \u2192 \u211d))\nvariable (hT : T = {U \u2208 D_G | G U \u2208 D_f})\nvariable (hU0_in_T : U_0 \u2208 T)\n\nvariable (hG_cont : \u2200 U \u2208 T, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 T, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\nvariable (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5)\n\nvariable (hU0_limit : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 T, \u2016U - U_0\u2016 < \u03b4 \u2192 \u2016G U - G U_0\u2016 < \u03b5)\n\ntheorem composite_function_continuity : \n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 T, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language explicitly states it's a premise with no new conclusions derived, only establishing given conditions. However, the Lean theorem proves a specific result about composite function continuity using epsilon-delta definition. This is a fundamental mismatch between a premise statement (natural language) and a theorem proving a conclusion (Lean)."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language explicitly states it's a premise with no new conclusions derived, only establishing given conditions. However, the Lean theorem proves a specific result about composite function continuity using epsilon-delta definition. This is a fundamental mismatch between a premise statement (natural language) and a theorem proving a conclusion (Lean).\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Suppose that  $\\epsilon>0$. Since $f$ is continuous at $\\mathbf{X}_0=\\mathbf{G}(\\mathbf{U}_0)$, there is an $\\epsilon_1>0$ such that $|f(\\mathbf{X})-f(\\mathbf{G}(\\mathbf{U}_0))|<\\epsilon$ if $|\\mathbf{X}-\\mathbf{G}(\\mathbf{U}_0)|<\\epsilon_1\\mbox{\\quad and\\quad} \\mathbf{X}\\in D_f.$", "statement": "We assume:\n\u2022 f is a real-valued function defined on D_f \u2286 \u211d^n [tc_1]\n\u2022 f is continuous at X\u2080 = G(U\u2080) [tc_3]\n\u2022 An arbitrary \u03b5 > 0 is given.\nTherefore, we conclude:\n\u2022 There exists an \u03b5\u2081 > 0 such that for any X \u2208 D_f, if |X - G(U\u2080)| < \u03b5\u2081, then |f(X) - f(G(U\u2080))| < \u03b5 [l1].", "dependencies": ["tc_1", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d)) \n  (D_f : Set (Fin n \u2192 \u211d))\n  (hU0_in_T : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f})\n  (hG_cont : \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d)) \n  (D_f : Set (Fin n \u2192 \u211d))\n  (hU0_in_T : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f})\n  (hG_cont : \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by\n    intro \u03b5 h\u03b5\n    have h1 : G U_0 \u2208 D_f := by\n      -- Extract that G(U_0) \u2208 D_f from hU0_in_T\n      simp only [Set.mem_setOf_eq] at hU0_in_T\n      exact hU0_in_T.2\n    -- Use the continuity of f at G(U_0) to get \u03b5\u2081\n    have h2 : \u2203 \u03b5\u2081 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b5\u2081 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n      obtain \u27e8\u03b5\u2081, h\u03b5\u2081, h3\u27e9 := hf_cont (G U_0) h1 \u03b5 h\u03b5\n      refine' \u27e8\u03b5\u2081, h\u03b5\u2081, _\u27e9\n      intro Y hY hY'\n      have h4 := h3 Y hY hY'\n      exact h4\n    obtain \u27e8\u03b5\u2081, h\u03b5\u2081, h3\u27e9 := h2\n    -- Use the continuity of G at U_0 to get \u03b4\n    have h4 : \u2203 \u03b4 > 0, \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4 \u2192 \u2016G V - G U_0\u2016 < \u03b5\u2081 := by\n      obtain \u27e8\u03b4, h\u03b4, h5\u27e9 := hG_cont U_0 hU0_in_T \u03b5\u2081 h\u03b5\u2081\n      refine' \u27e8\u03b4, h\u03b4, _\u27e9\n      intro V hV hV'\n      have h6 := h5 V hV hV'\n      exact h6\n    obtain \u27e8\u03b4, h\u03b4, h5\u27e9 := h4\n    refine' \u27e8\u03b4, h\u03b4, _\u27e9\n    intro U hU hU'\n    have h6 : \u2016G U - G U_0\u2016 < \u03b5\u2081 := by\n      have h7 : U \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU\n      have h8 : \u2016U - U_0\u2016 < \u03b4 := hU'\n      have h9 : \u2016G U - G U_0\u2016 < \u03b5\u2081 := h5 U h7 h8\n      exact h9\n    have h7 : G U \u2208 D_f := by\n      simp only [Set.mem_setOf_eq] at hU\n      exact hU.2\n    have h8 : |f (G U) - f (G U_0)| < \u03b5 := by\n      have h9 : \u2016G U - G U_0\u2016 < \u03b5\u2081 := h6\n      have h10 : G U \u2208 D_f := h7\n      have h11 : |f (G U) - f (G U_0)| < \u03b5 := h3 (G U) h10 h9\n      exact h11\n    exact h8\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The function f definition and domain D_f are correctly represented in Lean.", "The continuity assumption is overly broad - natural language specifies continuity at a specific point X\u2080 = G(U\u2080), but Lean assumes continuity everywhere on D_f.", "The arbitrary \u03b5 > 0 condition is correctly captured in the universal quantification.", "The conclusion has a fundamental mismatch - natural language talks about X \u2208 D_f near G(U\u2080), while Lean talks about U near U\u2080 in a different space.", "The Lean formalization introduces additional structure (function G, domain D_G) that significantly changes the problem context, though this could be seen as providing necessary background."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The function f definition and domain D_f are correctly represented in Lean.', 'The continuity assumption is overly broad - natural language specifies continuity at a specific point X\u2080 = G(U\u2080), but Lean assumes continuity everywhere on D_f.', 'The arbitrary \u03b5 > 0 condition is correctly captured in the universal quantification.', 'The conclusion has a fundamental mismatch - natural language talks about X \u2208 D_f near G(U\u2080), while Lean talks about U near U\u2080 in a different space.', 'The Lean formalization introduces additional structure (function G, domain D_G) that significantly changes the problem context, though this could be seen as providing necessary background.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since $\\mathbf{G}$ is continuous at $\\mathbf{U}_0$, there is a $\\delta>0$ such that $|\\mathbf{G}(\\mathbf{U})-\\mathbf{G}(\\mathbf{U}_0)|<\\epsilon_1 \\mbox{\\quad if\\quad} |\\mathbf{U}-\\mathbf{U}_0|< \\delta\\mbox{\\quad and\\quad}\\mathbf{U}\\in D_\\mathbf{G}.$", "statement": "We assume:\n\u2022 G is a vector-valued function from D_G \u2286 \u211d^m to \u211d^n [tc_1]\n\u2022 G is continuous at U\u2080 [tc_3]\n\u2022 For a given \u03b5 > 0, there exists an \u03b5\u2081 > 0 as specified in [l1].\nTherefore, we conclude:\n\u2022 For the \u03b5\u2081 from [l1], there exists a \u03b4 > 0 such that for any U \u2208 D_G, if |U - U\u2080| < \u03b4, then |G(U) - G(U\u2080)| < \u03b5\u2081 [l2].", "dependencies": ["tc_1", "tc_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem composite_function_continuity \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d)) \n  (D_f : Set (Fin n \u2192 \u211d))\n  (hU0_in_T : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f})\n  (hG_cont : \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem composite_function_continuity \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d)) \n  (D_f : Set (Fin n \u2192 \u211d))\n  (hU0_in_T : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f})\n  (hG_cont : \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by\n    intro \u03b5 h\u03b5\n    have h1 : G U_0 \u2208 D_f := by\n      -- Extract the fact that G(U_0) \u2208 D_f from hU0_in_T\n      simp only [Set.mem_setOf_eq] at hU0_in_T\n      exact hU0_in_T.2\n    -- Use the continuity of f at G(U_0) to get \u03b5\u2081\n    have h2 : \u2203 \u03b5\u2081 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b5\u2081 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n      have h3 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b4 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n        intro \u03b5 h\u03b5\n        have h4 : G U_0 \u2208 D_f := h1\n        have h5 : \u2203 \u03b4 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b4 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n          -- Use the continuity of f at G(U_0)\n          obtain \u27e8\u03b4, h\u03b4, h6\u27e9 := hf_cont (G U_0) h4 \u03b5 h\u03b5\n          refine' \u27e8\u03b4, h\u03b4, _\u27e9\n          intro Y hY hY'\n          exact h6 Y hY hY'\n        exact h5\n      -- Apply the above with \u03b5\n      have h6 : \u2203 \u03b4 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b4 \u2192 |f Y - f (G U_0)| < \u03b5 := h3 \u03b5 h\u03b5\n      obtain \u27e8\u03b5\u2081, h\u03b5\u2081, h7\u27e9 := h6\n      refine' \u27e8\u03b5\u2081, h\u03b5\u2081, _\u27e9\n      intro Y hY hY'\n      exact h7 Y hY hY'\n    -- Obtain \u03b5\u2081 and its properties\n    obtain \u27e8\u03b5\u2081, h\u03b5\u2081, h3\u27e9 := h2\n    -- Use the continuity of G at U_0 to get \u03b4\n    have h4 : \u2203 \u03b4 > 0, \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4 \u2192 \u2016G V - G U_0\u2016 < \u03b5\u2081 := by\n      have h5 : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU0_in_T\n      have h6 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4 \u2192 \u2016G V - G U_0\u2016 < \u03b5 := by\n        intro \u03b5 h\u03b5\n        have h7 : \u2203 \u03b4 > 0, \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4 \u2192 \u2016G V - G U_0\u2016 < \u03b5 := by\n          -- Use the continuity of G at U_0\n          obtain \u27e8\u03b4, h\u03b4, h8\u27e9 := hG_cont U_0 h5 \u03b5 h\u03b5\n          refine' \u27e8\u03b4, h\u03b4, _\u27e9\n          intro V hV hV'\n          exact h8 V hV hV'\n        exact h7\n      -- Apply the above with \u03b5\u2081\n      have h7 : \u2203 \u03b4 > 0, \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4 \u2192 \u2016G V - G U_0\u2016 < \u03b5\u2081 := h6 \u03b5\u2081 h\u03b5\u2081\n      exact h7\n    -- Obtain \u03b4 and its properties\n    obtain \u27e8\u03b4, h\u03b4, h5\u27e9 := h4\n    -- Combine the results to get the final \u03b4\n    refine' \u27e8\u03b4, h\u03b4, _\u27e9\n    intro U hU hU'\n    have h6 : \u2016G U - G U_0\u2016 < \u03b5\u2081 := by\n      have h7 : U \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU\n      have h8 : \u2016U - U_0\u2016 < \u03b4 := hU'\n      have h9 : \u2016G U - G U_0\u2016 < \u03b5\u2081 := h5 U h7 h8\n      exact h9\n    have h7 : G U \u2208 D_f := by\n      -- Extract that G(U) \u2208 D_f from hU\n      simp only [Set.mem_setOf_eq] at hU\n      exact hU.2\n    have h8 : |f (G U) - f (G U_0)| < \u03b5 := by\n      have h9 : \u2016G U - G U_0\u2016 < \u03b5\u2081 := h6\n      have h10 : G U \u2208 D_f := h7\n      have h11 : |f (G U) - f (G U_0)| < \u03b5 := h3 (G U) h10 h9\n      exact h11\n    exact h8\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization introduces an entirely different mathematical concept (composite function continuity) that is not mentioned in the natural language. The natural language describes the continuity of a single function G at point U\u2080, concluding with a statement about |G(U) - G(U\u2080)| < \u03b5\u2081. However, the Lean formalization proves continuity of a composite function f \u2218 G, where function f is not mentioned at all in the natural language. The conclusion in Lean is about |f(G(U)) - f(G(U\u2080))| < \u03b5, which is fundamentally different from what the natural language describes. This represents a major logical discrepancy as the Lean code is proving a different theorem than what is described in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization introduces an entirely different mathematical concept (composite function continuity) that is not mentioned in the natural language. The natural language describes the continuity of a single function G at point U\u2080, concluding with a statement about |G(U) - G(U\u2080)| < \u03b5\u2081. However, the Lean formalization proves continuity of a composite function f \u2218 G, where function f is not mentioned at all in the natural language. The conclusion in Lean is about |f(G(U)) - f(G(U\u2080))| < \u03b5, which is fundamentally different from what the natural language describes. This represents a major logical discrepancy as the Lean code is proving a different theorem than what is described in the natural language.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By taking $\\mathbf{X}=\\mathbf{G}(\\mathbf{U})$ in \\eqref{eq:5.2.17} and \\eqref{eq:5.2.18}, we see that $|h(\\mathbf{U})-h(\\mathbf{U}_0)|=|f(\\mathbf{G}(\\mathbf{U})) -f(\\mathbf{G}(\\mathbf{U}_0))|<\\epsilon$ if $|\\mathbf{U}-\\mathbf{U}_0|<\\delta\\mbox{\\quad and\\quad}\\mathbf{U}\\in T.$", "statement": "We assume:\n\u2022 The composite function h on T is defined by h(U) = f(G(U)), where T = {U \u2208 D_G | G(U) \u2208 D_f} [tc_2]\n\u2022 U\u2080 is in T and is a limit point of T [tc_3]\n\u2022 For any \u03b5 > 0, there exists an \u03b5\u2081 > 0 such that for any X \u2208 D_f with |X - G(U\u2080)| < \u03b5\u2081, we have |f(X) - f(G(U\u2080))| < \u03b5 [l1]\n\u2022 For this \u03b5\u2081, there exists a \u03b4 > 0 such that for any U \u2208 D_G with |U - U\u2080| < \u03b4, we have |G(U) - G(U\u2080)| < \u03b5\u2081 [l2]\nTherefore, we conclude:\n\u2022 The function h is continuous at U\u2080 [ts_1].", "dependencies": ["tc_2", "tc_3", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem composite_function_continuity \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d)) \n  (D_f : Set (Fin n \u2192 \u211d))\n  (hU0_in_T : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f})\n  (hG_cont : \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem composite_function_continuity \n  {n m : \u2115} \n  (f : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (G : (Fin m \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (U_0 : Fin m \u2192 \u211d)\n  (D_G : Set (Fin m \u2192 \u211d)) \n  (D_f : Set (Fin n \u2192 \u211d))\n  (hU0_in_T : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f})\n  (hG_cont : \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 V \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016V - U\u2016 < \u03b4 \u2192 \u2016G V - G U\u2016 < \u03b5)\n  (hf_cont : \u2200 X \u2208 D_f, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 Y \u2208 D_f, \u2016Y - X\u2016 < \u03b4 \u2192 |f Y - f X| < \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 U \u2208 {U \u2208 D_G | G U \u2208 D_f}, \u2016U - U_0\u2016 < \u03b4 \u2192 |f (G U) - f (G U_0)| < \u03b5 := by\n    intro \u03b5 h\u03b5\n    have hG_U0_in_Df : G U_0 \u2208 D_f := by\n      -- Extract that G(U_0) \u2208 D_f from hU0_in_T\n      have h\u2081 : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU0_in_T\n      simp only [Set.mem_setOf_eq] at h\u2081\n      exact h\u2081.2\n    -- Step 1: Use hf_cont at G(U_0) with \u03b5 to get \u03b4\u2081\n    have h\u2081 : \u2203 \u03b4\u2081 > (0 : \u211d), \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b4\u2081 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n      -- Apply hf_cont to X = G(U_0), \u03b5 > 0\n      have h\u2082 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b4 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n        intro \u03b5 h\u03b5\n        have h\u2083 : G U_0 \u2208 D_f := hG_U0_in_Df\n        have h\u2084 : \u2203 \u03b4 > 0, \u2200 (Y : Fin n \u2192 \u211d), Y \u2208 D_f \u2192 \u2016Y - G U_0\u2016 < \u03b4 \u2192 |f Y - f (G U_0)| < \u03b5 := by\n          -- Use the given hf_cont\n          obtain \u27e8\u03b4, h\u03b4, h\u2085\u27e9 := hf_cont (G U_0) hG_U0_in_Df \u03b5 h\u03b5\n          refine' \u27e8\u03b4, h\u03b4, _\u27e9\n          intro Y hY hY'\n          exact h\u2085 Y hY hY'\n        exact h\u2084\n      -- Use h\u2082 with the given \u03b5 and h\u03b5\n      obtain \u27e8\u03b4\u2081, h\u03b4\u2081, h\u2083\u27e9 := h\u2082 \u03b5 h\u03b5\n      refine' \u27e8\u03b4\u2081, h\u03b4\u2081, _\u27e9\n      intro Y hY hY'\n      exact h\u2083 Y hY hY'\n    -- Obtain \u03b4\u2081 and its properties\n    obtain \u27e8\u03b4\u2081, h\u03b4\u2081_pos, h\u03b4\u2081\u27e9 := h\u2081\n    -- Step 2: Use hG_cont at U_0 with \u03b4\u2081 to get \u03b4\u2082\n    have h\u2082 : \u2203 \u03b4\u2082 > (0 : \u211d), \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4\u2082 \u2192 \u2016G V - G U_0\u2016 < \u03b4\u2081 := by\n      -- Apply hG_cont to U = U_0, \u03b5 = \u03b4\u2081\n      have h\u2083 : U_0 \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU0_in_T\n      have h\u2084 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 (V : Fin m \u2192 \u211d), V \u2208 {U \u2208 D_G | G U \u2208 D_f} \u2192 \u2016V - U_0\u2016 < \u03b4 \u2192 \u2016G V - G U_0\u2016 < \u03b5 := by\n        intro \u03b5 h\u03b5\n        obtain \u27e8\u03b4, h\u03b4, h\u2085\u27e9 := hG_cont U_0 h\u2083 \u03b5 h\u03b5\n        refine' \u27e8\u03b4, h\u03b4, _\u27e9\n        intro V hV hV'\n        exact h\u2085 V hV hV'\n      -- Use h\u2084 with \u03b5 = \u03b4\u2081 and h\u03b4\u2081_pos\n      obtain \u27e8\u03b4\u2082, h\u03b4\u2082_pos, h\u2085\u27e9 := h\u2084 \u03b4\u2081 h\u03b4\u2081_pos\n      refine' \u27e8\u03b4\u2082, h\u03b4\u2082_pos, _\u27e9\n      intro V hV hV'\n      exact h\u2085 V hV hV'\n    -- Obtain \u03b4\u2082 and its properties\n    obtain \u27e8\u03b4\u2082, h\u03b4\u2082_pos, h\u03b4\u2082\u27e9 := h\u2082\n    -- Step 3: Set \u03b4 = \u03b4\u2082\n    refine' \u27e8\u03b4\u2082, h\u03b4\u2082_pos, _\u27e9\n    intro U hU hU'\n    -- For any U \u2208 T with \u2016U - U_0\u2016 < \u03b4\u2082, we have \u2016G(U) - G(U_0)\u2016 < \u03b4\u2081\n    have h\u2083 : \u2016G U - G U_0\u2016 < \u03b4\u2081 := by\n      have h\u2084 : U \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU\n      have h\u2085 : \u2016U - U_0\u2016 < \u03b4\u2082 := hU'\n      have h\u2086 : \u2016G U - G U_0\u2016 < \u03b4\u2081 := h\u03b4\u2082 U h\u2084 h\u2085\n      exact h\u2086\n    -- Since G(U) \u2208 D_f, apply hf_cont to Y = G(U)\n    have h\u2084 : G U \u2208 D_f := by\n      have h\u2085 : U \u2208 {U \u2208 D_G | G U \u2208 D_f} := hU\n      simp only [Set.mem_setOf_eq] at h\u2085\n      exact h\u2085.2\n    have h\u2085 : |f (G U) - f (G U_0)| < \u03b5 := by\n      have h\u2086 : \u2016G U - G U_0\u2016 < \u03b4\u2081 := h\u2083\n      have h\u2087 : G U \u2208 D_f := h\u2084\n      have h\u2088 : |f (G U) - f (G U_0)| < \u03b5 := h\u03b4\u2081 (G U) h\u2087 h\u2086\n      exact h\u2088\n    exact h\u2085\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The composite function definition and domain T are correctly captured in the Lean formalization.", "The Lean formalization is missing the crucial condition that U\u2080 is a limit point of T, which is essential for the continuity proof.", "The f continuity condition is generalized to all points in D_f rather than specifically at G(U\u2080), and uses different variable names (X,Y vs the specific point), but captures the same logical meaning.", "The G continuity condition is generalized to all points and restricts the domain to T rather than D_G, representing a structural difference from the natural language.", "The conclusion correctly represents continuity of the composite function h at U\u2080 using the epsilon-delta definition."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The composite function definition and domain T are correctly captured in the Lean formalization.', 'The Lean formalization is missing the crucial condition that U\u2080 is a limit point of T, which is essential for the continuity proof.', 'The f continuity condition is generalized to all points in D_f rather than specifically at G(U\u2080), and uses different variable names (X,Y vs the specific point), but captures the same logical meaning.', 'The G continuity condition is generalized to all points and restricts the domain to T rather than D_G, representing a structural difference from the natural language.', 'The conclusion correctly represents continuity of the composite function h at U\u2080 using the epsilon-delta definition.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    