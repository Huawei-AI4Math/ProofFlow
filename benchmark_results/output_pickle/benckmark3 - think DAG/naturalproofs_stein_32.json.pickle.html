
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: We have $g_0=0$.

We can assume the following statement(s) without a proof. 

  The map $\psi:(\zmod{p})^*	o \{\pm 1\}$ given by
$\psi(a) = \kr{a}{p}$ is a surjective group homomorphism.

Proof: By definition
\begin{equation}\label{eqn:lem_gauss_3}
g_0 = \sum_{n=0}^{p-1} \kr{n}{p}.
\end{equation}
By Lemma~\ref{lem:qrhom}, the map
$$
\kr{\cdot}{p} : (\zmod{p})^* \ra \{\pm 1\}
$$
is a surjective homomorphism of groups.  Thus,  half the
elements of $(\zmod{p})^*$ map to $+1$ and half map to $-1$ (the
subgroup that maps to $+1$ has index $2$).  Since $\kr{0}{p}=0$, the
sum (\ref{eqn:lem_gauss_3}) is~$0$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "The map $\\psi:(\\zmod{p})^*\\to \\{\\pm 1\\}$ given by\n$\\psi(a) = \\kr{a}{p}$ is a surjective group homomorphism.", "statement": "Premise:\n\u2022 Let p be an odd prime. The map $\\psi: a \\mapsto \\kr{a}{p}$ from the multiplicative group of integers modulo p, $(\\zmod{p})^*$, to $\\{\\pm 1\\}$ is a surjective group homomorphism [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (p : \u2115) [Fact (Nat.Prime p)] (hp_odd : Odd p) :\n  let \u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2 := sorry\n  Function.Surjective \u03c8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Both specify that p is an odd prime. The Lean version uses [Fact (Nat.Prime p)] and (hp_odd : Odd p) which correctly captures this condition.", "The natural language specifies the map goes from (\u2124/p\u2124)* to {\u00b11}, but the Lean version has the codomain as ZMod 2. While ZMod 2 = {0,1} can represent {\u00b11} via isomorphism, this is a significant difference in the literal specification of the map's codomain. Additionally, the natural language explicitly defines the map as a \u21a6 (a/p) (Legendre symbol), but the Lean version leaves the map definition as 'sorry'.", "The natural language states \u03c8 is a surjective group homomorphism, but the Lean version only asserts Function.Surjective \u03c8. The Lean type signature (ZMod p)\u02e3 \u2192* ZMod 2 does indicate it's a group homomorphism (the \u2192* notation), but the conclusion only explicitly states surjectivity, missing the explicit assertion that it's a group homomorphism in the proposition being proved."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Both specify that p is an odd prime. The Lean version uses [Fact (Nat.Prime p)] and (hp_odd : Odd p) which correctly captures this condition.', \"The natural language specifies the map goes from (\u2124/p\u2124)* to {\u00b11}, but the Lean version has the codomain as ZMod 2. While ZMod 2 = {0,1} can represent {\u00b11} via isomorphism, this is a significant difference in the literal specification of the map's codomain. Additionally, the natural language explicitly defines the map as a \u21a6 (a/p) (Legendre symbol), but the Lean version leaves the map definition as 'sorry'.\", \"The natural language states \u03c8 is a surjective group homomorphism, but the Lean version only asserts Function.Surjective \u03c8. The Lean type signature (ZMod p)\u02e3 \u2192* ZMod 2 does indicate it's a group homomorphism (the \u2192* notation), but the conclusion only explicitly states surjectivity, missing the explicit assertion that it's a group homomorphism in the proposition being proved.\"]"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "g_0 = \\sum_{n=0}^{p-1} \\kr{n}{p}.", "statement": "Definition:\n\u2022 Let p be an odd prime. We define $g_0 = \\sum_{n=0}^{p-1} \\kr{n}{p}$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (p : \u2115) (hp_odd : Odd p) (hp_prime : Nat.Prime p) :\n  (\u2211 n in Finset.range p, jacobiSym n p) = 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that p is an odd prime using separate conditions for oddness and primality", "The natural language only defines g_0 as a sum without specifying its value, while the Lean theorem proves that this sum equals 0. The natural language is a definition, but the Lean code is proving a theorem about the value of the sum"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that p is an odd prime using separate conditions for oddness and primality', 'The natural language only defines g_0 as a sum without specifying its value, while the Lean theorem proves that this sum equals 0. The natural language is a definition, but the Lean code is proving a theorem about the value of the sum']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "By Lemma~\\ref{lem:qrhom}, the map\n$$\n\\kr{\\cdot}{p} : (\\zmod{p})^* \\ra \\{\\pm 1\\}\n$$\nis a surjective homomorphism of groups.  Thus,  half the\nelements of $(\\zmod{p})^*$ map to $+1$ and half map to $-1$ (the\nsubgroup that maps to $+1$ has index $2$).", "statement": "We assume:\n\u2022 Let p be an odd prime. The map $\\psi: a \\mapsto \\kr{a}{p}$ from $(\\zmod{p})^*$ to $\\{\\pm 1\\}$ is a surjective group homomorphism [tc_1].\nTherefore, we conclude:\n\u2022 The number of elements $a \\in (\\zmod{p})^*$ for which $\\kr{a}{p} = 1$ is equal to the number of elements for which $\\kr{a}{p} = -1$. [l1]", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p : \u2115) [Fact (Nat.Prime p)] (hp_odd : Odd p) \n  (\u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2) (h\u03c8_surj : Function.Surjective \u03c8) :\n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)).card = \n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))).card := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p : \u2115) [Fact (Nat.Prime p)] (hp_odd : Odd p) \n  (\u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2) (h\u03c8_surj : Function.Surjective \u03c8) :\n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)).card = \n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))).card := by\n  have h_contradiction : False := by\n    -- Since \u03c8 is surjective, there exists an element a in (ZMod p)\u02e3 such that \u03c8(a) = 0\n    have h\u2081 : \u2203 (a : (ZMod p)\u02e3), \u03c8 a = 0 := by\n      -- Use the surjectivity of \u03c8 to find an element mapping to 0\n      have h\u2082 : (0 : ZMod 2) \u2208 Set.range \u03c8 := by\n        apply h\u03c8_surj\n      -- Obtain the element a such that \u03c8(a) = 0\n      obtain \u27e8a, ha\u27e9 := h\u2082\n      exact \u27e8a, by simpa using ha\u27e9\n    -- Obtain the element a such that \u03c8(a) = 0\n    obtain \u27e8a, ha\u27e9 := h\u2081\n    -- Since a is a unit, it has an inverse a\u207b\u00b9\n    have h\u2082 : (a : (ZMod p)\u02e3) * a\u207b\u00b9 = 1 := by\n      simp [Units.mul_inv]\n    -- Apply \u03c8 to both sides of the equation a * a\u207b\u00b9 = 1\n    have h\u2083 : \u03c8 ((a : (ZMod p)\u02e3) * a\u207b\u00b9) = \u03c8 (1 : (ZMod p)\u02e3) := by rw [h\u2082]\n    -- Use the multiplicative property of \u03c8 to expand \u03c8(a * a\u207b\u00b9)\n    have h\u2084 : \u03c8 ((a : (ZMod p)\u02e3) * a\u207b\u00b9) = \u03c8 (a : (ZMod p)\u02e3) * \u03c8 (a\u207b\u00b9 : (ZMod p)\u02e3) := by\n      apply \u03c8.map_mul\n    -- Use the fact that \u03c8(1) = 1\n    have h\u2085 : \u03c8 (1 : (ZMod p)\u02e3) = (1 : ZMod 2) := by\n      simp [MonoidHom.map_one]\n    -- Substitute the known values into the equations\n    have h\u2086 : (\u03c8 (a : (ZMod p)\u02e3) * \u03c8 (a\u207b\u00b9 : (ZMod p)\u02e3) : ZMod 2) = (1 : ZMod 2) := by\n      calc\n        (\u03c8 (a : (ZMod p)\u02e3) * \u03c8 (a\u207b\u00b9 : (ZMod p)\u02e3) : ZMod 2) = \u03c8 ((a : (ZMod p)\u02e3) * a\u207b\u00b9) := by rw [h\u2084]\n        _ = \u03c8 (1 : (ZMod p)\u02e3) := by rw [h\u2083]\n        _ = (1 : ZMod 2) := by rw [h\u2085]\n    -- Substitute \u03c8(a) = 0 into the equation\n    have h\u2087 : (\u03c8 (a : (ZMod p)\u02e3) : ZMod 2) = 0 := by\n      simpa using ha\n    -- Derive a contradiction from 0 * \u03c8(a\u207b\u00b9) = 1\n    have h\u2088 : (0 : ZMod 2) * \u03c8 (a\u207b\u00b9 : (ZMod p)\u02e3) = (0 : ZMod 2) := by\n      simp [zero_mul]\n    have h\u2089 : (0 : ZMod 2) = (1 : ZMod 2) := by\n      calc\n        (0 : ZMod 2) = (\u03c8 (a : (ZMod p)\u02e3) * \u03c8 (a\u207b\u00b9 : (ZMod p)\u02e3) : ZMod 2) := by\n          rw [h\u2087]\n          <;> simp [h\u2088]\n          <;> aesop\n        _ = (1 : ZMod 2) := by rw [h\u2086]\n    -- Since 0 \u2260 1 in ZMod 2, we have a contradiction\n    have h\u2081\u2080 : (0 : ZMod 2) \u2260 (1 : ZMod 2) := by\n      decide\n    exact h\u2081\u2080 h\u2089\n  \n  have h_main : (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)).card = (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))).card := by\n    exfalso\n    exact h_contradiction\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language describes \u03c8 as mapping to {\u00b11}, but the Lean formalization uses ZMod 2 as the codomain. While these are isomorphic as groups, this is a notational difference. The group homomorphism and surjectivity properties are correctly captured.", "The conclusion about equal cardinalities is perfectly captured. The Lean code correctly counts elements where \u03c8(a) = 1 and \u03c8(a) = -1, using appropriate filtering and cardinality functions.", "The context of p being an odd prime is perfectly captured with the appropriate type constraints and assumptions in Lean."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Thus,  half the\nelements of $(\\zmod{p})^*$ map to $+1$ and half map to $-1$... the\nsum (\\ref{eqn:lem_gauss_3}) is~$0$.", "statement": "We assume:\n\u2022 Let p be an odd prime.\n\u2022 The number of elements $a \\in (\\zmod{p})^*$ for which $\\kr{a}{p} = 1$ is equal to the number of elements for which $\\kr{a}{p} = -1$ [l1].\nTherefore, we conclude:\n\u2022 $\\sum_{n=1}^{p-1} \\kr{n}{p} = 0$. [l2]", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p : \u2115) [Fact (Nat.Prime p)] (hp_odd : Odd p) \n  (\u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2) (h\u03c8_surj : Function.Surjective \u03c8) :\n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)).card = \n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))).card := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p : \u2115) [Fact (Nat.Prime p)] (hp_odd : Odd p) \n  (\u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2) (h\u03c8_surj : Function.Surjective \u03c8) :\n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)).card = \n  (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))).card := by\n  have h_neg_one_eq_one : (-1 : ZMod 2) = (1 : ZMod 2) := by\n    norm_num [ZMod.nat_cast_self]\n    <;> rfl\n  \n  have h_main : (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)) = (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))) := by\n    apply Finset.ext\n    intro a\n    simp only [Finset.mem_filter, Finset.mem_univ, true_and]\n    constructor\n    \u00b7 intro h\n      have h\u2081 : \u03c8 a = (1 : ZMod 2) := h\n      have h\u2082 : \u03c8 a = (-1 : ZMod 2) := by\n        rw [h\u2081]\n        <;> simp [h_neg_one_eq_one]\n      exact h\u2082\n    \u00b7 intro h\n      have h\u2081 : \u03c8 a = (-1 : ZMod 2) := h\n      have h\u2082 : \u03c8 a = (1 : ZMod 2) := by\n        rw [h\u2081]\n        <;> simp [h_neg_one_eq_one]\n      exact h\u2082\n  \n  have h_final : (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = 1)).card = (Finset.univ.filter (fun a : (ZMod p)\u02e3 => \u03c8 a = (-1 : ZMod 2))).card := by\n    rw [h_main]\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has several major issues: (1) It uses a generic group homomorphism \u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2 instead of the specific Legendre symbol mentioned in the natural language, fundamentally changing the mathematical content. (2) The conclusion about the sum \u2211_{n=1}^{p-1} \u27e8n/p\u27e9 = 0 is completely missing from the formalization. (3) An additional surjectivity condition is introduced that wasn't present in the natural language. While the basic structure about counting elements is preserved, the specific mathematical object (Legendre symbol) and the key conclusion are either missing or incorrectly generalized."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has several major issues: (1) It uses a generic group homomorphism \u03c8 : (ZMod p)\u02e3 \u2192* ZMod 2 instead of the specific Legendre symbol mentioned in the natural language, fundamentally changing the mathematical content. (2) The conclusion about the sum \u2211_{n=1}^{p-1} \u27e8n/p\u27e9 = 0 is completely missing from the formalization. (3) An additional surjectivity condition is introduced that wasn't present in the natural language. While the basic structure about counting elements is preserved, the specific mathematical object (Legendre symbol) and the key conclusion are either missing or incorrectly generalized.\"]"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since $\\kr{0}{p}=0$", "statement": "We assume:\n\u2022 Let p be a prime.\nTherefore, we conclude:\n\u2022 $\\kr{0}{p}=0$ [l3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (p : \u2115) (hp : Nat.Prime p) : jacobiSym 0 p = 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (p : \u2115) (hp : Nat.Prime p) : jacobiSym 0 p = 0 := by\n  have h_p_ne_one : p \u2260 1 := by\n    intro h\n    have h\u2081 := Nat.Prime.ne_one hp\n    contradiction\n  \n  have h_main : jacobiSym 0 p = 0 := by\n    have h\u2081 : (p : \u2115) \u2260 0 := by\n      have h\u2082 := Nat.Prime.pos hp\n      linarith\n    have h\u2082 : (0 : \u2124) = 0 := by rfl\n    rw [show (jacobiSym 0 p : \u2124) = 0 by\n      -- Use the definition of jacobiSym to simplify the expression\n      simp [jacobiSym, h\u2081, h_p_ne_one, h\u2082]\n      <;>\n      (try decide) <;>\n      (try contradiction) <;>\n      (try norm_num) <;>\n      (try simp_all [Nat.Prime.ne_zero])\n      ]\n    <;> norm_cast\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The assumption that p is prime is properly encoded as 'hp : Nat.Prime p', the conclusion about the Jacobi symbol $\\kr{0}{p}=0$ is correctly formalized as 'jacobiSym 0 p = 0', and the theorem name 'l3' matches the reference [l3] in the natural language. The additional type declaration 'p : \u2115' is a reasonable and mathematically appropriate specification that doesn't contradict the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since $\\kr{0}{p}=0$, the\nsum (\\ref{eqn:lem_gauss_3}) is~$0$.", "statement": "We assume:\n\u2022 Let p be an odd prime.\n\u2022 $g_0 = \\sum_{n=0}^{p-1} \\kr{n}{p}$ [def_1].\n\u2022 $\\sum_{n=1}^{p-1} \\kr{n}{p} = 0$ [l2].\n\u2022 $\\kr{0}{p}=0$ [l3].\nTherefore, we conclude:\n\u2022 $g_0 = 0$ [ts_1].", "dependencies": ["def_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (p : \u2115) (hp_prime : Nat.Prime p) (hp_odd : Odd p) \n  (l2 : \u2211 n in Finset.range (p - 1), jacobiSym (n + 1) p = 0)\n  (l3 : jacobiSym 0 p = 0) :\n  (\u2211 n in Finset.range p, jacobiSym n p) = 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (p : \u2115) (hp_prime : Nat.Prime p) (hp_odd : Odd p) \n  (l2 : \u2211 n in Finset.range (p - 1), jacobiSym (n + 1) p = 0)\n  (l3 : jacobiSym 0 p = 0) :\n  (\u2211 n in Finset.range p, jacobiSym n p) = 0 := by\n  have h_p_ge_two : p \u2265 2 := by\n    have h\u2081 := Nat.Prime.two_le hp_prime\n    linarith\n  \n  have h_sum_split : (\u2211 n in Finset.range p, jacobiSym n p) = jacobiSym 0 p + \u2211 n in Finset.Ico 1 p, jacobiSym n p := by\n    have h\u2081 : (\u2211 n in Finset.range p, jacobiSym n p) = \u2211 n in Finset.range p, jacobiSym n p := rfl\n    have h\u2082 : (Finset.range p) = {0} \u222a Finset.Ico 1 p := by\n      apply Finset.ext\n      intro x\n      simp [Finset.mem_range, Finset.mem_Ico, Nat.lt_succ_iff]\n      <;>\n      (try omega) <;>\n      (try\n        {\n          by_cases h : x = 0 <;> by_cases h' : x < p <;> simp_all [h, h']\n          <;> omega\n        }) <;>\n      (try\n        {\n          omega\n        })\n    rw [h\u2082]\n    rw [Finset.sum_union] <;>\n    (try simp [Finset.disjoint_left]) <;>\n    (try\n      {\n        aesop\n      }) <;>\n    (try\n      {\n        norm_num\n        <;>\n        (try omega)\n      })\n    <;>\n    (try\n      {\n        aesop\n      })\n  \n  have h_Ico_eq_image : Finset.Ico 1 p = Finset.image (fun n => n + 1) (Finset.range (p - 1)) := by\n    have h\u2081 : p \u2265 1 := by linarith\n    have h\u2082 : Finset.Ico 1 p = Finset.image (fun n => n + 1) (Finset.range (p - 1)) := by\n      apply Finset.ext\n      intro x\n      simp [Finset.mem_Ico, Finset.mem_image, Finset.mem_range]\n      <;>\n      (try omega) <;>\n      (try\n        {\n          constructor <;> intro h <;>\n          (try omega) <;>\n          (try\n            {\n              use x - 1\n              <;>\n              (try omega) <;>\n              (try\n                {\n                  simp_all [Nat.lt_succ_iff]\n                  <;>\n                  omega\n                })\n            })\n        }) <;>\n      (try\n        {\n          cases p with\n          | zero => contradiction\n          | succ p =>\n            cases p with\n            | zero => contradiction\n            | succ p =>\n              simp_all [Nat.lt_succ_iff]\n              <;>\n              omega\n        })\n    exact h\u2082\n  \n  have h_sum_Ico_eq_sum_range : \u2211 n in Finset.Ico 1 p, jacobiSym n p = \u2211 n in Finset.range (p - 1), jacobiSym (n + 1) p := by\n    rw [h_Ico_eq_image]\n    have h\u2081 : \u2200 (x y : \u2115), x \u2208 Finset.range (p - 1) \u2192 y \u2208 Finset.range (p - 1) \u2192 (x + 1 : \u2115) = (y + 1 : \u2115) \u2192 x = y := by\n      intro x y hx hy hxy\n      simp only [Finset.mem_range] at hx hy\n      omega\n    rw [Finset.sum_image]\n    <;> simp_all [add_assoc]\n    <;>\n    (try omega) <;>\n    (try aesop)\n    <;>\n    (try\n      {\n        intro x hx\n        simp_all [Finset.mem_range]\n        <;>\n        omega\n      })\n  \n  have h_sum_Ico_zero : \u2211 n in Finset.Ico 1 p, jacobiSym n p = 0 := by\n    rw [h_sum_Ico_eq_sum_range]\n    exact l2\n  \n  have h_final : (\u2211 n in Finset.range p, jacobiSym n p) = 0 := by\n    rw [h_sum_split]\n    rw [h_sum_Ico_zero]\n    rw [l3]\n    <;> simp\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The assumptions about p being an odd prime are properly stated. The sum from 1 to p-1 is correctly represented using Finset.range with appropriate indexing. The Jacobi symbol notation is appropriate for this context. The logical flow from the assumptions to the conclusion is preserved, and the goal statement correctly represents that g\u2080 = 0."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    