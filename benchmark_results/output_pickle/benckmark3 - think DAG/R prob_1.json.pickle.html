
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let X be a random variable with an expected value $E[X] = 5$. Let Y be another random variable defined as $Y = 2X + 3$. Then the expected value of Y is $E[Y] = 13$.

Proof: Given the definition $Y = 2X + 3$, the expected value of Y is $E[Y] = E[2X + 3]$. By the linearity of expectation, this can be written as $E[Y] = E[2X] + E[3]$. Applying the properties that $E[cX] = cE[X]$ for a constant $c$ and $E[c] = c$, we get the expression $E[Y] = 2E[X] + 3$. Using the given condition $E[X] = 5$, we substitute this into our expression to get $E[Y] = 2(5) + 3 = 13$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let X be a random variable with an expected value $E[X] = 5$.", "statement": "Premise:\n\u2022 X is a random variable and its expected value is E[X] = 5 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) \n  (h : \u222b \u03c9, X \u03c9 \u2202P = 5) :\n  \u222b \u03c9, X \u03c9 \u2202P = 5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures 'X is a random variable' by defining X as a measurable function from a probability space \u03a9 to \u211d, with the necessary mathematical infrastructure (measurable space, probability measure). The extra technical details like measurability and probability measure axioms are appropriate formalizations of the concept 'random variable'.", "The condition E[X] = 5 is correctly formalized as \u222b \u03c9, X \u03c9 \u2202P = 5, which is the standard measure-theoretic definition of expected value. This is a perfect mathematical translation.", "The natural language states no conclusions are derived from this premise alone, but the Lean theorem has \u222b \u03c9, X \u03c9 \u2202P = 5 as its conclusion. However, this conclusion is trivial since it's identical to one of the hypotheses, so it's essentially just restating the premise rather than deriving new facts. This is a minor structural difference."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let Y be another random variable defined as $Y = 2X + 3$.", "statement": "Premise:\n\u2022 X is a random variable [from tc_1]\n\u2022 Y is a random variable defined as Y = 2X + 3 [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) \n  (h : \u222b \u03c9, X \u03c9 \u2202P = 5) :\n  let Y : \u03a9 \u2192 \u211d := fun \u03c9 => 2 * X \u03c9 + 3\n  \u222b \u03c9, Y \u03c9 \u2202P = 13 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly represents X as a random variable using `X : \u03a9 \u2192 \u211d` with measurability condition `hX : Measurable X`. The additional probability space structure is appropriate mathematical formalization.", "The Lean definition `let Y : \u03a9 \u2192 \u211d := fun \u03c9 => 2 * X \u03c9 + 3` perfectly captures the relationship Y = 2X + 3 from the natural language.", "The natural language explicitly states there are no new derived facts in this premise step, but the Lean formalization includes additional conditions (expectation of X equals 5) and derives a conclusion (expectation of Y equals 13). This introduces mathematical content not present in the natural language statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly represents X as a random variable using `X : \u03a9 \u2192 \u211d` with measurability condition `hX : Measurable X`. The additional probability space structure is appropriate mathematical formalization.', 'The Lean definition `let Y : \u03a9 \u2192 \u211d := fun \u03c9 => 2 * X \u03c9 + 3` perfectly captures the relationship Y = 2X + 3 from the natural language.', 'The natural language explicitly states there are no new derived facts in this premise step, but the Lean formalization includes additional conditions (expectation of X equals 5) and derives a conclusion (expectation of Y equals 13). This introduces mathematical content not present in the natural language statement.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Given the definition $Y = 2X + 3$, the expected value of Y is $E[Y] = E[2X + 3]$.", "statement": "We assume:\n\u2022 Y is a random variable defined as Y = 2X + 3 [tc_2]\nTherefore, we conclude:\n\u2022 E[Y] = E[2X + 3] [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) \n  (h : \u222b \u03c9, X \u03c9 \u2202P = 5) :\n  let Y : \u03a9 \u2192 \u211d := fun \u03c9 => 2 * X \u03c9 + 3\n  \u222b \u03c9, Y \u03c9 \u2202P = \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) \n  (h : \u222b \u03c9, X \u03c9 \u2202P = 5) :\n  let Y : \u03a9 \u2192 \u211d := fun \u03c9 => 2 * X \u03c9 + 3\n  \u222b \u03c9, Y \u03c9 \u2202P = \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P := by\n  intro Y\n  have h_main : \u222b \u03c9, Y \u03c9 \u2202P = \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P := by\n    dsimp only [Y]\n    <;>\n    rfl\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The definition of Y as 2X + 3 is correctly captured in Lean using function notation, with the mathematical relationship preserved exactly.", "The conclusion E[Y] = E[2X + 3] is correctly represented using integral notation for expected values. The Lean formalization includes necessary mathematical infrastructure (measure theory setup) that doesn't contradict but rather supports the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By the linearity of expectation, this can be written as $E[Y] = E[2X] + E[3]$.", "statement": "We assume:\n\u2022 X is a random variable and its expected value exists [from tc_1]\nTherefore, we conclude:\n\u2022 E[2X + 3] = E[2X] + E[3] [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) :\n  \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9, 2 * X \u03c9 \u2202P + \u222b \u03c9, 3 \u2202P := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) :\n  \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9, 2 * X \u03c9 \u2202P + \u222b \u03c9, 3 \u2202P := by\n  have h1 : Measurable (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) := by\n    apply Measurable.const_mul\n    exact hX\n  \n  have h2 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => (3 : \u211d)) P := by\n    have h3 : P (Set.univ : Set \u03a9) < \u221e := by\n      rw [hP]\n      <;> norm_num\n    -- Use the fact that the measure of the universe is finite to show that the constant function is integrable.\n    have h4 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => (3 : \u211d)) P := by\n      -- Use the lemma that a constant function is integrable if the measure of the space is finite.\n      have h5 : MeasureTheory.Integrable (fun \u03c9 : \u03a9 => (3 : \u211d)) P := by\n        apply MeasureTheory.integrable_const_iff.mpr\n        <;> simp_all [hP]\n        <;>\n        (try norm_num) <;>\n        (try linarith)\n        <;>\n        (try\n          {\n            -- Prove that the measure of the universe is finite.\n            have h6 : P (Set.univ : Set \u03a9) < \u221e := by\n              rw [hP]\n              <;> norm_num\n            simp_all [h6]\n          })\n      exact h5\n    exact h4\n  \n  have h3 : \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9, ( (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 + (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 ) \u2202P := by\n    simp [add_assoc]\n    <;>\n    simp_all [MeasureTheory.integral_congr_ae]\n    <;>\n    aesop\n  \n  have h4 : \u222b \u03c9, ( (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 + (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 ) \u2202P = \u222b \u03c9, (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 \u2202P + \u222b \u03c9, (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 \u2202P := by\n    have h4\u2081 : \u222b \u03c9, ( (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 + (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 ) \u2202P = \u222b \u03c9, (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 \u2202P + \u222b \u03c9, (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 \u2202P := by\n      -- Use the additivity of the integral when one of the functions is integrable.\n      apply MeasureTheory.integral_add_of_integrable_right h1 h2\n    rw [h4\u2081]\n  \n  have h5 : \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9, 2 * X \u03c9 \u2202P + \u222b \u03c9, 3 \u2202P := by\n    calc\n      \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9, ( (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 + (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 ) \u2202P := by rw [h3]\n      _ = \u222b \u03c9, (fun \u03c9 : \u03a9 => (2 : \u211d) * X \u03c9) \u03c9 \u2202P + \u222b \u03c9, (fun \u03c9 : \u03a9 => (3 : \u211d)) \u03c9 \u2202P := by rw [h4]\n      _ = \u222b \u03c9, 2 * X \u03c9 \u2202P + \u222b \u03c9, 3 \u2202P := by\n        simp [add_assoc]\n        <;>\n        simp_all [MeasureTheory.integral_congr_ae]\n        <;>\n        aesop\n  \n  rw [h5]\n  <;>\n  simp_all [MeasureTheory.integral_congr_ae]\n  <;>\n  aesop", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language statement. The theorem demonstrates linearity of expectation E[2X + 3] = E[2X] + E[3] using proper measure-theoretic notation. The setup includes all necessary mathematical infrastructure: probability space (\u03a9 with measure P normalized to 1), measurable random variable X, and the linearity property expressed through Lebesgue integrals. While the natural language uses standard probabilistic notation E[\u00b7] and the Lean uses integral notation \u222b\u00b7\u2202P, these represent the same mathematical concept. The measurability condition hX serves the same purpose as the referenced tc_1 assumption about expected value existence.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) :\n  \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9, 2 * X \u03c9 \u2202P + \u222b \u03c9, 3 \u2202P := by\n  have h3 : \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P = 3 := by\n    -- Prove that the integral of the constant function 3 is 3\n    have h\u2081 : \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P = (3 : \u211d) := by\n      -- Use the fact that P(\u03a9) = 1 to simplify the integral of the constant function\n      have h\u2082 : \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P = (3 : \u211d) * P (Set.univ : Set \u03a9) := by\n        simp [MeasureTheory.integral_const]\n        <;>\n        (try norm_num)\n        <;>\n        (try simp_all [hP])\n        <;>\n        (try ring_nf)\n        <;>\n        (try linarith)\n      rw [h\u2082]\n      rw [hP]\n      <;> norm_num\n    rw [h\u2081]\n  \n  -- Use the linearity of the integral to split the integral of the sum into the sum of integrals\n  have h_add : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n    -- Use the fact that the integral of the sum is the sum of the integrals\n    have h\u2081 : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n      -- Use the additivity of the integral for integrable functions\n      -- Since X is measurable, 2 * X is measurable, and 3 is a constant, both are integrable\n      -- Therefore, we can apply the additivity of the integral\n      have h\u2082 : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n        -- Use the fact that the integral of the sum is the sum of the integrals\n        -- for integrable functions\n        have h\u2083 : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n          -- Apply the additivity of the integral\n          -- This works because both 2 * X and 3 are integrable\n          have h\u2084 : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n            -- Use the fact that the integral of the sum is the sum of the integrals\n            -- for integrable functions\n            have h\u2085 : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n              -- Apply the additivity of the integral\n              -- This works because both 2 * X and 3 are integrable\n              have h\u2086 : Integrable (fun \u03c9 : \u03a9 => (2 * X \u03c9 : \u211d)) P := by\n                -- Prove that 2 * X is integrable\n                -- Since X is measurable and P(\u03a9) = 1, 2 * X is integrable\n                have h\u2087 : Integrable X P := by\n                  -- Prove that X is integrable\n                  -- Since X is measurable and P(\u03a9) = 1, X is integrable\n                  have h\u2088 : Integrable X P := by\n                    -- Use the fact that P(\u03a9) = 1 to prove that X is integrable\n                    apply Measurable.integrable\n                    <;> simp_all [hX]\n                    <;>\n                    (try norm_num)\n                  exact h\u2088\n                -- Since X is integrable, 2 * X is integrable\n                have h\u2089 : Integrable (fun \u03c9 : \u03a9 => (2 * X \u03c9 : \u211d)) P := by\n                  -- Use the fact that X is integrable to prove that 2 * X is integrable\n                  have h\u2081\u2080 : Integrable (fun \u03c9 : \u03a9 => (2 : \u211d)) P := by\n                    -- Prove that the constant function 2 is integrable\n                    apply integrable_const\n                  -- Use the fact that X is integrable and 2 is integrable to prove that 2 * X is integrable\n                  apply Integrable.mul h\u2081\u2080 h\u2087\n                exact h\u2089\n              -- Since 2 * X is integrable, we can apply the additivity of the integral\n              have h\u2081\u2080 : Integrable (fun \u03c9 : \u03a9 => (3 : \u211d)) P := by\n                -- Prove that the constant function 3 is integrable\n                apply integrable_const\n              -- Use the additivity of the integral\n              have h\u2081\u2081 : \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n                -- Apply the additivity of the integral\n                -- This works because both 2 * X and 3 are integrable\n                calc\n                  \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P = \u222b \u03c9 : \u03a9, ((2 * X \u03c9 : \u211d) + (3 : \u211d)) \u2202P := by simp [add_assoc]\n                  _ = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by\n                    -- Apply the additivity of the integral\n                    -- This works because both 2 * X and 3 are integrable\n                    apply integral_add\n                    <;> simp_all [h\u2086, h\u2081\u2080]\n                    <;>\n                    (try norm_num)\n                    <;>\n                    (try linarith)\n              exact h\u2081\u2081\n            exact h\u2085\n          exact h\u2084\n        exact h\u2083\n      exact h\u2082\n    exact h\u2081\n  \n  -- Combine the results to get the final equality\n  calc\n    \u222b \u03c9, (2 * X \u03c9 + 3) \u2202P = \u222b \u03c9 : \u03a9, (2 * X \u03c9 + 3 : \u211d) \u2202P := by simp\n    _ = \u222b \u03c9 : \u03a9, (2 * X \u03c9 : \u211d) \u2202P + \u222b \u03c9 : \u03a9, (3 : \u211d) \u2202P := by rw [h_add]\n    _ = \u222b \u03c9, 2 * X \u03c9 \u2202P + \u222b \u03c9, 3 \u2202P := by simp [h3]"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Applying the properties that $E[cX] = cE[X]$ for a constant $c$", "statement": "We assume:\n\u2022 X is a random variable [from tc_1]\nTherefore, we conclude:\n\u2022 E[2X] = 2 * E[X] [l3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) \n  (h : \u222b \u03c9, X \u03c9 \u2202P = 5) :\n  \u222b \u03c9, (2 * X \u03c9) \u2202P = 2 * (\u222b \u03c9, X \u03c9 \u2202P) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : MeasureTheory.Measure \u03a9) \n  (X : \u03a9 \u2192 \u211d) \n  (hX : Measurable X) \n  (hP : P (Set.univ : Set \u03a9) = 1) \n  (h : \u222b \u03c9, X \u03c9 \u2202P = 5) :\n  \u222b \u03c9, (2 * X \u03c9) \u2202P = 2 * (\u222b \u03c9, X \u03c9 \u2202P) := by\n  have h_integrable : MeasureTheory.Integrable X P := by\n    by_contra h\u2081\n    -- If X is not integrable, then the integral is 0 by definition\n    have h\u2082 : \u00acMeasureTheory.Integrable X P := h\u2081\n    have h\u2083 : \u222b \u03c9 : \u03a9, X \u03c9 \u2202P = 0 := by\n      -- Use the fact that if X is not integrable, the integral is 0\n      have h\u2084 : \u00acMeasureTheory.Integrable X P := h\u2082\n      simp_all [MeasureTheory.integral_undef]\n    -- But we have a contradiction because the integral is supposed to be 5\n    linarith\n  \n  have h_main : \u222b \u03c9, (2 * X \u03c9) \u2202P = 2 * (\u222b \u03c9, X \u03c9 \u2202P) := by\n    have h\u2081 : \u222b \u03c9 : \u03a9, (2 * X \u03c9) \u2202P = 2 * \u222b \u03c9 : \u03a9, X \u03c9 \u2202P := by\n      -- Use the linearity of the integral to factor out the constant 2\n      have h\u2082 : \u222b \u03c9 : \u03a9, (2 * X \u03c9) \u2202P = \u222b \u03c9 : \u03a9, (2 : \u211d) * X \u03c9 \u2202P := by\n        simp [mul_comm]\n      rw [h\u2082]\n      -- Apply the integral_mul_left lemma to factor out the constant\n      have h\u2083 : \u222b \u03c9 : \u03a9, (2 : \u211d) * X \u03c9 \u2202P = (2 : \u211d) * \u222b \u03c9 : \u03a9, X \u03c9 \u2202P := by\n        -- Use the fact that X is integrable to apply the lemma\n        apply MeasureTheory.integral_mul_left\n        <;>\n        (try simp_all) <;>\n        (try assumption) <;>\n        (try exact h_integrable)\n      rw [h\u2083]\n      <;>\n      (try simp_all) <;>\n      (try assumption)\n    -- The final result follows directly from the above steps\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The measurable function representation correctly formalizes the concept of a random variable", "The probability measure with unit total measure correctly captures the probability space framework", "The integral notation with respect to the probability measure is the standard mathematical formalization of expected value", "The main equality statement is a direct and accurate translation of the linearity of expectation property", "The additional constraint h : \u222b \u03c9, X \u03c9 \u2202P = 5 provides extra context but doesn't contradict the natural language statement - it's an acceptable additional condition"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "and $E[c] = c$", "statement": "We assume:\n\u2022 (This is a general property of expectation for constants)\nTherefore, we conclude:\n\u2022 E[3] = 3 [l4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)  -- expectation operator\n  (X : \u211d \u2192 \u211d)         -- random variable X\n  (h1 : E X = 5)        -- given: E[X] = 5\n  (h2 : \u2200 a : \u211d, E (fun _ => a) = a)  -- expectation of constants\n  (h3 : \u2200 f g : \u211d \u2192 \u211d, \u2200 a : \u211d, E (fun x => a * f x + g x) = a * E f + E g)  -- linearity\n  (Y : \u211d \u2192 \u211d)         -- random variable Y\n  (h4 : Y = fun x => 2 * X x + 3) :  -- Y = 2X + 3\n  E Y = 13 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)  \n  (X : \u211d \u2192 \u211d)         \n  (h1 : E X = 5)        \n  (h2 : \u2200 a : \u211d, E (fun _ => a) = a)  \n  (h3 : \u2200 f g : \u211d \u2192 \u211d, \u2200 a : \u211d, E (fun x => a * f x + g x) = a * E f + E g)  \n  (Y : \u211d \u2192 \u211d)         \n  (h4 : Y = fun x => 2 * X x + 3) :  \n  E Y = 13 := by\n  have h5 : E Y = 2 * E X + E (fun _ : \u211d => (3 : \u211d)) := by\n    have h5\u2081 : Y = (fun x : \u211d => 2 * X x + (3 : \u211d)) := by\n      rw [h4]\n      <;> funext x <;> ring\n    rw [h5\u2081]\n    have h5\u2082 : E (fun x : \u211d => 2 * X x + (3 : \u211d)) = 2 * E X + E (fun _ : \u211d => (3 : \u211d)) := by\n      have h5\u2083 : E (fun x : \u211d => 2 * X x + (3 : \u211d)) = E (fun x : \u211d => 2 * X x + (fun _ : \u211d => (3 : \u211d)) x) := by\n        congr\n        <;> funext x <;> simp\n        <;> ring\n      rw [h5\u2083]\n      have h5\u2084 : E (fun x : \u211d => 2 * X x + (fun _ : \u211d => (3 : \u211d)) x) = 2 * E X + E (fun _ : \u211d => (3 : \u211d)) := by\n        have h5\u2085 := h3 X (fun _ : \u211d => (3 : \u211d)) 2\n        -- Simplify the expression using the given linearity property\n        simp at h5\u2085 \u22a2\n        <;>\n        (try ring_nf at h5\u2085 \u22a2) <;>\n        (try simp_all) <;>\n        (try linarith) <;>\n        (try norm_num at h5\u2085 \u22a2) <;>\n        (try ring_nf at h5\u2085 \u22a2) <;>\n        (try simp_all) <;>\n        (try linarith)\n        <;>\n        (try\n          {\n            congr 1 <;>\n            funext x <;>\n            ring_nf <;>\n            simp_all <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n            <;>\n            ring_nf at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n            <;>\n            ring_nf at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n            <;>\n            ring_nf at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n            <;>\n            ring_nf at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n            <;>\n            ring_nf at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            norm_num at *\n            <;>\n            linarith\n          })\n      rw [h5\u2084]\n    rw [h5\u2082]\n    <;>\n    (try simp_all)\n    <;>\n    (try linarith)\n  \n  have h6 : E (fun _ : \u211d => (3 : \u211d)) = 3 := by\n    have h6\u2081 : E (fun _ : \u211d => (3 : \u211d)) = (3 : \u211d) := by\n      apply h2\n    rw [h6\u2081]\n    <;> norm_num\n  \n  have h7 : E Y = 13 := by\n    rw [h5]\n    rw [h6]\n    rw [h1]\n    <;> norm_num\n    <;> linarith\n  \n  exact h7", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language mentions a general property of expectation for constants without specifying it, while the Lean formalization explicitly states this property as h2. This is a minor structural difference but the semantic meaning is preserved.", "The natural language concludes E[3] = 3, but the Lean formalization proves E[Y] = 13 where Y = 2X + 3. These are fundamentally different mathematical statements - one is about the expectation of a constant, the other is about the expectation of a linear transformation of a random variable.", "Both the natural language and Lean formalization use the label [l4] for the main result, which matches perfectly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language mentions a general property of expectation for constants without specifying it, while the Lean formalization explicitly states this property as h2. This is a minor structural difference but the semantic meaning is preserved.', 'The natural language concludes E[3] = 3, but the Lean formalization proves E[Y] = 13 where Y = 2X + 3. These are fundamentally different mathematical statements - one is about the expectation of a constant, the other is about the expectation of a linear transformation of a random variable.', 'Both the natural language and Lean formalization use the label [l4] for the main result, which matches perfectly.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "we get the expression $E[Y] = 2E[X] + 3$.", "statement": "We assume:\n\u2022 E[Y] = E[2X + 3] [l1]\n\u2022 E[2X + 3] = E[2X] + E[3] [l2]\n\u2022 E[2X] = 2 * E[X] [l3]\n\u2022 E[3] = 3 [l4]\nTherefore, we conclude:\n\u2022 E[Y] = 2 * E[X] + 3 [l5].", "dependencies": ["l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)  -- expectation operator\n  (X : \u211d \u2192 \u211d)         -- random variable X\n  (h1 : E X = 5)        -- given: E[X] = 5\n  (h2 : \u2200 a : \u211d, E (fun _ => a) = a)  -- expectation of constants\n  (h3 : \u2200 f g : \u211d \u2192 \u211d, \u2200 a : \u211d, E (fun x => a * f x + g x) = a * E f + E g)  -- linearity\n  (Y : \u211d \u2192 \u211d)         -- random variable Y\n  (h4 : Y = fun x => 2 * X x + 3)     -- Y = 2X + 3\n  (l1 : E (2 * X + 3) = E (2 * X + 3)) -- dependency l1: E[Y] = E[2X + 3]\n  (l2 : E (2 * X + 3) = E (2 * X) + E (3)) -- dependency l2: E[2X + 3] = E[2X] + E[3]\n  (l3 : E (2 * X) = 2 * E X)             -- dependency l3: E[2X] = 2 * E[X]\n  (l4 : E (3) = 3)                       -- dependency l4: E[3] = 3\n  :\n  E Y = 2 * E X + 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)  \n  (X : \u211d \u2192 \u211d)         \n  (h1 : E X = 5)        \n  (h2 : \u2200 a : \u211d, E (fun _ => a) = a)  \n  (h3 : \u2200 f g : \u211d \u2192 \u211d, \u2200 a : \u211d, E (fun x => a * f x + g x) = a * E f + E g)  \n  (Y : \u211d \u2192 \u211d)         \n  (h4 : Y = fun x => 2 * X x + 3)     \n  (l1 : E (2 * X + 3) = E (2 * X + 3)) \n  (l2 : E (2 * X + 3) = E (2 * X) + E (3)) \n  (l3 : E (2 * X) = 2 * E X)             \n  (l4 : E (3) = 3)                       \n  :\n  E Y = 2 * E X + 3 := by\n  have hY : E Y = E (2 * X + 3) := by\n    have h5 : Y = 2 * X + 3 := by\n      funext x\n      rw [h4]\n      <;> simp [Pi.add_apply, Pi.smul_apply]\n      <;> ring\n    rw [h5]\n    <;>\n    simp [Pi.add_apply, Pi.smul_apply]\n    <;>\n    ring\n  \n  have h_step1 : E Y = E (2 * X) + E (3) := by\n    have h6 : E (2 * X + 3) = E (2 * X) + E (3) := l2\n    linarith\n  \n  have h_step2 : E Y = 2 * E X + E (3) := by\n    have h7 : E Y = E (2 * X) + E (3) := h_step1\n    have h8 : E (2 * X) = 2 * E X := l3\n    linarith\n  \n  have h_step3 : E Y = 2 * E X + 3 := by\n    have h9 : E Y = 2 * E X + E (3) := h_step2\n    have h10 : E (3 : \u211d \u2192 \u211d) = 3 := by\n      have h11 := h2 (3 : \u211d)\n      simpa using h11\n    have h11 : E (3 : \u211d \u2192 \u211d) = 3 := h10\n    simp [h11] at h9 \u22a2\n    <;> linarith\n  \n  exact h_step3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the overall logical structure correctly but has some issues: (1) It includes an extra assumption 'h1 : E X = 5' not mentioned in the natural language, (2) The dependency l1 is formalized as a tautology 'E (2 * X + 3) = E (2 * X + 3)' rather than the intended relationship 'E Y = E (2 * X + 3)', and (3) There are minor notational differences like '2 * X' vs '2X'. Despite these issues, the core mathematical meaning and proof structure are preserved, making this a minor rather than major inconsistency."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization captures the overall logical structure correctly but has some issues: (1) It includes an extra assumption 'h1 : E X = 5' not mentioned in the natural language, (2) The dependency l1 is formalized as a tautology 'E (2 * X + 3) = E (2 * X + 3)' rather than the intended relationship 'E Y = E (2 * X + 3)', and (3) There are minor notational differences like '2 * X' vs '2X'. Despite these issues, the core mathematical meaning and proof structure are preserved, making this a minor rather than major inconsistency.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Using the given condition $E[X] = 5$, we substitute this into our expression to get $E[Y] = 2(5) + 3 = 13$.", "statement": "We assume:\n\u2022 The expected value of X is E[X] = 5 [tc_1]\n\u2022 The expected value of Y is given by the expression E[Y] = 2 * E[X] + 3 [l5]\nTherefore, we conclude:\n\u2022 E[Y] = 13 [ts_1].", "dependencies": ["tc_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)  -- expectation operator\n  (X Y : \u211d \u2192 \u211d)       -- random variables\n  (hX : E X = 5)        -- given: E[X] = 5 [tc_1]\n  (hY : E Y = 2 * E X + 3)  -- given: E[Y] = 2 * E[X] + 3 [l5]\n  :\n  E Y = 13 := by sorry  -- conclusion: E[Y] = 13 [ts_1]", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)  \n  (X Y : \u211d \u2192 \u211d)       \n  (hX : E X = 5)        \n  (hY : E Y = 2 * E X + 3)  \n  :\n  E Y = 13 := by\n  have h1 : E Y = 13 := by\n    rw [hY]\n    rw [hX]\n    norm_num\n  exact h1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The mathematical setup correctly models the expectation operator and random variables as functions from reals to reals, which is appropriate for the probability theory context.", "The first assumption E[X] = 5 is exactly captured as hX : E X = 5, with proper reference to tc_1 maintained in the comment.", "The second assumption about the relationship E[Y] = 2 * E[X] + 3 is precisely formalized as hY : E Y = 2 * E X + 3, with reference l5 preserved.", "The conclusion E[Y] = 13 is correctly stated as the goal, with reference ts_1 maintained and the logical 'therefore' relationship properly represented in the theorem structure.", "The mathematical reasoning (substituting E[X] = 5 into E[Y] = 2 * E[X] + 3 to get E[Y] = 13) is implicitly captured in the theorem structure, where the proof would demonstrate this calculation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    