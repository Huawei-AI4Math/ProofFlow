
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}$ and $\mathbf{Y}$ are in $\R^n,$ then
\begin{equation}\label{eq:5.1.6}
|\mathbf{X}+\mathbf{Y}|\le |\mathbf{X}|+|\mathbf{Y}|,
\end{equation}
with equality if and only if one of the vectors is a nonnegative
multiple of the other$.$

We can assume the following statement(s) without a proof. 

If $\mathbf{X}$ and $\mathbf{Y}$ are any two vectors in $\R^n,$ then
\begin{equation} \label{eq:5.1.3}
|\mathbf{X}\cdot\mathbf{Y}|\le |\mathbf{X}|\,|\mathbf{Y}|,
\end{equation}
with equality  if and only if one of the vectors is a scalar
multiple of the other$.$

Proof: By definition,
\begin{equation} \label{eq:5.1.7}
\begin{array}{rcl}
|\mathbf{X}+\mathbf{Y}|^2\ar=\dst\sum^n_{i=1} (x_i+y_i)^2=\sum^n_{i=1} x^2_i+
2\sum^n_{i=1} x_iy_i+\sum^n_{i=1}y^2_i\\[4\jot]
\ar=|\mathbf{X}|^2+2(\mathbf{X}\cdot\mathbf{Y})+|\mathbf{Y}|^2\\[2\jot]
\ar\le  |\mathbf{X}|^2+2|\mathbf{X}|\,|\mathbf{Y}|+|\mathbf{Y}|^2\mbox{\quad (by
Schwarz's inequality)}\\[2\jot]
\ar=(|\mathbf{X}|+|\mathbf{Y}|)^2.
\end{array}
\end{equation}
Hence,
$$
|\mathbf{X}+\mathbf{Y}|^2\le (|\mathbf{X}|+|\mathbf{Y}|)^2.
$$
Taking square roots yields \eqref{eq:5.1.6}.
From the third line of \eqref{eq:5.1.7},
equality holds in \eqref{eq:5.1.6} if and
only  if $\mathbf{X}\cdot\mathbf{Y}=|\mathbf{X}||\mathbf{Y}|$, which is true if
and
only if one of the vectors $\mathbf{X}$ and $\mathbf{Y}$ is a nonnegative
scalar multiple of the other (Lemma~\ref{thmtype:5.1.5}).
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X}$ and $\\mathbf{Y}$ are in $\\R^n,$", "statement": "Premise:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (X Y : Fin n \u2192 \u211d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents vectors in \u211d\u207f using the standard type `Fin n \u2192 \u211d`, which is the canonical way to represent n-dimensional real vectors in Lean. The variable declarations match the mathematical statement perfectly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "If $\\mathbf{X}$ and $\\mathbf{Y}$ are any two vectors in $\\R^n,$ then\n\\begin{equation} \\label{eq:5.1.3}\n|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|,\n\\end{equation}\nwith equality  if and only if one of the vectors is a scalar\nmultiple of the other$.$", "statement": "Definition:\n\u2022 For any two vectors $\\mathbf{U}, \\mathbf{V} \\in \\mathbb{R}^n$, the Cauchy-Schwarz inequality states that $|\\mathbf{U}\\cdot\\mathbf{V}| \\le |\\mathbf{U}| \\cdot |\\mathbf{V}|$, with equality holding if and only if one vector is a scalar multiple of the other [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 {n : \u2115} (U V : Fin n \u2192 \u211d) :\n  |\u2211 i, U i * V i| \u2264 \u2016U\u2016 * \u2016V\u2016 \u2227\n  (|\u2211 i, U i * V i| = \u2016U\u2016 * \u2016V\u2016 \u2194 \n   \u2203 c : \u211d, U = c \u2022 V \u2228 V = c \u2022 U) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization represents vectors as functions `Fin n \u2192 \u211d`, which is the standard way to represent n-dimensional real vectors in Lean. This perfectly captures the mathematical concept of vectors in \u211d\u207f.", "The Lean inequality `|\u2211 i, U i * V i| \u2264 \u2016U\u2016 * \u2016V\u2016` correctly formalizes the Cauchy-Schwarz inequality. The sum `\u2211 i, U i * V i` represents the dot product, and `\u2016U\u2016`, `\u2016V\u2016` represent the norms (magnitudes) of the vectors.", "The equality condition `|\u2211 i, U i * V i| = \u2016U\u2016 * \u2016V\u2016 \u2194 \u2203 c : \u211d, U = c \u2022 V \u2228 V = c \u2022 U` perfectly captures the mathematical statement that equality holds if and only if one vector is a scalar multiple of the other. The `c \u2022 V` notation represents scalar multiplication, and the disjunction covers both cases (U is a multiple of V or V is a multiple of U)."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "equality holds in \\eqref{eq:5.1.6} if and\nonly  if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$, which is true if\nand\nonly if one of the vectors $\\mathbf{X}$ and $\\mathbf{Y}$ is a nonnegative\nscalar multiple of the other (Lemma~\\ref{thmtype:5.1.5}).", "statement": "Definition:\n\u2022 For any two vectors $\\mathbf{U}, \\mathbf{V} \\in \\mathbb{R}^n$, the equality $\\mathbf{U}\\cdot\\mathbf{V} = |\\mathbf{U}| \\cdot |\\mathbf{V}|$ holds if and only if one vector is a non-negative scalar multiple of the other [def_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2 {n : \u2115} (U V : Fin n \u2192 \u211d) :\n  (\u2211 i, U i * V i = (\u2211 i, U i ^ 2) ^ (1/2) * (\u2211 i, V i ^ 2) ^ (1/2)) \u2194 \n  (\u2203 c : \u211d, c \u2265 0 \u2227 (U = c \u2022 V \u2228 V = c \u2022 U)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The vector space specification matches: both refer to n-dimensional real vectors, with Lean using function type Fin n \u2192 \u211d which is equivalent to \u211d\u207f", "The dot product equality condition matches: Lean's sum notation \u2211 i, U i * V i correctly represents the dot product, and the magnitude expressions using square roots of sums of squares are mathematically equivalent to |U| and |V|", "The conclusion about scalar multiples matches: Lean's existential statement with c \u2265 0 and the disjunction (U = c \u2022 V \u2228 V = c \u2022 U) correctly captures 'one vector is a non-negative scalar multiple of the other'", "The vector space specification matches for the reverse direction as well", "The scalar multiple condition matches: the same Lean expression correctly represents the natural language condition", "The dot product equality conclusion matches: the same mathematical equivalence holds for the reverse direction"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "\\begin{array}{rcl}\n|\\mathbf{X}+\\mathbf{Y}|^2\\ar=\\dst\\sum^n_{i=1} (x_i+y_i)^2=\\sum^n_{i=1} x^2_i+\n2\\sum^n_{i=1} x_iy_i+\\sum^n_{i=1}y^2_i\\[4\\jot]\n\\ar=|\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2\n\\end{array}", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2 + 2(\\mathbf{X}\\cdot\\mathbf{Y}) + |\\mathbf{Y}|^2$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d) :\n  \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (X \u2022 Y) + \u2016Y\u2016^2 := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 14, "endLine": 9, "endColumn": 33, "data": "failed to synthesize\n  HAdd \u211d (Fin n \u2192 \u211d) ?m.1925\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d) :\n  \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (X \u2022 Y) + \u2016Y\u2016^2 := by\n  classical\n    by_cases h : \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (X \u2022 Y) + \u2016Y\u2016 ^ 2\n    \u00b7 exact h\n    \u00b7 exfalso\n      -- Attempt to derive a contradiction\n      have h\u2081 : False := by\n        -- This is a placeholder for the actual contradiction derivation\n        -- Since we cannot derive a contradiction, we use `simp_all` to simplify the goal\n        simp_all [Pi.norm_def, Finset.sum_add_distrib, add_sq]\n        <;>\n        simp_all [Real.norm_eq_abs, sq_abs]\n        <;>\n        ring_nf\n        <;>\n        simp_all [Finset.sum_add_distrib, add_assoc, add_comm, add_left_comm]\n      exact h\u2081", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 6, "column": 14, "endLine": 6, "endColumn": 33, "data": "failed to synthesize\n  HAdd \u211d (Fin n \u2192 \u211d) ?m.1925\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 8, "column": 31, "endLine": 8, "endColumn": 52, "data": "failed to synthesize\n  HAdd \u211d (Fin n \u2192 \u211d) ?m.4740\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 12, "endLine": 9, "endColumn": 13, "data": "unknown identifier 'h'"}, {"line": 17, "column": 8, "endLine": 17, "endColumn": 43, "data": "simp_all made no progress"}, {"line": 6, "column": 45, "endLine": 22, "endColumn": 14, "data": "unsolved goals\ncase neg\nn : \u2115\nX Y : Fin n \u2192 \u211d\nh : \u00ac\u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * X \u2022 Y + \u2016Y\u2016 ^ 2\n\u22a2 \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * X \u2022 Y + \u2016Y\u2016 ^ 2"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "\\ar\\le  |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2\\mbox{\\quad (by\nSchwarz's inequality)}\\[2\\jot]\n\\ar=(|\\mathbf{X}|+|\\mathbf{Y}|)^2.", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2 + 2(\\mathbf{X}\\cdot\\mathbf{Y}) + |\\mathbf{Y}|^2$ [l1].\n\u2022 For any vectors $\\mathbf{U}, \\mathbf{V} \\in \\mathbb{R}^n$, $|\\mathbf{U}\\cdot\\mathbf{V}| \\le |\\mathbf{U}| \\cdot |\\mathbf{V}|$ [def_1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l2].", "dependencies": ["tc_1", "l1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (def_1 : \u2200 (U V : Fin n \u2192 \u211d), |\u2211 i, U i * V i| \u2264 \u2016U\u2016 * \u2016V\u2016) :\n  \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (def_1 : \u2200 (U V : Fin n \u2192 \u211d), |\u2211 i, U i * V i| \u2264 \u2016U\u2016 * \u2016V\u2016) :\n  \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n  have h_sum_le : (\u2211 i : Fin n, X i * Y i) \u2264 \u2016X\u2016 * \u2016Y\u2016 := by\n    have h1 : |\u2211 i : Fin n, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016 := def_1 X Y\n    have h2 : (\u2211 i : Fin n, X i * Y i) \u2264 |\u2211 i : Fin n, X i * Y i| := by\n      exact le_abs_self _\n    linarith\n  \n  have h_sum_le_2 : 2 * (\u2211 i : Fin n, X i * Y i) \u2264 2 * (\u2016X\u2016 * \u2016Y\u2016) := by\n    have h\u2081 : (\u2211 i : Fin n, X i * Y i) \u2264 \u2016X\u2016 * \u2016Y\u2016 := h_sum_le\n    have h\u2082 : 2 * (\u2211 i : Fin n, X i * Y i) \u2264 2 * (\u2016X\u2016 * \u2016Y\u2016) := by\n      -- Multiply both sides of the inequality by 2, which is positive, so the inequality direction remains the same.\n      linarith\n    exact h\u2082\n  \n  have h_main : \u2016X\u2016^2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n    have h2 : 0 \u2264 \u2016X\u2016 := norm_nonneg X\n    have h3 : 0 \u2264 \u2016Y\u2016 := norm_nonneg Y\n    have h4 : 0 \u2264 \u2016X\u2016 * \u2016Y\u2016 := by positivity\n    have h5 : (\u2016X\u2016 + \u2016Y\u2016)^2 = \u2016X\u2016^2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016^2 := by\n      ring\n    have h6 : \u2016X\u2016^2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016^2 := by\n      linarith\n    linarith\n  \n  have h_final : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n    calc\n      \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 := by\n        rw [l1]\n        <;> simp [Finset.sum_congr]\n      _ \u2264 (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n        exact h_main\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Vector representation as Fin n \u2192 \u211d correctly captures vectors in \u211d\u207f using standard Lean/Mathlib conventions", "The norm expansion formula is accurately translated with proper dot product representation as sum and correct norm notation", "Cauchy-Schwarz inequality is correctly formalized with proper universal quantification and mathematical notation", "The triangle inequality conclusion is directly and accurately translated"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Taking square roots yields \\eqref{eq:5.1.6}.", "statement": "We assume:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l2].\n\u2022 The norm of a vector is non-negative.\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l2 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l2 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n  have h\u2081 : 0 \u2264 \u2016X + Y\u2016 := by\n    exact norm_nonneg _\n  \n  have h\u2082 : 0 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n    have h\u2082\u2081 : 0 \u2264 \u2016X\u2016 := norm_nonneg X\n    have h\u2082\u2082 : 0 \u2264 \u2016Y\u2016 := norm_nonneg Y\n    linarith\n  \n  have h\u2083 : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n    have h\u2083\u2081 : 0 \u2264 \u2016X + Y\u2016 := h\u2081\n    have h\u2083\u2082 : 0 \u2264 \u2016X\u2016 + \u2016Y\u2016 := h\u2082\n    nlinarith [sq_nonneg (\u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016)), l2]\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Vector representation as Fin n \u2192 \u211d is mathematically equivalent to standard vector notation, and norm notation \u2016\u00b7\u2016 correctly corresponds to |\u00b7|", "The assumption l2 is perfectly captured with equivalent mathematical notation", "While not explicitly stated, the non-negativity of norms is built into Mathlib's norm definitions, making this assumption implicitly available", "The conclusion ts_1 is perfectly represented with equivalent mathematical notation", "The logical structure correctly captures the inference from the squared inequality to the triangle inequality"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "l3": {"id": "l3", "natural_language": "From the third line of \\eqref{eq:5.1.7}, equality holds in \\eqref{eq:5.1.6} if and only if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$.", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\mathbb{R}^n$ [tc_1].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2 + 2(\\mathbf{X}\\cdot\\mathbf{Y}) + |\\mathbf{Y}|^2$ [l1].\n\u2022 The reasoning leading to $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l2].\nTherefore, we conclude:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ if and only if $\\mathbf{X}\\cdot\\mathbf{Y} = |\\mathbf{X}| \\cdot |\\mathbf{Y}|$ [l3].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (l2 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  (\u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016) \u2194 (\u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {n : \u2115} (X Y : Fin n \u2192 \u211d)\n  (l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (l2 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  (\u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016) \u2194 (\u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) := by\n  have h_forward : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2192 (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 := by\n    intro h\n    have h3 : \u2016X + Y\u2016 ^ 2 = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n      rw [h]\n      <;> ring_nf\n    have h4 : \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n      calc\n        \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 = \u2016X + Y\u2016 ^ 2 := by\n          rw [l1]\n          <;> simp [Finset.sum_range_succ]\n        _ = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by rw [h3]\n    have h5 : \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016 ^ 2 := by\n      calc\n        \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by rw [h4]\n        _ = \u2016X\u2016 ^ 2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016 ^ 2 := by ring\n    have h6 : 2 * (\u2211 i : Fin n, X i * Y i) = 2 * (\u2016X\u2016 * \u2016Y\u2016) := by\n      linarith\n    have h7 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 := by\n      linarith\n    exact h7\n  \n  have h_backward : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 \u2192 \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n    intro h\n    have h3 : \u2016X + Y\u2016 ^ 2 = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n      calc\n        \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 := by\n          rw [l1]\n          <;> simp [Finset.sum_range_succ]\n        _ = \u2016X\u2016 ^ 2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016 ^ 2 := by\n          rw [h]\n          <;> ring\n        _ = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by ring\n    have h4 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n      have h5 : 0 \u2264 \u2016X + Y\u2016 := norm_nonneg _\n      have h6 : 0 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by positivity\n      have h7 : 0 \u2264 \u2016X\u2016 := norm_nonneg _\n      have h8 : 0 \u2264 \u2016Y\u2016 := norm_nonneg _\n      nlinarith [sq_nonneg (\u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016))]\n    exact h4\n  \n  have h_main : (\u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016) \u2194 (\u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) := by\n    constructor\n    \u00b7 -- Prove the forward direction: if \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016, then \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016\n      intro h\n      exact h_forward h\n    \u00b7 -- Prove the backward direction: if \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016, then \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016\n      intro h\n      exact h_backward h\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Vector representation as functions Fin n \u2192 \u211d is the standard and correct way to represent n-dimensional real vectors in Lean", "The norm expansion formula is correctly translated with appropriate Lean notation for norms and dot products", "The triangle inequality constraint is directly and correctly translated", "The main biconditional statement about equality conditions is accurately captured with proper Lean notation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "which is true if and only if one of the vectors $\\mathbf{X}$ and $\\mathbf{Y}$ is a nonnegative scalar multiple of the other (Lemma~\\ref{thmtype:5.1.5}).", "statement": "We assume:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ if and only if $\\mathbf{X}\\cdot\\mathbf{Y} = |\\mathbf{X}| \\cdot |\\mathbf{Y}|$ [l3].\n\u2022 For any two vectors $\\mathbf{U}, \\mathbf{V} \\in \\mathbb{R}^n$, $\\mathbf{U}\\cdot\\mathbf{V} = |\\mathbf{U}| \\cdot |\\mathbf{V}|$ if and only if one vector is a non-negative scalar multiple of the other [def_2].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}| = |\\mathbf{X}|+|\\mathbf{Y}|$ if and only if one of the vectors is a nonnegative multiple of the other [ts_2].", "dependencies": ["l3", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 {n : \u2115} (X Y : Fin n \u2192 \u211d) \n  (l3 : \u2200 (X Y : Fin n \u2192 \u211d), \n    \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n    \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016)\n  (def_2 : \u2200 (U V : Fin n \u2192 \u211d), \n    (\u2211 i, U i * V i) = \u2016U\u2016 * \u2016V\u2016 \u2194 \n    \u2203 c : \u211d, c \u2265 0 \u2227 ((U = c \u2022 V) \u2228 (V = c \u2022 U))) :\n  \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n  \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 {n : \u2115} (X Y : Fin n \u2192 \u211d) \n  (l3 : \u2200 (X Y : Fin n \u2192 \u211d), \n    \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n    \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016)\n  (def_2 : \u2200 (U V : Fin n \u2192 \u211d), \n    (\u2211 i, U i * V i) = \u2016U\u2016 * \u2016V\u2016 \u2194 \n    \u2203 c : \u211d, c \u2265 0 \u2227 ((U = c \u2022 V) \u2228 (V = c \u2022 U))) :\n  \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n  \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := by\n  have h_forward : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2192 (\u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X))) := by\n    intro h\n    have h1 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n      have h2 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := l3 X Y\n      have h3 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := h\n      have h4 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n        rw [h2] at *\n        exact h3\n      exact h4\n    have h2 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 \u2194 \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := def_2 X Y\n    have h3 : \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := by\n      have h4 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 := h1\n      have h5 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 \u2194 \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := h2\n      have h6 : \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := by\n        rw [h5] at h4\n        exact h4\n      exact h6\n    exact h3\n  \n  have h_backward : (\u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X))) \u2192 \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n    intro h\n    have h1 : \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := h\n    have h2 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 := by\n      have h3 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 \u2194 \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := def_2 X Y\n      have h4 : \u2203 c : \u211d, c \u2265 0 \u2227 ((X = c \u2022 Y) \u2228 (Y = c \u2022 X)) := h1\n      have h5 : (\u2211 i : Fin n, X i * Y i) = \u2016X\u2016 * \u2016Y\u2016 := by\n        rw [h3]\n        exact h4\n      exact h5\n    have h3 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n      have h4 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := l3 X Y\n      have h5 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h2\n      have h6 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n        rw [h4]\n        exact h5\n      exact h6\n    exact h3\n  \n  exact \u27e8h_forward, h_backward\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly and completely captures all mathematical and logical content from the natural language. The vector representation using Fin n \u2192 \u211d is appropriate, the norm notation \u2016\u00b7\u2016 correctly represents vector magnitude, the dot product is properly formalized as a sum, and all logical relationships (biconditionals, existential quantification, scalar multiplication) are accurately translated. The theorem structure with assumptions l3 and def_2 leading to conclusion ts_2 perfectly mirrors the natural language reasoning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    