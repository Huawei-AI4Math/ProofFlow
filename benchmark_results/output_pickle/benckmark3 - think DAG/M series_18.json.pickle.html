
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = 2^n - 1$.

Proof: This proof uses **strong mathematical induction** because the recurrence relation for $a_n$ depends on two previous terms. First, we verify the formula for the initial terms, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1 = 2^1 - 1 = 1$. This matches the given value of $a_1=1$. For $n=2$, the formula gives $a_2 = 2^2 - 1 = 3$. This matches the given value of $a_2=3$. Now for the inductive step, assume the formula holds for all integers $j$ where $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^j - 1$ is true. We must now prove that the formula holds for $n=k+1$, i.e., $a_{k+1} = 2^{k+1} - 1$. Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = 3a_k - 2a_{k-1}$. By our assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$. Now we expand and simplify the expression: $a_{k+1} = 3 \cdot 2^k - 3 - 2 \cdot 2^{k-1} + 2 = 3 \cdot 2^k - 2^k - 1 = 2 \cdot 2^k - 1 = 2^{k+1} - 1$. This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^n - 1$ is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined by:\n  \u2022 $a_1=1$,\n  \u2022 $a_2=3$,\n  \u2022 $a_n = 3a_{n-1} - 2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2200 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))) \u2192\n    (\u2200 n, n \u2265 1 \u2192 a n = 2^n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The initial condition a_1 = 1 is correctly captured in Lean as 'a 1 = 1'", "The initial condition a_2 = 3 is correctly captured in Lean as 'a 2 = 3'", "The recurrence relation is correctly formalized in Lean with the same mathematical meaning", "The natural language conclusion states that the sequence is well-defined for all n \u2265 1, which means the sequence exists and can be computed. However, the Lean conclusion provides a specific closed-form formula a_n = 2^n - 1, which is a much stronger and completely different statement than just asserting well-definedness"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The initial condition a_1 = 1 is correctly captured in Lean as 'a 1 = 1'\", \"The initial condition a_2 = 3 is correctly captured in Lean as 'a 2 = 3'\", 'The recurrence relation is correctly formalized in Lean with the same mathematical meaning', 'The natural language conclusion states that the sequence is well-defined for all n \u2265 1, which means the sequence exists and can be computed. However, the Lean conclusion provides a specific closed-form formula a_n = 2^n - 1, which is a much stronger and completely different statement than just asserting well-definedness']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1 = 2^1 - 1 = 1$.", "statement": "We conclude:\n\u2022 For n=1, the expression $2^n - 1$ evaluates to $2^1 - 1 = 1$ [l1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 : 2^1 - 1 = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 : 2^1 - 1 = 1 := by\n  have h : 2^1 = 2 := by\n    norm_num\n    <;> rfl\n  \n  have h2 : 2 - 1 = 1 := by\n    norm_num\n    <;> rfl\n  \n  have h3 : 2^1 - 1 = 1 := by\n    rw [h]\n    <;> rw [h2]\n    <;> rfl\n  \n  apply h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean theorem l1 correctly captures the mathematical content of the natural language statement. While the natural language provides context about evaluating an expression for n=1, the core mathematical claim is the equality 2^1 - 1 = 1, which is exactly what the Lean formalization states. The labeling is also consistent between both versions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "This matches the given value of $a_1=1$.", "statement": "We assume:\n\u2022 The sequence is defined with $a_1=1$ [tc_1].\n\u2022 For n=1, the expression $2^n - 1$ evaluates to 1 [l1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^n - 1$ holds for n=1 [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2200 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))) \u2192\n    (\u2200 n, n \u2265 1 \u2192 a n = 2^n - 1) := by sorry\n\ntheorem l1 : 2^1 - 1 = 1 := by sorry\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : 2^1 - 1 = 1) :\n  a 1 = 2^1 - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2200 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))) \u2192\n    (\u2200 n, n \u2265 1 \u2192 a n = 2^n - 1) := by\n  intro a h\n  have h\u2081 : a 1 = 1 := by\n    have h\u2081\u2081 : a 1 = 1 := h.1\n    exact h\u2081\u2081\n\n  have h\u2082 : a 2 = 3 := by\n    have h\u2082\u2081 : a 2 = 3 := h.2.1\n    exact h\u2082\u2081\n\n  have h\u2083 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2) := by\n    have h\u2083\u2081 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2) := h.2.2\n    exact h\u2083\u2081\n\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n    intro n hn\n    have h\u2084 : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false.\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h\u2081] at hn \u22a2 <;>\n        simp_all [h\u2081]\n        <;>\n        norm_num\n        <;>\n        linarith\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h\u2082] at hn \u22a2 <;>\n        simp_all [h\u2082]\n        <;>\n        norm_num\n        <;>\n        linarith\n      | k + 3 =>\n        -- Inductive step: assume the statement holds for all m < k + 3, prove for k + 3\n        have h\u2085 := h\u2083 (k + 3) (by linarith)\n        have h\u2086 := ih (k + 2) (by omega)\n        have h\u2087 := ih (k + 1) (by omega)\n        have h\u2088 : (k + 3 : \u2115) \u2265 3 := by linarith\n        have h\u2089 : a (k + 3) = 3 * a (k + 2) - 2 * a (k + 1) := by\n          simpa [Nat.add_assoc] using h\u2085\n        have h\u2081\u2080 : a (k + 2) = (2 : \u211d)^(k + 2) - 1 := by\n          have h\u2081\u2081 : (k + 2 : \u2115) \u2265 1 := by linarith\n          have h\u2081\u2082 : a (k + 2) = (2 : \u211d)^(k + 2) - 1 := by\n            specialize ih (k + 2) (by omega)\n            simpa [h\u2081\u2081] using ih (by linarith)\n          exact h\u2081\u2082\n        have h\u2081\u2081 : a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n          have h\u2081\u2082 : (k + 1 : \u2115) \u2265 1 := by linarith\n          have h\u2081\u2083 : a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n            specialize ih (k + 1) (by omega)\n            simpa [h\u2081\u2082] using ih (by linarith)\n          exact h\u2081\u2083\n        rw [h\u2089, h\u2081\u2080, h\u2081\u2081]\n        -- Simplify the expression to show it equals (2 : \u211d)^(k + 3) - 1\n        have h\u2081\u2082 : (3 : \u211d) * ((2 : \u211d)^(k + 2) - 1) - 2 * ((2 : \u211d)^(k + 1) - 1) = (2 : \u211d)^(k + 3) - 1 := by\n          have h\u2081\u2083 : (2 : \u211d)^(k + 3) = (2 : \u211d)^(k + 2) * 2 := by\n            ring_nf\n            <;> simp [pow_succ]\n            <;> ring_nf\n          have h\u2081\u2084 : (2 : \u211d)^(k + 2) = (2 : \u211d)^(k + 1) * 2 := by\n            ring_nf\n            <;> simp [pow_succ]\n            <;> ring_nf\n          calc\n            (3 : \u211d) * ((2 : \u211d)^(k + 2) - 1) - 2 * ((2 : \u211d)^(k + 1) - 1) = 3 * (2 : \u211d)^(k + 2) - 3 - 2 * (2 : \u211d)^(k + 1) + 2 := by ring\n            _ = 3 * (2 : \u211d)^(k + 2) - 2 * (2 : \u211d)^(k + 1) - 1 := by ring\n            _ = 3 * ((2 : \u211d)^(k + 1) * 2) - 2 * (2 : \u211d)^(k + 1) - 1 := by rw [h\u2081\u2084]\n            _ = (3 * 2 - 2) * (2 : \u211d)^(k + 1) - 1 := by ring\n            _ = 4 * (2 : \u211d)^(k + 1) - 1 := by ring\n            _ = 2 ^ 2 * (2 : \u211d)^(k + 1) - 1 := by norm_num\n            _ = (2 : \u211d)^(k + 1 + 2) - 1 := by\n              rw [\u2190 pow_add]\n              <;> ring_nf\n              <;> norm_num\n            _ = (2 : \u211d)^(k + 3) - 1 := by\n              ring_nf\n              <;> simp [pow_succ]\n              <;> ring_nf\n        rw [h\u2081\u2082]\n        <;> simp_all [pow_add, pow_one, mul_assoc]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n    exact h\u2084 n hn\n  \n  have h_final : \u2200 n, n \u2265 1 \u2192 a n = 2^n - 1 := by\n    intro n hn\n    have h\u2084 : a n = (2 : \u211d)^n - 1 := h_main n hn\n    have h\u2085 : (2 : \u211d)^n - 1 = (2 : \u2115)^n - 1 := by\n      norm_cast\n      <;>\n      simp [pow_succ]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      simp_all [h\u2081]\n      <;>\n      linarith\n    rw [h\u2084, h\u2085]\n    <;>\n    norm_cast\n    <;>\n    simp_all [h\u2081]\n    <;>\n    linarith\n  \n  exact h_final\n\ntheorem l1 : 2^1 - 1 = 1 := by\n  norm_num\n  <;>\n  simp_all\n  <;>\n  linarith\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : 2^1 - 1 = 1) :\n  a 1 = 2^1 - 1 := by\n  have h3 : a 1 = (2 : \u211d)^1 - 1 := by\n    have h4 : (2 : \u211d)^1 - 1 = (1 : \u211d) := by norm_num\n    have h5 : a 1 = (1 : \u211d) := by\n      norm_num [h1]\n    linarith\n  norm_num at h3 \u22a2\n  <;>\n  simp_all [h1]\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language only mentions a_1=1 as an assumption, but the Lean formalization introduces additional conditions (a_2=3 and a recurrence relation) and proves a general formula. This significantly expands beyond what's stated in the natural language.", "Both the natural language and Lean correctly state that 2^1 - 1 = 1.", "Both establish that the formula a_n = 2^n - 1 holds for n=1, with the Lean version providing the logical structure to prove this from the given hypotheses."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language only mentions a_1=1 as an assumption, but the Lean formalization introduces additional conditions (a_2=3 and a recurrence relation) and proves a general formula. This significantly expands beyond what's stated in the natural language.\", 'Both the natural language and Lean correctly state that 2^1 - 1 = 1.', 'Both establish that the formula a_n = 2^n - 1 holds for n=1, with the Lean version providing the logical structure to prove this from the given hypotheses.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "For $n=2$, the formula gives $a_2 = 2^2 - 1 = 3$.", "statement": "We conclude:\n\u2022 For n=2, the expression $2^n - 1$ evaluates to $2^2 - 1 = 3$ [l3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : 2^2 - 1 = 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : 2^2 - 1 = 3 := by\n  have h : 2^2 - 1 = 3 := by\n    norm_num\n  exact h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the mathematical statement from the natural language. The theorem l3 states exactly the same equality (2^2 - 1 = 3) that is concluded in the natural language, and the theorem name corresponds to the reference [l3]. The proof placeholder 'by sorry' is an implementation detail that doesn't affect the semantic meaning of the mathematical claim being made."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "This matches the given value of $a_2=3$.", "statement": "We assume:\n\u2022 The sequence is defined with $a_2=3$ [tc_1].\n\u2022 For n=2, the expression $2^n - 1$ evaluates to 3 [l3].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^n - 1$ holds for n=2 [l4].", "dependencies": ["tc_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 2 = 3) -- from tc_1: a_2 = 3\n  (h2 : (2 : \u211d)^2 - 1 = 3) -- from l3: 2^2 - 1 = 3\n  : a 2 = (2 : \u211d)^2 - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 2 = 3) \n  (h2 : (2 : \u211d)^2 - 1 = 3) \n  : a 2 = (2 : \u211d)^2 - 1 := by\n  have h3 : a 2 = (2 : \u211d)^2 - 1 := by\n    rw [h1]\n    -- Now we have 3 = (2 : \u211d)^2 - 1, which is the same as h2 but in reverse.\n    -- We can use the symmetry of equality to conclude the proof.\n    linarith\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition and the condition a\u2082=3 are correctly captured with appropriate type declarations", "The evaluation of 2^n-1 for n=2 is correctly formalized with proper type annotations for real numbers", "The conclusion that the formula holds for n=2 is accurately represented as the equality a 2 = (2 : \u211d)^2 - 1", "The logical structure perfectly matches: two hypotheses leading to a conclusion that follows by transitivity of equality"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the formula holds for all integers $j$ where $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^j - 1$ is true.", "statement": "Definition:\n\u2022 For the inductive step, we fix an integer $k \\geq 2$ and assume that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^j - 1$ holds. This is the strong induction hypothesis [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n) -- sequence of positive reals\n(tc_2 : a 1 = 1 \u2227 a 2 = 3) -- initial conditions\n(tc_3 : \u2200 n \u2265 3, a n = 3 * a (n-1) - 2 * a (n-2)) -- recurrence relation\n(def_1 : \u2200 k \u2265 2, (\u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k+1) = 2^(k+1) - 1) -- strong induction hypothesis", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language talks about fixing a specific integer k \u2265 2, while Lean uses universal quantification over all k \u2265 2. This is a structural difference in how the induction step is formulated.", "The condition about the formula holding for all j with 1 \u2264 j \u2264 k is perfectly captured in the Lean premise.", "The natural language only mentions establishing the strong induction hypothesis, but the Lean definition actually defines what the hypothesis IS and includes an additional implication to a (k+1) = 2^(k+1) - 1 that's not mentioned in the natural language. This is a significant logical difference."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language talks about fixing a specific integer k \u2265 2, while Lean uses universal quantification over all k \u2265 2. This is a structural difference in how the induction step is formulated.', 'The condition about the formula holding for all j with 1 \u2264 j \u2264 k is perfectly captured in the Lean premise.', \"The natural language only mentions establishing the strong induction hypothesis, but the Lean definition actually defines what the hypothesis IS and includes an additional implication to a (k+1) = 2^(k+1) - 1 that's not mentioned in the natural language. This is a significant logical difference.\"]"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = 3a_k - 2a_{k-1}$.", "statement": "We assume:\n\u2022 The recurrence relation is $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 3a_k - 2a_{k-1}$ [l5].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2200 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))) \u2192\n    (\u2200 n, n \u2265 1 \u2192 a n = 2^n - 1) := by sorry\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n) -- sequence of positive reals\n(tc_2 : a 1 = 1 \u2227 a 2 = 3) -- initial conditions  \n(tc_3 : \u2200 n \u2265 3, a n = 3 * a (n-1) - 2 * a (n-2)) -- recurrence relation\n(def_1 : \u2200 k \u2265 2, (\u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k+1) = 2^(k+1) - 1) -- strong induction hypothesis\n\ntheorem l5 : \n  \u2200 k \u2265 2, a (k+1) = 3 * a k - 2 * a (k-1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2200 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))) \u2192\n    (\u2200 n, n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1) := by\n  intro a h\n  have h\u2081 : a 1 = 1 := h.1\n  have h\u2082 : a 2 = 3 := h.2.1\n  have h\u2083 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2) := h.2.2\n  have h\u2084 : \u2200 n, n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n    intro n hn\n    induction' n using Nat.strong_induction_on with n ih\n    match n with\n    | 0 =>\n      exfalso\n      linarith\n    | 1 =>\n      norm_num [h\u2081]\n    | 2 =>\n      norm_num [h\u2082]\n    | k + 3 =>\n      have h\u2085 : a (k + 3) = 3 * a (k + 2) - 2 * a (k + 1) := by\n        have h\u2085\u2081 : (k + 3 : \u2115) \u2265 3 := by linarith\n        have h\u2085\u2082 : a (k + 3) = 3 * a (k + 3 - 1) - 2 * a (k + 3 - 2) := h\u2083 (k + 3) h\u2085\u2081\n        have h\u2085\u2083 : (k + 3 : \u2115) - 1 = k + 2 := by\n          norm_num\n          <;> omega\n        have h\u2085\u2084 : (k + 3 : \u2115) - 2 = k + 1 := by\n          norm_num\n          <;> omega\n        rw [h\u2085\u2082, h\u2085\u2083, h\u2085\u2084]\n        <;> ring_nf\n        <;> norm_num\n      have h\u2086 : a (k + 3) = (2 : \u211d)^(k + 3) - 1 := by\n        have h\u2086\u2081 : a (k + 2) = (2 : \u211d)^(k + 2) - 1 := by\n          have h\u2086\u2082 := ih (k + 2) (by omega)\n          have h\u2086\u2083 : (k + 2 : \u2115) \u2265 1 := by linarith\n          specialize h\u2086\u2082 (by linarith)\n          exact h\u2086\u2082\n        have h\u2086\u2084 : a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n          have h\u2086\u2085 := ih (k + 1) (by omega)\n          have h\u2086\u2086 : (k + 1 : \u2115) \u2265 1 := by linarith\n          specialize h\u2086\u2085 (by linarith)\n          exact h\u2086\u2085\n        rw [h\u2085, h\u2086\u2081, h\u2086\u2084]\n        have h\u2086\u2087 : ((2 : \u211d)^(k + 2) : \u211d) = 2 * (2 : \u211d)^(k + 1) := by\n          ring_nf\n          <;> field_simp [pow_add, pow_one, mul_assoc]\n          <;> ring_nf\n        have h\u2086\u2088 : ((2 : \u211d)^(k + 3) : \u211d) = 2 * (2 : \u211d)^(k + 2) := by\n          ring_nf\n          <;> field_simp [pow_add, pow_one, mul_assoc]\n          <;> ring_nf\n        norm_num at *\n        <;>\n        (try ring_nf at *) <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try norm_num at *) <;>\n        (try linarith) <;>\n        (try ring_nf at *) <;>\n        (try nlinarith)\n        <;>\n        (try\n          {\n            simp_all [pow_add, pow_one, mul_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> linarith\n          })\n        <;>\n        (try\n          {\n            nlinarith [pow_pos (by norm_num : (0 : \u211d) < 2) (k + 1),\n              pow_pos (by norm_num : (0 : \u211d) < 2) (k + 2)]\n          })\n        <;>\n        (try\n          {\n            nlinarith [pow_pos (by norm_num : (0 : \u211d) < 2) (k + 1),\n              pow_pos (by norm_num : (0 : \u211d) < 2) (k + 2)]\n          })\n        <;>\n        (try\n          {\n            nlinarith [pow_pos (by norm_num : (0 : \u211d) < 2) (k + 1),\n              pow_pos (by norm_num : (0 : \u211d) < 2) (k + 2)]\n          })\n      exact h\u2086\n  exact h\u2084\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n)\n(tc_2 : a 1 = 1 \u2227 a 2 = 3)\n(tc_3 : \u2200 n \u2265 3, a n = 3 * a (n-1) - 2 * a (n-2))\n(def_1 : \u2200 k \u2265 2, (\u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k+1) = 2^(k+1) - 1)\n\ntheorem l5 : \n  \u2200 k \u2265 2, a (k+1) = 3 * a k - 2 * a (k-1) := by\n  intro k hk\n  have h\u2081 : (k + 1 : \u2115) \u2265 3 := by\n    omega\n  have h\u2082 : a (k + 1) = 3 * a (k + 1 - 1) - 2 * a (k + 1 - 2) := by\n    have h\u2083 : (k + 1 : \u2115) \u2265 3 := h\u2081\n    have h\u2084 : a (k + 1) = 3 * a (k + 1 - 1) - 2 * a (k + 1 - 2) := by\n      apply tc_3\n      <;> omega\n    exact h\u2084\n  have h\u2083 : (k + 1 : \u2115) - 1 = k := by\n    omega\n  have h\u2084 : (k + 1 : \u2115) - 2 = (k - 1 : \u2115) := by\n    have h\u2084\u2081 : k \u2265 2 := hk\n    have h\u2084\u2082 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2084\u2081\n    have h\u2084\u2083 : (k + 1 : \u2115) - 2 = (k - 1 : \u2115) := by\n      have h\u2084\u2084 : (k : \u2115) \u2265 1 := by omega\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc] at h\u2084\u2082 \u22a2\n          <;> ring_nf at *\n          <;> omega\n    exact h\u2084\u2083\n  have h\u2085 : a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n    rw [h\u2082]\n    rw [h\u2083]\n    rw [h\u2084]\n    <;>\n    (try simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_mul, Nat.cast_sub]) <;>\n    (try ring_nf at *) <;>\n    (try norm_num at *) <;>\n    (try linarith)\n  exact h\u2085", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 107, "column": 12, "endLine": 107, "endColumn": 16, "data": "unknown identifier 'tc_3'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The recurrence relation is correctly captured in variable tc_3. While the theorem tc_1 contains additional information (initial conditions and closed form), the core recurrence relation from the natural language is properly formalized.", "The natural language def_1 simply defines k as an integer \u2265 2, but the Lean def_1 is completely different - it's a strong induction hypothesis about the closed form solution. This misses the key logical component of defining k.", "The conclusion l5 perfectly matches the natural language. Both state that for k \u2265 2, a_{k+1} follows the recurrence relation pattern.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The recurrence relation is correctly captured in variable tc_3. While the theorem tc_1 contains additional information (initial conditions and closed form), the core recurrence relation from the natural language is properly formalized.', \"The natural language def_1 simply defines k as an integer \u2265 2, but the Lean def_1 is completely different - it's a strong induction hypothesis about the closed form solution. This misses the key logical component of defining k.\", 'The conclusion l5 perfectly matches the natural language. Both state that for k \u2265 2, a_{k+1} follows the recurrence relation pattern.']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By our assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$.", "statement": "We assume:\n\u2022 $a_{k+1} = 3a_k - 2a_{k-1}$ [l5].\n\u2022 For all integers $j$ with $1 \\leq j \\leq k$ (for $k \\geq 2$), the formula $a_j = 2^j - 1$ holds [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$ [l6].", "dependencies": ["def_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) :\n  a (k + 1) = 3 * (2^k - 1) - 2 * (2^(k - 1) - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (2 : \u211d)^j - 1) :\n  a (k + 1) = 3 * ((2 : \u211d)^k - 1) - 2 * ((2 : \u211d)^(k - 1) - 1) := by\n  have h_recurrence : a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n    have h\u2081 : k + 1 \u2265 3 := by\n      omega\n    have h\u2082 : a (k + 1) = 3 * a (k + 1 - 1) - 2 * a (k + 1 - 2) := l5 (k + 1) h\u2081\n    have h\u2083 : a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n      have h\u2084 : (k + 1 : \u2115) - 1 = k := by\n        simp\n        <;> omega\n      have h\u2085 : (k + 1 : \u2115) - 2 = k - 1 := by\n        have h\u2085\u2081 : k \u2265 2 := hk\n        have h\u2085\u2082 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2085\u2081\n        omega\n      rw [h\u2082, h\u2084, h\u2085]\n      <;> simp [Nat.cast_sub, Nat.cast_add, Nat.cast_one]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_zero]\n      <;> linarith\n    exact h\u2083\n  \n  have h_ak : a k = (2 : \u211d)^k - 1 := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor\n      \u00b7 -- Prove 1 \u2264 k\n        have h\u2082 : k \u2265 2 := hk\n        omega\n      \u00b7 -- Prove k \u2264 k\n        linarith\n    have h\u2082 : a k = (2 : \u211d)^k - 1 := def_1 k h\u2081\n    exact h\u2082\n  \n  have h_ak1 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      constructor\n      \u00b7 -- Prove 1 \u2264 k - 1\n        have h\u2082 : k \u2265 2 := hk\n        have h\u2083 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2082\n        have h\u2084 : (k - 1 : \u2115) \u2265 1 := by\n          omega\n        exact by\n          omega\n      \u00b7 -- Prove k - 1 \u2264 k\n        have h\u2082 : k \u2265 2 := hk\n        have h\u2083 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2082\n        omega\n    have h\u2082 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := def_1 (k - 1) \u27e8by\n      -- Prove 1 \u2264 k - 1\n      have h\u2083 : k \u2265 2 := hk\n      have h\u2084 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2083\n      omega, by\n      -- Prove k - 1 \u2264 k\n      have h\u2083 : k \u2265 2 := hk\n      have h\u2084 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2083\n      omega\u27e9\n    exact h\u2082\n  \n  have h_final : a (k + 1) = 3 * ((2 : \u211d)^k - 1) - 2 * ((2 : \u211d)^(k - 1) - 1) := by\n    rw [h_recurrence]\n    rw [h_ak]\n    rw [h_ak1]\n    <;> ring_nf\n    <;> simp_all [pow_succ]\n    <;> field_simp at *\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The recurrence relation l5 is generalized to all n \u2265 3 rather than just the specific case of a_{k+1}, but this is a reasonable and mathematically sound generalization that doesn't contradict the original statement. All other components (def_1, the constraint hk, and the conclusion) are accurately translated. The logical structure of the argument is preserved with assumptions as hypotheses and the conclusion as the theorem goal."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Now we expand and simplify the expression: $a_{k+1} = 3 \\cdot 2^k - 3 - 2 \\cdot 2^{k-1} + 2 = 3 \\cdot 2^k - 2^k - 1 = 2 \\cdot 2^k - 1 = 2^{k+1} - 1$.", "statement": "We assume:\n\u2022 $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{k+1} - 1$ [l7].", "dependencies": ["l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) :\n  3 * (2^k - 1) - 2 * (2^(k - 1) - 1) = 2^(k + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) :\n  3 * (2^k - 1) - 2 * (2^(k - 1) - 1) = 2^(k + 1) - 1 := by\n  have h\u2081 : 3 * (2^k - 1) - 2 * (2^(k - 1) - 1) = 2^(k + 1) - 1 := by\n    have h\u2082 : k \u2265 1 := by linarith\n    have h\u2083 : 2 ^ (k - 1) * 2 = 2 ^ k := by\n      have h\u2084 : k - 1 + 1 = k := by\n        have h\u2085 : k \u2265 1 := by linarith\n        omega\n      calc\n        2 ^ (k - 1) * 2 = 2 ^ (k - 1) * 2 ^ 1 := by norm_num\n        _ = 2 ^ ((k - 1) + 1) := by rw [\u2190 pow_add]\n        _ = 2 ^ k := by rw [h\u2084]\n    have h\u2084 : 3 * (2 ^ k - 1) - 2 * (2 ^ (k - 1) - 1) = 2 ^ (k + 1) - 1 := by\n      have h\u2085 : 3 * (2 ^ k - 1) - 2 * (2 ^ (k - 1) - 1) = 3 * 2 ^ k - 3 - (2 * 2 ^ (k - 1) - 2) := by\n        cases k with\n        | zero => contradiction -- k cannot be zero since hk : k \u2265 2\n        | succ k' =>\n          cases k' with\n          | zero => contradiction -- k cannot be one since hk : k \u2265 2\n          | succ k'' =>\n            simp [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib, Nat.pow_succ, Nat.add_assoc]\n            <;> ring_nf at *\n            <;> omega\n      rw [h\u2085]\n      have h\u2086 : 2 * 2 ^ (k - 1) = 2 ^ k := by\n        have h\u2087 : 2 ^ (k - 1) * 2 = 2 ^ k := h\u2083\n        have h\u2088 : 2 * 2 ^ (k - 1) = 2 ^ (k - 1) * 2 := by ring\n        linarith\n      have h\u2087 : 3 * 2 ^ k - 3 - (2 * 2 ^ (k - 1) - 2) = 2 ^ (k + 1) - 1 := by\n        have h\u2088 : 3 * 2 ^ k - 3 \u2265 2 * 2 ^ (k - 1) - 2 := by\n          have h\u2089 : 2 * 2 ^ (k - 1) = 2 ^ k := h\u2086\n          have h\u2081\u2080 : 3 * 2 ^ k - 3 \u2265 2 ^ k - 2 := by\n            have h\u2081\u2081 : 3 * 2 ^ k \u2265 2 ^ k + 2 := by\n              have h\u2081\u2082 : 2 ^ k \u2265 4 := by\n                have h\u2081\u2083 : k \u2265 2 := hk\n                have h\u2081\u2084 : 2 ^ k \u2265 2 ^ 2 := pow_le_pow_right (by norm_num) h\u2081\u2083\n                linarith\n              omega\n            omega\n          omega\n        have h\u2089 : 2 * 2 ^ (k - 1) = 2 ^ k := h\u2086\n        have h\u2081\u2080 : 3 * 2 ^ k - 3 - (2 * 2 ^ (k - 1) - 2) = 3 * 2 ^ k - 3 - (2 ^ k - 2) := by\n          rw [h\u2089]\n          <;> simp [Nat.sub_sub]\n          <;> ring_nf at *\n          <;> omega\n        rw [h\u2081\u2080]\n        have h\u2081\u2081 : 3 * 2 ^ k - 3 - (2 ^ k - 2) = 2 ^ (k + 1) - 1 := by\n          have h\u2081\u2082 : 2 ^ (k + 1) = 2 * 2 ^ k := by\n            ring_nf\n            <;> simp [pow_succ]\n            <;> ring_nf\n          have h\u2081\u2083 : 3 * 2 ^ k - 3 \u2265 2 ^ k - 2 := by\n            have h\u2081\u2084 : 3 * 2 ^ k \u2265 2 ^ k + 2 := by\n              have h\u2081\u2085 : 2 ^ k \u2265 4 := by\n                have h\u2081\u2086 : k \u2265 2 := hk\n                have h\u2081\u2087 : 2 ^ k \u2265 2 ^ 2 := pow_le_pow_right (by norm_num) h\u2081\u2086\n                linarith\n              omega\n            omega\n          have h\u2081\u2084 : 3 * 2 ^ k - 3 - (2 ^ k - 2) = 2 * 2 ^ k - 1 := by\n            have h\u2081\u2085 : 2 ^ k \u2265 4 := by\n              have h\u2081\u2086 : k \u2265 2 := hk\n              have h\u2081\u2087 : 2 ^ k \u2265 2 ^ 2 := pow_le_pow_right (by norm_num) h\u2081\u2086\n              linarith\n            have h\u2081\u2086 : 3 * 2 ^ k - 3 \u2265 2 ^ k - 2 := by omega\n            have h\u2081\u2087 : 3 * 2 ^ k - 3 - (2 ^ k - 2) = 2 * 2 ^ k - 1 := by\n              have h\u2081\u2088 : 3 * 2 ^ k - 3 - (2 ^ k - 2) = (3 * 2 ^ k - 3) - (2 ^ k - 2) := rfl\n              rw [h\u2081\u2088]\n              have h\u2081\u2089 : (3 * 2 ^ k - 3) - (2 ^ k - 2) = 2 * 2 ^ k - 1 := by\n                have h\u2082\u2080 : 3 * 2 ^ k - 3 \u2265 2 ^ k - 2 := by omega\n                have h\u2082\u2081 : (3 * 2 ^ k - 3) - (2 ^ k - 2) = 2 * 2 ^ k - 1 := by\n                  cases k with\n                  | zero => contradiction -- k cannot be zero since hk : k \u2265 2\n                  | succ k' =>\n                    cases k' with\n                    | zero => contradiction -- k cannot be one since hk : k \u2265 2\n                    | succ k'' =>\n                      simp [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib, Nat.pow_succ, Nat.add_assoc] at *\n                      <;> ring_nf at *\n                      <;> omega\n                exact h\u2082\u2081\n              rw [h\u2081\u2089]\n            exact h\u2081\u2087\n          have h\u2081\u2085 : 2 * 2 ^ k - 1 = 2 ^ (k + 1) - 1 := by\n            have h\u2081\u2086 : 2 ^ (k + 1) = 2 * 2 ^ k := by\n              ring_nf\n              <;> simp [pow_succ]\n              <;> ring_nf\n            omega\n          omega\n        rw [h\u2081\u2081]\n      rw [h\u2087]\n    exact h\u2084\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the core mathematical statement that 3(2^k-1) - 2(2^(k-1)-1) = 2^(k+1) - 1. The additional hypotheses about the sequence a, the constraint k \u2265 2, the recurrence relation, and the formula for sequence terms provide helpful mathematical context that is consistent with the natural language setting, even though not explicitly stated. The essential logical content - proving the equality between the assumed and concluded expressions for a_{k+1} - is perfectly preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "This result matches the formula for $n=k+1$.", "statement": "We assume:\n\u2022 The recurrence relation for $a_{k+1}$ simplifies to $a_{k+1} = 2^{k+1} - 1$ [l7].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=k+1$ [l8].", "dependencies": ["l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) :\n  a (k + 1) = 2^(k + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : \u2200 n, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (2 : \u211d)^j - 1) :\n  a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : k + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h_a_k_plus_1 : a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n    have h\u2081 : a (k + 1) = 3 * a (k + 1 - 1) - 2 * a (k + 1 - 2) := by\n      have h\u2082 : (k + 1 : \u2115) \u2265 3 := by exact_mod_cast h_k_plus_1_ge_3\n      have h\u2083 : a (k + 1) = 3 * a (k + 1 - 1) - 2 * a (k + 1 - 2) := l5 (k + 1) h\u2082\n      exact h\u2083\n    have h\u2082 : (k + 1 : \u2115) - 1 = k := by\n      simp [Nat.add_sub_cancel]\n    have h\u2083 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2084 : k \u2265 2 := hk\n      have h\u2085 : (k + 1 : \u2115) - 2 = k - 1 := by\n        have h\u2086 : k + 1 \u2265 3 := by omega\n        have h\u2087 : (k + 1 : \u2115) - 2 = k - 1 := by\n          omega\n        exact h\u2087\n      exact h\u2085\n    rw [h\u2081]\n    rw [h\u2082]\n    rw [h\u2083]\n    <;> ring_nf\n    <;> norm_num\n  \n  have h_a_k : a k = (2 : \u211d)^k - 1 := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2082 : a k = (2 : \u211d)^k - 1 := def_1 k h\u2081\n    exact h\u2082\n  \n  have h_a_k_minus_1 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2084 : k \u2265 2 := hk\n        have h\u2085 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2084\n        have h\u2086 : (k - 1 : \u2115) \u2265 1 := by\n          omega\n        exact h\u2086\n      have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n        have h\u2085 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n        omega\n      exact \u27e8h\u2083, h\u2084\u27e9\n    have h\u2082 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := def_1 (k - 1) \u27e8by\n      -- Prove that 1 \u2264 (k - 1 : \u2115)\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) := h\u2081.1\n      exact_mod_cast h\u2083, by\n      -- Prove that (k - 1 : \u2115) \u2264 k\n      have h\u2083 : (k - 1 : \u2115) \u2264 k := h\u2081.2\n      exact_mod_cast h\u2083\u27e9\n    exact h\u2082\n  \n  have h_main : a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n    rw [h_a_k_plus_1]\n    rw [h_a_k]\n    rw [h_a_k_minus_1]\n    have h\u2081 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n    have h\u2082 : (3 : \u211d) * ((2 : \u211d) ^ k - 1) - 2 * ((2 : \u211d) ^ (k - 1) - 1) = (2 : \u211d) ^ (k + 1) - 1 := by\n      have h\u2083 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n      have h\u2084 : (2 : \u211d) ^ (k : \u2115) = (2 : \u211d) ^ (k : \u2115) := rfl\n      have h\u2085 : (2 : \u211d) ^ (k - 1 : \u2115) = (2 : \u211d) ^ (k - 1 : \u2115) := rfl\n      have h\u2086 : (k : \u2115) \u2265 1 := by linarith\n      have h\u2087 : (k - 1 : \u2115) + 1 = k := by\n        have h\u2088 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n        have h\u2089 : (k - 1 : \u2115) + 1 = k := by\n          omega\n        exact h\u2089\n      have h\u2088 : (2 : \u211d) ^ (k : \u2115) = (2 : \u211d) ^ ((k - 1 : \u2115) + 1) := by\n        rw [h\u2087]\n        <;> simp [pow_add, pow_one]\n        <;> ring_nf\n        <;> norm_num\n        <;> field_simp\n        <;> ring_nf\n      have h\u2089 : (2 : \u211d) ^ ((k - 1 : \u2115) + 1) = (2 : \u211d) ^ (k - 1 : \u2115) * 2 := by\n        rw [pow_succ]\n        <;> ring_nf\n        <;> simp [pow_add, pow_one]\n        <;> field_simp\n        <;> ring_nf\n      have h\u2081\u2080 : (2 : \u211d) ^ (k : \u2115) = (2 : \u211d) ^ (k - 1 : \u2115) * 2 := by\n        rw [h\u2088]\n        rw [h\u2089]\n      have h\u2081\u2081 : (3 : \u211d) * ((2 : \u211d) ^ k - 1) - 2 * ((2 : \u211d) ^ (k - 1) - 1) = (2 : \u211d) ^ (k + 1) - 1 := by\n        calc\n          (3 : \u211d) * ((2 : \u211d) ^ k - 1) - 2 * ((2 : \u211d) ^ (k - 1) - 1) = (3 : \u211d) * (2 : \u211d) ^ k - 3 - 2 * (2 : \u211d) ^ (k - 1) + 2 := by\n            ring_nf\n          _ = (3 : \u211d) * (2 : \u211d) ^ k - 2 * (2 : \u211d) ^ (k - 1) - 1 := by ring_nf\n          _ = (3 : \u211d) * (2 : \u211d) ^ k - (2 : \u211d) ^ (k - 1) * 2 - 1 := by ring_nf\n          _ = (3 : \u211d) * (2 : \u211d) ^ k - (2 : \u211d) ^ k - 1 := by\n            have h\u2081\u2082 : (2 : \u211d) ^ (k - 1 : \u2115) * 2 = (2 : \u211d) ^ k := by\n              calc\n                (2 : \u211d) ^ (k - 1 : \u2115) * 2 = (2 : \u211d) ^ (k - 1 : \u2115) * (2 : \u211d) ^ 1 := by norm_num\n                _ = (2 : \u211d) ^ ((k - 1 : \u2115) + 1) := by\n                  rw [\u2190 pow_add]\n                _ = (2 : \u211d) ^ k := by\n                  have h\u2081\u2083 : (k - 1 : \u2115) + 1 = k := by\n                    have h\u2081\u2084 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n                    omega\n                  rw [h\u2081\u2083]\n            rw [h\u2081\u2082]\n            <;> ring_nf\n          _ = (2 : \u211d) ^ (k + 1) - 1 := by\n            have h\u2081\u2082 : (3 : \u211d) * (2 : \u211d) ^ k - (2 : \u211d) ^ k = (2 : \u211d) ^ (k + 1) := by\n              have h\u2081\u2083 : (3 : \u211d) * (2 : \u211d) ^ k - (2 : \u211d) ^ k = (2 : \u211d) ^ k * 2 := by\n                ring_nf\n                <;>\n                (try norm_num) <;>\n                (try linarith)\n              have h\u2081\u2084 : (2 : \u211d) ^ k * 2 = (2 : \u211d) ^ (k + 1) := by\n                have h\u2081\u2085 : (2 : \u211d) ^ (k + 1) = (2 : \u211d) ^ k * 2 := by\n                  calc\n                    (2 : \u211d) ^ (k + 1) = (2 : \u211d) ^ k * (2 : \u211d) ^ 1 := by\n                      rw [pow_add]\n                    _ = (2 : \u211d) ^ k * 2 := by norm_num\n                linarith\n              linarith\n            linarith\n      exact h\u2081\u2081\n    rw [h\u2082]\n    <;>\n    (try ring_nf) <;>\n    (try norm_num) <;>\n    (try linarith)\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the essential goal (proving a(k+1) = 2^(k+1) - 1) but differs in how it treats the premise. The natural language presents the recurrence relation for a_{k+1} as a given assumption that directly leads to the conclusion, while the Lean formalization provides a more complete mathematical context with a general recurrence relation, inductive hypothesis, and constraints that would be needed to actually prove this statement. The logical meaning is similar, but the structural approach differs - the natural language suggests a direct application of an assumption, while Lean sets up a proper inductive proof framework."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization captures the essential goal (proving a(k+1) = 2^(k+1) - 1) but differs in how it treats the premise. The natural language presents the recurrence relation for a_{k+1} as a given assumption that directly leads to the conclusion, while the Lean formalization provides a more complete mathematical context with a general recurrence relation, inductive hypothesis, and constraints that would be needed to actually prove this statement. The logical meaning is similar, but the structural approach differs - the natural language suggests a direct application of an assumption, while Lean sets up a proper inductive proof framework.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^n - 1$ is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The formula $a_n = 2^n - 1$ holds for n=1 [l2].\n\u2022 The formula $a_n = 2^n - 1$ holds for n=2 [l4].\n\u2022 It has been shown that for any integer k \u2265 2, if the formula holds for all integers j from 1 to k, then it also holds for k+1 [l8].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the formula is $a_n = 2^n - 1$ [ts_1].", "dependencies": ["l2", "l4", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (l2 : a 1 = 2^1 - 1)\n  (l4 : a 2 = 2^2 - 1)\n  (l8 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^n - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (l2 : a 1 = 2^1 - 1)\n  (l4 : a 2 = 2^2 - 1)\n  (l8 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^n - 1 := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n      intro n hn\n      have h\u2081 : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n        intro n hn\n        -- Use strong induction on n\n        have h\u2082 : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n          intro n hn\n          induction' n using Nat.strong_induction_on with n ih\n          match n with\n          | 0 =>\n            -- This case is impossible because n \u2265 1\n            exfalso\n            linarith\n          | 1 =>\n            -- Base case: n = 1\n            norm_num [l2] at *\n            <;>\n            simp_all [pow_one]\n            <;>\n            norm_num\n          | 2 =>\n            -- Base case: n = 2\n            norm_num [l4] at *\n            <;>\n            simp_all [pow_two]\n            <;>\n            norm_num\n          | k + 3 =>\n            -- Inductive step: n \u2265 3\n            have h\u2083 : k + 3 \u2265 3 := by\n              omega\n            have h\u2084 : (k + 3) - 1 \u2265 2 := by\n              omega\n            have h\u2085 : \u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 (k + 3) - 1 \u2192 a j = (2 : \u211d)^j - 1 := by\n              intro j hj\n              have h\u2086 : j < k + 3 := by\n                have h\u2087 : j \u2264 (k + 3) - 1 := hj.2\n                have h\u2088 : (k + 3) - 1 < k + 3 := by\n                  omega\n                omega\n              have h\u2089 : j \u2265 1 := hj.1\n              have h\u2081\u2080 : a j = (2 : \u211d)^j - 1 := by\n                have h\u2081\u2081 : j \u2265 1 := hj.1\n                have h\u2081\u2082 : j < k + 3 := h\u2086\n                have h\u2081\u2083 : a j = (2 : \u211d)^j - 1 := by\n                  apply ih j\n                  <;>\n                  (try omega) <;>\n                  (try linarith) <;>\n                  (try\n                    {\n                      omega\n                    })\n                  <;>\n                  (try\n                    {\n                      linarith\n                    })\n                exact h\u2081\u2083\n              exact h\u2081\u2080\n            have h\u2086 : a ((k + 3) - 1 + 1) = (2 : \u211d)^((k + 3) - 1 + 1) - 1 := by\n              have h\u2087 : (k + 3) - 1 \u2265 2 := by\n                omega\n              have h\u2088 : \u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 (k + 3) - 1 \u2192 a j = (2 : \u211d)^j - 1 := h\u2085\n              have h\u2089 : a ((k + 3) - 1 + 1) = (2 : \u211d)^((k + 3) - 1 + 1) - 1 := by\n                have h\u2081\u2080 : a ((k + 3) - 1 + 1) = (2 : \u211d)^((k + 3) - 1 + 1) - 1 := by\n                  have h\u2081\u2081 : (k + 3) - 1 \u2265 2 := by\n                    omega\n                  have h\u2081\u2082 : (\u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 (k + 3) - 1 \u2192 a j = (2 : \u211d)^j - 1) := h\u2085\n                  have h\u2081\u2083 : a ((k + 3) - 1 + 1) = (2 : \u211d)^((k + 3) - 1 + 1) - 1 := by\n                    have h\u2081\u2084 := l8 ((k + 3) - 1) (by omega) h\u2081\u2082\n                    norm_num at h\u2081\u2084 \u22a2\n                    <;>\n                    (try ring_nf at h\u2081\u2084 \u22a2) <;>\n                    (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n                    (try norm_num at h\u2081\u2084 \u22a2) <;>\n                    (try linarith) <;>\n                    (try ring_nf at h\u2081\u2084 \u22a2 <;> simp_all [pow_add, pow_one, mul_assoc] <;> norm_num at h\u2081\u2084 \u22a2 <;> linarith)\n                    <;>\n                    (try\n                      {\n                        simp_all [pow_add, pow_one, mul_assoc]\n                        <;>\n                        norm_num at *\n                        <;>\n                        linarith\n                      })\n                  exact h\u2081\u2083\n                exact h\u2081\u2080\n              exact h\u2089\n            have h\u2087 : (k + 3) - 1 + 1 = k + 3 := by\n              omega\n            have h\u2088 : a (k + 3) = (2 : \u211d)^(k + 3) - 1 := by\n              rw [h\u2087] at h\u2086\n              simpa using h\u2086\n            simpa using h\u2088\n        exact h\u2082 n hn\n      exact h\u2081 n hn\n    exact h n hn\n  intro n hn\n  have h\u2081 : a n = (2 : \u211d)^n - 1 := h_main n hn\n  norm_num at h\u2081 \u22a2\n  <;>\n  (try ring_nf at h\u2081 \u22a2) <;>\n  (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n  (try norm_num at h\u2081 \u22a2) <;>\n  (try linarith) <;>\n  (try ring_nf at h\u2081 \u22a2 <;> simp_all [pow_add, pow_one, mul_assoc] <;> norm_num at h\u2081 \u22a2 <;> linarith)\n  <;>\n  (try\n    {\n      simp_all [pow_add, pow_one, mul_assoc]\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Base cases l2 and l4 correctly formalize the given conditions for n=1 and n=2", "The inductive step l8 accurately captures the logical structure: for k\u22652, if the formula holds for all j from 1 to k, then it holds for k+1", "The conclusion correctly states the general formula for all n\u22651", "The overall theorem structure properly represents a mathematical induction argument with the base cases and inductive step as hypotheses leading to the general conclusion", "Using natural numbers \u2115 instead of integers \u2124 is appropriate since the domain is restricted to positive integers (n\u22651), and this doesn't affect the mathematical meaning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    