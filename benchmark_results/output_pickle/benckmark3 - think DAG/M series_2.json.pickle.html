
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = n+1$ and $(b_n)$ be a sequence such that $b_n = 2n^2$. Let the sequence $(c_n)$ be defined as $c_n = a_n+b_n$. Then the sum of the first two terms of $(c_n)$, $\sum_{n=1}^{2} c_n$, is $15$.

Proof: First, we find the expression for the sequence $(c_n)$ by adding the expressions for $a_n$ and $b_n$, which gives $c_n = (n+1) + 2n^2$. Next, we find the values for the first two terms: $c_1 = (1+1) + 2(1)^2 = 4$ and $c_2 = (2+1) + 2(2)^2 = 11$. Finally, we sum these two terms to get $\sum_{n=1}^{2} c_n = c_1+c_2=4+11=15$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = n+1$", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers such that $a_n = n+1$ for all $n \\in \\mathbb{N}$ where $n \\ge 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = n + 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `a : \u2115 \u2192 \u211d` correctly captures the concept of a sequence of real numbers indexed by natural numbers", "The domain constraint `n \u2208 \u2115` where `n \u2265 1` is properly incorporated into the Lean formalization through the implication structure", "The defining equation `a_n = n+1` is exactly represented as `a n = n + 1` in the Lean formalization with the same domain constraint"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "and $(b_n)$ be a sequence such that $b_n = 2n^2$.", "statement": "Premise:\n\u2022 $(b_n)$ is a sequence of real numbers such that $b_n = 2n^2$ for all $n \\in \\mathbb{N}$ where $n \\ge 1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (b : \u2115 \u2192 \u211d)\n(tc_2 : \u2200 n : \u2115, 1 \u2264 n \u2192 b n = 2 * n^2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `b : \u2115 \u2192 \u211d` correctly captures the sequence of real numbers indexed by natural numbers", "The domain constraint $n \\in \\mathbb{N}$ where $n \\ge 1$ is properly captured in the Lean implication `1 \u2264 n \u2192`", "The formula $b_n = 2n^2$ is exactly represented as `b n = 2 * n^2` in Lean, with the universal quantification and domain constraint properly formalized"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Let the sequence $(c_n)$ be defined as $c_n = a_n+b_n$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence such that $a_n = n+1$ [tc_1]\n\u2022 $(b_n)$ is a sequence such that $b_n = 2n^2$ [tc_2]\n\u2022 $(c_n)$ is a sequence of real numbers defined as $c_n = a_n+b_n$ for all $n \\in \\mathbb{N}$ where $n \\ge 1$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_3 : \n  let a : \u2115 \u2192 \u211d := fun n => n + 1\n  let b : \u2115 \u2192 \u211d := fun n => 2 * n^2\n  let c : \u2115 \u2192 \u211d := fun n => a n + b n\n  c 1 + c 2 = 15 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean definition `let a : \u2115 \u2192 \u211d := fun n => n + 1` correctly captures the sequence $a_n = n+1$", "The Lean definition `let b : \u2115 \u2192 \u211d := fun n => 2 * n^2` correctly captures the sequence $b_n = 2n^2$", "The Lean definition `let c : \u2115 \u2192 \u211d := fun n => a n + b n` correctly captures the definition $c_n = a_n + b_n$", "The natural language conclusion states a general formula $c_n = 2n^2 + n + 1$ for all $n \\ge 1$, but the Lean formalization only proves a specific numerical fact `c 1 + c 2 = 15`. This is a completely different mathematical statement - one is a general algebraic identity, the other is a specific arithmetic calculation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean definition `let a : \u2115 \u2192 \u211d := fun n => n + 1` correctly captures the sequence $a_n = n+1$', 'The Lean definition `let b : \u2115 \u2192 \u211d := fun n => 2 * n^2` correctly captures the sequence $b_n = 2n^2$', 'The Lean definition `let c : \u2115 \u2192 \u211d := fun n => a n + b n` correctly captures the definition $c_n = a_n + b_n$', 'The natural language conclusion states a general formula $c_n = 2n^2 + n + 1$ for all $n \\\\ge 1$, but the Lean formalization only proves a specific numerical fact `c 1 + c 2 = 15`. This is a completely different mathematical statement - one is a general algebraic identity, the other is a specific arithmetic calculation.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, we find the expression for the sequence $(c_n)$ by adding the expressions for $a_n$ and $b_n$, which gives $c_n = (n+1) + 2n^2$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence such that $a_n = n+1$ [tc_1]\n\u2022 $(b_n)$ is a sequence such that $b_n = 2n^2$ [tc_2]\n\u2022 $(c_n)$ is a sequence defined as $c_n = a_n+b_n$ [tc_3]\nTherefore, we conclude:\n\u2022 The sequence $(c_n)$ has the explicit formula $c_n = (n+1) + 2n^2$ for all $n \\in \\mathbb{N}$ where $n \\ge 1$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a b c : \u2115 \u2192 \u211d)\n  (ha : \u2200 n : \u2115, n \u2265 1 \u2192 a n = n + 1)\n  (hb : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2 * n^2)\n  (hc : \u2200 n : \u2115, n \u2265 1 \u2192 c n = a n + b n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 c n = (n + 1) + 2 * n^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a b c : \u2115 \u2192 \u211d)\n  (ha : \u2200 n : \u2115, n \u2265 1 \u2192 a n = n + 1)\n  (hb : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2 * n^2)\n  (hc : \u2200 n : \u2115, n \u2265 1 \u2192 c n = a n + b n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 c n = (n + 1) + 2 * n^2 := by\n  intro n hn\n  have h\u2081 : c n = a n + b n := by\n    have h\u2081\u2081 : c n = a n + b n := hc n hn\n    exact h\u2081\u2081\n  \n  have h\u2082 : a n = (n : \u211d) + 1 := by\n    have h\u2082\u2081 : a n = (n : \u211d) + 1 := by\n      have h\u2082\u2082 : a n = (n : \u211d) + 1 := by\n        have h\u2082\u2083 : a n = n + 1 := ha n hn\n        norm_cast at h\u2082\u2083 \u22a2\n        <;> simp_all [ha]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      exact h\u2082\u2082\n    exact h\u2082\u2081\n  \n  have h\u2083 : b n = 2 * (n : \u211d)^2 := by\n    have h\u2083\u2081 : b n = 2 * (n : \u211d)^2 := by\n      have h\u2083\u2082 : b n = 2 * (n : \u211d)^2 := by\n        have h\u2083\u2083 : b n = 2 * n ^ 2 := hb n hn\n        norm_cast at h\u2083\u2083 \u22a2\n        <;> simp_all [hb]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      exact h\u2083\u2082\n    exact h\u2083\u2081\n  \n  have h\u2084 : c n = (n + 1 : \u211d) + 2 * (n : \u211d)^2 := by\n    have h\u2084\u2081 : c n = a n + b n := h\u2081\n    rw [h\u2084\u2081]\n    have h\u2084\u2082 : a n = (n : \u211d) + 1 := h\u2082\n    have h\u2084\u2083 : b n = 2 * (n : \u211d)^2 := h\u2083\n    rw [h\u2084\u2082, h\u2084\u2083]\n    <;> ring_nf\n    <;> simp [add_assoc]\n    <;> norm_cast\n    <;> field_simp\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h\u2085 : c n = (n + 1 : \u211d) + 2 * (n : \u211d)^2 := h\u2084\n  have h\u2086 : c n = (n + 1 : \u211d) + 2 * (n : \u211d)^2 := by simpa using h\u2085\n  -- Convert the final result back to the required form\n  have h\u2087 : c n = (n + 1 : \u211d) + 2 * (n : \u211d)^2 := by simpa using h\u2086\n  -- Since Lean automatically casts n to \u211d in the goal, we can directly use h\u2087\n  norm_cast at h\u2087 \u22a2\n  <;> simp_all [ha, hb, hc]\n  <;> ring_nf at *\n  <;> norm_num at *\n  <;> linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definitions and assumptions are correctly captured in the Lean hypotheses with identical mathematical relationships and domain restrictions.", "The conclusion statement perfectly matches the natural language, expressing the same explicit formula for the sequence c_n.", "The logical structure and mathematical reasoning flow are preserved exactly from natural language to Lean formalization.", "The type specifications (\u2115 \u2192 \u211d) and domain constraints (n \u2265 1) appropriately formalize the natural language specifications.", "Minor notational differences like '2 * n^2' vs '2n^2' and function vs subscript notation are standard formal mathematics conventions that preserve semantic meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Next, we find the values for the first two terms: $c_1 = (1+1) + 2(1)^2 = 4$", "statement": "We assume:\n\u2022 The sequence $(c_n)$ has the explicit formula $c_n = (n+1) + 2n^2$ [l1]\nTherefore, we conclude:\n\u2022 The first term of the sequence is $c_1 = 4$ [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (c : \u2115 \u2192 \u211d)\n  (h : \u2200 n : \u2115, n \u2265 1 \u2192 c n = (n + 1) + 2 * n^2) :\n  c 1 = 4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (c : \u2115 \u2192 \u211d)\n  (h : \u2200 n : \u2115, n \u2265 1 \u2192 c n = (n + 1) + 2 * n^2) :\n  c 1 = 4 := by\n  have h1 : c 1 = (1 + 1 : \u211d) + 2 * (1 : \u211d)^2 := by\n    have h2 : c 1 = (1 + 1 : \u211d) + 2 * (1 : \u211d)^2 := by\n      have h3 : (1 : \u2115) \u2265 1 := by norm_num\n      have h4 : c 1 = (1 + 1 : \u211d) + 2 * (1 : \u211d)^2 := by\n        have h5 : c 1 = (1 + 1 : \u211d) + 2 * (1 : \u211d)^2 := by\n          -- Use the given formula to compute c 1\n          have h6 := h 1 (by norm_num)\n          norm_num at h6 \u22a2\n          <;>\n          (try norm_num) <;>\n          (try ring_nf at h6 \u22a2) <;>\n          (try simp_all [pow_two]) <;>\n          (try norm_cast at h6 \u22a2) <;>\n          (try linarith) <;>\n          (try nlinarith)\n          <;>\n          (try simp_all [pow_two])\n          <;>\n          (try norm_num at h6 \u22a2)\n          <;>\n          (try linarith)\n          <;>\n          (try nlinarith)\n        exact h5\n      exact h4\n    exact h2\n  \n  have h2 : c 1 = 4 := by\n    have h3 : c 1 = (1 + 1 : \u211d) + 2 * (1 : \u211d)^2 := h1\n    rw [h3]\n    norm_num\n    <;>\n    (try ring_nf) <;>\n    (try norm_num) <;>\n    (try linarith)\n    <;>\n    (try nlinarith)\n  \n  apply h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence formula is correctly formalized with appropriate domain restriction n \u2265 1", "The conclusion c 1 = 4 is accurately represented", "The overall theorem structure properly captures the logical relationship between the assumption and conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "and $c_2 = (2+1) + 2(2)^2 = 11$.", "statement": "We assume:\n\u2022 The sequence $(c_n)$ has the explicit formula $c_n = (n+1) + 2n^2$ [l1]\nTherefore, we conclude:\n\u2022 The second term of the sequence is $c_2 = 11$ [l3].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (c : \u2115 \u2192 \u211d)\n  (hc : \u2200 n : \u2115, n \u2265 1 \u2192 c n = (n + 1) + 2 * n^2) :\n  c 2 = 11 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (c : \u2115 \u2192 \u211d)\n  (hc : \u2200 n : \u2115, n \u2265 1 \u2192 c n = (n + 1) + 2 * n^2) :\n  c 2 = 11 := by\n  have h\u2082 : c 2 = (2 + 1 : \u211d) + 2 * (2 : \u211d)^2 := by\n    have h\u2082\u2081 : (2 : \u2115) \u2265 1 := by norm_num\n    have h\u2082\u2082 : c 2 = (2 + 1 : \u211d) + 2 * (2 : \u211d)^2 := by\n      have h\u2082\u2083 : c 2 = (2 + 1 : \u211d) + 2 * (2 : \u211d)^2 := by\n        -- Use the given formula for c(n) with n = 2\n        have h\u2082\u2084 : c 2 = (2 + 1 : \u211d) + 2 * (2 : \u211d)^2 := by\n          -- Apply the hypothesis hc to n = 2\n          have h\u2082\u2085 : c 2 = (2 + 1 : \u211d) + 2 * (2 : \u211d)^2 := by\n            -- Convert the natural number 2 to real number and apply hc\n            norm_cast at hc \u22a2\n            have h\u2082\u2086 := hc 2 (by norm_num)\n            norm_num at h\u2082\u2086 \u22a2\n            <;> simp_all [pow_two]\n            <;> ring_nf at *\n            <;> linarith\n          exact h\u2082\u2085\n        exact h\u2082\u2084\n      exact h\u2082\u2083\n    exact h\u2082\u2082\n  \n  have h\u2083 : c 2 = 11 := by\n    rw [h\u2082]\n    <;> norm_num\n    <;> simp [pow_two]\n    <;> ring_nf\n    <;> norm_num\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence formula is correctly formalized. The added constraint 'n \u2265 1' is a reasonable mathematical assumption for sequence indexing that doesn't contradict the natural language.", "The conclusion 'c 2 = 11' perfectly matches the natural language statement about the second term.", "The logical structure correctly captures the premise-conclusion relationship as a theorem with appropriate hypothesis and goal."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Finally, we sum these two terms to get $\\sum_{n=1}^{2} c_n = c_1+c_2=4+11=15$.", "statement": "We assume:\n\u2022 The first term of the sequence $(c_n)$ is $c_1 = 4$ [l2]\n\u2022 The second term of the sequence $(c_n)$ is $c_2 = 11$ [l3]\nTherefore, we conclude:\n\u2022 The sum of the first two terms of $(c_n)$ is $\\sum_{n=1}^{2} c_n = 15$ [ts_1].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (c : \u2115 \u2192 \u211d)\n  (l2 : c 1 = 4)\n  (l3 : c 2 = 11) :\n  c 1 + c 2 = 15 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (c : \u2115 \u2192 \u211d)\n  (l2 : c 1 = 4)\n  (l3 : c 2 = 11) :\n  c 1 + c 2 = 15 := by\n  have h_sum : c 1 + c 2 = 15 := by\n    calc\n      c 1 + c 2 = 4 + 11 := by rw [l2, l3]\n      _ = 15 := by norm_num\n  exact h_sum", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The sequence definition, initial conditions, and conclusion are all properly represented. The use of 'c 1 + c 2 = 15' instead of summation notation is mathematically equivalent to the natural language's sum notation, and the theorem structure appropriately reflects the logical flow from assumptions to conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    