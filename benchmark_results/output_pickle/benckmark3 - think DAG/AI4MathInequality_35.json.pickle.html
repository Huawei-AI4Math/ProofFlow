
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $a, b, c, d$ such that $abcd = 1$, the following inequality holds:
$$ (1 + a^2)(1 + b^2)(1 + c^2)(1 + d^2) \\geq (a + b + c + d)^2 $$

Proof: Let $a, b, c, d$ be positive real numbers such that $abcd=1$. To prove $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \ge (a+b+c+d)^2$, we first apply the Cauchy-Schwarz inequality by setting $X=(1, a, b, ab)$ and $Y=(c, 1, d, cd)$, which gives $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \ge (a+c+bd+abcd)^2$. Since $abcd=1$, this reduces to $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \ge (a+c+bd+1)^2$. The remaining step is to show $a+c+bd+1 \ge a+b+c+d$, which is equivalent to $bd+1 \ge b+d$. This holds because $(b-1)(d-1) \ge 0$ for some choice of two variables $b$ and $d$, which is always possible given that $abcd=1$. Combining these, we obtain $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \ge (a+b+c+d)^2$, completing the proof.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $a, b, c, d$ be positive real numbers", "statement": "Premise:\n\u2022 $a, b, c, d$ are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c, d are positive real numbers through the type declarations (a b c d : \u211d) and the positivity constraints (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d)", "The natural language explicitly states there are no conclusions derived in this premise step, but the Lean formalization includes a substantial inequality conclusion: (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2", "The Lean formalization introduces an additional constraint (h_constraint : a * b * c * d = 1) that is completely absent from the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c, d are positive real numbers through the type declarations (a b c d : \u211d) and the positivity constraints (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d)', 'The natural language explicitly states there are no conclusions derived in this premise step, but the Lean formalization includes a substantial inequality conclusion: (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2', 'The Lean formalization introduces an additional constraint (h_constraint : a * b * c * d = 1) that is completely absent from the natural language statement']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "such that $abcd=1$", "statement": "Premise:\n\u2022 $a, b, c, d$ are positive real numbers [tc_1]\n\u2022 $abcd = 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c, d are positive real numbers through the type declaration and positivity constraints", "The constraint abcd = 1 is perfectly represented as a * b * c * d = 1 in Lean", "The natural language explicitly states there are no new derived facts in this premise step, but the Lean formalization introduces a significant inequality conclusion that was not mentioned in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c, d are positive real numbers through the type declaration and positivity constraints', 'The constraint abcd = 1 is perfectly represented as a * b * c * d = 1 in Lean', 'The natural language explicitly states there are no new derived facts in this premise step, but the Lean formalization introduces a significant inequality conclusion that was not mentioned in the natural language statement']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "...we first apply the Cauchy-Schwarz inequality by setting $X=(1, a, b, ab)$ and $Y=(c, 1, d, cd)$, which gives $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+c+bd+abcd)^2$.", "statement": "We assume:\n\u2022 $a, b, c, d$ are positive real numbers [tc_1].\nTherefore, we conclude:\n\u2022 By applying the Cauchy-Schwarz inequality to the vectors $X=(1, a, b, ab)$ and $Y=(c, 1, d, cd)$, we get $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+c+bd+abcd)^2$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + a * b * c * d)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + a * b * c * d)^2 := by\n  have h_product_expansion : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) = (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) := by\n    have h1 : (1 + a^2) * (1 + b^2) = 1 + a^2 + b^2 + (a * b)^2 := by\n      ring_nf\n      <;>\n      nlinarith [sq_nonneg (a - b)]\n    have h2 : (1 + c^2) * (1 + d^2) = 1 + c^2 + d^2 + (c * d)^2 := by\n      ring_nf\n      <;>\n      nlinarith [sq_nonneg (c - d)]\n    calc\n      (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) = ((1 + a^2) * (1 + b^2)) * ((1 + c^2) * (1 + d^2)) := by ring\n      _ = (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) := by\n        rw [h1, h2]\n        <;>\n        ring_nf\n        <;>\n        nlinarith [sq_nonneg (a - b), sq_nonneg (c - d)]\n  \n  have h_cauchy_schwarz : (a + c + b * d + a * b * c * d)^2 \u2264 (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) := by\n    have h1 : 0 \u2264 (1 - a * c)^2 + (d - b * c)^2 + (c * d - a * b * c)^2 + (a * d - b)^2 + (a * c * d - a * b)^2 + (b * c * d - a * b * d)^2 := by positivity\n    have h2 : (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) - (a + c + b * d + a * b * c * d)^2 = (1 - a * c)^2 + (d - b * c)^2 + (c * d - a * b * c)^2 + (a * d - b)^2 + (a * c * d - a * b)^2 + (b * c * d - a * b * d)^2 := by\n      ring_nf\n      <;>\n      nlinarith [sq_nonneg (a - b), sq_nonneg (a - c), sq_nonneg (a - d), sq_nonneg (b - c), sq_nonneg (b - d), sq_nonneg (c - d)]\n    nlinarith\n  \n  have h_main : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + a * b * c * d)^2 := by\n    have h\u2081 : (a + c + b * d + a * b * c * d)^2 \u2264 (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) := h_cauchy_schwarz\n    have h\u2082 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) = (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) := h_product_expansion\n    have h\u2083 : (a + c + b * d + a * b * c * d)^2 \u2264 (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) := by\n      calc\n        (a + c + b * d + a * b * c * d)^2 \u2264 (1 + a^2 + b^2 + (a * b)^2) * (1 + c^2 + d^2 + (c * d)^2) := h\u2081\n        _ = (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) := by\n          rw [h\u2082]\n          <;> ring_nf\n          <;> nlinarith\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization introduces a critical constraint 'a * b * c * d = 1' that is completely absent from the natural language description. This constraint is mathematically essential for the inequality to hold in general. Additionally, the natural language claims the result follows from applying Cauchy-Schwarz to specific vectors, but the actual Cauchy-Schwarz application on those vectors would yield a different inequality structure. The missing constraint represents a major logical component that fundamentally changes the mathematical statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization introduces a critical constraint 'a * b * c * d = 1' that is completely absent from the natural language description. This constraint is mathematically essential for the inequality to hold in general. Additionally, the natural language claims the result follows from applying Cauchy-Schwarz to specific vectors, but the actual Cauchy-Schwarz application on those vectors would yield a different inequality structure. The missing constraint represents a major logical component that fundamentally changes the mathematical statement.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since $abcd=1$, this reduces to $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+c+bd+1)^2$.", "statement": "We assume:\n\u2022 $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+c+bd+abcd)^2$ [l1]\n\u2022 $abcd=1$ [tc_2].\nTherefore, we conclude:\n\u2022 $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+c+bd+1)^2$ [l2].", "dependencies": ["l1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1)\n  (l1 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + a * b * c * d)^2) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + 1)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1)\n  (l1 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + a * b * c * d)^2) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + 1)^2 := by\n  have h_sum_eq : (a + c + b * d + a * b * c * d) = (a + c + b * d + 1) := by\n    have h\u2081 : a * b * c * d = 1 := h_constraint\n    have h\u2082 : a + c + b * d + a * b * c * d = a + c + b * d + 1 := by\n      rw [h\u2081]\n      <;> ring\n    exact h\u2082\n  \n  have h_sq_eq : (a + c + b * d + a * b * c * d)^2 = (a + c + b * d + 1)^2 := by\n    rw [h_sum_eq]\n    <;>\n    ring_nf\n    <;>\n    simp_all\n    <;>\n    nlinarith\n  \n  have h_main : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + 1)^2 := by\n    have h\u2082 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + a * b * c * d)^2 := l1\n    have h\u2083 : (a + c + b * d + a * b * c * d)^2 = (a + c + b * d + 1)^2 := h_sq_eq\n    have h\u2084 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + 1)^2 := by\n      calc\n        (1 + a ^ 2) * (1 + b ^ 2) * (1 + c ^ 2) * (1 + d ^ 2) \u2265 (a + c + b * d + a * b * c * d) ^ 2 := h\u2082\n        _ = (a + c + b * d + 1) ^ 2 := by rw [h\u2083]\n    exact h\u2084\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all mathematical content from the natural language. The variable declarations, constraint abcd=1, assumption l1, and conclusion l2 are all correctly represented. The additional positivity constraints (0 < a, 0 < b, 0 < c, 0 < d) are reasonable mathematical assumptions that don't contradict the natural language and are acceptable as extra conditions. The logical structure showing how the constraint tc_2 allows the substitution of 'abcd' with '1' in assumption l1 to derive conclusion l2 is properly maintained."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "The remaining step is to show $a+c+bd+1 \\ge a+b+c+d$, which is equivalent to $bd+1 \\ge b+d$. This holds because $(b-1)(d-1) \\ge 0$ for some choice of two variables $b$ and $d$, which is always possible given that $abcd=1$.", "statement": "We assume:\n\u2022 $a, b, c, d$ are positive real numbers [tc_1]\n\u2022 $abcd=1$ [tc_2].\nTherefore, we conclude:\n\u2022 $a+c+bd+1 \\ge a+b+c+d$ [l3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  a + c + b * d + 1 \u2265 a + b + c + d := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  a + b + c + d \u2265 4 := by\n  have h\u2081 : 0 < a * b := by positivity\n  have h\u2082 : 0 < a * b * c := by positivity\n  have h\u2083 : 0 < a * b * c * d := by positivity\n  -- Using AM-GM inequality\n  have h\u2084 : a + b + c + d \u2265 4 := by\n    nlinarith [sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (c - 1), sq_nonneg (d - 1),\n      sq_nonneg (a * b - 1), sq_nonneg (a * b * c - 1)]\n  exact h\u2084", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 4, "endLine": 13, "endColumn": 55, "data": "linarith failed to find a contradiction\ncase a\na b c d : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\nhd : 0 < d\nh_constraint : a * b * c * d = 1\nh\u2081 : 0 < a * b\nh\u2082 : 0 < a * b * c\nh\u2083 : 0 < a * b * c * d\na\u271d : 4 > a + b + c + d\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations perfectly capture 'a, b, c, d are positive real numbers' with explicit type and positivity constraints", "The constraint 'abcd = 1' is perfectly represented as 'a * b * c * d = 1' with equivalent mathematical meaning", "The conclusion inequality is perfectly matched between natural language and Lean formalization, with only notational differences (bd vs b * d)", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1) :\n  a + c + b * d + 1 \u2265 a + b + c + d := by\n  have h\u2081 : 0 < a * b := by positivity\n  have h\u2082 : 0 < a * b * c := by positivity\n  have h\u2083 : 0 < a * b * d := by positivity\n  have h\u2084 : 0 < a * c := by positivity\n  have h\u2085 : 0 < a * d := by positivity\n  have h\u2086 : 0 < b * c := by positivity\n  have h\u2087 : 0 < b * d := by positivity\n  have h\u2088 : 0 < c * d := by positivity\n  have h_main : a + c + b * d + 1 \u2265 a + b + c + d := by\n    nlinarith [sq_nonneg (b - 1), sq_nonneg (d - 1), sq_nonneg (a - 1), sq_nonneg (c - 1),\n      mul_nonneg ha.le hb.le, mul_nonneg ha.le hc.le, mul_nonneg ha.le hd.le,\n      mul_nonneg hb.le hc.le, mul_nonneg hb.le hd.le, mul_nonneg hc.le hd.le,\n      mul_pos ha hb, mul_pos ha hc, mul_pos ha hd, mul_pos hb hc, mul_pos hb hd,\n      mul_pos hc hd]\n  exact h_main"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Combining these, we obtain $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+b+c+d)^2$, completing the proof.", "statement": "We assume:\n\u2022 $a, b, c, d$ are positive real numbers [tc_1]\n\u2022 $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+c+bd+1)^2$ [l2]\n\u2022 $a+c+bd+1 \\ge a+b+c+d$ [l3].\nTherefore, we conclude:\n\u2022 $(1+a^2)(1+b^2)(1+c^2)(1+d^2) \\ge (a+b+c+d)^2$ [ts_1].", "dependencies": ["tc_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1)\n  (tc_1 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2)\n  (l2 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + 1)^2)\n  (l3 : a + c + b * d + 1 \u2265 a + b + c + d) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b c d : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hd : 0 < d) \n  (h_constraint : a * b * c * d = 1)\n  (tc_1 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2)\n  (l2 : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + c + b * d + 1)^2)\n  (l3 : a + c + b * d + 1 \u2265 a + b + c + d) :\n  (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2 := by\n  have h_sum_pos : 0 < a + b + c + d := by\n    have h\u2081 : 0 < a + b + c + d := by linarith [ha, hb, hc, hd]\n    exact h\u2081\n  \n  have h_sum_le : a + b + c + d \u2264 a + c + b * d + 1 := by\n    linarith\n  \n  have h_sq_le : (a + b + c + d)^2 \u2264 (a + c + b * d + 1)^2 := by\n    have h\u2081 : 0 \u2264 a + b + c + d := by linarith\n    have h\u2082 : 0 \u2264 a + c + b * d + 1 := by\n      nlinarith [mul_pos hb hd, ha, hc, hb, hd]\n    have h\u2083 : 0 \u2264 (a + c + b * d + 1) + (a + b + c + d) := by linarith\n    have h\u2084 : 0 \u2264 (a + c + b * d + 1) - (a + b + c + d) := by linarith\n    nlinarith [sq_nonneg ((a + c + b * d + 1) - (a + b + c + d))]\n  \n  have h_main : (1 + a^2) * (1 + b^2) * (1 + c^2) * (1 + d^2) \u2265 (a + b + c + d)^2 := by\n    have h\u2081 : (1 + a ^ 2) * (1 + b ^ 2) * (1 + c ^ 2) * (1 + d ^ 2) \u2265 (a + c + b * d + 1) ^ 2 := l2\n    have h\u2082 : (a + b + c + d) ^ 2 \u2264 (a + c + b * d + 1) ^ 2 := h_sq_le\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations correctly capture that a, b, c, d are positive real numbers", "tc_1 has contradictory meanings: in natural language it refers to variables being positive reals, but in Lean it states the conclusion inequality. Additionally, the constraint 'a * b * c * d = 1' appears in Lean but is not mentioned in the natural language", "Assumption l2 is correctly formalized with the proper inequality involving (a + c + b * d + 1)\u00b2", "Assumption l3 is correctly formalized showing a + c + b * d + 1 \u2265 a + b + c + d", "The conclusion ts_1 correctly states the target inequality (1 + a\u00b2)(1 + b\u00b2)(1 + c\u00b2)(1 + d\u00b2) \u2265 (a + b + c + d)\u00b2"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations correctly capture that a, b, c, d are positive real numbers', \"tc_1 has contradictory meanings: in natural language it refers to variables being positive reals, but in Lean it states the conclusion inequality. Additionally, the constraint 'a * b * c * d = 1' appears in Lean but is not mentioned in the natural language\", 'Assumption l2 is correctly formalized with the proper inequality involving (a + c + b * d + 1)\u00b2', 'Assumption l3 is correctly formalized showing a + c + b * d + 1 \u2265 a + b + c + d', 'The conclusion ts_1 correctly states the target inequality (1 + a\u00b2)(1 + b\u00b2)(1 + c\u00b2)(1 + d\u00b2) \u2265 (a + b + c + d)\u00b2']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    