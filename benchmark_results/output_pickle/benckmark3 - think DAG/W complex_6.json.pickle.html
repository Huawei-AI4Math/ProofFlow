
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $z$ be a complex number. If $|z-i| = 1$ and $\operatorname{Arg}(z) = \pi/6$, then $z = \frac{\sqrt{3}}{2} + \frac{i}{2}$.

Proof: From the condition $\operatorname{Arg}(z) = \pi/6$, we can write $z$ in polar form as $z = r(\frac{\sqrt{3}}{2} + \frac{i}{2})$ for some $r>0$. From the condition $|z-i|=1$, we can write this in cartesian coordinates $x, y$ as $x^2+(y-1)^2=1$. By substituting the real and imaginary parts of $z$, namely $x=r\frac{\sqrt{3}}{2}$ and $y=r/2$, into the cartesian equation, we get $(r\frac{\sqrt{3}}{2})^2 + (r/2-1)^2 = 1$, which simplifies to $r^2-r=0$. Since the argument of $z$ is defined, $z$ must be non-zero, which implies $r>0$; therefore, the only valid solution is $r=1$. Substituting $r=1$ into the polar form gives the result $z = \frac{\sqrt{3}}{2} + \frac{i}{2}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $|z-i| = 1$", "statement": "Premise:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(tc_1 : Complex.abs (z - Complex.I) = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `(z : \u2102)` correctly declares z as a complex number, matching the natural language condition exactly.", "The Lean expression `Complex.abs (z - Complex.I) = 1` is a direct and accurate translation of the mathematical notation |z-i| = 1, where Complex.abs represents the modulus and Complex.I represents the imaginary unit."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "and $\\operatorname{Arg}(z) = \\pi/6$", "statement": "Premise:\n\u2022 $z$ is a complex number such that $\\operatorname{Arg}(z) = \\pi/6$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(tc_2 : Complex.arg z = Real.pi / 6)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (z : \u2102)' correctly captures that z is a complex number, where \u2102 represents the complex number type in Lean", "The Lean condition 'Complex.arg z = Real.pi / 6' perfectly matches the mathematical statement 'Arg(z) = \u03c0/6', where Complex.arg is Lean's representation of the argument function and Real.pi / 6 represents \u03c0/6"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "From the condition $\\operatorname{Arg}(z) = \\pi/6$, we can write $z$ in polar form as $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $\\operatorname{Arg}(z) = \\pi/6$ [tc_2].\nTherefore, we conclude:\n\u2022 There exists a real number $r>0$ such that $z = r(\\cos(\\pi/6) + i\\sin(\\pi/6)) = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (h : Complex.arg z = Real.pi / 6) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (h : Complex.arg z = Real.pi / 6) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n  have h_abs_pos : Complex.abs z > 0 := by\n    by_contra h\u2081\n    have h\u2082 : Complex.abs z \u2264 0 := by linarith [Complex.abs.nonneg z]\n    have h\u2083 : Complex.abs z = 0 := by\n      have h\u2084 : Complex.abs z \u2265 0 := Complex.abs.nonneg z\n      linarith\n    have h\u2084 : z = 0 := by\n      have h\u2085 : Complex.abs z = 0 := h\u2083\n      have h\u2086 : z = 0 := by\n        simpa [Complex.abs.eq_zero] using h\u2085\n      exact h\u2086\n    have h\u2085 : Complex.arg z = 0 := by\n      rw [h\u2084]\n      simp [Complex.arg_zero]\n    have h\u2086 : Real.pi / 6 = (0 : \u211d) := by linarith\n    have h\u2087 : Real.pi > 0 := Real.pi_pos\n    have h\u2088 : Real.pi / 6 > 0 := by positivity\n    linarith\n  \n  have h_re : z.re = Complex.abs z * Real.cos (Real.pi / 6) := by\n    have h\u2082 : z = Complex.abs z * Complex.exp (Complex.arg z * Complex.I) := by\n      rw [Complex.abs_mul_exp_arg_mul_I]\n    have h\u2083 : z.re = (Complex.abs z * Complex.exp (Complex.arg z * Complex.I)).re := by rw [h\u2082]\n    have h\u2084 : (Complex.abs z * Complex.exp (Complex.arg z * Complex.I)).re = Complex.abs z * (Complex.exp (Complex.arg z * Complex.I)).re := by\n      simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, Complex.exp_re, Complex.exp_im]\n      <;> norm_num\n    have h\u2085 : (Complex.exp (Complex.arg z * Complex.I)).re = Real.cos (Complex.arg z) := by\n      simp [Complex.exp_re]\n    have h\u2086 : z.re = Complex.abs z * Real.cos (Complex.arg z) := by\n      calc\n        z.re = (Complex.abs z * Complex.exp (Complex.arg z * Complex.I)).re := h\u2083\n        _ = Complex.abs z * (Complex.exp (Complex.arg z * Complex.I)).re := by rw [h\u2084]\n        _ = Complex.abs z * Real.cos (Complex.arg z) := by rw [h\u2085]\n    rw [h\u2086, h]\n    <;> simp [Real.cos_pi_div_six]\n    <;> ring_nf\n    <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n    <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n  \n  have h_im : z.im = Complex.abs z * Real.sin (Real.pi / 6) := by\n    have h\u2082 : z = Complex.abs z * Complex.exp (Complex.arg z * Complex.I) := by\n      rw [Complex.abs_mul_exp_arg_mul_I]\n    have h\u2083 : z.im = (Complex.abs z * Complex.exp (Complex.arg z * Complex.I)).im := by rw [h\u2082]\n    have h\u2084 : (Complex.abs z * Complex.exp (Complex.arg z * Complex.I)).im = Complex.abs z * (Complex.exp (Complex.arg z * Complex.I)).im := by\n      simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, Complex.exp_re, Complex.exp_im]\n      <;> norm_num\n    have h\u2085 : (Complex.exp (Complex.arg z * Complex.I)).im = Real.sin (Complex.arg z) := by\n      simp [Complex.exp_im]\n    have h\u2086 : z.im = Complex.abs z * Real.sin (Complex.arg z) := by\n      calc\n        z.im = (Complex.abs z * Complex.exp (Complex.arg z * Complex.I)).im := h\u2083\n        _ = Complex.abs z * (Complex.exp (Complex.arg z * Complex.I)).im := by rw [h\u2084]\n        _ = Complex.abs z * Real.sin (Complex.arg z) := by rw [h\u2085]\n    rw [h\u2086, h]\n    <;> simp [Real.sin_pi_div_six]\n    <;> ring_nf\n    <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n    <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n  \n  have h_cos : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 := by\n    norm_num [Real.cos_pi_div_six]\n    <;>\n    linarith [Real.sqrt_nonneg 3]\n  \n  have h_sin : Real.sin (Real.pi / 6) = 1 / 2 := by\n    norm_num [Real.sin_pi_div_six]\n  \n  have h_main : z = (Complex.abs z : \u2102) * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n    have h\u2081 : z.re = Complex.abs z * Real.cos (Real.pi / 6) := h_re\n    have h\u2082 : z.im = Complex.abs z * Real.sin (Real.pi / 6) := h_im\n    have h\u2083 : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 := h_cos\n    have h\u2084 : Real.sin (Real.pi / 6) = 1 / 2 := h_sin\n    have h\u2085 : z.re = Complex.abs z * (Real.sqrt 3 / 2) := by\n      calc\n        z.re = Complex.abs z * Real.cos (Real.pi / 6) := h\u2081\n        _ = Complex.abs z * (Real.sqrt 3 / 2) := by rw [h\u2083]\n    have h\u2086 : z.im = Complex.abs z * (1 / 2) := by\n      calc\n        z.im = Complex.abs z * Real.sin (Real.pi / 6) := h\u2082\n        _ = Complex.abs z * (1 / 2) := by rw [h\u2084]\n    have h\u2087 : z = (Complex.abs z : \u2102) * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n      apply Complex.ext <;> simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add,\n        Complex.ofReal_mul, Complex.ofReal_div, Complex.ofReal_one, Complex.ofReal_zero] at h\u2085 h\u2086 \u22a2 <;>\n        (try ring_nf at h\u2085 h\u2086 \u22a2) <;>\n        (try norm_num at h\u2085 h\u2086 \u22a2) <;>\n        (try simp_all [Complex.ext_iff, Complex.abs, Complex.normSq, pow_two]) <;>\n        (try field_simp [Real.sqrt_eq_iff_sq_eq] at * <;>\n          nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]) <;>\n        (try linarith) <;>\n        (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n      <;>\n      (try\n        {\n          nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n        })\n      <;>\n      (try\n        {\n          ring_nf at *\n          <;>\n          nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n        })\n      <;>\n      (try\n        {\n          field_simp [Real.sqrt_eq_iff_sq_eq] at *\n          <;>\n          nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n        })\n    exact h\u2087\n  \n  have h_final : \u2203 (r : \u211d), r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n    refine' \u27e8Complex.abs z, by exact_mod_cast h_abs_pos, _\u27e9\n    -- We need to show that z = (Complex.abs z) * (Real.sqrt 3 / 2 + Complex.I / 2)\n    -- This is already given by h_main, so we just need to use it\n    simpa using h_main\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 28, "column": 85, "endLine": 28, "endColumn": 95, "data": "unsolved goals\nz : \u2102\nh : z.arg = \u03c0 / 6\nh_abs_pos : Complex.abs z > 0\nh\u2082 : z = \u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I)\n\u22a2 (\u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I)).re =\n    (\u2191(Complex.abs (\u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I))) *\n        Complex.exp (\u2191(\u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I)).arg * Complex.I)).re"}, {"line": 50, "column": 85, "endLine": 50, "endColumn": 95, "data": "unsolved goals\nz : \u2102\nh : z.arg = \u03c0 / 6\nh_abs_pos : Complex.abs z > 0\nh_re : z.re = Complex.abs z * cos (\u03c0 / 6)\nh\u2082 : z = \u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I)\n\u22a2 (\u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I)).im =\n    (\u2191(Complex.abs (\u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I))) *\n        Complex.exp (\u2191(\u2191(Complex.abs z) * Complex.exp (\u2191z.arg * Complex.I)).arg * Complex.I)).im"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise is correctly formalized with z as a complex number and the argument condition properly expressed using Complex.arg", "The existential statement with the positive real constraint is accurately captured", "The mathematical expression correctly uses the evaluated trigonometric values, which is equivalent to the natural language statement even though it skips the intermediate trigonometric form", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (h : Complex.arg z = Real.pi / 6) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n  have h_z_ne_zero : z \u2260 0 := by\n    by_contra h\u2080\n    rw [h\u2080] at h\n    have h\u2081 : Complex.arg (0 : \u2102) = 0 := by simp [Complex.arg_zero]\n    rw [h\u2081] at h\n    have h\u2082 : (0 : \u211d) \u2260 Real.pi / 6 := by\n      have h\u2083 : Real.pi > 0 := Real.pi_pos\n      have h\u2084 : Real.pi / 6 > 0 := by positivity\n      linarith\n    exact h\u2082 (by linarith)\n  \n  have h_abs_pos : Complex.abs z > 0 := by\n    have h\u2081 : Complex.abs z > 0 := by\n      -- Use the property that the absolute value of a non-zero complex number is positive.\n      have h\u2082 : z \u2260 0 := h_z_ne_zero\n      exact Complex.abs.pos h\u2082\n    exact h\u2081\n  \n  have h_re : z.re = Complex.abs z * Real.cos (Real.pi / 6) := by\n    have h\u2081 : Real.cos (Complex.arg z) = z.re / Complex.abs z := by\n      apply Complex.cos_arg\n      <;> simp_all [h_z_ne_zero]\n    have h\u2082 : Real.cos (Complex.arg z) = Real.cos (Real.pi / 6) := by\n      rw [h]\n    have h\u2083 : Real.cos (Real.pi / 6) = z.re / Complex.abs z := by\n      linarith\n    have h\u2084 : z.re = Complex.abs z * Real.cos (Real.pi / 6) := by\n      have h\u2085 : z.re / Complex.abs z = Real.cos (Real.pi / 6) := by\n        linarith\n      have h\u2086 : z.re = Complex.abs z * (z.re / Complex.abs z) := by\n        field_simp [h_abs_pos.ne']\n        <;> ring_nf\n        <;> simp_all [Complex.abs.ne_zero]\n        <;> field_simp [h_abs_pos.ne']\n        <;> linarith\n      rw [h\u2085] at h\u2086\n      linarith\n    exact h\u2084\n  \n  have h_im : z.im = Complex.abs z * Real.sin (Real.pi / 6) := by\n    have h\u2081 : Real.sin (Complex.arg z) = z.im / Complex.abs z := by\n      apply Complex.sin_arg\n      <;> simp_all [h_z_ne_zero]\n    have h\u2082 : Real.sin (Complex.arg z) = Real.sin (Real.pi / 6) := by\n      rw [h]\n    have h\u2083 : Real.sin (Real.pi / 6) = z.im / Complex.abs z := by\n      linarith\n    have h\u2084 : z.im = Complex.abs z * Real.sin (Real.pi / 6) := by\n      have h\u2085 : z.im / Complex.abs z = Real.sin (Real.pi / 6) := by\n        linarith\n      have h\u2086 : z.im = Complex.abs z * (z.im / Complex.abs z) := by\n        field_simp [h_abs_pos.ne']\n        <;> ring_nf\n        <;> simp_all [Complex.abs.ne_zero]\n        <;> field_simp [h_abs_pos.ne']\n        <;> linarith\n      rw [h\u2085] at h\u2086\n      linarith\n    exact h\u2084\n  \n  have h_cos : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 := by\n    norm_num [Real.cos_pi_div_six]\n    <;>\n    linarith [Real.sqrt_nonneg 3]\n  \n  have h_sin : Real.sin (Real.pi / 6) = 1 / 2 := by\n    norm_num [Real.sin_pi_div_six]\n    <;>\n    linarith [Real.sqrt_nonneg 3]\n  \n  have h_main : z = (Complex.abs z : \u2102) * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n    have h\u2081 : z.re = Complex.abs z * (Real.sqrt 3 / 2) := by\n      rw [h_re, h_cos]\n      <;> ring_nf\n      <;> field_simp\n      <;> ring_nf\n    have h\u2082 : z.im = Complex.abs z * (1 / 2) := by\n      rw [h_im, h_sin]\n      <;> ring_nf\n      <;> field_simp\n      <;> ring_nf\n    have h\u2083 : z = (Complex.abs z : \u2102) * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n      apply Complex.ext <;> simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_div, Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im] at h\u2081 h\u2082 \u22a2 <;>\n      (try ring_nf at h\u2081 h\u2082 \u22a2) <;>\n      (try norm_num at h\u2081 h\u2082 \u22a2) <;>\n      (try simp_all [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_div, Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im]) <;>\n      (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]) <;>\n      (try linarith)\n    exact h\u2083\n  \n  have h_final : \u2203 (r : \u211d), r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n    refine' \u27e8Complex.abs z, by positivity, _\u27e9\n    -- We need to show that z = (Complex.abs z : \u211d) * (Real.sqrt 3 / 2 + Complex.I / 2)\n    -- This follows directly from h_main by casting Complex.abs z to \u211d\n    simpa [Complex.ext_iff, Complex.ofReal_mul, Complex.ofReal_add, Complex.ofReal_div] using h_main\n  \n  exact h_final"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From the condition $|z-i|=1$, we can write this in cartesian coordinates $x, y$ as $x^2+(y-1)^2=1$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1].\nTherefore, we conclude:\n\u2022 If $z = x+iy$ where $x,y$ are real numbers, then $x^2 + (y-1)^2 = 1$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (z : \u2102) \n  (tc_1 : Complex.abs (z - Complex.I) = 1) :\n  let x := z.re\n  let y := z.im\n  x^2 + (y - 1)^2 = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (z : \u2102) \n  (tc_1 : Complex.abs (z - Complex.I) = 1) :\n  let x := z.re\n  let y := z.im\n  x^2 + (y - 1)^2 = 1 := by\n  intro x y\n  have h_main : x ^ 2 + (y - 1) ^ 2 = 1 := by\n    have h\u2081 : Complex.abs (z - Complex.I) = Real.sqrt (x ^ 2 + (y - 1) ^ 2) := by\n      -- Calculate the modulus of z - i\n      simp [x, y, Complex.abs, Complex.normSq, Complex.ext_iff, Real.sqrt_eq_iff_sq_eq,\n        sq, sub_mul, mul_comm]\n      <;> ring_nf <;> simp [Real.sqrt_eq_iff_sq_eq, sq, sub_mul, mul_comm]\n      <;> field_simp [Real.sqrt_eq_iff_sq_eq, sq, sub_mul, mul_comm]\n      <;> ring_nf <;> norm_num <;>\n      simp_all [Complex.ext_iff, pow_two] <;>\n      nlinarith\n    -- Use the given condition to equate the modulus to 1\n    have h\u2082 : Real.sqrt (x ^ 2 + (y - 1) ^ 2) = 1 := by\n      rw [h\u2081] at tc_1\n      exact tc_1\n    -- Square both sides to eliminate the square root\n    have h\u2083 : x ^ 2 + (y - 1) ^ 2 = 1 := by\n      have h\u2084 : Real.sqrt (x ^ 2 + (y - 1) ^ 2) = 1 := h\u2082\n      have h\u2085 : 0 \u2264 x ^ 2 + (y - 1) ^ 2 := by nlinarith\n      have h\u2086 : Real.sqrt (x ^ 2 + (y - 1) ^ 2) ^ 2 = x ^ 2 + (y - 1) ^ 2 := by\n        rw [Real.sq_sqrt] <;> nlinarith\n      nlinarith\n    exact h\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The complex number assumption and modulus condition |z-i| = 1 are correctly formalized using Complex.abs and Complex.I", "The coordinate representation z = x+iy is properly captured using z.re and z.im, with the implicit understanding that these are real numbers", "The conclusion x^2 + (y-1)^2 = 1 is identically represented, and the logical structure (assumption implies conclusion) is preserved in the theorem format"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "By substituting the real and imaginary parts of $z$, namely $x=r\\frac{\\sqrt{3}}{2}$ and $y=r/2$, into the cartesian equation", "statement": "We assume:\n\u2022 There exists a real number $r>0$ such that the complex number $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ [l1].\nTherefore, we conclude:\n\u2022 The real part of $z$ is $x = r\\frac{\\sqrt{3}}{2}$ and the imaginary part is $y = r/2$ [l3].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (z : \u2102) (r : \u211d) (hr : r > 0) (h : z = r * (Real.sqrt 3 / 2 + Complex.I / 2)) :\n  z.re = r * Real.sqrt 3 / 2 \u2227 z.im = r / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (z : \u2102) (r : \u211d) (hr : r > 0) (h : z = r * (Real.sqrt 3 / 2 + Complex.I / 2)) :\n  z.re = r * Real.sqrt 3 / 2 \u2227 z.im = r / 2 := by\n  have h_re : z.re = r * Real.sqrt 3 / 2 := by\n    rw [h]\n    simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_mul, Complex.ofReal_add,\n      Complex.ofReal_div, Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im]\n    <;> ring_nf <;> field_simp <;> ring_nf <;> norm_num <;>\n    simp_all [Real.sqrt_eq_iff_sq_eq] <;>\n    nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n  \n  have h_im : z.im = r / 2 := by\n    rw [h]\n    simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_mul, Complex.ofReal_add,\n      Complex.ofReal_div, Complex.ofReal_one, Complex.ofReal_zero, Complex.I_re, Complex.I_im]\n    <;> ring_nf <;> field_simp <;> ring_nf <;> norm_num <;>\n    simp_all [Real.sqrt_eq_iff_sq_eq] <;>\n    nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n  \n  have h_final : z.re = r * Real.sqrt 3 / 2 \u2227 z.im = r / 2 := by\n    exact \u27e8h_re, h_im\u27e9\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and assumptions are correctly formalized. The Lean code properly captures r > 0 and the complex number definition.", "The conclusion about real and imaginary parts is accurately represented. Using z.re and z.im instead of x and y is appropriate Lean notation for the same mathematical concepts.", "The mathematical expressions are equivalent. The Lean syntax Real.sqrt 3 and Complex.I correctly represent \u221a3 and i respectively.", "The logical structure is properly maintained. The theorem format appropriately formalizes the assumption-conclusion relationship from the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "we get $(r\\frac{\\sqrt{3}}{2})^2 + (r/2-1)^2 = 1$,", "statement": "We assume:\n\u2022 For a complex number $z=x+iy$, we have $x^2 + (y-1)^2 = 1$ [l2].\n\u2022 The real part of $z$ is $x = r\\frac{\\sqrt{3}}{2}$ and the imaginary part is $y = r/2$ for some $r>0$ [l3].\nTherefore, we conclude:\n\u2022 $(r\\frac{\\sqrt{3}}{2})^2 + (r/2-1)^2 = 1$ [l4].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (r : \u211d) (hr : r > 0) :\n  (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (r : \u211d) (hr : r > 0) :\n  (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = 1 := by\n  have h\u2081 : (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = r^2 - r + 1 := by\n    have h\u2082 : 0 \u2264 Real.sqrt 3 := Real.sqrt_nonneg _\n    have h\u2083 : (Real.sqrt 3) ^ 2 = 3 := by norm_num [Real.sqrt_eq_iff_sq_eq]\n    calc\n      (r * Real.sqrt 3 / 2) ^ 2 + (r / 2 - 1) ^ 2 = (r ^ 2 * (Real.sqrt 3) ^ 2) / 4 + (r / 2 - 1) ^ 2 := by\n        ring_nf\n        <;> field_simp [pow_two]\n        <;> ring_nf\n      _ = (r ^ 2 * 3) / 4 + (r / 2 - 1) ^ 2 := by rw [h\u2083]\n      _ = (3 * r ^ 2) / 4 + (r / 2 - 1) ^ 2 := by ring\n      _ = (3 * r ^ 2) / 4 + (r ^ 2 / 4 - r + 1) := by\n        ring_nf\n        <;> field_simp [pow_two]\n        <;> ring_nf\n      _ = r ^ 2 - r + 1 := by ring\n  \n  have h\u2082 : (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = 1 := by\n    have h\u2083 : r = 1 := by\n      by_contra h\n      -- Assume r \u2260 1 and derive a contradiction\n      have h\u2084 : r \u2260 1 := h\n      -- Use specific values to show contradiction\n      have h\u2085 : (2 : \u211d) > 0 := by norm_num\n      have h\u2086 : ((2 : \u211d) * Real.sqrt 3 / 2) ^ 2 + ((2 : \u211d) / 2 - 1) ^ 2 = (3 : \u211d) := by\n        have h\u2087 : Real.sqrt 3 \u2265 0 := Real.sqrt_nonneg _\n        norm_num [pow_two, Real.sqrt_eq_iff_sq_eq]\n        <;>\n        ring_nf <;>\n        norm_num <;>\n        nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n      -- Use linear arithmetic to derive a contradiction\n      have h\u2087 : False := by\n        by_contra h\u2088\n        -- Normalize the numbers and use linear arithmetic to find a contradiction\n        norm_num at h\u2086 \u22a2\n        <;>\n        (try contradiction) <;>\n        (try linarith) <;>\n        (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)])\n      -- Conclude the proof by contradiction\n      exact h\u2087\n    -- Substitute r = 1 into the original expression and verify the result\n    rw [h\u2083]\n    have h\u2084 : ((1 : \u211d) * Real.sqrt 3 / 2) ^ 2 + ((1 : \u211d) / 2 - 1) ^ 2 = 1 := by\n      have h\u2085 : Real.sqrt 3 \u2265 0 := Real.sqrt_nonneg _\n      norm_num [pow_two, Real.sqrt_eq_iff_sq_eq]\n      <;>\n      ring_nf <;>\n      norm_num <;>\n      nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n    simpa using h\u2084\n  exact h\u2082", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 38, "column": 25, "endLine": 45, "endColumn": 83, "data": "unsolved goals\nr : \u211d\nhr : r > 0\nh\u2081 : (r * \u221a3 / 2) ^ 2 + (r / 2 - 1) ^ 2 = r ^ 2 - r + 1\nh : \u00acr = 1\nh\u2084 : r \u2260 1\nh\u2085 : 2 > 0\nh\u2088 : \u00acFalse\nh\u2086 : True\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical conclusion from the natural language. The theorem properly declares r as a positive real number and states the exact equation that results from substituting the given expressions for x and y into the circle equation. While the formalization doesn't explicitly mention the complex number z or the original constraint, this is appropriate since the theorem focuses on the derived mathematical relationship. The mathematical expressions are equivalent between both representations.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem not_l4 : \u2203 (r : \u211d), r > 0 \u2227 (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 \u2260 1 := by\n  have h_main : (2 : \u211d) > 0 \u2227 ((2 : \u211d) * Real.sqrt 3 / 2)^2 + ((2 : \u211d) / 2 - 1)^2 \u2260 1 := by\n    constructor\n    \u00b7 -- Prove that 2 > 0\n      norm_num\n    \u00b7 -- Prove that the expression is not equal to 1\n      have h\u2081 : ((2 : \u211d) * Real.sqrt 3 / 2) = Real.sqrt 3 := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n      have h\u2082 : ((2 : \u211d) / 2 - 1 : \u211d) = 0 := by norm_num\n      have h\u2083 : ((2 : \u211d) * Real.sqrt 3 / 2)^2 + ((2 : \u211d) / 2 - 1)^2 = (Real.sqrt 3)^2 + (0 : \u211d)^2 := by\n        rw [h\u2081, h\u2082]\n        <;> norm_num\n      have h\u2084 : (Real.sqrt 3 : \u211d) ^ 2 = 3 := by norm_num [Real.sqrt_eq_iff_sq_eq]\n      have h\u2085 : ((2 : \u211d) * Real.sqrt 3 / 2)^2 + ((2 : \u211d) / 2 - 1)^2 = 3 := by\n        rw [h\u2083]\n        rw [h\u2084]\n        <;> norm_num\n      have h\u2086 : (3 : \u211d) \u2260 1 := by norm_num\n      intro h\u2087\n      rw [h\u2085] at h\u2087\n      apply h\u2086\n      linarith\n  \n  have h_final : \u2203 (r : \u211d), r > 0 \u2227 (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 \u2260 1 := by\n    refine' \u27e82, _\u27e9\n    -- We already have the proof for r = 2 in h_main\n    exact h_main\n  \n  exact h_final"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "which simplifies to $r^2-r=0$.", "statement": "We assume:\n\u2022 $(r\\frac{\\sqrt{3}}{2})^2 + (r/2-1)^2 = 1$ [l4].\nTherefore, we conclude:\n\u2022 $r^2 - r = 0$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (r : \u211d) (hr : r > 0) \n  (h : (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = 1) : \n  r^2 - r = 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (r : \u211d) (hr : r > 0) \n  (h : (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = 1) : \n  r^2 - r = 0 := by\n  have h1 : (r * Real.sqrt 3 / 2)^2 = 3 * r^2 / 4 := by\n    have h1\u2081 : (r * Real.sqrt 3 / 2) ^ 2 = (r * Real.sqrt 3) ^ 2 / 4 := by\n      ring_nf\n      <;> field_simp\n      <;> ring_nf\n    rw [h1\u2081]\n    have h1\u2082 : (r * Real.sqrt 3) ^ 2 = r ^ 2 * (Real.sqrt 3) ^ 2 := by\n      ring_nf\n    rw [h1\u2082]\n    have h1\u2083 : (Real.sqrt 3) ^ 2 = 3 := by norm_num [Real.sqrt_eq_iff_sq_eq]\n    rw [h1\u2083]\n    <;> ring_nf\n    <;> field_simp\n    <;> ring_nf\n  \n  have h2 : (r / 2 - 1)^2 = r^2 / 4 - r + 1 := by\n    have h\u2082 : (r / 2 - 1) ^ 2 = (r / 2) ^ 2 - 2 * (r / 2) + 1 := by\n      ring_nf\n    rw [h\u2082]\n    <;> ring_nf\n    <;> field_simp\n    <;> ring_nf\n  \n  have h3 : 3 * r^2 / 4 + (r^2 / 4 - r + 1) = 1 := by\n    have h3\u2081 : (r * Real.sqrt 3 / 2)^2 + (r / 2 - 1)^2 = 1 := h\n    have h3\u2082 : (r * Real.sqrt 3 / 2)^2 = 3 * r^2 / 4 := h1\n    have h3\u2083 : (r / 2 - 1)^2 = r^2 / 4 - r + 1 := h2\n    rw [h3\u2082, h3\u2083] at h3\u2081\n    linarith\n  \n  have h4 : r^2 - r + 1 = 1 := by\n    have h4\u2081 : 3 * r ^ 2 / 4 + (r ^ 2 / 4 - r + 1) = 1 := h3\n    have h4\u2082 : 3 * r ^ 2 / 4 + (r ^ 2 / 4 - r + 1) = r ^ 2 - r + 1 := by\n      ring_nf at h4\u2081 \u22a2\n      <;> linarith\n    linarith\n  \n  have h5 : r^2 - r = 0 := by\n    have h5\u2081 : r ^ 2 - r + 1 = 1 := h4\n    have h5\u2082 : r ^ 2 - r = 0 := by\n      linarith\n    exact h5\u2082\n  \n  exact h5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The mathematical equation in the assumption is correctly translated, with proper operator precedence and function calls for square root", "The conclusion r\u00b2 - r = 0 is exactly captured in the Lean formalization", "The additional constraint (hr : r > 0) is an acceptable extra condition that doesn't contradict the natural language and is mathematically reasonable for this context", "The logical structure correctly captures the implication from assumption to conclusion using Lean's theorem format"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since the argument of $z$ is defined, $z$ must be non-zero, which implies $r>0$; therefore, the only valid solution is $r=1$.", "statement": "We assume:\n\u2022 There exists a real number $r>0$ [from l1].\n\u2022 $r^2 - r = 0$ [l5].\nTherefore, we conclude:\n\u2022 $r = 1$ [l6].", "dependencies": ["l1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (r : \u211d) (hr : r > 0) (h : r^2 - r = 0) : r = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (r : \u211d) (hr : r > 0) (h : r^2 - r = 0) : r = 1 := by\n  have h_main : r = 1 := by\n    have h\u2081 : r * (r - 1) = 0 := by\n      -- Factor the quadratic equation r^2 - r = 0 into r(r - 1) = 0\n      have h\u2082 : r ^ 2 - r = 0 := h\n      have h\u2083 : r ^ 2 - r = r * (r - 1) := by ring\n      rw [h\u2083] at h\u2082\n      linarith\n    -- Since r > 0, r \u2260 0, so we can deduce that r - 1 = 0\n    have h\u2082 : r - 1 = 0 := by\n      -- Use the fact that if a product of two numbers is zero and one of them is non-zero, the other must be zero\n      have h\u2083 : r \u2260 0 := by linarith\n      have h\u2084 : r * (r - 1) = 0 := h\u2081\n      have h\u2085 : r - 1 = 0 := by\n        apply mul_left_cancel\u2080 h\u2083\n        nlinarith\n      exact h\u2085\n    -- Solve for r to get r = 1\n    have h\u2083 : r = 1 := by linarith\n    exact h\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures all components of the natural language statement. The variable r is correctly declared as a real number, the positivity condition r > 0 is properly represented as hypothesis hr, the equation r\u00b2 - r = 0 is exactly translated as hypothesis h, and the conclusion r = 1 is correctly stated. The logical structure of the theorem (premises implying conclusion) accurately reflects the natural language reasoning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting $r=1$ into the polar form gives the result $z = \\frac{\\sqrt{3}}{2} + \\frac{i}{2}$.", "statement": "We assume:\n\u2022 There exists a real number $r>0$ such that the complex number $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ [l1].\n\u2022 $r = 1$ [l6].\nTherefore, we conclude:\n\u2022 $z = \\frac{\\sqrt{3}}{2} + \\frac{i}{2}$ [ts_1].", "dependencies": ["l1", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (z : \u2102) (r : \u211d) (hr_pos : r > 0) \n  (l1 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l6 : r^2 - r = 0) :\n  z = Real.sqrt 3 / 2 + Complex.I / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (z : \u2102) (r : \u211d) (hr_pos : r > 0) \n  (l1 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l6 : r^2 - r = 0) :\n  z = Real.sqrt 3 / 2 + Complex.I / 2 := by\n  have h_r : r = 1 := by\n    have h\u2081 : r^2 - r = 0 := l6\n    have h\u2082 : r > 0 := hr_pos\n    have h\u2083 : r * (r - 1) = 0 := by\n      nlinarith\n    have h\u2084 : r \u2260 0 := by linarith\n    have h\u2085 : r - 1 = 0 := by\n      apply mul_left_cancel\u2080 h\u2084\n      nlinarith\n    nlinarith\n  \n  have h_main : z = Real.sqrt 3 / 2 + Complex.I / 2 := by\n    rw [l1]\n    rw [h_r]\n    <;> simp [Complex.ext_iff, Complex.I_mul_I, pow_two]\n    <;> ring_nf\n    <;> norm_num\n    <;> field_simp [Complex.ext_iff, Complex.I_mul_I, pow_two]\n    <;> ring_nf\n    <;> norm_num\n    <;>\n    simp_all [Complex.ext_iff, Complex.I_mul_I, pow_two]\n    <;>\n    norm_num\n    <;>\n    linarith [Real.sqrt_nonneg 3]\n  \n  rw [h_main]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical meaning of the natural language. While l6 uses 'r^2 - r = 0' instead of 'r = 1', these are mathematically equivalent given the constraint r > 0. The condition r^2 - r = 0 factors to r(r-1) = 0, giving r = 0 or r = 1, but since r > 0, we must have r = 1. All other components (the positivity constraint, the expression for z, and the conclusion) are accurately represented."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    