
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $f$ is monotonic on $[a,b],$ then $f$ is integrable on $[a,b]$.

We can assume the following statement(s) without a proof. 

If $f$ is bounded on $[a,b],$ then $f$ is integrable on $[a,b]$
 if and only if for each $\epsilon>0$ there is
a partition $P$ of $[a,b]$ for which
\begin{equation} \label{eq:3.2.19}
S(P)-s(P)<\epsilon.
\end{equation}

Proof: Let $P=\{x_0,x_1, \dots,x_n\}$ be a partition of $[a,b]$. Since
 $f$ is nondecreasing,
\begin{eqnarray*}
f(x_j)\ar=M_j=\sup_{x_{j-1}\le x\le x_j}f(x)\\
\arraytext{and}\\
f(x_{j-1})\ar=m_j=\inf_{x_{j-1}\le x\le x_j}f(x).
\end{eqnarray*}
Hence,
$$
S(P)-s(P)=\sum_{j=1}^n(f(x_j)-f(x_{j-1})) (x_j-x_{j-1}).
$$
Since $0<x_j-x_{j-1}\le \|P\|$ and $f(x_j)-f(x_{j-1})\ge0$,
\begin{eqnarray*}
S(P)-s(P)\ar\le  \|P\| \sum_{j=1}^n(f(x_j)-f(x_{j-1})) \\
\ar=\|P\|(f(b)-f(a)).
\end{eqnarray*}

ewpage

oindent
Therefore,
$$
S(P)-s(P)<\epsilon\mbox{\quad if \quad}
\|P\|(f(b)-f(a))<\epsilon,
$$
 so $f$ is integrable on $[a,b]$, by Theorem~\ref{thmtype:3.2.7}.
The proof for nonincreasing $f$ is similar.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $f$ is monotonic on $[a,b]$", "statement": "Premise:\n\u2022 $f$ is a real-valued function defined and monotonic on the closed interval $[a,b]$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u211d) (f : \u211d \u2192 \u211d)\n(h_le : a \u2264 b)\n(tc_1 : MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'f : \u211d \u2192 \u211d' correctly captures that f is a real-valued function", "The Lean formalization implicitly handles the domain through 'Set.Icc a b' in the monotonicity condition, and includes the extra constraint 'h_le : a \u2264 b' to ensure the interval is well-defined, which is logically consistent", "The Lean condition 'MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b)' correctly captures monotonicity on the closed interval [a,b], where 'Set.Icc a b' represents the closed interval and the disjunction covers both increasing and decreasing monotonicity"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "If $f$ is bounded on $[a,b],$ then $f$ is integrable on $[a,b]$ if and only if for each $\\epsilon>0$ there is a partition $P$ of $[a,b]$ for which $S(P)-s(P)<\\epsilon$.", "statement": "Definition:\n\u2022 (Riemann's Criterion for Integrability) If a function $f$ is bounded on $[a,b]$, then $f$ is integrable on $[a,b]$ if and only if for each $\\epsilon>0$ there exists a partition $P$ of $[a,b]$ such that the difference between the upper sum $S(P)$ and lower sum $s(P)$ is less than $\\epsilon$, i.e., $S(P)-s(P)<\\epsilon$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u211d) (hab : a \u2264 b) (f : \u211d \u2192 \u211d)\nvariable (hf_bounded : \u2203 M, \u2200 x \u2208 Set.Icc a b, |f x| \u2264 M)\n\n-- Riemann's Criterion for Integrability\ndef_1 : \n  (IntervalIntegrable f volume a b) \u2194 \n  (\u2200 \u03b5 > 0, \u2203 P : List \u211d, \n    P.Sorted (\u00b7 \u2264 \u00b7) \u2227 P.head? = some a \u2227 P.getLast? = some b \u2227\n    let upper_sum := \u2211 j in Finset.range (P.length - 1), \n      (sSup (f '' Set.Icc (P.get \u27e8j, by sorry\u27e9) (P.get \u27e8j + 1, by sorry\u27e9))) * \n      (P.get \u27e8j + 1, by sorry\u27e9 - P.get \u27e8j, by sorry\u27e9)\n    let lower_sum := \u2211 j in Finset.range (P.length - 1), \n      (sInf (f '' Set.Icc (P.get \u27e8j, by sorry\u27e9) (P.get \u27e8j + 1, by sorry\u27e9))) * \n      (P.get \u27e8j + 1, by sorry\u27e9 - P.get \u27e8j, by sorry\u27e9)\n    upper_sum - lower_sum < \u03b5) := by sorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 0, "endLine": 11, "endColumn": 5, "data": "unexpected identifier; expected command"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "Let $P=\\{x_0,x_1, \\dots,x_n\\}$ be a partition of $[a,b]$.", "statement": "Definition:\n\u2022 Let $P=\\{x_0,x_1, \\dots,x_n\\}$ be a partition of the interval $[a,b]$, where $a=x_0 < x_1 < \\dots < x_n=b$. Let $\\|P\\| = \\max_{1 \\le j \\le n} (x_j - x_{j-1})$ be the norm of the partition [def_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n(h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n(h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n\nnoncomputable def partition_norm : \u211d := \n  sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures that P is a partition of [a,b] through the variable declarations and h_partition condition, establishing the sequence x with endpoints a and b.", "The Lean conditions h_partition and h_strict together perfectly capture the mathematical requirement a=x_0 < x_1 < ... < x_n=b. The h_partition ensures a = x 0, b = x n, and monotonicity, while h_strict ensures the strict inequalities.", "The Lean definition uses sSup (supremum) over the image of differences, which is mathematically equivalent to max but uses a different approach. The indexing is also slightly different - Lean uses Fin n with j.val + 1 to access x_{j+1}, while the math directly uses indices 1 to n. Both represent the same mathematical concept but with different technical implementations."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_3": {"id": "def_3", "natural_language": "Since $f$ is nondecreasing,", "statement": "Definition:\n\u2022 We perform a case analysis on the premise that $f$ is monotonic [tc_1]. We first assume $f$ is nondecreasing on $[a,b]$ [def_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u211d) (f : \u211d \u2192 \u211d)\n(h_le : a \u2264 b)\n(def_3 : MonotoneOn f (Set.Icc a b))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The general condition that f is monotonic [tc_1] is missing from the Lean formalization. The Lean only has the specific assumption def_3 about monotonicity on [a,b], but not the general monotonicity condition tc_1.", "The Lean formalization perfectly captures the assumption that f is nondecreasing on [a,b] using MonotoneOn f (Set.Icc a b).", "The conclusion about performing case analysis is a meta-mathematical statement about proof strategy that would not appear as a proposition in Lean variable declarations. This type of procedural conclusion is not captured in the Lean formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The general condition that f is monotonic [tc_1] is missing from the Lean formalization. The Lean only has the specific assumption def_3 about monotonicity on [a,b], but not the general monotonicity condition tc_1.', 'The Lean formalization perfectly captures the assumption that f is nondecreasing on [a,b] using MonotoneOn f (Set.Icc a b).', 'The conclusion about performing case analysis is a meta-mathematical statement about proof strategy that would not appear as a proposition in Lean variable declarations. This type of procedural conclusion is not captured in the Lean formalization.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "(Implicit prerequisite for applying the given theorem)", "statement": "We assume:\n\u2022 $f$ is a real-valued function defined and monotonic on the closed interval $[a,b]$ [tc_1].\nTherefore, we conclude:\n\u2022 $f$ is bounded on $[a,b]$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) (h_le : a \u2264 b)\n  (tc_1 : MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b)) :\n  \u2203 M, \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) (h_le : a \u2264 b)\n  (tc_1 : MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b)) :\n  \u2203 M, \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M := by\n  have h_main : \u2203 (M : \u211d), \u2200 (x : \u211d), x \u2208 Set.Icc a b \u2192 abs (f x) \u2264 M := by\n    use max (abs (f a)) (abs (f b))\n    intro x hx\n    have h\u2081 : a \u2264 x := hx.1\n    have h\u2082 : x \u2264 b := hx.2\n    have h\u2083 : a \u2208 Set.Icc a b := \u27e8by linarith, by linarith\u27e9\n    have h\u2084 : b \u2208 Set.Icc a b := \u27e8by linarith, by linarith\u27e9\n    have h\u2085 : x \u2208 Set.Icc a b := hx\n    have h\u2086 : f x \u2264 max (abs (f a)) (abs (f b)) := by\n      cases' tc_1 with h_mono h_anti\n      \u00b7 -- Case: f is monotone on [a, b]\n        have h\u2087 : f x \u2264 f b := by\n          apply h_mono\n          <;> simp_all [Set.mem_Icc]\n          <;> linarith\n        have h\u2088 : f b \u2264 abs (f b) := by\n          exact le_abs_self (f b)\n        have h\u2089 : abs (f b) \u2264 max (abs (f a)) (abs (f b)) := by\n          apply le_max_right\n        have h\u2081\u2080 : f x \u2264 max (abs (f a)) (abs (f b)) := by\n          linarith\n        exact h\u2081\u2080\n      \u00b7 -- Case: f is antitone on [a, b]\n        have h\u2087 : f x \u2264 f a := by\n          apply h_anti\n          <;> simp_all [Set.mem_Icc]\n          <;> linarith\n        have h\u2088 : f a \u2264 abs (f a) := by\n          exact le_abs_self (f a)\n        have h\u2089 : abs (f a) \u2264 max (abs (f a)) (abs (f b)) := by\n          apply le_max_left\n        have h\u2081\u2080 : f x \u2264 max (abs (f a)) (abs (f b)) := by\n          linarith\n        exact h\u2081\u2080\n    have h\u2087 : -max (abs (f a)) (abs (f b)) \u2264 f x := by\n      cases' tc_1 with h_mono h_anti\n      \u00b7 -- Case: f is monotone on [a, b]\n        have h\u2088 : f a \u2264 f x := by\n          apply h_mono\n          <;> simp_all [Set.mem_Icc]\n          <;> linarith\n        have h\u2089 : -abs (f a) \u2264 f a := by\n          linarith [abs_nonneg (f a)]\n        have h\u2081\u2080 : -abs (f a) \u2265 -max (abs (f a)) (abs (f b)) := by\n          have h\u2081\u2081 : abs (f a) \u2264 max (abs (f a)) (abs (f b)) := by\n            apply le_max_left\n          linarith\n        have h\u2081\u2081 : -max (abs (f a)) (abs (f b)) \u2264 f x := by\n          linarith\n        exact h\u2081\u2081\n      \u00b7 -- Case: f is antitone on [a, b]\n        have h\u2088 : f b \u2264 f x := by\n          apply h_anti\n          <;> simp_all [Set.mem_Icc]\n          <;> linarith\n        have h\u2089 : -abs (f b) \u2264 f b := by\n          linarith [abs_nonneg (f b)]\n        have h\u2081\u2080 : -abs (f b) \u2265 -max (abs (f a)) (abs (f b)) := by\n          have h\u2081\u2081 : abs (f b) \u2264 max (abs (f a)) (abs (f b)) := by\n            apply le_max_right\n          linarith\n        have h\u2081\u2081 : -max (abs (f a)) (abs (f b)) \u2264 f x := by\n          linarith\n        exact h\u2081\u2081\n    have h\u2088 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n      rw [abs_le]\n      constructor <;> linarith\n    exact h\u2088\n  obtain \u27e8M, hM\u27e9 := h_main\n  refine' \u27e8M, _\u27e9\n  intro x hx\n  exact hM x hx", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 50, "column": 10, "endLine": 50, "endColumn": 37, "data": "linarith failed to find a contradiction\ncase a\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nx : \u211d\nhx : x \u2208 Set.Icc a b\nh\u2081 : a \u2264 x\nh\u2082 : x \u2264 b\nh\u2083 : a \u2208 Set.Icc a b\nh\u2084 : b \u2208 Set.Icc a b\nh\u2085 : x \u2208 Set.Icc a b\nh\u2086 : f x \u2264 |f a| \u2294 |f b|\nh_mono : MonotoneOn f (Set.Icc a b)\nh\u2088 : f a \u2264 f x\na\u271d : -|f a| > f a\n\u22a2 False failed"}, {"line": 64, "column": 10, "endLine": 64, "endColumn": 37, "data": "linarith failed to find a contradiction\ncase a\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nx : \u211d\nhx : x \u2208 Set.Icc a b\nh\u2081 : a \u2264 x\nh\u2082 : x \u2264 b\nh\u2083 : a \u2208 Set.Icc a b\nh\u2084 : b \u2208 Set.Icc a b\nh\u2085 : x \u2208 Set.Icc a b\nh\u2086 : f x \u2264 |f a| \u2294 |f b|\nh_anti : AntitoneOn f (Set.Icc a b)\nh\u2088 : f b \u2264 f x\na\u271d : -|f b| > f b\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function type and domain are correctly captured. The Lean formalization uses Set.Icc a b which correctly represents the closed interval [a,b].", "The explicit condition h_le : a \u2264 b is a reasonable mathematical assumption that ensures the interval [a,b] is well-defined, even though not explicitly stated in natural language.", "The monotonicity condition is correctly formalized. The Lean version uses a disjunction of MonotoneOn and AntitoneOn, which properly captures 'monotonic' (either increasing or decreasing).", "The boundedness conclusion is correctly formalized. The existential quantification of a bound M such that |f(x)| \u2264 M for all x in the interval is the standard mathematical definition of boundedness.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) (h_le : a \u2264 b)\n  (tc_1 : MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b)) :\n  \u2203 M, \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M := by\n  cases tc_1 with\n  | inl h_mono =>\n    -- Case: f is monotone on [a, b]\n    use max (abs (f a)) (abs (f b))\n    intro x hx\n    have h\u2081 : a \u2264 x := hx.1\n    have h\u2082 : x \u2264 b := hx.2\n    have h\u2083 : f a \u2264 f x := by\n      apply h_mono\n      <;> simp_all [Set.Icc, le_of_lt]\n      <;> (try { nlinarith })\n      <;> (try { linarith })\n    have h\u2084 : f x \u2264 f b := by\n      apply h_mono\n      <;> simp_all [Set.Icc, le_of_lt]\n      <;> (try { nlinarith })\n      <;> (try { linarith })\n    -- Now prove that |f x| \u2264 max(|f a|, |f b|)\n    have h\u2085 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n      by_cases h : f x \u2265 0\n      \u00b7 -- Case: f x \u2265 0\n        have h\u2086 : abs (f x) = f x := by rw [abs_of_nonneg h]\n        have h\u2087 : f x \u2264 f b := h\u2084\n        have h\u2088 : f x \u2264 abs (f b) := by\n          cases' le_or_lt 0 (f b) with h\u2089 h\u2089\n          \u00b7 -- Subcase: f b \u2265 0\n            have h\u2081\u2080 : abs (f b) = f b := by rw [abs_of_nonneg h\u2089]\n            linarith\n          \u00b7 -- Subcase: f b < 0\n            have h\u2081\u2080 : abs (f b) = -f b := by rw [abs_of_neg h\u2089]\n            have h\u2081\u2081 : f x \u2264 f b := h\u2084\n            have h\u2081\u2082 : f x \u2264 0 := by linarith\n            have h\u2081\u2083 : f b < 0 := h\u2089\n            linarith\n        have h\u2089 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n          calc\n            abs (f x) = f x := by rw [h\u2086]\n            _ \u2264 abs (f b) := h\u2088\n            _ \u2264 max (abs (f a)) (abs (f b)) := by apply le_max_right\n        exact h\u2089\n      \u00b7 -- Case: f x < 0\n        have h\u2086 : abs (f x) = -f x := by rw [abs_of_neg (by linarith)]\n        have h\u2087 : f a \u2264 f x := h\u2083\n        have h\u2088 : -f x \u2264 -f a := by linarith\n        have h\u2089 : -f a \u2264 abs (f a) := by\n          cases' le_or_lt 0 (f a) with h\u2081\u2080 h\u2081\u2080\n          \u00b7 -- Subcase: f a \u2265 0\n            have h\u2081\u2081 : abs (f a) = f a := by rw [abs_of_nonneg h\u2081\u2080]\n            linarith\n          \u00b7 -- Subcase: f a < 0\n            have h\u2081\u2081 : abs (f a) = -f a := by rw [abs_of_neg h\u2081\u2080]\n            linarith\n        have h\u2081\u2080 : abs (f x) \u2264 abs (f a) := by linarith\n        have h\u2081\u2081 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n          calc\n            abs (f x) \u2264 abs (f a) := h\u2081\u2080\n            _ \u2264 max (abs (f a)) (abs (f b)) := by apply le_max_left\n        exact h\u2081\u2081\n    exact h\u2085\n  | inr h_anti =>\n    -- Case: f is antitone on [a, b]\n    use max (abs (f a)) (abs (f b))\n    intro x hx\n    have h\u2081 : a \u2264 x := hx.1\n    have h\u2082 : x \u2264 b := hx.2\n    have h\u2083 : f b \u2264 f x := by\n      apply h_anti\n      <;> simp_all [Set.Icc, le_of_lt]\n      <;> (try { nlinarith })\n      <;> (try { linarith })\n    have h\u2084 : f x \u2264 f a := by\n      apply h_anti\n      <;> simp_all [Set.Icc, le_of_lt]\n      <;> (try { nlinarith })\n      <;> (try { linarith })\n    -- Now prove that |f x| \u2264 max(|f a|, |f b|)\n    have h\u2085 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n      by_cases h : f x \u2265 0\n      \u00b7 -- Case: f x \u2265 0\n        have h\u2086 : abs (f x) = f x := by rw [abs_of_nonneg h]\n        have h\u2087 : f x \u2264 f a := h\u2084\n        have h\u2088 : f a \u2265 0 := by\n          by_contra h\u2089\n          have h\u2081\u2080 : f a < 0 := by linarith\n          have h\u2081\u2081 : f x \u2264 f a := h\u2084\n          have h\u2081\u2082 : f x < 0 := by linarith\n          linarith\n        have h\u2089 : abs (f a) = f a := by rw [abs_of_nonneg h\u2088]\n        have h\u2081\u2080 : abs (f x) \u2264 abs (f a) := by\n          calc\n            abs (f x) = f x := by rw [h\u2086]\n            _ \u2264 f a := h\u2087\n            _ = abs (f a) := by rw [h\u2089]\n        have h\u2081\u2081 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n          calc\n            abs (f x) \u2264 abs (f a) := h\u2081\u2080\n            _ \u2264 max (abs (f a)) (abs (f b)) := by apply le_max_left\n        exact h\u2081\u2081\n      \u00b7 -- Case: f x < 0\n        have h\u2086 : abs (f x) = -f x := by rw [abs_of_neg (by linarith)]\n        have h\u2087 : f b \u2264 f x := h\u2083\n        have h\u2088 : f b \u2264 0 := by linarith\n        have h\u2089 : abs (f b) = -f b := by rw [abs_of_neg (by linarith)]\n        have h\u2081\u2080 : -f x \u2264 -f b := by linarith\n        have h\u2081\u2081 : abs (f x) \u2264 abs (f b) := by\n          calc\n            abs (f x) = -f x := by rw [h\u2086]\n            _ \u2264 -f b := h\u2081\u2080\n            _ = abs (f b) := by rw [h\u2089]\n        have h\u2081\u2082 : abs (f x) \u2264 max (abs (f a)) (abs (f b)) := by\n          calc\n            abs (f x) \u2264 abs (f b) := h\u2081\u2081\n            _ \u2264 max (abs (f a)) (abs (f b)) := by apply le_max_right\n        exact h\u2081\u2082\n    exact h\u2085"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since $f$ is nondecreasing, $f(x_j)=M_j=\\sup_{x_{j-1}\\le x\\le x_j}f(x)$ and $f(x_{j-1})=m_j=\\inf_{x_{j-1}\\le x\\le x_j}f(x).", "statement": "We assume:\n\u2022 $f$ is nondecreasing on $[a,b]$ [def_3].\n\u2022 $P=\\{x_0,x_1, \\dots,x_n\\}$ is a partition of $[a,b]$ [def_2].\n\u2022 For each subinterval $[x_{j-1}, x_j]$, $M_j = \\sup_{x \\in [x_{j-1}, x_j]} f(x)$ and $m_j = \\inf_{x \\in [x_{j-1}, x_j]} f(x)$.\nTherefore, we conclude:\n\u2022 For each $j \\in \\{1, \\dots, n\\}$, $M_j = f(x_j)$ and $m_j = f(x_{j-1})$ [l2].", "dependencies": ["def_3", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b : \u211d) (f : \u211d \u2192 \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n  (h_le : a \u2264 b)\n  (h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n  (h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n  (def_3 : MonotoneOn f (Set.Icc a b)) :\n  \u2200 j \u2208 Finset.Ico 1 (n + 1), \n    (sSup (f '' Set.Icc (x (j-1)) (x j)) = f (x j)) \u2227 \n    (sInf (f '' Set.Icc (x (j-1)) (x j)) = f (x (j-1))) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b : \u211d) (f : \u211d \u2192 \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n  (h_le : a \u2264 b)\n  (h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n  (h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n  (def_3 : MonotoneOn f (Set.Icc a b)) :\n  \u2200 j \u2208 Finset.Ico 1 (n + 1), \n    (sSup (f '' Set.Icc (x (j-1)) (x j)) = f (x j)) \u2227 \n    (sInf (f '' Set.Icc (x (j-1)) (x j)) = f (x (j-1))) := by\n  have h_main : \u2200 j \u2208 Finset.Ico 1 (n + 1), (sSup (f '' Set.Icc (x (j-1)) (x j)) = f (x j)) \u2227 (sInf (f '' Set.Icc (x (j-1)) (x j)) = f (x (j-1))) := by\n    intro j hj\n    have h\u2081 : 1 \u2264 j := Finset.mem_Ico.mp hj |>.1\n    have h\u2082 : j \u2264 n := by\n      have h\u2083 : j < n + 1 := Finset.mem_Ico.mp hj |>.2\n      linarith\n    have h\u2083 : (j : \u2115) - 1 < j := by\n      have h\u2084 : 0 < j := by linarith\n      omega\n    have h\u2084 : (j : \u2115) - 1 \u2264 n := by\n      have h\u2085 : j \u2264 n := h\u2082\n      have h\u2086 : (j : \u2115) - 1 \u2264 j := by\n        have h\u2087 : 0 < j := by linarith\n        omega\n      omega\n    have h\u2085 : x ((j : \u2115) - 1) < x j := h_strict ((j : \u2115) - 1) j (by\n      have h\u2086 : 0 < j := by linarith\n      omega) (by\n        omega)\n    have h\u2086 : a \u2264 x ((j : \u2115) - 1) := by\n      have h\u2087 : a = x 0 := h_partition.1\n      have h\u2088 : x 0 \u2264 x ((j : \u2115) - 1) := by\n        have h\u2089 : 0 \u2264 (j : \u2115) - 1 := by\n          have h\u2081\u2080 : 1 \u2264 j := h\u2081\n          omega\n        have h\u2081\u2080 : (j : \u2115) - 1 \u2264 n := h\u2084\n        have h\u2081\u2081 : x 0 \u2264 x ((j : \u2115) - 1) := h_partition.2.2 0 ((j : \u2115) - 1) (by omega) (by omega)\n        exact h\u2081\u2081\n      linarith\n    have h\u2087 : x j \u2264 b := by\n      have h\u2088 : x j \u2264 x n := h_partition.2.2 j n (by omega) (by omega)\n      have h\u2089 : b = x n := h_partition.2.1\n      linarith\n    have h\u2088 : Set.Icc (x ((j : \u2115) - 1)) (x j) \u2286 Set.Icc a b := by\n      intro y hy\n      constructor <;>\n      (try norm_num at hy \u22a2) <;>\n      (try constructor <;> linarith [hy.1, hy.2]) <;>\n      (try\n        {\n          have h\u2089 : a \u2264 x ((j : \u2115) - 1) := h\u2086\n          have h\u2081\u2080 : x j \u2264 b := h\u2087\n          linarith [hy.1, hy.2]\n        })\n    have h\u2089 : MonotoneOn f (Set.Icc (x ((j : \u2115) - 1)) (x j)) := by\n      apply MonotoneOn.mono def_3\n      exact h\u2088\n    have h\u2081\u2080 : IsGreatest (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) (f (x j)) := by\n      constructor\n      \u00b7 -- Show that f(x_j) is in the set\n        have h\u2081\u2081 : x j \u2208 Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n          constructor <;>\n          (try norm_num) <;>\n          (try linarith [h\u2085])\n        have h\u2081\u2082 : f (x j) \u2208 f '' Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n          exact Set.mem_image_of_mem f h\u2081\u2081\n        exact h\u2081\u2082\n      \u00b7 -- Show that f(x_j) is an upper bound\n        intro y hy\n        rcases hy with \u27e8z, hz, rfl\u27e9\n        have h\u2081\u2083 : z \u2208 Set.Icc (x ((j : \u2115) - 1)) (x j) := hz\n        have h\u2081\u2084 : x ((j : \u2115) - 1) \u2264 z := h\u2081\u2083.1\n        have h\u2081\u2085 : z \u2264 x j := h\u2081\u2083.2\n        have h\u2081\u2086 : z \u2208 Set.Icc a b := by\n          constructor <;>\n          (try norm_num at h\u2081\u2083 \u22a2) <;>\n          (try linarith [h\u2086, h\u2087, h\u2081\u2083.1, h\u2081\u2083.2])\n        have h\u2081\u2087 : x j \u2208 Set.Icc a b := by\n          constructor <;>\n          (try norm_num) <;>\n          (try linarith [h\u2086, h\u2087])\n        have h\u2081\u2088 : f z \u2264 f (x j) := by\n          apply def_3\n          <;>\n          (try simp_all [Set.Icc, le_of_lt]) <;>\n          (try constructor <;> linarith) <;>\n          (try nlinarith)\n        exact h\u2081\u2088\n    have h\u2081\u2081 : sSup (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) = f (x j) := by\n      have h\u2081\u2082 : IsGreatest (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) (f (x j)) := h\u2081\u2080\n      have h\u2081\u2083 : sSup (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) = f (x j) := by\n        apply le_antisymm\n        \u00b7 -- sSup \u2264 f(x_j)\n          apply csSup_le (Set.nonempty_of_mem h\u2081\u2080.1)\n          intro y hy\n          exact h\u2081\u2082.2 hy\n        \u00b7 -- f(x_j) \u2264 sSup\n          apply le_csSup\n          \u00b7 -- Bounded above\n            exact \u27e8f (x j), by\n              intro y hy\n              exact h\u2081\u2082.2 hy\u27e9\n          \u00b7 -- f(x_j) is in the set\n            exact h\u2081\u2080.1\n      exact h\u2081\u2083\n    have h\u2081\u2082 : IsLeast (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) (f (x ((j : \u2115) - 1))) := by\n      constructor\n      \u00b7 -- Show that f(x_{j-1}) is in the set\n        have h\u2081\u2083 : x ((j : \u2115) - 1) \u2208 Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n          constructor <;>\n          (try norm_num) <;>\n          (try linarith [h\u2085])\n        have h\u2081\u2084 : f (x ((j : \u2115) - 1)) \u2208 f '' Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n          exact Set.mem_image_of_mem f h\u2081\u2083\n        exact h\u2081\u2084\n      \u00b7 -- Show that f(x_{j-1}) is a lower bound\n        intro y hy\n        rcases hy with \u27e8z, hz, rfl\u27e9\n        have h\u2081\u2085 : z \u2208 Set.Icc (x ((j : \u2115) - 1)) (x j) := hz\n        have h\u2081\u2086 : x ((j : \u2115) - 1) \u2264 z := h\u2081\u2085.1\n        have h\u2081\u2087 : z \u2264 x j := h\u2081\u2085.2\n        have h\u2081\u2088 : z \u2208 Set.Icc a b := by\n          constructor <;>\n          (try norm_num at h\u2081\u2085 \u22a2) <;>\n          (try linarith [h\u2086, h\u2087, h\u2081\u2085.1, h\u2081\u2085.2])\n        have h\u2081\u2089 : x ((j : \u2115) - 1) \u2208 Set.Icc a b := by\n          constructor <;>\n          (try norm_num) <;>\n          (try linarith [h\u2086, h\u2087])\n        have h\u2082\u2080 : f (x ((j : \u2115) - 1)) \u2264 f z := by\n          apply def_3\n          <;>\n          (try simp_all [Set.Icc, le_of_lt]) <;>\n          (try constructor <;> linarith) <;>\n          (try nlinarith)\n        exact h\u2082\u2080\n    have h\u2081\u2083 : sInf (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) = f (x ((j : \u2115) - 1)) := by\n      have h\u2081\u2084 : IsLeast (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) (f (x ((j : \u2115) - 1))) := h\u2081\u2082\n      have h\u2081\u2085 : sInf (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) = f (x ((j : \u2115) - 1)) := by\n        apply le_antisymm\n        \u00b7 -- sInf \u2264 f(x_{j-1})\n          apply csInf_le (by\n            -- Show that the set is bounded below\n            have h\u2081\u2086 : BddBelow (f '' Set.Icc (x ((j : \u2115) - 1)) (x j)) := by\n              use f (x ((j : \u2115) - 1))\n              intro y hy\n              have h\u2081\u2087 : f (x ((j : \u2115) - 1)) \u2264 y := by\n                have h\u2081\u2088 : y \u2208 f '' Set.Icc (x ((j : \u2115) - 1)) (x j) := hy\n                have h\u2081\u2089 : f (x ((j : \u2115) - 1)) \u2264 y := h\u2081\u2084.2 h\u2081\u2088\n                exact h\u2081\u2089\n              linarith\n            exact h\u2081\u2086)\n          exact h\u2081\u2084.1\n        \u00b7 -- f(x_{j-1}) \u2264 sInf\n          apply le_csInf (by\n            -- Show that the set is nonempty\n            have h\u2081\u2086 : (f (x ((j : \u2115) - 1))) \u2208 f '' Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n              have h\u2081\u2087 : x ((j : \u2115) - 1) \u2208 Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n                constructor <;>\n                (try norm_num) <;>\n                (try linarith [h\u2085])\n              have h\u2081\u2088 : f (x ((j : \u2115) - 1)) \u2208 f '' Set.Icc (x ((j : \u2115) - 1)) (x j) := by\n                exact Set.mem_image_of_mem f h\u2081\u2087\n              exact h\u2081\u2088\n            exact Set.nonempty_of_mem h\u2081\u2086)\n          intro y hy\n          have h\u2081\u2087 : f (x ((j : \u2115) - 1)) \u2264 y := h\u2081\u2084.2 hy\n          linarith\n      exact h\u2081\u2085\n    constructor\n    \u00b7 -- sSup part\n      exact h\u2081\u2081\n    \u00b7 -- sInf part\n      have h\u2081\u2084 : (j : \u2115) - 1 = j - 1 := by\n        have h\u2081\u2085 : 1 \u2264 j := h\u2081\n        omega\n      rw [h\u2081\u2084] at h\u2081\u2083\n      exact h\u2081\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The monotonicity condition is correctly captured using MonotoneOn, which is the standard Lean representation for nondecreasing functions on an interval.", "The partition definition is properly formalized with both the boundary conditions (a = x 0, b = x n) and the ordering properties. The additional strict inequality condition h_strict provides extra precision that's mathematically consistent.", "The supremum and infimum definitions are correctly represented using sSup and sInf applied to the image of f over the interval Set.Icc (x (j-1)) (x j), which precisely captures the mathematical meaning.", "The main conclusion is accurately formalized. The range 'j \u2208 Finset.Ico 1 (n + 1)' correctly represents j \u2208 {1, ..., n}, and both equality statements for M_j and m_j are properly captured with the supremum equaling f(x_j) and infimum equaling f(x_{j-1})."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Hence, $S(P)-s(P)=\\sum_{j=1}^n(f(x_j)-f(x_{j-1})) (x_j-x_{j-1})$.", "statement": "We assume:\n\u2022 For a partition $P=\\{x_0, \\dots, x_n\\}$ of $[a,b]$ [def_2], the supremum and infimum on each subinterval $[x_{j-1}, x_j]$ are $M_j=f(x_j)$ and $m_j=f(x_{j-1})$ [l2].\n\u2022 The upper sum is $S(P) = \\sum_{j=1}^n M_j (x_j - x_{j-1})$ and the lower sum is $s(P) = \\sum_{j=1}^n m_j (x_j - x_{j-1})$.\nTherefore, we conclude:\n\u2022 $S(P)-s(P) = \\sum_{j=1}^n (f(x_j) - f(x_{j-1})) (x_j - x_{j-1})$ [l3].", "dependencies": ["l2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b : \u211d) (f : \u211d \u2192 \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n  (h_le : a \u2264 b)\n  (h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n  (h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (l2 : \u2200 j \u2208 Finset.Ico 1 (n + 1), \n    (sSup (f '' Set.Icc (x (j-1)) (x j)) = f (x j)) \u2227 \n    (sInf (f '' Set.Icc (x (j-1)) (x j)) = f (x (j-1)))) :\n  let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n  let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n  S_P - s_P = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j-1))) * (x j - x (j-1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b : \u211d) (f : \u211d \u2192 \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n  (h_le : a \u2264 b)\n  (h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n  (h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (l2 : \u2200 j \u2208 Finset.Ico 1 (n + 1), \n    (sSup (f '' Set.Icc (x (j-1)) (x j)) = f (x j)) \u2227 \n    (sInf (f '' Set.Icc (x (j-1)) (x j)) = f (x (j-1)))) :\n  let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n  let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n  S_P - s_P = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j-1))) * (x j - x (j-1)) := by\n  intro S_P s_P\n  have h_main : S_P - s_P = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j-1))) * (x j - x (j-1)) := by\n    calc\n      S_P - s_P = (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - \u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) := by rfl\n      _ = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) * (x j - x (j - 1)) - f (x (j - 1)) * (x j - x (j - 1))) := by\n        rw [Finset.sum_sub_distrib]\n      _ = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1)) := by\n        apply Finset.sum_congr rfl\n        intro j hj\n        have h\u2081 : f (x j) * (x j - x (j - 1)) - f (x (j - 1)) * (x j - x (j - 1)) = (f (x j) - f (x (j - 1))) * (x j - x (j - 1)) := by\n          ring\n        rw [h\u2081]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all the mathematical content from the natural language. The partition definition, supremum/infimum conditions, upper/lower sum definitions, and the main conclusion are all correctly translated. The additional conditions (h_le, h_strict, h_mono) are mathematically reasonable constraints that don't contradict the natural language but provide necessary context for the theorem. The indexing and summation ranges are properly handled using Lean's Finset.Ico notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since $0<x_j-x_{j-1}\\le \\|P\\|$ and $f(x_j)-f(x_{j-1})\\ge0$, $S(P)-s(P)\\le  \\|P\\| \\sum_{j=1}^n(f(x_j)-f(x_{j-1})) =\\|P\\|(f(b)-f(a))$.", "statement": "We assume:\n\u2022 $f$ is nondecreasing on $[a,b]$ [def_3].\n\u2022 $P=\\{x_0, \\dots, x_n\\}$ is a partition of $[a,b]$ with norm $\\|P\\|$ [def_2].\n\u2022 $S(P)-s(P) = \\sum_{j=1}^n (f(x_j) - f(x_{j-1})) (x_j - x_{j-1})$ [l3].\nTherefore, we conclude:\n\u2022 $S(P)-s(P) \\le \\|P\\| (f(b) - f(a))$ [l4].", "dependencies": ["l3", "def_3", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n  (h_le : a \u2264 b)\n  (h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n  (h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (l3 : \u2203 (S_P s_P : \u211d), \n    S_P = \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)) \u2227\n    s_P = \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)) \u2227\n    S_P - s_P = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j-1))) * (x j - x (j-1))) :\n  let partition_norm := sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)\n  let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n  let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n  S_P - s_P \u2264 partition_norm * (f b - f a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nhave h\u2081\u2081 : x (j.val + 1) - x j.val \u2264 b - a := by\n  have h\u2081\u2082 : x (j.val + 1) \u2264 b := by ...\n  have h\u2081\u2083 : a \u2264 x j.val := by ...\n  linarith", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 4, "column": 0, "endLine": 4, "endColumn": 4, "data": "unexpected token 'have'; expected command"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The monotonicity condition is correctly formalized using MonotoneOn for the closed interval", "The partition definition properly captures all necessary conditions including endpoints, ordering, and norm definition", "The formula S(P) - s(P) is correctly stated in the premise and used in the conclusion", "The main inequality conclusion is accurately formalized with correct variable correspondence", "The upper and lower sum definitions are standard and mathematically correct, providing necessary detail for the formalization", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) (n : \u2115) (x : \u2115 \u2192 \u211d)\n  (h_le : a \u2264 b)\n  (h_partition : a = x 0 \u2227 b = x n \u2227 \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)\n  (h_strict : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (l3 : \u2203 (S_P s_P : \u211d), \n    S_P = \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)) \u2227\n    s_P = \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)) \u2227\n    S_P - s_P = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j-1))) * (x j - x (j-1))) :\n  let partition_norm := sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)\n  let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n  let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n  S_P - s_P \u2264 partition_norm * (f b - f a) := by\n  dsimp only\n  have h_main : (\u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1))) \u2264 (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f b - f a) := by\n    have h\u2081 : \u2200 (j : \u2115), j \u2208 Finset.Ico 1 (n + 1) \u2192 (f (x j) - f (x (j - 1))) * (x j - x (j - 1)) \u2264 (f (x j) - f (x (j - 1))) * (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) := by\n      intro j hj\n      have h\u2082 : j \u2208 Finset.Ico 1 (n + 1) := hj\n      have h\u2083 : 1 \u2264 j \u2227 j \u2264 n := by\n        simp [Finset.mem_Ico] at h\u2082 \u22a2\n        <;> omega\n      have h\u2084 : j - 1 < j := by\n        have h\u2085 : 1 \u2264 j := h\u2083.1\n        omega\n      have h\u2085 : j \u2264 n := h\u2083.2\n      have h\u2086 : x (j - 1) \u2264 x j := by\n        have h\u2087 : j - 1 \u2264 j := by omega\n        have h\u2088 : j \u2264 n := h\u2083.2\n        have h\u2089 : x (j - 1) \u2264 x j := h_partition.2.2 (j - 1) j (by omega) (by omega)\n        exact h\u2089\n      have h\u2087 : x j - x (j - 1) \u2265 0 := by linarith\n      have h\u2088 : (x j - x (j - 1)) \u2264 sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ) := by\n        -- Prove that each interval length is less than or equal to the supremum of interval lengths\n        by_cases hn : n = 0\n        \u00b7 -- Case n = 0\n          subst hn\n          simp_all [Finset.mem_Ico]\n          <;> omega\n        \u00b7 -- Case n \u2260 0\n          have h\u2089 : 0 < n := Nat.pos_of_ne_zero hn\n          have h\u2081\u2080 : j \u2264 n := h\u2083.2\n          have h\u2081\u2081 : 1 \u2264 j := h\u2083.1\n          have h\u2081\u2082 : j - 1 < n := by\n            omega\n          -- Use the fact that x_j - x_{j-1} is in the set of interval lengths\n          have h\u2081\u2083 : \u2203 (k : Fin n), (k : \u2115) = j - 1 := by\n            use \u27e8j - 1, by\n              have h\u2081\u2084 : j - 1 < n := by omega\n              omega\u27e9\n            <;> simp [Fin.val_eq_val]\n            <;> omega\n          obtain \u27e8k, hk\u27e9 := h\u2081\u2083\n          have h\u2081\u2084 : (x (k.val + 1) - x k.val : \u211d) = x j - x (j - 1) := by\n            have h\u2081\u2085 : (k : \u2115) = j - 1 := by simp_all [Fin.val_eq_val]\n            have h\u2081\u2086 : (k.val : \u2115) = j - 1 := by\n              simp_all [Fin.val_eq_val]\n            have h\u2081\u2087 : (x (k.val + 1) - x k.val : \u211d) = x ( (j - 1 : \u2115) + 1 ) - x (j - 1 : \u2115) := by\n              simp_all [Fin.val_eq_val]\n              <;> ring_nf\n              <;> norm_cast\n              <;> simp_all [Fin.val_eq_val]\n              <;> omega\n            have h\u2081\u2088 : (x ( (j - 1 : \u2115) + 1 ) - x (j - 1 : \u2115) : \u211d) = x j - x (j - 1) := by\n              have h\u2081\u2089 : (j - 1 : \u2115) + 1 = j := by\n                have h\u2082\u2080 : 1 \u2264 j := by omega\n                omega\n              rw [h\u2081\u2089]\n              <;> norm_num\n              <;> simp_all [Fin.val_eq_val]\n              <;> ring_nf\n              <;> norm_cast\n              <;> simp_all [Fin.val_eq_val]\n              <;> omega\n            linarith\n          have h\u2081\u2085 : (x j - x (j - 1) : \u211d) \u2208 ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ) := by\n            refine' \u27e8k, _, _\u27e9\n            \u00b7 simp [Set.mem_univ]\n            \u00b7 simp_all [Fin.val_eq_val]\n              <;> ring_nf at *\n              <;> simp_all [Fin.val_eq_val]\n              <;> norm_num at *\n              <;> linarith\n          have h\u2081\u2086 : (x j - x (j - 1) : \u211d) \u2264 sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ) := by\n            apply le_csSup\n            \u00b7 -- Prove that the set is bounded above\n              use x n - x 0\n              intro y hy\n              rcases hy with \u27e8j, _, rfl\u27e9\n              have h\u2081\u2087 : (x (j.val + 1) - x j.val : \u211d) \u2264 x n - x 0 := by\n                have h\u2081\u2088 : (j.val : \u2115) < n := by\n                  have h\u2081\u2089 : (j : \u2115) < n := by\n                    simpa [Fin.val_eq_val] using j.prop\n                  omega\n                have h\u2082\u2080 : (x 0 : \u211d) \u2264 x j.val := by\n                  have h\u2082\u2081 : (0 : \u2115) \u2264 j.val := by\n                    have h\u2082\u2082 : (0 : \u2115) \u2264 (j : \u2115) := by\n                      simpa [Fin.val_eq_val] using Nat.zero_le _\n                    omega\n                  have h\u2082\u2083 : (x 0 : \u211d) \u2264 x j.val := by\n                    have h\u2082\u2084 : (0 : \u2115) \u2264 j.val := by omega\n                    have h\u2082\u2085 : j.val \u2264 n := by\n                      have h\u2082\u2086 : (j : \u2115) < n := by\n                        simpa [Fin.val_eq_val] using j.prop\n                      omega\n                    have h\u2082\u2086 : (x 0 : \u211d) \u2264 x j.val := by\n                      have h\u2082\u2087 : (0 : \u2115) \u2264 j.val := by omega\n                      have h\u2082\u2088 : j.val \u2264 n := by omega\n                      exact by\n                        have h\u2082\u2089 := h_partition.2.2 0 j.val (by omega) (by omega)\n                        exact_mod_cast h\u2082\u2089\n                    exact h\u2082\u2086\n                  exact h\u2082\u2083\n                have h\u2082\u2081 : (x (j.val + 1) : \u211d) \u2264 x n := by\n                  have h\u2082\u2082 : (j.val + 1 : \u2115) \u2264 n := by\n                    have h\u2082\u2083 : (j.val : \u2115) < n := by\n                      have h\u2082\u2084 : (j : \u2115) < n := by\n                        simpa [Fin.val_eq_val] using j.prop\n                      omega\n                    omega\n                  have h\u2082\u2083 : (x (j.val + 1) : \u211d) \u2264 x n := by\n                    have h\u2082\u2084 : (j.val + 1 : \u2115) \u2264 n := by omega\n                    have h\u2082\u2085 : (x (j.val + 1) : \u211d) \u2264 x n := by\n                      have h\u2082\u2086 := h_partition.2.2 (j.val + 1) n (by omega) (by omega)\n                      exact_mod_cast h\u2082\u2086\n                    exact h\u2082\u2085\n                  exact h\u2082\u2083\n                linarith\n              linarith\n            \u00b7 -- Prove that the element is in the set\n              exact h\u2081\u2085\n          exact h\u2081\u2086\n      have h\u2089 : f (x (j - 1)) \u2264 f (x j) := by\n        -- Prove that f is non-decreasing\n        have h\u2081\u2080 : x (j - 1) \u2264 x j := h\u2086\n        have h\u2081\u2081 : x (j - 1) \u2208 Set.Icc a b := by\n          have h\u2081\u2082 : a = x 0 := h_partition.1\n          have h\u2081\u2083 : b = x n := h_partition.2.1\n          have h\u2081\u2084 : x 0 \u2264 x (j - 1) := by\n            have h\u2081\u2085 : 0 \u2264 j - 1 := by\n              have h\u2081\u2086 : 1 \u2264 j := h\u2083.1\n              omega\n            have h\u2081\u2086 : x 0 \u2264 x (j - 1) := h_partition.2.2 0 (j - 1) (by omega) (by\n              have h\u2081\u2087 : j - 1 \u2264 n := by\n                have h\u2081\u2088 : j \u2264 n := h\u2083.2\n                omega\n              omega)\n            exact h\u2081\u2086\n          have h\u2081\u2085 : x (j - 1) \u2264 x n := by\n            have h\u2081\u2086 : j - 1 \u2264 n := by\n              have h\u2081\u2087 : j \u2264 n := h\u2083.2\n              omega\n            have h\u2081\u2087 : x (j - 1) \u2264 x n := h_partition.2.2 (j - 1) n (by omega) (by omega)\n            exact h\u2081\u2087\n          have h\u2081\u2086 : a \u2264 x (j - 1) := by\n            linarith [h_partition.1]\n          have h\u2081\u2087 : x (j - 1) \u2264 b := by\n            linarith [h_partition.2.1]\n          exact \u27e8h\u2081\u2086, h\u2081\u2087\u27e9\n        have h\u2081\u2082 : x j \u2208 Set.Icc a b := by\n          have h\u2081\u2083 : a = x 0 := h_partition.1\n          have h\u2081\u2084 : b = x n := h_partition.2.1\n          have h\u2081\u2085 : x 0 \u2264 x j := by\n            have h\u2081\u2086 : 0 \u2264 j := by\n              have h\u2081\u2087 : 1 \u2264 j := h\u2083.1\n              omega\n            have h\u2081\u2087 : x 0 \u2264 x j := h_partition.2.2 0 j (by omega) (by omega)\n            exact h\u2081\u2087\n          have h\u2081\u2086 : x j \u2264 x n := by\n            have h\u2081\u2087 : j \u2264 n := h\u2083.2\n            have h\u2081\u2088 : x j \u2264 x n := h_partition.2.2 j n (by omega) (by omega)\n            exact h\u2081\u2088\n          have h\u2081\u2087 : a \u2264 x j := by\n            linarith [h_partition.1]\n          have h\u2081\u2088 : x j \u2264 b := by\n            linarith [h_partition.2.1]\n          exact \u27e8h\u2081\u2087, h\u2081\u2088\u27e9\n        have h\u2081\u2083 : f (x (j - 1)) \u2264 f (x j) := by\n          apply h_mono\n          <;> simp_all [Set.Icc]\n          <;>\n          (try omega) <;>\n          (try linarith) <;>\n          (try nlinarith) <;>\n          (try assumption)\n          <;>\n          (try\n            {\n              cases' le_total (x (j - 1)) (x j) with h h <;>\n              simp_all [h]\n              <;>\n              nlinarith\n            })\n        exact h\u2081\u2083\n      have h\u2081\u2080 : f (x j) - f (x (j - 1)) \u2265 0 := by linarith\n      -- Use the fact that the product of two non-negative numbers is non-negative\n      have h\u2081\u2081 : (f (x j) - f (x (j - 1))) * (x j - x (j - 1)) \u2264 (f (x j) - f (x (j - 1))) * (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) := by\n        have h\u2081\u2082 : (x j - x (j - 1)) \u2264 sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ) := h\u2088\n        have h\u2081\u2083 : 0 \u2264 (f (x j) - f (x (j - 1))) := by linarith\n        nlinarith\n      exact h\u2081\u2081\n    -- Sum the inequalities over all j in Finset.Ico 1 (n + 1)\n    have h\u2082 : (\u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1))) \u2264 \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) := by\n      apply Finset.sum_le_sum\n      intro j hj\n      exact h\u2081 j hj\n    -- Factor out the supremum from the sum\n    have h\u2083 : \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) = (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) := by\n      have h\u2084 : \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) = \u2211 j in Finset.Ico 1 (n + 1), (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f (x j) - f (x (j - 1))) := by\n        apply Finset.sum_congr rfl\n        intro j hj\n        ring\n      rw [h\u2084]\n      have h\u2085 : \u2211 j in Finset.Ico 1 (n + 1), (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f (x j) - f (x (j - 1))) = (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) := by\n        rw [Finset.mul_sum]\n      rw [h\u2085]\n    -- Use the fact that the sum of differences telescopes to f(b) - f(a)\n    have h\u2084 : \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) = f b - f a := by\n      have h\u2085 : \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) = f (x n) - f (x 0) := by\n        -- Prove that the sum telescopes\n        have h\u2086 : \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) := rfl\n        rw [h\u2086]\n        have h\u2087 : \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) = f (x n) - f (x 0) := by\n          -- Use induction on n to prove the telescoping sum\n          have h\u2088 : \u2200 (n : \u2115), \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) = f (x n) - f (x 0) := by\n            intro n\n            induction n with\n            | zero =>\n              simp [Finset.sum_range_zero]\n            | succ n ih =>\n              rw [Finset.sum_Ico_succ_top (by omega : 1 \u2264 n.succ)]\n              rw [ih]\n              <;> simp [Nat.cast_add, Nat.cast_one, add_assoc]\n              <;> ring_nf\n              <;> norm_num\n              <;> linarith\n          exact h\u2088 n\n        exact h\u2087\n      have h\u2086 : f (x n) - f (x 0) = f b - f a := by\n        have h\u2087 : a = x 0 := h_partition.1\n        have h\u2088 : b = x n := h_partition.2.1\n        rw [h\u2087, h\u2088]\n      linarith\n    -- Combine all the results to get the final inequality\n    have h\u2085 : (\u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1))) \u2264 (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f b - f a) := by\n      calc\n        (\u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1))) \u2264 \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) := h\u2082\n        _ = (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) := by rw [h\u2083]\n        _ = (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f b - f a) := by rw [h\u2084]\n    exact h\u2085\n  \n  -- Obtain the sum expressions from l3\n  obtain \u27e8S_P, s_P, hS_P, hs_P, h_diff\u27e9 := l3\n  have h\u2082 : (\u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1))) \u2264 (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f b - f a) := h_main\n  have h\u2083 : S_P - s_P = \u2211 j in Finset.Ico 1 (n + 1), (f (x j) - f (x (j - 1))) * (x j - x (j - 1)) := by\n    linarith\n  have h\u2084 : S_P - s_P \u2264 (sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)) * (f b - f a) := by\n    linarith\n  simpa [hS_P, hs_P] using h\u2084"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, $S(P)-s(P)<\\epsilon\\mbox{\\quad if \\quad} \\|P\\|(f(b)-f(a))<\\epsilon,", "statement": "We assume:\n\u2022 $f$ is nondecreasing on $[a,b]$ [def_3].\n\u2022 For any partition $P$, $S(P)-s(P) \\le \\|P\\| (f(b) - f(a))$ [l4].\nTherefore, we conclude:\n\u2022 For any $\\epsilon > 0$, there exists a partition $P$ of $[a,b]$ for which $S(P)-s(P) < \\epsilon$ [l5].", "dependencies": ["l4", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (l4 : \u2200 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2192\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    let partition_norm := sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)\n    S_P - s_P \u2264 partition_norm * (f b - f a)) :\n  \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    S_P - s_P < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (l4 : \u2200 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2192\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    let partition_norm := sSup ((fun j : Fin n => x (j.val + 1) - x j.val) '' Set.univ)\n    S_P - s_P \u2264 partition_norm * (f b - f a)) :\n  \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    S_P - s_P < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)); S_P - s_P < \u03b5) := by\n    intro \u03b5 h\u03b5\n    by_cases h : a = b\n    \u00b7 -- Case: a = b\n      use 0, fun _ => a\n      constructor\n      \u00b7 -- Prove a = x 0\n        simp\n      constructor\n      \u00b7 -- Prove b = x n\n        simp [h]\n      constructor\n      \u00b7 -- Prove the non-decreasing condition\n        intro i j hij hjn\n        simp_all\n        <;> omega\n      constructor\n      \u00b7 -- Prove the strictly increasing condition\n        intro i j hij hjn\n        exfalso\n        omega\n      \u00b7 -- Prove S_P - s_P < \u03b5\n        dsimp\n        simp [Finset.sum_range_zero]\n        <;> linarith\n    \u00b7 -- Case: a < b\n      have h\u2081 : a < b := by\n        contrapose! h\n        linarith\n      by_cases h\u2082 : f b = f a\n      \u00b7 -- Subcase: f(b) = f(a)\n        use 1, fun j => if j = 0 then a else b\n        constructor\n        \u00b7 -- Prove a = x 0\n          simp\n        constructor\n        \u00b7 -- Prove b = x n\n          simp\n          <;> aesop\n        constructor\n        \u00b7 -- Prove the non-decreasing condition\n          intro i j hij hjn\n          by_cases hi : i = 0 <;> by_cases hj : j = 0 <;> simp_all [hi, hj] <;>\n            (try omega) <;>\n            (try linarith) <;>\n            (try\n              {\n                cases j <;> simp_all [Nat.succ_eq_add_one] <;>\n                  (try omega) <;>\n                  (try linarith)\n              }) <;>\n            (try\n              {\n                cases i <;> simp_all [Nat.succ_eq_add_one] <;>\n                  (try omega) <;>\n                  (try linarith)\n              })\n        constructor\n        \u00b7 -- Prove the strictly increasing condition\n          intro i j hij hjn\n          by_cases hi : i = 0 <;> by_cases hj : j = 0 <;> simp_all [hi, hj] <;>\n            (try omega) <;>\n            (try linarith) <;>\n            (try\n              {\n                cases j <;> simp_all [Nat.succ_eq_add_one] <;>\n                  (try omega) <;>\n                  (try linarith)\n              }) <;>\n            (try\n              {\n                cases i <;> simp_all [Nat.succ_eq_add_one] <;>\n                  (try omega) <;>\n                  (try linarith)\n              })\n        \u00b7 -- Prove S_P - s_P < \u03b5\n          dsimp\n          simp [Finset.sum_Ico_succ_top]\n          <;> norm_num <;>\n          (try simp_all [h\u2082]) <;>\n          (try ring_nf) <;>\n          (try linarith)\n      \u00b7 -- Subcase: f(b) > f(a)\n        have h\u2083 : f b > f a := by\n          by_contra h\u2083\n          have h\u2084 : f b \u2264 f a := by linarith\n          have h\u2085 : f b = f a := by\n            have h\u2085\u2081 : a \u2208 Set.Icc a b := by exact \u27e8by linarith, by linarith\u27e9\n            have h\u2085\u2082 : b \u2208 Set.Icc a b := by exact \u27e8by linarith, by linarith\u27e9\n            have h\u2085\u2083 : f a \u2264 f b := by\n              apply h_mono\n              <;> simp_all [Set.Icc, le_of_lt]\n              <;> linarith\n            linarith\n          contradiction\n        -- Use the Archimedean property to find n\n        have h\u2084 : \u2203 (n : \u2115), (n : \u211d) > (b - a) * (f b - f a) / \u03b5 := by\n          obtain \u27e8n, hn\u27e9 := exists_nat_gt ((b - a) * (f b - f a) / \u03b5)\n          refine' \u27e8n, _\u27e9\n          exact mod_cast hn\n        obtain \u27e8n, hn\u27e9 := h\u2084\n        have h\u2085 : (n : \u211d) > 0 := by\n          have h\u2085\u2081 : (b - a : \u211d) > 0 := by linarith\n          have h\u2085\u2082 : (f b - f a : \u211d) > 0 := by linarith\n          have h\u2085\u2083 : (b - a : \u211d) * (f b - f a) / \u03b5 > 0 := by\n            have h\u2085\u2084 : (\u03b5 : \u211d) > 0 := by exact_mod_cast h\u03b5\n            have h\u2085\u2085 : (b - a : \u211d) > 0 := by linarith\n            have h\u2085\u2086 : (f b - f a : \u211d) > 0 := by linarith\n            positivity\n          have h\u2085\u2087 : (n : \u211d) > (b - a) * (f b - f a) / \u03b5 := hn\n          linarith\n        have h\u2086 : (n : \u2115) > 0 := by\n          by_contra h\u2086\n          have h\u2086\u2081 : n = 0 := by\n            omega\n          have h\u2086\u2082 : (n : \u211d) = 0 := by simp [h\u2086\u2081]\n          have h\u2086\u2083 : (n : \u211d) > (b - a) * (f b - f a) / \u03b5 := hn\n          have h\u2086\u2084 : (b - a : \u211d) > 0 := by linarith\n          have h\u2086\u2085 : (f b - f a : \u211d) > 0 := by linarith\n          have h\u2086\u2086 : (b - a : \u211d) * (f b - f a) / \u03b5 > 0 := by\n            have h\u2086\u2087 : (\u03b5 : \u211d) > 0 := by exact_mod_cast h\u03b5\n            positivity\n          linarith\n        -- Define the partition\n        use n, fun j => a + (j : \u211d) * (b - a) / n\n        constructor\n        \u00b7 -- Prove a = x 0\n          simp [h\u2086]\n          <;> field_simp [h\u2086]\n          <;> ring_nf\n          <;> linarith\n        constructor\n        \u00b7 -- Prove b = x n\n          have h\u2087 : (n : \u211d) \u2260 0 := by positivity\n          field_simp [h\u2087]\n          <;> ring_nf\n          <;> field_simp [h\u2087]\n          <;> linarith\n        constructor\n        \u00b7 -- Prove the non-decreasing condition\n          intro i j hij hjn\n          have h\u2088 : (i : \u211d) \u2264 (j : \u211d) := by exact_mod_cast hij\n          have h\u2089 : (j : \u211d) \u2264 (n : \u211d) := by exact_mod_cast hjn\n          have h\u2081\u2080 : (a + (i : \u211d) * (b - a) / n : \u211d) \u2264 (a + (j : \u211d) * (b - a) / n : \u211d) := by\n            have h\u2081\u2081 : (b - a : \u211d) \u2265 0 := by linarith\n            have h\u2081\u2082 : (i : \u211d) * (b - a) \u2264 (j : \u211d) * (b - a) := by\n              nlinarith\n            have h\u2081\u2083 : (i : \u211d) * (b - a) / n \u2264 (j : \u211d) * (b - a) / n := by\n              have h\u2081\u2084 : (n : \u211d) > 0 := by positivity\n              have h\u2081\u2085 : (i : \u211d) * (b - a) \u2264 (j : \u211d) * (b - a) := by nlinarith\n              have h\u2081\u2086 : (i : \u211d) * (b - a) / n \u2264 (j : \u211d) * (b - a) / n := by\n                rw [div_le_div_iff (by positivity) (by positivity)]\n                nlinarith\n              exact h\u2081\u2086\n            linarith\n          exact_mod_cast h\u2081\u2080\n        constructor\n        \u00b7 -- Prove the strictly increasing condition\n          intro i j hij hjn\n          have h\u2088 : (i : \u211d) < (j : \u211d) := by exact_mod_cast hij\n          have h\u2089 : (j : \u211d) \u2264 (n : \u211d) := by exact_mod_cast hjn\n          have h\u2081\u2080 : (a + (i : \u211d) * (b - a) / n : \u211d) < (a + (j : \u211d) * (b - a) / n : \u211d) := by\n            have h\u2081\u2081 : (b - a : \u211d) > 0 := by linarith\n            have h\u2081\u2082 : (i : \u211d) * (b - a) < (j : \u211d) * (b - a) := by\n              nlinarith\n            have h\u2081\u2083 : (i : \u211d) * (b - a) / n < (j : \u211d) * (b - a) / n := by\n              have h\u2081\u2084 : (n : \u211d) > 0 := by positivity\n              have h\u2081\u2085 : (i : \u211d) * (b - a) < (j : \u211d) * (b - a) := by nlinarith\n              have h\u2081\u2086 : (i : \u211d) * (b - a) / n < (j : \u211d) * (b - a) / n := by\n                rw [div_lt_div_iff (by positivity) (by positivity)]\n                nlinarith\n              exact h\u2081\u2086\n            linarith\n          exact_mod_cast h\u2081\u2080\n        \u00b7 -- Prove S_P - s_P < \u03b5\n          dsimp\n          have h\u2081\u2081 : (n : \u211d) > 0 := by positivity\n          have h\u2081\u2082 : (b - a : \u211d) > 0 := by linarith\n          have h\u2081\u2083 : (f b - f a : \u211d) > 0 := by linarith\n          -- Use the given condition l4 to bound S_P - s_P\n          have h\u2081\u2084 : (\u2211 j in Finset.Ico 1 (n + 1), f (a + (j : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n))) - \u2211 j in Finset.Ico 1 (n + 1), f (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n)) \u2264 (sSup ((fun j : Fin n => (a + ((j : \u2115) + 1 : \u211d) * (b - a) / n - (a + (j : \u2115) * (b - a) / n))) '' Set.univ)) * (f b - f a) := by\n            have h\u2081\u2085 : a = (fun j => a + (j : \u211d) * (b - a) / n) 0 \u2227 b = (fun j => a + (j : \u211d) * (b - a) / n) n \u2227 (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 (a + (i : \u211d) * (b - a) / n : \u211d) \u2264 (a + (j : \u211d) * (b - a) / n : \u211d)) \u2227 (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 (a + (i : \u211d) * (b - a) / n : \u211d) < (a + (j : \u211d) * (b - a) / n : \u211d)) := by\n              constructor\n              \u00b7 -- Prove a = x 0\n                simp [h\u2086]\n                <;> field_simp [h\u2086]\n                <;> ring_nf\n                <;> linarith\n              constructor\n              \u00b7 -- Prove b = x n\n                have h\u2081\u2086 : (n : \u211d) \u2260 0 := by positivity\n                field_simp [h\u2081\u2086]\n                <;> ring_nf\n                <;> field_simp [h\u2081\u2086]\n                <;> linarith\n              constructor\n              \u00b7 -- Prove the non-decreasing condition\n                intro i j hij hjn\n                have h\u2081\u2087 : (i : \u211d) \u2264 (j : \u211d) := by exact_mod_cast hij\n                have h\u2081\u2088 : (j : \u211d) \u2264 (n : \u211d) := by exact_mod_cast hjn\n                have h\u2081\u2089 : (a + (i : \u211d) * (b - a) / n : \u211d) \u2264 (a + (j : \u211d) * (b - a) / n : \u211d) := by\n                  have h\u2082\u2080 : (b - a : \u211d) \u2265 0 := by linarith\n                  have h\u2082\u2081 : (i : \u211d) * (b - a) \u2264 (j : \u211d) * (b - a) := by\n                    nlinarith\n                  have h\u2082\u2082 : (i : \u211d) * (b - a) / n \u2264 (j : \u211d) * (b - a) / n := by\n                    have h\u2082\u2083 : (n : \u211d) > 0 := by positivity\n                    have h\u2082\u2084 : (i : \u211d) * (b - a) \u2264 (j : \u211d) * (b - a) := by nlinarith\n                    have h\u2082\u2085 : (i : \u211d) * (b - a) / n \u2264 (j : \u211d) * (b - a) / n := by\n                      rw [div_le_div_iff (by positivity) (by positivity)]\n                      nlinarith\n                    exact h\u2082\u2085\n                  linarith\n                exact_mod_cast h\u2081\u2089\n              \u00b7 -- Prove the strictly increasing condition\n                intro i j hij hjn\n                have h\u2082\u2080 : (i : \u211d) < (j : \u211d) := by exact_mod_cast hij\n                have h\u2082\u2081 : (j : \u211d) \u2264 (n : \u211d) := by exact_mod_cast hjn\n                have h\u2082\u2082 : (a + (i : \u211d) * (b - a) / n : \u211d) < (a + (j : \u211d) * (b - a) / n : \u211d) := by\n                  have h\u2082\u2083 : (b - a : \u211d) > 0 := by linarith\n                  have h\u2082\u2084 : (i : \u211d) * (b - a) < (j : \u211d) * (b - a) := by\n                    nlinarith\n                  have h\u2082\u2085 : (i : \u211d) * (b - a) / n < (j : \u211d) * (b - a) / n := by\n                    have h\u2082\u2086 : (n : \u211d) > 0 := by positivity\n                    have h\u2082\u2087 : (i : \u211d) * (b - a) < (j : \u211d) * (b - a) := by nlinarith\n                    have h\u2082\u2088 : (i : \u211d) * (b - a) / n < (j : \u211d) * (b - a) / n := by\n                      rw [div_lt_div_iff (by positivity) (by positivity)]\n                      nlinarith\n                    exact h\u2082\u2088\n                  linarith\n                exact_mod_cast h\u2082\u2082\n            have h\u2082\u2083 := l4 n (fun j => a + (j : \u211d) * (b - a) / n) h\u2081\u2085\n            simpa [Finset.sum_range_succ, Finset.sum_range_zero] using h\u2082\u2083\n          -- Calculate the partition norm\n          have h\u2081\u2085 : sSup ((fun j : Fin n => (a + ((j : \u2115) + 1 : \u211d) * (b - a) / n - (a + (j : \u2115) * (b - a) / n))) '' Set.univ) = (b - a) / n := by\n            have h\u2081\u2086 : \u2200 (j : Fin n), (a + ((j : \u2115) + 1 : \u211d) * (b - a) / n - (a + (j : \u2115) * (b - a) / n) : \u211d) = (b - a) / n := by\n              intro j\n              have h\u2081\u2087 : (n : \u211d) > 0 := by positivity\n              field_simp [h\u2081\u2087.ne']\n              <;> ring_nf\n              <;> field_simp [h\u2081\u2087.ne']\n              <;> ring_nf\n              <;> norm_num\n              <;> linarith\n            have h\u2081\u2088 : ((fun j : Fin n => (a + ((j : \u2115) + 1 : \u211d) * (b - a) / n - (a + (j : \u2115) * (b - a) / n))) '' Set.univ) = {(b - a) / n} := by\n              apply Set.ext\n              intro x\n              simp only [Set.mem_image, Set.mem_singleton_iff]\n              constructor\n              \u00b7 -- Prove the forward direction\n                rintro \u27e8j, _, rfl\u27e9\n                rw [h\u2081\u2086 j]\n              \u00b7 -- Prove the reverse direction\n                intro hx\n                have h\u2081\u2089 : x = (b - a) / n := by simpa using hx\n                refine' \u27e8\u27e80, by\n                  have h\u2082\u2080 : n > 0 := by positivity\n                  omega\u27e9, _, _\u27e9 <;> simp_all [h\u2081\u2086]\n                <;> norm_num\n                <;>\n                  (try\n                    {\n                      field_simp [h\u2081\u2081.ne']\n                      <;> ring_nf\n                      <;> norm_num\n                      <;> linarith\n                    })\n            rw [h\u2081\u2088]\n            simp [Real.sSup_singleton]\n            <;>\n              (try\n                {\n                  field_simp [h\u2081\u2081.ne']\n                  <;> ring_nf\n                  <;> norm_num\n                  <;> linarith\n                })\n          -- Combine the inequalities\n          have h\u2081\u2086 : (\u2211 j in Finset.Ico 1 (n + 1), f (a + (j : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n))) - \u2211 j in Finset.Ico 1 (n + 1), f (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n)) \u2264 ((b - a) / n : \u211d) * (f b - f a) := by\n            calc\n              (\u2211 j in Finset.Ico 1 (n + 1), f (a + (j : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n))) - \u2211 j in Finset.Ico 1 (n + 1), f (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n)) \u2264 (sSup ((fun j : Fin n => (a + ((j : \u2115) + 1 : \u211d) * (b - a) / n - (a + (j : \u2115) * (b - a) / n))) '' Set.univ)) * (f b - f a) := by\n                exact h\u2081\u2084\n              _ = ((b - a) / n : \u211d) * (f b - f a) := by\n                rw [h\u2081\u2085]\n                <;>\n                  (try\n                    {\n                      field_simp [h\u2081\u2081.ne']\n                      <;> ring_nf\n                      <;> norm_num\n                      <;> linarith\n                    })\n          -- Prove that ((b - a) / n : \u211d) * (f b - f a) < \u03b5\n          have h\u2081\u2087 : ((b - a) / n : \u211d) * (f b - f a) < \u03b5 := by\n            have h\u2081\u2088 : (n : \u211d) > (b - a) * (f b - f a) / \u03b5 := hn\n            have h\u2081\u2089 : 0 < (n : \u211d) := by positivity\n            have h\u2082\u2080 : 0 < (b - a : \u211d) := by linarith\n            have h\u2082\u2081 : 0 < (f b - f a : \u211d) := by linarith\n            have h\u2082\u2082 : 0 < \u03b5 := by exact_mod_cast h\u03b5\n            have h\u2082\u2083 : 0 < (b - a : \u211d) * (f b - f a) := by positivity\n            have h\u2082\u2084 : (b - a : \u211d) * (f b - f a) / \u03b5 > 0 := by positivity\n            have h\u2082\u2085 : (n : \u211d) > (b - a) * (f b - f a) / \u03b5 := hn\n            have h\u2082\u2086 : ((b - a) / n : \u211d) * (f b - f a) < \u03b5 := by\n              calc\n                ((b - a) / n : \u211d) * (f b - f a) = (b - a) * (f b - f a) / n := by\n                  field_simp\n                  <;> ring_nf\n                _ < \u03b5 := by\n                  have h\u2082\u2087 : (n : \u211d) > (b - a) * (f b - f a) / \u03b5 := hn\n                  have h\u2082\u2088 : 0 < (b - a) * (f b - f a) := by positivity\n                  have h\u2082\u2089 : 0 < \u03b5 := by positivity\n                  have h\u2083\u2080 : 0 < (n : \u211d) := by positivity\n                  calc\n                    (b - a) * (f b - f a) / n < (b - a) * (f b - f a) / ((b - a) * (f b - f a) / \u03b5) := by\n                      gcongr\n                      <;>\n                        (try positivity)\n                    _ = \u03b5 := by\n                      field_simp [h\u2082\u2088.ne', h\u2082\u2089.ne']\n                      <;> ring_nf\n                      <;> field_simp [h\u2082\u2088.ne', h\u2082\u2089.ne']\n                      <;> linarith\n            exact h\u2082\u2086\n          -- Combine everything to get the final result\n          have h\u2082\u2080 : (\u2211 j in Finset.Ico 1 (n + 1), f (a + (j : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n))) - \u2211 j in Finset.Ico 1 (n + 1), f (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n) * (a + (j : \u211d) * (b - a) / n - (a + ((j - 1 : \u2115) : \u211d) * (b - a) / n)) < \u03b5 := by\n            linarith\n          simpa [Finset.sum_Ico_succ_top] using h\u2082\u2080\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The monotonicity assumption is correctly captured using MonotoneOn with the appropriate interval Set.Icc a b", "The partition inequality l4 is properly formalized with all necessary partition conditions, upper/lower sum definitions, and the correct inequality relationship", "The conclusion l5 correctly captures the existential statement about epsilon-fine partitions with the proper quantifier structure", "The concrete partition representation using sequences and explicit Riemann sum formulas is a valid and complete formalization of the abstract partition notation in the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "so $f$ is integrable on $[a,b]$, by Theorem~\\ref{thmtype:3.2.7}.", "statement": "We assume:\n\u2022 $f$ is nondecreasing on $[a,b]$ [def_3].\n\u2022 $f$ is bounded on $[a,b]$ [l1].\n\u2022 For any $\\epsilon > 0$, there exists a partition $P$ such that $S(P)-s(P) < \\epsilon$ [l5].\n\u2022 Riemann's Criterion for Integrability [def_1].\nTherefore, we conclude:\n\u2022 If $f$ is nondecreasing on $[a,b]$, then $f$ is integrable on $[a,b]$ [l6].", "dependencies": ["l1", "l5", "def_1", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (h_bounded : \u2203 M, \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M)\n  (h_riemann : \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    S_P - s_P < \u03b5) :\n  \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (h_bounded : \u2203 M, \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M)\n  (h_riemann : \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    S_P - s_P < \u03b5) :\n  \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2 := by\n  have h_main : \u2203 (I : \u211d), \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)); |S_P - I| < \u03b5 / 2 \u2227 |s_P - I| < \u03b5 / 2)) := by sorry\n  sorry", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The monotonicity assumption is correctly captured using MonotoneOn for the closed interval", "The boundedness condition is properly formalized with existential quantification over a bound M", "The Riemann criterion assumption accurately captures the partition-based condition with upper and lower sums", "The integrability conclusion correctly uses the standard definition via convergence of Riemann sums to a limit", "The logical structure perfectly mirrors the natural language theorem statement with assumptions and conclusion", "The Lean formalization includes appropriate technical details for mathematical rigor while preserving all semantic content from the natural language", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b))\n  (h_bounded : \u2203 M, \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M)\n  (h_riemann : \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    S_P - s_P < \u03b5) :\n  \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2 := by\n  have h_bounded_sums : \u2203 (M' : \u211d), \u2200 (n : \u2115) (x : \u2115 \u2192 \u211d), (a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j)) \u2192 (\u2200 j \u2208 Finset.Ico 1 (n + 1), x (j - 1) \u2208 Set.Icc a b \u2227 x j \u2208 Set.Icc a b) \u2192 abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2264 M' \u2227 abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) \u2264 M' := by\n    obtain \u27e8M, hM\u27e9 := h_bounded\n    use (M + 1) * (abs (b - a) + 1)\n    intro n x hx h_in_Icc\n    have h\u2081 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2264 (M + 1) * (abs (b - a) + 1) := by\n      have h\u2082 : \u2200 j \u2208 Finset.Ico 1 (n + 1), abs (f (x j) * (x j - x (j - 1))) \u2264 (M + 1) * (abs (b - a) + 1) := by\n        intro j hj\n        have h\u2083 : x (j - 1) \u2208 Set.Icc a b \u2227 x j \u2208 Set.Icc a b := h_in_Icc j hj\n        have h\u2084 : x (j - 1) \u2208 Set.Icc a b := h\u2083.1\n        have h\u2085 : x j \u2208 Set.Icc a b := h\u2083.2\n        have h\u2086 : a \u2264 x (j - 1) := h\u2084.1\n        have h\u2087 : x (j - 1) \u2264 b := h\u2084.2\n        have h\u2088 : a \u2264 x j := h\u2085.1\n        have h\u2089 : x j \u2264 b := h\u2085.2\n        have h\u2081\u2080 : abs (f (x j)) \u2264 M := by\n          have h\u2081\u2081 : x j \u2208 Set.Icc a b := h\u2085\n          exact hM (x j) h\u2081\u2081\n        have h\u2081\u2081 : abs (x j - x (j - 1)) \u2264 abs (b - a) := by\n          have h\u2081\u2082 : x (j - 1) \u2265 a := h\u2086\n          have h\u2081\u2083 : x (j - 1) \u2264 b := h\u2087\n          have h\u2081\u2084 : x j \u2265 a := h\u2088\n          have h\u2081\u2085 : x j \u2264 b := h\u2089\n          have h\u2081\u2086 : x j - x (j - 1) \u2264 b - a := by linarith\n          have h\u2081\u2087 : x j - x (j - 1) \u2265 -(b - a) := by linarith\n          rw [abs_le]\n          constructor <;> linarith\n        calc\n          abs (f (x j) * (x j - x (j - 1))) = abs (f (x j)) * abs (x j - x (j - 1)) := by\n            rw [abs_mul]\n          _ \u2264 M * abs (x j - x (j - 1)) := by gcongr\n          _ \u2264 M * (abs (b - a)) := by gcongr\n          _ \u2264 (M + 1) * (abs (b - a) + 1) := by\n            have h\u2081\u2082 : 0 \u2264 M := by\n              have h\u2081\u2083 : \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M := hM\n              have h\u2081\u2084 : a \u2208 Set.Icc a b := \u27e8by linarith, by linarith\u27e9\n              have h\u2081\u2085 : abs (f a) \u2264 M := h\u2081\u2083 a h\u2081\u2084\n              have h\u2081\u2086 : 0 \u2264 abs (f a) := abs_nonneg (f a)\n              linarith\n            have h\u2081\u2083 : 0 \u2264 abs (b - a) := abs_nonneg (b - a)\n            nlinarith\n      calc\n        abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2264 \u2211 j in Finset.Ico 1 (n + 1), abs (f (x j) * (x j - x (j - 1))) := by\n          exact Finset.abs_sum_le_sum_abs _ _\n        _ \u2264 \u2211 j in Finset.Ico 1 (n + 1), (M + 1) * (abs (b - a) + 1) := by\n          apply Finset.sum_le_sum\n          intro j hj\n          exact h\u2082 j hj\n        _ = (n + 1 - 1 : \u2115) \u2022 ((M + 1) * (abs (b - a) + 1)) := by\n          simp [Finset.sum_const, Finset.card_range]\n          <;>\n          simp_all [Finset.Ico_eq_empty_of_le]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith\n        _ \u2264 (M + 1) * (abs (b - a) + 1) := by\n          cases n with\n          | zero =>\n            simp [add_assoc]\n          | succ n =>\n            simp [add_assoc, add_comm, add_left_comm, nsmul_eq_mul]\n            <;>\n            norm_num\n            <;>\n            nlinarith\n    have h\u2082 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) \u2264 (M + 1) * (abs (b - a) + 1) := by\n      have h\u2083 : \u2200 j \u2208 Finset.Ico 1 (n + 1), abs (f (x (j - 1)) * (x j - x (j - 1))) \u2264 (M + 1) * (abs (b - a) + 1) := by\n        intro j hj\n        have h\u2084 : x (j - 1) \u2208 Set.Icc a b \u2227 x j \u2208 Set.Icc a b := h_in_Icc j hj\n        have h\u2085 : x (j - 1) \u2208 Set.Icc a b := h\u2084.1\n        have h\u2086 : x j \u2208 Set.Icc a b := h\u2084.2\n        have h\u2087 : a \u2264 x (j - 1) := h\u2085.1\n        have h\u2088 : x (j - 1) \u2264 b := h\u2085.2\n        have h\u2089 : a \u2264 x j := h\u2086.1\n        have h\u2081\u2080 : x j \u2264 b := h\u2086.2\n        have h\u2081\u2081 : abs (f (x (j - 1))) \u2264 M := by\n          have h\u2081\u2082 : x (j - 1) \u2208 Set.Icc a b := h\u2085\n          exact hM (x (j - 1)) h\u2081\u2082\n        have h\u2081\u2082 : abs (x j - x (j - 1)) \u2264 abs (b - a) := by\n          have h\u2081\u2083 : x (j - 1) \u2265 a := h\u2087\n          have h\u2081\u2084 : x (j - 1) \u2264 b := h\u2088\n          have h\u2081\u2085 : x j \u2265 a := h\u2089\n          have h\u2081\u2086 : x j \u2264 b := h\u2081\u2080\n          have h\u2081\u2087 : x j - x (j - 1) \u2264 b - a := by linarith\n          have h\u2081\u2088 : x j - x (j - 1) \u2265 -(b - a) := by linarith\n          rw [abs_le]\n          constructor <;> linarith\n        calc\n          abs (f (x (j - 1)) * (x j - x (j - 1))) = abs (f (x (j - 1))) * abs (x j - x (j - 1)) := by\n            rw [abs_mul]\n          _ \u2264 M * abs (x j - x (j - 1)) := by gcongr\n          _ \u2264 M * (abs (b - a)) := by gcongr\n          _ \u2264 (M + 1) * (abs (b - a) + 1) := by\n            have h\u2081\u2083 : 0 \u2264 M := by\n              have h\u2081\u2084 : \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M := hM\n              have h\u2081\u2085 : a \u2208 Set.Icc a b := \u27e8by linarith, by linarith\u27e9\n              have h\u2081\u2086 : abs (f a) \u2264 M := h\u2081\u2084 a h\u2081\u2085\n              have h\u2081\u2087 : 0 \u2264 abs (f a) := abs_nonneg (f a)\n              linarith\n            have h\u2081\u2084 : 0 \u2264 abs (b - a) := abs_nonneg (b - a)\n            nlinarith\n      calc\n        abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) \u2264 \u2211 j in Finset.Ico 1 (n + 1), abs (f (x (j - 1)) * (x j - x (j - 1))) := by\n          exact Finset.abs_sum_le_sum_abs _ _\n        _ \u2264 \u2211 j in Finset.Ico 1 (n + 1), (M + 1) * (abs (b - a) + 1) := by\n          apply Finset.sum_le_sum\n          intro j hj\n          exact h\u2083 j hj\n        _ = (n + 1 - 1 : \u2115) \u2022 ((M + 1) * (abs (b - a) + 1)) := by\n          simp [Finset.sum_const, Finset.card_range]\n          <;>\n          simp_all [Finset.Ico_eq_empty_of_le]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith\n        _ \u2264 (M + 1) * (abs (b - a) + 1) := by\n          cases n with\n          | zero =>\n            simp [add_assoc]\n          | succ n =>\n            simp [add_assoc, add_comm, add_left_comm, nsmul_eq_mul]\n            <;>\n            norm_num\n            <;>\n            nlinarith\n    exact \u27e8h\u2081, h\u2082\u27e9\n  \n  have h_exists_I : \u2203 (I : \u211d), True := by\n    refine' \u27e80, _\u27e9\n    <;> trivial\n  \n  have h_main : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I) < \u03b5 / 2 \u2227 abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I) < \u03b5 / 2) := by\n    obtain \u27e8M', hM'\u27e9 := h_bounded_sums\n    use 0\n    intro \u03b5 \u03b5pos\n    have h\u2081 : \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := by\n      have h\u2082 : \u03b5 / 2 > 0 := by linarith\n      obtain \u27e8n, x, hx\u2080, hx\u2081, hx\u2082, hx\u2083, hsum\u27e9 := h_riemann (\u03b5 / 2) h\u2082\n      refine' \u27e8n, x, hx\u2080, hx\u2081, hx\u2082, hx\u2083, _\u27e9\n      simpa [sub_lt_iff_lt_add] using hsum\n    obtain \u27e8n, x, hx\u2080, hx\u2081, hx\u2082, hx\u2083, hsum\u27e9 := h\u2081\n    have h\u2082 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - 0) < \u03b5 / 2 \u2227 abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := by\n      have h\u2083 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := hsum\n      have h\u2084 : 0 \u2264 (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := by\n        have h\u2085 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2265 (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := by\n          have h\u2086 : \u2200 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) \u2265 f (x (j - 1)) * (x j - x (j - 1)) := by\n            intro j hj\n            have h\u2087 : 1 \u2264 j := by\n              simp [Finset.mem_Ico] at hj\n              linarith\n            have h\u2088 : j \u2264 n + 1 := by\n              simp [Finset.mem_Ico] at hj\n              linarith\n            have h\u2089 : (j : \u2115) - 1 + 1 = j := by\n              have h\u2081\u2080 : 1 \u2264 j := by\n                simp [Finset.mem_Ico] at hj\n                linarith\n              omega\n            have h\u2081\u2080 : a \u2264 x (j - 1) := by\n              have h\u2081\u2081 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n              have h\u2081\u2082 : 0 \u2264 (j - 1 : \u2115) := by\n                have h\u2081\u2083 : 1 \u2264 j := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                omega\n              have h\u2081\u2083 : (j - 1 : \u2115) \u2264 n := by\n                have h\u2081\u2084 : j \u2264 n + 1 := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                have h\u2081\u2085 : (j : \u2115) - 1 \u2264 n := by\n                  omega\n                exact h\u2081\u2085\n              have h\u2081\u2084 : x 0 \u2264 x (j - 1) := hx\u2082 0 (j - 1) (by\n                have h\u2081\u2085 : 1 \u2264 j := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                omega) (by\n                  omega)\n              linarith\n            have h\u2081\u2081 : x (j - 1) \u2264 x j := by\n              have h\u2081\u2082 : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j := hx\u2083\n              have h\u2081\u2083 : (j : \u2115) - 1 < j := by\n                have h\u2081\u2084 : 1 \u2264 j := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                omega\n              have h\u2081\u2084 : j \u2264 n := by\n                simp [Finset.mem_Ico] at hj\n                omega\n              have h\u2081\u2085 : x ((j : \u2115) - 1) < x j := hx\u2083 ((j : \u2115) - 1) j (by\n                omega) (by\n                  omega)\n              linarith\n            have h\u2081\u2082 : x (j - 1) \u2264 b := by\n              have h\u2081\u2083 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n              have h\u2081\u2084 : (j : \u2115) \u2264 n := by\n                simp [Finset.mem_Ico] at hj\n                omega\n              have h\u2081\u2085 : x (j - 1) \u2264 x n := hx\u2082 (j - 1) n (by\n                have h\u2081\u2086 : 1 \u2264 j := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                omega) (by\n                  omega)\n              linarith\n            have h\u2081\u2083 : x (j - 1) \u2208 Set.Icc a b := by\n              exact \u27e8h\u2081\u2080, h\u2081\u2082\u27e9\n            have h\u2081\u2084 : x j \u2208 Set.Icc a b := by\n              have h\u2081\u2085 : a \u2264 x j := by\n                have h\u2081\u2086 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                have h\u2081\u2087 : 0 \u2264 j := by\n                  omega\n                have h\u2081\u2088 : j \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2081\u2089 : x 0 \u2264 x j := hx\u2082 0 j (by omega) (by omega)\n                linarith\n              have h\u2081\u2086 : x j \u2264 b := by\n                have h\u2081\u2087 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                have h\u2081\u2088 : j \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2081\u2089 : x j \u2264 x n := hx\u2082 j n (by omega) (by omega)\n                linarith\n              exact \u27e8h\u2081\u2085, h\u2081\u2086\u27e9\n            have h\u2081\u2085 : f (x (j - 1)) \u2264 f (x j) := by\n              apply h_mono\n              <;> simp_all [Set.Icc, Set.mem_setOf_eq]\n              <;>\n                (try omega) <;>\n                (try linarith)\n            have h\u2081\u2086 : 0 \u2264 (x j - x (j - 1)) := by\n              have h\u2081\u2087 : x (j - 1) \u2264 x j := by\n                have h\u2081\u2088 : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j := hx\u2083\n                have h\u2081\u2089 : (j : \u2115) - 1 < j := by\n                  have h\u2082\u2080 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega\n                have h\u2082\u2080 : j \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2082\u2081 : x ((j : \u2115) - 1) < x j := hx\u2083 ((j : \u2115) - 1) j (by omega) (by omega)\n                linarith\n              linarith\n            nlinarith\n          calc\n            (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2265 \u2211 j in Finset.Ico 1 (n + 1), (f (x (j - 1)) * (x j - x (j - 1))) := by\n              exact Finset.sum_le_sum h\u2086\n            _ = (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := by rfl\n        linarith\n      have h\u2085 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := hsum\n      have h\u2086 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := by\n        have h\u2087 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) < \u03b5 / 2 := by\n          have h\u2088 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := hsum\n          have h\u2089 : 0 \u2264 (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := h\u2084\n          have h\u2081\u2080 : (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) \u2265 0 := by\n            have h\u2081\u2081 : \u2200 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) \u2265 0 := by\n              intro j hj\n              have h\u2081\u2082 : 1 \u2264 j := by\n                simp [Finset.mem_Ico] at hj\n                linarith\n              have h\u2081\u2083 : j \u2264 n + 1 := by\n                simp [Finset.mem_Ico] at hj\n                linarith\n              have h\u2081\u2084 : (j : \u2115) - 1 + 1 = j := by\n                have h\u2081\u2085 : 1 \u2264 j := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                omega\n              have h\u2081\u2085 : a \u2264 x (j - 1) := by\n                have h\u2081\u2086 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                have h\u2081\u2087 : 0 \u2264 (j - 1 : \u2115) := by\n                  have h\u2081\u2088 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega\n                have h\u2081\u2088 : (j - 1 : \u2115) \u2264 n := by\n                  have h\u2081\u2089 : j \u2264 n + 1 := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  have h\u2082\u2080 : (j : \u2115) - 1 \u2264 n := by\n                    omega\n                  exact h\u2082\u2080\n                have h\u2081\u2089 : x 0 \u2264 x (j - 1) := hx\u2082 0 (j - 1) (by\n                  have h\u2082\u2080 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega) (by\n                    omega)\n                linarith\n              have h\u2081\u2086 : x (j - 1) \u2264 x j := by\n                have h\u2081\u2087 : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j := hx\u2083\n                have h\u2081\u2088 : (j : \u2115) - 1 < j := by\n                  have h\u2081\u2089 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega\n                have h\u2081\u2089 : j \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2082\u2080 : x ((j : \u2115) - 1) < x j := hx\u2083 ((j : \u2115) - 1) j (by\n                  omega) (by\n                    omega)\n                linarith\n              have h\u2081\u2087 : x (j - 1) \u2264 b := by\n                have h\u2081\u2088 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                have h\u2081\u2089 : (j : \u2115) \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2082\u2080 : x (j - 1) \u2264 x n := hx\u2082 (j - 1) n (by\n                  have h\u2082\u2081 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega) (by\n                    omega)\n                linarith\n              have h\u2081\u2088 : x (j - 1) \u2208 Set.Icc a b := by\n                exact \u27e8h\u2081\u2085, h\u2081\u2087\u27e9\n              have h\u2081\u2089 : x j \u2208 Set.Icc a b := by\n                have h\u2082\u2080 : a \u2264 x j := by\n                  have h\u2082\u2081 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                  have h\u2082\u2082 : 0 \u2264 j := by\n                    omega\n                  have h\u2082\u2083 : j \u2264 n := by\n                    simp [Finset.mem_Ico] at hj\n                    omega\n                  have h\u2082\u2084 : x 0 \u2264 x j := hx\u2082 0 j (by omega) (by omega)\n                  linarith\n                have h\u2082\u2081 : x j \u2264 b := by\n                  have h\u2082\u2082 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                  have h\u2082\u2083 : j \u2264 n := by\n                    simp [Finset.mem_Ico] at hj\n                    omega\n                  have h\u2082\u2084 : x j \u2264 x n := hx\u2082 j n (by omega) (by omega)\n                  linarith\n                exact \u27e8h\u2082\u2080, h\u2082\u2081\u27e9\n              have h\u2082\u2080 : 0 \u2264 (x j - x (j - 1)) := by\n                have h\u2082\u2081 : x (j - 1) \u2264 x j := by\n                  have h\u2082\u2082 : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j := hx\u2083\n                  have h\u2082\u2083 : (j : \u2115) - 1 < j := by\n                    have h\u2082\u2084 : 1 \u2264 j := by\n                      simp [Finset.mem_Ico] at hj\n                      linarith\n                    omega\n                  have h\u2082\u2084 : j \u2264 n := by\n                    simp [Finset.mem_Ico] at hj\n                    omega\n                  have h\u2082\u2085 : x ((j : \u2115) - 1) < x j := hx\u2083 ((j : \u2115) - 1) j (by omega) (by omega)\n                  linarith\n                linarith\n              have h\u2082\u2081 : 0 \u2264 f (x (j - 1)) := by\n                have h\u2082\u2082 : \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M' := by\n                  intro x hx\n                  have h\u2082\u2083 := hM' 0 (fun i j _ _ => by simp_all [hx\u2080, hx\u2081]) (by\n                    intro j hj\n                    simp_all [Finset.mem_Ico]\n                    <;>\n                    (try omega) <;>\n                    (try {\n                      have h\u2082\u2084 : a \u2264 x 0 := by\n                        simp_all [hx\u2080]\n                        <;>\n                        linarith\n                      have h\u2082\u2085 : x 0 \u2264 b := by\n                        simp_all [hx\u2080, hx\u2081]\n                        <;>\n                        linarith\n                      simp_all [Set.Icc, Set.mem_setOf_eq]\n                      <;>\n                      (try omega) <;>\n                      (try linarith)\n                    })\n                  )\n                  have h\u2082\u2084 : abs (f x) \u2264 M' := h\u2082\u2083\n                  have h\u2082\u2085 : 0 \u2264 M' := by\n                    have h\u2082\u2086 := hM' 0 (fun i j _ _ => by simp_all [hx\u2080, hx\u2081]) (by\n                      intro j hj\n                      simp_all [Finset.mem_Ico]\n                      <;>\n                      (try omega) <;>\n                      (try {\n                        have h\u2082\u2087 : a \u2264 x 0 := by\n                          simp_all [hx\u2080]\n                          <;>\n                          linarith\n                        have h\u2082\u2088 : x 0 \u2264 b := by\n                          simp_all [hx\u2080, hx\u2081]\n                          <;>\n                          linarith\n                        simp_all [Set.Icc, Set.mem_setOf_eq]\n                        <;>\n                        (try omega) <;>\n                        (try linarith)\n                      })\n                    )\n                    simp_all [abs_nonneg]\n                    <;>\n                    linarith\n                  have h\u2082\u2086 : 0 \u2264 abs (f x) := abs_nonneg (f x)\n                  linarith\n                have h\u2082\u2083 : x (j - 1) \u2208 Set.Icc a b := by\n                  have h\u2082\u2084 : a \u2264 x (j - 1) := by\n                    have h\u2082\u2085 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                    have h\u2082\u2086 : 0 \u2264 (j - 1 : \u2115) := by\n                      have h\u2082\u2087 : 1 \u2264 j := by\n                        simp [Finset.mem_Ico] at hj\n                        linarith\n                      omega\n                    have h\u2082\u2087 : (j - 1 : \u2115) \u2264 n := by\n                      have h\u2082\u2088 : j \u2264 n + 1 := by\n                        simp [Finset.mem_Ico] at hj\n                        linarith\n                      have h\u2082\u2089 : (j : \u2115) - 1 \u2264 n := by\n                        omega\n                      exact h\u2082\u2089\n                    have h\u2082\u2088 : x 0 \u2264 x (j - 1) := hx\u2082 0 (j - 1) (by\n                      have h\u2082\u2089 : 1 \u2264 j := by\n                        simp [Finset.mem_Ico] at hj\n                        linarith\n                      omega) (by\n                        omega)\n                    linarith\n                  have h\u2082\u2085 : x (j - 1) \u2264 b := by\n                    have h\u2082\u2086 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                    have h\u2082\u2087 : (j : \u2115) \u2264 n := by\n                      simp [Finset.mem_Ico] at hj\n                      omega\n                    have h\u2082\u2088 : x (j - 1) \u2264 x n := hx\u2082 (j - 1) n (by\n                      have h\u2082\u2089 : 1 \u2264 j := by\n                        simp [Finset.mem_Ico] at hj\n                        linarith\n                      omega) (by\n                        omega)\n                    linarith\n                  exact \u27e8h\u2082\u2084, h\u2082\u2085\u27e9\n                have h\u2082\u2084 : abs (f (x (j - 1))) \u2264 M' := h\u2082\u2082 (x (j - 1)) h\u2082\u2083\n                have h\u2082\u2085 : 0 \u2264 M' := by\n                  have h\u2082\u2086 := hM' 0 (fun i j _ _ => by simp_all [hx\u2080, hx\u2081]) (by\n                    intro j hj\n                    simp_all [Finset.mem_Ico]\n                    <;>\n                    (try omega) <;>\n                    (try {\n                      have h\u2082\u2087 : a \u2264 x 0 := by\n                        simp_all [hx\u2080]\n                        <;>\n                        linarith\n                      have h\u2082\u2088 : x 0 \u2264 b := by\n                        simp_all [hx\u2080, hx\u2081]\n                        <;>\n                        linarith\n                      simp_all [Set.Icc, Set.mem_setOf_eq]\n                      <;>\n                      (try omega) <;>\n                      (try linarith)\n                    })\n                  )\n                  simp_all [abs_nonneg]\n                  <;>\n                  linarith\n                have h\u2082\u2086 : 0 \u2264 abs (f (x (j - 1))) := abs_nonneg (f (x (j - 1)))\n                have h\u2082\u2087 : f (x (j - 1)) \u2265 0 := by\n                  cases' abs_cases (f (x (j - 1))) with h\u2082\u2088 h\u2082\u2088 <;> linarith\n                linarith\n              nlinarith\n            calc\n              (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) \u2265 \u2211 j in Finset.Ico 1 (n + 1), 0 := by\n                exact Finset.sum_le_sum fun j hj => by\n                  have h\u2082\u2081 := h\u2081\u2081 j hj\n                  linarith\n              _ = 0 := by simp\n          have h\u2081\u2082 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) < \u03b5 / 2 := by\n            linarith\n          linarith\n        have h\u2088 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := by\n          rw [abs_sub_lt_iff]\n          constructor <;> linarith\n        exact h\u2088\n      have h\u2087 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := by\n        have h\u2088 : (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := by\n          have h\u2089 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := hsum\n          have h\u2081\u2080 : 0 \u2264 (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := h\u2084\n          have h\u2081\u2081 : (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2265 0 := by\n            have h\u2081\u2082 : \u2200 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) \u2265 0 := by\n              intro j hj\n              have h\u2081\u2083 : 1 \u2264 j := by\n                simp [Finset.mem_Ico] at hj\n                linarith\n              have h\u2081\u2084 : j \u2264 n + 1 := by\n                simp [Finset.mem_Ico] at hj\n                linarith\n              have h\u2081\u2085 : (j : \u2115) - 1 + 1 = j := by\n                have h\u2081\u2086 : 1 \u2264 j := by\n                  simp [Finset.mem_Ico] at hj\n                  linarith\n                omega\n              have h\u2081\u2086 : a \u2264 x (j - 1) := by\n                have h\u2081\u2087 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                have h\u2081\u2088 : 0 \u2264 (j - 1 : \u2115) := by\n                  have h\u2081\u2089 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega\n                have h\u2081\u2089 : (j - 1 : \u2115) \u2264 n := by\n                  have h\u2082\u2080 : j \u2264 n + 1 := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  have h\u2082\u2081 : (j : \u2115) - 1 \u2264 n := by\n                    omega\n                  exact h\u2082\u2081\n                have h\u2082\u2080 : x 0 \u2264 x (j - 1) := hx\u2082 0 (j - 1) (by\n                  have h\u2082\u2081 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega) (by\n                    omega)\n                linarith\n              have h\u2081\u2087 : x (j - 1) \u2264 x j := by\n                have h\u2081\u2088 : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j := hx\u2083\n                have h\u2081\u2089 : (j : \u2115) - 1 < j := by\n                  have h\u2082\u2080 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega\n                have h\u2082\u2080 : j \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2082\u2081 : x ((j : \u2115) - 1) < x j := hx\u2083 ((j : \u2115) - 1) j (by\n                  omega) (by\n                    omega)\n                linarith\n              have h\u2081\u2088 : x (j - 1) \u2264 b := by\n                have h\u2081\u2089 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                have h\u2082\u2080 : (j : \u2115) \u2264 n := by\n                  simp [Finset.mem_Ico] at hj\n                  omega\n                have h\u2082\u2081 : x (j - 1) \u2264 x n := hx\u2082 (j - 1) n (by\n                  have h\u2082\u2082 : 1 \u2264 j := by\n                    simp [Finset.mem_Ico] at hj\n                    linarith\n                  omega) (by\n                    omega)\n                linarith\n              have h\u2081\u2089 : x (j - 1) \u2208 Set.Icc a b := by\n                exact \u27e8h\u2081\u2086, h\u2081\u2088\u27e9\n              have h\u2082\u2080 : x j \u2208 Set.Icc a b := by\n                have h\u2082\u2081 : a \u2264 x j := by\n                  have h\u2082\u2082 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                  have h\u2082\u2083 : 0 \u2264 j := by\n                    omega\n                  have h\u2082\u2084 : j \u2264 n := by\n                    simp [Finset.mem_Ico] at hj\n                    omega\n                  have h\u2082\u2085 : x 0 \u2264 x j := hx\u2082 0 j (by omega) (by omega)\n                  linarith\n                have h\u2082\u2082 : x j \u2264 b := by\n                  have h\u2082\u2083 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                  have h\u2082\u2084 : j \u2264 n := by\n                    simp [Finset.mem_Ico] at hj\n                    omega\n                  have h\u2082\u2085 : x j \u2264 x n := hx\u2082 j n (by omega) (by omega)\n                  linarith\n                exact \u27e8h\u2082\u2081, h\u2082\u2082\u27e9\n              have h\u2082\u2081 : 0 \u2264 (x j - x (j - 1)) := by\n                have h\u2082\u2082 : x (j - 1) \u2264 x j := by\n                  have h\u2082\u2083 : \u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j := hx\u2083\n                  have h\u2082\u2084 : (j : \u2115) - 1 < j := by\n                    have h\u2082\u2085 : 1 \u2264 j := by\n                      simp [Finset.mem_Ico] at hj\n                      linarith\n                    omega\n                  have h\u2082\u2085 : j \u2264 n := by\n                    simp [Finset.mem_Ico] at hj\n                    omega\n                  have h\u2082\u2086 : x ((j : \u2115) - 1) < x j := hx\u2083 ((j : \u2115) - 1) j (by\n                    omega) (by\n                      omega)\n                  linarith\n                linarith\n              have h\u2082\u2082 : 0 \u2264 f (x j) := by\n                have h\u2082\u2083 : \u2200 x \u2208 Set.Icc a b, abs (f x) \u2264 M' := by\n                  intro x hx\n                  have h\u2082\u2084 := hM' 0 (fun i j _ _ => by simp_all [hx\u2080, hx\u2081]) (by\n                    intro j hj\n                    simp_all [Finset.mem_Ico]\n                    <;>\n                    (try omega) <;>\n                    (try {\n                      have h\u2082\u2085 : a \u2264 x 0 := by\n                        simp_all [hx\u2080]\n                        <;>\n                        linarith\n                      have h\u2082\u2086 : x 0 \u2264 b := by\n                        simp_all [hx\u2080, hx\u2081]\n                        <;>\n                        linarith\n                      simp_all [Set.Icc, Set.mem_setOf_eq]\n                      <;>\n                      (try omega) <;>\n                      (try linarith)\n                    })\n                  )\n                  have h\u2082\u2085 : abs (f x) \u2264 M' := h\u2082\u2084\n                  have h\u2082\u2086 : 0 \u2264 M' := by\n                    have h\u2082\u2087 := hM' 0 (fun i j _ _ => by simp_all [hx\u2080, hx\u2081]) (by\n                      intro j hj\n                      simp_all [Finset.mem_Ico]\n                      <;>\n                      (try omega) <;>\n                      (try {\n                        have h\u2082\u2088 : a \u2264 x 0 := by\n                          simp_all [hx\u2080]\n                          <;>\n                          linarith\n                        have h\u2082\u2089 : x 0 \u2264 b := by\n                          simp_all [hx\u2080, hx\u2081]\n                          <;>\n                          linarith\n                        simp_all [Set.Icc, Set.mem_setOf_eq]\n                        <;>\n                        (try omega) <;>\n                        (try linarith)\n                      })\n                    )\n                    simp_all [abs_nonneg]\n                    <;>\n                    linarith\n                  have h\u2082\u2087 : 0 \u2264 abs (f x) := abs_nonneg (f x)\n                  linarith\n                have h\u2082\u2084 : x j \u2208 Set.Icc a b := by\n                  have h\u2082\u2085 : a \u2264 x j := by\n                    have h\u2082\u2086 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                    have h\u2082\u2087 : 0 \u2264 j := by\n                      omega\n                    have h\u2082\u2088 : j \u2264 n := by\n                      simp [Finset.mem_Ico] at hj\n                      omega\n                    have h\u2082\u2089 : x 0 \u2264 x j := hx\u2082 0 j (by omega) (by omega)\n                    linarith\n                  have h\u2082\u2086 : x j \u2264 b := by\n                    have h\u2082\u2087 : \u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j := hx\u2082\n                    have h\u2082\u2088 : j \u2264 n := by\n                      simp [Finset.mem_Ico] at hj\n                      omega\n                    have h\u2082\u2089 : x j \u2264 x n := hx\u2082 j n (by omega) (by omega)\n                    linarith\n                  exact \u27e8h\u2082\u2085, h\u2082\u2086\u27e9\n                have h\u2082\u2085 : abs (f (x j)) \u2264 M' := h\u2082\u2083 (x j) h\u2082\u2084\n                have h\u2082\u2086 : 0 \u2264 M' := by\n                  have h\u2082\u2087 := hM' 0 (fun i j _ _ => by simp_all [hx\u2080, hx\u2081]) (by\n                    intro j hj\n                    simp_all [Finset.mem_Ico]\n                    <;>\n                    (try omega) <;>\n                    (try {\n                      have h\u2082\u2088 : a \u2264 x 0 := by\n                        simp_all [hx\u2080]\n                        <;>\n                        linarith\n                      have h\u2082\u2089 : x 0 \u2264 b := by\n                        simp_all [hx\u2080, hx\u2081]\n                        <;>\n                        linarith\n                      simp_all [Set.Icc, Set.mem_setOf_eq]\n                      <;>\n                      (try omega) <;>\n                      (try linarith)\n                    })\n                  )\n                  simp_all [abs_nonneg]\n                  <;>\n                  linarith\n                have h\u2082\u2087 : 0 \u2264 abs (f (x j)) := abs_nonneg (f (x j))\n                have h\u2082\u2088 : f (x j) \u2265 0 := by\n                  cases' abs_cases (f (x j)) with h\u2082\u2089 h\u2082\u2089 <;> linarith\n                linarith\n              nlinarith\n            calc\n              (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) \u2265 \u2211 j in Finset.Ico 1 (n + 1), 0 := by\n                exact Finset.sum_le_sum fun j hj => by\n                  have h\u2082\u2083 := h\u2081\u2082 j hj\n                  linarith\n              _ = 0 := by simp\n          have h\u2081\u2082 : (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) < \u03b5 / 2 := by\n            linarith\n          linarith\n        have h\u2089 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := by\n          rw [abs_sub_lt_iff]\n          constructor <;> linarith\n        exact h\u2089\n      exact \u27e8h\u2086, h\u2087\u27e9\n    refine' \u27e8n, x, hx\u2080, hx\u2081, hx\u2082, hx\u2083, _\u27e9\n    have h\u2083 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := h\u2082.1\n    have h\u2084 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - 0) < \u03b5 / 2 := h\u2082.2\n    simp_all\n    <;>\n    (try\n      {\n        simp_all [abs_sub_lt_iff]\n        <;>\n        (try linarith)\n      })\n    <;>\n    (try\n      {\n        linarith\n      })\n  \n  obtain \u27e8I, hI\u27e9 := h_main\n  refine' \u27e8I, _\u27e9\n  intro \u03b5 \u03b5pos\n  have h\u2082 : \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I) < \u03b5 / 2 \u2227 abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I) < \u03b5 / 2) := by\n    have h\u2083 := hI \u03b5 \u03b5pos\n    exact h\u2083\n  obtain \u27e8n, x, hx\u2080, hx\u2081, hx\u2082, hx\u2083, hx\u2084\u27e9 := h\u2082\n  refine' \u27e8n, x, hx\u2080, hx\u2081, hx\u2082, hx\u2083, _\u27e9\n  simpa using hx\u2084"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "If $f$ is monotonic on $[a,b],$ then $f$ is integrable on $[a,b]$. \n The proof for nonincreasing $f$ is similar.", "statement": "We assume:\n\u2022 $f$ is monotonic on $[a,b]$ [tc_1].\n\u2022 If $f$ is non-decreasing on $[a,b]$, then $f$ is integrable on $[a,b]$ [l6].\n\u2022 The proof for a non-increasing function is analogous to the non-decreasing case.\nTherefore, we conclude:\n\u2022 $f$ is integrable on $[a,b]$ [ts_1].", "dependencies": ["tc_1", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b))\n  (l6 : \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d), c \u2264 d \u2192 MonotoneOn g (Set.Icc c d) \u2192 \n    \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n      c = x 0 \u2227 d = x n \u2227 \n      (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n      (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n      let S_P := \u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j-1))\n      let s_P := \u2211 j in Finset.Ico 1 (n + 1), g (x (j-1)) * (x j - x (j-1))\n      abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) :\n  \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b : \u211d) (f : \u211d \u2192 \u211d) \n  (h_le : a \u2264 b)\n  (h_mono : MonotoneOn f (Set.Icc a b) \u2228 AntitoneOn f (Set.Icc a b))\n  (l6 : \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d), c \u2264 d \u2192 MonotoneOn g (Set.Icc c d) \u2192 \n    \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n      c = x 0 \u2227 d = x n \u2227 \n      (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n      (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n      let S_P := \u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j-1))\n      let s_P := \u2211 j in Finset.Ico 1 (n + 1), g (x (j-1)) * (x j - x (j-1))\n      abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) :\n  \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), \n    a = x 0 \u2227 b = x n \u2227 \n    (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n    (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n    let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1))\n    let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1))\n    abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2 := by\n  have h_main : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n    cases h_mono with\n    | inl h_mono =>\n      -- Case 1: f is monotone on [a, b]\n      have h1 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n        -- Use the given lemma l6 directly with g = f, c = a, d = b\n        have h2 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n          -- Apply the given lemma l6\n          have h3 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n            -- Use the given lemma l6 with g = f, c = a, d = b\n            have h4 : a \u2264 b := h_le\n            have h5 : MonotoneOn f (Set.Icc a b) := h_mono\n            specialize l6 f a b h4 h5\n            -- Obtain I and the required properties\n            obtain \u27e8I, hI\u27e9 := l6\n            refine' \u27e8I, _\u27e9\n            intro \u03b5 h\u03b5\n            -- Obtain n, x, etc., from l6\n            have h6 := hI \u03b5 (by linarith)\n            obtain \u27e8n, x, hx1, hx2, hx3, hx4, hx5\u27e9 := h6\n            refine' \u27e8n, x, hx1, hx2, hx3, hx4, _\u27e9\n            dsimp at hx5 \u22a2\n            <;>\n            (try norm_num at hx5 \u22a2) <;>\n            (try simp_all) <;>\n            (try linarith) <;>\n            (try ring_nf at hx5 \u22a2) <;>\n            (try norm_num at hx5 \u22a2) <;>\n            (try simp_all [abs_lt]) <;>\n            (try linarith)\n          exact h3\n        exact h2\n      exact h1\n    | inr h_mono =>\n      -- Case 2: f is antitone on [a, b]\n      -- Define g(x) = -f(x)\n      have h1 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), f (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n        -- Define g(x) = -f(x)\n        let g : \u211d \u2192 \u211d := fun x => -f x\n        -- Prove that g is monotone on [a, b]\n        have h2 : MonotoneOn g (Set.Icc a b) := by\n          intro x hx y hy hxy\n          have h3 : x \u2208 Set.Icc a b := hx\n          have h4 : y \u2208 Set.Icc a b := hy\n          have h5 : x \u2264 y := hxy\n          have h6 : AntitoneOn f (Set.Icc a b) := h_mono\n          have h7 : f x \u2265 f y := h6 h3 h4 h5\n          have h8 : g x \u2264 g y := by\n            simp only [g]\n            linarith\n          exact h8\n        -- Use l6 with g, c = a, d = b\n        have h3 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), g (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n          have h4 : a \u2264 b := h_le\n          have h5 : MonotoneOn g (Set.Icc a b) := h2\n          have h6 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), g (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n            -- Use l6 with g, a, b\n            have h7 : \u2203 I : \u211d, \u2200 \u03b5 > 0, \u2203 (n : \u2115) (x : \u2115 \u2192 \u211d), a = x 0 \u2227 b = x n \u2227 (\u2200 i j, i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227 (\u2200 i j, i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227 (let S_P := \u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j-1)); let s_P := \u2211 j in Finset.Ico 1 (n + 1), g (x (j-1)) * (x j - x (j-1)); abs (S_P - I) < \u03b5 / 2 \u2227 abs (s_P - I) < \u03b5 / 2) := by\n              have h8 : a \u2264 b := h_le\n              have h9 : MonotoneOn g (Set.Icc a b) := h2\n              specialize l6 g a b h8 h9\n              -- Obtain I and the required properties\n              obtain \u27e8I, hI\u27e9 := l6\n              refine' \u27e8I, _\u27e9\n              intro \u03b5 h\u03b5\n              -- Obtain n, x, etc., from l6\n              have h10 := hI \u03b5 (by linarith)\n              obtain \u27e8n, x, hx1, hx2, hx3, hx4, hx5\u27e9 := h10\n              refine' \u27e8n, x, hx1, hx2, hx3, hx4, _\u27e9\n              dsimp at hx5 \u22a2\n              <;>\n              (try norm_num at hx5 \u22a2) <;>\n              (try simp_all) <;>\n              (try linarith) <;>\n              (try ring_nf at hx5 \u22a2) <;>\n              (try norm_num at hx5 \u22a2) <;>\n              (try simp_all [abs_lt]) <;>\n              (try linarith)\n            exact h7\n          exact h6\n        -- Obtain I' and the partition for g\n        obtain \u27e8I', hI'\u27e9 := h3\n        -- Set I = -I'\n        use -I'\n        intro \u03b5 h\u03b5\n        -- Obtain n, x, etc., for g\n        have h4 := hI' \u03b5 (by linarith)\n        obtain \u27e8n, x, hx1, hx2, hx3, hx4, hx5\u27e9 := h4\n        refine' \u27e8n, x, hx1, hx2, hx3, hx4, _\u27e9\n        dsimp at hx5 \u22a2\n        have h5 : abs (\u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I') < \u03b5 / 2 := hx5.1\n        have h6 : abs (\u2211 j in Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I') < \u03b5 / 2 := hx5.2\n        have h7 : (\u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1))) = - (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) := by\n          calc\n            (\u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1))) = \u2211 j in Finset.Ico 1 (n + 1), (-f (x j)) * (x j - x (j - 1)) := by\n              apply Finset.sum_congr rfl\n              intro j _\n              simp only [g]\n              <;> ring_nf\n            _ = \u2211 j in Finset.Ico 1 (n + 1), - (f (x j) * (x j - x (j - 1))) := by\n              apply Finset.sum_congr rfl\n              intro j _\n              ring_nf\n            _ = - (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) := by\n              rw [Finset.sum_neg_distrib]\n        have h8 : (\u2211 j in Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1))) = - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := by\n          calc\n            (\u2211 j in Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1))) = \u2211 j in Finset.Ico 1 (n + 1), (-f (x (j - 1))) * (x j - x (j - 1)) := by\n              apply Finset.sum_congr rfl\n              intro j _\n              simp only [g]\n              <;> ring_nf\n            _ = \u2211 j in Finset.Ico 1 (n + 1), - (f (x (j - 1)) * (x j - x (j - 1))) := by\n              apply Finset.sum_congr rfl\n              intro j _\n              ring_nf\n            _ = - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := by\n              rw [Finset.sum_neg_distrib]\n        constructor\n        \u00b7 -- Prove abs (S_P - I) < \u03b5 / 2\n          have h9 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - (-I')) < \u03b5 / 2 := by\n            have h10 : abs (\u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I') < \u03b5 / 2 := h5\n            have h11 : (\u2211 j in Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1))) = - (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) := h7\n            rw [h11] at h10\n            have h12 : abs (- (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - I') < \u03b5 / 2 := h10\n            have h13 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) + I') < \u03b5 / 2 := by\n              calc\n                abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) + I') = abs (-(- (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - I')) := by\n                  ring_nf\n                  <;> simp [abs_neg]\n                _ = abs (- (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))) - I') := by\n                  simp [abs_neg]\n                _ < \u03b5 / 2 := h12\n            have h14 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - (-I')) = abs (\u2211 j in Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) + I') := by\n              ring_nf at *\n              <;> simp [abs_sub_comm]\n              <;> linarith\n            rw [h14]\n            exact h13\n          simpa [sub_eq_add_neg] using h9\n        \u00b7 -- Prove abs (s_P - I) < \u03b5 / 2\n          have h9 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - (-I')) < \u03b5 / 2 := by\n            have h10 : abs (\u2211 j in Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I') < \u03b5 / 2 := h6\n            have h11 : (\u2211 j in Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1))) = - (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) := h8\n            rw [h11] at h10\n            have h12 : abs (- (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) - I') < \u03b5 / 2 := h10\n            have h13 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) + I') < \u03b5 / 2 := by\n              calc\n                abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) + I') = abs (-(- (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) - I')) := by\n                  ring_nf\n                  <;> simp [abs_neg]\n                _ = abs (- (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))) - I') := by\n                  simp [abs_neg]\n                _ < \u03b5 / 2 := h12\n            have h14 : abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - (-I')) = abs (\u2211 j in Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) + I') := by\n              ring_nf at *\n              <;> simp [abs_sub_comm]\n              <;> linarith\n            rw [h14]\n            exact h13\n          simpa [sub_eq_add_neg] using h9\n      exact h1\n  obtain \u27e8I, hI\u27e9 := h_main\n  refine' \u27e8I, _\u27e9\n  intro \u03b5 h\u03b5\n  obtain \u27e8n, x, hx1, hx2, hx3, hx4, hx5\u27e9 := hI \u03b5 h\u03b5\n  refine' \u27e8n, x, hx1, hx2, hx3, hx4, _\u27e9\n  simpa using hx5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 150, "column": 164, "endLine": 152, "endColumn": 36, "data": "unsolved goals\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nl6 :\n  \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d),\n    c \u2264 d \u2192\n      MonotoneOn g (Set.Icc c d) \u2192\n        \u2203 I,\n          \u2200 \u03b5 > 0,\n            \u2203 n x,\n              c = x 0 \u2227\n                d = x n \u2227\n                  (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n                    (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n                      let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n                      let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n                      |S_P - I| < \u03b5 / 2 \u2227 |s_P - I| < \u03b5 / 2\nh_mono : AntitoneOn f (Set.Icc a b)\ng : \u211d \u2192 \u211d := fun x => -f x\nh2 : MonotoneOn g (Set.Icc a b)\nI' : \u211d\nhI' :\n  \u2200 \u03b5 > 0,\n    \u2203 n x,\n      a = x 0 \u2227\n        b = x n \u2227\n          (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n            (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n              let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n              let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n              |S_P - I'| < \u03b5 / 2 \u2227 |s_P - I'| < \u03b5 / 2\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nn : \u2115\nx : \u2115 \u2192 \u211d\nhx1 : a = x 0\nhx2 : b = x n\nhx3 : \u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j\nhx4 : \u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j\nhx5 :\n  |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2 \u2227\n    |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh5 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh6 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh7 : \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) = -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))\nh8 :\n  \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) =\n    -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))\nh10 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh11 : \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) = -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))\nh12 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\n\u22a2 |\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * x x_1 - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * x (x_1 - 1) + I'| =\n    |I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))|"}, {"line": 153, "column": 95, "endLine": 154, "endColumn": 32, "data": "unsolved goals\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nl6 :\n  \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d),\n    c \u2264 d \u2192\n      MonotoneOn g (Set.Icc c d) \u2192\n        \u2203 I,\n          \u2200 \u03b5 > 0,\n            \u2203 n x,\n              c = x 0 \u2227\n                d = x n \u2227\n                  (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n                    (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n                      let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n                      let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n                      |S_P - I| < \u03b5 / 2 \u2227 |s_P - I| < \u03b5 / 2\nh_mono : AntitoneOn f (Set.Icc a b)\ng : \u211d \u2192 \u211d := fun x => -f x\nh2 : MonotoneOn g (Set.Icc a b)\nI' : \u211d\nhI' :\n  \u2200 \u03b5 > 0,\n    \u2203 n x,\n      a = x 0 \u2227\n        b = x n \u2227\n          (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n            (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n              let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n              let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n              |S_P - I'| < \u03b5 / 2 \u2227 |s_P - I'| < \u03b5 / 2\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nn : \u2115\nx : \u2115 \u2192 \u211d\nhx1 : a = x 0\nhx2 : b = x n\nhx3 : \u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j\nhx4 : \u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j\nhx5 :\n  |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2 \u2227\n    |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh5 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh6 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh7 : \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) = -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))\nh8 :\n  \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) =\n    -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))\nh10 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh11 : \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) = -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))\nh12 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\n\u22a2 |I' + \u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))| =\n    |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1)) - I'|"}, {"line": 159, "column": 18, "endLine": 159, "endColumn": 26, "data": "linarith failed to find a contradiction\ncase h1.h\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nh_mono : AntitoneOn f (Set.Icc a b)\ng : \u211d \u2192 \u211d := fun x => -f x\nh2 : MonotoneOn g (Set.Icc a b)\nI' \u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nn : \u2115\nx : \u2115 \u2192 \u211d\nhx1 : a = x 0\nhx2 : b = x n\nhx3 : \u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j\nhx4 : \u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j\nh13 : |I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh12 : |-I' - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh11 :\n  \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x x_1) * (x x_1 - x (x_1 - 1)) =\n    -\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))\nh10 : |-I' - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh8 :\n  \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1)) =\n    -\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))\nh7 :\n  \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x x_1) * (x x_1 - x (x_1 - 1)) =\n    -\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))\nh6 : |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh5 : |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nhx5 :\n  |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2) \u2227\n    |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nhI' :\n  \u2200 \u03b5 > 0,\n    \u2203 n x,\n      a = x 0 \u2227\n        b = x n \u2227\n          (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n            (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n              |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), (-(f (x x_1) * x x_1) + f (x x_1) * x (x_1 - 1))| < \u03b5 * (1 / 2) \u2227\n                |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nl6 :\n  \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d),\n    c \u2264 d \u2192\n      MonotoneOn g (Set.Icc c d) \u2192\n        \u2203 I,\n          \u2200 \u03b5 > 0,\n            \u2203 n x,\n              c = x 0 \u2227\n                d = x n \u2227\n                  (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n                    (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n                      |\u2211 x_1 \u2208 Finset.Ico 1 (n + 1), g (x x_1) * (x x_1 - x (x_1 - 1)) - I| < \u03b5 / 2 \u2227\n                        |\u2211 x_1 \u2208 Finset.Ico 1 (n + 1), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1)) - I| < \u03b5 / 2\na\u271d :\n  |\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * x x_1 - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * x (x_1 - 1) + I'| <\n    |I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))|\n\u22a2 False failed"}, {"line": 171, "column": 176, "endLine": 173, "endColumn": 36, "data": "unsolved goals\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nl6 :\n  \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d),\n    c \u2264 d \u2192\n      MonotoneOn g (Set.Icc c d) \u2192\n        \u2203 I,\n          \u2200 \u03b5 > 0,\n            \u2203 n x,\n              c = x 0 \u2227\n                d = x n \u2227\n                  (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n                    (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n                      let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n                      let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n                      |S_P - I| < \u03b5 / 2 \u2227 |s_P - I| < \u03b5 / 2\nh_mono : AntitoneOn f (Set.Icc a b)\ng : \u211d \u2192 \u211d := fun x => -f x\nh2 : MonotoneOn g (Set.Icc a b)\nI' : \u211d\nhI' :\n  \u2200 \u03b5 > 0,\n    \u2203 n x,\n      a = x 0 \u2227\n        b = x n \u2227\n          (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n            (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n              let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n              let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n              |S_P - I'| < \u03b5 / 2 \u2227 |s_P - I'| < \u03b5 / 2\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nn : \u2115\nx : \u2115 \u2192 \u211d\nhx1 : a = x 0\nhx2 : b = x n\nhx3 : \u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j\nhx4 : \u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j\nhx5 :\n  |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2 \u2227\n    |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh5 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh6 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh7 : \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) = -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))\nh8 :\n  \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) =\n    -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))\nh10 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh11 :\n  \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) =\n    -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))\nh12 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\n\u22a2 |\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * x x_1 - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * x (x_1 - 1) +\n        I'| =\n    |I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))|"}, {"line": 174, "column": 101, "endLine": 175, "endColumn": 32, "data": "unsolved goals\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nl6 :\n  \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d),\n    c \u2264 d \u2192\n      MonotoneOn g (Set.Icc c d) \u2192\n        \u2203 I,\n          \u2200 \u03b5 > 0,\n            \u2203 n x,\n              c = x 0 \u2227\n                d = x n \u2227\n                  (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n                    (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n                      let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n                      let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n                      |S_P - I| < \u03b5 / 2 \u2227 |s_P - I| < \u03b5 / 2\nh_mono : AntitoneOn f (Set.Icc a b)\ng : \u211d \u2192 \u211d := fun x => -f x\nh2 : MonotoneOn g (Set.Icc a b)\nI' : \u211d\nhI' :\n  \u2200 \u03b5 > 0,\n    \u2203 n x,\n      a = x 0 \u2227\n        b = x n \u2227\n          (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n            (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n              let S_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1));\n              let s_P := \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1));\n              |S_P - I'| < \u03b5 / 2 \u2227 |s_P - I'| < \u03b5 / 2\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nn : \u2115\nx : \u2115 \u2192 \u211d\nhx1 : a = x 0\nhx2 : b = x n\nhx3 : \u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j\nhx4 : \u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j\nhx5 :\n  |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2 \u2227\n    |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh5 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh6 : |\u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh7 : \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x j) * (x j - x (j - 1)) = -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x j) * (x j - x (j - 1))\nh8 :\n  \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) =\n    -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))\nh10 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\nh11 :\n  \u2211 j \u2208 Finset.Ico 1 (n + 1), g (x (j - 1)) * (x j - x (j - 1)) =\n    -\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))\nh12 : |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I'| < \u03b5 / 2\n\u22a2 |I' + \u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1))| =\n    |-\u2211 j \u2208 Finset.Ico 1 (n + 1), f (x (j - 1)) * (x j - x (j - 1)) - I'|"}, {"line": 180, "column": 18, "endLine": 180, "endColumn": 26, "data": "linarith failed to find a contradiction\ncase h1.h\na b : \u211d\nf : \u211d \u2192 \u211d\nh_le : a \u2264 b\nh_mono : AntitoneOn f (Set.Icc a b)\ng : \u211d \u2192 \u211d := fun x => -f x\nh2 : MonotoneOn g (Set.Icc a b)\nI' \u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nn : \u2115\nx : \u2115 \u2192 \u211d\nhx1 : a = x 0\nhx2 : b = x n\nhx3 : \u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j\nhx4 : \u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j\nh13 : |I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh12 : |-I' - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh11 :\n  \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1)) =\n    -\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))\nh10 : |-I' - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh8 :\n  \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1)) =\n    -\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))\nh7 :\n  \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), -f (x x_1) * (x x_1 - x (x_1 - 1)) =\n    -\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x x_1) * (x x_1 - x (x_1 - 1))\nh6 : |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nh5 : |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nhx5 :\n  |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x x_1) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2) \u2227\n    |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nhI' :\n  \u2200 \u03b5 > 0,\n    \u2203 n x,\n      a = x 0 \u2227\n        b = x n \u2227\n          (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n            (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n              |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), (-(f (x x_1) * x x_1) + f (x x_1) * x (x_1 - 1))| < \u03b5 * (1 / 2) \u2227\n                |-I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))| < \u03b5 * (1 / 2)\nl6 :\n  \u2200 (g : \u211d \u2192 \u211d) (c d : \u211d),\n    c \u2264 d \u2192\n      MonotoneOn g (Set.Icc c d) \u2192\n        \u2203 I,\n          \u2200 \u03b5 > 0,\n            \u2203 n x,\n              c = x 0 \u2227\n                d = x n \u2227\n                  (\u2200 (i j : \u2115), i \u2264 j \u2192 j \u2264 n \u2192 x i \u2264 x j) \u2227\n                    (\u2200 (i j : \u2115), i < j \u2192 j \u2264 n \u2192 x i < x j) \u2227\n                      |\u2211 x_1 \u2208 Finset.Ico 1 (n + 1), g (x x_1) * (x x_1 - x (x_1 - 1)) - I| < \u03b5 / 2 \u2227\n                        |\u2211 x_1 \u2208 Finset.Ico 1 (n + 1), g (x (x_1 - 1)) * (x x_1 - x (x_1 - 1)) - I| < \u03b5 / 2\na\u271d :\n  |\u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * x x_1 - \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * x (x_1 - 1) +\n        I'| <\n    |I' + \u2211 x_1 \u2208 Finset.Ico 1 (1 + n), f (x (x_1 - 1)) * (x x_1 - x (x_1 - 1))|\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The monotonicity assumption is correctly captured as a disjunction of MonotoneOn and AntitoneOn, which properly represents the mathematical concept of monotonicity.", "The integrability lemma l6 correctly formalizes integrability using the constructive Riemann sum definition with epsilon-delta convergence, which is mathematically sound.", "The natural language mentions the analogous proof for non-increasing functions as a meta-statement, while the Lean formalization handles this structurally through the disjunction. The approach is valid but represents the concept differently.", "The conclusion correctly states integrability, but there's a structural issue: the Lean code only provides lemma l6 for the monotone case, yet needs to prove integrability for both monotone and antitone functions. The natural language suggests both cases are covered, but the Lean formalization is incomplete for the antitone case.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The monotonicity assumption is correctly captured as a disjunction of MonotoneOn and AntitoneOn, which properly represents the mathematical concept of monotonicity.', 'The integrability lemma l6 correctly formalizes integrability using the constructive Riemann sum definition with epsilon-delta convergence, which is mathematically sound.', 'The natural language mentions the analogous proof for non-increasing functions as a meta-statement, while the Lean formalization handles this structurally through the disjunction. The approach is valid but represents the concept differently.', \"The conclusion correctly states integrability, but there's a structural issue: the Lean code only provides lemma l6 for the monotone case, yet needs to prove integrability for both monotone and antitone functions. The natural language suggests both cases are covered, but the Lean formalization is incomplete for the antitone case.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    