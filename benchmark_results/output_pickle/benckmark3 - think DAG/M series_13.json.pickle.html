
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=5$ and the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, $a_n = 2^{n-1}+3^{n-1}$.

Proof: We will prove this by strong mathematical induction on $n$. First, for the base cases, we need to verify the formula holds for $n=1$ and $n=2$. For $n=1$, we are given $a_1=2$. The formula gives $a_1=2^{1-1}+3^{1-1}=2^0+3^0=1+1=2$. This holds. For $n=2$, we are given $a_2=5$. The formula gives $a_2=2^{2-1}+3^{2-1}=2^1+3^1=2+3=5$. This also holds. Now, for the inductive step, we assume the statement is true for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{j-1}+3^{j-1}$ for $1 \leq j \leq k$. We want to show the statement is true for $k+1$, i.e., $a_{k+1}=2^{k}+3^{k}$. From the recurrence relation, we have $a_{k+1}=5a_k-6a_{k-1}$. By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$. So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$. We expand this: $5 \cdot 2^{k-1} + 5 \cdot 3^{k-1} - 6 \cdot 2^{k-2} - 6 \cdot 3^{k-2}$. We can rewrite the coefficients. $5 \cdot 2^{k-1} = (2+3) \cdot 2^{k-1} = 2 \cdot 2^{k-1} + 3 \cdot 2^{k-1} = 2^k + 3 \cdot 2^{k-1}$. No, that's not right. $5 \cdot 2^{k-1} = 5 \cdot 2^{k-2} \cdot 2 = 10 \cdot 2^{k-2}$. We have $a_{k+1}=10 \cdot 2^{k-2} + 15 \cdot 3^{k-2} - 6 \cdot 2^{k-2} - 6 \cdot 3^{k-2}$. Combining like terms gives $(10-6) \cdot 2^{k-2} + (15-6) \cdot 3^{k-2} = 4 \cdot 2^{k-2} + 9 \cdot 3^{k-2}$. We can simplify this further: $4 \cdot 2^{k-2} = 2^2 \cdot 2^{k-2} = 2^k$. And $9 \cdot 3^{k-2} = 3^2 \cdot 3^{k-2} = 3^k$. Thus, $a_{k+1}=2^k+3^k$. This matches the formula for $n=k+1$. By the principle of strong mathematical induction, the statement is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=5$", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of integers with first terms $a_1=2$ and $a_2=5$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2124)\n(tc_1 : a 1 = 2 \u2227 a 2 = 5)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'a : \u2115 \u2192 \u2124' perfectly captures the mathematical concept of a sequence of integers (a_n)", "The Lean condition 'a 1 = 2 \u2227 a 2 = 5' perfectly captures both initial conditions a_1 = 2 and a_2 = 5, combining them with logical conjunction which is mathematically equivalent"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "and the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of integers with first terms $a_1=2$ and $a_2=5$ [tc_1].\n\u2022 For all integers $n \\geq 3$, the sequence $(a_n)$ follows the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2) \n  (h2 : a 2 = 5) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n - 1) + 3^(n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean headers correctly capture the sequence definition and initial conditions. The sequence type (\u2115 \u2192 \u2124) properly represents a sequence of integers, and h1, h2 match the initial terms a\u2081=2 and a\u2082=5.", "The recurrence relation in h3 perfectly matches the natural language condition, using the same formula a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3.", "The natural language states there are no new derived facts or conclusions - it only establishes the given conditions. However, the Lean formalization introduces a major new conclusion that a_n = 2^(n-1) + 3^(n-1), which is not mentioned anywhere in the natural language statement. This is a significant addition that changes the logical meaning."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean headers correctly capture the sequence definition and initial conditions. The sequence type (\u2115 \u2192 \u2124) properly represents a sequence of integers, and h1, h2 match the initial terms a\u2081=2 and a\u2082=5.', 'The recurrence relation in h3 perfectly matches the natural language condition, using the same formula a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3.', 'The natural language states there are no new derived facts or conclusions - it only establishes the given conditions. However, the Lean formalization introduces a major new conclusion that a_n = 2^(n-1) + 3^(n-1), which is not mentioned anywhere in the natural language statement. This is a significant addition that changes the logical meaning.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, we are given $a_1=2$. The formula gives $a_1=2^{1-1}+3^{1-1}=2^0+3^0=1+1=2$. This holds.", "statement": "We assume:\n\u2022 The first term of the sequence is $a_1=2$ [tc_1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for n=1, as $2^{1-1}+3^{1-1} = 2$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u2124) (tc_1 : a 1 = 2) :\n  2^(1-1) + 3^(1-1) = 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u2124) (tc_1 : a 1 = 2) :\n  2^(1-1) + 3^(1-1) = 2 := by\n  have h\u2081 : 2^(1-1) = 1 := by\n    norm_num\n    <;> simp [pow_zero]\n    <;> norm_num\n  \n  have h\u2082 : 3^(1-1) = 1 := by\n    norm_num\n    <;> simp [pow_zero]\n    <;> norm_num\n  \n  have h\u2083 : 2^(1-1) + 3^(1-1) = 2 := by\n    rw [h\u2081, h\u2082]\n    <;> norm_num\n  \n  apply h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The premise is correctly formalized - the sequence a and the condition a 1 = 2 are properly represented in Lean.", "The conclusion has a major inconsistency. The natural language concludes that the formula a_n = 2^(n-1) + 3^(n-1) holds for n=1, but the Lean formalization only proves the arithmetic identity 2^(1-1) + 3^(1-1) = 2 without connecting it to the sequence a. The key logical component establishing that a 1 = 2^(1-1) + 3^(1-1) is missing."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The premise is correctly formalized - the sequence a and the condition a 1 = 2 are properly represented in Lean.', 'The conclusion has a major inconsistency. The natural language concludes that the formula a_n = 2^(n-1) + 3^(n-1) holds for n=1, but the Lean formalization only proves the arithmetic identity 2^(1-1) + 3^(1-1) = 2 without connecting it to the sequence a. The key logical component establishing that a 1 = 2^(1-1) + 3^(1-1) is missing.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we are given $a_2=5$. The formula gives $a_2=2^{2-1}+3^{2-1}=2^1+3^1=2+3=5$. This also holds.", "statement": "We assume:\n\u2022 The second term of the sequence is $a_2=5$ [tc_1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for n=2, as $2^{2-1}+3^{2-1} = 5$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u211d) (h : a 2 = 5) : \n  2^(2-1 : \u2115) + 3^(2-1 : \u2115) = 5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u211d) (h : a 2 = 5) : \n  2^(2-1 : \u2115) + 3^(2-1 : \u2115) = 5 := by\n  have h\u2081 : 2^(2-1 : \u2115) + 3^(2-1 : \u2115) = 5 := by\n    norm_num\n    <;> rfl\n  \n  apply h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The assumption that a\u2082 = 5 is correctly captured as hypothesis h : a 2 = 5 in the Lean formalization.", "The Lean formalization only proves the arithmetic calculation 2^(2-1) + 3^(2-1) = 5, but fails to establish the key logical connection that a 2 = 2^(2-1) + 3^(2-1), which is what the natural language is actually trying to conclude. The natural language wants to verify the formula holds for the sequence, not just compute the arithmetic."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The assumption that a\u2082 = 5 is correctly captured as hypothesis h : a 2 = 5 in the Lean formalization.', 'The Lean formalization only proves the arithmetic calculation 2^(2-1) + 3^(2-1) = 5, but fails to establish the key logical connection that a 2 = 2^(2-1) + 3^(2-1), which is what the natural language is actually trying to conclude. The natural language wants to verify the formula holds for the sequence, not just compute the arithmetic.']"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now, for the inductive step, we assume the statement is true for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{j-1}+3^{j-1}$ for $1 \\leq j \\leq k$.", "statement": "Definition:\n\u2022 Let $k$ be an integer such that $k \\geq 2$, and assume as the strong induction hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ is true [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\nvariable (k : \u2115)\nvariable (h_k : k \u2265 2)\nvariable (h_base1 : a 1 = 2)\nvariable (h_base2 : a 2 = 5)\nvariable (h_rec : \u2200 n, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\nvariable (h_def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies k as an integer, but Lean uses \u2115 (natural numbers). While \u2115 \u2286 \u2124 and the condition k \u2265 2 ensures k is a positive integer, this is a slight type difference from the original specification.", "The Lean formalization `h_def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)` perfectly captures the natural language condition about the formula being true for all integers j with 1 \u2264 j \u2264 k.", "The strong induction hypothesis [def_1] is established through the variable h_def_1 in Lean, which directly corresponds to the conclusion. The additional variables (h_base1, h_base2, h_rec) provide extra context about the sequence but don't contradict the establishment of the hypothesis."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relation, we have $a_{k+1}=5a_k-6a_{k-1}$.", "statement": "We assume:\n\u2022 For all integers $n \\geq 3$, the sequence $(a_n)$ follows the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ [tc_2].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 Since $k \\geq 2$, it follows that $k+1 \\geq 3$, so the recurrence relation applies, giving $a_{k+1}=5a_k-6a_{k-1}$ [l3].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115) \n  (h_k : k \u2265 2)\n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a (k + 1) = 5 * a k - 6 * a (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115) \n  (h_k : k \u2265 2)\n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a (k + 1) = 5 * a k - 6 * a (k - 1) := by\n  have h\u2081 : k + 1 \u2265 3 := by\n    have h\u2082 : k \u2265 2 := h_k\n    omega\n  \n  have h\u2082 : a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := by\n    have h\u2083 : a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := by\n      have h\u2084 : (k + 1 : \u2115) \u2265 3 := by exact_mod_cast h\u2081\n      have h\u2085 : a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := h_rec (k + 1) h\u2084\n      exact h\u2085\n    exact h\u2083\n  \n  have h\u2083 : (k + 1) - 1 = k := by\n    have h\u2084 : (k + 1) - 1 = k := by\n      omega\n    exact h\u2084\n  \n  have h\u2084 : (k + 1) - 2 = k - 1 := by\n    have h\u2085 : (k + 1) - 2 = k - 1 := by\n      cases k with\n      | zero => contradiction -- k cannot be zero since h_k : k \u2265 2\n      | succ k' =>\n        cases k' with\n        | zero => contradiction -- k cannot be one since h_k : k \u2265 2\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc] at h_k \u22a2\n          <;> ring_nf at *\n          <;> omega\n    exact h\u2085\n  \n  have h\u2085 : a (k + 1) = 5 * a k - 6 * a (k - 1) := by\n    have h\u2086 : a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := h\u2082\n    have h\u2087 : (k + 1) - 1 = k := h\u2083\n    have h\u2088 : (k + 1) - 2 = k - 1 := h\u2084\n    have h\u2089 : a (k + 1) = 5 * a k - 6 * a (k - 1) := by\n      calc\n        a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := h\u2086\n        _ = 5 * a k - 6 * a ((k + 1) - 2) := by rw [h\u2087]\n        _ = 5 * a k - 6 * a (k - 1) := by rw [h\u2088]\n    exact h\u2089\n  \n  exact h\u2085", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The recurrence relation uses natural numbers (\u2115) in Lean instead of integers as stated in natural language. However, since the constraint n \u2265 3 makes this effectively equivalent for the relevant domain, this is a minor notational difference.", "The constraint k \u2265 2 is perfectly captured, with k appropriately typed as a natural number which aligns with the mathematical context.", "The logical conclusion and reasoning are perfectly captured. The goal statement correctly represents the application of the recurrence relation to k+1.", "The sequence is defined over natural numbers (\u2115 \u2192 \u211d) rather than integers as suggested in natural language. This is a minor structural difference but doesn't affect the mathematical meaning in this context."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The recurrence relation uses natural numbers (\u2115) in Lean instead of integers as stated in natural language. However, since the constraint n \u2265 3 makes this effectively equivalent for the relevant domain, this is a minor notational difference.', 'The constraint k \u2265 2 is perfectly captured, with k appropriately typed as a natural number which aligns with the mathematical context.', 'The logical conclusion and reasoning are perfectly captured. The goal statement correctly represents the application of the recurrence relation to k+1.', \"The sequence is defined over natural numbers (\u2115 \u2192 \u211d) rather than integers as suggested in natural language. This is a minor structural difference but doesn't affect the mathematical meaning in this context.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$.", "statement": "We assume:\n\u2022 For all integers $j$ with $1 \\leq j \\leq k$ (where $k \\geq 2$), $a_j = 2^{j-1}+3^{j-1}$ [def_1].\nTherefore, we conclude:\n\u2022 The hypothesis applies to $j=k$ and $j=k-1$, giving $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$ [l4].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) :\n  (a k = 2^(k - 1) + 3^(k - 1)) \u2227 (a (k - 1) = 2^(k - 2) + 3^(k - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_def_1 : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) :\n  (a k = 2^(k - 1) + 3^(k - 1)) \u2227 (a (k - 1) = 2^(k - 2) + 3^(k - 2)) := by\n  have h\u2081 : a k = (2:\u211d)^(k - 1) + (3:\u211d)^(k - 1) := by\n    have h\u2082 : 1 \u2264 (k : \u2115) \u2227 (k : \u2115) \u2264 k := by\n      constructor <;>\n      (try norm_num) <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2083 : a k = (2 : \u211d) ^ (k - 1) + (3 : \u211d) ^ (k - 1) := by\n      have h\u2084 := h_def_1 k h\u2082\n      norm_cast at h\u2084 \u22a2\n      <;>\n      (try simp_all [pow_succ]) <;>\n      (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n      (try simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]) <;>\n      (try ring_nf at * <;> norm_num at * <;> linarith)\n    exact h\u2083\n  \n  have h\u2082 : 1 \u2264 (k - 1 : \u2115) := by\n    have h\u2083 : k \u2265 2 := h_k\n    have h\u2084 : k - 1 \u2265 1 := by\n      have h\u2085 : k \u2265 2 := h_k\n      omega\n    exact h\u2084\n  \n  have h\u2083 : (k - 1 : \u2115) \u2264 k := by\n    have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n      have h\u2085 : k - 1 \u2264 k := by\n        omega\n      exact h\u2085\n    exact h\u2084\n  \n  have h\u2084 : a (k - 1) = (2:\u211d)^((k - 1 : \u2115) - 1) + (3:\u211d)^((k - 1 : \u2115) - 1) := by\n    have h\u2085 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      constructor\n      \u00b7 exact h\u2082\n      \u00b7 exact h\u2083\n    have h\u2086 := h_def_1 (k - 1) h\u2085\n    norm_cast at h\u2086 \u22a2\n    <;>\n    (try simp_all [pow_succ]) <;>\n    (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n    (try simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]) <;>\n    (try ring_nf at * <;> norm_num at * <;> linarith)\n  \n  have h\u2085 : (k - 1 : \u2115) - 1 = k - 2 := by\n    have h\u2085\u2081 : (k - 1 : \u2115) - 1 = k - 2 := by\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    exact h\u2085\u2081\n  \n  have h\u2086 : a (k - 1) = (2:\u211d)^(k - 2) + (3:\u211d)^(k - 2) := by\n    rw [h\u2084]\n    have h\u2087 : ((k - 1 : \u2115) - 1 : \u2115) = k - 2 := by\n      exact h\u2085\n    have h\u2088 : (2:\u211d)^((k - 1 : \u2115) - 1 : \u2115) = (2:\u211d)^(k - 2 : \u2115) := by\n      norm_cast\n      <;> simp [h\u2087]\n      <;> ring_nf\n      <;> norm_num\n      <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    have h\u2089 : (3:\u211d)^((k - 1 : \u2115) - 1 : \u2115) = (3:\u211d)^(k - 2 : \u2115) := by\n      norm_cast\n      <;> simp [h\u2087]\n      <;> ring_nf\n      <;> norm_num\n      <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    rw [h\u2088, h\u2089]\n    <;> norm_num\n    <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_main : (a k = 2^(k - 1) + 3^(k - 1)) \u2227 (a (k - 1) = 2^(k - 2) + 3^(k - 2)) := by\n    refine' \u27e8_, _\u27e9\n    \u00b7 -- Prove a k = 2^(k - 1) + 3^(k - 1)\n      norm_cast at h\u2081 \u22a2\n      <;>\n      (try simp_all [pow_succ]) <;>\n      (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n      (try simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]) <;>\n      (try ring_nf at * <;> norm_num at * <;> linarith)\n    \u00b7 -- Prove a (k - 1) = 2^(k - 2) + 3^(k - 2)\n      norm_cast at h\u2086 \u22a2\n      <;>\n      (try simp_all [pow_succ]) <;>\n      (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n      (try simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_pow]) <;>\n      (try ring_nf at * <;> norm_num at * <;> linarith)\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the logical components from the natural language. The assumption about the formula for a_j with the constraint 1 \u2264 j \u2264 k is properly formalized, the constraint k \u2265 2 is included, and the conclusion correctly states the two specific instances (for j=k and j=k-1) as a conjunction. The use of natural numbers instead of integers and reals as codomain are reasonable mathematical choices that don't alter the semantic meaning of the statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$.", "statement": "We assume:\n\u2022 $a_{k+1}=5a_k-6a_{k-1}$ [l3].\n\u2022 $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_l3 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h_l4_1 : a k = 2^(k - 1) + 3^(k - 1))\n  (h_l4_2 : a (k - 1) = 2^(k - 2) + 3^(k - 2)) :\n  a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_l3 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h_l4_1 : a k = 2^(k - 1) + 3^(k - 1))\n  (h_l4_2 : a (k - 1) = 2^(k - 2) + 3^(k - 2)) :\n  a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)) := by\n  have h_main : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)) := by\n    rw [h_l3]\n    rw [h_l4_1]\n    rw [h_l4_2]\n    <;> norm_cast\n    <;> simp [pow_add, pow_one, mul_add, mul_comm, mul_left_comm, mul_assoc]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_add, mul_comm, mul_left_comm, mul_assoc]\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The recurrence relation, the two formula assumptions, and the conclusion are all accurately represented. The additional type declarations and the constraint k \u2265 2 are mathematically appropriate additions that don't contradict the natural language but ensure the formalization is well-defined in Lean's type system. The logical structure properly reflects that this is a substitution step where the conclusion follows from the given assumptions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "$a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$.", "statement": "We assume:\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l5].\nTherefore, we conclude:\n\u2022 $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$ [l6].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (k : \u2115)\n  (h_k : k \u2265 2) :\n  5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2)) = \n  10 * 2^(k-2) + 15 * 3^(k-2) - 6 * 2^(k-2) - 6 * 3^(k-2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (k : \u2115)\n  (h_k : k \u2265 2) :\n  5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2)) = \n  10 * 2^(k-2) + 15 * 3^(k-2) - 6 * 2^(k-2) - 6 * 3^(k-2) := by\n  have h2 : 2 ^ (k - 1) = 2 * 2 ^ (k - 2) := by\n    have h\u2082 : k - 1 = (k - 2) + 1 := by\n      have h\u2083 : k \u2265 2 := h_k\n      have h\u2084 : k - 2 + 2 = k := by\n        have h\u2085 : k \u2265 2 := h_k\n        omega\n      omega\n    rw [h\u2082]\n    simp [pow_add, pow_one, mul_comm]\n    <;> ring_nf\n    <;> simp [pow_add, pow_one, mul_comm]\n    <;> ring_nf\n  \n  have h3 : 3 ^ (k - 1) = 3 * 3 ^ (k - 2) := by\n    have h\u2083 : k - 1 = (k - 2) + 1 := by\n      have h\u2084 : k \u2265 2 := h_k\n      have h\u2085 : k - 2 + 2 = k := by\n        have h\u2086 : k \u2265 2 := h_k\n        omega\n      omega\n    rw [h\u2083]\n    simp [pow_add, pow_one, mul_comm]\n    <;> ring_nf\n    <;> simp [pow_add, pow_one, mul_comm]\n    <;> ring_nf\n  \n  have h4 : 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) := by\n    rw [h2, h3]\n    <;> ring_nf\n    <;> simp [pow_add, pow_one, mul_assoc, mul_comm, mul_left_comm]\n    <;> norm_num\n    <;> ring_nf at *\n    <;> omega\n  \n  have h5 : 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) := by\n    rw [h4]\n    <;>\n    (try omega) <;>\n    (try ring_nf) <;>\n    (try simp_all [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib]) <;>\n    (try omega)\n  \n  have h6 : 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) := by\n    have h\u2086 : 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) = 6 * 2 ^ (k - 2) + 6 * 3 ^ (k - 2) := by\n      ring_nf\n      <;> simp [Nat.mul_add, Nat.add_mul]\n      <;> ring_nf\n    rw [h\u2086]\n    <;>\n    (try omega) <;>\n    (try ring_nf) <;>\n    (try simp_all [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib]) <;>\n    (try omega)\n    <;>\n    (try\n      {\n        have h\u2087 : 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) \u2265 6 * 2 ^ (k - 2) + 6 * 3 ^ (k - 2) := by\n          have h\u2088 : 10 * 2 ^ (k - 2) \u2265 6 * 2 ^ (k - 2) := by\n            have h\u2089 : 10 \u2265 6 := by norm_num\n            have h\u2081\u2080 : 2 ^ (k - 2) \u2265 0 := by positivity\n            nlinarith\n          have h\u2081\u2081 : 15 * 3 ^ (k - 2) \u2265 6 * 3 ^ (k - 2) := by\n            have h\u2081\u2082 : 15 \u2265 6 := by norm_num\n            have h\u2081\u2083 : 3 ^ (k - 2) \u2265 0 := by positivity\n            nlinarith\n          nlinarith\n        omega\n      })\n  \n  have h_main : 5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2)) = 10 * 2^(k-2) + 15 * 3^(k-2) - 6 * 2^(k-2) - 6 * 3^(k-2) := by\n    rw [h5]\n    <;> rw [h6]\n    <;>\n    (try omega) <;>\n    (try ring_nf) <;>\n    (try simp_all [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib]) <;>\n    (try omega)\n  \n  rw [h_main]\n  <;>\n  (try omega) <;>\n  (try ring_nf) <;>\n  (try simp_all [Nat.mul_sub_left_distrib, Nat.mul_sub_right_distrib]) <;>\n  (try omega)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the exact mathematical equality being demonstrated in the natural language, with proper operator precedence and notation.", "The additional constraint k \u2265 2 is a reasonable mathematical requirement that ensures well-definedness of the expressions, which is consistent with the implicit assumptions in the natural language.", "The theorem structure appropriately formalizes the logical relationship shown in the natural language where one expression is concluded to equal another through algebraic manipulation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Combining like terms gives $(10-6) \\cdot 2^{k-2} + (15-6) \\cdot 3^{k-2} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$.", "statement": "We assume:\n\u2022 $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$ [l7].", "dependencies": ["l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_l6 : 5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2)) = \n          10 * 2^(k-2) + 15 * 3^(k-2) - 6 * 2^(k-2) - 6 * 3^(k-2)) :\n  4 * 2^(k-2) + 9 * 3^(k-2) = 2^k + 3^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_l6 : 5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2)) = \n          10 * 2^(k-2) + 15 * 3^(k-2) - 6 * 2^(k-2) - 6 * 3^(k-2)) :\n  4 * 2^(k-2) + 9 * 3^(k-2) = 2^k + 3^k := by\n  have h2_pow : 2^k = 4 * 2^(k - 2) := by\n    have h\u2081 : k \u2265 2 := h_k\n    have h\u2082 : k - 2 + 2 = k := by\n      have h\u2083 : k \u2265 2 := h_k\n      omega\n    calc\n      2 ^ k = 2 ^ (k - 2 + 2) := by rw [h\u2082]\n      _ = 2 ^ (k - 2) * 2 ^ 2 := by rw [pow_add]\n      _ = 2 ^ (k - 2) * 4 := by norm_num\n      _ = 4 * 2 ^ (k - 2) := by ring\n  \n  have h3_pow : 3^k = 9 * 3^(k - 2) := by\n    have h\u2081 : k \u2265 2 := h_k\n    have h\u2082 : k - 2 + 2 = k := by\n      have h\u2083 : k \u2265 2 := h_k\n      omega\n    calc\n      3 ^ k = 3 ^ (k - 2 + 2) := by rw [h\u2082]\n      _ = 3 ^ (k - 2) * 3 ^ 2 := by rw [pow_add]\n      _ = 3 ^ (k - 2) * 9 := by norm_num\n      _ = 9 * 3 ^ (k - 2) := by ring\n  \n  have h_main : 4 * 2^(k - 2) + 9 * 3^(k - 2) = 2^k + 3^k := by\n    have h\u2081 : 2 ^ k = 4 * 2 ^ (k - 2) := h2_pow\n    have h\u2082 : 3 ^ k = 9 * 3 ^ (k - 2) := h3_pow\n    have h\u2083 : 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) = 2 ^ k + 3 ^ k := by\n      calc\n        4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) = 2 ^ k + 3 ^ k := by\n          rw [h\u2081, h\u2082]\n          <;> ring_nf\n        _ = 2 ^ k + 3 ^ k := by rfl\n    exact h\u2083\n  \n  rw [h_main]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The assumption in the Lean formalization uses a different left-hand side expression (5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2))) compared to the natural language which directly states a_{k+1} equals the expanded form. While these might be mathematically equivalent in some broader context, the natural language doesn't establish this relationship.", "The conclusion in the Lean formalization proves that 4 * 2^(k-2) + 9 * 3^(k-2) = 2^k + 3^k, but the natural language only concludes that a_{k+1} = 4 * 2^(k-2) + 9 * 3^(k-2). The relationship to 2^k + 3^k is not mentioned in the natural language, making this a significant addition that changes the logical meaning of what's being proven."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The assumption in the Lean formalization uses a different left-hand side expression (5 * (2^(k-1) + 3^(k-1)) - 6 * (2^(k-2) + 3^(k-2))) compared to the natural language which directly states a_{k+1} equals the expanded form. While these might be mathematically equivalent in some broader context, the natural language doesn't establish this relationship.\", \"The conclusion in the Lean formalization proves that 4 * 2^(k-2) + 9 * 3^(k-2) = 2^k + 3^k, but the natural language only concludes that a_{k+1} = 4 * 2^(k-2) + 9 * 3^(k-2). The relationship to 2^k + 3^k is not mentioned in the natural language, making this a significant addition that changes the logical meaning of what's being proven.\"]"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "We can simplify this further: $4 \\cdot 2^{k-2} = 2^2 \\cdot 2^{k-2} = 2^k$.", "statement": "We assume:\n\u2022 Basic properties of exponentiation.\nTherefore, we conclude:\n\u2022 $4 \\cdot 2^{k-2} = 2^k$ [l8].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 (k : \u2115) (hk : k \u2265 2) : 4 * 2^(k-2) = 2^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 (k : \u2115) (hk : k \u2265 2) : 4 * 2^(k-2) = 2^k := by\n  have h_add : 2 + (k - 2) = k := by\n    have h\u2081 : k - 2 + 2 = k := by\n      have h\u2082 : 2 \u2264 k := hk\n      have h\u2083 : k - 2 + 2 = k := by\n        rw [Nat.sub_add_cancel h\u2082]\n      exact h\u2083\n    have h\u2084 : 2 + (k - 2) = k := by\n      omega\n    exact h\u2084\n  \n  have h_pow_add : 2^k = 2^(2 + (k - 2)) := by\n    rw [\u2190 h_add]\n    <;> simp [pow_add]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_pow_split : 2^(2 + (k - 2)) = 2^2 * 2^(k - 2) := by\n    rw [pow_add]\n    <;> ring_nf\n    <;> simp [pow_add, pow_one, mul_assoc]\n    <;> norm_num\n    <;> linarith\n  \n  have h_two_sq : 2^2 = 4 := by\n    norm_num\n  \n  have h_final : 4 * 2^(k-2) = 2^k := by\n    calc\n      4 * 2 ^ (k - 2) = 2 ^ 2 * 2 ^ (k - 2) := by\n        norm_num\n      _ = 2 ^ (2 + (k - 2)) := by\n        rw [\u2190 pow_add]\n        <;> ring_nf\n      _ = 2 ^ k := by\n        rw [h_add]\n        <;> simp [pow_add]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equation 4 * 2^(k-2) = 2^k with the same label l8. The additional constraint k \u2265 2 and type declaration k : \u2115 are necessary technical details that ensure the statement is well-defined mathematically, as k-2 needs to be a valid natural number. The basic properties of exponentiation mentioned in the natural language are available through Lean's mathematical libraries. These extra conditions enhance mathematical rigor without contradicting the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "And $9 \\cdot 3^{k-2} = 3^2 \\cdot 3^{k-2} = 3^k$.", "statement": "We assume:\n\u2022 Basic properties of exponentiation.\nTherefore, we conclude:\n\u2022 $9 \\cdot 3^{k-2} = 3^k$ [l9].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 (k : \u2115) (hk : k \u2265 2) : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 (k : \u2115) (hk : k \u2265 2) : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^k := by\n  have h\u2081 : (k - 2 : \u2115) + 2 = k := by\n    have h\u2081\u2081 : k - 2 + 2 = k := by\n      have h\u2081\u2082 : k \u2265 2 := hk\n      have h\u2081\u2083 : k - 2 + 2 = k := by\n        have h\u2081\u2084 : k - 2 + 2 = k := by\n          omega\n        exact h\u2081\u2084\n      exact h\u2081\u2083\n    exact h\u2081\u2081\n  \n  have h\u2082 : (3 : \u211d)^k = (3 : \u211d)^((k - 2 : \u2115) + 2) := by\n    have h\u2082\u2081 : (k : \u2115) = (k - 2 : \u2115) + 2 := by\n      omega\n    have h\u2082\u2082 : (3 : \u211d) ^ k = (3 : \u211d) ^ ((k - 2 : \u2115) + 2) := by\n      rw [show (k : \u2115) = (k - 2 : \u2115) + 2 by omega]\n      <;> simp [pow_add]\n      <;> ring_nf\n      <;> norm_cast\n    exact h\u2082\u2082\n  \n  have h\u2083 : (3 : \u211d)^((k - 2 : \u2115) + 2) = (3 : \u211d)^(k - 2) * (3 : \u211d)^2 := by\n    rw [pow_add]\n    <;> norm_cast\n    <;> simp [pow_add]\n    <;> ring_nf\n    <;> norm_num\n  \n  have h\u2084 : (3 : \u211d)^2 = (9 : \u211d) := by\n    norm_num\n    <;>\n    simp_all [pow_add, pow_two, mul_assoc]\n    <;>\n    ring_nf at *\n    <;>\n    norm_num at *\n    <;>\n    linarith\n  \n  have h\u2085 : (3 : \u211d)^k = (3 : \u211d)^(k - 2) * (9 : \u211d) := by\n    calc\n      (3 : \u211d) ^ k = (3 : \u211d) ^ ((k - 2 : \u2115) + 2) := by rw [h\u2082]\n      _ = (3 : \u211d) ^ (k - 2) * (3 : \u211d) ^ 2 := by rw [h\u2083]\n      _ = (3 : \u211d) ^ (k - 2) * (9 : \u211d) := by\n        rw [h\u2084]\n        <;>\n        norm_cast\n        <;>\n        simp [pow_add, pow_two, mul_assoc]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n  \n  have h\u2086 : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^k := by\n    have h\u2086\u2081 : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^(k - 2) * (9 : \u211d) := by\n      ring\n    rw [h\u2086\u2081]\n    linarith\n  \n  exact h\u2086", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equation from the natural language. The additional constraint k \u2265 2 is not explicitly mentioned in the natural language but is mathematically necessary to ensure the expression k - 2 is well-defined in natural number arithmetic. The specification of natural numbers for k and real numbers for the arithmetic operations are reasonable mathematical interpretations that don't contradict the natural language. The assumption of basic exponentiation properties is implicitly satisfied by Lean's mathematical library."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l10": {"id": "l10", "natural_language": "Thus, $a_{k+1}=2^k+3^k$.", "statement": "We assume:\n\u2022 $a_{k+1} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$ [l7].\n\u2022 $4 \\cdot 2^{k-2} = 2^k$ [l8].\n\u2022 $9 \\cdot 3^{k-2} = 3^k$ [l9].\nTherefore, we conclude:\n\u2022 $a_{k+1}=2^k+3^k$ [l10].", "dependencies": ["l7", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (k : \u2115) \n  (hk : k \u2265 2) \n  (a : \u2115 \u2192 \u211d)\n  (l7 : a (k+1) = 4 * 2^(k-2) + 9 * 3^(k-2))\n  (l8 : 4 * 2^(k-2) = 2^k)\n  (l9 : 9 * 3^(k-2) = 3^k) :\n  a (k+1) = 2^k + 3^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (k : \u2115) \n  (hk : k \u2265 2) \n  (a : \u2115 \u2192 \u211d)\n  (l7 : a (k+1) = 4 * 2^(k-2) + 9 * 3^(k-2))\n  (l8 : 4 * 2^(k-2) = 2^k)\n  (l9 : 9 * 3^(k-2) = 3^k) :\n  a (k+1) = 2^k + 3^k := by\n  have h1 : (a (k+1) : \u211d) = (2 : \u211d)^k + (3 : \u211d)^k := by\n    have h\u2081 : (a (k+1) : \u211d) = (4 : \u211d) * (2 : \u211d)^(k - 2) + (9 : \u211d) * (3 : \u211d)^(k - 2) := by\n      norm_cast at l7 \u22a2\n      <;>\n      (try simp_all [pow_succ, mul_assoc, mul_comm, mul_left_comm]) <;>\n      (try ring_nf at * <;> simp_all [pow_succ, mul_assoc, mul_comm, mul_left_comm]) <;>\n      (try norm_num at * <;> simp_all [pow_succ, mul_assoc, mul_comm, mul_left_comm]) <;>\n      (try linarith)\n      <;>\n      (try\n        {\n          simp_all [Nat.cast_add, Nat.cast_mul, Nat.cast_pow, Nat.cast_ofNat]\n          <;>\n          ring_nf at *\n          <;>\n          norm_num at *\n          <;>\n          linarith\n        })\n      <;>\n      (try\n        {\n          simp_all [Nat.cast_add, Nat.cast_mul, Nat.cast_pow, Nat.cast_ofNat]\n          <;>\n          ring_nf at *\n          <;>\n          norm_num at *\n          <;>\n          linarith\n        })\n    have h\u2082 : (4 : \u211d) * (2 : \u211d)^(k - 2) = (2 : \u211d)^k := by\n      have h\u2082\u2081 : (4 : \u211d) * (2 : \u211d)^(k - 2) = (2 : \u211d)^k := by\n        have h\u2082\u2082 : (4 : \u211d) * (2 : \u211d)^(k - 2) = (2 : \u211d)^2 * (2 : \u211d)^(k - 2) := by norm_num\n        rw [h\u2082\u2082]\n        have h\u2082\u2083 : (2 : \u211d)^2 * (2 : \u211d)^(k - 2) = (2 : \u211d)^(2 + (k - 2)) := by\n          rw [\u2190 pow_add]\n          <;>\n          norm_num\n          <;>\n          ring_nf\n        rw [h\u2082\u2083]\n        have h\u2082\u2084 : (2 : \u211d)^(2 + (k - 2)) = (2 : \u211d)^k := by\n          have h\u2082\u2085 : 2 + (k - 2) = k := by\n            have h\u2082\u2085\u2081 : k \u2265 2 := hk\n            have h\u2082\u2085\u2082 : 2 + (k - 2) = k := by\n              omega\n            exact h\u2082\u2085\u2082\n          rw [h\u2082\u2085]\n        rw [h\u2082\u2084]\n      exact h\u2082\u2081\n    have h\u2083 : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^k := by\n      have h\u2083\u2081 : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^k := by\n        have h\u2083\u2082 : (9 : \u211d) * (3 : \u211d)^(k - 2) = (3 : \u211d)^2 * (3 : \u211d)^(k - 2) := by norm_num\n        rw [h\u2083\u2082]\n        have h\u2083\u2083 : (3 : \u211d)^2 * (3 : \u211d)^(k - 2) = (3 : \u211d)^(2 + (k - 2)) := by\n          rw [\u2190 pow_add]\n          <;>\n          norm_num\n          <;>\n          ring_nf\n        rw [h\u2083\u2083]\n        have h\u2083\u2084 : (3 : \u211d)^(2 + (k - 2)) = (3 : \u211d)^k := by\n          have h\u2083\u2085 : 2 + (k - 2) = k := by\n            have h\u2083\u2085\u2081 : k \u2265 2 := hk\n            have h\u2083\u2085\u2082 : 2 + (k - 2) = k := by\n              omega\n            exact h\u2083\u2085\u2082\n          rw [h\u2083\u2085]\n        rw [h\u2083\u2084]\n      exact h\u2083\u2081\n    calc\n      (a (k+1) : \u211d) = (4 : \u211d) * (2 : \u211d)^(k - 2) + (9 : \u211d) * (3 : \u211d)^(k - 2) := by rw [h\u2081]\n      _ = (2 : \u211d)^k + (3 : \u211d)^k := by\n        rw [h\u2082, h\u2083]\n        <;>\n        ring_nf\n        <;>\n        norm_num\n        <;>\n        linarith\n  \n  have h2 : a (k+1) = 2^k + 3^k := by\n    have h\u2082\u2081 : (a (k+1) : \u211d) = (2 : \u211d)^k + (3 : \u211d)^k := h1\n    have h\u2082\u2082 : (a (k+1) : \u211d) = ( (2 : \u2115)^k + (3 : \u2115)^k : \u211d) := by\n      norm_cast at h\u2082\u2081 \u22a2\n      <;>\n      simp [pow_add, pow_mul, mul_assoc] at h\u2082\u2081 \u22a2 <;>\n      ring_nf at h\u2082\u2081 \u22a2 <;>\n      norm_num at h\u2082\u2081 \u22a2 <;>\n      simp_all [Nat.cast_add, Nat.cast_pow]\n      <;>\n      linarith\n    have h\u2082\u2083 : a (k+1) = (2 : \u2115)^k + (3 : \u2115)^k := by\n      norm_cast at h\u2082\u2082 \u22a2\n      <;>\n      simp_all [Nat.cast_add, Nat.cast_pow]\n      <;>\n      linarith\n    norm_cast at h\u2082\u2083 \u22a2\n    <;>\n    simp_all [Nat.cast_add, Nat.cast_pow]\n    <;>\n    linarith\n  \n  apply h2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content and logical structure from the natural language. The three assumptions (l7, l8, l9) are precisely translated, and the conclusion (l10) is identical. The additional constraint 'k \u2265 2' is a reasonable mathematical addition that doesn't contradict the natural language but ensures the expressions are well-defined. The logical flow from assumptions to conclusion is preserved perfectly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of strong mathematical induction, the statement is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ is true for the base cases n=1 and n=2 [l1, l2].\n\u2022 The inductive step is proven: for any $k \\geq 2$, assuming the formula holds for all $1 \\leq j \\leq k$ implies it holds for $k+1$ [l10].\nTherefore, we conclude:\n\u2022 By the principle of strong mathematical induction, the formula $a_n = 2^{n-1}+3^{n-1}$ is true for all integers $n \\geq 1$ [ts_1].", "dependencies": ["l1", "l2", "l10"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (hrec : \u2200 n, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (l1 : a 1 = 2^(1 - 1 : \u2115) + 3^(1 - 1 : \u2115))\n  (l2 : a 2 = 2^(2 - 1 : \u2115) + 3^(2 - 1 : \u2115))\n  (l10 : \u2200 k, k \u2265 2 \u2192 (\u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1 : \u2115) + 3^(j - 1 : \u2115)) \u2192 a (k + 1) = 2^k + 3^k) :\n  \u2200 n, n \u2265 1 \u2192 a n = 2^(n - 1 : \u2115) + 3^(n - 1 : \u2115) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (hrec : \u2200 n, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (l1 : a 1 = 2^(1 - 1 : \u2115) + 3^(1 - 1 : \u2115))\n  (l2 : a 2 = 2^(2 - 1 : \u2115) + 3^(2 - 1 : \u2115))\n  (l10 : \u2200 k, k \u2265 2 \u2192 (\u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1 : \u2115) + 3^(j - 1 : \u2115)) \u2192 a (k + 1) = 2^k + 3^k) :\n  \u2200 n, n \u2265 1 \u2192 a n = 2^(n - 1 : \u2115) + 3^(n - 1 : \u2115) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d) ^ (n - 1 : \u2115) + (3 : \u211d) ^ (n - 1 : \u2115) := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d) ^ (n - 1 : \u2115) + (3 : \u211d) ^ (n - 1 : \u2115) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case n = 1\n        norm_num [l1] at *\n        <;>\n        simp_all [h1]\n        <;>\n        norm_num\n        <;>\n        linarith\n      | 2 =>\n        -- Base case n = 2\n        norm_num [l2] at *\n        <;>\n        simp_all [h2]\n        <;>\n        norm_num\n        <;>\n        linarith\n      | k + 3 =>\n        -- Inductive step for n = k + 3 (i.e., n \u2265 3)\n        have h\u2081 := hrec (k + 3) (by linarith)\n        have h\u2082 := ih (k + 2) (by omega)\n        have h\u2083 := ih (k + 1) (by omega)\n        simp [h\u2081, h\u2082, h\u2083, pow_add, pow_one, Nat.add_assoc] at *\n        <;>\n        (try ring_nf at *) <;>\n        (try norm_num at *) <;>\n        (try ring_nf) <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try\n          {\n            cases k with\n            | zero =>\n              norm_num at *\n              <;>\n              linarith\n            | succ k' =>\n              simp_all [pow_succ, mul_add, mul_comm, mul_left_comm, mul_assoc]\n              <;>\n              ring_nf at *\n              <;>\n              norm_num at *\n              <;>\n              linarith\n          })\n        <;>\n        (try\n          {\n            norm_num [pow_succ] at *\n            <;>\n            ring_nf at *\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [pow_succ, mul_add, mul_comm, mul_left_comm, mul_assoc]\n            <;>\n            ring_nf at *\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n    exact h n hn\n  \n  intro n hn\n  have h\u2081 := h_main n hn\n  norm_num at h\u2081 \u22a2\n  <;>\n  simp_all [h1, h2, l1, l2]\n  <;>\n  ring_nf at *\n  <;>\n  norm_num at *\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The base cases l1 and l2 correctly capture that the formula holds for n=1 and n=2. The Lean formalization uses the exact same mathematical expressions as the natural language.", "The inductive step l10 accurately represents the strong induction hypothesis - assuming the formula holds for all j from 1 to k (where k\u22652) implies it holds for k+1. The logical structure matches perfectly.", "The conclusion ts_1 correctly states that the formula holds for all n\u22651, which is exactly what the natural language claims to prove by strong mathematical induction. The Lean formalization includes additional hypotheses (h1, h2, hrec) that define the sequence properties, but these are logically consistent extra details that don't contradict the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l10", "label": "l10", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    