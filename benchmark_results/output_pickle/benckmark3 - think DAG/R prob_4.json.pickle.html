
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a discrete random variable with expected value $E[X] = \mu$ and variance $Var(X) = \sigma^2$. Let $a$ and $b$ be real constants, and let the random variable $Y$ be defined as $Y = aX + b$. Then, the variance of $Y$ is $Var(Y) = a^2\sigma^2$.

Proof: First, we compute the expected value of $Y$. Using the linearity of expectation, we have $E[Y] = E[aX + b] = aE[X] + b = a\mu + b$. Next, we simplify the term inside the variance calculation, $Y - E[Y]$. This gives $Y - E[Y] = (aX + b) - (a\mu + b) = a(X - \mu)$. Using the definition of variance, $Var(Y) = E[(Y - E[Y])^2]$, and substituting our result, we get $Var(Y) = E[(a(X - \mu))^2]$. This can be expanded to $Var(Y) = a^2E[(X - \mu)^2]$. Since we are given that $Var(X) = E[(X - \mu)^2] = \sigma^2$, we can conclude that $Var(Y) = a^2\sigma^2$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a discrete random variable with expected value $E[X] = \\mu$ and variance $Var(X) = \\sigma^2$.", "statement": "Premise:\n\u2022 X is a discrete random variable with expected value E[X] = \u03bc and variance Var(X) = \u03c3\u00b2 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  \u2211 \u03c9, P \u03c9 * (Y \u03c9 - (\u2211 \u03c9', P \u03c9' * Y \u03c9'))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents X as a discrete random variable through the finite type \u03a9 and function X : \u03a9 \u2192 \u211d, with proper probability measure P", "The expected value condition E[X] = \u03bc is correctly formalized as (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc)", "The variance condition Var(X) = \u03c3\u00b2 is correctly formalized as (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $a$ and $b$ be real constants, and let the random variable $Y$ be defined as $Y = aX + b$.", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1].\n\u2022 a and b are real constants, and Y is a random variable defined as Y = aX + b [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  \u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly models X as a discrete random variable using a finite sample space \u03a9 with probability function P. The additional probability axioms (non-negativity, sum to 1) and statistical parameters (\u03bc, \u03c3) are extra details that don't contradict the natural language statement.", "The Lean formalization declares a and b as real constants (a b : \u211d), which perfectly matches the natural language. The additional parameters \u03bc and \u03c3 are extra details for the theorem's purpose.", "The Lean definition 'let Y := fun \u03c9 => a * X \u03c9 + b' correctly captures Y = aX + b as stated in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Since we are given that $Var(X) = E[(X - \\mu)^2] = \\sigma^2$", "statement": "Premise:\n\u2022 The variance of X, where E[X]=\u03bc, is defined as Var(X) = E[(X - \u03bc)\u00b2], and its value is \u03c3\u00b2 [tc_3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_3 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d)\n  (hP_nonneg : \u2200 \u03c9, P \u03c9 \u2265 0)\n  (hP_sum_one : \u2211 \u03c9, P \u03c9 = 1)\n  (hE_X : \u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc)\n  (hVar_X : \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2) :\n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let E_Y := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  \u2211 \u03c9, P \u03c9 * (Y \u03c9 - E_Y)^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization \u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc correctly captures the expectation E[X] = \u03bc using discrete probability notation", "The natural language states Var(X) = E[(X - \u03bc)\u00b2] as a condition (definition), but the Lean version hVar_X directly assumes \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2, which combines both the definition and the conclusion into one assumption. This misses the definitional aspect", "The natural language conclusion is Var(X) = \u03c3\u00b2, but the Lean proposition is about a different random variable Y and states \u2211 \u03c9, P \u03c9 * (Y \u03c9 - E_Y)^2 = a^2 * \u03c3^2. This is completely different from what the natural language concludes"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization \u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc correctly captures the expectation E[X] = \u03bc using discrete probability notation', 'The natural language states Var(X) = E[(X - \u03bc)\u00b2] as a condition (definition), but the Lean version hVar_X directly assumes \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2, which combines both the definition and the conclusion into one assumption. This misses the definitional aspect', 'The natural language conclusion is Var(X) = \u03c3\u00b2, but the Lean proposition is about a different random variable Y and states \u2211 \u03c9, P \u03c9 * (Y \u03c9 - E_Y)^2 = a^2 * \u03c3^2. This is completely different from what the natural language concludes']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Using the linearity of expectation, we have $E[Y] = E[aX + b] = aE[X] + b = a\\mu + b$.", "statement": "We assume:\n\u2022 X is a discrete random variable with expected value E[X] = \u03bc [tc_1].\n\u2022 a and b are real constants, and Y is a random variable defined as Y = aX + b [tc_2].\nTherefore, we conclude:\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  \u2211 \u03c9, P \u03c9 * Y \u03c9 = a * \u03bc + b := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  \u2211 \u03c9, P \u03c9 * Y \u03c9 = a * \u03bc + b := by\n  intro hP_nonneg hP_sum hX_sum\n  intro Y\n  have h_sum_expand : \u2211 \u03c9 : \u03a9, P \u03c9 * Y \u03c9 = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9) + b * P \u03c9) := by\n    calc\n      _ = \u2211 \u03c9 : \u03a9, P \u03c9 * Y \u03c9 := rfl\n      _ = \u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b) := by\n        simp [Y]\n        <;>\n        congr <;>\n        ext \u03c9 <;>\n        ring\n      _ = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9) + b * P \u03c9) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring_nf\n        <;>\n        simp_all [mul_assoc, mul_comm, mul_left_comm]\n        <;>\n        ring_nf\n        <;>\n        linarith [hP_nonneg \u03c9]\n  \n  have h_sum_split : \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9) + b * P \u03c9) = a * \u2211 \u03c9 : \u03a9, P \u03c9 * X \u03c9 + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n    calc\n      _ = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9) + b * P \u03c9) := rfl\n      _ = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9)) + \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n        rw [Finset.sum_add_distrib]\n      _ = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) + \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n        have h1 : \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9)) = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) := by\n          rw [Finset.mul_sum]\n          <;>\n          apply Finset.sum_congr rfl\n          <;>\n          intros <;>\n          ring\n        rw [h1]\n      _ = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n        have h2 : \u2211 \u03c9 : \u03a9, (b * P \u03c9) = b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n          rw [Finset.mul_sum]\n          <;>\n          apply Finset.sum_congr rfl\n          <;>\n          intros <;>\n          ring\n        rw [h2]\n  \n  have h_final : \u2211 \u03c9 : \u03a9, P \u03c9 * Y \u03c9 = a * \u03bc + b := by\n    calc\n      _ = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9) + b * P \u03c9) := by rw [h_sum_expand]\n      _ = a * \u2211 \u03c9 : \u03a9, P \u03c9 * X \u03c9 + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by rw [h_sum_split]\n      _ = a * \u03bc + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by rw [hX_sum]\n      _ = a * \u03bc + b * 1 := by rw [hP_sum]\n      _ = a * \u03bc + b := by ring\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The discrete random variable X and its expected value \u03bc are correctly formalized using the standard discrete expectation formula \u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc", "The real constants a, b and the linear transformation Y = aX + b are accurately represented with proper type declarations and function definition", "The conclusion E[Y] = a\u03bc + b is correctly formalized as \u2211 \u03c9, P \u03c9 * Y \u03c9 = a * \u03bc + b, which is the appropriate discrete expectation formula", "The Lean formalization appropriately includes additional mathematical rigor with explicit probability measure conditions (non-negativity and normalization) and finite sample space structure, which are necessary for the discrete setting but not contradictory to the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "This gives $Y - E[Y] = (aX + b) - (a\\mu + b) = a(X - \\mu)$.", "statement": "We assume:\n\u2022 Y is a random variable defined as Y = aX + b [tc_2].\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1].\nTherefore, we conclude:\n\u2022 The term Y - E[Y] simplifies to a(X - \u03bc) [l2].", "dependencies": ["tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  \u2200 \u03c9, Y \u03c9 - EY = a * (X \u03c9 - \u03bc) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  \u2200 \u03c9, Y \u03c9 - EY = a * (X \u03c9 - \u03bc) := by\n  intro hP_nonneg hP_sum hX_sum\n  dsimp only\n  intro \u03c9\n  have h_EY : (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)) = a * \u03bc + b := by\n    calc\n      (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)) = \u2211 \u03c9 : \u03a9, (P \u03c9 * (a * X \u03c9) + P \u03c9 * b) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring\n      _ = \u2211 \u03c9 : \u03a9, (P \u03c9 * (a * X \u03c9)) + \u2211 \u03c9 : \u03a9, (P \u03c9 * b) := by\n        rw [Finset.sum_add_distrib]\n      _ = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n        have h\u2081 : \u2211 \u03c9 : \u03a9, (P \u03c9 * (a * X \u03c9)) = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) := by\n          calc\n            \u2211 \u03c9 : \u03a9, (P \u03c9 * (a * X \u03c9)) = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9)) := by\n              apply Finset.sum_congr rfl\n              intro \u03c9 _\n              ring\n            _ = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) := by\n              rw [Finset.mul_sum]\n              <;> simp [mul_assoc]\n        have h\u2082 : \u2211 \u03c9 : \u03a9, (P \u03c9 * b) = b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n          calc\n            \u2211 \u03c9 : \u03a9, (P \u03c9 * b) = \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n              apply Finset.sum_congr rfl\n              intro \u03c9 _\n              ring\n            _ = b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n              rw [Finset.mul_sum]\n              <;> simp [mul_assoc]\n        rw [h\u2081, h\u2082]\n        <;> ring\n      _ = a * \u03bc + b * 1 := by\n        rw [hX_sum, hP_sum]\n        <;> ring\n      _ = a * \u03bc + b := by\n        ring\n  \n  have h_main : (a * X \u03c9 + b) - (a * \u03bc + b) = a * (X \u03c9 - \u03bc) := by\n    ring_nf\n    <;>\n    (try simp_all)\n    <;>\n    (try linarith)\n    <;>\n    (try nlinarith)\n  \n  have h_final : (a * X \u03c9 + b) - (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)) = a * (X \u03c9 - \u03bc) := by\n    rw [h_EY]\n    <;>\n    (try simp_all)\n    <;>\n    (try linarith)\n    <;>\n    (try nlinarith)\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try linarith)\n  \n  simpa using h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The definition of Y as a linear transformation, the expected value relationship, and the main conclusion Y - E[Y] = a(X - \u03bc) are all properly represented. The additional explicit probability measure conditions (non-negativity and normalization) are mathematically necessary and enhance the formalization without contradicting the natural language. The pointwise formulation (\u2200 \u03c9) is the correct mathematical interpretation of the algebraic simplification described in natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Using the definition of variance, $Var(Y) = E[(Y - E[Y])^2]$", "statement": "We assume:\n\u2022 Y is a random variable with a defined expectation [tc_2, l1].\nTherefore, we conclude:\n\u2022 The variance of Y is defined as Var(Y) = E[(Y - E[Y])\u00b2] [l3].", "dependencies": ["tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  \u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  \u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2 = a^2 * \u03c3^2 := by\n  intro hP_nonneg hP_sum hX_sum hX_var\n  dsimp only\n  have h_EY : \u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b) = a * \u03bc + b := by\n    calc\n      \u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b) = \u2211 \u03c9 : \u03a9, (a * P \u03c9 * X \u03c9 + b * P \u03c9) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring_nf\n        <;>\n        simp [mul_assoc, mul_comm, mul_left_comm]\n        <;>\n        ring_nf\n      _ = \u2211 \u03c9 : \u03a9, (a * P \u03c9 * X \u03c9) + \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n        rw [Finset.sum_add_distrib]\n      _ = a * \u2211 \u03c9 : \u03a9, P \u03c9 * X \u03c9 + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n        calc\n          (\u2211 \u03c9 : \u03a9, (a * P \u03c9 * X \u03c9) + \u2211 \u03c9 : \u03a9, (b * P \u03c9)) = (\u2211 \u03c9 : \u03a9, a * (P \u03c9 * X \u03c9)) + \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n            apply congr_arg\u2082 (\u00b7 + \u00b7)\n            \u00b7 apply Finset.sum_congr rfl\n              intro \u03c9 _\n              ring_nf\n              <;>\n              simp [mul_assoc, mul_comm, mul_left_comm]\n              <;>\n              ring_nf\n            \u00b7 rfl\n          _ = a * \u2211 \u03c9 : \u03a9, P \u03c9 * X \u03c9 + \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n            simp [Finset.mul_sum]\n          _ = a * \u2211 \u03c9 : \u03a9, P \u03c9 * X \u03c9 + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n            simp [Finset.mul_sum]\n            <;>\n            ring_nf\n      _ = a * \u03bc + b * 1 := by\n        rw [hX_sum, hP_sum]\n        <;>\n        ring_nf\n      _ = a * \u03bc + b := by\n        ring_nf\n  \n  have h_main : \u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n    have h1 : \u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = \u2211 \u03c9 : \u03a9, P \u03c9 * (a * (X \u03c9 - \u03bc))^2 := by\n      apply Finset.sum_congr rfl\n      intro \u03c9 _\n      have h2 : a * X \u03c9 + b - (a * \u03bc + b) = a * (X \u03c9 - \u03bc) := by\n        ring\n      rw [h2]\n      <;>\n      ring_nf\n    rw [h1]\n    have h2 : \u2211 \u03c9 : \u03a9, P \u03c9 * (a * (X \u03c9 - \u03bc))^2 = \u2211 \u03c9 : \u03a9, P \u03c9 * (a ^ 2 * (X \u03c9 - \u03bc) ^ 2) := by\n      apply Finset.sum_congr rfl\n      intro \u03c9 _\n      ring_nf\n      <;>\n      simp [mul_assoc, mul_comm, mul_left_comm]\n      <;>\n      ring_nf\n    rw [h2]\n    have h3 : \u2211 \u03c9 : \u03a9, P \u03c9 * (a ^ 2 * (X \u03c9 - \u03bc) ^ 2) = a ^ 2 * \u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc) ^ 2 := by\n      calc\n        \u2211 \u03c9 : \u03a9, P \u03c9 * (a ^ 2 * (X \u03c9 - \u03bc) ^ 2) = \u2211 \u03c9 : \u03a9, (a ^ 2 * (P \u03c9 * (X \u03c9 - \u03bc) ^ 2)) := by\n          apply Finset.sum_congr rfl\n          intro \u03c9 _\n          ring_nf\n          <;>\n          simp [mul_assoc, mul_comm, mul_left_comm]\n          <;>\n          ring_nf\n        _ = a ^ 2 * \u2211 \u03c9 : \u03a9, (P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by\n          simp [Finset.mul_sum]\n          <;>\n          ring_nf\n    rw [h3]\n    have h4 : \u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc) ^ 2 = \u03c3 ^ 2 := by\n      exact hX_var\n    rw [h4]\n    <;>\n    ring_nf\n  \n  simp_all only [h_EY]\n  <;>\n  try norm_num\n  <;>\n  try linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premise about Y having a defined expectation is correctly captured. The Lean code defines Y as a linear transformation of X and computes its expectation EY properly.", "The variance definition Var(Y) = E[(Y - E[Y])\u00b2] is perfectly represented in discrete form as \u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2 in the Lean formalization.", "The Lean formalization goes beyond just stating the definition - it proves the specific variance property for linear transformations, which is mathematically consistent and adds valuable content without contradicting the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "and substituting our result, we get $Var(Y) = E[(a(X - \\mu))^2]$.", "statement": "We assume:\n\u2022 The term Y - E[Y] simplifies to a(X - \u03bc) [l2].\n\u2022 The variance of Y is defined as Var(Y) = E[(Y - E[Y])\u00b2] [l3].\nTherefore, we conclude:\n\u2022 Var(Y) = E[(a(X - \u03bc))\u00b2] [l4].", "dependencies": ["l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  (\u2200 \u03c9, Y \u03c9 - EY = a * (X \u03c9 - \u03bc)) \u2192\n  (\u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2 = a^2 * (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  (\u2200 \u03c9, Y \u03c9 - EY = a * (X \u03c9 - \u03bc)) \u2192\n  (\u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2 = a^2 * (\u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2)) := by\n  intro hP_nonneg hP_sum hX_sum\n  dsimp only\n  intro hY_sub_EY\n  have h_main : (\u2211 \u03c9 : \u03a9, P \u03c9 * ( (fun \u03c9 => a * X \u03c9 + b) \u03c9 - (\u2211 \u03c9 : \u03a9, P \u03c9 * ( (fun \u03c9 => a * X \u03c9 + b) \u03c9)) ) ^ 2) = a ^ 2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by\n    calc\n      (\u2211 \u03c9 : \u03a9, P \u03c9 * ( (fun \u03c9 => a * X \u03c9 + b) \u03c9 - (\u2211 \u03c9 : \u03a9, P \u03c9 * ( (fun \u03c9 => a * X \u03c9 + b) \u03c9)) ) ^ 2)\n        = \u2211 \u03c9 : \u03a9, P \u03c9 * (a * (X \u03c9 - \u03bc)) ^ 2 := by\n          -- Use the given condition to replace (Y \u03c9 - EY) with a * (X \u03c9 - \u03bc)\n          apply Finset.sum_congr rfl\n          intro \u03c9 _\n          have h\u2081 := hY_sub_EY \u03c9\n          have h\u2082 : ((fun \u03c9 => a * X \u03c9 + b) \u03c9 - (\u2211 \u03c9 : \u03a9, P \u03c9 * ( (fun \u03c9 => a * X \u03c9 + b) \u03c9))) = a * (X \u03c9 - \u03bc) := by\n            simpa using h\u2081\n          rw [h\u2082]\n          <;>\n          ring_nf\n      _ = \u2211 \u03c9 : \u03a9, P \u03c9 * (a ^ 2 * (X \u03c9 - \u03bc) ^ 2) := by\n        -- Expand (a * (X \u03c9 - \u03bc)) ^ 2 to a ^ 2 * (X \u03c9 - \u03bc) ^ 2\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring_nf\n        <;>\n        simp [pow_two, mul_assoc, mul_comm, mul_left_comm]\n        <;>\n        ring_nf\n      _ = \u2211 \u03c9 : \u03a9, (a ^ 2 * (P \u03c9 * (X \u03c9 - \u03bc) ^ 2)) := by\n        -- Factor out a ^ 2 from each term in the sum\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring_nf\n        <;>\n        simp [pow_two, mul_assoc, mul_comm, mul_left_comm]\n        <;>\n        ring_nf\n      _ = a ^ 2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by\n        -- Factor out a ^ 2 from the entire sum\n        calc\n          (\u2211 \u03c9 : \u03a9, (a ^ 2 * (P \u03c9 * (X \u03c9 - \u03bc) ^ 2))) = \u2211 \u03c9 : \u03a9, a ^ 2 * (P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by rfl\n          _ = a ^ 2 * \u2211 \u03c9 : \u03a9, (P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by\n            -- Use the fact that a ^ 2 is a constant to factor it out of the sum\n            rw [Finset.mul_sum]\n            <;>\n            simp [mul_assoc, mul_comm, mul_left_comm]\n            <;>\n            ring_nf\n          _ = a ^ 2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by rfl\n  simpa using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical essence of the natural language statement. While it includes additional mathematical rigor (probability measure conditions, explicit variable definitions) and works in a discrete setting rather than using general expectation notation, these are appropriate mathematical formalizations that don't contradict the original statement. The core logical relationship about variance calculation under linear transformation is preserved accurately. The inclusion of parameter 'b' in Y's definition and the discrete probability framework are reasonable mathematical extensions that enhance precision without changing the fundamental meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This can be expanded to $Var(Y) = a^2E[(X - \\mu)^2]$.", "statement": "We assume:\n\u2022 Var(Y) = E[(a(X - \u03bc))\u00b2] [l4].\n\u2022 a is a real constant [tc_2].\nTherefore, we conclude:\n\u2022 Var(Y) = a\u00b2 * E[(X - \u03bc)\u00b2] [l5].", "dependencies": ["l4", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  let VarY := \u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2\n  let VarX := \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2\n  VarY = a^2 * VarX := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc a b : \u211d) :\n  (\u2200 \u03c9, P \u03c9 \u2265 0) \u2192 \n  (\u2211 \u03c9, P \u03c9 = 1) \u2192 \n  (\u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc) \u2192 \n  let Y := fun \u03c9 => a * X \u03c9 + b\n  let EY := \u2211 \u03c9, P \u03c9 * Y \u03c9\n  let VarY := \u2211 \u03c9, P \u03c9 * (Y \u03c9 - EY)^2\n  let VarX := \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2\n  VarY = a^2 * VarX := by\n  intro hP_nonneg hP_sum hX_sum\n  dsimp only\n  have h_EY : (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)) = a * \u03bc + b := by\n    calc\n      (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)) = \u2211 \u03c9 : \u03a9, (P \u03c9 * (a * X \u03c9) + P \u03c9 * b) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring\n      _ = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9) + b * P \u03c9) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring\n      _ = \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9)) + \u2211 \u03c9 : \u03a9, (b * P \u03c9) := by\n        rw [Finset.sum_add_distrib]\n      _ = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) + b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n        have h1 : \u2211 \u03c9 : \u03a9, (a * (P \u03c9 * X \u03c9)) = a * \u2211 \u03c9 : \u03a9, (P \u03c9 * X \u03c9) := by\n          rw [Finset.mul_sum]\n          <;> simp [mul_assoc]\n        have h2 : \u2211 \u03c9 : \u03a9, (b * P \u03c9) = b * \u2211 \u03c9 : \u03a9, P \u03c9 := by\n          rw [Finset.mul_sum]\n          <;> simp [mul_assoc]\n        rw [h1, h2]\n        <;> ring\n      _ = a * \u03bc + b * 1 := by\n        rw [hX_sum, hP_sum]\n        <;> ring\n      _ = a * \u03bc + b := by ring\n  \n  have h_main : (\u2211 \u03c9 : \u03a9, P \u03c9 * ( (a * X \u03c9 + b) - (a * \u03bc + b))^2 ) = a^2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc)^2) := by\n    calc\n      (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (a * \u03bc + b)) ^ 2) = \u2211 \u03c9 : \u03a9, P \u03c9 * (a * (X \u03c9 - \u03bc)) ^ 2 := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        have h\u2081 : (a * X \u03c9 + b) - (a * \u03bc + b) = a * (X \u03c9 - \u03bc) := by ring\n        rw [h\u2081]\n        <;> ring_nf\n      _ = \u2211 \u03c9 : \u03a9, P \u03c9 * (a ^ 2 * (X \u03c9 - \u03bc) ^ 2) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring_nf\n        <;>\n        (try norm_num) <;>\n        (try ring_nf) <;>\n        (try field_simp) <;>\n        (try linarith [hP_nonneg \u03c9])\n      _ = \u2211 \u03c9 : \u03a9, a ^ 2 * (P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by\n        apply Finset.sum_congr rfl\n        intro \u03c9 _\n        ring_nf\n        <;>\n        (try norm_num) <;>\n        (try ring_nf) <;>\n        (try field_simp) <;>\n        (try linarith [hP_nonneg \u03c9])\n      _ = a ^ 2 * \u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc) ^ 2 := by\n        have h\u2082 : \u2211 \u03c9 : \u03a9, a ^ 2 * (P \u03c9 * (X \u03c9 - \u03bc) ^ 2) = a ^ 2 * \u2211 \u03c9 : \u03a9, (P \u03c9 * (X \u03c9 - \u03bc) ^ 2) := by\n          rw [Finset.mul_sum]\n          <;>\n          (try simp [mul_assoc, mul_comm, mul_left_comm]) <;>\n          (try ring_nf) <;>\n          (try norm_num)\n        rw [h\u2082]\n        <;>\n        (try simp [mul_assoc, mul_comm, mul_left_comm]) <;>\n        (try ring_nf) <;>\n        (try norm_num)\n  \n  have h_final : (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)))^2) = a^2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc)^2) := by\n    calc\n      (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)))^2) = (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (a * \u03bc + b))^2) := by\n        have h\u2081 : (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)) = a * \u03bc + b := h_EY\n        have h\u2082 : (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)))^2) = (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (a * \u03bc + b))^2) := by\n          apply Finset.sum_congr rfl\n          intro \u03c9 _\n          rw [h\u2081]\n          <;>\n          (try ring_nf) <;>\n          (try simp_all) <;>\n          (try linarith [hP_nonneg \u03c9])\n        rw [h\u2082]\n      _ = a^2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc)^2) := by\n        rw [h_main]\n  \n  have h_final\u2082 : (\u2211 \u03c9 : \u03a9, P \u03c9 * ((a * X \u03c9 + b) - (\u2211 \u03c9 : \u03a9, P \u03c9 * (a * X \u03c9 + b)))^2) = a^2 * (\u2211 \u03c9 : \u03a9, P \u03c9 * (X \u03c9 - \u03bc)^2) := by\n    exact h_final\n  \n  simp_all only [mul_assoc]\n  <;>\n  (try ring_nf at *) <;>\n  (try simp_all) <;>\n  (try linarith)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has a major inconsistency in the definition of Y. The natural language assumes Var(Y) = E[(a(X - \u03bc))\u00b2], which implies Y should be defined as a(X - \u03bc) plus a constant. However, the Lean code defines Y = aX + b without the constraint that b = -a\u03bc. This makes the assumption l4 from the natural language incompatible with the Lean definition of Y. While the conclusion formula Var(Y) = a\u00b2 * Var(X) is correctly stated, the setup doesn't properly capture the assumed relationship between Y and X from the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has a major inconsistency in the definition of Y. The natural language assumes Var(Y) = E[(a(X - \u03bc))\u00b2], which implies Y should be defined as a(X - \u03bc) plus a constant. However, the Lean code defines Y = aX + b without the constraint that b = -a\u03bc. This makes the assumption l4 from the natural language incompatible with the Lean definition of Y. While the conclusion formula Var(Y) = a\u00b2 * Var(X) is correctly stated, the setup doesn't properly capture the assumed relationship between Y and X from the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since we are given that $Var(X) = E[(X - \\mu)^2] = \\sigma^2$, we can conclude that $Var(Y) = a^2\\sigma^2$.", "statement": "We assume:\n\u2022 The variance of X is E[(X - \u03bc)\u00b2] = \u03c3\u00b2 [tc_3].\n\u2022 Var(Y) = a\u00b2 * E[(X - \u03bc)\u00b2] [l5].\nTherefore, we conclude:\n\u2022 Var(Y) = a\u00b2\u03c3\u00b2 [ts_1].", "dependencies": ["l5", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d)\n  (hP_nonneg : \u2200 \u03c9, P \u03c9 \u2265 0)\n  (hP_sum_one : \u2211 \u03c9, P \u03c9 = 1)\n  (hE_X : \u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc)\n  (hVar_X : \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2)\n  (hVar_def : \u2200 (Z : \u03a9 \u2192 \u211d), \u2211 \u03c9, P \u03c9 * (Z \u03c9 - \u2211 \u03c9, P \u03c9 * Z \u03c9)^2 = \u2211 \u03c9, P \u03c9 * (Z \u03c9 - (\u2211 \u03c9, P \u03c9 * Z \u03c9))^2)\n  (hVar_Y : \u2211 \u03c9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = a^2 * \u03c3^2) :\n  \u2211 \u03c9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {\u03a9 : Type*} [Fintype \u03a9] (P : \u03a9 \u2192 \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d)\n  (hP_nonneg : \u2200 \u03c9, P \u03c9 \u2265 0)\n  (hP_sum_one : \u2211 \u03c9, P \u03c9 = 1)\n  (hE_X : \u2211 \u03c9, P \u03c9 * X \u03c9 = \u03bc)\n  (hVar_X : \u2211 \u03c9, P \u03c9 * (X \u03c9 - \u03bc)^2 = \u03c3^2)\n  (hVar_def : \u2200 (Z : \u03a9 \u2192 \u211d), \u2211 \u03c9, P \u03c9 * (Z \u03c9 - \u2211 \u03c9, P \u03c9 * Z \u03c9)^2 = \u2211 \u03c9, P \u03c9 * (Z \u03c9 - (\u2211 \u03c9, P \u03c9 * Z \u03c9))^2)\n  (hVar_Y : \u2211 \u03c9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = a^2 * \u03c3^2) :\n  \u2211 \u03c9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n  have h_main : \u2211 \u03c9, P \u03c9 * (a * X \u03c9 + b - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n    exact hVar_Y\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The variance of X assumption is correctly formalized in the discrete probability setting.", "The assumption about Var(Y) is problematic. The natural language suggests Var(Y) = a\u00b2 * E[(X - \u03bc)\u00b2] as a given relationship, but the Lean code assumes Y = aX + b and directly assumes Var(Y) = a\u00b2\u03c3\u00b2, making the theorem trivial since this assumption is identical to the conclusion.", "The conclusion Var(Y) = a\u00b2\u03c3\u00b2 matches exactly between natural language and Lean formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variance of X assumption is correctly formalized in the discrete probability setting.', 'The assumption about Var(Y) is problematic. The natural language suggests Var(Y) = a\u00b2 * E[(X - \u03bc)\u00b2] as a given relationship, but the Lean code assumes Y = aX + b and directly assumes Var(Y) = a\u00b2\u03c3\u00b2, making the theorem trivial since this assumption is identical to the conclusion.', 'The conclusion Var(Y) = a\u00b2\u03c3\u00b2 matches exactly between natural language and Lean formalization.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    