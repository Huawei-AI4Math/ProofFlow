
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: A point $\overline{x}$ is a limit
point of a set $S$ if and only if there is a sequence $\{x_n\}$ of points
in $S$ such that $x_n
e\overline{x}$ for $n\ge 1,$ and
$$
\lim_{n	o\infty}x_n=\overline{x}.
$$

Proof: For sufficiency, suppose that the stated condition holds.
Then, for each $\epsilon>0$, there is an integer $N$ such
that $0<|x_n-x|<\epsilon$ if $n\ge N$. Therefore, every
$\epsilon$-neighborhood of $\overline{x}$ contains infinitely many
points of $S$. This means that $\overline{x}$ is a limit point of $S$.
For necessity, let $\overline{x}$ be a limit point of $S$. Then,
for every integer $n\ge1$,
the interval  $(\overline{x}-1/n,\overline{x}+1/n)$
contains
a point $x_n\ (
e\overline{x})$ in $S$. Since
$|x_m-\overline{x}|\le1/n$ if $m\ge n$, $\lim_{n	o\infty}x_n=
\overline{x}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "suppose that the stated condition holds.", "statement": "Premise:\n\u2022 There is a sequence $\\{x_n\\}_{n\\ge1}$ of points in a set $S$ such that $x_n \ne \\overline{x}$ for all $n\\ge 1$, and $\\lim_{n\\to\\infty}x_n=\\overline{x}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (S : Set \u211d) (x : \u211d) (x_seq : \u2115 \u2192 \u211d) :\n  (\u2200 n : \u2115, n \u2265 1 \u2192 x_seq n \u2208 S \u2227 x_seq n \u2260 x) \u2227 \n  Filter.Tendsto x_seq Filter.atTop (nhds x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that there is a sequence x_seq where for all n \u2265 1, x_seq n is in S. The variable name difference (x_seq vs {x_n}) is just notational.", "The Lean formalization correctly captures that x_seq n \u2260 x for all n \u2265 1. The variable name difference (x vs \\overline{x}) is just notational - both represent the limit point.", "The Lean formalization correctly captures the limit condition using Filter.Tendsto x_seq Filter.atTop (nhds x), which is the standard way to express lim_{n\u2192\u221e} x_n = \\overline{x} in Lean."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Then, for each $\\epsilon>0$, there is an integer $N$ such that $0<|x_n-x|<\\epsilon$ if $n\\ge N$.", "statement": "We assume:\n\u2022 There is a sequence $\\{x_n\\}_{n\\ge1}$ of points in a set $S$ such that $x_n \ne \\overline{x}$ for all $n\\ge 1$, and $\\lim_{n\\to\\infty}x_n=\\overline{x}$ [tc_1].\nTherefore, we conclude:\n\u2022 For each $\\epsilon > 0$, there exists an integer $N$ such that for all $n \\ge N$, we have $x_n \\in S$ and $0 < |x_n - \\overline{x}| < \\epsilon$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (S : Set \u211d) (x : \u211d) (x_seq : \u2115 \u2192 \u211d) :\n  (\u2200 n : \u2115, n \u2265 1 \u2192 x_seq n \u2208 S \u2227 x_seq n \u2260 x) \u2227 \n  Filter.Tendsto x_seq Filter.atTop (nhds x) \u2192\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, x_seq n \u2208 S \u2227 0 < |x_seq n - x| \u2227 |x_seq n - x| < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (S : Set \u211d) (x : \u211d) (x_seq : \u2115 \u2192 \u211d) :\n  (\u2200 n : \u2115, n \u2265 1 \u2192 x_seq n \u2208 S \u2227 x_seq n \u2260 x) \u2227 \n  Filter.Tendsto x_seq Filter.atTop (nhds x) \u2192\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, x_seq n \u2208 S \u2227 0 < |x_seq n - x| \u2227 |x_seq n - x| < \u03b5 := by\n  intro h \u03b5 h\u03b5\n  have h\u2081 : \u2203 (N\u2081 : \u2115), \u2200 (n : \u2115), n \u2265 N\u2081 \u2192 |x_seq n - x| < \u03b5 := by\n    have h\u2082 : Filter.Tendsto x_seq Filter.atTop (nhds x) := h.2\n    have h\u2083 : \u2200 \u03b5 > 0, \u2203 (N\u2081 : \u2115), \u2200 (n : \u2115), n \u2265 N\u2081 \u2192 |x_seq n - x| < \u03b5 := by\n      have h\u2084 : Filter.Tendsto x_seq Filter.atTop (nhds x) := h\u2082\n      -- Use the metric space definition of the limit to get the required N\u2081\n      have h\u2085 : \u2200 \u03b5 > 0, \u2203 (N\u2081 : \u2115), \u2200 (n : \u2115), n \u2265 N\u2081 \u2192 dist (x_seq n) x < \u03b5 := by\n        simpa [Real.dist_eq] using Metric.tendsto_atTop.mp h\u2084\n      intro \u03b5 h\u03b5\n      obtain \u27e8N\u2081, hN\u2081\u27e9 := h\u2085 \u03b5 h\u03b5\n      refine' \u27e8N\u2081, _\u27e9\n      intro n hn\n      have h\u2086 : dist (x_seq n) x < \u03b5 := hN\u2081 n hn\n      simpa [Real.dist_eq] using h\u2086\n    -- Apply the above result to \u03b5 and h\u03b5\n    obtain \u27e8N\u2081, hN\u2081\u27e9 := h\u2083 \u03b5 h\u03b5\n    exact \u27e8N\u2081, hN\u2081\u27e9\n  \n  have h\u2082 : \u2203 (N : \u2115), \u2200 (n : \u2115), n \u2265 N \u2192 x_seq n \u2208 S \u2227 0 < |x_seq n - x| \u2227 |x_seq n - x| < \u03b5 := by\n    obtain \u27e8N\u2081, hN\u2081\u27e9 := h\u2081\n    use max N\u2081 1\n    intro n hn\n    have h\u2083 : n \u2265 N\u2081 := by\n      have h\u2084 : n \u2265 max N\u2081 1 := hn\n      have h\u2085 : max N\u2081 1 \u2265 N\u2081 := by apply le_max_left\n      linarith\n    have h\u2084 : n \u2265 1 := by\n      have h\u2085 : n \u2265 max N\u2081 1 := hn\n      have h\u2086 : max N\u2081 1 \u2265 1 := by\n        apply le_max_right\n      linarith\n    have h\u2085 : x_seq n \u2208 S \u2227 x_seq n \u2260 x := h.1 n h\u2084\n    have h\u2086 : |x_seq n - x| < \u03b5 := hN\u2081 n h\u2083\n    have h\u2087 : x_seq n \u2208 S := h\u2085.1\n    have h\u2088 : x_seq n \u2260 x := h\u2085.2\n    have h\u2089 : 0 < |x_seq n - x| := by\n      have h\u2081\u2080 : x_seq n - x \u2260 0 := by\n        intro h\u2081\u2080\n        apply h\u2088\n        linarith\n      have h\u2081\u2081 : |x_seq n - x| > 0 := abs_pos.mpr h\u2081\u2080\n      linarith\n    exact \u27e8h\u2087, h\u2089, h\u2086\u27e9\n  \n  obtain \u27e8N, hN\u27e9 := h\u2082\n  refine' \u27e8N, _\u27e9\n  intro n hn\n  exact hN n hn", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence membership condition is correctly formalized with proper quantification over n\u22651", "The distinctness condition properly captures that no sequence element equals the limit point", "The convergence condition uses the standard Lean Filter.Tendsto formalization which correctly represents limit behavior", "The quantifier structure in the conclusion perfectly matches the natural language \u03b5-N definition", "Set membership is preserved correctly in the conclusion", "The compound inequality 0 < |x_n - x\u0304| < \u03b5 is properly decomposed into two conjunctive conditions in Lean", "The overall implication structure correctly captures the premise-conclusion relationship from the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Therefore, every $\\epsilon$-neighborhood of $\\overline{x}$ contains infinitely many points of $S$.", "statement": "We assume:\n\u2022 For each $\\epsilon > 0$, there exists an integer $N$ such that for all $n \\ge N$, we have $x_n \\in S$ and $0 < |x_n - \\overline{x}| < \\epsilon$ [l1].\nTherefore, we conclude:\n\u2022 Every $\\epsilon$-neighborhood of $\\overline{x}$ contains infinitely many points of $S$ [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (S : Set \u211d) (x_bar : \u211d) (x_seq : \u2115 \u2192 \u211d) :\n  (\u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, x_seq n \u2208 S \u2227 0 < |x_seq n - x_bar| \u2227 |x_seq n - x_bar| < \u03b5) \u2192\n  \u2200 \u03b5 > 0, Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (S : Set \u211d) (x_bar : \u211d) (x_seq : \u2115 \u2192 \u211d) :\n  (\u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, x_seq n \u2208 S \u2227 0 < |x_seq n - x_bar| \u2227 |x_seq n - x_bar| < \u03b5) \u2192\n  \u2200 \u03b5 > 0, Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := by\n  intro h\n  intro \u03b5 h\u03b5\n  have h_main : Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := by sorry\n  sorry", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise is correctly formalized. The condition '0 < |x_n - x\u0304| < \u03b5' from natural language is properly split into two explicit conditions in Lean, which is mathematically equivalent and more precise.", "The conclusion correctly captures the concept of \u03b5-neighborhoods containing infinitely many points. The Lean formalization properly represents this using Set.Infinite with the appropriate set comprehension.", "The overall logical structure as an implication from premise to conclusion is correctly maintained in the Lean formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (S : Set \u211d) (x_bar : \u211d) (x_seq : \u2115 \u2192 \u211d) :\n  (\u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n \u2265 N, x_seq n \u2208 S \u2227 0 < |x_seq n - x_bar| \u2227 |x_seq n - x_bar| < \u03b5) \u2192\n  \u2200 \u03b5 > 0, Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := by\n  intro h\n  intro \u03b5 h\u03b5\n  have h_main : Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := by\n    -- Use the given condition to get N such that for all n \u2265 N, x_seq n is in S and satisfies the required inequalities.\n    have h\u2081 : \u2203 N : \u2115, \u2200 n \u2265 N, x_seq n \u2208 S \u2227 0 < |x_seq n - x_bar| \u2227 |x_seq n - x_bar| < \u03b5 := h \u03b5 h\u03b5\n    obtain \u27e8N, hN\u27e9 := h\u2081\n    -- Show that the set {x_seq n | n \u2265 N} is infinite.\n    have h\u2082 : Set.Infinite (Set.range fun n : \u2115 => x_seq (n + N)) := by\n      by_contra h\u2083\n      -- If the set is finite, then the function n \u21a6 x_seq (n + N) from \u2115 to \u211d has finite range.\n      have h\u2084 : Set.Finite (Set.range fun n : \u2115 => x_seq (n + N)) := Set.not_infinite.mp h\u2083\n      -- There exists a real number c and an infinite subset of \u2115 such that x_seq (n + N) = c for all n in the subset.\n      have h\u2085 : \u2203 (c : \u211d), Set.Infinite {n : \u2115 | x_seq (n + N) = c} := by\n        -- Use the pigeonhole principle to find a c that repeats infinitely often.\n        have h\u2085\u2081 : \u2203 (c : \u211d), Set.Infinite (Set.preimage (fun n : \u2115 => x_seq (n + N)) {c}) := by\n          by_contra h\u2085\u2081\n          -- If no such c exists, then the range would be countable, but it's actually finite.\n          push_neg at h\u2085\u2081\n          have h\u2085\u2082 : Set.Finite (Set.range fun n : \u2115 => x_seq (n + N)) := h\u2084\n          have h\u2085\u2083 : \u2200 (c : \u211d), Set.Finite (Set.preimage (fun n : \u2115 => x_seq (n + N)) {c}) := by\n            intro c\n            have h\u2085\u2084 := h\u2085\u2081 c\n            simp only [Set.infinite_coe_iff, Set.preimage, Set.mem_singleton_iff] at h\u2085\u2084 \u22a2\n            exact Set.not_infinite.mp h\u2085\u2084\n          -- Use the fact that the union of finite sets is finite.\n          have h\u2085\u2084 : Set.Finite (Set.range fun n : \u2115 => x_seq (n + N)) := h\u2084\n          have h\u2085\u2085 : Set.Finite (Set.range fun n : \u2115 => x_seq (n + N)) := h\u2084\n          classical\n          -- Use the fact that the range is a subset of the union of preimages.\n          have h\u2085\u2086 : (Set.range fun n : \u2115 => x_seq (n + N)) \u2286 \u22c3 (c : \u211d), (Set.preimage (fun n : \u2115 => x_seq (n + N)) {c}) := by\n            intro y hy\n            rcases hy with \u27e8n, rfl\u27e9\n            refine' Set.mem_iUnion.mpr \u27e8x_seq (n + N), _\u27e9\n            simp [Set.mem_preimage]\n            <;> aesop\n          -- The union of preimages is finite because each preimage is finite and there are finitely many c in the range.\n          have h\u2085\u2087 : Set.Finite (\u22c3 (c : \u211d), (Set.preimage (fun n : \u2115 => x_seq (n + N)) {c})) := by\n            have h\u2085\u2088 : Set.Finite (Set.range fun n : \u2115 => x_seq (n + N)) := h\u2084\n            have h\u2085\u2089 : (\u22c3 (c : \u211d), (Set.preimage (fun n : \u2115 => x_seq (n + N)) {c})) = \u22c3 (c : Set.range fun n : \u2115 => x_seq (n + N)), (Set.preimage (fun n : \u2115 => x_seq (n + N)) {c}) := by\n              apply Set.Subset.antisymm\n              \u00b7 intro x hx\n                rcases hx with \u27e8c, hc\u27e9\n                have h\u2086\u2080 : c \u2208 Set.range fun n : \u2115 => x_seq (n + N) := by\n                  rcases hc with \u27e8n, rfl\u27e9\n                  exact \u27e8n, by simp\u27e9\n                refine' Set.mem_iUnion.mpr \u27e8c, h\u2086\u2080, _\u27e9\n                simp_all [Set.mem_preimage]\n                <;> aesop\n              \u00b7 intro x hx\n                rcases hx with \u27e8c, hc, hx\u27e9\n                refine' Set.mem_iUnion.mpr \u27e8c, _\u27e9\n                simp_all [Set.mem_preimage]\n                <;> aesop\n            rw [h\u2085\u2089]\n            apply Set.Finite.biUnion\n            \u00b7 exact h\u2084\n            \u00b7 intro c _\n              exact h\u2085\u2083 c\n          -- The range is finite because it's a subset of a finite set.\n          have h\u2086\u2080 : Set.Finite (Set.range fun n : \u2115 => x_seq (n + N)) := Set.Finite.subset h\u2085\u2087 h\u2085\u2086\n          exact absurd h\u2085\u2085 (by simp_all)\n        -- Obtain the c that repeats infinitely often.\n        obtain \u27e8c, hc\u27e9 := h\u2085\u2081\n        refine' \u27e8c, _\u27e9\n        simpa [Set.preimage, Set.mem_singleton_iff] using hc\n      -- Obtain c and the infinite set of indices.\n      obtain \u27e8c, hc\u27e9 := h\u2085\n      -- Show that c = x_bar, leading to a contradiction.\n      have h\u2086 : c = x_bar := by\n        -- Use the fact that x_seq (n + N) \u2192 x_bar to show that c = x_bar.\n        have h\u2086\u2081 : \u2200 \u03b5' > 0, \u2203 M : \u2115, \u2200 n \u2265 M, |x_seq n - x_bar| < \u03b5' := by\n          intro \u03b5' h\u03b5'\n          obtain \u27e8M, hM\u27e9 := h \u03b5' h\u03b5'\n          exact \u27e8M, fun n hn => (hM n hn).2.2\u27e9\n        -- For any \u03b5' > 0, there exists M such that for all n \u2265 M, |x_seq n - x_bar| < \u03b5'.\n        have h\u2086\u2082 : c = x_bar := by\n          by_contra h\u2086\u2083\n          -- If c \u2260 x_bar, then |c - x_bar| > 0.\n          have h\u2086\u2084 : 0 < |c - x_bar| := by\n            apply abs_pos.mpr\n            intro h\u2086\u2085\n            apply h\u2086\u2083\n            linarith\n          -- Take \u03b5' = |c - x_bar| / 2.\n          have h\u2086\u2085 : \u2203 M : \u2115, \u2200 n \u2265 M, |x_seq n - x_bar| < |c - x_bar| / 2 := h\u2086\u2081 (|c - x_bar| / 2) (by linarith)\n          obtain \u27e8M, hM\u27e9 := h\u2086\u2085\n          -- Find n such that x_seq (n + N) = c and n + N \u2265 M.\n          have h\u2086\u2086 : \u2203 n : \u2115, x_seq (n + N) = c \u2227 n + N \u2265 M := by\n            -- Since {n : \u2115 | x_seq (n + N) = c} is infinite, there exists n \u2265 M - N.\n            have h\u2086\u2087 : Set.Infinite {n : \u2115 | x_seq (n + N) = c} := hc\n            have h\u2086\u2088 : \u2203 n : \u2115, n + N \u2265 M \u2227 x_seq (n + N) = c := by\n              by_contra h\u2086\u2088\n              push_neg at h\u2086\u2088\n              have h\u2086\u2089 : \u2200 n : \u2115, x_seq (n + N) = c \u2192 n + N < M := by\n                intro n hn\n                by_contra h\u2087\u2080\n                have h\u2087\u2081 : n + N \u2265 M := by linarith\n                have h\u2087\u2082 : \u2203 n : \u2115, n + N \u2265 M \u2227 x_seq (n + N) = c := \u27e8n, h\u2087\u2081, hn\u27e9\n                exact h\u2086\u2088 h\u2087\u2082\n              have h\u2087\u2080 : Set.Finite {n : \u2115 | x_seq (n + N) = c} := by\n                have h\u2087\u2081 : {n : \u2115 | x_seq (n + N) = c} \u2286 Set.Iio M := by\n                  intro n hn\n                  have h\u2087\u2082 : x_seq (n + N) = c := hn\n                  have h\u2087\u2083 : n + N < M := h\u2086\u2089 n h\u2087\u2082\n                  have h\u2087\u2084 : n < M := by omega\n                  exact h\u2087\u2084\n                exact Set.Finite.subset (Set.finite_Iio M) h\u2087\u2081\n              exact Set.not_infinite.mpr h\u2087\u2080 hc\n            obtain \u27e8n, hn\u2081, hn\u2082\u27e9 := h\u2086\u2088\n            exact \u27e8n, by omega, hn\u2082\u27e9\n          obtain \u27e8n, hn\u2081, hn\u2082\u27e9 := h\u2086\u2086\n          have h\u2086\u2087 : |x_seq (n + N) - x_bar| < |c - x_bar| / 2 := by\n            have h\u2086\u2088 : n + N \u2265 M := hn\u2081\n            have h\u2086\u2089 : |x_seq (n + N) - x_bar| < |c - x_bar| / 2 := hM (n + N) h\u2086\u2088\n            exact h\u2086\u2089\n          have h\u2086\u2088 : x_seq (n + N) = c := hn\u2082\n          rw [h\u2086\u2088] at h\u2086\u2087\n          have h\u2086\u2089 : |c - x_bar| < |c - x_bar| / 2 := by simpa using h\u2086\u2087\n          have h\u2087\u2080 : 0 < |c - x_bar| := by\n            apply abs_pos.mpr\n            intro h\u2087\u2081\n            apply h\u2086\u2083\n            linarith\n          linarith\n        exact h\u2086\u2082\n      -- Obtain a contradiction by showing that 0 < |c - x_bar|.\n      have h\u2087 : 0 < |c - x_bar| := by\n        -- There exists n such that x_seq (n + N) = c and x_seq (n + N) \u2208 S and 0 < |x_seq (n + N) - x_bar|.\n        have h\u2087\u2081 : \u2203 n : \u2115, x_seq (n + N) = c := by\n          have h\u2087\u2082 : Set.Infinite {n : \u2115 | x_seq (n + N) = c} := hc\n          have h\u2087\u2083 : \u2203 n : \u2115, x_seq (n + N) = c := by\n            by_contra h\u2087\u2083\n            push_neg at h\u2087\u2083\n            have h\u2087\u2084 : {n : \u2115 | x_seq (n + N) = c} = \u2205 := by\n              ext n\n              simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false_iff]\n              intro h\u2087\u2085\n              have h\u2087\u2086 := h\u2087\u2083 n\n              tauto\n            rw [h\u2087\u2084] at h\u2087\u2082\n            exact Set.not_infinite.mpr (Set.finite_empty) h\u2087\u2082\n          exact h\u2087\u2083\n        obtain \u27e8n, hn\u27e9 := h\u2087\u2081\n        have h\u2087\u2082 : x_seq (n + N) \u2208 S \u2227 0 < |x_seq (n + N) - x_bar| \u2227 |x_seq (n + N) - x_bar| < \u03b5 := hN (n + N) (by linarith)\n        have h\u2087\u2083 : 0 < |x_seq (n + N) - x_bar| := h\u2087\u2082.2.1\n        have h\u2087\u2084 : x_seq (n + N) = c := hn\n        rw [h\u2087\u2084] at h\u2087\u2083\n        exact h\u2087\u2083\n      have h\u2088 : c = x_bar := h\u2086\n      have h\u2089 : 0 < |c - x_bar| := h\u2087\n      rw [h\u2088] at h\u2089\n      norm_num at h\u2089\n      <;> linarith\n    -- Show that the set {x_seq n | n \u2265 N} is contained in {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5}.\n    have h\u2083 : (Set.range fun n : \u2115 => x_seq (n + N)) \u2286 {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := by\n      intro x hx\n      rcases hx with \u27e8n, rfl\u27e9\n      have h\u2084 : x_seq (n + N) \u2208 S \u2227 0 < |x_seq (n + N) - x_bar| \u2227 |x_seq (n + N) - x_bar| < \u03b5 := hN (n + N) (by linarith)\n      have h\u2085 : x_seq (n + N) \u2208 S := h\u2084.1\n      have h\u2086 : 0 < |x_seq (n + N) - x_bar| := h\u2084.2.1\n      have h\u2087 : |x_seq (n + N) - x_bar| < \u03b5 := h\u2084.2.2\n      exact \u27e8h\u2085, h\u2086, h\u2087\u27e9\n    -- Conclude that {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} is infinite.\n    exact Set.Infinite.mono h\u2083 h\u2082\n  exact h_main"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "This means that $\\overline{x}$ is a limit point of $S$.", "statement": "We assume:\n\u2022 Every $\\epsilon$-neighborhood of $\\overline{x}$ contains infinitely many points of $S$ [l2].\nTherefore, we conclude:\n\u2022 $\\overline{x}$ is a limit point of $S$ [ts_1].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (S : Set \u211d) (x_bar : \u211d) :\n  (\u2200 \u03b5 > 0, Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5}) \u2192\n  (\u2200 \u03b5 > 0, \u2203 x \u2208 S, x \u2260 x_bar \u2227 |x - x_bar| < \u03b5) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (S : Set \u211d) (x_bar : \u211d) :\n  (\u2200 \u03b5 > 0, Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5}) \u2192\n  (\u2200 \u03b5 > 0, \u2203 x \u2208 S, x \u2260 x_bar \u2227 |x - x_bar| < \u03b5) := by\n  intro h\n  intro \u03b5 h\u03b5\n  have h_main : \u2203 (x : \u211d), x \u2208 S \u2227 x \u2260 x_bar \u2227 |x - x_bar| < \u03b5 := by\n    have h\u2081 : Set.Infinite {x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} := h \u03b5 h\u03b5\n    have h\u2082 : ({x \u2208 S | 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5} : Set \u211d).Nonempty := by\n      -- Prove that an infinite set is nonempty\n      apply Set.Infinite.nonempty h\u2081\n    -- Extract an element from the nonempty set\n    obtain \u27e8x, hx\u27e9 := h\u2082\n    have h\u2083 : x \u2208 S := hx.1\n    have h\u2084 : 0 < |x - x_bar| \u2227 |x - x_bar| < \u03b5 := hx.2\n    have h\u2085 : x \u2260 x_bar := by\n      by_contra h\u2085\n      -- If x = x_bar, then |x - x_bar| = 0, contradicting 0 < |x - x_bar|\n      have h\u2086 : x = x_bar := by tauto\n      have h\u2087 : |x - x_bar| = 0 := by\n        rw [h\u2086]\n        simp [abs_of_nonneg]\n      linarith [h\u2084.1]\n    refine' \u27e8x, h\u2083, h\u2085, _\u27e9\n    -- The last condition |x - x_bar| < \u03b5 is directly from h\u2084\n    exact h\u2084.2\n  -- Convert the existence statement to the required form\n  obtain \u27e8x, hx\u2081, hx\u2082, hx\u2083\u27e9 := h_main\n  refine' \u27e8x, hx\u2081, _\u27e9\n  exact \u27e8hx\u2082, hx\u2083\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premise about \u03b5-neighborhoods containing infinitely many points is correctly formalized using Set.Infinite with the appropriate distance constraints.", "The conclusion about x\u0304 being a limit point is correctly captured using the standard mathematical definition of limit points in terms of neighborhoods.", "The logical structure of assumption leading to conclusion is properly represented as an implication, and the mathematical relationship between the premise and conclusion is sound."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "tc_2": {"id": "tc_2", "natural_language": "let $\\overline{x}$ be a limit point of $S$.", "statement": "Premise:\n\u2022 $\\overline{x}$ is a limit point of a set $S$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (S : Set \u211d) (x : \u211d)\n(tc_2 : \u2203 (seq : \u2115 \u2192 \u211d), (\u2200 n, seq n \u2208 S) \u2227 (\u2200 n \u2265 1, seq n \u2260 x) \u2227 (Filter.Tendsto seq Filter.atTop (nhds x)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning of 'x is a limit point of set S' using the sequential characterization. While the natural language uses the general concept of limit point, the Lean version provides the equivalent sequential definition: there exists a sequence in S (with terms distinct from x) that converges to x. This is a standard and mathematically equivalent way to define limit points in metric spaces like \u211d."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l3": {"id": "l3", "natural_language": "Then, for every integer $n\\ge1$, the interval $(\\overline{x}-1/n,\\overline{x}+1/n)$ contains a point $x_n\\ (\\ne\\overline{x})$ in $S$.", "statement": "We assume:\n\u2022 $\\overline{x}$ is a limit point of a set $S$, meaning for any $\\epsilon > 0$, the punctured neighborhood $B'(\\overline{x}, \\epsilon) = \\{y : 0 < |y - \\overline{x}| < \\epsilon\\}$ has a non-empty intersection with $S$ [tc_2].\nTherefore, we conclude:\n\u2022 There exists a sequence of points $\\{x_n\\}_{n\\ge1}$ such that for every integer $n\\ge1$, $x_n \\in S$, $x_n \\ne \\overline{x}$, and $|x_n - \\overline{x}| < 1/n$ [l3].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (S : Set \u211d) (x : \u211d)\n  (tc_2 : \u2200 \u03b5 > 0, \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < \u03b5) :\n  \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 |seq n - x| < 1 / n) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (S : Set \u211d) (x : \u211d)\n  (tc_2 : \u2200 \u03b5 > 0, \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < \u03b5) :\n  \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 |seq n - x| < 1 / n) := by\n  use fun n => if hn : n = 0 then 0 else Classical.choose (tc_2 (1 / (n : \u211d)) (by\n    have h\u2081 : (n : \u211d) \u2260 0 := by\n      intro h\n      have h\u2082 : n = 0 := by\n        norm_cast at h \u22a2\n        <;> simp_all\n      simp_all\n    have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n      norm_cast\n      cases n with\n      | zero => contradiction\n      | succ n => positivity\n    have h\u2083 : (0 : \u211d) < 1 / (n : \u211d) := by positivity\n    positivity\n  ))\n  constructor\n  \u00b7 -- Prove that for all n \u2265 1, seq n \u2208 S\n    intro n hn\n    split_ifs at * <;>\n    (try omega) <;>\n    (try {\n      have h\u2081 : \u2203 (y : \u211d), y \u2208 S \u2227 y \u2260 x \u2227 |y - x| < (1 : \u211d) / (n : \u211d) := tc_2 (1 / (n : \u211d)) (by\n        have h\u2082 : (n : \u211d) \u2260 0 := by\n          intro h\n          have h\u2083 : n = 0 := by\n            norm_cast at h \u22a2\n            <;> simp_all\n          simp_all\n        have h\u2083 : (0 : \u211d) < (n : \u211d) := by\n          norm_cast\n          cases n with\n          | zero => contradiction\n          | succ n => positivity\n        have h\u2084 : (0 : \u211d) < 1 / (n : \u211d) := by positivity\n        positivity\n      )\n      have h\u2082 : Classical.choose h\u2081 \u2208 S \u2227 Classical.choose h\u2081 \u2260 x \u2227 |Classical.choose h\u2081 - x| < (1 : \u211d) / (n : \u211d) := Classical.choose_spec h\u2081\n      exact h\u2082.1\n    })\n  \u00b7 constructor\n    \u00b7 -- Prove that for all n \u2265 1, seq n \u2260 x\n      intro n hn\n      split_ifs at * <;>\n      (try omega) <;>\n      (try {\n        have h\u2081 : \u2203 (y : \u211d), y \u2208 S \u2227 y \u2260 x \u2227 |y - x| < (1 : \u211d) / (n : \u211d) := tc_2 (1 / (n : \u211d)) (by\n          have h\u2082 : (n : \u211d) \u2260 0 := by\n            intro h\n            have h\u2083 : n = 0 := by\n              norm_cast at h \u22a2\n              <;> simp_all\n            simp_all\n          have h\u2083 : (0 : \u211d) < (n : \u211d) := by\n            norm_cast\n            cases n with\n            | zero => contradiction\n            | succ n => positivity\n          have h\u2084 : (0 : \u211d) < 1 / (n : \u211d) := by positivity\n          positivity\n        )\n        have h\u2082 : Classical.choose h\u2081 \u2208 S \u2227 Classical.choose h\u2081 \u2260 x \u2227 |Classical.choose h\u2081 - x| < (1 : \u211d) / (n : \u211d) := Classical.choose_spec h\u2081\n        exact h\u2082.2.1\n      })\n    \u00b7 -- Prove that for all n \u2265 1, |seq n - x| < 1 / n\n      intro n hn\n      split_ifs at * <;>\n      (try omega) <;>\n      (try {\n        have h\u2081 : \u2203 (y : \u211d), y \u2208 S \u2227 y \u2260 x \u2227 |y - x| < (1 : \u211d) / (n : \u211d) := tc_2 (1 / (n : \u211d)) (by\n          have h\u2082 : (n : \u211d) \u2260 0 := by\n            intro h\n            have h\u2083 : n = 0 := by\n              norm_cast at h \u22a2\n              <;> simp_all\n            simp_all\n          have h\u2083 : (0 : \u211d) < (n : \u211d) := by\n            norm_cast\n            cases n with\n            | zero => contradiction\n            | succ n => positivity\n          have h\u2084 : (0 : \u211d) < 1 / (n : \u211d) := by positivity\n          positivity\n        )\n        have h\u2082 : Classical.choose h\u2081 \u2208 S \u2227 Classical.choose h\u2081 \u2260 x \u2227 |Classical.choose h\u2081 - x| < (1 : \u211d) / (n : \u211d) := Classical.choose_spec h\u2081\n        have h\u2083 : |Classical.choose h\u2081 - x| < (1 : \u211d) / (n : \u211d) := h\u2082.2.2\n        have h\u2084 : (1 : \u211d) / (n : \u211d) = (1 : \u211d) / (n : \u2115) := by\n          norm_cast\n          <;> field_simp [Nat.cast_ne_zero]\n          <;> ring_nf\n          <;> norm_cast\n          <;> simp_all [Nat.cast_ne_zero]\n          <;> linarith\n        rw [h\u2084] at h\u2083\n        exact h\u2083\n      })", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 40, "column": 10, "endLine": 42, "endColumn": 32, "data": "no goals to be solved"}, {"line": 64, "column": 12, "endLine": 66, "endColumn": 34, "data": "no goals to be solved"}, {"line": 73, "column": 4, "endLine": 104, "endColumn": 8, "data": "unsolved goals\ncase neg\nS : Set \u211d\nx : \u211d\ntc_2 : \u2200 \u03b5 > 0, \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < \u03b5\nn : \u2115\nhn : n \u2265 1\nh\u271d : \u00acn = 0\n\u22a2 |Classical.choose \u22ef - x| < 1 / \u2191n"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise tc_2 correctly captures the limit point definition. The Lean formalization directly states the equivalent condition to the punctured neighborhood definition given in natural language.", "The conclusion l3 perfectly matches the natural language statement. Both express the existence of a sequence with the same three properties for all n \u2265 1.", "Variable naming differs ($\\overline{x}$ vs x) but this is purely notational and doesn't affect the mathematical content or logical structure.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (S : Set \u211d) (x : \u211d)\n  (tc_2 : \u2200 \u03b5 > 0, \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < \u03b5) :\n  \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 |seq n - x| < 1 / n) := by\n  have h_main : \u2203 (seq : \u2115 \u2192 \u211d), (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 (\u2200 n : \u2115, n \u2265 1 \u2192 |seq n - x| < 1 / n) := by\n    use fun n => if n = 0 then x else Classical.choose (tc_2 (1 / (n : \u211d)) (by\n      have h : 0 < (n : \u2115) := by\n        by_contra h\u2081\n        have h\u2082 : n = 0 := by\n          omega\n        simp_all\n      have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n        exact mod_cast h\n      positivity\n    ))\n    constructor\n    \u00b7 -- Prove that for all n \u2265 1, seq n \u2208 S\n      intro n hn\n      have h\u2081 : (if n = 0 then x else Classical.choose (tc_2 (1 / (n : \u211d)) (by\n        have h : 0 < (n : \u2115) := by\n          by_contra h\u2081\n          have h\u2082 : n = 0 := by\n            omega\n          simp_all\n        have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n          exact mod_cast h\n        positivity\n      ))) = Classical.choose (tc_2 (1 / (n : \u211d)) (by\n        have h : 0 < (n : \u2115) := by\n          by_contra h\u2081\n          have h\u2082 : n = 0 := by\n            omega\n          simp_all\n        have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n          exact mod_cast h\n        positivity\n      )) := by\n        have h\u2082 : n \u2260 0 := by\n          intro h\u2083\n          have h\u2084 : n = 0 := h\u2083\n          linarith\n        simp [h\u2082]\n      rw [h\u2081]\n      have h\u2082 : Classical.choose (tc_2 (1 / (n : \u211d)) (by\n        have h : 0 < (n : \u2115) := by\n          by_contra h\u2081\n          have h\u2082 : n = 0 := by\n            omega\n          simp_all\n        have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n          exact mod_cast h\n        positivity\n      )) \u2208 S := by\n        have h\u2083 : \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < (1 : \u211d) / (n : \u211d) := tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        )\n        have h\u2084 : Classical.choose h\u2083 \u2208 S := (Classical.choose_spec h\u2083).1\n        have h\u2085 : Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        )) = Classical.choose h\u2083 := by\n          congr 1\n          <;> simp_all [h\u2083]\n          <;> aesop\n        rw [h\u2085]\n        exact h\u2084\n      exact h\u2082\n    \u00b7 constructor\n      \u00b7 -- Prove that for all n \u2265 1, seq n \u2260 x\n        intro n hn\n        have h\u2081 : (if n = 0 then x else Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        ))) = Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        )) := by\n          have h\u2082 : n \u2260 0 := by\n            intro h\u2083\n            have h\u2084 : n = 0 := h\u2083\n            linarith\n          simp [h\u2082]\n        rw [h\u2081]\n        have h\u2082 : Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        )) \u2260 x := by\n          have h\u2083 : \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < (1 : \u211d) / (n : \u211d) := tc_2 (1 / (n : \u211d)) (by\n            have h : 0 < (n : \u2115) := by\n              by_contra h\u2081\n              have h\u2082 : n = 0 := by\n                omega\n              simp_all\n            have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n              exact mod_cast h\n            positivity\n          )\n          have h\u2084 : Classical.choose h\u2083 \u2260 x := (Classical.choose_spec h\u2083).2.1\n          have h\u2085 : Classical.choose (tc_2 (1 / (n : \u211d)) (by\n            have h : 0 < (n : \u2115) := by\n              by_contra h\u2081\n              have h\u2082 : n = 0 := by\n                omega\n              simp_all\n            have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n              exact mod_cast h\n            positivity\n          )) = Classical.choose h\u2083 := by\n            congr 1\n            <;> simp_all [h\u2083]\n            <;> aesop\n          rw [h\u2085]\n          exact h\u2084\n        exact h\u2082\n      \u00b7 -- Prove that for all n \u2265 1, |seq n - x| < 1 / n\n        intro n hn\n        have h\u2081 : (if n = 0 then x else Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        ))) = Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        )) := by\n          have h\u2082 : n \u2260 0 := by\n            intro h\u2083\n            have h\u2084 : n = 0 := h\u2083\n            linarith\n          simp [h\u2082]\n        rw [h\u2081]\n        have h\u2082 : |(Classical.choose (tc_2 (1 / (n : \u211d)) (by\n          have h : 0 < (n : \u2115) := by\n            by_contra h\u2081\n            have h\u2082 : n = 0 := by\n              omega\n            simp_all\n          have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n            exact mod_cast h\n          positivity\n        ))) - x| < (1 : \u211d) / (n : \u211d) := by\n          have h\u2083 : \u2203 y \u2208 S, y \u2260 x \u2227 |y - x| < (1 : \u211d) / (n : \u211d) := tc_2 (1 / (n : \u211d)) (by\n            have h : 0 < (n : \u2115) := by\n              by_contra h\u2081\n              have h\u2082 : n = 0 := by\n                omega\n              simp_all\n            have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n              exact mod_cast h\n            positivity\n          )\n          have h\u2084 : |(Classical.choose h\u2083) - x| < (1 : \u211d) / (n : \u211d) := (Classical.choose_spec h\u2083).2.2\n          have h\u2085 : Classical.choose (tc_2 (1 / (n : \u211d)) (by\n            have h : 0 < (n : \u2115) := by\n              by_contra h\u2081\n              have h\u2082 : n = 0 := by\n                omega\n              simp_all\n            have h\u2082 : (0 : \u211d) < (n : \u211d) := by\n              exact mod_cast h\n            positivity\n          )) = Classical.choose h\u2083 := by\n            congr 1\n            <;> simp_all [h\u2083]\n            <;> aesop\n          rw [h\u2085]\n          exact h\u2084\n        -- Since Lean automatically coerces n to \u211d in 1 / n, we can directly use h\u2082\n        have h\u2083 : (1 : \u211d) / (n : \u211d) = (1 : \u211d) / (n : \u211d) := rfl\n        -- The following line is not needed, but we can use it to make the coercion explicit\n        have h\u2084 : (1 : \u211d) / (n : \u211d) = (1 : \u211d) / (n : \u211d) := rfl\n        -- Use the fact that Lean will coerce n to \u211d in 1 / n\n        simpa [div_eq_mul_inv] using h\u2082\n  exact h_main"}, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Since $|x_m-\\overline{x}|\\le1/n$ if $m\\ge n$, $\\lim_{n\\to\\infty}x_n= \\overline{x}$.", "statement": "We assume:\n\u2022 There exists a sequence $\\{x_n\\}_{n\\ge1}$ such that for every integer $n\\ge1$, $x_n \\in S$, $x_n \\ne \\overline{x}$, and $|x_n - \\overline{x}| < 1/n$ [l3].\nTherefore, we conclude:\n\u2022 There is a sequence $\\{x_n\\}$ of points in $S$ such that $x_n \\ne \\overline{x}$ for $n \\ge 1$, and $\\lim_{n\\to\\infty}x_n=\\overline{x}$ [ts_2].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 (S : Set \u211d) (x : \u211d)\n  (h : \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 |seq n - x| < 1 / n)) :\n  \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (Filter.Tendsto seq Filter.atTop (nhds x)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 (S : Set \u211d) (x : \u211d)\n  (h : \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 |seq n - x| < 1 / n)) :\n  \u2203 (seq : \u2115 \u2192 \u211d), \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 \n    (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 \n    (Filter.Tendsto seq Filter.atTop (nhds x)) := by\n  have h_main : \u2203 (seq : \u2115 \u2192 \u211d), (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2208 S) \u2227 (\u2200 n : \u2115, n \u2265 1 \u2192 seq n \u2260 x) \u2227 (Filter.Tendsto seq Filter.atTop (nhds x)) := by\n    obtain \u27e8seq, hS, hne, hdist\u27e9 := h\n    refine' \u27e8seq, hS, hne, _\u27e9\n    -- Prove that seq tends to x using the definition of tendsto\n    have h\u2081 : Filter.Tendsto seq Filter.atTop (nhds x) := by\n      -- Use the fact that for any \u03b5 > 0, there exists N such that for all n \u2265 N, |seq n - x| < \u03b5\n      have h\u2082 : \u2200 \u03b5 : \u211d, \u03b5 > 0 \u2192 (\u2203 N : \u2115, \u2200 n : \u2115, n \u2265 N \u2192 |seq n - x| < \u03b5) := by\n        intro \u03b5 \u03b5pos\n        -- Find N such that 1 / N < \u03b5\n        have h\u2083 : \u2203 N : \u2115, (1 : \u211d) / \u03b5 < N := by\n          -- Use the Archimedean property\n          obtain \u27e8N, hN\u27e9 := exists_nat_gt (1 / \u03b5)\n          exact \u27e8N, by exact_mod_cast hN\u27e9\n        obtain \u27e8N, hN\u27e9 := h\u2083\n        have h\u2084 : (1 : \u211d) / (N : \u211d) < \u03b5 := by\n          have h\u2085 : (1 : \u211d) / \u03b5 < (N : \u211d) := by exact_mod_cast hN\n          have h\u2086 : 0 < (1 : \u211d) / \u03b5 := by positivity\n          have h\u2087 : 0 < (N : \u211d) := by\n            by_contra h\u2088\n            have h\u2089 : (N : \u211d) \u2264 0 := by linarith\n            have h\u2081\u2080 : (1 : \u211d) / \u03b5 < (N : \u211d) := by exact_mod_cast hN\n            have h\u2081\u2081 : (1 : \u211d) / \u03b5 \u2264 0 := by linarith\n            have h\u2081\u2082 : (1 : \u211d) / \u03b5 > 0 := by positivity\n            linarith\n          have h\u2088 : 0 < \u03b5 := by positivity\n          have h\u2089 : 0 < (N : \u211d) := by positivity\n          -- Use the fact that 1 / \u03b5 < N to show 1 / N < \u03b5\n          have h\u2081\u2080 : (1 : \u211d) / (N : \u211d) < \u03b5 := by\n            calc\n              (1 : \u211d) / (N : \u211d) = 1 / (N : \u211d) := by norm_num\n              _ < \u03b5 := by\n                -- Use the inequality 1 / \u03b5 < N to derive 1 / N < \u03b5\n                have h\u2081\u2081 : (1 : \u211d) / \u03b5 < (N : \u211d) := by exact_mod_cast hN\n                have h\u2081\u2082 : 0 < (N : \u211d) := by positivity\n                have h\u2081\u2083 : 0 < \u03b5 := by positivity\n                have h\u2081\u2084 : 0 < (1 : \u211d) / \u03b5 := by positivity\n                -- Use the fact that if a < b, then 1 / b < 1 / a for positive a, b\n                have h\u2081\u2085 : (1 : \u211d) / (N : \u211d) < \u03b5 := by\n                  calc\n                    (1 : \u211d) / (N : \u211d) < (1 : \u211d) / ((1 : \u211d) / \u03b5) := by\n                      apply (div_lt_div_iff (by positivity) (by positivity)).mpr\n                      nlinarith\n                    _ = \u03b5 := by\n                      field_simp\n                      <;> ring_nf\n                      <;> field_simp [h\u2088.ne']\n                      <;> linarith\n                exact h\u2081\u2085\n          exact h\u2081\u2080\n        -- Use N to find the required bound\n        use max 1 N\n        intro n hn\n        have h\u2085 : n \u2265 max 1 N := hn\n        have h\u2086 : n \u2265 1 := by\n          have h\u2087 : (1 : \u2115) \u2264 max 1 N := by simp [le_max_left]\n          linarith\n        have h\u2087 : n \u2265 N := by\n          have h\u2088 : (N : \u2115) \u2264 max 1 N := by simp [le_max_right]\n          linarith\n        -- Use the given condition |seq n - x| < 1 / n for n \u2265 1\n        have h\u2088 : |seq n - x| < 1 / (n : \u211d) := by\n          have h\u2089 : n \u2265 1 := h\u2086\n          have h\u2081\u2080 : |seq n - x| < 1 / (n : \u211d) := by\n            have h\u2081\u2081 := hdist n h\u2089\n            norm_cast at h\u2081\u2081 \u22a2\n            <;> simpa [abs_sub_lt_iff] using h\u2081\u2081\n          exact h\u2081\u2080\n        -- Show that 1 / n \u2264 1 / N < \u03b5\n        have h\u2089 : (1 : \u211d) / (n : \u211d) \u2264 (1 : \u211d) / (N : \u211d) := by\n          have h\u2081\u2080 : (n : \u211d) \u2265 (N : \u211d) := by exact_mod_cast h\u2087\n          have h\u2081\u2081 : 0 < (n : \u211d) := by positivity\n          have h\u2081\u2082 : 0 < (N : \u211d) := by\n            by_contra h\u2081\u2083\n            have h\u2081\u2084 : (N : \u211d) \u2264 0 := by linarith\n            have h\u2081\u2085 : (1 : \u211d) / \u03b5 < (N : \u211d) := by exact_mod_cast hN\n            have h\u2081\u2086 : (1 : \u211d) / \u03b5 \u2264 0 := by linarith\n            have h\u2081\u2087 : (1 : \u211d) / \u03b5 > 0 := by positivity\n            linarith\n          -- Use the fact that if a \u2264 b, then 1 / b \u2264 1 / a for positive a, b\n          have h\u2081\u2083 : (1 : \u211d) / (n : \u211d) \u2264 (1 : \u211d) / (N : \u211d) := by\n            apply one_div_le_one_div_of_le\n            \u00b7 positivity\n            \u00b7 exact_mod_cast h\u2087\n          exact h\u2081\u2083\n        -- Combine the inequalities to get |seq n - x| < \u03b5\n        have h\u2081\u2080 : |seq n - x| < \u03b5 := by\n          calc\n            |seq n - x| < (1 : \u211d) / (n : \u211d) := h\u2088\n            _ \u2264 (1 : \u211d) / (N : \u211d) := h\u2089\n            _ < \u03b5 := h\u2084\n        exact h\u2081\u2080\n      -- Use the fact that for any \u03b5 > 0, there exists N such that for all n \u2265 N, |seq n - x| < \u03b5\n      -- to show that seq tends to x\n      have h\u2083 : Filter.Tendsto seq Filter.atTop (nhds x) := by\n        rw [Metric.tendsto_atTop]\n        intro \u03b5 \u03b5pos\n        obtain \u27e8N, hN\u27e9 := h\u2082 \u03b5 \u03b5pos\n        refine' \u27e8N, _\u27e9\n        intro n hn\n        have h\u2084 := hN n hn\n        simp [Real.dist_eq, abs_sub_comm] at h\u2084 \u22a2\n        <;> linarith\n      exact h\u2083\n    exact h\u2081\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence existence and membership condition is correctly formalized with the universal quantifier over n \u2265 1.", "The distinctness condition x_n \u2260 x\u0304 is accurately captured in the Lean formalization.", "The distance bound |x_n - x\u0304| < 1/n is precisely translated to Lean syntax.", "The limit conclusion is properly expressed using Lean's Filter.Tendsto with atTop and nhds, which correctly represents lim_{n\u2192\u221e} x_n = x\u0304.", "The overall logical structure correctly transforms the natural language assumption-conclusion format into a Lean theorem with hypothesis and goal. The mathematical content is preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    