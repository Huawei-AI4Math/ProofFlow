
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: no point of $S^c$ is a limit point of~$S.$

Proof: Suppose that $S$ is closed and $x_0\in S^c$. Since $S^c$ is open,
there is a neighborhood of $x_0$ that is contained in $S^c$ and
therefore contains no points of $S$. Hence, $x_0$ cannot be a limit
point of $S$. For the converse, if no point of $S^c$ is a limit point
of $S$ then every point in $S^c$ must have a neighborhood contained
in $S^c$. Therefore, $S^c$ is open and $S$ is closed.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Suppose that $S$ is closed", "statement": "Premise:\n\u2022 S is a closed set in a topological space X [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [TopologicalSpace X] (S : Set X)\n(tc_1 : IsClosed S)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the condition that S is a closed set in a topological space X. The variable declarations establish X as a type with topological space structure, S as a set in X, and tc_1 as the hypothesis that S is closed. Since there are no conclusions in the natural language statement, the Lean code appropriately contains only variable declarations without any propositions to prove."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since $S^c$ is open,", "statement": "We assume:\n\u2022 S is a closed set in a topological space X [tc_1].\nTherefore, we conclude:\n\u2022 The complement of S, S\u1d9c, is an open set [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (tc_1 : IsClosed S) :\n  IsOpen (S\u1d9c) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (tc_1 : IsClosed S) :\n  IsOpen (S\u1d9c) := by\n  have h_main : IsOpen (S\u1d9c) := by\n    -- Since S is closed, by definition its complement is open.\n    exact tc_1.isOpen_compl\n  -- The result follows directly from the above step.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The topological space X is properly declared, S is correctly specified as a set in X with the closed property as hypothesis tc_1, and the conclusion about the complement being open is accurately represented. The theorem structure appropriately formalizes the logical relationship between the assumption and conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "there is a neighborhood of $x_0$ that is contained in $S^c$", "statement": "We assume:\n\u2022 S\u1d9c is an open set in a topological space X [l1].\nTherefore, we conclude:\n\u2022 For any point x\u2080 \u2208 S\u1d9c, there exists a neighborhood N of x\u2080 such that N \u2286 S\u1d9c [l2].", "dependencies": ["l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (hS : IsClosed S)\n  (l1 : IsOpen (S\u1d9c))\n  (x\u2080 : X) (hx\u2080 : x\u2080 \u2208 S\u1d9c) :\n  \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 S\u1d9c := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (hS : IsClosed S)\n  (l1 : IsOpen (S\u1d9c))\n  (x\u2080 : X) (hx\u2080 : x\u2080 \u2208 S\u1d9c) :\n  \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 S\u1d9c := by\n  have h_main : \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 S\u1d9c := by\n    refine' \u27e8S\u1d9c, l1, hx\u2080, _\u27e9\n    -- We need to show that S\u1d9c \u2286 S\u1d9c, which is trivially true.\n    intro x hx\n    exact hx\n  -- The main statement directly follows from the above construction.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption that S\u1d9c is open is correctly formalized as IsOpen (S\u1d9c)", "The conclusion about neighborhood existence is properly captured. The Lean version proves it for a specific x\u2080 \u2208 S\u1d9c, which is mathematically equivalent to the universal quantification in natural language", "The extra assumption IsClosed S is mathematically consistent with IsOpen (S\u1d9c) and doesn't contradict the natural language. The formalization of neighborhood as an open set containing the point is standard and correct"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "and therefore contains no points of $S$.", "statement": "We assume:\n\u2022 For any point x\u2080 \u2208 S\u1d9c, there exists a neighborhood N of x\u2080 such that N \u2286 S\u1d9c [l2].\nTherefore, we conclude:\n\u2022 For any point x\u2080 \u2208 S\u1d9c, there exists a neighborhood N of x\u2080 such that the intersection of N and S is empty (N \u2229 S = \u2205) [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (hS : IsClosed S)\n  (x\u2080 : X) (hx\u2080 : x\u2080 \u2208 S\u1d9c)\n  (l2 : \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 S\u1d9c) :\n  \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (hS : IsClosed S)\n  (x\u2080 : X) (hx\u2080 : x\u2080 \u2208 Set.compl S)\n  (l2 : \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 Set.compl S) :\n  \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2229 S = \u2205 := by\n  have h_main : \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2229 S = \u2205 := by\n    obtain \u27e8N, hN_open, hx\u2080_in_N, hN_subset_S_compl\u27e9 := l2\n    have hN_inter_S_empty : N \u2229 S = \u2205 := by\n      apply Set.eq_empty_of_forall_not_mem\n      intro x hx\n      have hx_in_N : x \u2208 N := hx.1\n      have hx_in_S : x \u2208 S := hx.2\n      have hx_in_S_compl : x \u2208 Set.compl S := hN_subset_S_compl hx_in_N\n      have hx_not_in_S : x \u2209 S := by simpa using hx_in_S_compl\n      exact hx_not_in_S hx_in_S\n    exact \u27e8N, hN_open, hx\u2080_in_N, hN_inter_S_empty\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language uses universal quantification ('for any point x\u2080 \u2208 S\u1d9c') while the Lean formalization fixes a specific point x\u2080. The logical structure is preserved but the quantification scope differs.", "The conclusion correctly captures that N \u2229 S = \u2205, which is logically equivalent to the premise N \u2286 S\u1d9c. The neighborhood structure (IsOpen N \u2227 x\u2080 \u2208 N) is properly maintained.", "The Lean formalization appropriately sets up the topological space context. The additional condition (hS : IsClosed S) is extra information that doesn't contradict the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Hence, $x_0$ cannot be a limit point of $S$.", "statement": "We assume:\n\u2022 For any point x\u2080 \u2208 S\u1d9c, there exists a neighborhood N of x\u2080 such that N \u2229 S = \u2205 [l3].\nTherefore, we conclude:\n\u2022 No point of S\u1d9c is a limit point of S [ts_1].", "dependencies": ["l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (hS : IsClosed S)\n  (h : \u2200 x\u2080 \u2208 S\u1d9c, \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2229 S = \u2205) :\n  \u2200 x \u2208 S\u1d9c, \u00ac(\u2200 N, IsOpen N \u2192 x \u2208 N \u2192 N \u2229 S \u2260 \u2205) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {X : Type*} [TopologicalSpace X] (S : Set X)\n  (hS : IsClosed S)\n  (h : \u2200 x\u2080 \u2208 S\u1d9c, \u2203 (N : Set X), IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2229 S = \u2205) :\n  \u2200 x \u2208 S\u1d9c, \u00ac(\u2200 N, IsOpen N \u2192 x \u2208 N \u2192 N \u2229 S \u2260 \u2205) := by\n  intro x hx\n  have h_main : \u00ac(\u2200 N, IsOpen N \u2192 x \u2208 N \u2192 N \u2229 S \u2260 \u2205) := by\n    intro h_contra\n    -- Obtain the open neighborhood N from the hypothesis h\n    obtain \u27e8N, hN_open, hN_x, hN_empty\u27e9 := h x hx\n    -- Specialize the contradiction hypothesis to N\n    have hN_nonempty : N \u2229 S \u2260 \u2205 := h_contra N hN_open hN_x\n    -- Derive a contradiction from N \u2229 S = \u2205 and N \u2229 S \u2260 \u2205\n    have hN_empty' : N \u2229 S = \u2205 := hN_empty\n    have hN_nonempty' : N \u2229 S \u2260 \u2205 := hN_nonempty\n    exact hN_nonempty' (by simp [hN_empty'])\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premise about neighborhoods is correctly formalized with proper topological definitions (IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2229 S = \u2205)", "The conclusion correctly formalizes 'not a limit point' by negating the standard definition of limit point in topology", "The additional IsClosed assumption is mathematically consistent and doesn't contradict the natural language statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "tc_2": {"id": "tc_2", "natural_language": "if no point of $S^c$ is a limit point of $S$", "statement": "Premise:\n\u2022 In a topological space X, for a set S, no point of its complement S\u1d9c is a limit point of S [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 {X : Type*} [TopologicalSpace X] (S : Set X) :\n  (\u2200 x \u2209 S, \u2200 U : Set X, IsOpen U \u2192 x \u2208 U \u2192 U \u2229 S = \u2205) \u2194 IsClosed S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Both express that X is a topological space", "Both express that S is a set in the topological space X", "The Lean formulation uses '\u2200 x \u2209 S' which correctly refers to points in the complement of S", "The natural language states that no point of S\u1d9c is a limit point of S, but the Lean formalization presents a biconditional characterization of closed sets using open neighborhoods. The Lean statement is about the equivalence between a neighborhood condition and the closedness of S, which is fundamentally different from the direct statement about limit points in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Both express that X is a topological space', 'Both express that S is a set in the topological space X', \"The Lean formulation uses '\u2200 x \u2209 S' which correctly refers to points in the complement of S\", 'The natural language states that no point of S\u1d9c is a limit point of S, but the Lean formalization presents a biconditional characterization of closed sets using open neighborhoods. The Lean statement is about the equivalence between a neighborhood condition and the closedness of S, which is fundamentally different from the direct statement about limit points in the natural language']"}, "type": "condition"}, "l4": {"id": "l4", "natural_language": "every point in $S^c$ must have a neighborhood contained in $S^c$.", "statement": "We assume:\n\u2022 No point of S\u1d9c is a limit point of S [tc_2].\nTherefore, we conclude:\n\u2022 Every point x\u2080 in S\u1d9c has a neighborhood N such that N \u2286 S\u1d9c [l4].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {X : Type*} [TopologicalSpace X] (S : Set X) :\n  (\u2200 x \u2209 S, \u2200 U, IsOpen U \u2192 x \u2208 U \u2192 U \u2229 S = \u2205) \u2192\n  (\u2200 x \u2209 S, \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {X : Type*} [TopologicalSpace X] (S : Set X) :\n  (\u2200 x \u2209 S, \u2200 U, IsOpen U \u2192 x \u2208 U \u2192 U \u2229 S = \u2205) \u2192\n  (\u2200 x \u2209 S, \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c) := by\n  intro h\n  intro x hx\n  have h\u2081 : \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c := by\n    use Set.univ\n    constructor\n    \u00b7 exact isOpen_univ\n    constructor\n    \u00b7 exact Set.mem_univ x\n    \u00b7 -- Prove that Set.univ \u2286 S\u1d9c\n      intro y hy\n      have h\u2082 : (Set.univ : Set X) \u2229 S = \u2205 := by\n        have h\u2083 := h x hx (Set.univ : Set X) isOpen_univ (Set.mem_univ x)\n        exact h\u2083\n      -- Since Set.univ \u2229 S = \u2205, y cannot be in S\n      have h\u2084 : y \u2209 S := by\n        by_contra h\u2085\n        have h\u2086 : y \u2208 (Set.univ : Set X) \u2229 S := by\n          exact \u27e8Set.mem_univ y, h\u2085\u27e9\n        have h\u2087 : y \u2208 (\u2205 : Set X) := by\n          rw [h\u2082] at h\u2086\n          exact h\u2086\n        exact Set.not_mem_empty y h\u2087\n      exact h\u2084\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean premise is stronger than the natural language assumption. The natural language states 'no point of S\u1d9c is a limit point of S', but the Lean formalization requires that every open neighborhood of points outside S has empty intersection with S, which means these points are not even adherent points of S. While this stronger condition implies the natural language statement, it's not an exact translation.", "The Lean conclusion perfectly captures the natural language conclusion. Both state that every point outside S (equivalently in S\u1d9c) has an open neighborhood contained entirely in S\u1d9c.", "The overall logical structure as an implication is correctly preserved in the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, $S^c$ is open", "statement": "We assume:\n\u2022 Every point x\u2080 in S\u1d9c has a neighborhood N such that N \u2286 S\u1d9c [l4].\nTherefore, we conclude:\n\u2022 The set S\u1d9c is open [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {X : Type*} [TopologicalSpace X] (S : Set X) \n  (l4 : \u2200 x \u2209 S, \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c) : \n  IsOpen (S\u1d9c) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {X : Type*} [TopologicalSpace X] (S : Set X) \n  (l4 : \u2200 x \u2209 S, \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c) : \n  IsOpen (S\u1d9c) := by\n  have h_main : \u2200 x \u2208 S\u1d9c, \u2203 (U : Set X), IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c := by\n    intro x hx\n    have h : x \u2209 S := by simpa using hx\n    obtain \u27e8U, hU_open, hU_x, hU_subset\u27e9 := l4 x h\n    exact \u27e8U, hU_open, hU_x, hU_subset\u27e9\n  \n  have h_final : IsOpen (S\u1d9c) := by\n    apply isOpen_iff_forall_mem_open.mpr\n    intro x hx\n    obtain \u27e8U, hU_open, hU_x, hU_subset\u27e9 := h_main x hx\n    refine' \u27e8U, hU_open, hU_x, _\u27e9\n    exact hU_subset\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 16, "endLine": 17, "endColumn": 23, "data": "application type mismatch\n  And.intro hU_open\nargument\n  hU_open\nhas type\n  IsOpen U : Prop\nbut is expected to have type\n  U \u2286 S\u1d9c : Prop"}, {"line": 17, "column": 25, "endLine": 17, "endColumn": 29, "data": "application type mismatch\n  And.intro hU_x\nargument\n  hU_x\nhas type\n  x \u2208 U : Prop\nbut is expected to have type\n  IsOpen U : Prop"}, {"line": 18, "column": 4, "endLine": 18, "endColumn": 19, "data": "type mismatch\n  hU_subset\nhas type\n  U \u2286 S\u1d9c : Prop\nbut is expected to have type\n  x \u2208 U : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the assumption. The natural language uses 'neighborhood N' informally, while Lean makes explicit that this means an open set U containing x and contained in S\u1d9c. The notation 'x \u2209 S' is equivalent to 'x \u2208 S\u1d9c'. The additional explicit conditions (IsOpen U, x \u2208 U) are mathematically necessary details that formalize the concept of neighborhood.", "The conclusion is identically expressed in both natural language and Lean - that S\u1d9c is open.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem not_l5 {X : Type*} [TopologicalSpace X] : (\u2203 (S : Set X), (\u2200 x \u2209 S, \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c) \u2227 \u00acIsOpen (S\u1d9c)) := by\n  have h : \u2203 (S : Set X), (\u2200 x \u2209 S, \u2203 U, IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c) \u2227 \u00acIsOpen (S\u1d9c) := by\n    classical\n    -- We will use S = \u2205 as a candidate set\n    use \u2205\n    constructor\n    \u00b7 -- Prove that for all x \u2209 \u2205, there exists an open set U containing x such that U \u2286 (\u2205)\u1d9c\n      intro x hx\n      exfalso\n      exact hx (by simp)\n    \u00b7 -- Prove that (\u2205)\u1d9c is not open\n      have h\u2081 : (\u2205 : Set X)\u1d9c = (univ : Set X) := by\n        ext x\n        simp\n      rw [h\u2081]\n      -- In a topological space, the universal set is always open\n      have h\u2082 : IsOpen (univ : Set X) := isOpen_univ\n      simp_all\n  exact h"}, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "and $S$ is closed.", "statement": "We assume:\n\u2022 The set S\u1d9c is open [l5].\nTherefore, we conclude:\n\u2022 The set S is closed [ts_2].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 {X : Type*} [TopologicalSpace X] (S : Set X)\n  (l5 : IsOpen (S\u1d9c)) :\n  IsClosed S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 {X : Type*} [TopologicalSpace X] (S : Set X)\n  (l5 : IsOpen (S\u1d9c)) :\n  IsClosed S := by\n  have h_main : IsClosed S := by\n    have h\u2081 : IsClosed (S\u1d9c)\u1d9c := l5.isClosed_compl\n    have h\u2082 : (S\u1d9c)\u1d9c = S := by\n      apply Set.ext\n      intro x\n      simp [Set.mem_compl_iff]\n      <;> tauto\n    rw [h\u2082] at h\u2081\n    exact h\u2081\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the natural language statement. The premise 'S\u1d9c is open [l5]' is correctly represented as '(l5 : IsOpen (S\u1d9c))', and the conclusion 'S is closed [ts_2]' is accurately captured as 'IsClosed S' with theorem name 'ts_2'. The additional type declarations '{X : Type*} [TopologicalSpace X] (S : Set X)' provide necessary mathematical context for formal verification without contradicting the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    