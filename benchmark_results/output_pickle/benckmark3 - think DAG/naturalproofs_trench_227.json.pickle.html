
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\rho$ and $\sigma$ are equivalent  metrics on a set $A,$ then
 $(A,\rho)$ and $(A,\sigma)$ have the same open sets.

Proof: Suppose that \eqref{eq:8.1.18} holds. Let $S$ be an open set in
$(A,\rho)$ and let $x_0\in S$. Then there is an $\epsilon>0$ such
that $x\in S$ if $\rho(x,x_0)<\epsilon$, so the second
inequality in \eqref{eq:8.1.18}
implies  that $x_0\in S$ if $\sigma(x,x_0)\le\epsilon/\beta$.
Therefore, $S$ is open in $(A,\sigma)$.
Conversely, suppose that $S$ is open in $(A,\sigma)$
and let $x_0\in S$. Then there is an $\epsilon>0$ such
that $x\in S$ if $\sigma(x,x_0)<\epsilon$, so the first
inequality in \eqref{eq:8.1.18}
implies  that $x_0\in S$ if $\rho(x,x_0)\le\epsilon\alpha$.
Therefore, $S$ is open in $(A,\rho)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\rho$ and $\\sigma$ are equivalent  metrics on a set $A,$... Suppose that \\eqref{eq:8.1.18} holds.", "statement": "Premise:\n\u2022 $\\rho$ and $\\sigma$ are equivalent metrics on a set $A$, meaning there exist positive constants $\\alpha$ and $\\beta$ such that for all $x, y \\in A$, $\\alpha\\sigma(x, y) \\le \\rho(x, y) \\le \\beta\\sigma(x, y)$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) (\u03b1 \u03b2 : \u211d)\n(tc_1 : 0 < \u03b1 \u2227 0 < \u03b2 \u2227 \u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language states that \u03c1 and \u03c3 are 'equivalent metrics on a set A', but the Lean formalization only declares them as functions A \u2192 A \u2192 \u211d without explicitly stating they are metrics. However, the equivalence relationship is captured through the inequality conditions, so the mathematical meaning is preserved.", "The Lean formalization correctly captures the existence of positive constants \u03b1 and \u03b2 through the positivity conditions 0 < \u03b1 \u2227 0 < \u03b2.", "The Lean formalization perfectly captures the inequality condition with \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y, which is equivalent to the mathematical statement \u03b1\u00b7\u03c3(x,y) \u2264 \u03c1(x,y) \u2264 \u03b2\u00b7\u03c3(x,y)."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Let $S$ be an open set in $(A,\\rho)$ and let $x_0\\in S$. Then there is an $\\epsilon>0$ such that $x\\in S$ if $\\rho(x,x_0)<\\epsilon$.", "statement": "We assume:\n\u2022 $S$ is an open set in $(A,\\rho)$ [assumption_part1].\n\u2022 $x_0$ is an arbitrary element of $S$ [assumption_part1].\nTherefore, we conclude:\n\u2022 There exists an $\\epsilon>0$ such that for any $x \\in A$, if $\\rho(x,x_0)<\\epsilon$ then $x \\in S$ [l1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {A : Type*} [MetricSpace A] \n  (S : Set A) (hS : IsOpen S) (x\u2080 : A) (hx\u2080 : x\u2080 \u2208 S) :\n  \u2203 \u03b5 > 0, \u2200 x : A, dist x x\u2080 < \u03b5 \u2192 x \u2208 S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {A : Type*} [MetricSpace A] \n  (S : Set A) (hS : IsOpen S) (x\u2080 : A) (hx\u2080 : x\u2080 \u2208 S) :\n  \u2203 \u03b5 > 0, \u2200 x : A, dist x x\u2080 < \u03b5 \u2192 x \u2208 S := by\n  have h_main : \u2203 (\u03b5 : \u211d), \u03b5 > 0 \u2227 \u2200 (x : A), dist x x\u2080 < \u03b5 \u2192 x \u2208 S := by\n    -- Use the property of open sets in metric spaces to find \u03b5 > 0 such that the ball around x\u2080 is contained in S.\n    have h\u2081 : \u2203 \u03b5 > 0, Metric.ball x\u2080 \u03b5 \u2286 S := by\n      rw [Metric.isOpen_iff] at hS\n      -- Extract \u03b5 > 0 from the definition of open sets in metric spaces.\n      obtain \u27e8\u03b5, h\u03b5, h\u2082\u27e9 := hS x\u2080 hx\u2080\n      exact \u27e8\u03b5, h\u03b5, h\u2082\u27e9\n    -- Obtain \u03b5 > 0 and the subset condition.\n    obtain \u27e8\u03b5, h\u03b5, h\u2082\u27e9 := h\u2081\n    refine' \u27e8\u03b5, h\u03b5, _\u27e9\n    -- For any x with dist x x\u2080 < \u03b5, x is in the ball and hence in S.\n    intro x hx\n    have h\u2083 : x \u2208 Metric.ball x\u2080 \u03b5 := by\n      exact Metric.mem_ball.mpr hx\n    have h\u2084 : x \u2208 S := h\u2082 h\u2083\n    exact h\u2084\n  \n  obtain \u27e8\u03b5, h\u03b5, h_main\u27e9 := h_main\n  refine' \u27e8\u03b5, h\u03b5, _\u27e9\n  intro x hx\n  exact h_main x hx", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The metric space structure is correctly captured with MetricSpace typeclass and dist function corresponding to \u03c1", "The open set assumption is directly translated using IsOpen predicate", "The element membership assumption is properly formalized with the hypothesis hx\u2080 : x\u2080 \u2208 S", "The conclusion perfectly captures the existential-universal quantification structure with the distance condition and set membership", "The overall logical structure correctly transforms the natural language assumptions and conclusion into a well-formed Lean theorem"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "so the second inequality in \\eqref{eq:8.1.18} implies that $x_0\\in S$ if $\\sigma(x,x_0)\\le\\epsilon/\\beta$.", "statement": "We assume:\n\u2022 For all $x, y \\in A$, $\\rho(x, y) \\le \\beta\\sigma(x, y)$ for some $\\beta > 0$ [tc_1].\n\u2022 For a given $x_0 \\in S$, there exists an $\\epsilon>0$ such that for any $x \\in A$, if $\\rho(x,x_0)<\\epsilon$ then $x \\in S$ [l1].\nTherefore, we conclude:\n\u2022 For the same $x_0$ and $\\epsilon$, we can define $\\delta = \\epsilon/\\beta$, which is positive, and for any $x \\in A$, if $\\sigma(x,x_0) < \\delta$, then $x \\in S$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {A : Type*} [TopologicalSpace A] (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n  (h_equiv : 0 < \u03b1 \u2227 0 < \u03b2 \u2227 \u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y)\n  (S : Set A) (hS : IsOpen S) (x\u2080 : A) (hx\u2080 : x\u2080 \u2208 S)\n  (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) (h_ball : \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) :\n  \u2200 x : A, \u03c3 x x\u2080 < \u03b5 / \u03b2 \u2192 x \u2208 S := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {A : Type*} [TopologicalSpace A] (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n  (h_equiv : 0 < \u03b1 \u2227 0 < \u03b2 \u2227 \u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y)\n  (S : Set A) (hS : IsOpen S) (x\u2080 : A) (hx\u2080 : x\u2080 \u2208 S)\n  (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) (h_ball : \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) :\n  \u2200 x : A, \u03c3 x x\u2080 < \u03b5 / \u03b2 \u2192 x \u2208 S := by\n  have h\u03b2_pos : 0 < \u03b2 := by\n    have h\u2082 : 0 < \u03b2 := h_equiv.2.1\n    exact h\u2082\n  \n  intro x hx\n  have h\u03b2\u03c3_lt_\u03b5 : \u03b2 * \u03c3 x x\u2080 < \u03b5 := by\n    have h\u2081 : \u03c3 x x\u2080 < \u03b5 / \u03b2 := hx\n    have h\u2082 : 0 < \u03b2 := h\u03b2_pos\n    have h\u2083 : \u03b2 * \u03c3 x x\u2080 < \u03b2 * (\u03b5 / \u03b2) := by\n      -- Multiply both sides of the inequality by \u03b2 (which is positive)\n      have h\u2084 : \u03c3 x x\u2080 < \u03b5 / \u03b2 := h\u2081\n      have h\u2085 : \u03b2 * \u03c3 x x\u2080 < \u03b2 * (\u03b5 / \u03b2) := by\n        -- Use the fact that \u03b2 is positive to preserve the inequality direction\n        nlinarith\n      exact h\u2085\n    have h\u2084 : \u03b2 * (\u03b5 / \u03b2) = \u03b5 := by\n      -- Simplify \u03b2 * (\u03b5 / \u03b2) to \u03b5\n      field_simp [h\u2082.ne']\n      <;> ring\n      <;> linarith\n    -- Combine the inequalities to get \u03b2 * \u03c3 x x\u2080 < \u03b5\n    linarith\n  \n  have h\u03c1_lt_\u03b5 : \u03c1 x x\u2080 < \u03b5 := by\n    have h\u2081 : \u03c1 x x\u2080 \u2264 \u03b2 * \u03c3 x x\u2080 := (h_equiv.2.2 x x\u2080).2\n    linarith\n  \n  have hx_in_S : x \u2208 S := by\n    have h\u2081 : \u03c1 x x\u2080 < \u03b5 := h\u03c1_lt_\u03b5\n    have h\u2082 : x \u2208 S := h_ball x h\u2081\n    exact h\u2082\n  \n  exact hx_in_S", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The upper bound condition \u03c1(x,y) \u2264 \u03b2\u00b7\u03c3(x,y) with \u03b2 > 0 is correctly captured in the Lean formalization.", "The local inclusion property around x\u2080 \u2208 S with radius \u03b5 is properly formalized with all necessary components.", "The conclusion correctly states the derived inclusion property using \u03b4 = \u03b5/\u03b2 as the threshold for the \u03c3 metric.", "The additional mathematical structure (lower bound, open set assumption, parameter \u03b1) enhances the formalization without contradicting the natural language statements."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, $S$ is open in $(A,\\sigma)$.", "statement": "We assume:\n\u2022 S is a set that is open in $(A, \\rho)$ [assumption_part1].\n\u2022 For any arbitrary $x_0 \\in S$, we have shown that there exists a $\\delta > 0$ such that the open ball $B_\\sigma(x_0, \\delta)$ is a subset of $S$ [l2].\nTherefore, we conclude:\n\u2022 The set $S$ is open in $(A,\\sigma)$ [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {A : Type*} [TopologicalSpace A] (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n  (h_equiv : 0 < \u03b1 \u2227 0 < \u03b2 \u2227 \u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y)\n  (S : Set A) (hS : IsOpen S) (x\u2080 : A) (hx\u2080 : x\u2080 \u2208 S)\n  (\u03b4 : \u211d) (h\u03b4 : 0 < \u03b4) (h_ball : \u2200 x : A, \u03c1 x x\u2080 < \u03b4 \u2192 x \u2208 S) :\n  \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {A : Type*} [TopologicalSpace A] (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n  (h_equiv : 0 < \u03b1 \u2227 0 < \u03b2 \u2227 \u2200 x y : A, \u03b1 * \u03c3 x y \u2264 \u03c1 x y \u2227 \u03c1 x y \u2264 \u03b2 * \u03c3 x y)\n  (S : Set A) (hS : IsOpen S) (x\u2080 : A) (hx\u2080 : x\u2080 \u2208 S)\n  (\u03b4 : \u211d) (h\u03b4 : 0 < \u03b4) (h_ball : \u2200 x : A, \u03c1 x x\u2080 < \u03b4 \u2192 x \u2208 S) :\n  \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S := by\n  have h\u03b2_pos : 0 < \u03b2 := by\n    have h\u2081 : 0 < \u03b2 := h_equiv.2.1\n    exact h\u2081\n  \n  have h\u03b5_def : \u2203 (\u03b5 : \u211d), \u03b5 = \u03b4 / \u03b2 := by\n    refine' \u27e8\u03b4 / \u03b2, _\u27e9\n    <;> rfl\n  \n  have h_main : \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S := by\n    use \u03b4 / \u03b2\n    constructor\n    \u00b7 -- Prove that \u03b4 / \u03b2 > 0\n      have h\u2081 : 0 < \u03b4 := h\u03b4\n      have h\u2082 : 0 < \u03b2 := h\u03b2_pos\n      exact div_pos h\u2081 h\u2082\n    \u00b7 -- Prove that for all x, if \u03c3 x x\u2080 < \u03b4 / \u03b2 then x \u2208 S\n      intro x hx\n      have h\u2081 : 0 < \u03b2 := h\u03b2_pos\n      have h\u2082 : \u03c3 x x\u2080 < \u03b4 / \u03b2 := hx\n      have h\u2083 : \u03b2 * \u03c3 x x\u2080 < \u03b4 := by\n        calc\n          \u03b2 * \u03c3 x x\u2080 < \u03b2 * (\u03b4 / \u03b2) := by gcongr\n          _ = \u03b4 := by\n            field_simp [h\u2081.ne']\n            <;> ring\n            <;> linarith\n      have h\u2084 : \u03c1 x x\u2080 \u2264 \u03b2 * \u03c3 x x\u2080 := (h_equiv.2.2 x x\u2080).2\n      have h\u2085 : \u03c1 x x\u2080 < \u03b4 := by\n        linarith\n      have h\u2086 : x \u2208 S := h_ball x h\u2085\n      exact h\u2086\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The natural language treats the open ball property as a general result for any x\u2080 \u2208 S, while Lean formalizes it as an assumption for a specific x\u2080. The logical meaning is preserved but the structural presentation differs.", "The open ball condition B_\u03c1(x\u2080, \u03b4) \u2286 S is correctly captured as '\u2200 x : A, \u03c1 x x\u2080 < \u03b4 \u2192 x \u2208 S'.", "The conclusion about S being open in (A, \u03c3) is correctly formalized as proving the existence of an \u03b5-ball in the \u03c3-metric, which is equivalent to openness.", "The Lean formalization appropriately includes the metric equivalence condition (h_equiv) which is essential for the mathematical validity of the statement, even though not explicitly mentioned in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Conversely, suppose that $S$ is open in $(A,\\sigma)$ and let $x_0\\in S$. Then there is an $\\epsilon>0$ such that $x\\in S$ if $\\sigma(x,x_0)<\\epsilon$.", "statement": "We assume:\n\u2022 $S$ is an open set in $(A,\\sigma)$ [assumption_part2].\n\u2022 $x_0$ is an arbitrary element of $S$ [assumption_part2].\nTherefore, we conclude:\n\u2022 There exists an $\\epsilon>0$ such that for any $x \\in A$, if $\\sigma(x,x_0)<\\epsilon$ then $x \\in S$ [l4].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem equivalent_metrics_preserve_open_sets {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem equivalent_metrics_preserve_open_sets {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n  intro S\n  have h_imp : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03b5'\u27e9 := h\n    have h\u2081 : 0 < \u03b1 * \u03b5 := by positivity\n    refine' \u27e8x\u2080, hx\u2080, \u03b1 * \u03b5, by positivity, _\u27e9\n    intro x hx\n    have h\u2082 : \u03b1 * \u03c1 x x\u2080 \u2264 \u03c3 x x\u2080 := (h_equiv x x\u2080).1\n    have h\u2083 : \u03c3 x x\u2080 < \u03b1 * \u03b5 := hx\n    have h\u2084 : \u03b1 * \u03c1 x x\u2080 < \u03b1 * \u03b5 := by linarith\n    have h\u2085 : \u03c1 x x\u2080 < \u03b5 := by\n      -- Since \u03b1 > 0, we can divide both sides of the inequality by \u03b1 to get \u03c1 x x\u2080 < \u03b5\n      have h\u2086 : 0 < \u03b1 := by linarith\n      have h\u2087 : \u03b1 * \u03c1 x x\u2080 < \u03b1 * \u03b5 := h\u2084\n      have h\u2088 : \u03c1 x x\u2080 < \u03b5 := by\n        -- Divide both sides by \u03b1\n        have h\u2089 : \u03c1 x x\u2080 < \u03b5 := by\n          by_contra h\u2089\n          -- If \u03c1 x x\u2080 \u2265 \u03b5, then \u03b1 * \u03c1 x x\u2080 \u2265 \u03b1 * \u03b5, which contradicts h\u2084\n          have h\u2081\u2080 : \u03c1 x x\u2080 \u2265 \u03b5 := by linarith\n          have h\u2081\u2081 : \u03b1 * \u03c1 x x\u2080 \u2265 \u03b1 * \u03b5 := by\n            nlinarith\n          linarith\n        exact h\u2089\n      exact h\u2088\n    -- Since \u03c1 x x\u2080 < \u03b5, we have x \u2208 S by h\u03b5'\n    exact h\u03b5' x h\u2085\n  \n  have h_conv : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03b5'\u27e9 := h\n    have h\u2081 : 0 < \u03b5 / \u03b2 := by positivity\n    refine' \u27e8x\u2080, hx\u2080, \u03b5 / \u03b2, by positivity, _\u27e9\n    intro x hx\n    have h\u2082 : \u03c3 x x\u2080 \u2264 \u03b2 * \u03c1 x x\u2080 := (h_equiv x x\u2080).2\n    have h\u2083 : \u03c1 x x\u2080 < \u03b5 / \u03b2 := hx\n    have h\u2084 : \u03c3 x x\u2080 < \u03b5 := by\n      calc\n        \u03c3 x x\u2080 \u2264 \u03b2 * \u03c1 x x\u2080 := h\u2082\n        _ < \u03b2 * (\u03b5 / \u03b2) := by gcongr\n        _ = \u03b5 := by\n          field_simp [h\u03b2.ne']\n          <;> ring\n          <;> linarith\n    -- Since \u03c3 x x\u2080 < \u03b5, we have x \u2208 S by h\u03b5'\n    exact h\u03b5' x h\u2084\n  \n  have h_main : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    constructor\n    \u00b7 -- Prove the forward direction: (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S)\n      intro h\n      exact h_imp h\n    \u00b7 -- Prove the backward direction: (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S)\n      intro h\n      exact h_conv h\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes a specific logical inference about a single open set S having the epsilon-neighborhood property, while the Lean formalization proves a general biconditional equivalence between openness characterizations under two equivalent metrics. The natural language assumes S is open in (A,\u03c3) as a premise, but the Lean theorem doesn't include this assumption - instead it characterizes openness itself. The logical structure is fundamentally different: the natural language shows a simple implication (open set \u2192 has neighborhood property) while Lean shows an equivalence between two different metric characterizations of openness."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language describes a specific logical inference about a single open set S having the epsilon-neighborhood property, while the Lean formalization proves a general biconditional equivalence between openness characterizations under two equivalent metrics. The natural language assumes S is open in (A,\u03c3) as a premise, but the Lean theorem doesn't include this assumption - instead it characterizes openness itself. The logical structure is fundamentally different: the natural language shows a simple implication (open set \u2192 has neighborhood property) while Lean shows an equivalence between two different metric characterizations of openness.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "so the first inequality in \\eqref{eq:8.1.18} implies that $x_0\\in S$ if $\\rho(x,x_0)\\le\\epsilon\\alpha$.", "statement": "We assume:\n\u2022 For all $x, y \\in A$, $\\alpha\\sigma(x, y) \\le \\rho(x, y)$ for some $\\alpha > 0$ [tc_1].\n\u2022 For a given $x_0 \\in S$, there exists an $\\epsilon>0$ such that for any $x \\in A$, if $\\sigma(x,x_0)<\\epsilon$ then $x \\in S$ [l4].\nTherefore, we conclude:\n\u2022 For the same $x_0$ and $\\epsilon$, we can define $\\delta = \\epsilon\\alpha$, which is positive, and for any $x \\in A$, if $\\rho(x,x_0) < \\delta$, then $x \\in S$ [l5].", "dependencies": ["tc_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem equivalent_metrics_preserve_open_sets {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem equivalent_metrics_preserve_open_sets {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n  intro S\n  have h_imp : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03c1\u27e9 := h\n    have h\u2081 : \u2203 (\u03b5' : \u211d), \u03b5' > 0 \u2227 \u2200 (x : A), \u03c3 x x\u2080 < \u03b5' \u2192 \u03c1 x x\u2080 < \u03b5 := by\n      use \u03b1 * \u03b5\n      constructor\n      \u00b7 -- Prove that \u03b1 * \u03b5 > 0\n        have h\u2082 : \u03b1 > 0 := h\u03b1\n        have h\u2083 : \u03b5 > 0 := h\u03b5\n        positivity\n      \u00b7 -- Prove that if \u03c3 x x\u2080 < \u03b1 * \u03b5, then \u03c1 x x\u2080 < \u03b5\n        intro x h\u03c3\n        have h\u2084 : \u03b1 * \u03c1 x x\u2080 \u2264 \u03c3 x x\u2080 := (h_equiv x x\u2080).1\n        have h\u2085 : \u03c3 x x\u2080 < \u03b1 * \u03b5 := h\u03c3\n        have h\u2086 : \u03b1 * \u03c1 x x\u2080 < \u03b1 * \u03b5 := by linarith\n        have h\u2087 : \u03c1 x x\u2080 < \u03b5 := by\n          -- Since \u03b1 > 0, we can divide both sides by \u03b1\n          have h\u2088 : 0 < \u03b1 := h\u03b1\n          have h\u2089 : \u03c1 x x\u2080 < \u03b5 := by\n            by_contra h\u2089\n            have h\u2081\u2080 : \u03c1 x x\u2080 \u2265 \u03b5 := by linarith\n            have h\u2081\u2081 : \u03b1 * \u03c1 x x\u2080 \u2265 \u03b1 * \u03b5 := by\n              nlinarith\n            linarith\n          exact h\u2089\n        exact h\u2087\n    obtain \u27e8\u03b5', h\u03b5', h\u2082\u27e9 := h\u2081\n    refine' \u27e8x\u2080, hx\u2080, \u03b5', h\u03b5', _\u27e9\n    intro x h\u03c3\n    have h\u2083 : \u03c1 x x\u2080 < \u03b5 := h\u2082 x h\u03c3\n    exact h\u03c1 x h\u2083\n  \n  have h_conv : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03c3\u27e9 := h\n    have h\u2081 : \u2203 (\u03b5' : \u211d), \u03b5' > 0 \u2227 \u2200 (x : A), \u03c1 x x\u2080 < \u03b5' \u2192 \u03c3 x x\u2080 < \u03b5 := by\n      use \u03b5 / \u03b2\n      constructor\n      \u00b7 -- Prove that \u03b5 / \u03b2 > 0\n        have h\u2082 : \u03b2 > 0 := h\u03b2\n        have h\u2083 : \u03b5 > 0 := h\u03b5\n        positivity\n      \u00b7 -- Prove that if \u03c1 x x\u2080 < \u03b5 / \u03b2, then \u03c3 x x\u2080 < \u03b5\n        intro x h\u03c1\n        have h\u2084 : \u03c3 x x\u2080 \u2264 \u03b2 * \u03c1 x x\u2080 := (h_equiv x x\u2080).2\n        have h\u2085 : \u03c1 x x\u2080 < \u03b5 / \u03b2 := h\u03c1\n        have h\u2086 : \u03b2 * \u03c1 x x\u2080 < \u03b2 * (\u03b5 / \u03b2) := by\n          have h\u2087 : 0 < \u03b2 := h\u03b2\n          nlinarith\n        have h\u2087 : \u03b2 * (\u03b5 / \u03b2) = \u03b5 := by\n          field_simp [h\u03b2.ne']\n          <;> ring\n        have h\u2088 : \u03b2 * \u03c1 x x\u2080 < \u03b5 := by linarith\n        have h\u2089 : \u03c3 x x\u2080 < \u03b5 := by linarith\n        exact h\u2089\n    obtain \u27e8\u03b5', h\u03b5', h\u2082\u27e9 := h\u2081\n    refine' \u27e8x\u2080, hx\u2080, \u03b5', h\u03b5', _\u27e9\n    intro x h\u03c1\n    have h\u2083 : \u03c3 x x\u2080 < \u03b5 := h\u2082 x h\u03c1\n    exact h\u03c3 x h\u2083\n  \n  have h_main : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    constructor\n    \u00b7 -- Prove the forward direction: (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S)\n      intro h\n      exact h_imp h\n    \u00b7 -- Prove the backward direction: (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S)\n      intro h\n      exact h_conv h\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The metric relationship is reversed: natural language states \u03b1\u00b7\u03c3(x,y) \u2264 \u03c1(x,y) but Lean has \u03b1\u00b7\u03c1(x,y) \u2264 \u03c3(x,y). This is a fundamental mathematical error that changes the meaning completely.", "The logical structure is different: natural language presents assumptions leading to a conclusion, while Lean presents a biconditional equivalence. The natural language describes a one-way implication, not a two-way equivalence.", "The Lean formalization captures the general idea of relating properties under different metrics but misses the specific construction mentioned in the natural language (\u03b4 = \u03b5\u00b7\u03b1) and the requirement that it's the 'same x\u2080 and \u03b5'."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The metric relationship is reversed: natural language states \u03b1\u00b7\u03c3(x,y) \u2264 \u03c1(x,y) but Lean has \u03b1\u00b7\u03c1(x,y) \u2264 \u03c3(x,y). This is a fundamental mathematical error that changes the meaning completely.', 'The logical structure is different: natural language presents assumptions leading to a conclusion, while Lean presents a biconditional equivalence. The natural language describes a one-way implication, not a two-way equivalence.', \"The Lean formalization captures the general idea of relating properties under different metrics but misses the specific construction mentioned in the natural language (\u03b4 = \u03b5\u00b7\u03b1) and the requirement that it's the 'same x\u2080 and \u03b5'.\"]"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Therefore, $S$ is open in $(A,\\rho)$.", "statement": "We assume:\n\u2022 S is a set that is open in $(A, \\sigma)$ [assumption_part2].\n\u2022 For any arbitrary $x_0 \\in S$, we have shown that there exists a $\\delta > 0$ such that the open ball $B_\\rho(x_0, \\delta)$ is a subset of $S$ [l5].\nTherefore, we conclude:\n\u2022 The set $S$ is open in $(A,\\rho)$ [l6].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem equivalent_metrics_preserve_open_sets {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem equivalent_metrics_preserve_open_sets {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n  intro S\n  have h_imp_forward : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03b5'\u27e9 := h\n    refine' \u27e8x\u2080, hx\u2080, \u03b1 * \u03b5, by positivity, _\u27e9\n    intro x hx\n    have h\u2081 : \u03c3 x x\u2080 < \u03b1 * \u03b5 := hx\n    have h\u2082 : \u03b1 * \u03c1 x x\u2080 \u2264 \u03c3 x x\u2080 := (h_equiv x x\u2080).1\n    have h\u2083 : \u03b1 * \u03c1 x x\u2080 < \u03b1 * \u03b5 := by linarith\n    have h\u2084 : \u03c1 x x\u2080 < \u03b5 := by\n      by_contra h\u2084\n      have h\u2085 : \u03c1 x x\u2080 \u2265 \u03b5 := by linarith\n      have h\u2086 : \u03b1 * \u03c1 x x\u2080 \u2265 \u03b1 * \u03b5 := by\n        nlinarith\n      linarith\n    have h\u2085 : x \u2208 S := h\u03b5' x h\u2084\n    exact h\u2085\n  \n  have h_imp_backward : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03b5'\u27e9 := h\n    refine' \u27e8x\u2080, hx\u2080, \u03b5 / \u03b2, by positivity, _\u27e9\n    intro x hx\n    have h\u2081 : \u03c1 x x\u2080 < \u03b5 / \u03b2 := hx\n    have h\u2082 : \u03c3 x x\u2080 \u2264 \u03b2 * \u03c1 x x\u2080 := (h_equiv x x\u2080).2\n    have h\u2083 : \u03c3 x x\u2080 < \u03b5 := by\n      calc\n        \u03c3 x x\u2080 \u2264 \u03b2 * \u03c1 x x\u2080 := h\u2082\n        _ < \u03b2 * (\u03b5 / \u03b2) := by\n          gcongr\n          <;> linarith\n        _ = \u03b5 := by\n          field_simp [h\u03b2.ne']\n          <;> ring\n          <;> linarith\n    have h\u2084 : x \u2208 S := h\u03b5' x h\u2083\n    exact h\u2084\n  \n  have h_main : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    constructor\n    \u00b7 -- Prove the forward direction: (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S)\n      exact h_imp_forward\n    \u00b7 -- Prove the backward direction: (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S)\n      exact h_imp_backward\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization presents a biconditional theorem rather than capturing the directional argument structure described in the natural language (assumption \u2192 property \u2192 conclusion)", "The natural language explicitly assumes S is open in (A,\u03c3) as a premise, but the Lean formalization treats both openness conditions as equivalent rather than assuming one direction", "The open ball property is captured semantically but with different notation - using logical conditions rather than explicit ball subset notation", "The natural language presents this as a conclusion from premises, but the Lean formalization treats it as one side of an equivalence without the directional logical flow", "The Lean formalization appropriately includes the metric equivalence conditions that make the natural language argument valid, even though not explicitly mentioned in the excerpt"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization presents a biconditional theorem rather than capturing the directional argument structure described in the natural language (assumption \u2192 property \u2192 conclusion)', 'The natural language explicitly assumes S is open in (A,\u03c3) as a premise, but the Lean formalization treats both openness conditions as equivalent rather than assuming one direction', 'The open ball property is captured semantically but with different notation - using logical conditions rather than explicit ball subset notation', 'The natural language presents this as a conclusion from premises, but the Lean formalization treats it as one side of an equivalence without the directional logical flow', 'The Lean formalization appropriately includes the metric equivalence conditions that make the natural language argument valid, even though not explicitly mentioned in the excerpt']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "If $\\rho$ and $\\sigma$ are equivalent  metrics on a set $A,$ then\n $(A,\\rho)$ and $(A,\\sigma)$ have the same open sets.", "statement": "We assume:\n\u2022 For any set $S \\subseteq A$, if $S$ is open in $(A,\\rho)$, then $S$ is open in $(A,\\sigma)$ [l3].\n\u2022 For any set $S \\subseteq A$, if $S$ is open in $(A,\\sigma)$, then $S$ is open in $(A,\\rho)$ [l6].\nTherefore, we conclude:\n\u2022 The collection of open sets in $(A,\\rho)$ is identical to the collection of open sets in $(A,\\sigma)$ [ts_1].", "dependencies": ["l3", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {A : Type*} (\u03c1 \u03c3 : A \u2192 A \u2192 \u211d) \n  (h\u03c1_nonneg : \u2200 x y : A, \u03c1 x y \u2265 0) (h\u03c1_diag : \u2200 x : A, \u03c1 x x = 0)\n  (h\u03c1_symm : \u2200 x y : A, \u03c1 x y = \u03c1 y x) (h\u03c1_tri : \u2200 x y z : A, \u03c1 x z \u2264 \u03c1 x y + \u03c1 y z)\n  (h\u03c3_nonneg : \u2200 x y : A, \u03c3 x y \u2265 0) (h\u03c3_diag : \u2200 x : A, \u03c3 x x = 0)\n  (h\u03c3_symm : \u2200 x y : A, \u03c3 x y = \u03c3 y x) (h\u03c3_tri : \u2200 x y z : A, \u03c3 x z \u2264 \u03c3 x y + \u03c3 y z)\n  (\u03b1 \u03b2 : \u211d) (h\u03b1 : \u03b1 > 0) (h\u03b2 : \u03b2 > 0)\n  (h_equiv : \u2200 x y : A, \u03b1 * \u03c1 x y \u2264 \u03c3 x y \u2227 \u03c3 x y \u2264 \u03b2 * \u03c1 x y) :\n  \u2200 S : Set A, (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 \n              (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n  intro S\n  have h_imp_forward : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, h\u03b5'\u27e9 := h\n    have h\u2081 : \u2203 \u03b5' > (0 : \u211d), \u2200 (x : A), \u03c3 x x\u2080 < \u03b5' \u2192 x \u2208 S := by\n      use \u03b1 * \u03b5\n      constructor\n      \u00b7 -- Prove that \u03b1 * \u03b5 > 0\n        have h\u2082 : \u03b1 * \u03b5 > 0 := by\n          have h\u2083 : \u03b5 > 0 := h\u03b5\n          have h\u2084 : \u03b1 > 0 := h\u03b1\n          positivity\n        exact h\u2082\n      \u00b7 -- Prove that if \u03c3 x x\u2080 < \u03b1 * \u03b5, then x \u2208 S\n        intro x hx\n        have h\u2082 : \u03b1 * \u03c1 x x\u2080 \u2264 \u03c3 x x\u2080 := (h_equiv x x\u2080).1\n        have h\u2083 : \u03c3 x x\u2080 < \u03b1 * \u03b5 := hx\n        have h\u2084 : \u03b1 * \u03c1 x x\u2080 < \u03b1 * \u03b5 := by linarith\n        have h\u2085 : \u03c1 x x\u2080 < \u03b5 := by\n          have h\u2086 : 0 < \u03b1 := h\u03b1\n          have h\u2087 : \u03c1 x x\u2080 < \u03b5 := by\n            by_contra h\u2088\n            have h\u2089 : \u03c1 x x\u2080 \u2265 \u03b5 := by linarith\n            have h\u2081\u2080 : \u03b1 * \u03c1 x x\u2080 \u2265 \u03b1 * \u03b5 := by\n              nlinarith\n            linarith\n          exact h\u2087\n        have h\u2086 : x \u2208 S := h\u03b5' x h\u2085\n        exact h\u2086\n    obtain \u27e8\u03b5', h\u03b5', h\u03b5''\u27e9 := h\u2081\n    refine' \u27e8x\u2080, hx\u2080, \u03b5', h\u03b5', _\u27e9\n    intro x hx\n    exact h\u03b5'' x hx\n  \n  have h_imp_backward : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2192 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    intro h\n    obtain \u27e8x\u2080, hx\u2080, \u03b5', h\u03b5', h\u03b5'_prop\u27e9 := h\n    have h\u2081 : \u2203 \u03b5 > (0 : \u211d), \u2200 (x : A), \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S := by\n      use \u03b5' / \u03b2\n      constructor\n      \u00b7 -- Prove that \u03b5' / \u03b2 > 0\n        have h\u2082 : \u03b5' > 0 := h\u03b5'\n        have h\u2083 : \u03b2 > 0 := h\u03b2\n        positivity\n      \u00b7 -- Prove that if \u03c1 x x\u2080 < \u03b5' / \u03b2, then x \u2208 S\n        intro x hx\n        have h\u2082 : \u03c3 x x\u2080 \u2264 \u03b2 * \u03c1 x x\u2080 := (h_equiv x x\u2080).2\n        have h\u2083 : \u03c1 x x\u2080 < \u03b5' / \u03b2 := hx\n        have h\u2084 : \u03b2 * \u03c1 x x\u2080 < \u03b5' := by\n          have h\u2085 : 0 < \u03b2 := h\u03b2\n          have h\u2086 : \u03b2 * \u03c1 x x\u2080 < \u03b2 * (\u03b5' / \u03b2) := by\n            nlinarith\n          have h\u2087 : \u03b2 * (\u03b5' / \u03b2) = \u03b5' := by\n            field_simp [h\u2085.ne']\n            <;> ring\n          linarith\n        have h\u2085 : \u03c3 x x\u2080 < \u03b5' := by linarith\n        have h\u2086 : x \u2208 S := h\u03b5'_prop x h\u2085\n        exact h\u2086\n    obtain \u27e8\u03b5, h\u03b5, h\u03b5_prop\u27e9 := h\u2081\n    refine' \u27e8x\u2080, hx\u2080, \u03b5, h\u03b5, _\u27e9\n    intro x hx\n    exact h\u03b5_prop x hx\n  \n  have h_main : (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c1 x x\u2080 < \u03b5 \u2192 x \u2208 S) \u2194 (\u2203 x\u2080 \u2208 S, \u2203 \u03b5 > 0, \u2200 x : A, \u03c3 x x\u2080 < \u03b5 \u2192 x \u2208 S) := by\n    constructor\n    \u00b7 -- Prove the forward direction\n      intro h\n      exact h_imp_forward h\n    \u00b7 -- Prove the backward direction\n      intro h\n      exact h_imp_backward h\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning of the natural language statement. While it uses a more rigorous approach with explicit metric axioms and metric equivalence conditions instead of the informal assumptions l3 and l6, this is mathematically equivalent and actually more precise. The conclusion about identical collections of open sets is properly formalized through the biconditional characterization of open sets. The additional mathematical rigor (explicit metric properties, positive constants \u03b1 and \u03b2) enhances rather than contradicts the natural language meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    