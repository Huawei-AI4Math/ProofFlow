
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \cdot a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = 2^{F_{n-1}}$ where $F_n$ is the $n$-th Fibonacci number with $F_0=0$, $F_1=1$.

Proof: This proof uses **strong mathematical induction** because the recurrence relation depends on two previous terms. First, we verify the formula for the initial terms, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1 = 2^{F_{1-1}} = 2^{F_0} = 2^0 = 1$, which matches the given value. For $n=2$, the formula gives $a_2 = 2^{F_{2-1}} = 2^{F_1} = 2^1 = 2$, which also matches. Now for the inductive step, assume the formula holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{F_{j-1}}$ is true. We must now prove that the formula holds for $n=k+1$, i.e., $a_{k+1} = 2^{F_{k}}$. Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = a_k \cdot a_{k-1}$. By our inductive assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = (2^{F_{k-1}}) \cdot (2^{F_{k-2}})$. Using the laws of exponents, we add the powers: $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$. By the definition of the Fibonacci numbers, we know that $F_{k-1} + F_{k-2} = F_k$. Thus, $a_{k+1} = 2^{F_k}$. This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \\cdot a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence of integers $(a_n)_{n\\geq1}$ is defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \\cdot a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition : \n  \u2203 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1) \u2227 \n    (a 2 = 2) \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) * a (n-2)) \u2227\n    (\u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(Nat.fib (n-1))) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition a_1 = 1 is directly captured as 'a 1 = 1' in Lean", "The condition a_2 = 2 is directly captured as 'a 2 = 2' in Lean", "The recurrence relation for n \u2265 3 is correctly formalized in Lean with the same logical structure", "The natural language only concludes that the sequence is defined by the given conditions. However, the Lean formalization adds an extra constraint that a n = 2^(Nat.fib (n-1)) for all n \u2265 1, which is a specific closed-form solution not mentioned in the natural language. This introduces additional mathematical content that contradicts the open-ended nature of just 'defining' the sequence"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The condition a_1 = 1 is directly captured as 'a 1 = 1' in Lean\", \"The condition a_2 = 2 is directly captured as 'a 2 = 2' in Lean\", 'The recurrence relation for n \u2265 3 is correctly formalized in Lean with the same logical structure', \"The natural language only concludes that the sequence is defined by the given conditions. However, the Lean formalization adds an extra constraint that a n = 2^(Nat.fib (n-1)) for all n \u2265 1, which is a specific closed-form solution not mentioned in the natural language. This introduces additional mathematical content that contradicts the open-ended nature of just 'defining' the sequence\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "where $F_n$ is the $n$-th Fibonacci number with $F_0=0$, $F_1=1$.", "statement": "Premise:\n\u2022 The sequence of integers $(F_n)_{n\\geq0}$ is the Fibonacci sequence, defined by $F_0=0$, $F_1=1$, and the recurrence relation $F_n = F_{n-1} + F_{n-2}$ for all integers $n \\geq 2$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (F : \u2115 \u2192 \u2115)\n(tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The condition F_0 = 0 is directly captured as F 0 = 0 in the Lean conjunction", "The condition F_1 = 1 is directly captured as F 1 = 1 in the Lean conjunction", "The recurrence relation F_n = F_{n-1} + F_{n-2} for n \u2265 2 is exactly captured as \u2200 n, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)", "The conclusion that the sequence is the Fibonacci sequence is implicitly captured by the variable declaration F : \u2115 \u2192 \u2115 combined with the defining properties in tc_2. The Lean formalization defines F as a sequence satisfying exactly the Fibonacci properties"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1 = 2^{F_{1-1}} = 2^{F_0} = 2^0 = 1$, which matches the given value.", "statement": "We assume:\n\u2022 $a_1=1$ [tc_1].\n\u2022 $F_0=0$ [tc_2].\nTherefore, we conclude:\n\u2022 $a_1 = 2^{F_{1-1}}$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d) \n  (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1)\n  (tc_2 : F 0 = 0) :\n  a 1 = 2^(F (1 - 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d) \n  (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1)\n  (tc_2 : F 0 = 0) :\n  a 1 = 2^(F (1 - 1)) := by\n  have h1 : (1 : \u2115) - 1 = 0 := by\n    norm_num\n    <;> simp_all\n    <;> norm_num\n    <;> linarith\n  \n  have h2 : F (1 - 1) = 0 := by\n    have h3 : F (1 - 1) = F 0 := by\n      rw [h1]\n    rw [h3]\n    <;> simp [tc_2]\n  \n  have h3 : (2 : \u211d) ^ (F (1 - 1)) = 1 := by\n    rw [h2]\n    <;> norm_num\n    <;> simp [pow_zero]\n  \n  have h4 : a 1 = (2 : \u211d) ^ (F (1 - 1)) := by\n    rw [tc_1]\n    <;> rw [h3]\n    <;> norm_num\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations appropriately model the mathematical sequences as functions from natural numbers to reals/naturals", "The first assumption a\u2081=1 is correctly translated as tc_1 : a 1 = 1", "The second assumption F\u2080=0 is correctly translated as tc_2 : F 0 = 0", "The conclusion a\u2081 = 2^(F\u2081\u208b\u2081) is correctly formalized as a 1 = 2^(F (1 - 1)), maintaining the exact mathematical meaning", "The logical structure properly captures the premise-conclusion relationship using Lean's theorem format"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, the formula gives $a_2 = 2^{F_{2-1}} = 2^{F_1} = 2^1 = 2$, which also matches.", "statement": "We assume:\n\u2022 $a_2=2$ [tc_1].\n\u2022 $F_1=1$ [tc_2].\nTherefore, we conclude:\n\u2022 $a_2 = 2^{F_{2-1}}$ [l2].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u211d) \n  (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 2 = 2)\n  (tc_2 : F 1 = 1) :\n  a 2 = 2^(F (2-1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u211d) \n  (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 2 = 2)\n  (tc_2 : F 1 = 1) :\n  a 2 = 2^(F (2-1)) := by\n  have h1 : (2 : \u2115) - 1 = 1 := by\n    norm_num\n  \n  have h2 : F (2 - 1) = 1 := by\n    have h2\u2081 : F (2 - 1) = F 1 := by\n      norm_num\n    rw [h2\u2081]\n    <;> simp [tc_2]\n    <;> norm_num\n  \n  have h3 : (2 : \u211d) ^ (F (2 - 1)) = 2 := by\n    have h3\u2081 : (F (2 - 1) : \u2115) = 1 := by\n      exact_mod_cast h2\n    have h3\u2082 : (2 : \u211d) ^ (F (2 - 1)) = (2 : \u211d) ^ (1 : \u2115) := by\n      norm_cast\n      <;> simp [h3\u2081]\n      <;> norm_num\n    rw [h3\u2082]\n    <;> norm_num\n  \n  have h4 : a 2 = (2 : \u211d) ^ (F (2 - 1)) := by\n    rw [tc_1]\n    <;>\n    (try norm_num at h3 \u22a2) <;>\n    (try linarith) <;>\n    (try simp_all) <;>\n    (try norm_cast at h3 \u22a2) <;>\n    (try linarith) <;>\n    (try simp_all) <;>\n    (try norm_num) <;>\n    (try linarith)\n    <;>\n    (try\n      {\n        simp_all [h3]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h2]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h1]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        norm_num at h3 \u22a2\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        norm_num at h2 \u22a2\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        norm_num at h1 \u22a2\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h3]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h2]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h1]\n        <;> norm_num\n        <;> linarith\n      })\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are appropriately formalized with explicit types that match the mathematical context", "Assumption tc_1 is correctly translated with identical mathematical meaning", "Assumption tc_2 is correctly translated with identical mathematical meaning", "The conclusion correctly captures the mathematical relationship a_2 = 2^(F_(2-1))", "The logical structure of assumptions leading to conclusion is properly preserved in the theorem format"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "assume the formula holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{F_{j-1}}$ is true.", "statement": "Definition:\n\u2022 For the inductive step, let $k$ be an integer such that $k \\geq 2$, and assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{F_{j-1}}$ holds [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n(k : \u2115) (hk : k \u2265 2)\n(inductive_hypothesis : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1)))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies k as an integer, but Lean uses \u2115 (natural numbers). While \u2115 \u2286 \u2124 and for k \u2265 2 this doesn't change the mathematical meaning, it's technically a different type specification.", "The Lean formalization perfectly captures the inductive hypothesis with the same logical structure: for all j in the range [1,k], the formula a_j = 2^(F_(j-1)) holds.", "This conclusion is implicitly captured by the inductive_hypothesis declaration in Lean, which establishes exactly what the natural language states."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = a_k \\cdot a_{k-1}$.", "statement": "We assume:\n\u2022 The recurrence relation $a_n = a_{n-1} \\cdot a_{n-2}$ holds for $n \\geq 3$ [tc_1].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = a_k \\cdot a_{k-1}$ [l3].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition : \n  \u2203 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1) \u2227 \n    (a 2 = 2) \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) * a (n-2)) \u2227\n    (\u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(Nat.fib (n-1))) := by sorry\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 2)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) * a (n-2))\n  (h4 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(Nat.fib (n-1)))\n  (k : \u2115) (hk : k \u2265 2) :\n  a (k + 1) = a k * a (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition : \n  \u2203 (a : \u2115 \u2192 \u211d), \n    (a 1 = 1) \u2227 \n    (a 2 = 2) \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) * a (n-2)) \u2227\n    (\u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(Nat.fib (n-1))) := by\n  use fun n => (2 : \u211d) ^ (Nat.fib (n - 1))\n  constructor\n  \u00b7 -- Prove a 1 = 1\n    norm_num [Nat.fib_zero]\n  constructor\n  \u00b7 -- Prove a 2 = 2\n    norm_num [Nat.fib_one]\n  constructor\n  \u00b7 -- Prove the recurrence relation for n \u2265 3\n    intro n hn\n    cases n with\n    | zero => contradiction -- n cannot be zero since hn : n \u2265 3\n    | succ n =>\n      cases n with\n      | zero => contradiction -- n cannot be one since hn : n \u2265 3\n      | succ n =>\n        cases n with\n        | zero => contradiction -- n cannot be two since hn : n \u2265 3\n        | succ n =>\n          simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n          <;>\n          (try ring_nf) <;>\n          (try norm_num) <;>\n          (try field_simp) <;>\n          (try norm_cast) <;>\n          (try simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]) <;>\n          (try ring_nf) <;>\n          (try norm_num) <;>\n          (try linarith)\n          <;>\n          (try\n            {\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              ring_nf at *\n              <;>\n              norm_cast at *\n              <;>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              nlinarith\n            })\n  \u00b7 -- Prove the closed form for n \u2265 1\n    intro n hn\n    cases n with\n    | zero => contradiction -- n cannot be zero since hn : n \u2265 1\n    | succ n =>\n      simp [Nat.fib_add_two]\n      <;>\n      (try ring_nf) <;>\n      (try norm_num) <;>\n      (try simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]) <;>\n      (try ring_nf) <;>\n      (try norm_num) <;>\n      (try linarith)\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 2)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) * a (n-2))\n  (h4 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(Nat.fib (n-1)))\n  (k : \u2115) (hk : k \u2265 2) :\n  a (k + 1) = a k * a (k - 1) := by\n  have h_main : a (k + 1) = a k * a (k - 1) := by\n    have h5 : a (k + 1) = (2 : \u211d) ^ (Nat.fib ((k + 1) - 1)) := by\n      have h5\u2081 : (k + 1 : \u2115) \u2265 1 := by linarith\n      have h5\u2082 : a (k + 1) = (2 : \u211d) ^ (Nat.fib ((k + 1) - 1)) := by\n        have h5\u2083 := h4 (k + 1) (by linarith)\n        norm_num at h5\u2083 \u22a2\n        <;>\n        (try ring_nf at h5\u2083 \u22a2) <;>\n        (try simp_all [Nat.fib_add_two]) <;>\n        (try norm_cast at h5\u2083 \u22a2) <;>\n        (try linarith) <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at h5\u2083 \u22a2) <;>\n        (try norm_cast at h5\u2083 \u22a2) <;>\n        (try linarith) <;>\n        (try nlinarith)\n        <;>\n        (try\n          {\n            cases k with\n            | zero => contradiction\n            | succ k' =>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              ring_nf at * <;>\n              norm_cast at * <;>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              nlinarith\n          })\n        <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at h5\u2083 \u22a2) <;>\n        (try norm_cast at h5\u2083 \u22a2) <;>\n        (try linarith)\n        <;>\n        (try nlinarith)\n      exact h5\u2082\n    have h6 : a k = (2 : \u211d) ^ (Nat.fib (k - 1)) := by\n      have h6\u2081 : k \u2265 1 := by linarith\n      have h6\u2082 : a k = (2 : \u211d) ^ (Nat.fib (k - 1)) := by\n        have h6\u2083 := h4 k (by linarith)\n        norm_num at h6\u2083 \u22a2\n        <;>\n        (try ring_nf at h6\u2083 \u22a2) <;>\n        (try simp_all [Nat.fib_add_two]) <;>\n        (try norm_cast at h6\u2083 \u22a2) <;>\n        (try linarith) <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at h6\u2083 \u22a2) <;>\n        (try norm_cast at h6\u2083 \u22a2) <;>\n        (try linarith) <;>\n        (try nlinarith)\n        <;>\n        (try\n          {\n            cases k with\n            | zero => contradiction\n            | succ k' =>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              ring_nf at * <;>\n              norm_cast at * <;>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              nlinarith\n          })\n        <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at h6\u2083 \u22a2) <;>\n        (try norm_cast at h6\u2083 \u22a2) <;>\n        (try linarith)\n        <;>\n        (try nlinarith)\n      exact h6\u2082\n    have h7 : a (k - 1) = (2 : \u211d) ^ (Nat.fib ((k - 1) - 1)) := by\n      have h7\u2081 : k - 1 \u2265 1 := by\n        omega\n      have h7\u2082 : a (k - 1) = (2 : \u211d) ^ (Nat.fib ((k - 1) - 1)) := by\n        have h7\u2083 := h4 (k - 1) (by omega)\n        norm_num at h7\u2083 \u22a2\n        <;>\n        (try ring_nf at h7\u2083 \u22a2) <;>\n        (try simp_all [Nat.fib_add_two]) <;>\n        (try norm_cast at h7\u2083 \u22a2) <;>\n        (try linarith) <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at h7\u2083 \u22a2) <;>\n        (try norm_cast at h7\u2083 \u22a2) <;>\n        (try linarith) <;>\n        (try nlinarith)\n        <;>\n        (try\n          {\n            cases k with\n            | zero => contradiction\n            | succ k' =>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              ring_nf at * <;>\n              norm_cast at * <;>\n              simp_all [Nat.fib_add_two, pow_add, pow_one, mul_assoc]\n              <;>\n              nlinarith\n          })\n        <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at h7\u2083 \u22a2) <;>\n        (try norm_cast at h7\u2083 \u22a2) <;>\n        (try linarith)\n        <;>\n        (try nlinarith)\n      exact h7\u2082\n    have h8 : (2 : \u211d) ^ (Nat.fib ((k + 1) - 1)) = (2 : \u211d) ^ (Nat.fib (k - 1)) * (2 : \u211d) ^ (Nat.fib ((k - 1) - 1)) := by\n      have h8\u2081 : Nat.fib ((k + 1) - 1) = Nat.fib (k - 1) + Nat.fib ((k - 1) - 1) := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [Nat.fib_add_two, Nat.add_assoc] at *\n            <;>\n            (try omega) <;>\n            (try ring_nf at * <;> simp_all [Nat.fib_add_two, Nat.add_assoc]) <;>\n            (try omega)\n            <;>\n            (try\n              {\n                induction k'' <;> simp_all [Nat.fib_add_two, Nat.add_assoc] <;>\n                ring_nf at * <;>\n                omega\n              })\n      rw [h8\u2081]\n      have h8\u2082 : (2 : \u211d) ^ (Nat.fib (k - 1) + Nat.fib ((k - 1) - 1)) = (2 : \u211d) ^ (Nat.fib (k - 1)) * (2 : \u211d) ^ (Nat.fib ((k - 1) - 1)) := by\n        rw [pow_add]\n        <;>\n        norm_num\n        <;>\n        ring_nf\n        <;>\n        norm_cast\n        <;>\n        simp [pow_add]\n        <;>\n        ring_nf\n        <;>\n        norm_cast\n      rw [h8\u2082]\n      <;>\n      norm_num\n      <;>\n      ring_nf\n      <;>\n      norm_cast\n    calc\n      a (k + 1) = (2 : \u211d) ^ (Nat.fib ((k + 1) - 1)) := by rw [h5]\n      _ = (2 : \u211d) ^ (Nat.fib (k - 1)) * (2 : \u211d) ^ (Nat.fib ((k - 1) - 1)) := by rw [h8]\n      _ = a k * a (k - 1) := by\n        rw [h6, h7]\n        <;>\n        ring_nf\n        <;>\n        norm_num\n        <;>\n        simp_all [pow_add, pow_one, mul_assoc]\n        <;>\n        ring_nf at *\n        <;>\n        norm_cast at *\n        <;>\n        linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The recurrence relation is perfectly captured with the same logical structure and conditions.", "The constraint on k uses natural numbers instead of integers, but since k \u2265 2, this is mathematically equivalent and doesn't lose meaning.", "The conclusion statement matches exactly in mathematical content.", "The Lean formalization includes additional hypotheses about initial conditions and an explicit formula, which provide extra context but don't contradict the natural language premises."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By our inductive assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = (2^{F_{k-1}}) \\cdot (2^{F_{k-2}})$.", "statement": "We assume:\n\u2022 $a_{k+1} = a_k \\cdot a_{k-1}$ [l3].\n\u2022 The inductive hypothesis that $a_j = 2^{F_{j-1}}$ holds for $j=k$ and $j=k-1$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = (2^{F_{k-1}}) \\cdot (2^{F_{k-2}})$ [l4].", "dependencies": ["l3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l3 : a (k + 1) = a k * a (k - 1))\n  (def_1 : a k = 2^(F (k - 1)) \u2227 a (k - 1) = 2^(F (k - 2))) :\n  a (k + 1) = (2^(F (k - 1))) * (2^(F (k - 2))) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l3 : a (k + 1) = a k * a (k - 1))\n  (def_1 : a k = 2^(F (k - 1)) \u2227 a (k - 1) = 2^(F (k - 2))) :\n  a (k + 1) = (2^(F (k - 1))) * (2^(F (k - 2))) := by\n  have h_main : a (k + 1) = (2^(F (k - 1))) * (2^(F (k - 2))) := by\n    have h1 : a k = (2 : \u211d) ^ (F (k - 1)) := by\n      have h2 : a k = 2 ^ (F (k - 1)) := def_1.1\n      norm_num at h2 \u22a2\n      <;> simpa using h2\n    have h3 : a (k - 1) = (2 : \u211d) ^ (F (k - 2)) := by\n      have h4 : a (k - 1) = 2 ^ (F (k - 2)) := def_1.2\n      norm_num at h4 \u22a2\n      <;> simpa using h4\n    calc\n      a (k + 1) = a k * a (k - 1) := l3\n      _ = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by rw [h1, h3]\n      _ = (2 ^ (F (k - 1))) * (2 ^ (F (k - 2))) := by norm_num\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The recurrence relation a_{k+1} = a_k * a_{k-1} is correctly formalized as l3 with proper Lean syntax", "The inductive hypothesis for j=k and j=k-1 is accurately captured as a conjunction in def_1, preserving the exact mathematical meaning", "The conclusion a_{k+1} = (2^{F_{k-1}}) * (2^{F_{k-2}}) is directly translated with correct parenthesization and operator precedence", "The overall logical structure (assumptions \u2192 conclusion) is properly maintained, with additional type information and constraints that enhance rather than contradict the natural language statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Using the laws of exponents, we add the powers: $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$.", "statement": "We assume:\n\u2022 $a_{k+1} = (2^{F_{k-1}}) \\cdot (2^{F_{k-2}})$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$ [l5].", "dependencies": ["l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l4 : a (k + 1) = (2^(F (k - 1))) * (2^(F (k - 2)))) :\n  a (k + 1) = 2^(F (k - 1) + F (k - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l4 : a (k + 1) = (2^(F (k - 1))) * (2^(F (k - 2)))) :\n  a (k + 1) = 2^(F (k - 1) + F (k - 2)) := by\n  have h_main : (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) = (2 : \u211d) ^ (F (k - 1) + F (k - 2)) := by\n    rw [\u2190 pow_add]\n    <;> norm_cast\n    <;> simp [add_comm]\n    <;> ring_nf\n    <;> simp_all [pow_add]\n    <;> norm_num\n    <;> linarith\n  \n  have h_final : a (k + 1) = (2 : \u211d) ^ (F (k - 1) + F (k - 2)) := by\n    have h1 : a (k + 1) = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by\n      simpa [pow_mul] using l4\n    rw [h1]\n    rw [h_main]\n  \n  simpa [pow_add] using h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical and logical content from the natural language. The premise l4 and conclusion l5 are accurately translated, maintaining the same mathematical relationships. The additional constraint (hk : k \u2265 2) is a reasonable addition to ensure well-defined natural number arithmetic for k-1 and k-2. The logical structure properly represents the deduction from the premise to the conclusion using the exponent addition rule."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By the definition of the Fibonacci numbers, we know that $F_{k-1} + F_{k-2} = F_k$.", "statement": "We assume:\n\u2022 The recurrence relation $F_n = F_{n-1} + F_{n-2}$ holds for $n \\geq 2$ [tc_2].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $F_k = F_{k-1} + F_{k-2}$ [l6].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (F : \u2115 \u2192 \u2115) \n  (h0 : F 0 = 0) (h1 : F 1 = 1) \n  (hrec : \u2200 n, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (a : \u2115 \u2192 \u211d) \n  (hdef : \u2200 n, n \u2265 1 \u2192 a n = 2^(F (n - 1)))\n  (k : \u2115) (hk : k \u2265 2) :\n  F k = F (k - 1) + F (k - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (F : \u2115 \u2192 \u2115) \n  (h0 : F 0 = 0) (h1 : F 1 = 1) \n  (hrec : \u2200 n, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (a : \u2115 \u2192 \u211d) \n  (hdef : \u2200 n, n \u2265 1 \u2192 a n = 2^(F (n - 1)))\n  (k : \u2115) (hk : k \u2265 2) :\n  F k = F (k - 1) + F (k - 2) := by\n  have h_main : F k = F (k - 1) + F (k - 2) := by\n    have h\u2082 : F k = F (k - 1) + F (k - 2) := hrec k hk\n    exact h\u2082\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The recurrence relation assumption is correctly formalized with the same logical structure and conditions", "The constraint on k is properly captured. Using natural numbers (\u2115) instead of integers (\u2124) is acceptable since k \u2265 2 implies k is a positive integer", "The conclusion exactly matches the natural language statement, following directly from the assumptions via the recurrence relation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Thus, $a_{k+1} = 2^{F_k}$.", "statement": "We assume:\n\u2022 $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$ [l5].\n\u2022 $F_k = F_{k-1} + F_{k-2}$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_k}$ [l7].", "dependencies": ["l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l5 : a (k + 1) = 2^(F (k - 1) + F (k - 2)))\n  (l6 : F k = F (k - 1) + F (k - 2)) :\n  a (k + 1) = 2^(F k) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l5 : a (k + 1) = 2^(F (k - 1) + F (k - 2)))\n  (l6 : F k = F (k - 1) + F (k - 2)) :\n  a (k + 1) = 2^(F k) := by\n  have h_exp : F (k - 1) + F (k - 2) = F k := by\n    have h\u2081 : F k = F (k - 1) + F (k - 2) := l6\n    linarith\n  \n  have h_main : a (k + 1) = 2^(F k) := by\n    rw [l5]\n    have h\u2082 : (2 : \u211d) ^ (F (k - 1) + F (k - 2) : \u2115) = (2 : \u211d) ^ (F k : \u2115) := by\n      rw [show (F (k - 1) + F (k - 2) : \u2115) = (F k : \u2115) by\n        norm_cast at h_exp \u22a2\n        <;> simp_all [Nat.add_assoc]\n        <;> omega]\n    rw [h\u2082]\n    <;> norm_cast\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all mathematical content from the natural language. The explicit type declarations for functions a and F, the constraint k \u2265 2 for well-definedness, and the use of function notation instead of subscripts are all appropriate formal mathematics practices. The logical structure of the argument (using premises l5 and l6 to conclude l7) is perfectly preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The base case for n=1 is proven: $a_1 = 2^{F_{1-1}}$ [l1].\n\u2022 The base case for n=2 is proven: $a_2 = 2^{F_{2-1}}$ [l2].\n\u2022 The inductive step is proven: for an integer $k \\ge 2$, assuming $a_j = 2^{F_{j-1}}$ for all integers $j$ with $1 \\le j \\le k$, it follows that $a_{k+1} = 2^{F_k}$ [l7].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, $a_n = 2^{F_{n-1}}$ [ts_1].", "dependencies": ["l1", "l2", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u211d) \n  (F : \u2115 \u2192 \u2115)\n  (h_fib : \u2200 n, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (h_fib_0 : F 0 = 0)\n  (h_fib_1 : F 1 = 1)\n  (h_a1 : a 1 = 1)\n  (h_a2 : a 2 = 2)\n  (h_rec : \u2200 n, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)) :\n  \u2200 n, n \u2265 1 \u2192 a n = 2^(F (n - 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u211d) \n  (F : \u2115 \u2192 \u2115)\n  (h_fib : \u2200 n, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (h_fib_0 : F 0 = 0)\n  (h_fib_1 : F 1 = 1)\n  (h_a1 : a 1 = 1)\n  (h_a2 : a 2 = 2)\n  (h_rec : \u2200 n, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2)) :\n  \u2200 n, n \u2265 1 \u2192 a n = 2^(F (n - 1)) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d) ^ (F (n - 1)) := by\n    intro n hn\n    have h\u2081 : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d) ^ (F (n - 1)) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h_a1, h_fib_0] at hn \u22a2\n        <;>\n        simp_all [pow_zero]\n        <;>\n        norm_num\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h_a2, h_fib_1] at hn \u22a2\n        <;>\n        simp_all [pow_one]\n        <;>\n        norm_num\n      | k + 3 =>\n        -- Inductive step: n = k + 3, where k \u2265 0\n        have h\u2082 := h_rec (k + 3) (by omega)\n        have h\u2083 : a (k + 3) = a (k + 2) * a (k + 1) := by\n          simpa [Nat.add_assoc] using h\u2082\n        rw [h\u2083]\n        have h\u2084 : a (k + 2) = (2 : \u211d) ^ (F (k + 1)) := by\n          have h\u2085 : (k + 2) \u2265 1 := by omega\n          have h\u2086 : a (k + 2) = (2 : \u211d) ^ (F ((k + 2) - 1)) := ih (k + 2) (by omega) (by omega)\n          have h\u2087 : (k + 2) - 1 = k + 1 := by\n            omega\n          rw [h\u2086, h\u2087]\n          <;> simp [h\u2087]\n        have h\u2085 : a (k + 1) = (2 : \u211d) ^ (F k) := by\n          have h\u2086 : (k + 1) \u2265 1 := by omega\n          have h\u2087 : a (k + 1) = (2 : \u211d) ^ (F ((k + 1) - 1)) := ih (k + 1) (by omega) (by omega)\n          have h\u2088 : (k + 1) - 1 = k := by\n            omega\n          rw [h\u2087, h\u2088]\n          <;> simp [h\u2088]\n        rw [h\u2084, h\u2085]\n        -- Now we need to show that (2 : \u211d) ^ (F (k + 1)) * (2 : \u211d) ^ (F k) = (2 : \u211d) ^ (F (k + 2))\n        have h\u2086 : F (k + 2) = F (k + 1) + F k := by\n          have h\u2087 : (k + 2) \u2265 2 := by omega\n          have h\u2088 := h_fib (k + 2) h\u2087\n          have h\u2089 : (k + 2) - 1 = k + 1 := by omega\n          have h\u2081\u2080 : (k + 2) - 2 = k := by omega\n          rw [h\u2089, h\u2081\u2080] at h\u2088\n          <;> omega\n        have h\u2087 : (2 : \u211d) ^ (F (k + 1)) * (2 : \u211d) ^ (F k) = (2 : \u211d) ^ (F (k + 1) + F k) := by\n          rw [\u2190 pow_add]\n          <;> ring_nf\n        rw [h\u2087]\n        have h\u2088 : (F (k + 1) + F k : \u2115) = F (k + 2) := by\n          rw [h\u2086]\n          <;> ring_nf\n        rw [h\u2088]\n        <;> simp [h\u2088]\n        <;> ring_nf\n        <;> norm_cast\n        <;> simp_all [h_fib]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n    exact h\u2081 n hn\n  intro n hn\n  have h\u2082 := h_main n hn\n  simpa using h\u2082", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The base cases are correctly captured. The Lean formalization provides the explicit values that make a\u2081 = 2^(F\u2080) and a\u2082 = 2^(F\u2081) true.", "The Fibonacci sequence definition is properly formalized with the standard recurrence relation and correct base cases.", "The inductive step is correctly captured through the recurrence relation for sequence a, which is mathematically equivalent to what's needed for the inductive proof.", "The conclusion is perfectly translated as the theorem statement with the same mathematical content.", "The overall structure correctly represents the mathematical reasoning, with assumptions as hypotheses and the conclusion as the theorem to prove."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    