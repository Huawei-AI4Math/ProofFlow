
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = \frac{n+1}{2n+1}$. Then for all integers $n \geq 1$, the inequality $\frac{1}{2} < a_n \leq \frac{2}{3}$ holds.

Proof: First, we prove the left-hand side of the inequality, $\frac{1}{2} < a_n$. We are given $a_n = \frac{n+1}{2n+1}$. To show $\frac{1}{2} < \frac{n+1}{2n+1}$, we can cross-multiply since both denominators are positive for $n \geq 1$. This gives us $1(2n+1) < 2(n+1)$, which simplifies to $2n+1 < 2n+2$. Subtracting $2n$ from both sides gives $1 < 2$, which is a true statement. Therefore, $\frac{1}{2} < a_n$ holds for all $n \geq 1$. Next, we prove the right-hand side of the inequality, $a_n \leq \frac{2}{3}$. We need to show that $\frac{n+1}{2n+1} \leq \frac{2}{3}$. Again, we can cross-multiply to get $3(n+1) \leq 2(2n+1)$. This simplifies to $3n+3 \leq 4n+2$. Subtracting $3n$ and $2$ from both sides gives $1 \leq n$. This is true for all integers $n \geq 1$. Since both parts of the inequality hold, the full inequality $\frac{1}{2} < a_n \leq \frac{2}{3}$ is proven.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = \\frac{n+1}{2n+1}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for any integer n [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 :\n  let a : \u2115 \u2192 \u211d := fun n => (n + 1 : \u211d) / (2 * n + 1 : \u211d)\n  \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states the sequence is defined for 'any integer n' but Lean defines it as \u2115 \u2192 \u211d (natural numbers to reals). This is a domain mismatch between integers and natural numbers.", "The formula itself matches perfectly, but the domain issue from component 1 carries over - natural language specifies integers while Lean uses natural numbers.", "The natural language conclusion is simply that the sequence is well-defined with the given formula, but the Lean theorem proves specific bounds (1/2 < a_n \u2264 2/3 for n \u2265 1). This is a completely different mathematical statement - proving bounds rather than just establishing the definition."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states the sequence is defined for 'any integer n' but Lean defines it as \u2115 \u2192 \u211d (natural numbers to reals). This is a domain mismatch between integers and natural numbers.\", 'The formula itself matches perfectly, but the domain issue from component 1 carries over - natural language specifies integers while Lean uses natural numbers.', 'The natural language conclusion is simply that the sequence is well-defined with the given formula, but the Lean theorem proves specific bounds (1/2 < a_n \u2264 2/3 for n \u2265 1). This is a completely different mathematical statement - proving bounds rather than just establishing the definition.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "for all integers $n \\geq 1$", "statement": "Premise:\n\u2022 The proposition holds for all integers $n \\geq 1$ [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115)\n(tc_2 : 1 \u2264 n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language specifies n as an integer, while Lean declares n as a natural number (\u2115). Natural numbers are a subset of integers, so this is a type restriction that doesn't contradict the mathematical meaning but is slightly more specific than stated.", "The condition n \u2265 1 in natural language perfectly matches 1 \u2264 n in Lean - these are equivalent mathematical statements.", "The natural language conclusion states 'The proposition holds for n' but there is no corresponding statement or conclusion in the Lean formalization. This is a major omission of the key logical component."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language specifies n as an integer, while Lean declares n as a natural number (\u2115). Natural numbers are a subset of integers, so this is a type restriction that doesn't contradict the mathematical meaning but is slightly more specific than stated.\", 'The condition n \u2265 1 in natural language perfectly matches 1 \u2264 n in Lean - these are equivalent mathematical statements.', \"The natural language conclusion states 'The proposition holds for n' but there is no corresponding statement or conclusion in the Lean formalization. This is a major omission of the key logical component.\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "we can cross-multiply since both denominators are positive for $n \\geq 1$.", "statement": "We assume:\n\u2022 n is an integer such that $n \\geq 1$ [tc_2].\nTherefore, we conclude:\n\u2022 The denominators 2 and $2n+1$ are positive for $n \\geq 1$ [l1].", "dependencies": ["tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115)\nvariable (tc_2 : 1 \u2264 n)\n\ntheorem l1 : 0 < (2 : \u211d) \u2227 0 < (2 * n + 1 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 : 0 < (2 : \u211d) \u2227 0 < (2 * n + 1 : \u211d) := by\n  have h\u2081 : 0 < (2 : \u211d) := by\n    norm_num\n    <;>\n    linarith\n  \n  have h\u2082 : (1 : \u211d) \u2264 (n : \u211d) := by\n    have h\u2082\u2081 : (1 : \u2115) \u2264 n := by\n      exact tc_2\n    -- Cast the inequality from natural numbers to real numbers\n    exact_mod_cast h\u2082\u2081\n  \n  have h\u2083 : 0 < (2 * n + 1 : \u211d) := by\n    have h\u2083\u2081 : (2 : \u211d) * (n : \u211d) + 1 \u2265 3 := by\n      -- Use the fact that (n : \u211d) \u2265 1 to show that 2 * (n : \u211d) + 1 \u2265 3\n      have h\u2083\u2082 : (n : \u211d) \u2265 1 := by\n        linarith\n      -- Multiply both sides by 2 and add 1\n      linarith\n    -- Since 3 > 0, we have 2 * (n : \u211d) + 1 > 0\n    have h\u2083\u2082 : (2 : \u211d) * (n : \u211d) + 1 > 0 := by\n      linarith\n    -- Simplify the expression to match the goal\n    norm_cast at h\u2083\u2081 h\u2083\u2082 \u22a2\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try ring_nf at h\u2083\u2081 h\u2083\u2082 \u22a2 <;> linarith)\n    <;>\n    (try\n      {\n        simp_all [mul_assoc]\n        <;>\n        norm_num\n        <;>\n        linarith\n      })\n  \n  exact \u27e8h\u2081, h\u2083\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 12, "column": 12, "endLine": 12, "endColumn": 16, "data": "unknown identifier 'tc_2'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language specifies n as an integer, but Lean uses natural numbers (\u2115). While this doesn't affect the logical validity since 1 \u2264 n ensures we're dealing with positive integers anyway, it's a slight type difference from the original specification.", "The conclusion about positivity of denominators 2 and 2n+1 is perfectly captured in the Lean theorem statement. The conjunction and inequality expressions directly translate the mathematical meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language specifies n as an integer, but Lean uses natural numbers (\u2115). While this doesn't affect the logical validity since 1 \u2264 n ensures we're dealing with positive integers anyway, it's a slight type difference from the original specification.\", 'The conclusion about positivity of denominators 2 and 2n+1 is perfectly captured in the Lean theorem statement. The conjunction and inequality expressions directly translate the mathematical meaning.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "which simplifies to $2n+1 < 2n+2$. Subtracting $2n$ from both sides gives $1 < 2$", "statement": "We assume:\n\u2022 (no specific premises from this proof, this is general algebra)\nTherefore, we conclude:\n\u2022 The inequality $2n+1 < 2n+2$ is equivalent to $1 < 2$ [l2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 : \u2200 n : \u2115, (2 * n + 1 < 2 * n + 2) \u2194 (1 < 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 : \u2200 n : \u2115, (2 * n + 1 < 2 * n + 2) \u2194 (1 < 2) := by\n  intro n\n  have h\u2081 : 2 * n + 1 < 2 * n + 2 := by\n    have h\u2081\u2081 : 2 * n + 1 < 2 * n + 2 := by\n      -- Use the fact that for any natural number m, m < m + 1\n      have h\u2081\u2082 : 2 * n + 1 < (2 * n + 1) + 1 := by\n        apply Nat.lt_succ_self\n      -- Simplify the right-hand side to match the desired form\n      have h\u2081\u2083 : (2 * n + 1) + 1 = 2 * n + 2 := by\n        ring_nf\n      -- Use the transitivity of < to conclude the proof\n      rw [h\u2081\u2083] at h\u2081\u2082\n      exact h\u2081\u2082\n    exact h\u2081\u2081\n  \n  have h\u2082 : 1 < 2 := by\n    norm_num\n    <;> simp_all\n    <;> norm_num\n    <;> linarith\n  \n  have h\u2083 : (2 * n + 1 < 2 * n + 2) \u2194 (1 < 2) := by\n    constructor\n    \u00b7 -- Prove the forward direction: (2 * n + 1 < 2 * n + 2) \u2192 (1 < 2)\n      intro h\n      -- Since 1 < 2 is always true, we can directly use the fact\n      exact h\u2082\n    \u00b7 -- Prove the backward direction: (1 < 2) \u2192 (2 * n + 1 < 2 * n + 2)\n      intro h\n      -- Since 2 * n + 1 < 2 * n + 2 is always true, we can directly use the fact\n      exact h\u2081\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the equivalence statement from the natural language. The universal quantification over natural numbers n is appropriately added to make the statement mathematically precise, as the natural language implicitly uses the variable n. The equivalence relation and both sides of the comparison are accurately represented."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "which is a true statement.", "statement": "We assume:\n\u2022 (general knowledge of numbers)\nTherefore, we conclude:\n\u2022 The inequality $1 < 2$ is true [l3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (1/2 : \u211d) < ((n + 1) / (2 * n + 1) : \u211d) \u2227 ((n + 1) / (2 * n + 1) : \u211d) \u2264 (2/3 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (1/2 : \u211d) < ((n + 1) / (2 * n + 1) : \u211d) \u2227 ((n + 1) / (2 * n + 1) : \u211d) \u2264 (2/3 : \u211d) := by\n  intro n hn\n  have h\u2081 : (1 / 2 : \u211d) < ((n + 1) / (2 * n + 1) : \u211d) := by\n    have h\u2081 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n    have h\u2082 : 0 < (2 * n + 1 : \u211d) := by linarith\n    have h\u2083 : 0 < (2 : \u211d) := by norm_num\n    field_simp\n    rw [div_lt_div_iff] <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try nlinarith) <;>\n      (try\n        {\n          nlinarith [sq_nonneg (n - 1 : \u211d)]\n        }) <;>\n      (try\n        {\n          ring_nf\n          nlinarith\n        })\n    <;>\n    nlinarith\n  \n  have h\u2082 : ((n + 1) / (2 * n + 1) : \u211d) \u2264 (2 / 3 : \u211d) := by\n    have h\u2082 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n    have h\u2083 : 0 < (2 * n + 1 : \u211d) := by linarith\n    have h\u2084 : 0 < (3 : \u211d) := by norm_num\n    field_simp\n    rw [div_le_div_iff] <;>\n      (try norm_num) <;>\n      (try nlinarith) <;>\n      (try\n        {\n          nlinarith [sq_nonneg (n - 1 : \u211d)]\n        }) <;>\n      (try\n        {\n          ring_nf\n          nlinarith\n        })\n    <;>\n    nlinarith\n  \n  exact \u27e8h\u2081, h\u2082\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization proves a completely different mathematical statement than what is described in the natural language. The natural language claims to prove the simple inequality '1 < 2', while the Lean code proves bounds on the rational function (n+1)/(2n+1) for natural numbers n \u2265 1. These are entirely unrelated mathematical statements, representing a fundamental mismatch in content despite both being labeled as theorem l3."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization proves a completely different mathematical statement than what is described in the natural language. The natural language claims to prove the simple inequality '1 < 2', while the Lean code proves bounds on the rational function (n+1)/(2n+1) for natural numbers n \u2265 1. These are entirely unrelated mathematical statements, representing a fundamental mismatch in content despite both being labeled as theorem l3.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "To show $\\frac{1}{2} < \\frac{n+1}{2n+1}$, we can cross-multiply since both denominators are positive for $n \\geq 1$. This gives us $1(2n+1) < 2(n+1)$, which simplifies to $2n+1 < 2n+2$.", "statement": "We assume:\n\u2022 $a_n = \\frac{n+1}{2n+1}$ [tc_1]\n\u2022 The denominators 2 and $2n+1$ are positive [l1]\n\u2022 The inequality $2n+1 < 2n+2$ is equivalent to $1 < 2$ [l2]\n\u2022 The inequality $1 < 2$ is true [l3]\nTherefore, we conclude:\n\u2022 $\\frac{1}{2} < a_n$ [l4].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (n : \u2115)\n  (h_n : n \u2265 1)\n  (tc_1 : \n    let a : \u2115 \u2192 \u211d := fun m => (m + 1 : \u211d) / (2 * m + 1 : \u211d)\n    \u2200 m : \u2115, m \u2265 1 \u2192 (1 : \u211d) / 2 < a m \u2227 a m \u2264 (2 : \u211d) / 3)\n  (l1 : 0 < (2 : \u211d) \u2227 0 < (2 * n + 1 : \u211d))\n  (l2 : \u2200 m : \u2115, (2 * m + 1 < 2 * m + 2) \u2194 (1 < 2))\n  (l3 : 1 < 2) :\n  let a_n : \u211d := (n + 1 : \u211d) / (2 * n + 1 : \u211d)\n  (1 : \u211d) / 2 < a_n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (n : \u2115)\n  (h_n : n \u2265 1)\n  (tc_1 : \n    let a : \u2115 \u2192 \u211d := fun m => (m + 1 : \u211d) / (2 * m + 1 : \u211d)\n    \u2200 m : \u2115, m \u2265 1 \u2192 (1 : \u211d) / 2 < a m \u2227 a m \u2264 (2 : \u211d) / 3)\n  (l1 : 0 < (2 : \u211d) \u2227 0 < (2 * n + 1 : \u211d))\n  (l2 : \u2200 m : \u2115, (2 * m + 1 < 2 * m + 2) \u2194 (1 < 2))\n  (l3 : 1 < 2) :\n  let a_n : \u211d := (n + 1 : \u211d) / (2 * n + 1 : \u211d)\n  (1 : \u211d) / 2 < a_n := by\n  intro a_n\n  have h_main : (1 : \u211d) / 2 < a_n := by\n    have h\u2084 : (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n      -- Use the given hypothesis `tc_1` to directly obtain the inequality\n      dsimp only at tc_1\n      have h\u2085 := tc_1 n h_n\n      have h\u2086 : (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n        -- Extract the first part of the conjunction from `tc_1`\n        have h\u2087 : (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n          simpa [a_n] using h\u2085.1\n        exact h\u2087\n      exact h\u2086\n    -- Since `a_n` is defined as `(n + 1 : \u211d) / (2 * n + 1 : \u211d)`, we can directly use `h\u2084`\n    simpa [a_n] using h\u2084\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The definition of a_n correctly translates the mathematical formula from natural language to Lean.", "The tc_1 assumption in Lean assumes the very inequality we're trying to prove (plus an additional upper bound), making this a circular assumption that contradicts the natural language's intent to derive the result.", "The positivity conditions for denominators are correctly captured in both versions.", "The logical equivalence is preserved, though using variable m instead of n - this is a minor notational difference that doesn't affect the mathematical meaning.", "The basic arithmetic fact 1 < 2 is identically represented in both versions.", "The conclusion statement perfectly matches between natural language and Lean formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The definition of a_n correctly translates the mathematical formula from natural language to Lean.', \"The tc_1 assumption in Lean assumes the very inequality we're trying to prove (plus an additional upper bound), making this a circular assumption that contradicts the natural language's intent to derive the result.\", 'The positivity conditions for denominators are correctly captured in both versions.', \"The logical equivalence is preserved, though using variable m instead of n - this is a minor notational difference that doesn't affect the mathematical meaning.\", 'The basic arithmetic fact 1 < 2 is identically represented in both versions.', 'The conclusion statement perfectly matches between natural language and Lean formalization.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This simplifies to $3n+3 \\leq 4n+2$. Subtracting $3n$ and $2$ from both sides gives $1 \\leq n$.", "statement": "We assume:\n\u2022 (no specific premises from this proof, this is general algebra)\nTherefore, we conclude:\n\u2022 The inequality $3n+3 \\leq 4n+2$ is equivalent to $1 \\leq n$ [l5].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (n : \u2124) : 3 * n + 3 \u2264 4 * n + 2 \u2194 1 \u2264 n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (n : \u2124) : 3 * n + 3 \u2264 4 * n + 2 \u2194 1 \u2264 n := by\n  have h_imp : 3 * n + 3 \u2264 4 * n + 2 \u2192 1 \u2264 n := by\n    intro h\n    -- Subtract 3n from both sides to get 3 \u2264 n + 2\n    have h\u2081 : 3 \u2264 n + 2 := by\n      linarith\n    -- Subtract 2 from both sides to get 1 \u2264 n\n    have h\u2082 : 1 \u2264 n := by\n      linarith\n    exact h\u2082\n  \n  have h_conv : 1 \u2264 n \u2192 3 * n + 3 \u2264 4 * n + 2 := by\n    intro h\n    -- Add 2 to both sides to get 3 \u2264 n + 2\n    have h\u2081 : 3 \u2264 n + 2 := by\n      linarith\n    -- Add 3n to both sides to get 3 + 3n \u2264 4n + 2\n    have h\u2082 : 3 * n + 3 \u2264 4 * n + 2 := by\n      linarith\n    exact h\u2082\n  \n  constructor\n  \u00b7 -- Prove the forward direction: 3 * n + 3 \u2264 4 * n + 2 \u2192 1 \u2264 n\n    intro h\n    exact h_imp h\n  \u00b7 -- Prove the backward direction: 1 \u2264 n \u2192 3 * n + 3 \u2264 4 * n + 2\n    intro h\n    exact h_conv h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equivalence statement and theorem naming from the natural language. However, it adds an explicit integer type constraint (n : \u2124) that is not mentioned in the natural language, which represents a minor structural difference in the scope of the theorem."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the mathematical equivalence statement and theorem naming from the natural language. However, it adds an explicit integer type constraint (n : \u2124) that is not mentioned in the natural language, which represents a minor structural difference in the scope of the theorem.']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Again, we can cross-multiply to get $3(n+1) \\leq 2(2n+1)$. This simplifies to $3n+3 \\leq 4n+2$.", "statement": "We assume:\n\u2022 $a_n = \\frac{n+1}{2n+1}$ [tc_1]\n\u2022 The denominators 3 and $2n+1$ are positive (using [l1] for $2n+1$)\n\u2022 $n \\geq 1$ [tc_2]\n\u2022 The inequality $3n+3 \\leq 4n+2$ is equivalent to $1 \\leq n$ [l5]\nTherefore, we conclude:\n\u2022 $a_n \\leq \\frac{2}{3}$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (n : \u2115) (hn : 1 \u2264 n) :\n  let a : \u2115 \u2192 \u211d := fun n => (n + 1 : \u211d) / (2 * n + 1 : \u211d)\n  a n \u2264 (2 : \u211d) / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (n : \u2115) (hn : 1 \u2264 n) :\n  let a : \u2115 \u2192 \u211d := fun n => (n + 1 : \u211d) / (2 * n + 1 : \u211d)\n  a n \u2264 (2 : \u211d) / 3 := by\n  intro a\n  have h\u2081 : (n : \u211d) \u2265 1 := by\n    norm_cast\n    <;> linarith\n  \n  have h\u2082 : (2 : \u211d) * (n : \u211d) + 1 > 0 := by\n    have h\u2082\u2081 : (n : \u211d) \u2265 1 := h\u2081\n    have h\u2082\u2082 : (2 : \u211d) * (n : \u211d) \u2265 2 := by\n      linarith\n    linarith\n  \n  have h\u2083 : (2 : \u211d) / 3 - ((n : \u211d) + 1) / (2 * (n : \u211d) + 1) = ((n : \u211d) - 1) / (3 * (2 * (n : \u211d) + 1)) := by\n    have h\u2083\u2081 : (2 : \u211d) / 3 - ((n : \u211d) + 1) / (2 * (n : \u211d) + 1) = (2 * (2 * (n : \u211d) + 1) - 3 * ((n : \u211d) + 1)) / (3 * (2 * (n : \u211d) + 1)) := by\n      field_simp [h\u2082.ne']\n      <;> ring_nf\n      <;> field_simp [h\u2082.ne']\n      <;> ring_nf\n      <;> linarith\n    rw [h\u2083\u2081]\n    have h\u2083\u2082 : (2 * (2 * (n : \u211d) + 1) - 3 * ((n : \u211d) + 1)) = (n : \u211d) - 1 := by\n      ring_nf\n      <;> linarith\n    rw [h\u2083\u2082]\n    <;> ring_nf\n    <;> field_simp [h\u2082.ne']\n    <;> ring_nf\n    <;> linarith\n  \n  have h\u2084 : ((n : \u211d) - 1) / (3 * (2 * (n : \u211d) + 1)) \u2265 0 := by\n    have h\u2084\u2081 : (n : \u211d) - 1 \u2265 0 := by\n      have h\u2084\u2082 : (n : \u211d) \u2265 1 := h\u2081\n      linarith\n    have h\u2084\u2082 : (3 : \u211d) * (2 * (n : \u211d) + 1) > 0 := by\n      have h\u2084\u2083 : (2 : \u211d) * (n : \u211d) + 1 > 0 := h\u2082\n      positivity\n    -- Since the numerator is non-negative and the denominator is positive, the fraction is non-negative.\n    exact div_nonneg h\u2084\u2081 (by linarith)\n  \n  have h\u2085 : (2 : \u211d) / 3 - ((n : \u211d) + 1) / (2 * (n : \u211d) + 1) \u2265 0 := by\n    rw [h\u2083]\n    exact h\u2084\n  \n  have h\u2086 : ((n : \u211d) + 1) / (2 * (n : \u211d) + 1) \u2264 (2 : \u211d) / 3 := by\n    have h\u2086\u2081 : (2 : \u211d) / 3 - ((n : \u211d) + 1) / (2 * (n : \u211d) + 1) \u2265 0 := h\u2085\n    have h\u2086\u2082 : ((n : \u211d) + 1) / (2 * (n : \u211d) + 1) \u2264 (2 : \u211d) / 3 := by\n      linarith\n    exact h\u2086\u2082\n  \n  simpa [a] using h\u2086", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all essential mathematical content from the natural language. The sequence definition a_n = (n+1)/(2n+1) is accurately represented, the constraint n \u2265 1 is properly formalized as a hypothesis, and the conclusion a_n \u2264 2/3 is correctly stated. The additional contextual information in the natural language (about positive denominators, equivalent inequalities, and reference labels) represents supporting reasoning rather than core theorem components, so their absence from the Lean formalization does not constitute a mismatch. The theorem structure appropriately captures the logical flow: given the constraint and definition, prove the inequality."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since both parts of the inequality hold, the full inequality $\\frac{1}{2} < a_n \\leq \\frac{2}{3}$ is proven.", "statement": "We assume:\n\u2022 $\\frac{1}{2} < a_n$ [l4]\n\u2022 $a_n \\leq \\frac{2}{3}$ [l6]\nTherefore, we conclude:\n\u2022 $\\frac{1}{2} < a_n \\leq \\frac{2}{3}$ [ts_1].", "dependencies": ["l4", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (n : \u2115) (hn : 1 \u2264 n) (a : \u2115 \u2192 \u211d) \n  (ha : a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d))\n  (l4 : (1 : \u211d) / 2 < a n) \n  (l6 : a n \u2264 (2 : \u211d) / 3) :\n  (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (n : \u2115) (hn : 1 \u2264 n) (a : \u2115 \u2192 \u211d) \n  (ha : a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d))\n  (l4 : (1 : \u211d) / 2 < a n) \n  (l6 : a n \u2264 (2 : \u211d) / 3) :\n  (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\n  have h_main : (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\n    refine' \u27e8l4, l6\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the logical structure of the natural language. The core mathematical statement (concluding 1/2 < a_n \u2264 2/3 from the two given inequalities) is faithfully represented. The additional parameters in Lean (n, hn, a, ha) provide mathematical context about the sequence but do not alter the fundamental logical relationship being expressed. The conclusion correctly combines the two premises using conjunction, matching the natural language's compound inequality notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    