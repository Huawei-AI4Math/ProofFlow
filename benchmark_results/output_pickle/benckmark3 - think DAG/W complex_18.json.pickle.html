
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $z$ be a complex number. If $z^2 + 2\bar{z} + 1 = 0$ and $\operatorname{Im}(z) < 0$, then $z = 1 - 2i$.

Proof: Let $z = x+iy$ for real numbers $x, y$. Substituting this form into the equation $z^2 + 2\bar{z} + 1 = 0$ and equating the real and imaginary parts to zero gives the system of equations $x^2 - y^2 + 2x + 1 = 0$ and $2y(x-1) = 0$. From the condition $\operatorname{Im}(z) < 0$, we know $y 
eq 0$, so from the second equation we deduce $x=1$. Substituting $x=1$ into the first equation gives $1 - y^2 + 2 + 1 = 0$, which simplifies to $y^2=4$. Since $\operatorname{Im}(z) < 0$, we must have $y=-2$, which means $z=1-2i$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let z be a complex number. If z^2 + 2z\u0304 + 1 = 0", "statement": "Premise:\n\u2022 Let z be a complex number such that z\u00b2 + 2*conj(z) + 1 = 0 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102) (tc_1 : z^2 + 2 * star z + 1 = 0)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly declares z as a complex number using the type \u2102, which perfectly matches the natural language condition.", "The Lean formalization uses 'star z' for complex conjugate, which is the standard Mathlib notation equivalent to 'conj(z)' in the natural language. The equation structure is identical."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "and Im(z) < 0", "statement": "Premise:\n\u2022 Let z be a complex number such that Im(z) < 0 [tc_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(tc_2 : z.im < 0)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'z : \u2102' directly corresponds to 'z is a complex number' in the natural language", "The Lean expression 'z.im < 0' perfectly captures 'Im(z) < 0' from the natural language, using Lean's standard notation for the imaginary part of a complex number"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let z = x+iy for real numbers x, y.", "statement": "Definition:\n\u2022 Let z be a complex number. We define its representation as z = x + i*y, where x and y are real numbers, x = Re(z), and y = Im(z) [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem z_condition (z : \u2102) \n  (h1 : z^2 + 2 * star z + 1 = 0) \n  (h2 : z.im < 0) : \n  z = 1 - 2 * I := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Both declare z as a complex number, which matches perfectly", "The natural language states z = x + i*y as a general representation, but Lean introduces a specific algebraic condition z^2 + 2 * star z + 1 = 0 that is not mentioned in the natural language", "The natural language states x and y are real numbers as part of the general definition, but Lean introduces a specific constraint z.im < 0 on the imaginary part that contradicts the general definitional nature", "The natural language concludes x = Re(z) as part of the definition, but Lean concludes z = 1 - 2 * I, which is a specific value assignment rather than a definitional relationship", "The natural language concludes y = Im(z) as part of the definition, but this conclusion is completely absent from the Lean formalization"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Both declare z as a complex number, which matches perfectly', 'The natural language states z = x + i*y as a general representation, but Lean introduces a specific algebraic condition z^2 + 2 * star z + 1 = 0 that is not mentioned in the natural language', 'The natural language states x and y are real numbers as part of the general definition, but Lean introduces a specific constraint z.im < 0 on the imaginary part that contradicts the general definitional nature', 'The natural language concludes x = Re(z) as part of the definition, but Lean concludes z = 1 - 2 * I, which is a specific value assignment rather than a definitional relationship', 'The natural language concludes y = Im(z) as part of the definition, but this conclusion is completely absent from the Lean formalization']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Substituting this form into the equation z^2 + 2z\u0304 + 1 = 0 and equating the real and imaginary parts to zero gives the system of equations x^2 - y^2 + 2x + 1 = 0 and 2y(x-1) = 0.", "statement": "We assume:\n\u2022 z is a complex number such that z\u00b2 + 2*conj(z) + 1 = 0 [tc_1]\n\u2022 z is represented as z = x + i*y, where x and y are real numbers with x = Re(z) and y = Im(z) [def_1]\nTherefore, we conclude:\n\u2022 x\u00b2 - y\u00b2 + 2*x + 1 = 0 and 2*y*(x-1) = 0 [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (h1 : z^2 + 2 * star z + 1 = 0) :\n  let x := Complex.re z\n  let y := Complex.im z\n  (x^2 - y^2 + 2*x + 1 = 0) \u2227 (2*y*(x-1) = 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (h1 : z^2 + 2 * star z + 1 = 0) :\n  let x := Complex.re z\n  let y := Complex.im z\n  (x^2 - y^2 + 2*x + 1 = 0) \u2227 (2*y*(x-1) = 0) := by\n  dsimp only\n  have h2 : (Complex.re z)^2 - (Complex.im z)^2 + 2 * Complex.re z + 1 = 0 := by\n    have h2\u2081 := h1\n    have h2\u2082 := Complex.ext_iff.1 h2\u2081 |>.1\n    simp [Complex.ext_iff, pow_two, Complex.ext_iff, Complex.add_re, Complex.add_im, Complex.mul_re,\n      Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_one, Complex.star_def] at h2\u2082 \u22a2\n    <;> ring_nf at h2\u2082 \u22a2 <;>\n    (try norm_num at h2\u2082 \u22a2) <;>\n    (try linarith) <;>\n    (try nlinarith) <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      }) <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      }) <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n  \n  have h3 : 2 * Complex.im z * (Complex.re z - 1) = 0 := by\n    have h3\u2081 := h1\n    have h3\u2082 := Complex.ext_iff.1 h3\u2081 |>.2\n    simp [Complex.ext_iff, pow_two, Complex.ext_iff, Complex.add_re, Complex.add_im, Complex.mul_re,\n      Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul, Complex.ofReal_one, Complex.star_def] at h3\u2082 \u22a2\n    <;> ring_nf at h3\u2082 \u22a2 <;>\n    (try norm_num at h3\u2082 \u22a2) <;>\n    (try linarith) <;>\n    (try nlinarith) <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      }) <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      }) <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z), sq_nonneg (Complex.re z - 1)]\n      })\n  \n  exact \u27e8h2, h3\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 46, "column": 57, "endLine": 81, "endColumn": 8, "data": "unsolved goals\nz : \u2102\nh1 : z ^ 2 + 2 * star z + 1 = 0\nh2 : z.re ^ 2 - z.im ^ 2 + 2 * z.re + 1 = 0\nh3\u2081 : z ^ 2 + 2 * star z + 1 = 0\nh3\u2082 : z.re * z.im * 2 - z.im * 2 = 0\n\u22a2 z.im = 0 \u2228 -1 + z.re = 0"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Complex conjugate notation differs (conj vs star) but both refer to the same mathematical operation", "The main assumption z\u00b2 + 2*conj(z) + 1 = 0 is correctly captured as hypothesis h1", "The Lean formalization implicitly captures that x and y are the real and imaginary parts through Complex.re and Complex.im, but doesn't explicitly state that x,y are real or that z = x + i*y as mentioned in the natural language", "The conclusion with both equations connected by logical AND is perfectly captured", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.75 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (z : \u2102) (h1 : z^2 + 2 * star z + 1 = 0) :\n  let x := Complex.re z\n  let y := Complex.im z\n  (x^2 - y^2 + 2*x + 1 = 0) \u2227 (2*y*(x-1) = 0) := by\n  dsimp only\n  have h2 : (Complex.re z)^2 - (Complex.im z)^2 + 2 * (Complex.re z) + 1 = 0 := by\n    have h2\u2081 := h1\n    simp [Complex.ext_iff, pow_two, Complex.star_def, Complex.add_re, Complex.add_im, Complex.mul_re,\n      Complex.mul_im] at h2\u2081 \u22a2\n    <;> ring_nf at h2\u2081 \u22a2 <;>\n    (try norm_num at h2\u2081 \u22a2) <;>\n    (try nlinarith) <;>\n    (try linarith) <;>\n    (try nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z)])\n    <;>\n    (try\n      {\n        nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z)]\n      })\n  \n  have h3 : 2 * (Complex.im z) * (Complex.re z - 1) = 0 := by\n    have h3\u2081 := h1\n    simp [Complex.ext_iff, pow_two, Complex.star_def, Complex.add_re, Complex.add_im, Complex.mul_re,\n      Complex.mul_im] at h3\u2081 \u22a2\n    <;>\n    (try ring_nf at h3\u2081 \u22a2) <;>\n    (try norm_num at h3\u2081 \u22a2) <;>\n    (try\n      {\n        have h4 : 2 * (Complex.im z) * (Complex.re z - 1) = 0 := by\n          -- Factor the expression to match the goal\n          have h5 : Complex.re z * Complex.im z * 2 - Complex.im z * 2 = 0 := by\n            linarith\n          have h6 : 2 * Complex.im z * (Complex.re z - 1) = 0 := by\n            ring_nf at h5 \u22a2\n            linarith\n          exact h6\n        exact h4\n      })\n    <;>\n    (try linarith)\n    <;>\n    (try nlinarith)\n    <;>\n    (try nlinarith [sq_nonneg (Complex.re z + 1), sq_nonneg (Complex.im z)])\n  \n  exact \u27e8h2, h3\u27e9"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From the condition Im(z) < 0, we know y \u2260 0", "statement": "We assume:\n\u2022 The imaginary part of z is less than 0, i.e., Im(z) < 0 [tc_2]\n\u2022 z is represented as z = x + i*y, where x and y are real numbers with x = Re(z) and y = Im(z) [def_1]\nTherefore, we conclude:\n\u2022 y \u2260 0 [l2].", "dependencies": ["tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (z : \u2102) \n  (x y : \u211d)\n  (tc_2 : z.im < 0)\n  (def_1 : z = x + y * I) :\n  y \u2260 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (z : \u2102) \n  (x y : \u211d)\n  (tc_2 : z.im < 0)\n  (def_1 : z = x + y * I) :\n  y \u2260 0 := by\n  have h_main : y \u2260 0 := by\n    by_contra h\n    -- Assume y = 0 and derive a contradiction\n    have h\u2081 : y = 0 := by simpa using h\n    have h\u2082 : z = (x : \u2102) := by\n      rw [def_1]\n      simp [h\u2081]\n      <;> simp [Complex.ext_iff, pow_two]\n      <;> norm_num\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, pow_two]\n      <;> norm_num\n      <;> linarith\n    have h\u2083 : z.im = 0 := by\n      rw [h\u2082]\n      simp [Complex.ext_iff, pow_two]\n      <;> norm_num\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The assumption about the imaginary part being negative is correctly captured in both the natural language and Lean formalization.", "The complex number representation is mostly correct, but the Lean formalization doesn't explicitly state x = Re(z) and y = Im(z) as mentioned in the natural language, though these are mathematically implicit given z = x + y*I.", "The conclusion y \u2260 0 is identically expressed in both versions.", "The overall logical structure from assumptions to conclusion is properly maintained in the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "so from the second equation we deduce x=1.", "statement": "We assume:\n\u2022 The real numbers x and y satisfy the equation 2*y*(x-1) = 0 (from l1) [l1]\n\u2022 y \u2260 0 [l2]\nTherefore, we conclude:\n\u2022 x = 1 [l3].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (x y : \u211d) (l1 : 2 * y * (x - 1) = 0) (l2 : y \u2260 0) : x = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (x y : \u211d) (l1 : 2 * y * (x - 1) = 0) (l2 : y \u2260 0) : x = 1 := by\n  have h2y_ne_zero : (2 : \u211d) * y \u2260 0 := by\n    intro h\n    have h3 : y = 0 := by\n      apply mul_left_cancel\u2080 (show (2 : \u211d) \u2260 0 by norm_num)\n      linarith\n    contradiction\n  \n  have hx_sub_1_eq_zero : x - 1 = 0 := by\n    have h3 : (2 : \u211d) * y * (x - 1) = 0 := l1\n    have h4 : (2 : \u211d) * y \u2260 0 := h2y_ne_zero\n    have h5 : x - 1 = 0 := by\n      apply mul_left_cancel\u2080 h4\n      nlinarith\n    exact h5\n  \n  have h_main : x = 1 := by\n    have h3 : x - 1 = 0 := hx_sub_1_eq_zero\n    have h4 : x = 1 := by linarith\n    exact h4\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly specify x and y as real numbers", "The equation 2*y*(x-1) = 0 is accurately formalized with proper mathematical notation and operator precedence", "The condition y \u2260 0 is directly and correctly translated", "The conclusion x = 1 is properly stated as the theorem's goal", "The overall logical structure as a theorem with hypotheses leading to a conclusion is perfectly preserved"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Substituting x=1 into the first equation gives 1 - y^2 + 2 + 1 = 0, which simplifies to y^2=4.", "statement": "We assume:\n\u2022 The real numbers x and y satisfy the equation x\u00b2 - y\u00b2 + 2*x + 1 = 0 (from l1) [l1]\n\u2022 x = 1 [l3]\nTherefore, we conclude:\n\u2022 y\u00b2 = 4 [l4].", "dependencies": ["l1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (x y : \u211d) \n  (h1 : x^2 - y^2 + 2*x + 1 = 0)\n  (h2 : x = 1) :\n  y^2 = 4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (x y : \u211d) \n  (h1 : x^2 - y^2 + 2*x + 1 = 0)\n  (h2 : x = 1) :\n  y^2 = 4 := by\n  have h3 : y^2 = 4 := by\n    have h4 : x = 1 := h2\n    rw [h4] at h1\n    -- Substitute x = 1 into the equation x^2 - y^2 + 2*x + 1 = 0\n    ring_nf at h1 \u22a2\n    -- Simplify the equation to 4 - y^2 = 0\n    nlinarith\n    -- Solve for y^2 to get y^2 = 4\n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly specify x and y as real numbers, matching the natural language", "The first hypothesis perfectly captures the equation x\u00b2 - y\u00b2 + 2*x + 1 = 0", "The second hypothesis exactly matches the condition x = 1", "The conclusion y\u00b2 = 4 is precisely represented as the goal", "The overall theorem structure correctly formalizes the logical relationship between premises and conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Since Im(z) < 0, we must have y=-2", "statement": "We assume:\n\u2022 The imaginary part of z is less than 0, i.e., Im(z) < 0 [tc_2]\n\u2022 z is represented as z = x + i*y, where x and y are real numbers with x = Re(z) and y = Im(z) [def_1]\n\u2022 y\u00b2 = 4 [l4]\nTherefore, we conclude:\n\u2022 y = -2 [l5].", "dependencies": ["tc_2", "def_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (z : \u2102) (x y : \u211d) \n  (h1 : z.im < 0)\n  (h2 : z.re = x)\n  (h3 : z.im = y)\n  (h4 : y^2 = 4) :\n  y = -2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (z : \u2102) (x y : \u211d) \n  (h1 : z.im < 0)\n  (h2 : z.re = x)\n  (h3 : z.im = y)\n  (h4 : y^2 = 4) :\n  y = -2 := by\n  have h5 : y < 0 := by\n    have h5\u2081 : y < 0 := by\n      linarith [h1, h3]\n    exact h5\u2081\n  \n  have h6 : y = 2 \u2228 y = -2 := by\n    have h6\u2081 : y = 2 \u2228 y = -2 := by\n      have h6\u2082 : y ^ 2 = 4 := h4\n      have h6\u2083 : y = 2 \u2228 y = -2 := by\n        have h6\u2084 : y = 2 \u2228 y = -2 := by\n          -- Use the fact that if y^2 = 4, then y = 2 or y = -2\n          have h6\u2085 : y ^ 2 = 2 ^ 2 := by norm_num [h6\u2082]\n          have h6\u2086 : y = 2 \u2228 y = -2 := by\n            apply or_iff_not_imp_left.mpr\n            intro h6\u2087\n            apply eq_of_sub_eq_zero\n            apply mul_left_cancel\u2080 (sub_ne_zero.mpr h6\u2087)\n            nlinarith\n          exact h6\u2086\n        exact h6\u2084\n      exact h6\u2083\n    exact h6\u2081\n  \n  have h7 : y \u2260 2 := by\n    intro h7\u2081\n    have h7\u2082 : y < 0 := h5\n    have h7\u2083 : y = 2 := h7\u2081\n    linarith\n  \n  have h8 : y = -2 := by\n    cases h6 with\n    | inl h6 =>\n      exfalso\n      apply h7\n      exact h6\n    | inr h6 =>\n      exact h6\n  \n  exact h8", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The condition z.im < 0 perfectly matches the natural language statement about the imaginary part being less than 0", "The hypothesis z.re = x with x : \u211d correctly captures that x represents the real part of z and is a real number", "The hypothesis z.im = y with y : \u211d correctly captures that y represents the imaginary part of z and is a real number", "The constraint y^2 = 4 is exactly as stated in the natural language", "The conclusion y = -2 perfectly matches the natural language conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "which means z=1-2i.", "statement": "We assume:\n\u2022 z is represented as z = x + i*y, where x and y are real numbers with x = Re(z) and y = Im(z) [def_1]\n\u2022 x = 1 [l3]\n\u2022 y = -2 [l5]\nTherefore, we conclude:\n\u2022 z = 1 - 2*i [ts_1].", "dependencies": ["def_1", "l3", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (x y : \u211d) \n  (h1 : x = 1) \n  (h2 : y = -2) :\n  (x : \u2102) + (y : \u2102) * I = 1 - 2 * I := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (x y : \u211d) \n  (h1 : x = 1) \n  (h2 : y = -2) :\n  (x : \u2102) + (y : \u2102) * I = 1 - 2 * I := by\n  have h_main : (x : \u2102) + (y : \u2102) * I = 1 - 2 * I := by\n    rw [h1, h2]\n    simp [Complex.ext_iff, Complex.I_mul_I]\n    <;> norm_num <;>\n    (try ring_nf) <;>\n    (try simp_all) <;>\n    (try norm_num) <;>\n    (try linarith)\n    <;>\n    simp_all [Complex.ext_iff, Complex.I_mul_I]\n    <;>\n    norm_num <;>\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the essential mathematical content. It properly represents the complex number construction z = x + i*y using the appropriate Lean syntax (x : \u2102) + (y : \u2102) * I, includes the given conditions x = 1 and y = -2 as hypotheses, and states the correct conclusion 1 - 2 * I. While the natural language includes some definitional context about Re(z) and Im(z), the Lean theorem focuses on the core computational result, which is mathematically sound and complete for proving the stated conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    