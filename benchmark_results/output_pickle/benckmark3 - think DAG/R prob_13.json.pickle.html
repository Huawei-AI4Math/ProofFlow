
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X_1, \dots, X_n$ be a sequence of independent and identically distributed (i.i.d.) random variables from a Bernoulli distribution with parameter $p$, where $0 < p < 1$. Let the sample mean be defined as $\bar{X}_n = \frac{1}{n} \sum_{i=1}^n X_i$. Determine the expected value of the sample mean, $E[\bar{X}_n]$, the variance of the sample mean, $Var(\bar{X}_n)$, and the limit of the variance as $n 	o \infty$.

Proof: First, we recall the fundamental properties of the Bernoulli distribution. From the properties of a Bernoulli distribution, the expected value of any single variable $X_i$ is $E[X_i] = p$. Similarly, the variance of any single variable $X_i$ is $Var(X_i) = p(1-p)$.

To find the expectation of the sample mean, we first apply a property of expectation. By the linearity of expectation, the expectation of the sample mean is $E[\bar{X}_n] = E\left[\frac{1}{n} \sum_{i=1}^n X_i\right] = \frac{1}{n} \sum_{i=1}^n E[X_i]$. Substituting the result for $E[X_i]$ into our expression for $E[\bar{X}_n]$ gives the first solution, $E[\bar{X}_n] = \frac{1}{n} \sum_{i=1}^n p = \frac{1}{n}(np) = p$.

Next, we calculate the variance. Since the $X_i$ are independent, the variance of the sum is the sum of the variances: $Var\left(\sum_{i=1}^n X_i\right) = \sum_{i=1}^n Var(X_i)$. Also, using the property of variance for a scaled random variable, we have $Var(\bar{X}_n) = Var\left(\frac{1}{n} \sum_{i=1}^n X_i\right) = \frac{1}{n^2} Var\left(\sum_{i=1}^n X_i\right)$. Combining these properties with the known variance of a Bernoulli variable gives the second solution, $Var(\bar{X}_n) = \frac{1}{n^2} \sum_{i=1}^n p(1-p) = \frac{1}{n^2} (np(1-p)) = \frac{p(1-p)}{n}$.

Finally, for the third solution, we take the limit of the variance as $n$ approaches infinity: $\lim_{n 	o \infty} Var(\bar{X}_n) = \lim_{n 	o \infty} \frac{p(1-p)}{n} = 0$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X_1, \\dots, X_n$ be a sequence of independent and identically distributed (i.i.d.) random variables from a Bernoulli distribution with parameter $p$, where $0 < p < 1$.", "statement": "Premise:\n\u2022 $X_1, \\dots, X_n$ are independent and identically distributed (i.i.d.) random variables from a Bernoulli distribution with parameter $p$, where $0 < p < 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (X : Fin n \u2192 \u211d) (p : \u211d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean code declares X as a function Fin n \u2192 \u211d but completely omits the crucial properties of independence and identical distribution. Random variables require probability space formalization, which is entirely missing.", "The Lean code has no formalization of the Bernoulli distribution property. The variables are just declared as real-valued functions without any distributional characterization.", "The Lean code declares p : \u211d but omits the essential constraint 0 < p < 1 that defines the valid parameter range for a Bernoulli distribution."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean code declares X as a function Fin n \u2192 \u211d but completely omits the crucial properties of independence and identical distribution. Random variables require probability space formalization, which is entirely missing.', 'The Lean code has no formalization of the Bernoulli distribution property. The variables are just declared as real-valued functions without any distributional characterization.', 'The Lean code declares p : \u211d but omits the essential constraint 0 < p < 1 that defines the valid parameter range for a Bernoulli distribution.']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let the sample mean be defined as $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$.", "statement": "We assume:\n\u2022 $X_1, \\dots, X_n$ are random variables [tc_1].\nDefinition:\n\u2022 The sample mean is defined as $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (hn : 0 < n) (X : Fin n \u2192 \u211d)\n\nnoncomputable def sampleMean : \u211d := \n  (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization declares X as a function from Fin n to \u211d, which represents real-valued functions, not random variables. Random variables have probabilistic structure and are typically defined on probability spaces, which is completely missing from the Lean formalization.", "The sample mean formula is mathematically equivalent, but uses Fin n indexing instead of the traditional 1 to n indexing. The Lean version also includes an extra condition (hn : 0 < n) not mentioned in the natural language, but this is a reasonable mathematical constraint."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization declares X as a function from Fin n to \u211d, which represents real-valued functions, not random variables. Random variables have probabilistic structure and are typically defined on probability spaces, which is completely missing from the Lean formalization.', 'The sample mean formula is mathematically equivalent, but uses Fin n indexing instead of the traditional 1 to n indexing. The Lean version also includes an extra condition (hn : 0 < n) not mentioned in the natural language, but this is a reasonable mathematical constraint.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From the properties of a Bernoulli distribution, the expected value of any single variable $X_i$ is $E[X_i] = p$.", "statement": "We assume:\n\u2022 $X_i$ is a random variable from a Bernoulli distribution with parameter $p$ [tc_1].\nTherefore, we conclude:\n\u2022 The expected value of $X_i$ is $E[X_i] = p$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p : \u211d) (h_p_range : 0 < p \u2227 p < 1)\n  : (p * 1 + (1 - p) * 0 : \u211d) = p := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p : \u211d) (h_p_range : 0 < p \u2227 p < 1)\n  : (p * 1 + (1 - p) * 0 : \u211d) = p := by\n  have h_main : (p * 1 + (1 - p) * 0 : \u211d) = p := by\n    norm_num [mul_zero, sub_mul, add_zero, mul_one]\n    <;> ring_nf at *\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical relationship E[X_i] = p for a Bernoulli random variable through the algebraic identity (p * 1 + (1 - p) * 0 = p), which is the precise formula for computing the expected value of a Bernoulli distribution. While the formalization is expressed algebraically rather than in explicit probabilistic terms, it represents the exact same mathematical content. The additional constraint 0 < p < 1 is a reasonable parameter range for Bernoulli distributions and doesn't contradict the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Similarly, the variance of any single variable $X_i$ is $Var(X_i) = p(1-p)$.", "statement": "We assume:\n\u2022 $X_i$ is a random variable from a Bernoulli distribution with parameter $p$ [tc_1].\nTherefore, we conclude:\n\u2022 The variance of $X_i$ is $Var(X_i) = p(1-p)$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (p : \u211d) (h_p : 0 < p \u2227 p < 1) :\n  let X : \u211d \u2192 \u211d := fun x => if x = 1 then 1 else 0\n  -- For Bernoulli distribution with parameter p\n  -- E[X] = p, E[X\u00b2] = p, Var(X) = E[X\u00b2] - (E[X])\u00b2\n  (p - p^2) = p * (1 - p) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (p : \u211d) (h_p : 0 < p \u2227 p < 1) :\n  let X : \u211d \u2192 \u211d := fun x => if x = 1 then 1 else 0\n  (p - p^2) = p * (1 - p) := by\n  intro X\n  have h_main : p - p ^ 2 = p * (1 - p) := by\n    have h1 : p * (1 - p) = p - p ^ 2 := by\n      ring\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization defines X as a simple indicator function on real numbers rather than properly modeling a Bernoulli random variable. A Bernoulli random variable should be defined in terms of probability measures and sample spaces, not as a deterministic function that maps 1 to 1 and everything else to 0.", "The parameter constraints are appropriately captured. The condition 0 < p \u2227 p < 1 correctly represents the valid range for a Bernoulli parameter, though technically p could equal 0 or 1 in degenerate cases.", "The variance formula is mathematically correct (p - p\u00b2 = p(1-p)), but the Lean formalization completely bypasses the actual definition and computation of variance for a random variable. It proves an algebraic identity rather than establishing that the variance of the Bernoulli random variable equals this expression.", "The comments in the Lean code show awareness of the proper probabilistic foundations (expectation, variance formula), but these are not formally incorporated into the theorem statement or proof structure."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization defines X as a simple indicator function on real numbers rather than properly modeling a Bernoulli random variable. A Bernoulli random variable should be defined in terms of probability measures and sample spaces, not as a deterministic function that maps 1 to 1 and everything else to 0.', 'The parameter constraints are appropriately captured. The condition 0 < p \u2227 p < 1 correctly represents the valid range for a Bernoulli parameter, though technically p could equal 0 or 1 in degenerate cases.', 'The variance formula is mathematically correct (p - p\u00b2 = p(1-p)), but the Lean formalization completely bypasses the actual definition and computation of variance for a random variable. It proves an algebraic identity rather than establishing that the variance of the Bernoulli random variable equals this expression.', 'The comments in the Lean code show awareness of the proper probabilistic foundations (expectation, variance formula), but these are not formally incorporated into the theorem statement or proof structure.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "By the linearity of expectation, the expectation of the sample mean is $E[\\bar{X}_n] = E\\left[\\frac{1}{n} \\sum_{i=1}^n X_i\\right] = \\frac{1}{n} \\sum_{i=1}^n E[X_i]$.", "statement": "We assume:\n\u2022 $X_1, \\dots, X_n$ are random variables [tc_1].\n\u2022 The sample mean is $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$ [def_1].\nTherefore, we conclude:\n\u2022 By linearity of expectation, $E[\\bar{X}_n] = \\frac{1}{n} \\sum_{i=1}^n E[X_i]$ [l3].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (n : \u2115) (hn : 0 < n) \n  (X : Fin n \u2192 \u211d) \n  (E : (Fin n \u2192 \u211d) \u2192 \u211d) -- expectation operator\n  (h_def : \u2200 Y : Fin n \u2192 \u211d, E Y = (1 / (n : \u211d)) * \u2211 i : Fin n, Y i) -- definition of sample mean expectation\n  : E (fun i => X i) = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => X j) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (n : \u2115) (hn : 0 < n) \n  (X : Fin n \u2192 \u211d) \n  (E : (Fin n \u2192 \u211d) \u2192 \u211d) \n  (h_def : \u2200 Y : Fin n \u2192 \u211d, E Y = (1 / (n : \u211d)) * \u2211 i : Fin n, Y i) \n  : E (fun i => X i) = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => X j) := by\n  have h_LHS : E (fun i => X i) = (1 / (n : \u211d)) * \u2211 i : Fin n, X i := by\n    have h1 : E (fun i => X i) = (1 / (n : \u211d)) * \u2211 i : Fin n, (fun i => X i) i := by\n      apply h_def\n    have h2 : \u2211 i : Fin n, (fun i => X i) i = \u2211 i : Fin n, X i := by simp\n    rw [h1, h2]\n    <;> simp [Finset.sum_const, Finset.card_fin]\n    <;> field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n    <;> ring\n  \n  have h_E_const : \u2200 (i : Fin n), E (fun j => X j) = (1 / (n : \u211d)) * \u2211 j : Fin n, X j := by\n    intro i\n    have h1 : E (fun j => X j) = (1 / (n : \u211d)) * \u2211 j : Fin n, (fun j => X j) j := by\n      apply h_def\n    have h2 : \u2211 j : Fin n, (fun j => X j) j = \u2211 j : Fin n, X j := by simp\n    rw [h1, h2]\n    <;> simp [Finset.sum_const, Finset.card_fin]\n    <;> field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n    <;> ring\n  \n  have h_sum_E : \u2211 i : Fin n, E (fun j => X j) = \u2211 i : Fin n, X i := by\n    have h1 : \u2211 i : Fin n, E (fun j => X j) = \u2211 i : Fin n, ((1 / (n : \u211d)) * \u2211 j : Fin n, X j) := by\n      apply Finset.sum_congr rfl\n      intro i _\n      rw [h_E_const i]\n    rw [h1]\n    have h2 : \u2211 i : Fin n, ((1 / (n : \u211d)) * \u2211 j : Fin n, X j) = (n : \u211d) * ((1 / (n : \u211d)) * \u2211 j : Fin n, X j) := by\n      simp [Finset.sum_const, Finset.card_fin]\n      <;> ring_nf\n      <;> field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n      <;> ring_nf\n    rw [h2]\n    have h3 : (n : \u211d) * ((1 / (n : \u211d)) * \u2211 j : Fin n, X j) = \u2211 j : Fin n, X j := by\n      have h4 : (n : \u211d) \u2260 0 := by\n        norm_cast\n        <;> omega\n      field_simp [h4]\n      <;> ring_nf\n      <;> field_simp [h4]\n      <;> ring_nf\n    rw [h3]\n    <;> simp [Finset.sum_const, Finset.card_fin]\n    <;> field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n    <;> ring_nf\n  \n  have h_RHS : (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => X j) = (1 / (n : \u211d)) * \u2211 i : Fin n, X i := by\n    rw [h_sum_E]\n    <;>\n    simp_all [Finset.sum_const, Finset.card_fin]\n    <;>\n    field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n    <;>\n    ring_nf\n  \n  have h_final : E (fun i => X i) = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => X j) := by\n    calc\n      E (fun i => X i) = (1 / (n : \u211d)) * \u2211 i : Fin n, X i := by rw [h_LHS]\n      _ = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => X j) := by\n        rw [h_RHS]\n        <;>\n        simp_all [Finset.sum_const, Finset.card_fin]\n        <;>\n        field_simp [Nat.cast_ne_zero.mpr (by linarith : n \u2260 0)]\n        <;>\n        ring_nf\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Random variables representation as Fin n \u2192 \u211d is appropriate, though variable naming differs from X\u2081, ..., X\u2099 notation.", "The sample mean $\\bar{X}_n$ is never explicitly defined in the Lean formalization, which is a key component missing from the natural language definition.", "The expectation operator E is incorrectly defined in hypothesis h_def as computing the sample mean formula rather than representing a proper expectation operator with linearity properties.", "The main theorem statement doesn't correctly capture the linearity of expectation. The left side should be E applied to the sample mean, and the right side should sum E applied to individual X_i components, not E applied to the entire vector X."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Random variables representation as Fin n \u2192 \u211d is appropriate, though variable naming differs from X\u2081, ..., X\u2099 notation.', 'The sample mean $\\\\bar{X}_n$ is never explicitly defined in the Lean formalization, which is a key component missing from the natural language definition.', 'The expectation operator E is incorrectly defined in hypothesis h_def as computing the sample mean formula rather than representing a proper expectation operator with linearity properties.', \"The main theorem statement doesn't correctly capture the linearity of expectation. The left side should be E applied to the sample mean, and the right side should sum E applied to individual X_i components, not E applied to the entire vector X.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting the result for $E[X_i]$ into our expression for $E[\\bar{X}_n]$ gives the first solution, $E[\\bar{X}_n] = \\frac{1}{n} \\sum_{i=1}^n p = \\frac{1}{n}(np) = p$.", "statement": "We assume:\n\u2022 $E[\\bar{X}_n] = \\frac{1}{n} \\sum_{i=1}^n E[X_i]$ [l3].\n\u2022 For each $X_i$, $E[X_i] = p$ [l1].\nTherefore, we conclude:\n\u2022 $E[\\bar{X}_n] = p$ [ts_1].", "dependencies": ["l1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (n : \u2115) (hn : 0 < n)\n  (p : \u211d) (hp : 0 < p \u2227 p < 1)\n  (X : Fin n \u2192 \u211d) -- sequence of Bernoulli random variables\n  (E : (Fin n \u2192 \u211d) \u2192 \u211d) -- expectation operator\n  (h_l1 : \u2200 i : Fin n, E (fun j => if j = i then 1 else 0) = p) -- l1: E[X\u1d62] = p\n  (h_l3 : E (fun i => (1 / (n : \u211d)) * \u2211 j : Fin n, X j) = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => if j = i then 1 else 0)) -- l3: E[X\u0304\u2099] = (1/n)\u2211\u1d62\u208c\u2081\u207f E[X\u1d62]\n  : E (fun i => (1 / (n : \u211d)) * \u2211 j : Fin n, X j) = p := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (n : \u2115) (hn : 0 < n)\n  (p : \u211d) (hp : 0 < p \u2227 p < 1)\n  (X : Fin n \u2192 \u211d)\n  (E : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (h_l1 : \u2200 i : Fin n, E (fun j => if j = i then 1 else 0) = p)\n  (h_l3 : E (fun i => (1 / (n : \u211d)) * \u2211 j : Fin n, X j) = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => if j = i then 1 else 0))\n  : E (fun i => (1 / (n : \u211d)) * \u2211 j : Fin n, X j) = p := by\n  have h_sum : (\u2211 i : Fin n, E (fun j => if j = i then (1 : \u211d) else 0)) = (n : \u211d) * p := by\n    calc\n      (\u2211 i : Fin n, E (fun j => if j = i then (1 : \u211d) else 0)) = \u2211 i : Fin n, p := by\n        apply Finset.sum_congr rfl\n        intro i _\n        rw [h_l1 i]\n      _ = \u2211 i : Fin n, (p : \u211d) := by simp\n      _ = (n : \u211d) * p := by\n        simp [Finset.sum_const, Finset.card_fin]\n        <;> ring_nf\n        <;> field_simp [hn.ne']\n        <;> ring_nf\n  \n  have h_main : (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => if j = i then (1 : \u211d) else 0) = p := by\n    rw [h_sum]\n    have h\u2081 : (n : \u211d) \u2260 0 := by\n      norm_cast\n      <;> linarith\n    field_simp [h\u2081]\n    <;> ring_nf\n    <;> field_simp [h\u2081]\n    <;> linarith\n  \n  have h_final : E (fun i => (1 / (n : \u211d)) * \u2211 j : Fin n, X j) = p := by\n    calc\n      E (fun i => (1 / (n : \u211d)) * \u2211 j : Fin n, X j) = (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => if j = i then 1 else 0) := by\n        rw [h_l3]\n      _ = p := by\n        -- Use the previously established fact h_main to conclude the proof\n        have h\u2082 : (1 / (n : \u211d)) * \u2211 i : Fin n, E (fun j => if j = i then (1 : \u211d) else 0) = p := h_main\n        -- Since the sum in h_main is the same as in h_l3, we can directly use it\n        simpa using h\u2082\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The linearity assumption h_l3 uses indicator functions instead of the declared random variables X, creating inconsistency with the natural language which refers to the same sequence of random variables throughout.", "The individual expectation assumption h_l1 represents X_i as indicator functions rather than using the declared variable X, which doesn't match the natural language that refers to the same X_i variables mentioned in the setup.", "The conclusion correctly captures the mathematical statement that the expectation of the sample mean equals p.", "The Lean code declares X : Fin n \u2192 \u211d as random variables but then uses completely different indicator function representations in the hypotheses, creating a major disconnect from the natural language which consistently refers to the same sequence X_i."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The linearity assumption h_l3 uses indicator functions instead of the declared random variables X, creating inconsistency with the natural language which refers to the same sequence of random variables throughout.', \"The individual expectation assumption h_l1 represents X_i as indicator functions rather than using the declared variable X, which doesn't match the natural language that refers to the same X_i variables mentioned in the setup.\", 'The conclusion correctly captures the mathematical statement that the expectation of the sample mean equals p.', 'The Lean code declares X : Fin n \u2192 \u211d as random variables but then uses completely different indicator function representations in the hypotheses, creating a major disconnect from the natural language which consistently refers to the same sequence X_i.']"}, "solved_negation": null, "type": "solution"}, "l4": {"id": "l4", "natural_language": "Since the $X_i$ are independent, the variance of the sum is the sum of the variances: $Var\\left(\\sum_{i=1}^n X_i\\right) = \\sum_{i=1}^n Var(X_i)$.", "statement": "We assume:\n\u2022 $X_1, \\dots, X_n$ are independent random variables [tc_1].\nTherefore, we conclude:\n\u2022 The variance of the sum is the sum of the variances: $Var\\left(\\sum_{i=1}^n X_i\\right) = \\sum_{i=1}^n Var(X_i)$ [l4].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  {n : \u2115} (X : Fin n \u2192 \u211d \u2192 \u211d)\n  (h_indep : \u2200 i j : Fin n, i \u2260 j \u2192 \u2200 x y : \u211d, X i x * X j y = X i y * X j x) :\n  \u2200 x : \u211d, (\u2211 i, X i x)^2 - (\u2211 i, (X i x)^2) = \u2211 i, ((X i x)^2 - (X i x)^2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  {n : \u2115} (X : Fin n \u2192 \u211d \u2192 \u211d)\n  (h_indep : \u2200 i j : Fin n, i \u2260 j \u2192 \u2200 x y : \u211d, X i x * X j y = X i y * X j x) :\n  \u2200 x : \u211d, (\u2211 i, X i x)^2 - (\u2211 i, (X i x)^2) = \u2211 i, ((X i x)^2 - (X i x)^2) := by\n  have h_main : \u2200 (x : \u211d), (\u2211 i : Fin n, X i x)^2 - (\u2211 i : Fin n, (X i x)^2) = \u2211 i : Fin n, ((X i x)^2 - (X i x)^2) := by\n    intro x\n    have h\u2081 : \u2211 i : Fin n, ((X i x)^2 - (X i x)^2) = 0 := by\n      apply Finset.sum_eq_zero\n      intro i _\n      ring\n    have h\u2082 : (\u2211 i : Fin n, X i x)^2 - \u2211 i : Fin n, (X i x)^2 = 0 := by\n      -- We cannot prove this in general, but perhaps we can use the given condition to find that it is 0\n      cases n with\n      | zero =>\n        simp [Fin.sum_univ_zero]\n      | succ n =>\n        cases n with\n        | zero =>\n          simp [Fin.sum_univ_succ]\n          <;> ring_nf\n          <;> simp_all\n          <;> linarith\n        | succ n =>\n          sorry\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The independence condition in Lean (X i x * X j y = X i y * X j x) does not correspond to statistical independence of random variables. This is a completely different mathematical concept.", "The Lean formalization treats X as deterministic functions (\u211d \u2192 \u211d) rather than random variables, which fundamentally changes the mathematical context from probability theory to deterministic analysis.", "The variance formula is completely missing from the Lean formalization. Instead of Var(\u2211 X_i) = \u2211 Var(X_i), the Lean code has an equation that simplifies to (\u2211 X_i)\u00b2 - \u2211 (X_i)\u00b2 = 0, which is not related to variance and lacks any probability measure or expectation operators.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The independence condition in Lean (X i x * X j y = X i y * X j x) does not correspond to statistical independence of random variables. This is a completely different mathematical concept.', 'The Lean formalization treats X as deterministic functions (\u211d \u2192 \u211d) rather than random variables, which fundamentally changes the mathematical context from probability theory to deterministic analysis.', 'The variance formula is completely missing from the Lean formalization. Instead of Var(\u2211 X_i) = \u2211 Var(X_i), the Lean code has an equation that simplifies to (\u2211 X_i)\u00b2 - \u2211 (X_i)\u00b2 = 0, which is not related to variance and lacks any probability measure or expectation operators.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Also, using the property of variance for a scaled random variable, we have $Var(\\bar{X}_n) = Var\\left(\\frac{1}{n} \\sum_{i=1}^n X_i\\right) = \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i\\right)$.", "statement": "We assume:\n\u2022 The sample mean is $\\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i$ [def_1].\nTherefore, we conclude:\n\u2022 Using the property $Var(aY) = a^2Var(Y)$, we have $Var(\\bar{X}_n) = \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i\\right)$ [l5].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  {n : \u2115} (hn : 0 < n) (p : \u211d) (hp : 0 < p \u2227 p < 1) :\n  let X : Fin n \u2192 \u211d := fun _ => p -- Bernoulli random variables with parameter p\n  let sampleMean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  -- Using the property Var(aY) = a\u00b2Var(Y), we have:\n  let varianceSum := \u2211 i : Fin n, (X i - p)^2\n  let varianceSampleMean := varianceSum / n^2\n  varianceSampleMean = p * (1 - p) / n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  {n : \u2115} (hn : 0 < n) (p : \u211d) (hp : 0 < p \u2227 p < 1) :\n  let X : Fin n \u2192 \u211d := fun _ => p\n  let sampleMean := (1 / (n : \u211d)) * (\u2211 i : Fin n, X i)\n  let varianceSum := \u2211 i : Fin n, (X i - p)^2\n  let varianceSampleMean := varianceSum / n^2\n  varianceSampleMean = p * (1 - p) / n := by\n  intro X sampleMean varianceSum varianceSampleMean\n  have h\u2081 : varianceSum = 0 := by sorry\n  have h\u2082 : varianceSampleMean = 0 := by sorry\n  have h\u2083 : p * (1 - p) / (n : \u211d) > 0 := by sorry\n  -- Now, perhaps we can deduce the original statement by:\n  -- 1. Deduce that if varianceSampleMean = p * (1 - p) / n, then False.\n  -- 2. Use that to deduce the original statement from False.\n  exfalso\n  -- Deduce False:\n  have h\u2084 : False := by sorry\n  -- Deduce the original statement from False:\n  exact False.elim h\u2084", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sample mean definition is correctly translated from natural language to Lean, with appropriate indexing and summation notation.", "The key variance property Var(aY) = a\u00b2Var(Y) mentioned in the natural language is not explicitly represented in the Lean formalization. The general statement Var(X\u0304\u2099) = (1/n\u00b2)Var(\u2211X\u1d62) is also missing, and instead the code jumps to a specific Bernoulli case calculation.", "The Lean formalization is more specific (Bernoulli random variables) than the general variance property discussion in the natural language, though this adds context rather than contradicting the original statement.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sample mean definition is correctly translated from natural language to Lean, with appropriate indexing and summation notation.', 'The key variance property Var(aY) = a\u00b2Var(Y) mentioned in the natural language is not explicitly represented in the Lean formalization. The general statement Var(X\u0304\u2099) = (1/n\u00b2)Var(\u2211X\u1d62) is also missing, and instead the code jumps to a specific Bernoulli case calculation.', 'The Lean formalization is more specific (Bernoulli random variables) than the general variance property discussion in the natural language, though this adds context rather than contradicting the original statement.']"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Combining these properties with the known variance of a Bernoulli variable gives the second solution, $Var(\\bar{X}_n) = \\frac{1}{n^2} \\sum_{i=1}^n p(1-p) = \\frac{1}{n^2} (np(1-p)) = \\frac{p(1-p)}{n}$.", "statement": "We assume:\n\u2022 $Var(\\bar{X}_n) = \\frac{1}{n^2} Var\\left(\\sum_{i=1}^n X_i\\right)$ [l5].\n\u2022 $Var\\left(\\sum_{i=1}^n X_i\\right) = \\sum_{i=1}^n Var(X_i)$ [l4].\n\u2022 For each $X_i$, $Var(X_i) = p(1-p)$ [l2].\nTherefore, we conclude:\n\u2022 $Var(\\bar{X}_n) = \\frac{p(1-p)}{n}$ [ts_2].", "dependencies": ["l2", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  {n : \u2115} (hn : 0 < n) (p : \u211d) (hp : 0 < p \u2227 p < 1) \n  (X : Fin n \u2192 \u211d) \n  (h_bernoulli : \u2200 i, X i = 1 \u2228 X i = 0)\n  (h_indep : \u2200 i j : Fin n, i \u2260 j \u2192 X i * X j = 0 \u2228 X i * X j = 1)\n  (h_prob_p : \u2211 i, X i = n * p)\n  (l2 : \u2200 i, (X i)^2 - (X i)^2 = p * (1 - p))\n  (l4 : (\u2211 i, X i)^2 - (\u2211 i, (X i)^2) = \u2211 i, ((X i)^2 - (X i)^2))\n  (l5 : \u2203 varianceSum, varianceSum = \u2211 i, (X i - p)^2 \u2227 \n    \u2203 varianceSampleMean, varianceSampleMean = varianceSum / n^2) :\n  \u2203 varianceSum, varianceSum = \u2211 i, (X i - p)^2 \u2227 \n    \u2203 varianceSampleMean, varianceSampleMean = varianceSum / n^2 \u2227\n    varianceSampleMean = p * (1 - p) / n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  {n : \u2115} (hn : 0 < n) (p : \u211d) (hp : 0 < p \u2227 p < 1) \n  (X : Fin n \u2192 \u211d) \n  (h_bernoulli : \u2200 i, X i = 1 \u2228 X i = 0)\n  (h_indep : \u2200 i j : Fin n, i \u2260 j \u2192 X i * X j = 0 \u2228 X i * X j = 1)\n  (h_prob_p : \u2211 i, X i = n * p)\n  (l2 : \u2200 i, (X i)^2 - (X i)^2 = p * (1 - p))\n  (l4 : (\u2211 i, X i)^2 - (\u2211 i, (X i)^2) = \u2211 i, ((X i)^2 - (X i)^2))\n  (l5 : \u2203 varianceSum, varianceSum = \u2211 i, (X i - p)^2 \u2227 \n    \u2203 varianceSampleMean, varianceSampleMean = varianceSum / n^2) :\n  \u2203 varianceSum, varianceSum = \u2211 i, (X i - p)^2 \u2227 \n    \u2203 varianceSampleMean, varianceSampleMean = varianceSum / n^2 \u2227\n    varianceSampleMean = p * (1 - p) / n := by\n  have h_contradiction : False := by\n    have h\u2081 : p * (1 - p) = 0 := by\n      have h\u2082 := l2 (\u27e80, by omega\u27e9 : Fin n)\n      have h\u2083 : (X (\u27e80, by omega\u27e9 : Fin n)) ^ 2 - (X (\u27e80, by omega\u27e9 : Fin n)) ^ 2 = 0 := by\n        ring\n      linarith\n    have h\u2084 : 0 < p := hp.1\n    have h\u2085 : p < 1 := hp.2\n    have h\u2086 : 0 < 1 - p := by linarith\n    have h\u2087 : 0 < p * (1 - p) := by\n      nlinarith\n    linarith\n  \n  have h_main : \u2203 varianceSum, varianceSum = \u2211 i, (X i - p)^2 \u2227 \u2203 varianceSampleMean, varianceSampleMean = varianceSum / n^2 \u2227 varianceSampleMean = p * (1 - p) / n := by\n    exfalso\n    exact h_contradiction\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization treats X as deterministic functions rather than random variables, fundamentally changing the mathematical context from probability theory to deterministic arithmetic.", "The variance formulas l2 and l4 are mathematically incorrect - they use expressions like (X i)^2 - (X i)^2 which always equal zero, rather than proper variance calculations involving expectations.", "The independence assumption h_indep uses an incorrect condition that doesn't capture statistical independence of random variables.", "The conclusion maintains the same structural flaws as the premises, working with deterministic expressions rather than proper variance calculations for random variables."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization treats X as deterministic functions rather than random variables, fundamentally changing the mathematical context from probability theory to deterministic arithmetic.', 'The variance formulas l2 and l4 are mathematically incorrect - they use expressions like (X i)^2 - (X i)^2 which always equal zero, rather than proper variance calculations involving expectations.', \"The independence assumption h_indep uses an incorrect condition that doesn't capture statistical independence of random variables.\", 'The conclusion maintains the same structural flaws as the premises, working with deterministic expressions rather than proper variance calculations for random variables.']"}, "solved_negation": null, "type": "solution"}, "ts_3": {"id": "ts_3", "natural_language": "Finally, for the third solution, we take the limit of the variance as $n$ approaches infinity: $\\lim_{n \\to \\infty} Var(\\bar{X}_n) = \\lim_{n \\to \\infty} \\frac{p(1-p)}{n} = 0$.", "statement": "We assume:\n\u2022 $Var(\\bar{X}_n) = \\frac{p(1-p)}{n}$ [ts_2].\n\u2022 $p$ is a constant such that $0 < p < 1$ [tc_1].\nTherefore, we conclude:\n\u2022 $\\lim_{n \\to \\infty} Var(\\bar{X}_n) = 0$ [ts_3].", "dependencies": ["tc_1", "ts_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 \n  (p : \u211d) (hp : 0 < p \u2227 p < 1) :\n  Filter.Tendsto (fun n : \u2115 => p * (1 - p) / n) Filter.atTop (nhds 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 \n  (p : \u211d) (hp : 0 < p \u2227 p < 1) :\n  Filter.Tendsto (fun n : \u2115 => p * (1 - p) / n) Filter.atTop (nhds 0) := by\n  have h_main : Filter.Tendsto (fun n : \u2115 => p * (1 - p) / n) Filter.atTop (nhds 0) := by\n    have h\u2081 : Filter.Tendsto (fun n : \u2115 => (n : \u211d)) Filter.atTop Filter.atTop := tendsto_natCast_atTop_atTop\n    have h\u2082 : Filter.Tendsto (fun n : \u2115 => (p * (1 - p) : \u211d)) Filter.atTop (nhds (p * (1 - p))) := tendsto_const_nhds\n    have h\u2083 : Filter.Tendsto (fun n : \u2115 => (p * (1 - p) : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) :=\n      h\u2082.div_atTop h\u2081\n    -- The function (fun n : \u2115 => p * (1 - p) / n) is exactly the same as (fun n : \u2115 => (p * (1 - p) : \u211d) / (n : \u211d))\n    have h\u2084 : (fun n : \u2115 => p * (1 - p) / n) = (fun n : \u2115 => (p * (1 - p) : \u211d) / (n : \u211d)) := by\n      funext n\n      <;> simp [div_eq_mul_inv]\n      <;> field_simp\n      <;> ring_nf\n      <;> norm_cast\n    rw [h\u2084]\n    exact h\u2083\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variance formula Var(X\u0304_n) = p(1-p)/n is correctly represented as the function (fun n : \u2115 => p * (1 - p) / n)", "The constraint 0 < p < 1 is perfectly captured using logical conjunction (hp : 0 < p \u2227 p < 1)", "The limit statement lim_{n\u2192\u221e} Var(X\u0304_n) = 0 is correctly formalized using Filter.Tendsto with atTop and nhds 0", "The logical structure of assumptions leading to conclusion is preserved through the theorem format with hypotheses and goal"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_3", "label": "ts_3", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    