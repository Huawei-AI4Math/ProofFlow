
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $x\in\R$ and $n\in\N$, then there is a fraction $\ds\frac{a}{b}$
in lowest terms such that $0<b\leq n$ and
$$\left| x - \frac{a}{b} \right| \leq \frac{1}{b(n+1)}.$$

We can assume the following statement(s) without a proof. 

\iprop{convergence of continued fraction}%
Let $a_0,a_1,\ldots$ define a simple continued
fraction, and let $x=[a_0,a_1,\ldots]\in\R$ be its value.
Then for all~$m$,
$$
  \left| x - \frac{p_m}{q_m}\right|
  < \frac{1}{q_m \cdot q_{m+1}}.
$$

Proof: Consider the continued fraction\index{continued fraction}
$[a_0,a_1,\ldots]$ of~$x$.
By Corollary~\ref{cor:cfconv}, for each~$m$
$$
 \left| x - \frac{p_m}{q_m}\right|
  < \frac{1}{q_m \cdot q_{m+1}}.
$$
Since $q_{m+1}\geq q_m + 1$ and $q_0=1$,
either there exists an~$m$ such that $q_m\leq n < q_{m+1}$, or the
continued fraction\index{continued fraction} expansion of~$x$ is finite and $n$ is larger
than the denominator of the rational number~$x$, in which case
we take $\frac{a}{b}=x$ and are done.  In the first
case,
$$
  \left| x - \frac{p_m}{q_m}\right|
   < \frac{1}{q_m \cdot q_{m+1}}
      \leq \frac{1}{q_m \cdot (n+1)},$$
so $\ds\frac{a}{b} = \frac{p_m}{q_m}$ satisfies the conclusion of
the lemma.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $x\\in\\R$ and $n\\in\\N$", "statement": "Premise:\n\u2022 $x \\in \\R$ and $n \\in \\N$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (x : \u211d) (n : \u2115) :\n  \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean header (x : \u211d) correctly captures that x is a real number", "The Lean header (n : \u2115) correctly captures that n is a natural number", "The natural language explicitly states no conclusions are derived in this premise step, but the Lean formalization includes a substantial conclusion about the existence of a rational approximation with specific bounds involving gcd, which is a complete contradiction to the stated premise"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean header (x : \u211d) correctly captures that x is a real number', 'The Lean header (n : \u2115) correctly captures that n is a natural number', 'The natural language explicitly states no conclusions are derived in this premise step, but the Lean formalization includes a substantial conclusion about the existence of a rational approximation with specific bounds involving gcd, which is a complete contradiction to the stated premise']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $a_0,a_1,\\ldots$ define a simple continued fraction, and let $x=[a_0,a_1,\\ldots]\\in\\R$ be its value. Then for all~$m$,\n$$\n  \\left| x - \\frac{p_m}{q_m}\\right|\n  < \\frac{1}{q_m \\cdot q_{m+1}}.\n$$", "statement": "Definition:\n\u2022 For any $x \\in \\R$ with a simple continued fraction expansion $x=[a_0, a_1, \\ldots]$ and convergents $p_m/q_m$, it holds for all $m$ that $|x - p_m/q_m| < 1/(q_m q_{m+1})$ [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (x : \u211d) (a : \u2115 \u2192 \u2115) (p q : \u2115 \u2192 \u2115) \n  (h_q_pos : \u2200 m, 0 < q m)\n  (h_convergents : \u2200 m, (p m : \u211d) / (q m : \u211d) = \n    -- convergents of continued fraction [a\u2080, a\u2081, ..., a\u2098]\n    sorry)\n  (h_expansion : x = -- value of continued fraction [a\u2080, a\u2081, a\u2082, ...]\n    sorry) :\n  \u2200 m, |x - (p m : \u211d) / (q m : \u211d)| < 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The type declaration (x : \u211d) correctly captures that x is a real number", "The continued fraction expansion is properly represented with sequence a : \u2115 \u2192 \u2115 and the expansion hypothesis h_expansion", "The convergents p_m/q_m are correctly formalized as sequences p q : \u2115 \u2192 \u2115 with the convergents hypothesis h_convergents", "The additional constraint h_q_pos : \u2200 m, 0 < q m ensures denominators are positive, which is mathematically necessary but not explicitly stated in natural language - this is acceptable as an extra logical detail", "The universal quantification \u2200 m properly captures 'for all m' from the natural language", "The inequality |x - (p m : \u211d) / (q m : \u211d)| < 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) correctly formalizes the mathematical expression with proper type coercions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "Since $q_{m+1}\\geq q_m + 1$ and $q_0=1$", "statement": "Definition:\n\u2022 The denominators $q_m$ of the convergents of a simple continued fraction are integers satisfying $q_0=1$ and $q_{m+1} > q_m$ for $m \\geq 1$. This implies $(q_m)$ is a strictly increasing sequence of positive integers for $m \\ge 1$ [def_2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (q : \u2115 \u2192 \u2115)\n(q_zero : q 0 = 1)\n(q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n\ntheorem def_2 :\n  (\u2200 m : \u2115, m \u2265 1 \u2192 0 < q m) \u2227 (\u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language specifies q_0=1 and that q_m are integers, but the Lean formalization omits the q_0=1 condition entirely and only addresses positivity for m\u22651. This is a significant omission of a key initial condition.", "The condition q_{m+1} > q_m for m \u2265 1 is perfectly captured by the Lean statement q m < q (m + 1) for m \u2265 1, just with reversed inequality notation.", "The conclusion about strict increasing and positive sequence for m \u2265 1 is perfectly captured by the conjunction of the two Lean statements: positivity (0 < q m) and strict increasing (q m < q (m + 1))."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language specifies q_0=1 and that q_m are integers, but the Lean formalization omits the q_0=1 condition entirely and only addresses positivity for m\u22651. This is a significant omission of a key initial condition.', 'The condition q_{m+1} > q_m for m \u2265 1 is perfectly captured by the Lean statement q m < q (m + 1) for m \u2265 1, just with reversed inequality notation.', 'The conclusion about strict increasing and positive sequence for m \u2265 1 is perfectly captured by the conjunction of the two Lean statements: positivity (0 < q m) and strict increasing (q m < q (m + 1)).']"}, "type": "definition"}, "def_3": {"id": "def_3", "natural_language": "in lowest terms", "statement": "Definition:\n\u2022 The convergents $p_m/q_m$ of a simple continued fraction are always in lowest terms [def_3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\n-- Convergents p_m/q_m of a simple continued fraction\n-- are always in lowest terms\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p q : \u2115 \u2192 \u2115) \n-- p_m and q_m represent the numerator and denominator\n-- of the m-th convergent of some simple continued fraction\ntheorem def_3 (m : \u2115) :\n  Nat.gcd (p m) (q m) = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization doesn't explicitly state that p and q represent convergents of a simple continued fraction in the theorem header. This condition is implicit in the context but not formally declared in the theorem statement itself.", "The Lean conclusion 'Nat.gcd (p m) (q m) = 1' perfectly captures the mathematical meaning of 'in lowest terms' - a fraction is in lowest terms when the greatest common divisor of numerator and denominator is 1."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization doesn't explicitly state that p and q represent convergents of a simple continued fraction in the theorem header. This condition is implicit in the context but not formally declared in the theorem statement itself.\", \"The Lean conclusion 'Nat.gcd (p m) (q m) = 1' perfectly captures the mathematical meaning of 'in lowest terms' - a fraction is in lowest terms when the greatest common divisor of numerator and denominator is 1.\"]"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "either there exists an~$m$ such that $q_m\\leq n < q_{m+1}$, or the continued fraction expansion of~$x$ is finite and $n$ is larger than the denominator of the rational number~$x$", "statement": "We assume:\n\u2022 $x \\in \\R$ and $n \\in \\N$ [tc_1].\n\u2022 The denominators $(q_m)$ of the convergents of the continued fraction of $x$ form a strictly increasing sequence of positive integers (for $m \\ge 1$) [def_2].\nTherefore, we conclude:\n\u2022 One of the following two cases must hold for the continued fraction of $x$:\n  1. The fraction is finite, $x=p_k/q_k$ for some $k$, and $n \\geq q_k$.\n  2. There exists an integer $m \\geq 0$ such that $q_m \\leq n < q_{m+1}$. [l1]", "dependencies": ["tc_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (x : \u211d) (n : \u2115) \n  (q : \u2115 \u2192 \u2115)\n  (q_zero : q 0 = 1)\n  (q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n  (tc_1 : \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)))\n  (def_2 : \u2200 m : \u2115, m \u2265 1 \u2192 0 < q m) :\n  (\u2203 k : \u2115, \u2203 p : \u2124, Int.gcd p (q k) = 1 \u2227 x = (p : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228\n  (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (x : \u211d) (n : \u2115) \n  (q : \u2115 \u2192 \u2115)\n  (q_zero : q 0 = 1)\n  (q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n  (tc_1 : \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)))\n  (def_2 : \u2200 m : \u2115, m \u2265 1 \u2192 0 < q m) :\n  (\u2203 k : \u2115, \u2203 p : \u2124, Int.gcd p (q k) = 1 \u2227 x = (p : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228\n  (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1)) := by\n  have h_n_ge_one : n \u2265 1 := by\n    by_contra h\n    -- Assume n = 0 and derive a contradiction from tc_1\n    have h\u2081 : n = 0 := by\n      omega\n    -- Extract the integers a and b from tc_1\n    obtain \u27e8a, b, h\u2082, h\u2083, h\u2084, h\u2085\u27e9 := tc_1\n    -- Since n = 0, b must be \u2264 0, but b > 0, which is a contradiction\n    have h\u2086 : (b : \u2124) \u2264 0 := by\n      norm_cast at h\u2084 \u22a2\n      <;> simp [h\u2081] at h\u2084 \u22a2 <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2087 : (b : \u2124) > 0 := by exact_mod_cast h\u2083\n    linarith\n  \n  have h_exists_m : \u2203 m : \u2115, q (m + 1) > n := by\n    have h\u2081 : q (n + 1) > n := by\n      have h\u2082 : \u2200 k : \u2115, k \u2265 1 \u2192 q k \u2265 k := by\n        intro k hk\n        induction' hk with k hk IH\n        \u00b7 -- Base case: k = 1\n          have h\u2083 : q 1 \u2265 1 := by\n            have h\u2084 : 0 < q 1 := def_2 1 (by norm_num)\n            have h\u2085 : q 1 \u2265 1 := by\n              omega\n            exact h\u2085\n          omega\n        \u00b7 -- Inductive step: assume the statement holds for k, prove for k + 1\n          have h\u2083 : q (k + 1) > q k := q_increasing k hk\n          have h\u2084 : q (k + 1) \u2265 k + 1 := by\n            have h\u2085 : q (k + 1) > q k := q_increasing k hk\n            have h\u2086 : q k \u2265 k := IH\n            have h\u2087 : q (k + 1) \u2265 q k + 1 := by\n              omega\n            omega\n          omega\n      have h\u2083 : q (n + 1) \u2265 n + 1 := by\n        have h\u2084 : n + 1 \u2265 1 := by omega\n        have h\u2085 : q (n + 1) \u2265 n + 1 := h\u2082 (n + 1) (by omega)\n        exact h\u2085\n      have h\u2084 : (n : \u2115) < n + 1 := by omega\n      have h\u2085 : (q (n + 1) : \u2115) > n := by\n        have h\u2086 : (q (n + 1) : \u2115) \u2265 n + 1 := by\n          exact_mod_cast h\u2083\n        omega\n      exact_mod_cast h\u2085\n    exact \u27e8n, by simpa using h\u2081\u27e9\n  \n  have h_main : (\u2203 k : \u2115, \u2203 p : \u2124, Int.gcd p (q k) = 1 \u2227 x = (p : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228 (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1)) := by\n    classical\n    -- Find the smallest m such that q (m + 1) > n\n    let m := Nat.find h_exists_m\n    have h\u2081 : q (m + 1) > n := Nat.find_spec h_exists_m\n    -- Case distinction on m = 0 or m > 0\n    by_cases hm : m = 0\n    \u00b7 -- Case m = 0\n      have h\u2082 : q 1 > n := by simpa [hm] using h\u2081\n      have h\u2083 : q 0 \u2264 n := by\n        have h\u2084 : q 0 = 1 := q_zero\n        have h\u2085 : (1 : \u2115) \u2264 n := by exact_mod_cast h_n_ge_one\n        linarith\n      -- We have q 0 \u2264 n < q 1\n      have h\u2084 : \u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1) := by\n        refine' \u27e80, _\u27e9\n        constructor <;> simp_all [hm]\n        <;> omega\n      exact Or.inr h\u2084\n    \u00b7 -- Case m > 0\n      have h\u2082 : m > 0 := Nat.pos_of_ne_zero hm\n      have h\u2083 : q m \u2264 n := by\n        by_contra h\u2084\n        -- If q m > n, then m - 1 would be a smaller index with q (m - 1 + 1) > n\n        have h\u2085 : q m > n := by omega\n        have h\u2086 : m - 1 < m := by\n          omega\n        have h\u2087 : q ((m - 1) + 1) > n := by\n          have h\u2088 : (m - 1) + 1 = m := by\n            have h\u2089 : m > 0 := h\u2082\n            omega\n          rw [h\u2088]\n          exact h\u2085\n        have h\u2088 : m - 1 < m := by omega\n        have h\u2089 : m - 1 < m := by omega\n        have h\u2081\u2080 : \u00acq ((m - 1) + 1) > n := by\n          intro h\u2081\u2081\n          have h\u2081\u2082 : m - 1 < m := by omega\n          have h\u2081\u2083 : m - 1 < m := by omega\n          have h\u2081\u2084 : Nat.find h_exists_m \u2264 m - 1 := by\n            apply Nat.find_min'\n            <;> simp_all [Nat.lt_succ_iff]\n            <;> omega\n          omega\n        exact h\u2081\u2080 h\u2087\n      -- We have q m \u2264 n < q (m + 1)\n      have h\u2084 : \u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1) := by\n        refine' \u27e8m, _\u27e9\n        constructor\n        \u00b7 exact h\u2083\n        \u00b7 have h\u2085 : q (m + 1) > n := h\u2081\n          omega\n      exact Or.inr h\u2084\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 49, "column": 10, "endLine": 49, "endColumn": 15, "data": "omega could not prove the goal:\na possible counterexample may satisfy the constraints\n  f \u2265 0\n  e \u2265 0\n  d \u2265 0\n  d - e \u2264 -1\n  d - f \u2265 0\n  c \u2265 0\n  c - d \u2265 0\n  c - e \u2264 -1\n  b \u2265 1\n  a \u2265 1\n  a - b \u2264 0\nwhere\n a := \u22ef.choose\n b := \u2191n\n c := \u2191(q k)\n d := \u2191k\n e := \u2191(q (k + 1))\n f := \u2191(q k.succ)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations (x : \u211d) and (n : \u2115) correctly match the natural language specification.", "The sequence properties are well-captured: q_increasing for strict monotonicity, def_2 for positivity, and q_zero is a reasonable additional constraint for continued fractions.", "The tc_1 condition introduces a rational approximation bound that is completely absent from the natural language. The natural language tc_1 appears to just be a label for the variable assumptions, not a mathematical condition about approximation quality.", "The conclusion correctly captures both cases from the natural language: the finite continued fraction case and the interval condition, with appropriate mathematical details like the gcd condition.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations (x : \u211d) and (n : \u2115) correctly match the natural language specification.', 'The sequence properties are well-captured: q_increasing for strict monotonicity, def_2 for positivity, and q_zero is a reasonable additional constraint for continued fractions.', 'The tc_1 condition introduces a rational approximation bound that is completely absent from the natural language. The natural language tc_1 appears to just be a label for the variable assumptions, not a mathematical condition about approximation quality.', 'The conclusion correctly captures both cases from the natural language: the finite continued fraction case and the interval condition, with appropriate mathematical details like the gcd condition.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "in which case we take $\\frac{a}{b}=x$ and are done.", "statement": "We assume:\n\u2022 $x \\in \\R$ and $n \\in \\N$ [tc_1].\n\u2022 The continued fraction of $x$ is finite, $x=p_k/q_k$ for some $k$, and $n \\geq q_k$ [l1, case 1].\n\u2022 The fraction $p_k/q_k$ is in lowest terms [def_3].\n\u2022 The denominator $q_k$ is a positive integer [def_2].\nTherefore, we conclude:\n\u2022 The fraction $a/b = p_k/q_k$ satisfies the theorem's conditions: it is in lowest terms, $0 < b \\leq n$, and $|x - a/b| \\leq 1/(b(n+1))$ [l2].", "dependencies": ["tc_1", "def_2", "def_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (x : \u211d) (n : \u2115) \n  (p q : \u2115 \u2192 \u2115)\n  (q_zero : q 0 = 1)\n  (q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n  (tc_1 : \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)))\n  (def_2 : \u2200 m : \u2115, m \u2265 1 \u2192 0 < q m)\n  (def_3 : \u2200 m : \u2115, Nat.gcd (p m) (q m) = 1)\n  (l1 : (\u2203 k : \u2115, \u2203 p_k : \u2124, Int.gcd p_k (q k) = 1 \u2227 x = (p_k : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228\n        (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1))) :\n  \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (x : \u211d) (n : \u2115) \n  (p q : \u2115 \u2192 \u2115)\n  (q_zero : q 0 = 1)\n  (q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n  (tc_1 : \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)))\n  (def_2 : \u2200 m : \u2115, m \u2265 1 \u2192 0 < q m)\n  (def_3 : \u2200 m : \u2115, Nat.gcd (p m) (q m) = 1)\n  (l1 : (\u2203 k : \u2115, \u2203 p_k : \u2124, Int.gcd p_k (q k) = 1 \u2227 x = (p_k : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228\n        (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1))) :\n  \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by\n  have h_main : \u2203 (a b : \u2124), Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by\n    obtain \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084\u27e9 := tc_1\n    refine' \u27e8a, b, h\u2081, h\u2082, h\u2083, _\u27e9\n    -- The inequality is already given by h\u2084, so we just need to confirm it.\n    exact h\u2084\n  \n  -- The main statement directly follows from h_main.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The basic type assumptions are correctly captured in Lean, though the natural language incorrectly references [tc_1] for these assumptions when tc_1 actually refers to the conclusion.", "The continued fraction assumption is well captured, with the Lean including the additional lowest terms condition which is logically consistent.", "The lowest terms condition is captured but with minor notational differences (Nat.gcd vs Int.gcd) and scope differences (all m vs specific k).", "The positive denominator condition is correctly captured with appropriate generalization to all relevant indices.", "Major inconsistency: The Lean formalization includes an additional case in l1 (the second disjunct about m, q m \u2264 n \u2227 n < q (m + 1)) that is completely absent from the natural language description. Also, tc_1 in Lean is the conclusion itself, creating a circular reference issue with the natural language description."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The basic type assumptions are correctly captured in Lean, though the natural language incorrectly references [tc_1] for these assumptions when tc_1 actually refers to the conclusion.', 'The continued fraction assumption is well captured, with the Lean including the additional lowest terms condition which is logically consistent.', 'The lowest terms condition is captured but with minor notational differences (Nat.gcd vs Int.gcd) and scope differences (all m vs specific k).', 'The positive denominator condition is correctly captured with appropriate generalization to all relevant indices.', 'Major inconsistency: The Lean formalization includes an additional case in l1 (the second disjunct about m, q m \u2264 n \u2227 n < q (m + 1)) that is completely absent from the natural language description. Also, tc_1 in Lean is the conclusion itself, creating a circular reference issue with the natural language description.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "In the first case, $$  \\left| x - \\frac{p_m}{q_m}\\right|   < \\frac{1}{q_m \\cdot q_{m+1}}      \\leq \\frac{1}{q_m \\cdot (n+1)},$$", "statement": "We assume:\n\u2022 For any $m$, $|x - p_m/q_m| < 1/(q_m q_{m+1})$ [def_1].\n\u2022 There exists an $m$ such that $q_m \\leq n < q_{m+1}$ [l1, case 2].\nTherefore, we conclude:\n\u2022 For that $m$, $|x - p_m/q_m| \\leq 1/(q_m (n+1))$ [l3].", "dependencies": ["def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (x : \u211d) (n : \u2115) (q : \u2115 \u2192 \u2115)\n  (h_convergents : \u2200 m, |x - (q m : \u211d)\u207b\u00b9| < 1 / ((q m : \u211d) * (q (m + 1) : \u211d)))\n  (h_exists : \u2203 m, q m \u2264 n \u2227 n < q (m + 1))\n  (h_q_pos : \u2200 m, 0 < q m) :\n  \u2203 m, q m \u2264 n \u2227 n < q (m + 1) \u2227 |x - (q m : \u211d)\u207b\u00b9| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (x : \u211d) (n : \u2115) (q : \u2115 \u2192 \u2115)\n  (h_convergents : \u2200 m, |x - (q m : \u211d)\u207b\u00b9| < 1 / ((q m : \u211d) * (q (m + 1) : \u211d)))\n  (h_exists : \u2203 m, q m \u2264 n \u2227 n < q (m + 1))\n  (h_q_pos : \u2200 m, 0 < q m) :\n  \u2203 m, q m \u2264 n \u2227 n < q (m + 1) \u2227 |x - (q m : \u211d)\u207b\u00b9| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n  have h_main : \u2203 m, q m \u2264 n \u2227 n < q (m + 1) \u2227 |x - (q m : \u211d)\u207b\u00b9| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n    obtain \u27e8m, hm\u2081, hm\u2082\u27e9 := h_exists\n    have h\u2081 : (n : \u211d) + 1 \u2264 (q (m + 1) : \u211d) := by\n      have h\u2081\u2081 : n + 1 \u2264 q (m + 1) := by\n        have h\u2081\u2082 : n < q (m + 1) := hm\u2082\n        have h\u2081\u2083 : n + 1 \u2264 q (m + 1) := by\n          omega\n        exact h\u2081\u2083\n      exact_mod_cast h\u2081\u2081\n    have h\u2082 : 0 < (q m : \u211d) := by\n      have h\u2082\u2081 : 0 < q m := h_q_pos m\n      exact_mod_cast h\u2082\u2081\n    have h\u2083 : 0 < (q (m + 1) : \u211d) := by\n      have h\u2083\u2081 : 0 < q (m + 1) := h_q_pos (m + 1)\n      exact_mod_cast h\u2083\u2081\n    have h\u2084 : 0 < (n : \u211d) + 1 := by positivity\n    have h\u2085 : (q m : \u211d) * ((n : \u211d) + 1) \u2264 (q m : \u211d) * (q (m + 1) : \u211d) := by\n      have h\u2085\u2081 : (n : \u211d) + 1 \u2264 (q (m + 1) : \u211d) := h\u2081\n      have h\u2085\u2082 : 0 < (q m : \u211d) := h\u2082\n      nlinarith\n    have h\u2086 : 0 < (q m : \u211d) * (q (m + 1) : \u211d) := by positivity\n    have h\u2087 : 0 < (q m : \u211d) * ((n : \u211d) + 1) := by positivity\n    have h\u2088 : 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n      apply one_div_le_one_div_of_le\n      \u00b7 positivity\n      \u00b7 exact h\u2085\n    have h\u2089 : |x - (q m : \u211d)\u207b\u00b9| < 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) := h_convergents m\n    have h\u2081\u2080 : |x - (q m : \u211d)\u207b\u00b9| < 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n      calc\n        |x - (q m : \u211d)\u207b\u00b9| < 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) := h\u2089\n        _ \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := h\u2088\n    have h\u2081\u2081 : |x - (q m : \u211d)\u207b\u00b9| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n      linarith\n    exact \u27e8m, hm\u2081, hm\u2082, h\u2081\u2081\u27e9\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has a major inconsistency with the natural language. The natural language describes convergents p_m/q_m where both p_m and q_m are sequences, but the Lean formalization only includes the q sequence and uses (q m)\u207b\u00b9 instead of p_m/q_m. This suggests the formalization is restricted to the special case where p_m = 1 for all m, which significantly narrows the scope from the general continued fraction convergents described in the natural language. While the logical structure of the assumptions and conclusion is preserved, the missing p_m sequence represents a key mathematical component that is absent from the formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization has a major inconsistency with the natural language. The natural language describes convergents p_m/q_m where both p_m and q_m are sequences, but the Lean formalization only includes the q sequence and uses (q m)\u207b\u00b9 instead of p_m/q_m. This suggests the formalization is restricted to the special case where p_m = 1 for all m, which significantly narrows the scope from the general continued fraction convergents described in the natural language. While the logical structure of the assumptions and conclusion is preserved, the missing p_m sequence represents a key mathematical component that is absent from the formalization.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "so $\\ds\\frac{a}{b} = \\frac{p_m}{q_m}$ satisfies the conclusion of the lemma.", "statement": "We assume:\n\u2022 There exists an $m$ such that $q_m \\leq n < q_{m+1}$ [l1, case 2].\n\u2022 For that $m$, $|x - p_m/q_m| \\leq 1/(q_m (n+1))$ [l3].\n\u2022 The fraction $p_m/q_m$ is in lowest terms [def_3].\n\u2022 The denominator $q_m$ is a positive integer [def_2].\nTherefore, we conclude:\n\u2022 The fraction $a/b = p_m/q_m$ satisfies the theorem's conditions: it is in lowest terms, $0 < b \\leq n$, and $|x - a/b| \\leq 1/(b(n+1))$ [l4].", "dependencies": ["l1", "l3", "def_2", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\n-- We assume that there exists an $m$ such that $q_m \\leq n < q_{m+1}$ [l1, case 2]\n-- For that $m$, $|x - p_m/q_m| \\leq 1/(q_m (n+1))$ [l3]  \n-- The fraction $p_m/q_m$ is in lowest terms [def_3]\n-- The denominator $q_m$ is a positive integer [def_2]\n-- Therefore we conclude that the fraction $p_m/q_m$ satisfies the theorem's conditions\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (x : \u211d) (n : \u2115) (p q : \u2115 \u2192 \u2115) (m : \u2115)\n  (h_exists : q m \u2264 n \u2227 n < q (m + 1))\n  (h_convergent : |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)))\n  (h_lowest_terms : Nat.gcd (p m) (q m) = 1)\n  (h_q_pos : 0 < q m) :\n  Int.gcd (p m) (q m) = 1 \u2227 0 < q m \u2227 q m \u2264 n \u2227 \n    |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (x : \u211d) (n : \u2115) (p q : \u2115 \u2192 \u2115) (m : \u2115)\n  (h_exists : q m \u2264 n \u2227 n < q (m + 1))\n  (h_convergent : |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)))\n  (h_lowest_terms : Nat.gcd (p m) (q m) = 1)\n  (h_q_pos : 0 < q m) :\n  Int.gcd (p m) (q m) = 1 \u2227 0 < q m \u2227 q m \u2264 n \u2227 \n    |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n  have h_int_gcd : Int.gcd (p m) (q m) = 1 := by\n    have h\u2081 : (Int.gcd (p m : \u2124) (q m : \u2124) : \u2115) = Nat.gcd (p m) (q m) := by\n      rw [Int.gcd_eq_natAbs]\n      <;> simp [Int.natAbs_ofNat]\n      <;>\n      norm_cast\n      <;>\n      simp [Nat.gcd_comm]\n    have h\u2082 : (Int.gcd (p m : \u2124) (q m : \u2124) : \u2115) = 1 := by\n      rw [h\u2081]\n      <;> simp [h_lowest_terms]\n    have h\u2083 : Int.gcd (p m : \u2124) (q m : \u2124) = 1 := by\n      norm_cast at h\u2082 \u22a2\n      <;> simp_all\n    simpa using h\u2083\n  \n  have h_q_le_n : q m \u2264 n := by\n    have h\u2081 : q m \u2264 n := h_exists.1\n    exact h\u2081\n  \n  have h_main : Int.gcd (p m) (q m) = 1 \u2227 0 < q m \u2227 q m \u2264 n \u2227 |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n    refine' \u27e8h_int_gcd, _, h_q_le_n, _\u27e9\n    \u00b7 -- Prove 0 < q m\n      exact by\n        exact_mod_cast h_q_pos\n    \u00b7 -- Prove the inequality involving x\n      exact h_convergent\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The existence condition is correctly captured as a hypothesis about a specific m, which is appropriate for theorem statement structure.", "The convergent property is perfectly translated with proper type coercions from natural numbers to reals.", "The lowest terms condition is correctly expressed using Nat.gcd = 1.", "The positive denominator condition is correctly expressed as 0 < q m.", "The conclusion correctly captures all required conditions, but uses Int.gcd instead of Nat.gcd, creating a minor type inconsistency with the hypothesis h_lowest_terms which uses Nat.gcd."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "either there exists an~$m$ such that $q_m\\leq n < q_{m+1}$, or the continued fraction... is finite... in which case we take $\\frac{a}{b}=x$ and are done. In the first case..., so... satisfies the conclusion...", "statement": "We assume:\n\u2022 For a given $x \\in \\R$ and $n \\in \\N$, one of two cases holds: (1) $x$ has a finite continued fraction $p_k/q_k$ with $n \\ge q_k$, or (2) there exists an $m$ with $q_m \\le n < q_{m+1}$ [l1].\n\u2022 In case (1), there exists a fraction satisfying the theorem's conditions [l2].\n\u2022 In case (2), there exists a fraction satisfying the theorem's conditions [l4].\nTherefore, we conclude:\n\u2022 There is a fraction $a/b$ in lowest terms such that $0 < b \\le n$ and $|x - a/b| \\le 1/(b(n+1))$ [ts_1].", "dependencies": ["l1", "l2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (x : \u211d) (n : \u2115) (p q : \u2115 \u2192 \u2115) \n  (h_convergents : \u2200 m : \u2115, |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * (q (m + 1) : \u211d)))\n  (h_q_zero : q 0 = 1)\n  (h_q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n  (h_q_positive : \u2200 m : \u2115, 0 < q m)\n  (h_gcd : \u2200 m : \u2115, Nat.gcd (p m) (q m) = 1)\n  (h_exists : (\u2203 k : \u2115, \u2203 p_k : \u2124, Int.gcd p_k (q k) = 1 \u2227 x = (p_k : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228\n              (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1))) :\n  \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (x : \u211d) (n : \u2115) (p q : \u2115 \u2192 \u2115) \n  (h_convergents : \u2200 m : \u2115, |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * (q (m + 1) : \u211d)))\n  (h_q_zero : q 0 = 1)\n  (h_q_increasing : \u2200 m : \u2115, m \u2265 1 \u2192 q m < q (m + 1))\n  (h_q_positive : \u2200 m : \u2115, 0 < q m)\n  (h_gcd : \u2200 m : \u2115, Nat.gcd (p m) (q m) = 1)\n  (h_exists : (\u2203 k : \u2115, \u2203 p_k : \u2124, Int.gcd p_k (q k) = 1 \u2227 x = (p_k : \u211d) / (q k : \u211d) \u2227 n \u2265 q k) \u2228\n              (\u2203 m : \u2115, q m \u2264 n \u2227 n < q (m + 1))) :\n  \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 \n    abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by\n  have h_main : \u2203 a b : \u2124, Int.gcd a b = 1 \u2227 0 < b \u2227 b \u2264 n \u2227 abs (x - (a : \u211d) / (b : \u211d)) \u2264 1 / ((b : \u211d) * ((n : \u211d) + 1)) := by\n    cases h_exists with\n    | inl h_exists_case1 =>\n      -- Case 1: x is exactly equal to some p_k / q_k with q_k \u2264 n\n      obtain \u27e8k, p_k, h_gcd_k, h_x_eq, h_q_k_le_n\u27e9 := h_exists_case1\n      have h_b_pos : 0 < (q k : \u2124) := by\n        have h : 0 < q k := h_q_positive k\n        exact_mod_cast h\n      have h_b_le_n : (q k : \u2124) \u2264 n := by\n        exact_mod_cast h_q_k_le_n\n      refine' \u27e8p_k, (q k : \u2124), h_gcd_k, by positivity, _, _\u27e9\n      \u00b7 -- Prove that (q k : \u2124) \u2264 n\n        exact_mod_cast h_q_k_le_n\n      \u00b7 -- Prove the inequality |x - p_k / q_k| \u2264 1 / (q_k * (n + 1))\n        have h\u2081 : x = (p_k : \u211d) / (q k : \u211d) := by\n          simpa using h_x_eq\n        have h\u2082 : abs (x - (p_k : \u211d) / (q k : \u211d)) = 0 := by\n          rw [h\u2081]\n          simp [abs_of_nonneg]\n          <;> positivity\n        have h\u2083 : (0 : \u211d) \u2264 1 / ((q k : \u211d) * ((n : \u211d) + 1)) := by positivity\n        have h\u2084 : abs (x - (p_k : \u211d) / (q k : \u211d)) \u2264 1 / ((q k : \u211d) * ((n : \u211d) + 1)) := by\n          rw [h\u2082]\n          <;> linarith\n        -- Convert the inequality to use (p_k : \u211d) / (q k : \u211d)\n        have h\u2085 : abs (x - (p_k : \u211d) / (q k : \u211d)) = abs (x - (p_k : \u211d) / (q k : \u211d)) := rfl\n        -- Cast the inequality to use (p_k : \u2124) and (q k : \u2124)\n        have h\u2086 : abs (x - (p_k : \u211d) / (q k : \u211d)) = abs (x - (p_k : \u211d) / (q k : \u211d)) := rfl\n        -- Use the fact that (p_k : \u211d) / (q k : \u211d) = (p_k : \u211d) / (q k : \u211d)\n        have h\u2087 : (p_k : \u211d) / (q k : \u211d) = (p_k : \u211d) / (q k : \u211d) := rfl\n        -- Convert the inequality to use (p_k : \u2124) and (q k : \u2124)\n        simpa [h\u2081] using h\u2084\n    | inr h_exists_case2 =>\n      -- Case 2: There exists m such that q_m \u2264 n < q_{m+1}\n      obtain \u27e8m, hq_m_le_n, hn_lt_q_m1\u27e9 := h_exists_case2\n      have h\u2081 : |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) := h_convergents m\n      have h\u2082 : (q (m + 1) : \u2115) \u2265 n + 1 := by\n        have h\u2083 : n < q (m + 1) := by exact_mod_cast hn_lt_q_m1\n        have h\u2084 : (n : \u2115) + 1 \u2264 q (m + 1) := by\n          omega\n        exact_mod_cast h\u2084\n      have h\u2083 : (q m : \u211d) > 0 := by\n        have h\u2084 : 0 < q m := h_q_positive m\n        exact_mod_cast h\u2084\n      have h\u2084 : (q (m + 1) : \u211d) \u2265 (n : \u211d) + 1 := by\n        have h\u2085 : (q (m + 1) : \u2115) \u2265 n + 1 := h\u2082\n        have h\u2086 : (q (m + 1) : \u211d) \u2265 (n : \u211d) + 1 := by\n          have h\u2087 : (q (m + 1) : \u211d) = (q (m + 1) : \u2115) := by norm_cast\n          rw [h\u2087]\n          norm_cast at h\u2085 \u22a2\n          <;>\n          (try norm_num) <;>\n          (try linarith)\n        exact h\u2086\n      have h\u2085 : 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n        have h\u2086 : 0 < (q m : \u211d) := by positivity\n        have h\u2087 : 0 < (q (m + 1) : \u211d) := by\n          have h\u2088 : 0 < q (m + 1) := h_q_positive (m + 1)\n          exact_mod_cast h\u2088\n        have h\u2088 : 0 < (n : \u211d) + 1 := by positivity\n        have h\u2089 : 0 < (q m : \u211d) * (q (m + 1) : \u211d) := by positivity\n        have h\u2081\u2080 : 0 < (q m : \u211d) * ((n : \u211d) + 1) := by positivity\n        -- Use the fact that q (m + 1) \u2265 n + 1 to compare denominators\n        have h\u2081\u2081 : (q (m + 1) : \u211d) \u2265 (n : \u211d) + 1 := h\u2084\n        have h\u2081\u2082 : (q m : \u211d) * (q (m + 1) : \u211d) \u2265 (q m : \u211d) * ((n : \u211d) + 1) := by\n          nlinarith\n        -- Use the fact that the denominator on the LHS is larger to compare the fractions\n        have h\u2081\u2083 : 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n          apply one_div_le_one_div_of_le\n          \u00b7 positivity\n          \u00b7 nlinarith\n        exact h\u2081\u2083\n      have h\u2086 : abs (x - (p m : \u211d) / (q m : \u211d)) \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := by\n        calc\n          abs (x - (p m : \u211d) / (q m : \u211d)) \u2264 1 / ((q m : \u211d) * (q (m + 1) : \u211d)) := h\u2081\n          _ \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := h\u2085\n      have h\u2087 : 0 < (q m : \u2124) := by\n        have h\u2088 : 0 < q m := h_q_positive m\n        exact_mod_cast h\u2088\n      have h\u2088 : (q m : \u2124) \u2264 n := by\n        exact_mod_cast hq_m_le_n\n      have h\u2089 : Int.gcd (p m : \u2124) (q m : \u2124) = 1 := by\n        have h\u2081\u2080 : Nat.gcd (p m) (q m) = 1 := h_gcd m\n        have h\u2081\u2081 : Int.gcd (p m : \u2124) (q m : \u2124) = Nat.gcd (p m) (q m) := by\n          rw [Int.gcd_eq_natAbs]\n          <;> simp [Int.natAbs_ofNat]\n          <;> norm_cast\n          <;> simp [Nat.gcd_comm]\n        rw [h\u2081\u2081]\n        <;> exact_mod_cast h\u2081\u2080\n      refine' \u27e8(p m : \u2124), (q m : \u2124), h\u2089, by positivity, _, _\u27e9\n      \u00b7 -- Prove that (q m : \u2124) \u2264 n\n        exact_mod_cast hq_m_le_n\n      \u00b7 -- Prove the inequality |x - (p m : \u211d) / (q m : \u211d)| \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1))\n        have h\u2081\u2080 : abs (x - (p m : \u211d) / (q m : \u211d)) \u2264 1 / ((q m : \u211d) * ((n : \u211d) + 1)) := h\u2086\n        have h\u2081\u2081 : abs (x - ((p m : \u2124) : \u211d) / ((q m : \u2124) : \u211d)) = abs (x - (p m : \u211d) / (q m : \u211d)) := by\n          norm_cast\n          <;> field_simp\n          <;> ring_nf\n          <;> norm_cast\n          <;> simp [div_eq_mul_inv]\n          <;> ring_nf\n          <;> norm_cast\n        rw [h\u2081\u2081] at *\n        have h\u2081\u2082 : (1 : \u211d) / ((q m : \u211d) * ((n : \u211d) + 1)) = 1 / (((q m : \u2124) : \u211d) * ((n : \u211d) + 1)) := by\n          norm_cast\n          <;> field_simp\n          <;> ring_nf\n          <;> norm_cast\n        rw [h\u2081\u2082] at h\u2081\u2080\n        simpa [h\u2081\u2081, h\u2081\u2082] using h\u2081\u2080\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The case analysis structure is correctly captured as a disjunction in the Lean formalization", "Case 1 is properly formalized with the existence of a terminating continued fraction, including the gcd condition for lowest terms", "Case 2 correctly captures the intermediate convergent condition with the proper inequality bounds", "The conclusion structure properly uses existential quantification for integers a and b with the gcd condition", "The denominator constraints are correctly translated with proper type coercions", "The approximation inequality is accurately formalized with appropriate absolute value and arithmetic operations", "The additional hypotheses about convergents properties (h_convergents, h_q_zero, etc.) are standard assumptions in continued fraction theory and provide necessary context without contradicting the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    