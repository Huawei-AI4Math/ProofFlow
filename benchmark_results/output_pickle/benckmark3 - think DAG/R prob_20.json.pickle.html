
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $X_1$ and $X_2$ are independent random variables from exponential distributions with parameters $\lambda_1$ and $\lambda_2$ respectively, then $P(X_1 < X_2) = \frac{\lambda_1}{\lambda_1 + \lambda_2}$.

Proof: To compute $P(X_1 < X_2)$, we can use conditioning on $X_1$. This gives $P(X_1 < X_2) = E[P(X_1 < X_2 | X_1)]$. By independence, $P(X_1 < X_2 | X_1 = x) = P(x < X_2)$. The cumulative distribution function of $X_2$ is $F_{X_2}(x) = 1 - e^{-\lambda_2 x}$, so the survival function is $P(X_2 > x) = 1 - F_{X_2}(x) = e^{-\lambda_2 x}$. The probability density function of $X_1$ is $f_{X_1}(x) = \lambda_1 e^{-\lambda_1 x}$. Therefore, $P(X_1 < X_2) = \int_0^{\infty} P(X_2 > x) f_{X_1}(x) dx = \int_0^{\infty} e^{-\lambda_2 x} (\lambda_1 e^{-\lambda_1 x}) dx = \int_0^{\infty} \lambda_1 e^{-(\lambda_1 + \lambda_2)x} dx$. Evaluating this integral gives $\frac{\lambda_1}{\lambda_1 + \lambda_2}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $X_1$ and $X_2$ are independent random variables from exponential distributions with parameters $\\lambda_1$ and $\\lambda_2$ respectively", "statement": "Premise:\n\u2022 $X_1$ and $X_2$ are independent random variables, with $X_1$ following an exponential distribution with parameter $\\lambda_1 > 0$ and $X_2$ following an exponential distribution with parameter $\\lambda_2 > 0$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1\n  (\u03bb\u2081 \u03bb\u2082 : \u211d) (h\u03bb\u2081 : 0 < \u03bb\u2081) (h\u03bb\u2082 : 0 < \u03bb\u2082) :\n  let f\u2081 := fun x => if x \u2265 0 then \u03bb\u2081 * Real.exp (-\u03bb\u2081 * x) else 0\n  let f\u2082 := fun x => if x \u2265 0 then \u03bb\u2082 * Real.exp (-\u03bb\u2082 * x) else 0\n  (\u222b x\u2081 in Set.Ici 0, \u222b x\u2082 in Set.Ici x\u2081, f\u2081 x\u2081 * f\u2082 x\u2082) = \n  \u03bb\u2081 / (\u03bb\u2081 + \u03bb\u2082) := by sorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 3, "endLine": 8, "endColumn": 4, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "To compute $P(X_1 < X_2)$, we can use conditioning on $X_1$. This gives $P(X_1 < X_2) = E[P(X_1 < X_2 | X_1)]$.", "statement": "We assume:\n\u2022 $X_1$ is a continuous random variable with a probability density function $f_{X_1}(x)$ and support on $[0, \\infty)$ (from $X_1 \\sim \\text{Exp}(\\lambda_1)$) [tc_1].\nTherefore, we conclude:\n\u2022 The probability $P(X_1 < X_2)$ can be expressed using the law of total probability as an integral: $P(X_1 < X_2) = \\int_0^{\\infty} P(X_1 < X_2|X_1=x) f_{X_1}(x) dx$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (\u03bb\u2081 \u03bb\u2082 : \u211d) (h\u03bb\u2081 : 0 < \u03bb\u2081) (h\u03bb\u2082 : 0 < \u03bb\u2082) :\n  -- For independent exponential random variables X\u2081 ~ Exp(\u03bb\u2081) and X\u2082 ~ Exp(\u03bb\u2082),\n  -- P(X\u2081 < X\u2082) = \u222b\u2080^\u221e P(X\u2082 > x) * f\u2081(x) dx\n  -- where f\u2081(x) = \u03bb\u2081 * exp(-\u03bb\u2081 * x) is the PDF of X\u2081\n  -- and P(X\u2082 > x) = exp(-\u03bb\u2082 * x) is the survival function of X\u2082\n  (\u222b x in Set.Ici 0, Real.exp (-\u03bb\u2082 * x) * (\u03bb\u2081 * Real.exp (-\u03bb\u2081 * x))) = \u03bb\u2081 / (\u03bb\u2081 + \u03bb\u2082) := by sorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 12, "endLine": 7, "endColumn": 13, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (\u03bb\u2081 \u03bb\u2082 : \u211d) (h\u03bb\u2081 : 0 < \u03bb\u2081) (h\u03bb\u2082 : 0 < \u03bb\u2082) :\n  (\u222b x in Set.Ici 0, Real.exp (-\u03bb\u2082 * x) * (\u03bb\u2081 * Real.exp (-\u03bb\u2081 * x))) = \u03bb\u2081 / (\u03bb\u2081 + \u03bb\u2082) := by\n  have h_combine_exponent : (\u222b x in Set.Ici 0, Real.exp (-\u03bb\u2082 * x) * (\u03bb\u2081 * Real.exp (-\u03bb\u2081 * x))) = (\u222b x in Set.Ici 0, \u03bb\u2081 * Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by\n    have h1 : (\u222b x in Set.Ici 0, Real.exp (-\u03bb\u2082 * x) * (\u03bb\u2081 * Real.exp (-\u03bb\u2081 * x))) = \u222b x in Set.Ici 0, (\u03bb\u2081 * (Real.exp (-\u03bb\u2082 * x) * Real.exp (-\u03bb\u2081 * x))) := by\n      congr\n      ext x\n      ring_nf\n      <;> field_simp [Real.exp_neg]\n      <;> ring_nf\n    rw [h1]\n    have h2 : (\u222b x in Set.Ici 0, (\u03bb\u2081 * (Real.exp (-\u03bb\u2082 * x) * Real.exp (-\u03bb\u2081 * x)))) = \u222b x in Set.Ici 0, (\u03bb\u2081 * Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by\n      congr\n      ext x\n      have h3 : Real.exp (-\u03bb\u2082 * x) * Real.exp (-\u03bb\u2081 * x) = Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) := by\n        have h4 : Real.exp (-\u03bb\u2082 * x) * Real.exp (-\u03bb\u2081 * x) = Real.exp (-\u03bb\u2082 * x + -\u03bb\u2081 * x) := by\n          rw [\u2190 Real.exp_add]\n        rw [h4]\n        have h5 : -\u03bb\u2082 * x + -\u03bb\u2081 * x = -(\u03bb\u2081 + \u03bb\u2082) * x := by\n          ring\n        rw [h5]\n        <;>\n        simp [Real.exp_neg]\n        <;>\n        ring_nf\n      rw [h3]\n      <;>\n      ring_nf\n    rw [h2]\n    <;>\n    simp [mul_assoc]\n  \n  have h_factor_out_lambda : (\u222b x in Set.Ici 0, \u03bb\u2081 * Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) = \u03bb\u2081 * (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by\n    have h\u2081 : (\u222b x in Set.Ici 0, \u03bb\u2081 * Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) = \u03bb\u2081 * (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by\n      -- Use the property of integrals to factor out constants\n      have h\u2082 : (\u222b x in Set.Ici 0, \u03bb\u2081 * Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) = \u03bb\u2081 * (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by\n        -- Use the fact that \u03bb\u2081 is a constant and can be factored out of the integral\n        simp [intervalIntegral.integral_comp_mul_left (fun x => Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x))]\n        <;>\n        (try simp_all [mul_comm]) <;>\n        (try norm_num) <;>\n        (try ring_nf) <;>\n        (try field_simp [h\u03bb\u2081.ne', h\u03bb\u2082.ne', add_pos h\u03bb\u2081 h\u03bb\u2082]) <;>\n        (try norm_num) <;>\n        (try linarith)\n        <;>\n        (try\n          {\n            apply intervalIntegral.integral_congr\n            <;>\n            intro x <;>\n            simp [mul_assoc] <;>\n            ring_nf <;>\n            field_simp [h\u03bb\u2081.ne', h\u03bb\u2082.ne', add_pos h\u03bb\u2081 h\u03bb\u2082] <;>\n            ring_nf <;>\n            linarith\n          })\n      exact h\u2082\n    exact h\u2081\n  \n  have h_sum_pos : 0 < \u03bb\u2081 + \u03bb\u2082 := by\n    linarith\n  \n  have h_integral_result : (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) = 1 / (\u03bb\u2081 + \u03bb\u2082) := by\n    have h\u2081 : (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) = 1 / (\u03bb\u2081 + \u03bb\u2082) := by\n      have h\u2082 : \u222b x in Set.Ici (0 : \u211d), Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) := by\n        simp [MeasureTheory.integral_Ici_eq_integral_Ioi]\n        <;>\n        simp_all [Real.volume_Ioi]\n        <;>\n        congr 1 <;> ext <;> simp [Set.mem_Ioi]\n        <;>\n        simp_all [Real.volume_Ioi]\n        <;>\n        linarith\n      rw [h\u2082]\n      have h\u2083 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = 1 / (\u03bb\u2081 + \u03bb\u2082) := by\n        have h\u2084 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = 1 / (\u03bb\u2081 + \u03bb\u2082) := by\n          -- Use the fundamental theorem of calculus to evaluate the integral\n          have h\u2085 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) := rfl\n          rw [h\u2085]\n          -- Use the fact that the integral of exp(-kx) from 0 to infinity is 1/k\n          have h\u2086 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = 1 / (\u03bb\u2081 + \u03bb\u2082) := by\n            -- Use the fundamental theorem of calculus to evaluate the integral\n            have h\u2087 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = (1 / (\u03bb\u2081 + \u03bb\u2082)) := by\n              -- Use the fact that the integral of exp(-kx) from 0 to infinity is 1/k\n              have h\u2088 : 0 < (\u03bb\u2081 + \u03bb\u2082 : \u211d) := by linarith\n              have h\u2089 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = (1 / (\u03bb\u2081 + \u03bb\u2082)) := by\n                -- Use the fundamental theorem of calculus to evaluate the integral\n                have h\u2081\u2080 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = (1 / (\u03bb\u2081 + \u03bb\u2082)) := by\n                  -- Use the fact that the integral of exp(-kx) from 0 to infinity is 1/k\n                  have h\u2081\u2081 : \u222b x in (0 : \u211d)..\u221e, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x) = (1 / (\u03bb\u2081 + \u03bb\u2082)) := by\n                    -- Use the fundamental theorem of calculus to evaluate the integral\n                    rw [integral_exp_neg_mul_Ioi (by positivity)]\n                    <;> field_simp [h\u2088.ne']\n                    <;> ring_nf\n                    <;> norm_num\n                    <;> linarith\n                  exact h\u2081\u2081\n                exact h\u2081\u2080\n              exact h\u2089\n            rw [h\u2087]\n          rw [h\u2086]\n        rw [h\u2084]\n      rw [h\u2083]\n    rw [h\u2081]\n  \n  have h_final_calc : \u03bb\u2081 * (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) = \u03bb\u2081 / (\u03bb\u2081 + \u03bb\u2082) := by\n    rw [h_integral_result]\n    <;> field_simp [h_sum_pos.ne']\n    <;> ring\n    <;> field_simp [h_sum_pos.ne']\n    <;> ring\n  \n  have h_main : (\u222b x in Set.Ici 0, Real.exp (-\u03bb\u2082 * x) * (\u03bb\u2081 * Real.exp (-\u03bb\u2081 * x))) = \u03bb\u2081 / (\u03bb\u2081 + \u03bb\u2082) := by\n    calc\n      (\u222b x in Set.Ici 0, Real.exp (-\u03bb\u2082 * x) * (\u03bb\u2081 * Real.exp (-\u03bb\u2081 * x))) = (\u222b x in Set.Ici 0, \u03bb\u2081 * Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by rw [h_combine_exponent]\n      _ = \u03bb\u2081 * (\u222b x in Set.Ici 0, Real.exp (-(\u03bb\u2081 + \u03bb\u2082) * x)) := by rw [h_factor_out_lambda]\n      _ = \u03bb\u2081 / (\u03bb\u2081 + \u03bb\u2082) := by rw [h_final_calc]\n  \n  rw [h_main]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 4, "column": 12, "endLine": 4, "endColumn": 13, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By independence, $P(X_1 < X_2 | X_1 = x) = P(x < X_2)$.", "statement": "We assume:\n\u2022 $X_1$ and $X_2$ are independent random variables [tc_1].\nTherefore, we conclude:\n\u2022 The conditional probability $P(X_1 < X_2 | X_1 = x)$ simplifies to $P(x < X_2)$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (\u03bb\u2081 \u03bb\u2082 : \u211d) (h\u03bb\u2081 : 0 < \u03bb\u2081) (h\u03bb\u2082 : 0 < \u03bb\u2082) :\n  \u2200 x : \u211d, 0 \u2264 x \u2192 \n    \u222b t in Set.Ici x, \u03bb\u2082 * Real.exp (-\u03bb\u2082 * t) = \n    Real.exp (-\u03bb\u2082 * x) := by sorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 3, "endLine": 8, "endColumn": 4, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (l1 l2 : \u211d) (hl1 : 0 < l1) (hl2 : 0 < l2) :\n  \u2200 x : \u211d, 0 \u2264 x \u2192 \n    \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \n    Real.exp (-l2 * x) := by\n  intro x hx\n  have h_cont : Continuous (fun t : \u211d => l2 * Real.exp (-l2 * t)) := by\n    apply Continuous.mul\n    \u00b7 exact continuous_const\n    \u00b7 apply Continuous.exp\n      exact Continuous.neg (Continuous.mul continuous_const continuous_id)\n  \n  have h_interv : IntervalIntegrable (fun t : \u211d => l2 * Real.exp (-l2 * t)) volume (-\u221e) x := by\n    have h\u2081 : Continuous (fun t : \u211d => l2 * Real.exp (-l2 * t)) := h_cont\n    -- Use the fact that a continuous function is interval integrable on any interval\n    have h\u2082 : IntervalIntegrable (fun t : \u211d => l2 * Real.exp (-l2 * t)) volume (-\u221e) x := by\n      apply Continuous.intervalIntegrable\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try assumption) <;>\n      (try\n        {\n          simp_all [h\u2081]\n          <;>\n          (try norm_num)\n          <;>\n          (try linarith)\n        })\n      <;>\n      (try\n        {\n          exact h\u2081\n        })\n    exact h\u2082\n  \n  have h_integral_eq : \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) := by\n    have h\u2081 : \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) := by\n      -- Use the lemma `integral_Ici_eq_integral_Ioi` to equate the integrals over `Set.Ici x` and `Set.Ioi x`\n      have h\u2082 : \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) := by\n        -- Apply the lemma `integral_Ici_eq_integral_Ioi`\n        have h\u2083 : IntervalIntegrable (fun t : \u211d => l2 * Real.exp (-l2 * t)) volume (-\u221e) x := h_interv\n        have h\u2084 : \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) := by\n          -- Use the lemma `integral_Ici_eq_integral_Ioi`\n          have h\u2085 : \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) := by\n            apply integral_Ici_eq_integral_Ioi\n            <;>\n            (try\n              {\n                exact h_interv\n              })\n            <;>\n            (try\n              {\n                apply Continuous.intervalIntegrable\n                <;>\n                (try continuity)\n              })\n          exact h\u2085\n        exact h\u2084\n      exact h\u2082\n    exact h\u2081\n  \n  have h_integral_Ioi : \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) = Real.exp (-l2 * x) := by\n    have h\u2081 : \u222b (t : \u211d) in Set.Ioi x, l2 * Real.exp (-l2 * t) = Real.exp (-l2 * x) := by\n      -- Use the known result about the integral of the exponential function over (x, \u221e)\n      have h\u2082 : \u222b (t : \u211d) in Set.Ioi x, l2 * Real.exp (-l2 * t) = Real.exp (-l2 * x) := by\n        -- Use the lemma `integral_exp_neg_mul_Ioi` from the library\n        have h\u2083 : \u222b (t : \u211d) in Set.Ioi x, l2 * Real.exp (-l2 * t) = Real.exp (-l2 * x) := by\n          -- Apply the lemma with the given parameters\n          have h\u2084 : 0 < l2 := hl2\n          -- Use the lemma `integral_exp_neg_mul_Ioi`\n          have h\u2085 : \u222b (t : \u211d) in Set.Ioi x, l2 * Real.exp (-l2 * t) = Real.exp (-l2 * x) := by\n            -- Use the lemma `integral_exp_neg_mul_Ioi`\n            simpa using integral_exp_neg_mul_Ioi hl2 x\n          exact h\u2085\n        exact h\u2083\n      exact h\u2082\n    exact h\u2081\n  \n  have h_main : \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = Real.exp (-l2 * x) := by\n    calc\n      \u222b t in Set.Ici x, l2 * Real.exp (-l2 * t) = \u222b t in Set.Ioi x, l2 * Real.exp (-l2 * t) := by rw [h_integral_eq]\n      _ = Real.exp (-l2 * x) := by rw [h_integral_Ioi]\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "The cumulative distribution function of $X_2$ is $F_{X_2}(x) = 1 - e^{-\\lambda_2 x}$, so the survival function is $P(X_2 > x) = 1 - F_{X_2}(x) = e^{-\\lambda_2 x}$.", "statement": "We assume:\n\u2022 $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ [tc_1].\nTherefore, we conclude:\n\u2022 The survival function of $X_2$ is $P(X_2 > x) = e^{-\\lambda_2 x}$ for $x \\ge 0$ [l3].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (\u03bb\u2082 : \u211d) (h\u03bb\u2082 : \u03bb\u2082 > 0) :\n  \u2200 x : \u211d, x \u2265 0 \u2192 \n    \u222b t in Set.Ici x, \u03bb\u2082 * Real.exp (-\u03bb\u2082 * t) = Real.exp (-\u03bb\u2082 * x) := by sorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 3, "endLine": 8, "endColumn": 4, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (lambda\u2082 : \u211d) (hlambda\u2082 : lambda\u2082 > 0) :\n  \u2200 x : \u211d, x \u2265 0 \u2192 \n    \u222b t in Set.Ici x, lambda\u2082 * Real.exp (-lambda\u2082 * t) = Real.exp (-lambda\u2082 * x) := by\n  intro x hx\n  have h_main : \u222b t in Set.Ici x, lambda\u2082 * Real.exp (-lambda\u2082 * t) = Real.exp (-lambda\u2082 * x) := by\n    have h\u2081 : \u222b (t : \u211d) in Set.Ici x, lambda\u2082 * Real.exp (-lambda\u2082 * t) = Real.exp (-lambda\u2082 * x) := by\n      have h\u2082 : \u222b (t : \u211d) in x..\u221e, lambda\u2082 * Real.exp (-lambda\u2082 * t) = Real.exp (-lambda\u2082 * x) := by\n        -- Use the fundamental theorem of calculus to compute the integral from x to \u221e\n        have h\u2083 : \u222b (t : \u211d) in x..\u221e, lambda\u2082 * Real.exp (-lambda\u2082 * t) = Real.exp (-lambda\u2082 * x) := by\n          -- Simplify the integral using the antiderivative of the integrand\n          simp [intervalIntegral.integral_comp_mul_left (fun x => Real.exp (-x)),\n            Real.exp_neg, mul_comm lambda\u2082]\n          <;>\n            field_simp [hlambda\u2082.ne', Real.exp_neg] <;>\n            ring_nf <;>\n            norm_num <;>\n            simp_all [Real.exp_neg, Real.exp_log] <;>\n            linarith\n        -- The result follows directly from the simplification\n        exact h\u2083\n      -- Relate the integral over Set.Ici x to the integral from x to \u221e\n      have h\u2084 : \u222b (t : \u211d) in Set.Ici x, lambda\u2082 * Real.exp (-lambda\u2082 * t) = \u222b (t : \u211d) in x..\u221e, lambda\u2082 * Real.exp (-lambda\u2082 * t) := by\n        -- Use the fact that the integral over Set.Ici x is the same as the integral from x to \u221e\n        simp [MeasureTheory.integral_Ici_eq_integral_Ioi, intervalIntegral.integral_of_le (by linarith : (x : \u211d) \u2264 \u221e)]\n        <;>\n          simp_all [Set.Ioi, Set.Ici]\n        <;>\n          linarith\n      -- Combine the results to get the final answer\n      rw [h\u2084]\n      rw [h\u2082]\n    -- The final result follows from the established equality\n    exact h\u2081\n  -- The main statement follows directly from the established result\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "The probability density function of $X_1$ is $f_{X_1}(x) = \\lambda_1 e^{-\\lambda_1 x}$.", "statement": "We assume:\n\u2022 $X_1$ follows an exponential distribution with parameter $\\lambda_1 > 0$ [tc_1].\nTherefore, we conclude:\n\u2022 The probability density function (PDF) of $X_1$ is $f_{X_1}(x) = \\lambda_1 e^{-\\lambda_1 x}$ for $x \\ge 0$ [l4].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (\u03b1 : \u211d) (h\u03b1 : \u03b1 > 0) :\n  let f : \u211d \u2192 \u211d := fun x => if x \u2265 0 then \u03b1 * Real.exp (-\u03b1 * x) else 0\n  (\u2200 x \u2265 0, f x = \u03b1 * Real.exp (-\u03b1 * x)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (\u03b1 : \u211d) (h\u03b1 : \u03b1 > 0) :\n  let f : \u211d \u2192 \u211d := fun x => if x \u2265 0 then \u03b1 * Real.exp (-\u03b1 * x) else 0\n  (\u2200 x \u2265 0, f x = \u03b1 * Real.exp (-\u03b1 * x)) := by\n  intro f x hx\n  have h_main : f x = \u03b1 * Real.exp (-\u03b1 * x) := by\n    dsimp only [f]\n    split_ifs <;> simp_all [hx]\n    <;>\n    (try { contradiction }) <;>\n    (try { linarith }) <;>\n    (try { ring_nf }) <;>\n    (try { field_simp }) <;>\n    (try { norm_num })\n    <;>\n    (try {\n      -- This block is a catch-all for any remaining simplifications or contradictions\n      exfalso\n      linarith\n    })\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the exponential distribution PDF. The parameter \u03b1 with constraint \u03b1 > 0 corresponds to \u03bb\u2081 > 0, and the formula \u03b1 * Real.exp (-\u03b1 * x) for x \u2265 0 perfectly matches \u03bb\u2081 e^{-\u03bb\u2081 x} for x \u2265 0. The variable name change from \u03bb\u2081 to \u03b1 is just notational and doesn't affect the mathematical meaning. The function definition properly handles the domain by setting f(x) = 0 for x < 0, which is standard for PDFs."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, $P(X_1 < X_2) = \\int_0^{\\infty} P(X_2 > x) f_{X_1}(x) dx", "statement": "We assume:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} P(X_1 < X_2|X_1=x) f_{X_1}(x) dx$ [l1].\n\u2022 $P(X_1 < X_2 | X_1 = x) = P(x < X_2)$ [l2].\nTherefore, we conclude:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} P(X_2 > x) f_{X_1}(x) dx$ [l5].", "dependencies": ["l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (X\u2081 X\u2082 : \u211d \u2192 \u211d) \n  (f_X\u2081 : \u211d \u2192 \u211d) \n  (P : Set \u211d \u2192 \u211d)\n  (l1 : P {s | X\u2081 s < X\u2082 s} = \u222b x in Set.Ici 0, P {s | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x)\n  (l2 : \u2200 x, P {s | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} = P {s | X\u2082 s > x}) :\n  P {s | X\u2081 s < X\u2082 s} = \u222b x in Set.Ici 0, P {s | X\u2082 s > x} * f_X\u2081 x := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (X\u2081 X\u2082 : \u211d \u2192 \u211d) \n  (f_X\u2081 : \u211d \u2192 \u211d) \n  (P : Set \u211d \u2192 \u211d)\n  (l1 : P {s | X\u2081 s < X\u2082 s} = \u222b x in Set.Ici 0, P {s | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x)\n  (l2 : \u2200 x, P {s | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} = P {s | X\u2082 s > x}) :\n  P {s | X\u2081 s < X\u2082 s} = \u222b x in Set.Ici 0, P {s | X\u2082 s > x} * f_X\u2081 x := by\n  have h_main : (\u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x) = (\u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2082 s > x} * f_X\u2081 x) := by\n    have h3 : \u2200 (x : \u211d), x \u2208 Set.Ici (0 : \u211d) \u2192 P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x = P {s : \u211d | X\u2082 s > x} * f_X\u2081 x := by\n      intro x hx\n      have h4 : P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} = P {s : \u211d | X\u2082 s > x} := by\n        have h5 := l2 x\n        exact h5\n      calc\n        P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x = P {s : \u211d | X\u2082 s > x} * f_X\u2081 x := by rw [h4]\n        _ = P {s : \u211d | X\u2082 s > x} * f_X\u2081 x := by rfl\n    -- Use the fact that the integrands are equal to show the integrals are equal\n    have h6 : (\u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x) = (\u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2082 s > x} * f_X\u2081 x) := by\n      -- Use the set_integral_congr lemma to prove the equality of integrals\n      have h7 : \u2200 x \u2208 Set.Ici (0 : \u211d), P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x = P {s : \u211d | X\u2082 s > x} * f_X\u2081 x := by\n        intro x hx\n        exact h3 x hx\n      -- Use the fact that the integrands are equal to show the integrals are equal\n      calc\n        (\u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x) = \u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x := rfl\n        _ = \u222b x in Set.Ici (0 : \u211d), P {s : \u211d | X\u2082 s > x} * f_X\u2081 x := by\n          -- Use the set_integral_congr lemma to prove the equality of integrals\n          apply MeasureTheory.set_integral_congr (by\n            -- Prove that the set is measurable\n            exact measurableSet_Ici) h7\n    exact h6\n  \n  have h_final : P {s | X\u2081 s < X\u2082 s} = \u222b x in Set.Ici 0, P {s | X\u2082 s > x} * f_X\u2081 x := by\n    calc\n      P {s | X\u2081 s < X\u2082 s} = \u222b x in Set.Ici 0, P {s | X\u2081 s < X\u2082 s \u2227 X\u2081 s = x} * f_X\u2081 x := by\n        rw [l1]\n      _ = \u222b x in Set.Ici 0, P {s | X\u2082 s > x} * f_X\u2081 x := by\n        rw [h_main]\n      _ = \u222b x in Set.Ici 0, P {s | X\u2082 s > x} * f_X\u2081 x := by rfl\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The theorem structure correctly captures the logical flow from assumptions l1 and l2 to conclusion l5", "Variable declarations appropriately represent random variables X\u2081, X\u2082, density function f_X\u2081, and probability measure P", "Assumption l1 is correctly formalized using set notation for events and proper integral representation over [0,\u221e)", "Assumption l2 correctly represents the conditional probability equality using set-theoretic notation", "The conclusion l5 perfectly matches the natural language statement", "The overall mathematical logic and derivation structure is preserved accurately in the Lean formalization"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "...= \\int_0^{\\infty} e^{-\\lambda_2 x} (\\lambda_1 e^{-\\lambda_1 x}) dx", "statement": "We assume:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} P(X_2 > x) f_{X_1}(x) dx$ [l5].\n\u2022 The survival function of $X_2$ is $P(X_2 > x) = e^{-\\lambda_2 x}$ [l3].\n\u2022 The PDF of $X_1$ is $f_{X_1}(x) = \\lambda_1 e^{-\\lambda_1 x}$ [l4].\nTherefore, we conclude:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} e^{-\\lambda_2 x} (\\lambda_1 e^{-\\lambda_1 x}) dx$ [l6].", "dependencies": ["l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (alpha beta : \u211d) (halpha : alpha > 0) (hbeta : beta > 0)\n  (P : Set \u211d \u2192 \u211d) (f_X\u2081 : \u211d \u2192 \u211d)\n  (l3 : \u2200 x, P {s | s > x} = Real.exp (-(beta * x)))\n  (l4 : \u2200 x, f_X\u2081 x = if x \u2265 0 then alpha * Real.exp (-(alpha * x)) else 0)\n  (l5 : \u2200 t, P {s | s < t} = \u222b x in Set.Ici 0, P {s | s > x} * f_X\u2081 x) :\n  \u2200 t, P {s | s < t} = \u222b x in Set.Ici 0, Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (alpha beta : \u211d) (halpha : alpha > 0) (hbeta : beta > 0)\n  (P : Set \u211d \u2192 \u211d) (f_X\u2081 : \u211d \u2192 \u211d)\n  (l3 : \u2200 x, P {s | s > x} = Real.exp (-(beta * x)))\n  (l4 : \u2200 x, f_X\u2081 x = if x \u2265 0 then alpha * Real.exp (-(alpha * x)) else 0)\n  (l5 : \u2200 t, P {s | s < t} = \u222b x in Set.Ici 0, P {s | s > x} * f_X\u2081 x) :\n  \u2200 t, P {s | s < t} = \u222b x in Set.Ici 0, Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := by\n  have h_main : \u2200 (t : \u211d), P {s | s < t} = \u222b x in Set.Ici 0, Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := by\n    intro t\n    have h1 : P {s | s < t} = \u222b x in Set.Ici 0, P {s | s > x} * f_X\u2081 x := l5 t\n    have h2 : \u222b x in Set.Ici 0, P {s | s > x} * f_X\u2081 x = \u222b x in Set.Ici 0, Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := by\n      -- Show that the integrands are equal everywhere on Set.Ici 0\n      have h3 : \u2200 (x : \u211d), x \u2208 Set.Ici 0 \u2192 P {s | s > x} * f_X\u2081 x = Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := by\n        intro x hx\n        have h4 : x \u2265 0 := by simpa using hx\n        have h5 : P {s | s > x} = Real.exp (-(beta * x)) := l3 x\n        have h6 : f_X\u2081 x = alpha * Real.exp (-(alpha * x)) := by\n          rw [l4]\n          split_ifs <;> simp_all [h4]\n          <;> linarith\n        rw [h5, h6]\n        <;> ring_nf\n        <;> field_simp\n        <;> ring_nf\n      -- Use the fact that the integrands are equal everywhere on Set.Ici 0 to conclude the integrals are equal\n      have h7 : \u222b x in Set.Ici 0, P {s | s > x} * f_X\u2081 x = \u222b x in Set.Ici 0, Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := by\n        apply MeasureTheory.set_integral_congr (by measurability) (by measurability)\n        intro x hx\n        have h8 : x \u2208 Set.Ici 0 := hx\n        have h9 : P {s | s > x} * f_X\u2081 x = Real.exp (-(beta * x)) * (alpha * Real.exp (-(alpha * x))) := h3 x h8\n        exact h9\n      exact h7\n    -- Combine the results to get the final equality\n    rw [h1, h2]\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 30, "column": 70, "endLine": 30, "endColumn": 83, "data": "tactic 'aesop' failed, failed to prove the goal after exhaustive search.\nInitial goal:\n  alpha beta : \u211d\n  halpha : alpha > 0\n  hbeta : beta > 0\n  P : Set \u211d \u2192 \u211d\n  f_X\u2081 : \u211d \u2192 \u211d\n  l3 : \u2200 (x : \u211d), P {s | s > x} = rexp (-(beta * x))\n  l4 : \u2200 (x : \u211d), f_X\u2081 x = if x \u2265 0 then alpha * rexp (-(alpha * x)) else 0\n  l5 : \u2200 (t : \u211d), P {s | s < t} = \u222b (x : \u211d) in Set.Ici 0, P {s | s > x} * f_X\u2081 x\n  t : \u211d\n  h1 : P {s | s < t} = \u222b (x : \u211d) in Set.Ici 0, P {s | s > x} * f_X\u2081 x\n  h3 : \u2200 x \u2208 Set.Ici 0, P {s | s > x} * f_X\u2081 x = rexp (-(beta * x)) * (alpha * rexp (-(alpha * x)))\n  \u22a2 Set.EqOn (fun x => P {s | s > x} * f_X\u2081 x) (fun x => rexp (-(beta * x)) * (alpha * rexp (-(alpha * x)))) (Set.Ici 0)\nRemaining goals after safe rules:\n  alpha beta : \u211d\n  P : Set \u211d \u2192 \u211d\n  f_X\u2081 : \u211d \u2192 \u211d\n  t : \u211d\n  halpha : 0 < alpha\n  hbeta : 0 < beta\n  l3 : \u2200 (x : \u211d), P {s | x < s} = rexp (-(beta * x))\n  l4 : \u2200 (x : \u211d), f_X\u2081 x = if 0 \u2264 x then alpha * rexp (-(alpha * x)) else 0\n  l5 :\n    \u2200 (t : \u211d),\n      P {s | s < t} = \u222b (x : \u211d) in Set.Ici 0, if 0 \u2264 x then rexp (-(beta * x)) * (alpha * rexp (-(alpha * x))) else 0\n  \u22a2 Set.EqOn (fun x => if 0 \u2264 x then rexp (-(beta * x)) * (alpha * rexp (-(alpha * x))) else 0)\n      (fun x => rexp (-(beta * x)) * (alpha * rexp (-(alpha * x)))) (Set.Ici 0)"}, {"line": 31, "column": 8, "endLine": 31, "endColumn": 18, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable names differ (alpha/beta vs \u03bb\u2081/\u03bb\u2082) but represent the same mathematical concepts with appropriate positivity constraints", "Survival function correctly formalized with proper exponential form and parameter substitution", "PDF correctly formalized with explicit domain restriction (x \u2265 0) that's mathematically sound though not explicitly stated in natural language", "General integration formula correctly captures the relationship between probability and integral over survival function and PDF", "Conclusion correctly substitutes the expressions but uses generalized form (\u2200 t) rather than specific P(X\u2081 < X\u2082), and different variable names", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['Variable names differ (alpha/beta vs \u03bb\u2081/\u03bb\u2082) but represent the same mathematical concepts with appropriate positivity constraints', 'Survival function correctly formalized with proper exponential form and parameter substitution', \"PDF correctly formalized with explicit domain restriction (x \u2265 0) that's mathematically sound though not explicitly stated in natural language\", 'General integration formula correctly captures the relationship between probability and integral over survival function and PDF', 'Conclusion correctly substitutes the expressions but uses generalized form (\u2200 t) rather than specific P(X\u2081 < X\u2082), and different variable names']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "...= \\int_0^{\\infty} \\lambda_1 e^{-(\\lambda_1 + \\lambda_2)x} dx.", "statement": "We assume:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} e^{-\\lambda_2 x} (\\lambda_1 e^{-\\lambda_1 x}) dx$ [l6].\nTherefore, we conclude:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} \\lambda_1 e^{-(\\lambda_1 + \\lambda_2)x} dx$ [l7].", "dependencies": ["l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (lambda_1 lambda_2 : \u211d) (hlambda_1 : lambda_1 > 0) (hlambda_2 : lambda_2 > 0)\n  (P : \u211d \u2192 \u211d) (f_X\u2081 : \u211d \u2192 \u211d)\n  (l6 : \u222b x in Set.Ici 0, Real.exp (-(lambda_2 * x)) * (lambda_1 * Real.exp (-(lambda_1 * x))) = \n        \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x)) :\n  \u222b x in Set.Ici 0, Real.exp (-(lambda_2 * x)) * (lambda_1 * Real.exp (-(lambda_1 * x))) = \n  \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (lambda_1 lambda_2 : \u211d) (hlambda_1 : lambda_1 > 0) (hlambda_2 : lambda_2 > 0)\n  (P : \u211d \u2192 \u211d) (f_X\u2081 : \u211d \u2192 \u211d)\n  (l6 : \u222b x in Set.Ici 0, Real.exp (-(lambda_2 * x)) * (lambda_1 * Real.exp (-(lambda_1 * x))) = \n        \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x)) :\n  \u222b x in Set.Ici 0, Real.exp (-(lambda_2 * x)) * (lambda_1 * Real.exp (-(lambda_1 * x))) = \n  \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) := by\n  have h_main : \u222b x in Set.Ici 0, Real.exp (-(lambda_2 * x)) * (lambda_1 * Real.exp (-(lambda_1 * x))) = \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) := by\n    exact l6\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The mathematical expressions are correctly translated with proper operator precedence and parenthesization", "Integration domain [0,\u221e) is correctly represented using Set.Ici 0", "The logical flow from assumption l6 to conclusion l7 is properly captured in the theorem structure", "Additional type constraints and positivity conditions are reasonable mathematical assumptions that don't contradict the natural language", "The proof structure correctly reflects that l7 follows directly from l6, even though the natural language presents it as algebraic manipulation"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Evaluating this integral gives $\\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}$.", "statement": "We assume:\n\u2022 $P(X_1 < X_2) = \\int_0^{\\infty} \\lambda_1 e^{-(\\lambda_1 + \\lambda_2)x} dx$ [l7].\n\u2022 $\\lambda_1 > 0$ and $\\lambda_2 > 0$ [tc_1].\nTherefore, we conclude:\n\u2022 $P(X_1 < X_2) = \\frac{\\lambda_1}{\\lambda_1 + \\lambda_2}$ [ts_1].", "dependencies": ["l7", "tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (lambda_1 lambda_2 : \u211d) (hlambda_1 : lambda_1 > 0) (hlambda_2 : lambda_2 > 0)\n  (l7 : \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) = \n        lambda_1 / (lambda_1 + lambda_2))\n  (tc_1 : lambda_1 > 0 \u2227 lambda_2 > 0) :\n  \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) = \n  lambda_1 / (lambda_1 + lambda_2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (lambda_1 lambda_2 : \u211d) (hlambda_1 : lambda_1 > 0) (hlambda_2 : lambda_2 > 0)\n  (l7 : \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) = \n        lambda_1 / (lambda_1 + lambda_2))\n  (tc_1 : lambda_1 > 0 \u2227 lambda_2 > 0) :\n  \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) = \n  lambda_1 / (lambda_1 + lambda_2) := by\n  have h_main : \u222b x in Set.Ici 0, lambda_1 * Real.exp (-(lambda_1 + lambda_2) * x) = lambda_1 / (lambda_1 + lambda_2) := by\n    -- Directly use the given hypothesis `l7` to conclude the proof.\n    exact l7\n  \n  -- The goal is already achieved by `h_main`, so we can directly use it.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The integral assumption [l7] is treated as a given hypothesis in Lean, but the natural language context suggests this should be the integral that needs to be evaluated to reach the conclusion. The Lean formalization assumes the result rather than proving it.", "The positivity conditions for lambda_1 and lambda_2 are correctly captured in Lean, with some redundancy that doesn't affect correctness.", "The conclusion [ts_1] becomes trivial in the Lean formalization since it directly follows from assumption l7. The natural language suggests proving that the integral evaluates to the given fraction, but Lean assumes this equality and then restates it."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The integral assumption [l7] is treated as a given hypothesis in Lean, but the natural language context suggests this should be the integral that needs to be evaluated to reach the conclusion. The Lean formalization assumes the result rather than proving it.', \"The positivity conditions for lambda_1 and lambda_2 are correctly captured in Lean, with some redundancy that doesn't affect correctness.\", 'The conclusion [ts_1] becomes trivial in the Lean formalization since it directly follows from assumption l7. The natural language suggests proving that the integral evaluates to the given fraction, but Lean assumes this equality and then restates it.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    