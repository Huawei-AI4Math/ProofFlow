
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $x, y, z$ such that $xyz \geq xy + yz + zx$, the inequality $xyz \geq 3(x + y + z)$ holds.

Proof: Let $x, y, z$ be positive real numbers such that $xyz \ge xy + yz + zx$. Dividing both sides by $xyz$ and setting $a = 1/x, b = 1/y, c = 1/z$, the condition becomes $a+b+c \le 1$, and the inequality to prove, $xyz \ge 3(x+y+z)$, reduces to $1 \ge 3(ab+bc+ca)$. Observing that $(a-b)^2+(b-c)^2+(c-a)^2 \ge 0$ implies $a^2+b^2+c^2 \ge ab+bc+ca$, we expand $(a+b+c)^2 = a^2+b^2+c^2 + 2(ab+bc+ca) \ge 3(ab+bc+ca)$. Since $a+b+c \le 1$, squaring gives $(a+b+c)^2 \le 1$, and combining the inequalities yields $1 \ge (a+b+c)^2 \ge 3(ab+bc+ca)$. Substituting back $a=1/x, b=1/y, c=1/z$ and multiplying through by $xyz$ gives the desired result $xyz \ge 3(x+y+z)$, completing the proof.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let x, y, z be positive real numbers", "statement": "Premise:\n\u2022 x, y, z are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x y z : \u211d)\n(tc_1 : 0 < x \u2227 0 < y \u2227 0 < z \u2227 x * y * z \u2265 x * y + y * z + z * x)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures that x, y, z are positive real numbers, but includes an additional constraint 'x * y * z \u2265 x * y + y * z + z * x' that is not mentioned in the natural language premise. While the core condition is preserved, this extra constraint goes beyond what was stated in the premise."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures that x, y, z are positive real numbers, but includes an additional constraint 'x * y * z \u2265 x * y + y * z + z * x' that is not mentioned in the natural language premise. While the core condition is preserved, this extra constraint goes beyond what was stated in the premise.\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "such that $xyz \\ge xy + yz + zx$.", "statement": "Premise:\n\u2022 x, y, z are positive real numbers [tc_1]\n\u2022 xyz \u2265 xy + yz + zx [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x y z : \u211d)\n(tc_1 : 0 < x \u2227 0 < y \u2227 0 < z)\n(tc_2 : x * y * z \u2265 x * y + y * z + z * x)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that x, y, z are real numbers (\u211d) and positive (0 < x \u2227 0 < y \u2227 0 < z). The conjunction properly represents that all three variables are positive real numbers.", "The Lean formalization correctly translates the inequality xyz \u2265 xy + yz + zx using multiplication notation (x * y * z \u2265 x * y + y * z + z * x). The mathematical meaning is identical."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "setting $a = 1/x, b = 1/y, c = 1/z$", "statement": "Definition:\n\u2022 Given positive real numbers x, y, z [tc_1], let a, b, c be real numbers such that a = 1/x, b = 1/y, c = 1/z [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem xyz_geq_3xy_plus_3yz_plus_3zx :\n  \u2200 (x y z : \u211d), 0 < x \u2192 0 < y \u2192 0 < z \u2192 x * y * z \u2265 x * y + y * z + z * x \u2192 x * y * z \u2265 3 * (x + y + z) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Both the natural language and Lean specify that x, y, z are positive real numbers, though expressed differently", "The Lean theorem completely omits the definition a = 1/x, which is a key component of the natural language statement", "The Lean theorem completely omits the definition b = 1/y, which is a key component of the natural language statement", "The Lean theorem completely omits the definition c = 1/z, which is a key component of the natural language statement", "The Lean theorem does not conclude that a, b, c are real numbers, and in fact does not even mention variables a, b, c at all"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Both the natural language and Lean specify that x, y, z are positive real numbers, though expressed differently', 'The Lean theorem completely omits the definition a = 1/x, which is a key component of the natural language statement', 'The Lean theorem completely omits the definition b = 1/y, which is a key component of the natural language statement', 'The Lean theorem completely omits the definition c = 1/z, which is a key component of the natural language statement', 'The Lean theorem does not conclude that a, b, c are real numbers, and in fact does not even mention variables a, b, c at all']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Dividing both sides by $xyz$ and setting $a = 1/x, b = 1/y, c = 1/z$, the condition becomes $a+b+c \\le 1$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1]\n\u2022 xyz \u2265 xy + yz + zx [tc_2]\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1]\nTherefore, we conclude:\n\u2022 a + b + c \u2264 1 [l1].", "dependencies": ["tc_1", "tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (x y z : \u211d)\n  (tc_1 : 0 < x \u2227 0 < y \u2227 0 < z)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x) :\n  1/x + 1/y + 1/z \u2264 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (x y z : \u211d)\n  (tc_1 : 0 < x \u2227 0 < y \u2227 0 < z)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x) :\n  1/x + 1/y + 1/z \u2264 1 := by\n  have h_xyz_pos : 0 < x * y * z := by\n    have hx : 0 < x := tc_1.1\n    have hy : 0 < y := tc_1.2.1\n    have hz : 0 < z := tc_1.2.2\n    have hxy : 0 < x * y := mul_pos hx hy\n    have hxyz : 0 < x * y * z := mul_pos hxy hz\n    exact hxyz\n  \n  have h_main_ineq : (x * y + y * z + z * x) / (x * y * z) \u2264 1 := by\n    have h\u2081 : (x * y + y * z + z * x) \u2264 x * y * z := by\n      linarith\n    have h\u2082 : 0 < x * y * z := h_xyz_pos\n    -- Divide both sides of the inequality by x * y * z (which is positive)\n    have h\u2083 : (x * y + y * z + z * x) / (x * y * z) \u2264 1 := by\n      rw [div_le_one (by positivity)]\n      nlinarith\n    exact h\u2083\n  \n  have h_sum_recip : (x * y + y * z + z * x) / (x * y * z) = 1/x + 1/y + 1/z := by\n    have hx : 0 < x := tc_1.1\n    have hy : 0 < y := tc_1.2.1\n    have hz : 0 < z := tc_1.2.2\n    have hxy : 0 < x * y := mul_pos hx hy\n    have hxz : 0 < x * z := mul_pos hx hz\n    have hyz : 0 < y * z := mul_pos hy hz\n    have hxyz : 0 < x * y * z := by positivity\n    -- Simplify the left-hand side by splitting the fraction\n    have h\u2081 : (x * y + y * z + z * x) / (x * y * z) = (x * y) / (x * y * z) + (y * z) / (x * y * z) + (z * x) / (x * y * z) := by\n      have h\u2082 : (x * y + y * z + z * x) / (x * y * z) = (x * y) / (x * y * z) + (y * z) / (x * y * z) + (z * x) / (x * y * z) := by\n        field_simp [hxyz.ne']\n        <;> ring_nf\n        <;> field_simp [hxyz.ne']\n        <;> ring_nf\n      rw [h\u2082]\n    rw [h\u2081]\n    -- Simplify each term on the right-hand side\n    have h\u2082 : (x * y) / (x * y * z) = 1 / z := by\n      have h\u2083 : (x * y) / (x * y * z) = 1 / z := by\n        field_simp [hx.ne', hy.ne', hz.ne', hxy.ne', hxz.ne', hyz.ne', hxyz.ne']\n        <;> ring_nf\n        <;> field_simp [hx.ne', hy.ne', hz.ne', hxy.ne', hxz.ne', hyz.ne', hxyz.ne']\n        <;> ring_nf\n      rw [h\u2083]\n    have h\u2083 : (y * z) / (x * y * z) = 1 / x := by\n      have h\u2084 : (y * z) / (x * y * z) = 1 / x := by\n        field_simp [hx.ne', hy.ne', hz.ne', hxy.ne', hxz.ne', hyz.ne', hxyz.ne']\n        <;> ring_nf\n        <;> field_simp [hx.ne', hy.ne', hz.ne', hxy.ne', hxz.ne', hyz.ne', hxyz.ne']\n        <;> ring_nf\n      rw [h\u2084]\n    have h\u2084 : (z * x) / (x * y * z) = 1 / y := by\n      have h\u2085 : (z * x) / (x * y * z) = 1 / y := by\n        field_simp [hx.ne', hy.ne', hz.ne', hxy.ne', hxz.ne', hyz.ne', hxyz.ne']\n        <;> ring_nf\n        <;> field_simp [hx.ne', hy.ne', hz.ne', hxy.ne', hxz.ne', hyz.ne', hxyz.ne']\n        <;> ring_nf\n      rw [h\u2085]\n    rw [h\u2082, h\u2083, h\u2084]\n    <;> ring_nf\n    <;> field_simp [hx.ne', hy.ne', hz.ne']\n    <;> ring_nf\n  \n  have h_final : 1/x + 1/y + 1/z \u2264 1 := by\n    have h\u2081 : 1 / x + 1 / y + 1 / z = (x * y + y * z + z * x) / (x * y * z) := by\n      linarith\n    rw [h\u2081]\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable types and positivity constraints are correctly formalized", "The main inequality constraint is accurately translated", "The variable definitions are implicitly handled through direct substitution, which is mathematically equivalent", "The conclusion correctly represents the target inequality using the substituted expressions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Observing that $(a-b)^2+(b-c)^2+(c-a)^2 \\ge 0$ implies $a^2+b^2+c^2 \\ge ab+bc+ca$", "statement": "We assume:\n\u2022 a, b, c are real numbers.\nTherefore, we conclude:\n\u2022 a\u00b2 + b\u00b2 + c\u00b2 \u2265 ab + bc + ca [l2].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c : \u211d) : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c : \u211d) : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := by\n  have h_main : a^2 + b^2 + c^2 - (a*b + b*c + c*a) \u2265 0 := by\n    have h\u2081 : 0 \u2264 (a - b)^2 + (b - c)^2 + (c - a)^2 := by\n      nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a)]\n    nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a)]\n  \n  have h_final : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := by\n    have h\u2082 : a^2 + b^2 + c^2 - (a*b + b*c + c*a) \u2265 0 := h_main\n    -- Add (a*b + b*c + c*a) to both sides of the inequality\n    have h\u2083 : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := by\n      linarith\n    exact h\u2083\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The variable declarations (a b c : \u211d) properly represent 'a, b, c are real numbers', and the inequality a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a accurately translates the mathematical expression a\u00b2 + b\u00b2 + c\u00b2 \u2265 ab + bc + ca. The theorem structure appropriately represents the logical claim, and the naming convention l2 matches the natural language reference."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "we expand $(a+b+c)^2 = a^2+b^2+c^2 + 2(ab+bc+ca) \\ge 3(ab+bc+ca)$", "statement": "We assume:\n\u2022 a, b, c are real numbers.\n\u2022 a\u00b2 + b\u00b2 + c\u00b2 \u2265 ab + bc + ca [l2]\nTherefore, we conclude:\n\u2022 (a+b+c)\u00b2 \u2265 3(ab+bc+ca) [l3].", "dependencies": ["l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c : \u211d) (h : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a) :\n  (a + b + c)^2 \u2265 3 * (a*b + b*c + c*a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c : \u211d) (h : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a) :\n  (a + b + c)^2 \u2265 3 * (a*b + b*c + c*a) := by\n  have h_main : (a + b + c)^2 \u2265 3 * (a*b + b*c + c*a) := by\n    nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),\n      sq_nonneg (a + b + c), sq_nonneg (a + b - c), sq_nonneg (a - b + c),\n      sq_nonneg (-a + b + c)]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. Variable declarations, the premise inequality, the conclusion inequality, and the logical implication structure are all accurately represented. The notational differences (^2 vs \u00b2, explicit * operators) are standard Lean syntax and do not affect the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since $a+b+c \\le 1$, squaring gives $(a+b+c)^2 \\le 1$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1]\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1]\n\u2022 a + b + c \u2264 1 [l1]\nTherefore, we conclude:\n\u2022 (a+b+c)\u00b2 \u2264 1 [l4].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (x y z : \u211d)\n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (a b c : \u211d) (ha : a = 1/x) (hb : b = 1/y) (hc : c = 1/z)\n  (h : a + b + c \u2264 1) :\n  (a + b + c)^2 \u2264 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (x y z : \u211d)\n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (a b c : \u211d) (ha : a = 1/x) (hb : b = 1/y) (hc : c = 1/z)\n  (h : a + b + c \u2264 1) :\n  (a + b + c)^2 \u2264 1 := by\n  have h\u2081 : a > 0 := by\n    rw [ha]\n    exact div_pos zero_lt_one hx\n  \n  have h\u2082 : b > 0 := by\n    rw [hb]\n    exact div_pos zero_lt_one hy\n  \n  have h\u2083 : c > 0 := by\n    rw [hc]\n    exact div_pos zero_lt_one hz\n  \n  have h\u2084 : a + b + c > 0 := by\n    -- Since a, b, and c are all positive, their sum is also positive.\n    have h\u2084\u2081 : 0 < a := h\u2081\n    have h\u2084\u2082 : 0 < b := h\u2082\n    have h\u2084\u2083 : 0 < c := h\u2083\n    -- Using the fact that the sum of positive numbers is positive.\n    linarith\n  \n  have h\u2085 : (a + b + c)^2 \u2264 a + b + c := by\n    have h\u2085\u2081 : 0 < a + b + c := h\u2084\n    have h\u2085\u2082 : a + b + c \u2264 1 := h\n    -- Multiply both sides of the inequality `a + b + c \u2264 1` by the positive number `a + b + c`\n    have h\u2085\u2083 : (a + b + c) * (a + b + c) \u2264 (a + b + c) * 1 := by\n      nlinarith\n    -- Simplify the right side of the inequality\n    have h\u2085\u2084 : (a + b + c) * 1 = a + b + c := by ring\n    -- Substitute back into the inequality\n    have h\u2085\u2085 : (a + b + c) * (a + b + c) \u2264 a + b + c := by\n      linarith\n    -- Recognize that `(a + b + c) * (a + b + c)` is the same as `(a + b + c)^2`\n    have h\u2085\u2086 : (a + b + c) * (a + b + c) = (a + b + c)^2 := by ring\n    -- Substitute to get the final inequality\n    linarith\n  \n  have h\u2086 : (a + b + c)^2 \u2264 1 := by\n    have h\u2086\u2081 : (a + b + c)^2 \u2264 a + b + c := h\u2085\n    have h\u2086\u2082 : a + b + c \u2264 1 := h\n    linarith\n  \n  exact h\u2086", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured with appropriate type specifications and inequality hypotheses", "The definitions of a, b, c as reciprocals of x, y, z are exactly translated with proper hypothesis naming", "The constraint 'a + b + c \u2264 1' is precisely encoded as hypothesis h", "The conclusion '(a+b+c)\u00b2 \u2264 1' is correctly represented using equivalent exponentiation notation ^2"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "and combining the inequalities yields $1 \\ge (a+b+c)^2 \\ge 3(ab+bc+ca)$", "statement": "We assume:\n\u2022 (a+b+c)\u00b2 \u2265 3(ab+bc+ca) [l3]\n\u2022 (a+b+c)\u00b2 \u2264 1 [l4]\nTherefore, we conclude:\n\u2022 1 \u2265 3(ab+bc+ca) [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a b c : \u211d) \n  (l3 : (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a))\n  (l4 : (a + b + c)^2 \u2264 1) :\n  1 \u2265 3 * (a * b + b * c + c * a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a b c : \u211d) \n  (l3 : (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a))\n  (l4 : (a + b + c)^2 \u2264 1) :\n  1 \u2265 3 * (a * b + b * c + c * a) := by\n  have h_main : 3 * (a * b + b * c + c * a) \u2264 1 := by\n    have h\u2081 : 3 * (a * b + b * c + c * a) \u2264 (a + b + c) ^ 2 := by\n      linarith\n    have h\u2082 : (a + b + c) ^ 2 \u2264 1 := l4\n    linarith\n  \n  have h_final : 1 \u2265 3 * (a * b + b * c + c * a) := by\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations are correctly formalized with explicit real number types, which adds helpful clarity without changing meaning", "The first assumption l3 is perfectly captured with equivalent mathematical notation using explicit operators", "The second assumption l4 is identically represented in both versions", "The conclusion l5 maintains the same inequality direction and mathematical expression", "The overall logical structure preserving the transitive reasoning from two hypotheses to conclusion is correctly formalized"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting back $a=1/x, b=1/y, c=1/z$ and multiplying through by $xyz$ gives the desired result $xyz \\ge 3(x+y+z)$, completing the proof.", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1]\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1]\n\u2022 1 \u2265 3(ab+bc+ca) [l5]\nTherefore, we conclude:\n\u2022 xyz \u2265 3(x+y+z) [ts_1].", "dependencies": ["tc_1", "def_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem xyz_geq_3xy_plus_3yz_plus_3zx :\n  \u2200 (x y z : \u211d), 0 < x \u2192 0 < y \u2192 0 < z \u2192 \n  x * y * z \u2265 x * y + y * z + z * x \u2192 \n  x * y * z \u2265 3 * (x + y + z) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem xyz_geq_3xy_plus_3yz_plus_3zx :\n  \u2200 (x y z : \u211d), 0 < x \u2192 0 < y \u2192 0 < z \u2192 \n  x * y * z \u2265 x * y + y * z + z * x \u2192 \n  x * y * z \u2265 3 * (x + y + z) := by\n  intro x y z hx hy hz h\n  have h_aux : (x * y + y * z + z * x)^2 \u2265 3 * (x * y * z) * (x + y + z) := by\n    have h\u2081 : 0 < x * y := mul_pos hx hy\n    have h\u2082 : 0 < y * z := mul_pos hy hz\n    have h\u2083 : 0 < z * x := mul_pos hz hx\n    have h\u2084 : 0 < x * y * z := by positivity\n    have h\u2085 : 0 < x * y * z * x := by positivity\n    have h\u2086 : 0 < x * y * z * y := by positivity\n    have h\u2087 : 0 < x * y * z * z := by positivity\n    nlinarith [sq_nonneg (x * y - y * z), sq_nonneg (y * z - z * x), sq_nonneg (z * x - x * y),\n      sq_nonneg (x * y + y * z + z * x), sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x)]\n  \n  have h_mul : (x * y * z) * (x * y + y * z + z * x) \u2265 (x * y + y * z + z * x)^2 := by\n    have h\u2081 : 0 < x * y := mul_pos hx hy\n    have h\u2082 : 0 < y * z := mul_pos hy hz\n    have h\u2083 : 0 < z * x := mul_pos hz hx\n    have h\u2084 : 0 < x * y + y * z + z * x := by positivity\n    have h\u2085 : x * y * z \u2265 x * y + y * z + z * x := h\n    have h\u2086 : 0 < x * y * z := by positivity\n    nlinarith [h\u2085]\n  \n  have h_chain : (x * y * z) * (x * y + y * z + z * x) \u2265 3 * (x * y * z) * (x + y + z) := by\n    have h\u2081 : (x * y * z) * (x * y + y * z + z * x) \u2265 (x * y + y * z + z * x) ^ 2 := h_mul\n    have h\u2082 : (x * y + y * z + z * x) ^ 2 \u2265 3 * (x * y * z) * (x + y + z) := h_aux\n    have h\u2083 : 0 \u2264 (x * y * z) * (x * y + y * z + z * x) := by\n      have h\u2084 : 0 < x * y := mul_pos hx hy\n      have h\u2085 : 0 < y * z := mul_pos hy hz\n      have h\u2086 : 0 < z * x := mul_pos hz hx\n      have h\u2087 : 0 < x * y + y * z + z * x := by positivity\n      have h\u2088 : 0 < x * y * z := by positivity\n      positivity\n    nlinarith\n  \n  have h_sum_ineq : x * y + y * z + z * x \u2265 3 * (x + y + z) := by\n    have h\u2081 : 0 < x * y := mul_pos hx hy\n    have h\u2082 : 0 < y * z := mul_pos hy hz\n    have h\u2083 : 0 < z * x := mul_pos hz hx\n    have h\u2084 : 0 < x * y * z := by positivity\n    have h\u2085 : (x * y * z) * (x * y + y * z + z * x) \u2265 3 * (x * y * z) * (x + y + z) := h_chain\n    have h\u2086 : x * y + y * z + z * x \u2265 3 * (x + y + z) := by\n      -- Divide both sides by x * y * z (which is positive) to simplify the inequality\n      have h\u2087 : 0 < x * y * z := by positivity\n      have h\u2088 : (x * y * z) * (x * y + y * z + z * x) \u2265 3 * (x * y * z) * (x + y + z) := h_chain\n      have h\u2089 : x * y + y * z + z * x \u2265 3 * (x + y + z) := by\n        -- Use the fact that x * y * z > 0 to divide both sides of the inequality\n        have h\u2081\u2080 : 0 < x * y * z := by positivity\n        have h\u2081\u2081 : (x * y * z) * (x * y + y * z + z * x) \u2265 3 * (x * y * z) * (x + y + z) := h_chain\n        -- Divide both sides by x * y * z\n        have h\u2081\u2082 : x * y + y * z + z * x \u2265 3 * (x + y + z) := by\n          apply le_of_sub_nonneg\n          have h\u2081\u2083 : 0 \u2264 (x * y * z) := by positivity\n          nlinarith\n        exact h\u2081\u2082\n      exact h\u2089\n    exact h\u2086\n  \n  have h_final : x * y * z \u2265 3 * (x + y + z) := by\n    have h\u2081 : x * y * z \u2265 x * y + y * z + z * x := h\n    have h\u2082 : x * y + y * z + z * x \u2265 3 * (x + y + z) := h_sum_ineq\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured in the Lean formalization.", "The definitions a = 1/x, b = 1/y, c = 1/z are completely missing from the Lean formalization.", "The premise condition is fundamentally different: natural language has '1 \u2265 3(ab+bc+ca)' involving reciprocals, while Lean has 'x * y * z \u2265 x * y + y * z + z * x' involving original variables directly.", "The conclusion 'xyz \u2265 3(x+y+z)' is correctly represented as 'x * y * z \u2265 3 * (x + y + z)' in Lean."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations and positivity constraints are correctly captured in the Lean formalization.', 'The definitions a = 1/x, b = 1/y, c = 1/z are completely missing from the Lean formalization.', \"The premise condition is fundamentally different: natural language has '1 \u2265 3(ab+bc+ca)' involving reciprocals, while Lean has 'x * y * z \u2265 x * y + y * z + z * x' involving original variables directly.\", \"The conclusion 'xyz \u2265 3(x+y+z)' is correctly represented as 'x * y * z \u2265 3 * (x + y + z)' in Lean.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    