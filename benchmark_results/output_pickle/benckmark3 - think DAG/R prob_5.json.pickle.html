
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let X be a discrete random variable with expected value $E[X] = \mu$ and variance $Var(X) = \sigma^2$. If $Y = aX + b$ for some real constants $a$ and $b$, then the variance of Y is $Var(Y) = a^2 \sigma^2$.

Proof: The variance of Y is defined as $Var(Y) = E[(Y - E[Y])^2]$. First, we find the expected value of Y. Using the linearity of expectation and the given conditions, we have $E[Y] = E[aX + b] = aE[X] + b = a\mu + b$. Next, we find the deviation from the mean, $Y - E[Y] = (aX + b) - (a\mu + b) = a(X - \mu)$. Using this, the variance expression becomes $Var(Y) = E[(a(X-\mu))^2] = a^2 E[(X-\mu)^2]$. Since we know that $E[(X-\mu)^2]$ is the definition of $Var(X)$, which is given as $\sigma^2$, we can conclude that $Var(Y) = a^2 \sigma^2$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let X be a discrete random variable with expected value $E[X] = \\mu$ and variance $Var(X) = \\sigma^2$.", "statement": "Premise:\n\u2022 X is a discrete random variable with expected value E[X] = \u03bc and variance Var(X) = \u03c3\u00b2 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 \n  (\u03bc \u03c3 : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (hVar : \u2211' n, P n * (X n - \u03bc)^2 = \u03c3^2) :\n  \u2200 a b : \u211d, \n    let Y := fun n => a * X n + b\n    let E_Y := \u2211' n, P n * Y n\n    let Var_Y := \u2211' n, P n * (Y n - E_Y)^2\n    Var_Y = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization captures 'X is a discrete random variable' through the explicit probability framework: P : \u2115 \u2192 \u211d represents the probability mass function, X : \u2115 \u2192 \u211d represents the random variable values, with conditions hP_nonneg (non-negative probabilities), hP_sum (probabilities sum to 1), and hP_support (finite support for discrete distribution). This is a complete and correct formalization of a discrete random variable.", "The condition E[X] = \u03bc is perfectly captured by hE : \u2211' n, P n * X n = \u03bc, which is the standard mathematical definition of expected value for discrete random variables.", "The condition Var(X) = \u03c3\u00b2 is perfectly captured by hVar : \u2211' n, P n * (X n - \u03bc)^2 = \u03c3^2, which is the standard mathematical definition of variance for discrete random variables."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $Y = aX + b$ for some real constants $a$ and $b$", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 Y = aX + b for some real constants a and b [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2\n  (\u03bc \u03c3 : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (hVar : \u2211' n, P n * (X n - \u03bc)^2 = \u03c3^2)\n  (a b : \u211d) :\n  let Y := fun n => a * X n + b\n  let E_Y := \u2211' n, P n * Y n\n  let Var_Y := \u2211' n, P n * (Y n - E_Y)^2\n  Var_Y = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures X as a discrete random variable through the probability distribution P and the discrete support condition hP_support. The additional details about mean and variance are extra mathematical structure not contradicting the natural language statement.", "The Lean formalization correctly defines Y := fun n => a * X n + b with real constants a and b, which perfectly matches Y = aX + b from the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The variance of Y is defined as $Var(Y) = E[(Y - E[Y])^2]$.", "statement": "Definition:\n\u2022 The variance of a random variable Y is defined as Var(Y) = E[(Y - E[Y])^2] [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (P : ProbabilityMeasure \u03a9) (Y : \u03a9 \u2192 \u211d) [Measurable Y]\n  (h_integrable : Integrable Y P) :\n  let \u03bc := \u222b \u03c9, Y \u03c9 \u2202P\n  \u222b \u03c9, (Y \u03c9 - \u03bc)^2 \u2202P = \u222b \u03c9, (Y \u03c9 - \u03bc)^2 \u2202P := by sorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 74, "endLine": 8, "endColumn": 86, "data": "invalid binder annotation, type is not a class instance\n  Measurable Y\nuse the command `set_option checkBinderAnnotations false` to disable the check"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Using the linearity of expectation and the given conditions, we have $E[Y] = E[aX + b] = aE[X] + b = a\\mu + b$.", "statement": "We assume:\n\u2022 X is a discrete random variable with expected value E[X] = \u03bc [tc_1]\n\u2022 Y = aX + b for some real constants a and b [tc_2]\nTherefore, we conclude:\n\u2022 E[Y] = a\u03bc + b [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (\u03bc : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (a b : \u211d) :\n  let Y := fun n => a * X n + b\n  \u2211' n, P n * Y n = a * \u03bc + b := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (\u03bc : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (a b : \u211d) :\n  let Y := fun n => a * X n + b\n  \u2211' n, P n * Y n = a * \u03bc + b := by\n  intro Y\n  have h_sum_Y : \u2211' n, P n * Y n = \u2211' n, (a * (P n * X n) + b * P n) := by\n    have h\u2081 : (fun n => P n * Y n) = (fun n => a * (P n * X n) + b * P n) := by\n      funext n\n      simp only [Y]\n      ring_nf\n      <;>\n      (try norm_num) <;>\n      (try ring_nf) <;>\n      (try linarith [hP_nonneg n])\n      <;>\n      (try simp_all [mul_assoc])\n      <;>\n      (try field_simp [hP_nonneg n])\n      <;>\n      (try nlinarith [hP_nonneg n])\n    rw [h\u2081]\n    <;>\n    (try simp_all)\n    <;>\n    (try norm_num)\n    <;>\n    (try linarith)\n  \n  have h_sum_split : \u2211' n, (a * (P n * X n) + b * P n) = \u2211' n, a * (P n * X n) + \u2211' n, b * P n := by\n    have h\u2081 : Summable (fun n : \u2115 => a * (P n * X n)) := by\n      obtain \u27e8S, hS\u27e9 := hP_support\n      have h\u2082 : Summable (fun n : \u2115 => a * (P n * X n)) := by\n        have h\u2083 : (fun n : \u2115 => a * (P n * X n)) = (fun n : \u2115 => a * (P n * X n)) := rfl\n        rw [h\u2083]\n        apply Summable.of_finite_support\n        have h\u2084 : (fun n : \u2115 => a * (P n * X n)).support \u2286 S := by\n          intro n hn\n          simp only [Pi.support, Set.mem_setOf_eq] at hn\n          by_contra h\n          have h\u2085 : n \u2209 S := h\n          have h\u2086 : P n = 0 := hS n h\u2085\n          simp [h\u2086] at hn\n          <;> simp_all\n        exact Finset.finite_toSet S |>.mono h\u2084\n      exact h\u2082\n    have h\u2082 : Summable (fun n : \u2115 => b * P n) := by\n      obtain \u27e8S, hS\u27e9 := hP_support\n      have h\u2083 : Summable (fun n : \u2115 => b * P n) := by\n        have h\u2084 : (fun n : \u2115 => b * P n) = (fun n : \u2115 => b * P n) := rfl\n        rw [h\u2084]\n        apply Summable.of_finite_support\n        have h\u2085 : (fun n : \u2115 => b * P n).support \u2286 S := by\n          intro n hn\n          simp only [Pi.support, Set.mem_setOf_eq] at hn\n          by_contra h\n          have h\u2086 : n \u2209 S := h\n          have h\u2087 : P n = 0 := hS n h\u2086\n          simp [h\u2087] at hn\n          <;> simp_all\n        exact Finset.finite_toSet S |>.mono h\u2085\n      exact h\u2083\n    have h\u2083 : Summable (fun n : \u2115 => a * (P n * X n) + b * P n) := by\n      apply Summable.add h\u2081 h\u2082\n    -- Use the fact that the sum of the sums is the sum of the sum\n    have h\u2084 : \u2211' n : \u2115, (a * (P n * X n) + b * P n) = \u2211' n : \u2115, a * (P n * X n) + \u2211' n : \u2115, b * P n := by\n      rw [tsum_add h\u2081 h\u2082]\n    exact h\u2084\n  \n  have h_sum_a : \u2211' n, a * (P n * X n) = a * \u2211' n, (P n * X n) := by\n    have h\u2081 : Summable (fun n : \u2115 => P n * X n) := by\n      obtain \u27e8S, hS\u27e9 := hP_support\n      have h\u2082 : Summable (fun n : \u2115 => P n * X n) := by\n        have h\u2083 : (fun n : \u2115 => P n * X n) = (fun n : \u2115 => P n * X n) := rfl\n        rw [h\u2083]\n        apply Summable.of_finite_support\n        have h\u2084 : (fun n : \u2115 => P n * X n).support \u2286 S := by\n          intro n hn\n          simp only [Pi.support, Set.mem_setOf_eq] at hn\n          by_contra h\n          have h\u2085 : n \u2209 S := h\n          have h\u2086 : P n = 0 := hS n h\u2085\n          simp [h\u2086] at hn\n          <;> simp_all\n        exact Finset.finite_toSet S |>.mono h\u2084\n      exact h\u2082\n    -- Use the property of tsum to factor out the constant 'a'\n    have h\u2082 : \u2211' n : \u2115, a * (P n * X n) = a * \u2211' n : \u2115, (P n * X n) := by\n      rw [tsum_mul_left]\n    exact h\u2082\n  \n  have h_sum_b : \u2211' n, b * P n = b * \u2211' n, P n := by\n    have h\u2081 : Summable (fun n : \u2115 => P n) := by\n      obtain \u27e8S, hS\u27e9 := hP_support\n      have h\u2082 : Summable (fun n : \u2115 => P n) := by\n        have h\u2083 : (fun n : \u2115 => P n) = (fun n : \u2115 => P n) := rfl\n        rw [h\u2083]\n        apply Summable.of_finite_support\n        have h\u2084 : (fun n : \u2115 => P n).support \u2286 S := by\n          intro n hn\n          simp only [Pi.support, Set.mem_setOf_eq] at hn\n          by_contra h\n          have h\u2085 : n \u2209 S := h\n          have h\u2086 : P n = 0 := hS n h\u2085\n          simp [h\u2086] at hn\n          <;> simp_all\n        exact Finset.finite_toSet S |>.mono h\u2084\n      exact h\u2082\n    -- Use the property of tsum to factor out the constant 'b'\n    have h\u2082 : \u2211' n : \u2115, b * P n = b * \u2211' n : \u2115, P n := by\n      rw [tsum_mul_left]\n    exact h\u2082\n  \n  have h_final : \u2211' n, P n * Y n = a * \u03bc + b := by\n    calc\n      \u2211' n, P n * Y n = \u2211' n, (a * (P n * X n) + b * P n) := by rw [h_sum_Y]\n      _ = \u2211' n, a * (P n * X n) + \u2211' n, b * P n := by rw [h_sum_split]\n      _ = a * \u2211' n, (P n * X n) + \u2211' n, b * P n := by rw [h_sum_a]\n      _ = a * \u2211' n, (P n * X n) + b * \u2211' n, P n := by rw [h_sum_b]\n      _ = a * \u03bc + b * \u2211' n, P n := by rw [hE]\n      _ = a * \u03bc + b * 1 := by rw [hP_sum]\n      _ = a * \u03bc + b := by ring\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 45, "column": 14, "endLine": 45, "endColumn": 40, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Summable\nhas type\n  (?m.3466 \u2192 ?m.3465) \u2192 Prop"}, {"line": 46, "column": 8, "endLine": 46, "endColumn": 12, "data": "no goals to be solved"}, {"line": 61, "column": 14, "endLine": 61, "endColumn": 40, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Summable\nhas type\n  (?m.7117 \u2192 ?m.7116) \u2192 Prop"}, {"line": 62, "column": 8, "endLine": 62, "endColumn": 12, "data": "no goals to be solved"}, {"line": 85, "column": 14, "endLine": 85, "endColumn": 40, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Summable\nhas type\n  (?m.30820 \u2192 ?m.30819) \u2192 Prop"}, {"line": 86, "column": 8, "endLine": 86, "endColumn": 12, "data": "no goals to be solved"}, {"line": 107, "column": 14, "endLine": 107, "endColumn": 40, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Summable\nhas type\n  (?m.35329 \u2192 ?m.35328) \u2192 Prop"}, {"line": 108, "column": 8, "endLine": 108, "endColumn": 12, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The discrete random variable X and its expected value are correctly formalized. The Lean code properly includes the probability mass function P with all necessary probability axioms (non-negativity, normalization, finite support) and defines the expected value as the weighted sum. These technical details are implicit in the natural language but mathematically necessary.", "The linear transformation Y = aX + b is correctly represented as a function that applies the transformation pointwise. The real constants a and b are properly declared.", "The conclusion E[Y] = a\u03bc + b is perfectly captured using the same summation notation for expected value. The mathematical relationship is preserved exactly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (\u03bc : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (a b : \u211d) :\n  let Y := fun n => a * X n + b\n  \u2211' n, P n * Y n = a * \u03bc + b := by\n  intro Y\n  have h_sum_Y : \u2211' n, P n * Y n = a * \u03bc + b := by\n    obtain \u27e8S, hS\u27e9 := hP_support\n    have h\u2081 : \u2211' n : \u2115, P n * Y n = \u2211 n in S, P n * Y n := by\n      have h\u2082 : \u2200 n \u2209 S, P n * Y n = 0 := by\n        intro n hn\n        have h\u2083 : P n = 0 := hS n hn\n        rw [h\u2083]\n        <;> simp [Y]\n        <;> ring\n      -- Use the fact that the sum is zero outside S to convert tsum to a finite sum\n      calc\n        \u2211' n : \u2115, P n * Y n = \u2211' n : \u2115, P n * Y n := rfl\n        _ = \u2211 n in S, P n * Y n := by\n          apply tsum_eq_sum\n          intro n hn\n          exact h\u2082 n hn\n    rw [h\u2081]\n    have h\u2082 : \u2211 n in S, P n * Y n = \u2211 n in S, (a * (P n * X n) + b * P n) := by\n      apply Finset.sum_congr rfl\n      intro n hn\n      have h\u2083 : Y n = a * X n + b := rfl\n      rw [h\u2083]\n      ring_nf\n      <;>\n      simp_all [mul_assoc]\n      <;>\n      ring_nf\n      <;>\n      linarith [hP_nonneg n]\n    rw [h\u2082]\n    have h\u2083 : \u2211 n in S, (a * (P n * X n) + b * P n) = a * \u2211 n in S, (P n * X n) + b * \u2211 n in S, P n := by\n      calc\n        \u2211 n in S, (a * (P n * X n) + b * P n) = \u2211 n in S, (a * (P n * X n)) + \u2211 n in S, (b * P n) := by\n          rw [Finset.sum_add_distrib]\n        _ = a * \u2211 n in S, (P n * X n) + \u2211 n in S, (b * P n) := by\n          have h\u2084 : \u2211 n in S, (a * (P n * X n)) = a * \u2211 n in S, (P n * X n) := by\n            rw [Finset.mul_sum]\n            <;>\n            simp [mul_assoc]\n          rw [h\u2084]\n        _ = a * \u2211 n in S, (P n * X n) + b * \u2211 n in S, P n := by\n          have h\u2085 : \u2211 n in S, (b * P n) = b * \u2211 n in S, P n := by\n            rw [Finset.mul_sum]\n            <;>\n            simp [mul_assoc]\n          rw [h\u2085]\n    rw [h\u2083]\n    have h\u2084 : \u2211 n in S, (P n * X n) = \u2211' n : \u2115, P n * X n := by\n      have h\u2085 : \u2200 n \u2209 S, P n * X n = 0 := by\n        intro n hn\n        have h\u2086 : P n = 0 := hS n hn\n        rw [h\u2086]\n        <;> simp\n      calc\n        \u2211 n in S, (P n * X n) = \u2211' n : \u2115, P n * X n := by\n          apply Eq.symm\n          apply tsum_eq_sum\n          intro n hn\n          exact h\u2085 n hn\n        _ = \u2211' n : \u2115, P n * X n := rfl\n    have h\u2085 : \u2211 n in S, P n = \u2211' n : \u2115, P n := by\n      have h\u2086 : \u2200 n \u2209 S, P n = 0 := by\n        intro n hn\n        exact hS n hn\n      calc\n        \u2211 n in S, P n = \u2211' n : \u2115, P n := by\n          apply Eq.symm\n          apply tsum_eq_sum\n          intro n hn\n          exact by\n            have h\u2087 : P n = 0 := h\u2086 n hn\n            simp [h\u2087]\n        _ = \u2211' n : \u2115, P n := rfl\n    rw [h\u2084, h\u2085]\n    have h\u2086 : \u2211' n : \u2115, P n * X n = \u03bc := hE\n    have h\u2087 : \u2211' n : \u2115, P n = 1 := hP_sum\n    rw [h\u2086, h\u2087]\n    <;> ring\n  exact h_sum_Y"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Next, we find the deviation from the mean, $Y - E[Y] = (aX + b) - (a\\mu + b) = a(X - \\mu)$.", "statement": "We assume:\n\u2022 X is a discrete random variable with expected value E[X] = \u03bc [tc_1]\n\u2022 Y = aX + b for some real constants a and b [tc_2]\n\u2022 E[Y] = a\u03bc + b [l1]\nTherefore, we conclude:\n\u2022 Y - E[Y] = a(X - \u03bc) [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (\u03bc \u03c3 : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (hVar : \u2211' n, P n * (X n - \u03bc)^2 = \u03c3^2)\n  (a b : \u211d) :\n  let Y := fun n => a * X n + b\n  let E_Y := \u2211' n, P n * Y n\n  \u2200 n, Y n - E_Y = a * (X n - \u03bc) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (\u03bc \u03c3 : \u211d) \n  (P : \u2115 \u2192 \u211d) \n  (X : \u2115 \u2192 \u211d)\n  (hP_nonneg : \u2200 n, 0 \u2264 P n)\n  (hP_sum : \u2211' n, P n = 1)\n  (hP_support : \u2203 S : Finset \u2115, \u2200 n \u2209 S, P n = 0)\n  (hE : \u2211' n, P n * X n = \u03bc)\n  (hVar : \u2211' n, P n * (X n - \u03bc)^2 = \u03c3^2)\n  (a b : \u211d) :\n  let Y := fun n => a * X n + b\n  let E_Y := \u2211' n, P n * Y n\n  \u2200 n, Y n - E_Y = a * (X n - \u03bc) := by\n  intro Y E_Y\n  have h_main : E_Y = a * \u03bc + b := by\n    obtain \u27e8S, hS\u27e9 := hP_support\n    have h1 : \u2211' n, P n * Y n = \u2211 n in S, P n * Y n := by\n      have h2 : \u2200 n \u2209 S, P n * Y n = 0 := by\n        intro n hn\n        have h3 : P n = 0 := hS n hn\n        rw [h3]\n        <;> simp [Y]\n        <;> ring_nf\n        <;> simp_all\n      calc\n        \u2211' n, P n * Y n = \u2211' n : \u2115, P n * Y n := rfl\n        _ = \u2211 n in S, P n * Y n := by\n          rw [tsum_eq_sum h2]\n          <;>\n          simp_all [Finset.sum_congr]\n          <;>\n          aesop\n    have h3 : \u2211' n, P n * X n = \u2211 n in S, P n * X n := by\n      have h4 : \u2200 n \u2209 S, P n * X n = 0 := by\n        intro n hn\n        have h5 : P n = 0 := hS n hn\n        rw [h5]\n        <;> simp\n      calc\n        \u2211' n, P n * X n = \u2211' n : \u2115, P n * X n := rfl\n        _ = \u2211 n in S, P n * X n := by\n          rw [tsum_eq_sum h4]\n          <;>\n          simp_all [Finset.sum_congr]\n          <;>\n          aesop\n    have h5 : \u2211' n, P n = \u2211 n in S, P n := by\n      have h6 : \u2200 n \u2209 S, P n = 0 := by\n        intro n hn\n        exact hS n hn\n      calc\n        \u2211' n, P n = \u2211' n : \u2115, P n := rfl\n        _ = \u2211 n in S, P n := by\n          rw [tsum_eq_sum h6]\n          <;>\n          simp_all [Finset.sum_congr]\n          <;>\n          aesop\n    have h7 : \u2211 n in S, P n * Y n = a * \u2211 n in S, P n * X n + b * \u2211 n in S, P n := by\n      calc\n        \u2211 n in S, P n * Y n = \u2211 n in S, (a * (P n * X n) + b * P n) := by\n          apply Finset.sum_congr rfl\n          intro n hn\n          have h8 : Y n = a * X n + b := by\n            simp [Y]\n          rw [h8]\n          ring_nf\n          <;>\n          simp_all [mul_assoc]\n          <;>\n          ring_nf\n          <;>\n          linarith\n        _ = \u2211 n in S, (a * (P n * X n) + b * P n) := rfl\n        _ = \u2211 n in S, (a * (P n * X n)) + \u2211 n in S, (b * P n) := by\n          rw [Finset.sum_add_distrib]\n        _ = a * \u2211 n in S, (P n * X n) + b * \u2211 n in S, P n := by\n          have h9 : \u2211 n in S, (a * (P n * X n)) = a * \u2211 n in S, (P n * X n) := by\n            rw [Finset.mul_sum]\n            <;>\n            apply Finset.sum_congr rfl\n            <;>\n            intros <;>\n            ring_nf\n          have h10 : \u2211 n in S, (b * P n) = b * \u2211 n in S, P n := by\n            rw [Finset.mul_sum]\n            <;>\n            apply Finset.sum_congr rfl\n            <;>\n            intros <;>\n            ring_nf\n          rw [h9, h10]\n          <;>\n          ring_nf\n    have h8 : \u2211' n, P n * Y n = a * \u03bc + b := by\n      calc\n        \u2211' n, P n * Y n = \u2211 n in S, P n * Y n := by rw [h1]\n        _ = a * \u2211 n in S, P n * X n + b * \u2211 n in S, P n := by rw [h7]\n        _ = a * (\u2211 n in S, P n * X n) + b * (\u2211 n in S, P n) := by ring\n        _ = a * (\u2211' n, P n * X n) + b * (\u2211' n, P n) := by\n          have h9 : \u2211 n in S, P n * X n = \u2211' n, P n * X n := by\n            rw [h3]\n          have h10 : \u2211 n in S, P n = \u2211' n, P n := by\n            rw [h5]\n          rw [h9, h10]\n        _ = a * \u03bc + b * 1 := by\n          rw [hE]\n          <;>\n          rw [hP_sum]\n          <;>\n          ring\n        _ = a * \u03bc + b := by ring\n    have h9 : E_Y = \u2211' n, P n * Y n := rfl\n    rw [h9]\n    exact h8\n  \n  have h_final : \u2200 n, Y n - E_Y = a * (X n - \u03bc) := by\n    intro n\n    have h1 : Y n = a * X n + b := by\n      simp [Y]\n    rw [h1]\n    have h2 : E_Y = a * \u03bc + b := h_main\n    rw [h2]\n    ring_nf\n    <;>\n    simp_all [Y]\n    <;>\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The setup of discrete random variable X with expectation \u03bc is correctly formalized with appropriate probability axioms and expectation condition.", "The linear transformation Y = aX + b is perfectly captured with the same mathematical meaning.", "The expected value E[Y] is defined correctly, but the explicit relationship E[Y] = a\u03bc + b mentioned in natural language [l1] is not stated, though it would be derivable.", "The main conclusion Y - E[Y] = a(X - \u03bc) is perfectly formalized as the theorem statement with identical mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Using this, the variance expression becomes $Var(Y) = E[(a(X-\\mu))^2] = a^2 E[(X-\\mu)^2]$.", "statement": "We assume:\n\u2022 The variance of a random variable Y is defined as Var(Y) = E[(Y - E[Y])^2] [def_1]\n\u2022 Y - E[Y] = a(X - \u03bc) [l2]\nTherefore, we conclude:\n\u2022 Var(Y) = a^2 * E[(X-\u03bc)^2] [l3].", "dependencies": ["def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (E : (\u211d \u2192 \u211d) \u2192 \u211d) -- expectation operator\n  (variance : (\u211d \u2192 \u211d) \u2192 \u211d) -- variance function\n  (X Y : \u211d \u2192 \u211d) -- random variables\n  (a \u03bc : \u211d) -- parameters\n  (h_var_def : \u2200 Z : \u211d \u2192 \u211d, variance Z = E (fun \u03c9 => (Z \u03c9 - E Z)^2))\n  (h_l2 : \u2200 \u03c9, Y \u03c9 - E Y = a * (X \u03c9 - \u03bc)) :\n  variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)\n  (variance : (\u211d \u2192 \u211d) \u2192 \u211d)\n  (X Y : \u211d \u2192 \u211d)\n  (a \u03bc : \u211d)\n  (h_var_def : \u2200 Z : \u211d \u2192 \u211d, variance Z = E (fun \u03c9 => (Z \u03c9 - E Z)^2))\n  (h_l2 : \u2200 \u03c9, Y \u03c9 - E Y = a * (X \u03c9 - \u03bc)) :\n  variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2) := by\n  have h1 : \u2200 \u03c9, (Y \u03c9 - E Y)^2 = a^2 * (X \u03c9 - \u03bc)^2 := by\n    intro \u03c9\n    have h1 : Y \u03c9 - E Y = a * (X \u03c9 - \u03bc) := h_l2 \u03c9\n    have h2 : (Y \u03c9 - E Y)^2 = (a * (X \u03c9 - \u03bc))^2 := by rw [h1]\n    have h3 : (a * (X \u03c9 - \u03bc))^2 = a^2 * (X \u03c9 - \u03bc)^2 := by ring\n    rw [h2, h3]\n  \n  have h2 : (fun \u03c9 => (Y \u03c9 - E Y)^2) = (fun \u03c9 => a^2 * (X \u03c9 - \u03bc)^2) := by\n    funext \u03c9\n    rw [h1 \u03c9]\n  \n  have h3 : E (fun \u03c9 => (Y \u03c9 - E Y)^2) = E (fun \u03c9 => a^2 * (X \u03c9 - \u03bc)^2) := by\n    rw [h2]\n  \n  have h4 : variance Y = E (fun \u03c9 => a^2 * (X \u03c9 - \u03bc)^2) := by\n    have h4\u2081 : variance Y = E (fun \u03c9 => (Y \u03c9 - E Y) ^ 2) := by\n      have h4\u2082 := h_var_def Y\n      exact h4\u2082\n    rw [h4\u2081]\n    rw [h3]\n    <;>\n    simp_all\n  \n  have h5 : E (fun \u03c9 => a^2 * (X \u03c9 - \u03bc)^2) = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2) := by\n    have h\u2085 : E (fun \u03c9 => a ^ 2 * (X \u03c9 - \u03bc) ^ 2) = a ^ 2 * E (fun \u03c9 => (X \u03c9 - \u03bc) ^ 2) := by\n      -- Use the fact that the expectation of a constant times a function is the constant times the expectation of the function\n      -- This step requires the linearity of the expectation operator, which is not given in the problem statement.\n      -- Therefore, we cannot proceed further without additional assumptions.\n      sorry\n    exact h\u2085\n  \n  have h6 : variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2) := by\n    calc\n      variance Y = E (fun \u03c9 => a ^ 2 * (X \u03c9 - \u03bc) ^ 2) := by rw [h4]\n      _ = a ^ 2 * E (fun \u03c9 => (X \u03c9 - \u03bc) ^ 2) := by rw [h5]\n      _ = a ^ 2 * E (fun \u03c9 => (X \u03c9 - \u03bc) ^ 2) := by rfl\n  \n  exact h6", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variance definition is correctly formalized with proper universal quantification and lambda notation for the expectation.", "The linear relationship Y - E[Y] = a(X - \u03bc) is accurately captured with universal quantification over the sample space.", "The conclusion Var(Y) = a^2 * E[(X-\u03bc)^2] is precisely represented in the theorem goal.", "The logical structure properly reflects the premise-conclusion relationship with appropriate hypotheses and goal.", "All mathematical operations, parameters, and relationships are consistently preserved between natural language and Lean formalization.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nexample :\n  \u00ac (\u2200 (E : (\u211d \u2192 \u211d) \u2192 \u211d) (variance : (\u211d \u2192 \u211d) \u2192 \u211d) (X Y : \u211d \u2192 \u211d) (a \u03bc : \u211d),\n      (\u2200 Z : \u211d \u2192 \u211d, variance Z = E (fun \u03c9 => (Z \u03c9 - E Z)^2)) \u2192\n      (\u2200 \u03c9, Y \u03c9 - E Y = a * (X \u03c9 - \u03bc)) \u2192\n      variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2)) :=\nby\n  have h_main : \u00ac (\u2200 (E : (\u211d \u2192 \u211d) \u2192 \u211d) (variance : (\u211d \u2192 \u211d) \u2192 \u211d) (X Y : \u211d \u2192 \u211d) (a \u03bc : \u211d),\n      (\u2200 Z : \u211d \u2192 \u211d, variance Z = E (fun \u03c9 => (Z \u03c9 - E Z)^2)) \u2192\n      (\u2200 \u03c9, Y \u03c9 - E Y = a * (X \u03c9 - \u03bc)) \u2192\n      variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2)) := by\n    intro h\n    have h\u2081 := h (fun _ => (1 : \u211d)) (fun _ => (1 : \u211d)) (fun \u03c9 => \u03c9) (fun _ => (1 : \u211d)) 0 0\n      (by\n        intro Z\n        simp [sub_sq]\n        <;>\n        norm_num\n        <;>\n        simp_all [Function.funext_iff]\n        <;>\n        norm_num\n        <;>\n        aesop)\n      (by\n        intro \u03c9\n        norm_num\n        <;>\n        simp_all [Function.funext_iff]\n        <;>\n        norm_num\n        <;>\n        aesop)\n    norm_num at h\u2081\n    <;>\n    simp_all [Function.funext_iff]\n    <;>\n    norm_num\n    <;>\n    aesop\n  exact h_main"}, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "Since we know that $E[(X-\\mu)^2]$ is the definition of $Var(X)$", "statement": "Definition:\n\u2022 The variance of a random variable X with mean \u03bc is defined as Var(X) = E[(X-\u03bc)^2] [def_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (p : Fin n \u2192 \u211d) (X : Fin n \u2192 \u211d) (\u03bc : \u211d)\n(hp_nonneg : \u2200 i, 0 \u2264 p i)\n(hp_sum : \u2211 i, p i = 1)\n(hE : \u2211 i, p i * X i = \u03bc)\n\ndef variance : \u211d := \u2211 i, p i * (X i - \u03bc)^2", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the condition by defining X as a discrete random variable with finite support, including probability weights p and the mean condition. The additional constraints (hp_nonneg, hp_sum) are mathematically necessary for a proper probability distribution and don't contradict the natural language.", "The Lean definition of variance as \u2211 i, p i * (X i - \u03bc)^2 is exactly the discrete formulation of E[(X-\u03bc)\u00b2]. This is a perfectly valid and complete formalization of the variance definition."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "Since we know that $E[(X-\\mu)^2]$ is the definition of $Var(X)$, which is given as $\\sigma^2$", "statement": "We assume:\n\u2022 X is a discrete random variable with expected value E[X] = \u03bc and variance Var(X) = \u03c3\u00b2 [tc_1]\n\u2022 The variance of X is defined as Var(X) = E[(X-\u03bc)^2] [def_2]\nTherefore, we conclude:\n\u2022 E[(X - \u03bc)^2] = \u03c3^2 [l4].", "dependencies": ["tc_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (n : \u2115) (p : Fin n \u2192 \u211d) (X : Fin n \u2192 \u211d) (\u03bc \u03c3 : \u211d)\n  (hp_nonneg : \u2200 i, 0 \u2264 p i)\n  (hp_sum : \u2211 i, p i = 1)\n  (hE : \u2211 i, p i * X i = \u03bc)\n  (hVar_def : \u2200 \u03bc, \u2211 i, p i * (X i - \u03bc)^2 = (\u2211 i, p i * (X i - \u03bc)^2))\n  (hVar : \u2211 i, p i * (X i - \u03bc)^2 = \u03c3^2) :\n  \u2211 i, p i * (X i - \u03bc)^2 = \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (n : \u2115) (p : Fin n \u2192 \u211d) (X : Fin n \u2192 \u211d) (\u03bc \u03c3 : \u211d)\n  (hp_nonneg : \u2200 i, 0 \u2264 p i)\n  (hp_sum : \u2211 i, p i = 1)\n  (hE : \u2211 i, p i * X i = \u03bc)\n  (hVar_def : \u2200 \u03bc, \u2211 i, p i * (X i - \u03bc)^2 = (\u2211 i, p i * (X i - \u03bc)^2))\n  (hVar : \u2211 i, p i * (X i - \u03bc)^2 = \u03c3^2) :\n  \u2211 i, p i * (X i - \u03bc)^2 = \u03c3^2 := by\n  have h_main : \u2211 i : Fin n, p i * (X i - \u03bc) ^ 2 = \u03c3 ^ 2 := by\n    have h\u2081 : \u2211 i : Fin n, p i * (X i - \u03bc) ^ 2 = \u03c3 ^ 2 := by\n      simpa using hVar\n    exact h\u2081\n  \n  simpa using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The discrete random variable setup with expectation E[X] = \u03bc is correctly modeled using finite probability distributions with appropriate constraints.", "The variance definition is not properly formalized. The natural language defines Var(X) = E[(X-\u03bc)\u00b2], but hVar_def is just a tautology A = A rather than establishing the relationship between variance and expectation of squared deviations.", "The variance value Var(X) = \u03c3\u00b2 is correctly represented as the sum \u2211 i, p i * (X i - \u03bc)^2 = \u03c3^2.", "The conclusion E[(X - \u03bc)\u00b2] = \u03c3\u00b2 is correctly translated, but the theorem becomes trivial since it's identical to hypothesis hVar, rather than following from the variance definition as intended in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The discrete random variable setup with expectation E[X] = \u03bc is correctly modeled using finite probability distributions with appropriate constraints.', 'The variance definition is not properly formalized. The natural language defines Var(X) = E[(X-\u03bc)\u00b2], but hVar_def is just a tautology A = A rather than establishing the relationship between variance and expectation of squared deviations.', 'The variance value Var(X) = \u03c3\u00b2 is correctly represented as the sum \u2211 i, p i * (X i - \u03bc)^2 = \u03c3^2.', \"The conclusion E[(X - \u03bc)\u00b2] = \u03c3\u00b2 is correctly translated, but the theorem becomes trivial since it's identical to hypothesis hVar, rather than following from the variance definition as intended in the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "we can conclude that $Var(Y) = a^2 \\sigma^2$.", "statement": "We assume:\n\u2022 Var(Y) = a^2 * E[(X-\u03bc)^2] [l3]\n\u2022 E[(X - \u03bc)^2] = \u03c3^2 [l4]\nTherefore, we conclude:\n\u2022 Var(Y) = a^2 * \u03c3^2 [ts_1].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (E : (\u211d \u2192 \u211d) \u2192 \u211d) -- expectation operator\n  (variance : (\u211d \u2192 \u211d) \u2192 \u211d) -- variance function\n  (X Y : \u211d \u2192 \u211d) -- random variables\n  (a b \u03bc \u03c3 : \u211d) -- parameters\n  -- Given: Var(Y) = a\u00b2 * E[(X-\u03bc)\u00b2]\n  (h_l3 : variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2))\n  -- Given: E[(X - \u03bc)\u00b2] = \u03c3\u00b2  \n  (h_l4 : E (fun \u03c9 => (X \u03c9 - \u03bc)^2) = \u03c3^2) :\n  -- Conclusion: Var(Y) = a\u00b2 * \u03c3\u00b2\n  variance Y = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (E : (\u211d \u2192 \u211d) \u2192 \u211d)\n  (variance : (\u211d \u2192 \u211d) \u2192 \u211d)\n  (X Y : \u211d \u2192 \u211d)\n  (a b \u03bc \u03c3 : \u211d)\n  (h_l3 : variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2))\n  (h_l4 : E (fun \u03c9 => (X \u03c9 - \u03bc)^2) = \u03c3^2) :\n  variance Y = a^2 * \u03c3^2 := by\n  have h_main : variance Y = a^2 * \u03c3^2 := by\n    calc\n      variance Y = a^2 * E (fun \u03c9 => (X \u03c9 - \u03bc)^2) := h_l3\n      _ = a^2 * \u03c3^2 := by\n        rw [h_l4]\n        <;> ring\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Function and variable declarations correctly capture all entities mentioned in natural language. Extra parameter 'b' is harmless.", "Assumption l3 is perfectly formalized using standard probability theory notation with explicit function representation.", "Assumption l4 is correctly formalized with consistent notation matching l3.", "The conclusion statement exactly matches the natural language goal.", "The logical structure (assumptions \u2192 conclusion) is preserved perfectly in the theorem statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    