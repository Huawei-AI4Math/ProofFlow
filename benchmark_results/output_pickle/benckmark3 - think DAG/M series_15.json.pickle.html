
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=1$ and the recurrence relation $a_n = a_{n-1} + a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the inequality $a_n \leq 2^{n-1}$ holds.

Proof: For $n=1$, we have $a_1=1$. The inequality is $1 \leq 2^{1-1}=2^0=1$. This holds. For $n=2$, we have $a_2=1$. The inequality is $1 \leq 2^{2-1}=2^1=2$. This also holds. Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j \leq 2^{j-1}$ for $1 \leq j \leq k$. We must prove the inequality holds for $n=k+1$, i.e., $a_{k+1} \leq 2^{k}$. From the recurrence relation, we have $a_{k+1} = a_k + a_{k-1}$. By the inductive hypothesis, we know that $a_k \leq 2^{k-1}$ and $a_{k-1} \leq 2^{k-2}$. Therefore, we can write $a_{k+1} \leq 2^{k-1} + 2^{k-2}$. Now we simplify the right-hand side: $a_{k+1} \leq 2^{k-2}(2+1) = 3 \cdot 2^{k-2}$. We need to show that $3 \cdot 2^{k-2} \leq 2^k$. Dividing both sides by $2^{k-2}$ gives $3 \leq 2^2=4$. This is true. Thus, $a_{k+1} \leq 2^{k}$. By the principle of **strong mathematical induction**, the inequality $a_n \leq 2^{n-1}$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=1$ and the recurrence relation $a_n = a_{n-1} + a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence of integers $(a_n)_{n \\geq 1}$ is defined by:\n  \u2022 $a_1 = 1$\n  \u2022 $a_2 = 1$\n  \u2022 For all integers $n \\geq 3$, $a_n = a_{n-1} + a_{n-2}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition $a_1 = 1$ matches `h1 : a 1 = 1`, but there's a type difference: the natural language refers to integers while Lean uses `\u2115 \u2192 \u211d` (natural numbers to reals). This is a minor structural difference that doesn't affect the logical meaning.", "The condition $a_2 = 1$ matches `h2 : a 2 = 1`, with the same minor type inconsistency as above - integers vs natural numbers to reals.", "The recurrence relation condition perfectly matches between natural language and Lean formalization, both stating the same mathematical relationship for $n \u2265 3$.", "The natural language conclusion states that the sequence is defined as a recurrence relation, but the Lean proposition `\u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1)` is about an upper bound property of the sequence, which is completely different from just defining the recurrence relation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The condition $a_1 = 1$ matches `h1 : a 1 = 1`, but there's a type difference: the natural language refers to integers while Lean uses `\u2115 \u2192 \u211d` (natural numbers to reals). This is a minor structural difference that doesn't affect the logical meaning.\", 'The condition $a_2 = 1$ matches `h2 : a 2 = 1`, with the same minor type inconsistency as above - integers vs natural numbers to reals.', 'The recurrence relation condition perfectly matches between natural language and Lean formalization, both stating the same mathematical relationship for $n \u2265 3$.', 'The natural language conclusion states that the sequence is defined as a recurrence relation, but the Lean proposition `\u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1)` is about an upper bound property of the sequence, which is completely different from just defining the recurrence relation.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, we have $a_1=1$. The inequality is $1 \\leq 2^{1-1}=2^0=1$. This holds.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined with $a_1=1$ [tc_1].\nTherefore, we conclude:\n\u2022 $a_1 \\leq 2^{1-1}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by sorry\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  a 1 \u2264 2^(1 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by\n  have h_main : \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n    intro n hn\n    have h\u2083 : \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h1] at hn \u22a2\n        <;>\n        simp_all [pow_zero]\n        <;>\n        norm_num\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h2] at hn \u22a2\n        <;>\n        simp_all [pow_one]\n        <;>\n        norm_num\n      | 3 =>\n        -- Base case: n = 3\n        have h\u2084 : a 3 = a 2 + a 1 := by\n          have h\u2085 := h_rec 3 (by norm_num)\n          norm_num at h\u2085 \u22a2\n          <;> linarith\n        have h\u2085 : a 3 = 2 := by\n          rw [h\u2084]\n          norm_num [h1, h2]\n          <;> linarith\n        have h\u2086 : (2 : \u211d) ^ (3 - 1 : \u2115) = (4 : \u211d) := by norm_num\n        have h\u2087 : a 3 \u2264 (2 : \u211d) ^ (3 - 1 : \u2115) := by\n          rw [h\u2085]\n          norm_num [h\u2086]\n          <;>\n          simp_all [pow_succ]\n          <;>\n          norm_num\n          <;>\n          linarith\n        simpa using h\u2087\n      | n + 4 =>\n        -- Inductive step for n \u2265 4\n        have h\u2084 : a (n + 4) = a (n + 3) + a (n + 2) := by\n          have h\u2085 := h_rec (n + 4) (by omega)\n          norm_num at h\u2085 \u22a2\n          <;>\n          (try omega) <;>\n          (try ring_nf at h\u2085 \u22a2 <;> linarith)\n          <;>\n          (try simp_all [Nat.succ_eq_add_one])\n          <;>\n          (try omega)\n        have h\u2085 : a (n + 3) \u2264 (2 : \u211d) ^ ((n + 3) - 1 : \u2115) := by\n          have h\u2086 : (n + 3 : \u2115) \u2265 1 := by omega\n          have h\u2087 : a (n + 3) \u2264 (2 : \u211d) ^ ((n + 3) - 1 : \u2115) := by\n            apply ih (n + 3)\n            <;> omega\n          exact h\u2087\n        have h\u2086 : a (n + 2) \u2264 (2 : \u211d) ^ ((n + 2) - 1 : \u2115) := by\n          have h\u2087 : (n + 2 : \u2115) \u2265 1 := by omega\n          have h\u2088 : a (n + 2) \u2264 (2 : \u211d) ^ ((n + 2) - 1 : \u2115) := by\n            apply ih (n + 2)\n            <;> omega\n          exact h\u2088\n        have h\u2087 : (2 : \u211d) ^ ((n + 2) - 1 : \u2115) \u2264 (2 : \u211d) ^ ((n + 3) - 1 : \u2115) := by\n          have h\u2088 : ((n + 2) - 1 : \u2115) \u2264 ((n + 3) - 1 : \u2115) := by\n            omega\n          exact pow_le_pow_right (by norm_num) h\u2088\n        calc\n          a (n + 4) = a (n + 3) + a (n + 2) := by rw [h\u2084]\n          _ \u2264 (2 : \u211d) ^ ((n + 3) - 1 : \u2115) + (2 : \u211d) ^ ((n + 2) - 1 : \u2115) := by\n            gcongr <;> simp_all\n          _ \u2264 (2 : \u211d) ^ ((n + 3) - 1 : \u2115) + (2 : \u211d) ^ ((n + 3) - 1 : \u2115) := by\n            gcongr <;> simp_all\n          _ = 2 * (2 : \u211d) ^ ((n + 3) - 1 : \u2115) := by ring\n          _ = (2 : \u211d) ^ 1 * (2 : \u211d) ^ ((n + 3) - 1 : \u2115) := by norm_num\n          _ = (2 : \u211d) ^ (1 + ((n + 3) - 1 : \u2115)) := by\n            rw [\u2190 pow_add]\n            <;> ring_nf\n          _ = (2 : \u211d) ^ ((n + 4) - 1 : \u2115) := by\n            have h\u2088 : 1 + ((n + 3) - 1 : \u2115) = (n + 4) - 1 := by\n              cases n with\n              | zero => norm_num\n              | succ n =>\n                simp [Nat.succ_eq_add_one, add_assoc]\n                <;> ring_nf at *\n                <;> omega\n            rw [h\u2088]\n          _ = (2 : \u211d) ^ ((n + 4) - 1 : \u2115) := by rfl\n    exact h\u2083 n hn\n  intro n hn\n  have h\u2081 : a n \u2264 (2 : \u211d)^(n - 1) := h_main n hn\n  have h\u2082 : (2 : \u211d)^(n - 1) = (2 : \u211d)^(n - 1) := rfl\n  have h\u2083 : (a n : \u211d) \u2264 (2 : \u211d)^(n - 1) := by exact_mod_cast h\u2081\n  have h\u2084 : (a n : \u211d) \u2264 (2 : \u211d)^(n - 1) := by exact_mod_cast h\u2081\n  norm_cast at h\u2083 \u22a2\n  <;> simp_all [pow_succ]\n  <;> norm_num\n  <;> linarith\n  \ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  a 1 \u2264 2^(1 - 1) := by\n  have h\u2081 : a 1 \u2264 (2 : \u211d)^(1 - 1) := by\n    norm_num [h1]\n    <;>\n    simp_all [pow_zero]\n    <;>\n    norm_num\n  norm_num at h\u2081 \u22a2\n  <;>\n  simp_all [pow_zero]\n  <;>\n  norm_num\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition with a_1 = 1. The additional conditions (a_2 = 1 and recurrence relation) provide extra context that doesn't contradict the natural language but rather completes the sequence definition, which appears to be a Fibonacci-like sequence.", "The conclusion a_1 \u2264 2^(1-1) is perfectly captured in the Lean formalization. The theorem l1 correctly states this inequality with appropriate assumptions about the sequence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we have $a_2=1$. The inequality is $1 \\leq 2^{2-1}=2^1=2$. This also holds.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined with $a_2=1$ [tc_1].\nTherefore, we conclude:\n\u2022 $a_2 \\leq 2^{2-1}$ [l2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by sorry\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  a 2 \u2264 2^(2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 2^(n - 1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h1]\n        <;>\n        simp_all [Nat.pow_succ]\n        <;>\n        norm_num\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h2]\n        <;>\n        simp_all [Nat.pow_succ]\n        <;>\n        norm_num\n      | 3 =>\n        -- Base case: n = 3\n        have h3 : a 3 = a 2 + a 1 := by\n          have h3' := h_rec 3 (by norm_num)\n          norm_num at h3' \u22a2\n          <;> linarith\n        rw [h3]\n        norm_num [h1, h2]\n        <;>\n        simp_all [Nat.pow_succ]\n        <;>\n        norm_num\n      | n + 4 =>\n        -- Inductive step for n \u2265 4\n        have h_rec_n := h_rec (n + 4) (by omega)\n        have h1' : a (n + 4) = a (n + 3) + a (n + 2) := by\n          have h1'' := h_rec (n + 4) (by omega)\n          have h2'' : (n + 4 : \u2115) - 1 = n + 3 := by\n            omega\n          have h3'' : (n + 4 : \u2115) - 2 = n + 2 := by\n            omega\n          rw [h1'']\n          <;> simp [h2'', h3'']\n          <;> ring_nf at *\n          <;> simp_all\n          <;> linarith\n        rw [h1']\n        have h2' : a (n + 3) \u2264 (2 : \u211d) ^ ((n + 3) - 1) := by\n          have h3' : (n + 3 : \u2115) \u2265 1 := by omega\n          have h4' : a (n + 3) \u2264 (2 : \u211d) ^ ((n + 3) - 1) := by\n            apply ih (n + 3)\n            <;> omega\n          exact h4'\n        have h3' : a (n + 2) \u2264 (2 : \u211d) ^ ((n + 2) - 1) := by\n          have h4' : (n + 2 : \u2115) \u2265 1 := by omega\n          have h5' : a (n + 2) \u2264 (2 : \u211d) ^ ((n + 2) - 1) := by\n            apply ih (n + 2)\n            <;> omega\n          exact h5'\n        have h4' : (2 : \u211d) ^ ((n + 3) - 1 : \u2115) = (2 : \u211d) ^ (n + 2 : \u2115) := by\n          norm_num\n          <;> ring_nf at *\n          <;> simp_all [Nat.cast_add, Nat.cast_one]\n          <;> norm_num\n          <;> linarith\n        have h5' : (2 : \u211d) ^ ((n + 2) - 1 : \u2115) = (2 : \u211d) ^ (n + 1 : \u2115) := by\n          norm_num\n          <;> ring_nf at *\n          <;> simp_all [Nat.cast_add, Nat.cast_one]\n          <;> norm_num\n          <;> linarith\n        have h6' : (2 : \u211d) ^ (n + 4 - 1 : \u2115) = (2 : \u211d) ^ (n + 3 : \u2115) := by\n          norm_num\n          <;> ring_nf at *\n          <;> simp_all [Nat.cast_add, Nat.cast_one]\n          <;> norm_num\n          <;> linarith\n        have h7' : (2 : \u211d) ^ (n + 2 : \u2115) + (2 : \u211d) ^ (n + 1 : \u2115) \u2264 (2 : \u211d) ^ (n + 3 : \u2115) := by\n          have h8' : (2 : \u211d) ^ (n + 3 : \u2115) = (2 : \u211d) ^ (n + 1 : \u2115) * 4 := by\n            calc\n              (2 : \u211d) ^ (n + 3 : \u2115) = (2 : \u211d) ^ (n + 1 + 2 : \u2115) := by ring_nf\n              _ = (2 : \u211d) ^ (n + 1 : \u2115) * (2 : \u211d) ^ 2 := by\n                rw [pow_add]\n                <;> ring_nf\n              _ = (2 : \u211d) ^ (n + 1 : \u2115) * 4 := by norm_num\n          have h9' : (2 : \u211d) ^ (n + 2 : \u2115) = (2 : \u211d) ^ (n + 1 : \u2115) * 2 := by\n            calc\n              (2 : \u211d) ^ (n + 2 : \u2115) = (2 : \u211d) ^ (n + 1 + 1 : \u2115) := by ring_nf\n              _ = (2 : \u211d) ^ (n + 1 : \u2115) * (2 : \u211d) ^ 1 := by\n                rw [pow_add]\n                <;> ring_nf\n              _ = (2 : \u211d) ^ (n + 1 : \u2115) * 2 := by norm_num\n          rw [h8', h9']\n          nlinarith [pow_pos (by norm_num : (0 : \u211d) < 2) (n + 1)]\n        calc\n          a (n + 3) + a (n + 2) \u2264 (2 : \u211d) ^ ((n + 3) - 1 : \u2115) + (2 : \u211d) ^ ((n + 2) - 1 : \u2115) := by\n            linarith\n          _ = (2 : \u211d) ^ (n + 2 : \u2115) + (2 : \u211d) ^ (n + 1 : \u2115) := by\n            rw [h4', h5']\n            <;> ring_nf at *\n            <;> simp_all [Nat.cast_add, Nat.cast_one]\n            <;> norm_num\n            <;> linarith\n          _ \u2264 (2 : \u211d) ^ (n + 3 : \u2115) := by\n            exact h7'\n          _ = (2 : \u211d) ^ (n + 4 - 1 : \u2115) := by\n            rw [h6']\n            <;> ring_nf at *\n            <;> simp_all [Nat.cast_add, Nat.cast_one]\n            <;> norm_num\n            <;> linarith\n    exact h n hn\n  intro n hn\n  have h\u2081 : a n \u2264 (2 : \u211d)^(n - 1) := h_main n hn\n  have h\u2082 : (2 : \u211d)^(n - 1) = (2 : \u211d)^(n - 1) := rfl\n  norm_cast at h\u2081 \u22a2\n  <;>\n  (try simp_all [Nat.pow_succ]) <;>\n  (try norm_num) <;>\n  (try linarith) <;>\n  (try omega) <;>\n  (try ring_nf at *) <;>\n  (try simp_all [Nat.cast_add, Nat.cast_one]) <;>\n  (try norm_num) <;>\n  (try linarith)\n  <;>\n  (try\n    {\n      cases n with\n      | zero => contradiction\n      | succ n =>\n        simp_all [Nat.pow_succ]\n        <;>\n        norm_num\n        <;>\n        linarith\n    })\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  a 2 \u2264 2^(2 - 1) := by\n  have h : a 2 \u2264 (2 : \u211d)^(2 - 1) := by\n    norm_num [h2]\n    <;>\n    simp_all [Nat.pow_succ]\n    <;>\n    norm_num\n  norm_num at h \u22a2\n  <;>\n  (try simp_all [Nat.pow_succ]) <;>\n  (try norm_num) <;>\n  (try linarith) <;>\n  (try omega) <;>\n  (try ring_nf at *) <;>\n  (try simp_all [Nat.cast_add, Nat.cast_one]) <;>\n  (try norm_num) <;>\n  (try linarith)\n  <;>\n  (try\n    {\n      cases n with\n      | zero => contradiction\n      | succ n =>\n        simp_all [Nat.pow_succ]\n        <;>\n        norm_num\n        <;>\n        linarith\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition in tc_1 includes additional conditions (a 1 = 1 and recurrence relation) not mentioned in the natural language, but these are logically consistent extra details that properly define the sequence. The condition a 2 = 1 is correctly captured.", "The conclusion a 2 \u2264 2^(2 - 1) is captured exactly in theorem l2, matching the natural language statement perfectly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "assume the inequality holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j \\leq 2^{j-1}$ for $1 \\leq j \\leq k$.", "statement": "Definition:\n\u2022 Let $k$ be an integer such that $k \\geq 2$. We assume the inductive hypothesis (IH) that for all integers $j$ with $1 \\leq j \\leq k$, the inequality $a_j \\leq 2^{j-1}$ holds [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\nvariable (k : \u2115)\nvariable (h_k : k \u2265 2)\nvariable (h_IH : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies k as an integer, but Lean uses \u2115 (natural numbers). While \u2115 \u2286 \u2124 and the constraint k \u2265 2 ensures k is a positive integer, this is a type difference that represents the same mathematical concept but with a more restrictive type in Lean.", "The Lean formalization perfectly captures the inductive hypothesis with the same logical structure: for all j satisfying the range condition, the inequality holds.", "The conclusion is identical to the condition in this definitional context, and Lean captures this appropriately."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relation, we have $a_{k+1} = a_k + a_{k-1}$.", "statement": "We assume:\n\u2022 For all integers $n \\geq 3$, $a_n = a_{n-1} + a_{n-2}$ [tc_1].\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = a_k + a_{k-1}$ [l3].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) (k : \u2115) (hk : k \u2265 2) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  a (k + 1) = a k + a (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) (k : \u2115) (hk : k \u2265 2) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  a (k + 1) = a k + a (k - 1) := by\n  have h\u2081 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : k + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h\u2082 : a (k + 1) = a ((k + 1) - 1) + a ((k + 1) - 2) := by\n    have h\u2082 : a (k + 1) = a ((k + 1) - 1) + a ((k + 1) - 2) := by\n      have h\u2083 : (k + 1 : \u2115) \u2265 3 := by exact_mod_cast h\u2081\n      have h\u2084 : a (k + 1) = a ((k + 1) - 1) + a ((k + 1) - 2) := by\n        apply h_rec\n        <;> omega\n      exact h\u2084\n    exact h\u2082\n  \n  have h\u2083 : (k + 1) - 1 = k := by\n    have h\u2083 : (k + 1) - 1 = k := by\n      have h\u2084 : k + 1 \u2265 1 := by omega\n      have h\u2085 : (k + 1) - 1 = k := by\n        omega\n      exact h\u2085\n    exact h\u2083\n  \n  have h\u2084 : (k + 1) - 2 = k - 1 := by\n    have h\u2084 : k \u2265 2 := hk\n    have h\u2085 : (k + 1) - 2 = k - 1 := by\n      have h\u2086 : k \u2265 1 := by omega\n      -- Use the fact that k \u2265 1 to simplify the expression\n      have h\u2087 : (k + 1) - 2 = k - 1 := by\n        cases k with\n        | zero => contradiction -- k cannot be zero since k \u2265 2\n        | succ k' =>\n          cases k' with\n          | zero => contradiction -- k cannot be one since k \u2265 2\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc] at h\u2084 \u22a2\n            <;> ring_nf at *\n            <;> omega\n      exact h\u2087\n    exact h\u2085\n  \n  have h\u2085 : a (k + 1) = a k + a (k - 1) := by\n    have h\u2085 : a (k + 1) = a ((k + 1) - 1) + a ((k + 1) - 2) := h\u2082\n    have h\u2086 : (k + 1) - 1 = k := h\u2083\n    have h\u2087 : (k + 1) - 2 = k - 1 := h\u2084\n    rw [h\u2085]\n    rw [h\u2086]\n    rw [h\u2087]\n    <;>\n    (try ring_nf) <;>\n    (try norm_num) <;>\n    (try simp_all [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]) <;>\n    (try linarith)\n  \n  apply h\u2085", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the logical and mathematical content from the natural language. The use of natural numbers (\u2115) instead of integers is appropriate for sequence indexing, and the addition of the real number codomain (\u211d) for the sequence is a reasonable mathematical specification that doesn't contradict the natural language. The logical structure, assumptions, and conclusion are all faithfully represented."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we know that $a_k \\leq 2^{k-1}$ and $a_{k-1} \\leq 2^{k-2}$.", "statement": "We assume:\n\u2022 For a fixed integer $k \\ge 2$, the inductive hypothesis (IH) states that for all integers $j$ with $1 \\leq j \\leq k$, $a_j \\leq 2^{j-1}$ holds [def_1].\nTherefore, we conclude:\n\u2022 $a_k \\leq 2^{k-1}$ and $a_{k-1} \\leq 2^{k-2}$ [l4].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_IH : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) :\n  a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (h_k : k \u2265 2)\n  (h_IH : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j \u2264 2^(j - 1)) :\n  a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2) := by\n  have h\u2081 : a k \u2264 (2 : \u211d)^(k - 1) := by\n    have h\u2082 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor\n      \u00b7 -- Prove 1 \u2264 k\n        omega\n      \u00b7 -- Prove k \u2264 k\n        linarith\n    have h\u2083 : a k \u2264 (2 : \u211d)^(k - 1) := by\n      have h\u2084 : a k \u2264 (2 : \u211d)^(k - 1) := by\n        -- Use the inductive hypothesis with j = k\n        have h\u2085 : a k \u2264 (2 : \u211d)^(k - 1) := by\n          specialize h_IH k \u27e8by omega, by linarith\u27e9\n          -- Simplify the expression to match the required form\n          simpa [pow_succ] using h_IH\n        exact h\u2085\n      exact h\u2084\n    exact h\u2083\n  \n  have h\u2082 : a (k - 1) \u2264 (2 : \u211d)^(k - 2) := by\n    have h\u2083 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2084 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2085 : k \u2265 2 := h_k\n        have h\u2086 : (k : \u2115) - 1 \u2265 1 := by\n          omega\n        omega\n      have h\u2085 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h\u2084, h\u2085\u27e9\n    have h\u2084 : a (k - 1) \u2264 (2 : \u211d)^((k - 1 : \u2115) - 1) := by\n      have h\u2085 : a (k - 1) \u2264 (2 : \u211d)^((k - 1 : \u2115) - 1) := by\n        -- Use the inductive hypothesis with j = k - 1\n        have h\u2086 : a (k - 1) \u2264 (2 : \u211d)^((k - 1 : \u2115) - 1) := by\n          specialize h_IH (k - 1) h\u2083\n          -- Simplify the expression to match the required form\n          simpa [pow_succ] using h_IH\n        exact h\u2086\n      exact h\u2085\n    have h\u2085 : (2 : \u211d)^((k - 1 : \u2115) - 1) = (2 : \u211d)^(k - 2) := by\n      have h\u2086 : (k : \u2115) \u2265 2 := h_k\n      have h\u2087 : (k - 1 : \u2115) - 1 = k - 2 := by\n        have h\u2088 : k \u2265 2 := h_k\n        have h\u2089 : (k : \u2115) - 1 \u2265 1 := by omega\n        have h\u2081\u2080 : (k - 1 : \u2115) - 1 = k - 2 := by\n          cases k with\n          | zero => omega\n          | succ k' =>\n            cases k' with\n            | zero => omega\n            | succ k'' =>\n              simp [Nat.succ_eq_add_one, Nat.add_assoc] at h\u2088 \u22a2\n              <;> ring_nf at *\n              <;> omega\n        exact h\u2081\u2080\n      rw [h\u2087]\n      <;> simp [pow_succ]\n      <;> ring_nf\n      <;> norm_num\n    rw [h\u2085] at h\u2084\n    exact h\u2084\n  \n  have h_main : a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2) := by\n    constructor\n    \u00b7 -- Prove a k \u2264 2^(k - 1)\n      simpa using h\u2081\n    \u00b7 -- Prove a (k - 1) \u2264 2^(k - 2)\n      simpa using h\u2082\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The inductive hypothesis is correctly formalized with proper quantification and bounds", "The constraint k \u2265 2 is accurately represented", "The conclusion with both inequalities is precisely captured", "The sequence is appropriately typed, with natural numbers being more precise than the general 'integers' mentioned in natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, we can write $a_{k+1} \\leq 2^{k-1} + 2^{k-2}$.", "statement": "We assume:\n\u2022 $a_{k+1} = a_k + a_{k-1}$ [l3].\n\u2022 $a_k \\leq 2^{k-1}$ and $a_{k-1} \\leq 2^{k-2}$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} \\leq 2^{k-1} + 2^{k-2}$ [l5].", "dependencies": ["l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l3 : a (k + 1) = a k + a (k - 1))\n  (l4 : a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2)) :\n  a (k + 1) \u2264 2^(k - 1) + 2^(k - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l3 : a (k + 1) = a k + a (k - 1))\n  (l4 : a k \u2264 2^(k - 1) \u2227 a (k - 1) \u2264 2^(k - 2)) :\n  a (k + 1) \u2264 2^(k - 1) + 2^(k - 2) := by\n  have h_sum_le : a k + a (k - 1) \u2264 (2 : \u211d)^(k - 1) + (2 : \u211d)^(k - 2) := by\n    have h\u2081 : a k \u2264 (2 : \u211d)^(k - 1) := by\n      exact_mod_cast l4.1\n    have h\u2082 : a (k - 1) \u2264 (2 : \u211d)^(k - 2) := by\n      exact_mod_cast l4.2\n    -- Add the two inequalities to get the desired result\n    linarith\n  \n  have h_main : a (k + 1) \u2264 (2 : \u211d)^(k - 1) + (2 : \u211d)^(k - 2) := by\n    have h\u2081 : a (k + 1) = a k + a (k - 1) := l3\n    rw [h\u2081]\n    exact h_sum_le\n  \n  -- Since the goal uses natural number powers, we need to ensure the coercion is handled correctly.\n  -- In Lean, `(2 : \u211d)^(k - 1)` is the same as `(2 : \u211d)^(k - 1 : \u2115)`, so we can directly use `h_main`.\n  simpa [pow_add, pow_one, mul_comm] using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Function and variable declarations correctly capture the implicit sequence and index from natural language", "The constraint k \u2265 2 is an appropriate additional condition that ensures mathematical validity without contradicting the natural language", "The recurrence relation is perfectly translated with correct function notation", "The conjunction of inequalities exactly matches the natural language assumptions", "The conclusion inequality is precisely formalized"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Now we simplify the right-hand side: $a_{k+1} \\leq 2^{k-2}(2+1) = 3 \\cdot 2^{k-2}$.", "statement": "We assume:\n\u2022 $a_{k+1} \\leq 2^{k-1} + 2^{k-2}$ [l5].\nTherefore, we conclude:\n\u2022 $a_{k+1} \\leq 3 \\cdot 2^{k-2}$ [l6].", "dependencies": ["l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : a (k + 1) \u2264 2^(k - 1) + 2^(k - 2)) :\n  a (k + 1) \u2264 3 * 2^(k - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : a (k + 1) \u2264 2^(k - 1) + 2^(k - 2)) :\n  a (k + 1) \u2264 3 * 2^(k - 2) := by\n  have h1 : (2 : \u2115) ^ (k - 1) = 2 * 2 ^ (k - 2) := by\n    have h\u2081 : k - 1 = (k - 2) + 1 := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : k - 2 + 2 = k := by\n        have h\u2084 : k \u2265 2 := hk\n        omega\n      have h\u2084 : k - 1 = (k - 2) + 1 := by\n        omega\n      exact h\u2084\n    rw [h\u2081]\n    simp [pow_add, pow_one, mul_comm]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [Nat.pow_succ]\n    <;> ring_nf at *\n    <;> omega\n  \n  have h2 : (2 : \u2115) ^ (k - 1) + (2 : \u2115) ^ (k - 2) = 3 * 2 ^ (k - 2) := by\n    have h\u2082 : (2 : \u2115) ^ (k - 1) = 2 * 2 ^ (k - 2) := h1\n    rw [h\u2082]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp [pow_add, pow_one, mul_assoc]\n    <;> ring_nf at *\n    <;> omega\n  \n  have h3 : a (k + 1) \u2264 3 * (2 : \u211d) ^ (k - 2) := by\n    have h\u2083 : (a (k + 1) : \u211d) \u2264 (2 : \u211d) ^ (k - 1) + (2 : \u211d) ^ (k - 2) := by\n      -- Cast the given inequality to real numbers\n      norm_cast at l5 \u22a2\n      <;> simpa [pow_add, pow_one] using l5\n    have h\u2084 : (2 : \u211d) ^ (k - 1) + (2 : \u211d) ^ (k - 2) = 3 * (2 : \u211d) ^ (k - 2) := by\n      -- Cast the natural number equality to real numbers\n      have h\u2085 : (2 : \u2115) ^ (k - 1) + (2 : \u2115) ^ (k - 2) = 3 * 2 ^ (k - 2) := h2\n      have h\u2086 : (2 : \u211d) ^ (k - 1) + (2 : \u211d) ^ (k - 2) = 3 * (2 : \u211d) ^ (k - 2) := by\n        norm_cast at h\u2085 \u22a2\n        <;>\n        (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n        (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n        (try\n          {\n            cases k with\n            | zero => contradiction\n            | succ k' =>\n              cases k' with\n              | zero => contradiction\n              | succ k'' =>\n                simp_all [Nat.pow_succ, Nat.mul_succ]\n                <;> ring_nf at * <;> norm_num at * <;> linarith\n          }) <;>\n        (try\n          {\n            simp_all [Nat.pow_succ, Nat.mul_succ]\n            <;> ring_nf at * <;> norm_num at * <;> linarith\n          })\n      exact h\u2086\n    -- Use the equality to conclude the proof\n    linarith\n  \n  -- Since h3 already gives the desired inequality, we can directly use it.\n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l5 is correctly formalized with the exact same mathematical inequality", "The conclusion is correctly formalized with the exact same mathematical inequality", "The logical structure of assumption leading to conclusion is properly captured in the theorem format", "The additional constraint hk : k \u2265 2 is mathematically sound and necessary for well-definedness, which is acceptable as an extra logical detail"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "We need to show that $3 \\cdot 2^{k-2} \\leq 2^k$. Dividing both sides by $2^{k-2}$ gives $3 \\leq 2^2=4$. This is true.", "statement": "We assume:\n\u2022 $k$ is an integer such that $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $3 \\cdot 2^{k-2} \\leq 2^k$ [l7].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (k : \u2115) (h_k : k \u2265 2) : 3 * 2^(k - 2) \u2264 2^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (k : \u2115) (h_k : k \u2265 2) : 3 * 2^(k - 2) \u2264 2^k := by\n  have h_main : 3 * 2^(k - 2) \u2264 2^k := by\n    have h\u2081 : 3 * 2 ^ (k - 2) \u2264 4 * 2 ^ (k - 2) := by\n      -- Prove that 3 * 2^(k - 2) \u2264 4 * 2^(k - 2)\n      have h\u2082 : 3 \u2264 4 := by norm_num\n      have h\u2083 : 2 ^ (k - 2) \u2265 0 := by positivity\n      -- Multiply both sides of 3 \u2264 4 by 2^(k - 2)\n      have h\u2084 : 3 * 2 ^ (k - 2) \u2264 4 * 2 ^ (k - 2) := by\n        nlinarith [pow_nonneg (by norm_num : (0 : \u2115) \u2264 2) (k - 2)]\n      exact h\u2084\n    have h\u2082 : 4 * 2 ^ (k - 2) = 2 ^ k := by\n      -- Prove that 4 * 2^(k - 2) = 2^k\n      have h\u2083 : k \u2265 2 := h_k\n      have h\u2084 : 4 * 2 ^ (k - 2) = 2 ^ 2 * 2 ^ (k - 2) := by norm_num\n      rw [h\u2084]\n      have h\u2085 : 2 ^ 2 * 2 ^ (k - 2) = 2 ^ (2 + (k - 2)) := by\n        rw [\u2190 pow_add]\n        <;> ring_nf\n      rw [h\u2085]\n      have h\u2086 : 2 + (k - 2) = k := by\n        have h\u2087 : k \u2265 2 := h_k\n        omega\n      rw [h\u2086]\n    -- Combine the inequalities to get the final result\n    calc\n      3 * 2 ^ (k - 2) \u2264 4 * 2 ^ (k - 2) := h\u2081\n      _ = 2 ^ k := by rw [h\u2082]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies k as an integer, but Lean uses natural numbers (\u2115). Since k \u2265 2, natural numbers are a valid subset that captures the intended meaning, but this represents a slight structural difference in type specification.", "The mathematical inequality is perfectly translated from natural language to Lean notation, with equivalent mathematical meaning.", "The logical structure of assumption leading to conclusion is correctly captured in the Lean theorem statement format."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Thus, $a_{k+1} \\leq 2^{k}$.", "statement": "We assume:\n\u2022 $a_{k+1} \\leq 3 \\cdot 2^{k-2}$ [l6].\n\u2022 $3 \\cdot 2^{k-2} \\leq 2^k$ [l7].\nTherefore, we conclude:\n\u2022 $a_{k+1} \\leq 2^k$ [l8].", "dependencies": ["l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l6 : a (k + 1) \u2264 3 * (2 : \u211d)^(k - 2))\n  (l7 : 3 * (2 : \u211d)^(k - 2) \u2264 (2 : \u211d)^k) :\n  a (k + 1) \u2264 (2 : \u211d)^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a : \u2115 \u2192 \u211d) \n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l6 : a (k + 1) \u2264 3 * (2 : \u211d)^(k - 2))\n  (l7 : 3 * (2 : \u211d)^(k - 2) \u2264 (2 : \u211d)^k) :\n  a (k + 1) \u2264 (2 : \u211d)^k := by\n  have h_main : a (k + 1) \u2264 (2 : \u211d)^k := by\n    -- Use the transitivity of the \u2264 relation to combine l6 and l7\n    have h : a (k + 1) \u2264 (2 : \u211d)^k := by\n      calc\n        a (k + 1) \u2264 3 * (2 : \u211d)^(k - 2) := l6\n        _ \u2264 (2 : \u211d)^k := l7\n    exact h\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly and completely captures the mathematical logic from the natural language. The transitivity argument with premises l6 and l7 leading to conclusion l8 is faithfully represented. The additional constraint hk : k \u2265 2 is a reasonable mathematical requirement for the expression 2^(k-2) to be well-defined, and such extra conditions are acceptable. All variable types (sequence a, natural number k, real number arithmetic) are appropriate choices that don't contradict the natural language. The notational translations are mathematically equivalent and the logical structure is preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of **strong mathematical induction**, the inequality $a_n \\leq 2^{n-1}$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The inequality $a_n \\leq 2^{n-1}$ holds for $n=1$ [l1].\n\u2022 The inequality $a_n \\leq 2^{n-1}$ holds for $n=2$ [l2].\n\u2022 For any integer $k \\geq 2$, if we assume that $a_j \\leq 2^{j-1}$ for all integers $j$ with $1 \\leq j \\leq k$ [def_1], then it follows that $a_{k+1} \\leq 2^k$ [l8].\nTherefore, we conclude:\n\u2022 The inequality $a_n \\leq 2^{n-1}$ holds for all integers $n \\geq 1$ [ts_1].", "dependencies": ["l1", "l2", "l8", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) + a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n    intro n hn\n    have h\u2083 : \u2200 (n : \u2115), n \u2265 1 \u2192 a n \u2264 (2 : \u211d)^(n - 1) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case n = 1\n        norm_num [h1]\n        <;>\n        simp_all [h1]\n        <;>\n        norm_num\n      | 2 =>\n        -- Base case n = 2\n        norm_num [h2]\n        <;>\n        simp_all [h2]\n        <;>\n        norm_num\n      | 3 =>\n        -- Base case n = 3\n        have h\u2084 : a 3 = a 2 + a 1 := by\n          have h\u2085 := h_rec 3 (by norm_num)\n          norm_num at h\u2085 \u22a2\n          <;> linarith\n        have h\u2085 : a 3 \u2264 (2 : \u211d)^(3 - 1) := by\n          rw [h\u2084]\n          norm_num [h1, h2] at *\n          <;>\n          simp_all [h1, h2]\n          <;>\n          norm_num\n          <;>\n          linarith\n        exact h\u2085\n      | n + 4 =>\n        -- Inductive step for n \u2265 4\n        have h\u2084 : a (n + 4) = a (n + 3) + a (n + 2) := by\n          have h\u2085 := h_rec (n + 4) (by\n            omega\n          )\n          have h\u2086 : (n + 4 : \u2115) \u2265 3 := by omega\n          have h\u2087 : a (n + 4) = a (n + 4 - 1) + a (n + 4 - 2) := by\n            apply h_rec\n            <;> omega\n          have h\u2088 : (n + 4 : \u2115) - 1 = n + 3 := by\n            omega\n          have h\u2089 : (n + 4 : \u2115) - 2 = n + 2 := by\n            omega\n          rw [h\u2087, h\u2088, h\u2089]\n          <;> ring_nf\n          <;> simp_all\n          <;> linarith\n        have h\u2085 : a (n + 4) \u2264 (2 : \u211d)^((n + 4) - 1) := by\n          have h\u2086 : a (n + 3) \u2264 (2 : \u211d)^((n + 3) - 1) := by\n            have h\u2087 : (n + 3 : \u2115) \u2265 1 := by omega\n            have h\u2088 : a (n + 3) \u2264 (2 : \u211d)^((n + 3) - 1) := by\n              apply ih (n + 3)\n              <;> omega\n            exact h\u2088\n          have h\u2087 : a (n + 2) \u2264 (2 : \u211d)^((n + 2) - 1) := by\n            have h\u2088 : (n + 2 : \u2115) \u2265 1 := by omega\n            have h\u2089 : a (n + 2) \u2264 (2 : \u211d)^((n + 2) - 1) := by\n              apply ih (n + 2)\n              <;> omega\n            exact h\u2089\n          have h\u2088 : (2 : \u211d)^((n + 3) - 1 : \u2115) = (2 : \u211d)^(n + 2 : \u2115) := by\n            norm_num [pow_succ]\n            <;>\n            ring_nf\n            <;>\n            simp [pow_add, pow_one, mul_comm]\n            <;>\n            norm_num\n            <;>\n            linarith\n          have h\u2089 : (2 : \u211d)^((n + 2) - 1 : \u2115) = (2 : \u211d)^(n + 1 : \u2115) := by\n            norm_num [pow_succ]\n            <;>\n            ring_nf\n            <;>\n            simp [pow_add, pow_one, mul_comm]\n            <;>\n            norm_num\n            <;>\n            linarith\n          have h\u2081\u2080 : (2 : \u211d)^((n + 4) - 1 : \u2115) = (2 : \u211d)^(n + 3 : \u2115) := by\n            norm_num [pow_succ]\n            <;>\n            ring_nf\n            <;>\n            simp [pow_add, pow_one, mul_comm]\n            <;>\n            norm_num\n            <;>\n            linarith\n          have h\u2081\u2081 : (2 : \u211d)^(n + 3 : \u2115) = (2 : \u211d)^(n + 2 : \u2115) * 2 := by\n            norm_num [pow_succ]\n            <;>\n            ring_nf\n            <;>\n            simp [pow_add, pow_one, mul_comm]\n            <;>\n            norm_num\n            <;>\n            linarith\n          have h\u2081\u2082 : (2 : \u211d)^(n + 2 : \u2115) \u2265 0 := by positivity\n          have h\u2081\u2083 : (2 : \u211d)^(n + 1 : \u2115) \u2265 0 := by positivity\n          have h\u2081\u2084 : a (n + 4) = a (n + 3) + a (n + 2) := by\n            rw [h\u2084]\n          rw [h\u2081\u2084]\n          have h\u2081\u2085 : (a (n + 3) : \u211d) \u2264 (2 : \u211d)^((n + 3) - 1) := by\n            exact_mod_cast h\u2086\n          have h\u2081\u2086 : (a (n + 2) : \u211d) \u2264 (2 : \u211d)^((n + 2) - 1) := by\n            exact_mod_cast h\u2087\n          have h\u2081\u2087 : (a (n + 3) : \u211d) + (a (n + 2) : \u211d) \u2264 (2 : \u211d)^((n + 3) - 1) + (2 : \u211d)^((n + 2) - 1) := by\n            linarith\n          have h\u2081\u2088 : (2 : \u211d)^((n + 3) - 1) + (2 : \u211d)^((n + 2) - 1) \u2264 (2 : \u211d)^((n + 4) - 1) := by\n            calc\n              (2 : \u211d)^((n + 3) - 1) + (2 : \u211d)^((n + 2) - 1) = (2 : \u211d)^(n + 2 : \u2115) + (2 : \u211d)^(n + 1 : \u2115) := by\n                rw [h\u2088, h\u2089]\n                <;>\n                norm_num [pow_succ]\n                <;>\n                ring_nf\n                <;>\n                simp [pow_add, pow_one, mul_comm]\n                <;>\n                norm_num\n                <;>\n                linarith\n              _ \u2264 (2 : \u211d)^(n + 2 : \u2115) + (2 : \u211d)^(n + 2 : \u2115) := by\n                have h\u2081\u2089 : (2 : \u211d)^(n + 1 : \u2115) \u2264 (2 : \u211d)^(n + 2 : \u2115) := by\n                  apply pow_le_pow_right (by norm_num)\n                  <;> omega\n                linarith\n              _ = 2 * (2 : \u211d)^(n + 2 : \u2115) := by ring\n              _ = (2 : \u211d)^(n + 3 : \u2115) := by\n                have h\u2082\u2080 : (2 : \u211d)^(n + 3 : \u2115) = 2 * (2 : \u211d)^(n + 2 : \u2115) := by\n                  calc\n                    (2 : \u211d)^(n + 3 : \u2115) = (2 : \u211d)^((n + 2 : \u2115) + 1 : \u2115) := by\n                      ring_nf\n                    _ = (2 : \u211d)^(n + 2 : \u2115) * 2 := by\n                      simp [pow_add, pow_one]\n                      <;> ring_nf\n                    _ = 2 * (2 : \u211d)^(n + 2 : \u2115) := by ring\n                linarith\n              _ = (2 : \u211d)^((n + 4) - 1) := by\n                rw [h\u2081\u2080]\n                <;>\n                norm_num [pow_succ]\n                <;>\n                ring_nf\n                <;>\n                simp [pow_add, pow_one, mul_comm]\n                <;>\n                norm_num\n                <;>\n                linarith\n          linarith\n        exact h\u2085\n    exact h\u2083 n hn\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes an abstract inductive proof framework with unspecified sequence properties, while the Lean formalization defines a specific Fibonacci sequence. The natural language presents general assumptions about inequalities holding for base cases and an inductive step, but the Lean code replaces these with concrete initial values and a recurrence relation. This represents a fundamental shift from an abstract proof structure to a specific mathematical sequence, constituting a major inconsistency in the logical foundation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language describes an abstract inductive proof framework with unspecified sequence properties, while the Lean formalization defines a specific Fibonacci sequence. The natural language presents general assumptions about inequalities holding for base cases and an inductive step, but the Lean code replaces these with concrete initial values and a recurrence relation. This represents a fundamental shift from an abstract proof structure to a specific mathematical sequence, constituting a major inconsistency in the logical foundation.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    