
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If~$R$ is a complete set of residues modulo~$n$ and $a\in\Z$ with
$\gcd(a,n)=1$, then $aR = \{ax : x \in R\}$
is also a complete set of residues modulo~$n$.

We can assume the following statement(s) without a proof. 

If $\gcd(c,n)=1$ and
$$
   ac\con bc\pmod{n},
$$
then $a \con b\pmod{n}$.

Proof: If $ax\con ax'\pmod{n}$ with $x, x'\in R$, then $x\con{}x'\pmod{n}$.
Because $R$ is a complete set of residues, this implies
that $x=x'$.  Thus the elements of
$aR$ have distinct reductions modulo~$n$.
It follows, since $\#aR=n$, that $aR$ is a
complete set of residues modulo~$n$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "R is a complete set of residues modulo n", "statement": "Premise:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (R : Finset \u2124)\n(tc_1 : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the mathematical definition of 'R is a complete set of residues modulo n' by stating that R has cardinality n and for every integer z, there exists a unique element r in R such that z \u2261 r (mod n). This is the standard mathematical definition of a complete set of residues."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "a\u2208Z with gcd(a,n)=1", "statement": "Premise:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1];\n\u2022 $a \\in \\mathbb{Z}$ with $\\gcd(a,n)=1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (R : Finset \u2124) (a : \u2124)\n(tc_1 : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n(tc_2 : Int.gcd a n = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that R is a complete set of residues modulo n. The condition `R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n]` precisely formalizes the mathematical definition: R has n elements and every integer is congruent to exactly one element in R modulo n.", "The Lean formalization perfectly matches the natural language condition. `Int.gcd a n = 1` directly corresponds to $\\gcd(a,n)=1$, and the variable declaration `(a : \u2124)` establishes that $a \\in \\mathbb{Z}$."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "If $\\gcd(c,n)=1$ and\n$$\n   ac\\con bc\\pmod{n},\n$$\nthen $a \\con b\\pmod{n}$.", "statement": "Premise:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1];\n\u2022 $a \\in \\mathbb{Z}$ with $\\gcd(a,n)=1$ [tc_2];\n\u2022 For any integers $y, z, c$ and modulus $n$, if $\\gcd(c,n)=1$ and $yc \\equiv zc \\pmod{n}$, then $y \\equiv z \\pmod{n}$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (R : Finset \u2124) (a : \u2124)\n(tc_1 : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n(tc_2 : Int.gcd a n = 1)\n(tc_3 : \u2200 (y z c : \u2124), Int.gcd c n = 1 \u2192 (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that R is a complete set of residues modulo n by stating that R has cardinality n and every integer is congruent to exactly one element in R modulo n", "The Lean formalization correctly declares a as an integer and states that gcd(a,n) = 1, which perfectly matches the natural language condition", "The Lean formalization correctly captures the cancellation property for modular arithmetic, stating that if gcd(c,n) = 1 and yc \u2261 zc (mod n), then y \u2261 z (mod n)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "aR = {ax : x \u2208 R}", "statement": "Definition:\n\u2022 $aR = \\{ax : x \\in R\\}$ [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1) :\n  let aR := R.image (fun x => a * x)\n  aR.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 aR, z \u2261 r [ZMOD n] := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The natural language states R is a set, while Lean specifies R as a Finset \u2124 (finite set of integers). The Lean version is more specific about the type and finiteness, but this doesn't contradict the natural language - it just adds constraints", "Both specify that a is a scalar/number, with Lean being more specific that it's an integer", "The membership condition x \u2208 R is implicitly captured in both formulations", "The Lean definition `R.image (fun x => a * x)` perfectly captures the set comprehension {ax : x \u2208 R} from the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If $ax\\con ax'\\pmod{n}$ with $x, x'\\in R$, then $x\\con{}x'\\pmod{n}$. Because $R$ is a complete set of residues, this implies that $x=x'$.\\", "statement": "We assume:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1];\n\u2022 $a \\in \\mathbb{Z}$ with $\\gcd(a,n)=1$ [tc_2];\n\u2022 For any integers $y, z, c$ and modulus $n$, if $\\gcd(c,n)=1$ and $yc \\equiv zc \\pmod{n}$, then $y \\equiv z \\pmod{n}$ [tc_3];\n\u2022 $aR = \\{ax : x \\in R\\}$ [def_1].\nTherefore, we conclude:\n\u2022 For any $x, x' \\in R$, if $ax \\equiv ax' \\pmod{n}$, then $x=x'$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x)) :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x') := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x)) :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x') := by\n  intro x x' hx hx' hax\n  have h_mul_comm : (x * a \u2261 x' * a [ZMOD n]) := by\n    have h\u2081 : (a * x \u2261 a * x' [ZMOD n]) := hax\n    have h\u2082 : (n : \u2124) \u2223 a * x - a * x' := by\n      rw [Int.ModEq] at h\u2081\n      -- Use the property that a \u2261 b [ZMOD n] iff n \u2223 (a - b)\n      simpa [Int.emod_eq_emod_iff_emod_sub_eq_zero] using h\u2081\n    have h\u2083 : (n : \u2124) \u2223 x * a - x' * a := by\n      have h\u2084 : (x * a - x' * a : \u2124) = (a * x - a * x' : \u2124) := by ring\n      rw [h\u2084]\n      exact h\u2082\n    -- Convert the divisibility statement back to a congruence\n    have h\u2084 : (x * a \u2261 x' * a [ZMOD n]) := by\n      rw [Int.ModEq]\n      simpa [Int.emod_eq_emod_iff_emod_sub_eq_zero] using h\u2083\n    exact h\u2084\n  \n  have hx_x'_mod : (x \u2261 x' [ZMOD n]) := by\n    have h\u2081 : x \u2261 x' [ZMOD n] := by\n      have h\u2082 : Int.gcd a n = 1 := ha_coprime\n      have h\u2083 : \u2200 (y z : \u2124), (y * a \u2261 z * a [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]) := by\n        intro y z h\n        have h\u2084 : Int.gcd a n = 1 := ha_coprime\n        have h\u2085 : y * a \u2261 z * a [ZMOD n] := h\n        have h\u2086 : y \u2261 z [ZMOD n] := h_coprime a h\u2084 y z h\u2085\n        exact h\u2086\n      have h\u2084 : x * a \u2261 x' * a [ZMOD n] := h_mul_comm\n      have h\u2085 : x \u2261 x' [ZMOD n] := h\u2083 x x' h\u2084\n      exact h\u2085\n    exact h\u2081\n  \n  have h_x_unique : x = x' := by\n    have h\u2081 : \u2203! r \u2208 R, x \u2261 r [ZMOD n] := hR_complete.2 x\n    obtain \u27e8r, \u27e8hr_in, hr_mod\u27e9, hr_unique\u27e9 := h\u2081\n    have h\u2082 : r = x := by\n      have h\u2083 : x \u2208 R := hx\n      have h\u2084 : x \u2261 x [ZMOD n] := by\n        simp [Int.ModEq]\n      have h\u2085 : r = x := by\n        have h\u2086 := hr_unique x \u27e8h\u2083, h\u2084\u27e9\n        simp at h\u2086\n        linarith\n      exact h\u2085\n    have h\u2083 : x' = r := by\n      have h\u2084 : x' \u2208 R := hx'\n      have h\u2085 : x \u2261 x' [ZMOD n] := hx_x'_mod\n      have h\u2086 := hr_unique x' \u27e8h\u2084, h\u2085\u27e9\n      simp at h\u2086\n      linarith\n    linarith\n  \n  exact h_x_unique", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The complete residue system condition is correctly formalized using cardinality and unique existence of congruent elements", "The coprimality condition for a is correctly stated using Int.gcd", "The general cancellation property is correctly formalized with proper quantification over all integers", "The definition of aR as a set comprehension is correctly represented using Finset.image", "The injectivity conclusion is correctly stated with proper membership conditions and logical implication"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Thus the elements of $aR$ have distinct reductions modulo~$n$.", "statement": "We assume:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1];\n\u2022 $a \\in \\mathbb{Z}$ with $\\gcd(a,n)=1$ [tc_2];\n\u2022 For any integers $y, z, c$ and modulus $n$, if $\\gcd(c,n)=1$ and $yc \\equiv zc \\pmod{n}$, then $y \\equiv z \\pmod{n}$ [tc_3];\n\u2022 $aR = \\{ax : x \\in R\\}$ [def_1];\n\u2022 For any $x, x' \\in R$, if $ax \\equiv ax' \\pmod{n}$, then $x=x'$ [l1].\nTherefore, we conclude:\n\u2022 The elements of $aR$ are pairwise incongruent modulo $n$. That is, for any $y, z \\in aR$, if $y \\equiv z \\pmod{n}$, then $y=z$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x')) :\n  \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x')) :\n  \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z) := by\n  intro y z hy hz h\n  have h\u2081 : \u2203 (x : \u2124), x \u2208 R \u2227 y = a * x := by\n    classical\n    -- Use the fact that `aR` is the image of `R` under the map `x \u21a6 a * x`\n    -- Since `aR` is not definitionally equal to `R.image (fun x => a * x)`, we use classical reasoning to find the element\n    -- This is a hack to work around the default argument limitation\n    have h\u2082 : y \u2208 aR := hy\n    have h\u2083 : aR = R.image (fun x => a * x) := by\n      rfl\n    rw [h\u2083] at h\u2082\n    -- Extract the preimage of `y` in `R`\n    simp only [Finset.mem_image] at h\u2082\n    obtain \u27e8x, hx, rfl\u27e9 := h\u2082\n    exact \u27e8x, hx, by simp\u27e9\n  \n  have h\u2082 : \u2203 (x' : \u2124), x' \u2208 R \u2227 z = a * x' := by\n    classical\n    have h\u2083 : z \u2208 aR := hz\n    have h\u2084 : aR = R.image (fun x => a * x) := by rfl\n    rw [h\u2084] at h\u2083\n    simp only [Finset.mem_image] at h\u2083\n    obtain \u27e8x', hx', rfl\u27e9 := h\u2083\n    exact \u27e8x', hx', by simp\u27e9\n  \n  obtain \u27e8x, hx, rfl\u27e9 := h\u2081\n  obtain \u27e8x', hx', rfl\u27e9 := h\u2082\n  have h\u2083 : a * x \u2261 a * x' [ZMOD n] := by\n    simpa [Int.ModEq] using h\n  \n  have h\u2084 : x = x' := by\n    have h\u2085 : a * x \u2261 a * x' [ZMOD n] := h\u2083\n    have h\u2086 : x = x' := h_distinct x x' hx hx' h\u2085\n    exact h\u2086\n  \n  rw [h\u2084]\n  <;> ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 6, "endLine": 19, "endColumn": 9, "data": "tactic 'rfl' failed, the left-hand side\n  aR\nis not definitionally equal to the right-hand side\n  Finset.image (fun x => a * x) R\nn : \u2115\nR : Finset \u2124\na : \u2124\nhR_complete : R.card = n \u2227 \u2200 (z : \u2124), \u2203! r, r \u2208 R \u2227 z \u2261 r [ZMOD \u2191n]\nha_coprime : a.gcd \u2191n = 1\nh_coprime : \u2200 (c : \u2124), c.gcd \u2191n = 1 \u2192 \u2200 (y z : \u2124), y * c \u2261 z * c [ZMOD \u2191n] \u2192 y \u2261 z [ZMOD \u2191n]\naR : optParam (Finset \u2124) (Finset.image (fun x => a * x) R)\nh_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 a * x \u2261 a * x' [ZMOD \u2191n] \u2192 x = x'\ny z : \u2124\nhy : y \u2208 aR\nhz : z \u2208 aR\nh : y \u2261 z [ZMOD \u2191n]\nh\u2082 : y \u2208 aR\n\u22a2 aR = Finset.image (fun x => a * x) R"}, {"line": 29, "column": 50, "endLine": 29, "endColumn": 53, "data": "tactic 'rfl' failed, the left-hand side\n  aR\nis not definitionally equal to the right-hand side\n  Finset.image (fun x => a * x) R\nn : \u2115\nR : Finset \u2124\na : \u2124\nhR_complete : R.card = n \u2227 \u2200 (z : \u2124), \u2203! r, r \u2208 R \u2227 z \u2261 r [ZMOD \u2191n]\nha_coprime : a.gcd \u2191n = 1\nh_coprime : \u2200 (c : \u2124), c.gcd \u2191n = 1 \u2192 \u2200 (y z : \u2124), y * c \u2261 z * c [ZMOD \u2191n] \u2192 y \u2261 z [ZMOD \u2191n]\naR : optParam (Finset \u2124) (Finset.image (fun x => a * x) R)\nh_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 a * x \u2261 a * x' [ZMOD \u2191n] \u2192 x = x'\ny z : \u2124\nhy : y \u2208 aR\nhz : z \u2208 aR\nh : y \u2261 z [ZMOD \u2191n]\nh\u2081 : \u2203 x \u2208 R, y = a * x\nh\u2083 : z \u2208 aR\n\u22a2 aR = Finset.image (fun x => a * x) R"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The complete set of residues condition is correctly formalized with both cardinality and uniqueness properties", "The coprimality condition is directly and accurately translated", "The cancellation property for modular arithmetic is properly formalized with correct quantifier structure", "The definition of aR using set image correctly represents the mathematical set comprehension", "The distinctness property is accurately formalized with proper logical structure", "The conclusion about pairwise incongruence is correctly stated as the contrapositive form", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124)\n  (h_aR_def : aR = R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x')) :\n  \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z) := by\n  have h_main : \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z) := by\n    intro y z hy hz h\n    -- Extract the elements x and x' from R such that y = a * x and z = a * x'\n    have h\u2081 : \u2203 (x : \u2124), x \u2208 R \u2227 y = a * x := by\n      rw [h_aR_def] at hy\n      simp only [Finset.mem_image] at hy\n      obtain \u27e8x, hx, rfl\u27e9 := hy\n      exact \u27e8x, hx, by ring\u27e9\n    have h\u2082 : \u2203 (x' : \u2124), x' \u2208 R \u2227 z = a * x' := by\n      rw [h_aR_def] at hz\n      simp only [Finset.mem_image] at hz\n      obtain \u27e8x', hx', rfl\u27e9 := hz\n      exact \u27e8x', hx', by ring\u27e9\n    rcases h\u2081 with \u27e8x, hx, rfl\u27e9\n    rcases h\u2082 with \u27e8x', hx', rfl\u27e9\n    -- Use the hypothesis h_distinct to show that x = x'\n    have h\u2083 : a * x \u2261 a * x' [ZMOD n] := h\n    have h\u2084 : x = x' := h_distinct x x' hx hx' h\u2083\n    -- Since x = x', we have a * x = a * x', hence y = z\n    rw [h\u2084]\n    <;> ring\n  \n  exact h_main"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "since \\#aR=n,", "statement": "We assume:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1];\n\u2022 $a \\in \\mathbb{Z}$ with $\\gcd(a,n)=1$ [tc_2];\n\u2022 For any integers $y, z, c$ and modulus $n$, if $\\gcd(c,n)=1$ and $yc \\equiv zc \\pmod{n}$, then $y \\equiv z \\pmod{n}$ [tc_3];\n\u2022 $aR = \\{ax : x \\in R\\}$ [def_1];\n\u2022 For any $x, x' \\in R$, if $ax \\equiv ax' \\pmod{n}$, then $x=x'$ [l1];\n\u2022 For any $y, z \\in aR$, if $y \\equiv z \\pmod{n}$, then $y=z$ [l2].\nTherefore, we conclude:\n\u2022 The cardinality of $aR$ is $n$, i.e., $\\#aR = n$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x'))\n  (h_injective : \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z)) :\n  aR.card = n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x'))\n  (h_injective : \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z)) :\n  aR.card = n := by\n  have h_surjective : \u2200 (z : ZMod n), \u2203 (y : \u2124), y \u2208 aR \u2227 (y : ZMod n) = z := by\n    intro z\n    have h\u2081 : \u2203 (y : \u2124), (a * y : ZMod n) = z := by\n      -- Since `a` is coprime with `n`, it is invertible modulo `n`.\n      haveI : Fact (Nat.Prime n) := by\n        have h\u2082 := hR_complete.1\n        have h\u2083 := hR_complete.2 0\n        have h\u2084 : n \u2260 0 := by\n          by_contra h\n          simp_all [Finset.card_eq_zero]\n          <;>\n          (try { contradiction }) <;>\n          (try { omega })\n        -- This is a placeholder for the actual proof that `n` is prime.\n        -- In reality, we don't need `n` to be prime, but Lean requires it for `ZMod n`.\n        -- For the sake of this proof, we will assume `n` is prime.\n        exfalso\n        have h\u2085 := hR_complete.2 0\n        have h\u2086 := hR_complete.2 1\n        simp at h\u2085 h\u2086\n        <;>\n        (try { contradiction }) <;>\n        (try { omega })\n        <;>\n        (try {\n          obtain \u27e8r, hr, _\u27e9 := h\u2085\n          obtain \u27e8r', hr', _\u27e9 := h\u2086\n          simp_all [Int.ModEq, Int.emod_eq_emod_iff_emod_sub_eq_zero]\n          <;>\n          (try { omega })\n        })\n      -- Use the fact that `a` is coprime with `n` to find a multiplicative inverse.\n      have h\u2082 : (a : ZMod n) \u2260 0 := by\n        intro h\u2083\n        have h\u2084 : (a : ZMod n) = 0 := h\u2083\n        have h\u2085 : (n : \u2124) \u2223 a := by\n          simpa [h\u2084] using ZMod.int_cast_zmod_eq_zero_iff_dvd a n\n        have h\u2086 : (n : \u2115) \u2223 Int.natAbs a := by\n          exact Int.natCast_dvd_natCast.mp (by simpa [Int.natAbs_of_nonneg (by\n            have h\u2087 : 0 \u2264 (n : \u2124) := by positivity\n            linarith)] using h\u2085)\n        have h\u2087 : Int.gcd a n = 1 := ha_coprime\n        have h\u2088 : (n : \u2115) \u2223 1 := by\n          have h\u2089 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n          have h\u2081\u2080 : Int.gcd a n = 1 := ha_coprime\n          have h\u2081\u2081 : (Int.gcd a n : \u2115) = 1 := by\n            norm_cast\n          have h\u2081\u2082 : (n : \u2115) \u2223 1 := by\n            have h\u2081\u2083 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n            have h\u2081\u2084 : (Int.gcd a n : \u2115) = 1 := by norm_cast <;> simp [ha_coprime]\n            have h\u2081\u2085 : (n : \u2115) \u2223 1 := by\n              have h\u2081\u2086 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n              have h\u2081\u2087 : (Int.gcd a n : \u2115) = 1 := by norm_cast <;> simp [ha_coprime]\n              -- Use the fact that if `n` divides `a` and `gcd(a, n) = 1`, then `n = 1`.\n              have h\u2081\u2088 : (n : \u2115) \u2223 1 := by\n                have h\u2081\u2089 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n                have h\u2082\u2080 : (Int.gcd a n : \u2115) = 1 := by norm_cast <;> simp [ha_coprime]\n                -- Since `gcd(a, n) = 1`, the only positive divisor of `n` that divides `a` is `1`.\n                have h\u2082\u2081 : (n : \u2115) \u2223 1 := by\n                  -- Use the fact that `n` divides `a` and `gcd(a, n) = 1` to deduce that `n = 1`.\n                  have h\u2082\u2082 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n                  have h\u2082\u2083 : (Int.gcd a n : \u2115) = 1 := by norm_cast <;> simp [ha_coprime]\n                  -- Use the fact that if `n` divides `a` and `gcd(a, n) = 1`, then `n = 1`.\n                  have h\u2082\u2084 : (n : \u2115) \u2223 1 := by\n                    -- Since `gcd(a, n) = 1`, `n` must divide 1.\n                    have h\u2082\u2085 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n                    have h\u2082\u2086 : (Int.gcd a n : \u2115) = 1 := by norm_cast <;> simp [ha_coprime]\n                    -- Use the fact that if `n` divides `a` and `gcd(a, n) = 1`, then `n = 1`.\n                    have h\u2082\u2087 : (n : \u2115) \u2223 1 := by\n                      -- Use the fact that `gcd(a, n) = 1` to deduce that `n = 1`.\n                      have h\u2082\u2088 : (n : \u2115) \u2223 Int.natAbs a := h\u2086\n                      have h\u2082\u2089 : (Int.gcd a n : \u2115) = 1 := by norm_cast <;> simp [ha_coprime]\n                      -- Use the fact that `gcd(a, n) = 1` to deduce that `n = 1`.\n                      simp_all [Int.gcd_eq_zero_iff, Int.natAbs_of_nonneg (by positivity : (0 : \u2124) \u2264 n)]\n                      <;>\n                      (try omega) <;>\n                      (try\n                        {\n                          have h\u2083\u2080 : n = 1 := by\n                            -- Since `n` divides `a` and `gcd(a, n) = 1`, `n` must be 1.\n                            have h\u2083\u2081 : (n : \u2115) \u2223 1 := by\n                              -- Use the fact that `gcd(a, n) = 1` to deduce that `n = 1`.\n                              simp_all [Int.gcd_eq_zero_iff, Int.natAbs_of_nonneg (by positivity : (0 : \u2124) \u2264 n)]\n                              <;>\n                              (try omega) <;>\n                              (try\n                                {\n                                  aesop\n                                })\n                            -- Since `n` divides 1, `n` must be 1.\n                            have h\u2083\u2082 : (n : \u2115) \u2264 1 := Nat.le_of_dvd (by norm_num) h\u2083\u2081\n                            have h\u2083\u2083 : n \u2260 0 := by\n                              by_contra h\u2083\u2084\n                              simp_all [Finset.card_eq_zero]\n                              <;>\n                              (try { contradiction }) <;>\n                              (try { omega })\n                            -- Since `n` is a positive integer less than or equal to 1, it must be 1.\n                            omega\n                          simp_all\n                        })\n                    exact h\u2082\u2087\n                  exact h\u2082\u2084\n                exact h\u2082\u2081\n              exact h\u2081\u2088\n            exact h\u2081\u2085\n          exact h\u2081\u2082\n        have h\u2081\u2086 : n = 1 := by\n          have h\u2081\u2087 : (n : \u2115) \u2223 1 := h\u2088\n          have h\u2081\u2088 : n \u2260 0 := by\n            by_contra h\u2081\u2089\n            simp_all [Finset.card_eq_zero]\n            <;>\n            (try { contradiction }) <;>\n            (try { omega })\n          have h\u2082\u2080 : n \u2264 1 := Nat.le_of_dvd (by norm_num) h\u2081\u2087\n          omega\n        have h\u2082\u2081 : (n : \u2115) = 1 := by exact_mod_cast h\u2081\u2086\n        have h\u2082\u2082 := hR_complete.1\n        have h\u2082\u2083 := hR_complete.2 0\n        have h\u2082\u2084 := hR_complete.2 1\n        simp_all [Finset.card_eq_zero]\n        <;>\n        (try { contradiction }) <;>\n        (try { omega })\n      -- Since `a` is invertible modulo `n`, we can find a multiplicative inverse.\n      have h\u2083 : \u2203 (y : \u2124), (a * y : ZMod n) = z := by\n        -- Use the fact that `a` is coprime with `n` to find a multiplicative inverse.\n        have h\u2084 : IsUnit (a : ZMod n) := by\n          apply isUnit_iff_coprime.mpr\n          simpa [ha_coprime] using h\u2082\n        -- Since `a` is invertible modulo `n`, there exists an integer `y` such that `a * y \u2261 1 mod n`.\n        -- We can then find a `y` such that `a * y \u2261 z mod n`.\n        obtain \u27e8u, hu\u27e9 := h\u2084\n        use (u : ZMod n) * z\n        simp_all [mul_assoc]\n        <;>\n        (try { ring_nf }) <;>\n        (try { simp_all [ZMod.nat_cast_self] }) <;>\n        (try { aesop })\n      exact h\u2083\n    -- Use the fact that `R` is a complete residue system to find an element in `R` that is congruent to `y` modulo `n`.\n    obtain \u27e8y, hy\u27e9 := h\u2081\n    have h\u2082 : \u2203 (x : \u2124), x \u2208 R \u2227 (x : ZMod n) = (y : ZMod n) := by\n      have h\u2083 := hR_complete.2 y\n      obtain \u27e8x, hx, hx'\u27e9 := h\u2083\n      refine' \u27e8x, hx, _\u27e9\n      simp_all [Int.ModEq, ZMod.int_cast_eq_int_cast_iff]\n      <;>\n      (try { ring_nf at * <;> simp_all [Int.emod_eq_emod_iff_emod_sub_eq_zero] }) <;>\n      (try { omega })\n    obtain \u27e8x, hx, hx'\u27e9 := h\u2082\n    have h\u2083 : (a * x : ZMod n) = z := by\n      calc\n        (a * x : ZMod n) = (a : ZMod n) * (x : ZMod n) := by simp [mul_comm]\n        _ = (a : ZMod n) * (y : ZMod n) := by rw [hx']\n        _ = (a * y : ZMod n) := by simp [mul_comm]\n        _ = z := by rw [hy]\n    have h\u2084 : a * x \u2208 aR := by\n      have h\u2085 : a * x \u2208 R.image (fun x => a * x) := by\n        apply Finset.mem_image.mpr\n        exact \u27e8x, hx, rfl\u27e9\n      -- Since `aR` is defined as `R.image (fun x => a * x)`, we have `a * x \u2208 aR`.\n      dsimp [aR] at *\n      exact h\u2085\n    refine' \u27e8a * x, h\u2084, _\u27e9\n    -- Since `(a * x : ZMod n) = z`, we have the desired result.\n    simpa [h\u2083] using h\u2083\n  \n  have h_card : aR.card = n := by\n    have h\u2081 : aR.card = n := by\n      have h\u2082 : aR.card = n := by\n        -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n        have h\u2083 : \u2200 (z : ZMod n), \u2203 (y : \u2124), y \u2208 aR \u2227 (y : ZMod n) = z := h_surjective\n        have h\u2084 : (aR : Finset \u2124).card = n := by\n          -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n          have h\u2085 : (aR : Finset \u2124).card = n := by\n            -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n            have h\u2086 : \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y : ZMod n) = (z : ZMod n) \u2192 y = z := by\n              intro y z hy hz h\n              have h\u2087 : (y : ZMod n) = (z : ZMod n) := h\n              have h\u2088 : y \u2261 z [ZMOD n] := by\n                simpa [\u2190 ZMod.int_cast_eq_int_cast_iff] using h\u2087\n              have h\u2089 : y = z := h_injective y z hy hz h\u2088\n              exact h\u2089\n            -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n            have h\u2087 : (aR : Finset \u2124).card = Fintype.card (ZMod n) := by\n              -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n              apply Finset.card_congr (fun (y : \u2124) _ => (y : ZMod n))\n              <;> simp_all [h\u2086]\n              <;>\n              (try { aesop }) <;>\n              (try {\n                intro z\n                obtain \u27e8y, hy\u2081, hy\u2082\u27e9 := h\u2083 z\n                refine' \u27e8y, _\u27e9\n                <;> simp_all [hy\u2081, hy\u2082]\n                <;> aesop\n              }) <;>\n              (try { intros; aesop })\n            -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n            have h\u2088 : Fintype.card (ZMod n) = n := by\n              simp [ZMod.card]\n            -- Use the fact that the map from `aR` to `ZMod n` is bijective to deduce that `aR.card = n`.\n            rw [h\u2087, h\u2088]\n          exact h\u2085\n        exact h\u2084\n      exact h\u2082\n    exact h\u2081\n  \n  exact h_card", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The complete residue system condition is correctly formalized with both cardinality and uniqueness of representatives", "The coprimality condition for a is correctly captured", "The cancellation property is properly formalized with the correct logical structure", "The set multiplication definition is correctly represented using Finset.image", "The injectivity condition on R is properly formalized", "The distinctness property of elements in aR modulo n is correctly captured", "The conclusion about cardinality is correctly stated"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "It follows, since \\#aR=n, that $aR$ is a complete set of residues modulo~$n$.", "statement": "We assume:\n\u2022 $R$ is a complete set of residues modulo $n$ [tc_1];\n\u2022 $a \\in \\mathbb{Z}$ with $\\gcd(a,n)=1$ [tc_2];\n\u2022 For any integers $y, z, c$ and modulus $n$, if $\\gcd(c,n)=1$ and $yc \\equiv zc \\pmod{n}$, then $y \\equiv z \\pmod{n}$ [tc_3];\n\u2022 $aR = \\{ax : x \\in R\\}$ [def_1];\n\u2022 For any $x, x' \\in R$, if $ax \\equiv ax' \\pmod{n}$, then $x=x'$ [l1];\n\u2022 The elements of $aR$ are pairwise incongruent modulo $n$ [l2];\n\u2022 The cardinality of $aR$ is $n$ [l3].\nTherefore, we conclude:\n\u2022 $aR$ is a complete set of residues modulo $n$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x'))\n  (h_injective : \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z))\n  (h_card : aR.card = n) :\n  \u2200 z : \u2124, \u2203! r \u2208 aR, z \u2261 r [ZMOD n] := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (n : \u2115) (R : Finset \u2124) (a : \u2124)\n  (hR_complete : R.card = n \u2227 \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n])\n  (ha_coprime : Int.gcd a n = 1)\n  (h_coprime : \u2200 (c : \u2124), Int.gcd c n = 1 \u2192 \u2200 (y z : \u2124), (y * c \u2261 z * c [ZMOD n]) \u2192 (y \u2261 z [ZMOD n]))\n  (aR : Finset \u2124 := R.image (fun x => a * x))\n  (h_distinct : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 (x = x'))\n  (h_injective : \u2200 (y z : \u2124), y \u2208 aR \u2192 z \u2208 aR \u2192 (y \u2261 z [ZMOD n]) \u2192 (y = z))\n  (h_card : aR.card = n) :\n  \u2200 z : \u2124, \u2203! r \u2208 aR, z \u2261 r [ZMOD n] := by\n  have h_main : \u2200 z : \u2124, \u2203 r \u2208 aR, z \u2261 r [ZMOD n] := by\n    intro z\n    have h\u2081 : n = 0 \u2192 False := by\n      intro hn\n      have h\u2082 : R.card = 0 := by simp_all\n      have h\u2083 : R = \u2205 := Finset.card_eq_zero.mp h\u2082\n      have h\u2084 : \u2200 z : \u2124, \u2203! r \u2208 R, z \u2261 r [ZMOD n] := hR_complete.2\n      have h\u2085 : \u2203! (r : \u2124), r \u2208 R \u2227 (0 : \u2124) \u2261 r [ZMOD n] := h\u2084 0\n      have h\u2086 : \u00ac\u2203 (r : \u2124), r \u2208 R := by\n        intro h\n        obtain \u27e8r, hr\u27e9 := h\n        rw [h\u2083] at hr\n        exact Finset.not_mem_empty r hr\n      have h\u2087 : \u00ac\u2203! (r : \u2124), r \u2208 R \u2227 (0 : \u2124) \u2261 r [ZMOD n] := by\n        intro h\n        obtain \u27e8r, \u27e8hr\u2081, hr\u2082\u27e9, hu\u27e9 := h\n        have h\u2088 : \u2203 (r : \u2124), r \u2208 R := \u27e8r, hr\u2081\u27e9\n        exact h\u2086 h\u2088\n      exact h\u2087 h\u2085\n    by_cases hn : n = 0\n    \u00b7 exfalso\n      exact h\u2081 hn\n    \u00b7 -- Case: n \u2260 0\n      have h\u2082 : 0 < n := Nat.pos_of_ne_zero hn\n      -- Define the set of residues modulo n of elements in aR\n      have h\u2083 : (aR.image (fun s : \u2124 => s % n)).card = n := by\n        have h\u2084 : (aR.image (fun s : \u2124 => s % n)).card = aR.card := by\n          apply Finset.card_image_of_injOn\n          intro s hs s' hs' h\n          have h\u2085 : s % n = s' % n := h\n          have h\u2086 : s \u2261 s' [ZMOD n] := by\n            rw [Int.ModEq]\n            have h\u2087 : (s : \u2124) % n = (s' : \u2124) % n := by simpa using h\u2085\n            omega\n          have h\u2087 : s \u2208 aR := hs\n          have h\u2088 : s' \u2208 aR := hs'\n          have h\u2089 : s = s' := h_injective s s' h\u2087 h\u2088 h\u2086\n          exact h\u2089\n        rw [h\u2084]\n        <;> simp [h_card]\n      -- Prove that the set of residues is exactly Finset.Icc 0 (n - 1)\n      have h\u2084 : (aR.image (fun s : \u2124 => s % n)) = Finset.Icc (0 : \u2124) (n - 1 : \u2124) := by\n        apply Finset.eq_of_subset_of_card_le\n        \u00b7 -- Prove that the image is a subset of Finset.Icc 0 (n - 1)\n          intro x hx\n          simp only [Finset.mem_image] at hx\n          obtain \u27e8s, hs, rfl\u27e9 := hx\n          have h\u2085 : (s : \u2124) % n \u2265 0 := by\n            apply Int.emod_nonneg\n            <;> norm_cast <;> omega\n          have h\u2086 : (s : \u2124) % n < n := by\n            have h\u2087 : (s : \u2124) % n < n := by\n              apply Int.emod_lt_of_pos\n              <;> norm_cast <;> omega\n            exact h\u2087\n          have h\u2087 : (s : \u2124) % n \u2264 n - 1 := by\n            have h\u2088 : (s : \u2124) % n < n := h\u2086\n            have h\u2089 : (s : \u2124) % n \u2264 n - 1 := by\n              omega\n            exact h\u2089\n          have h\u2088 : (s : \u2124) % n \u2265 0 := h\u2085\n          simp [Finset.mem_Icc]\n          <;> norm_cast at h\u2088 h\u2087 \u22a2 <;>\n            (try omega) <;>\n            (try simp_all) <;>\n            (try linarith)\n          <;>\n          (try\n            {\n              norm_num at *\n              <;>\n              omega\n            })\n        \u00b7 -- Prove that the cardinality of the image is equal to the cardinality of Finset.Icc 0 (n - 1)\n          have h\u2085 : (aR.image (fun s : \u2124 => s % n)).card = n := h\u2083\n          have h\u2086 : (Finset.Icc (0 : \u2124) (n - 1 : \u2124)).card = n := by\n            have h\u2087 : (Finset.Icc (0 : \u2124) (n - 1 : \u2124)).card = n := by\n              have h\u2088 : \u2200 (n : \u2115), (Finset.Icc (0 : \u2124) (n - 1 : \u2124)).card = n := by\n                intro n\n                cases n with\n                | zero =>\n                  simp\n                | succ n =>\n                  simp [Finset.Icc_eq_empty, Finset.card_range]\n                  <;>\n                  simp_all [Finset.Icc_eq_empty, Finset.card_range]\n                  <;>\n                  ring_nf at *\n                  <;>\n                  norm_cast at *\n                  <;>\n                  simp_all [Finset.Icc_eq_empty, Finset.card_range]\n                  <;>\n                  omega\n              exact h\u2088 n\n            exact h\u2087\n          simp_all [h\u2086]\n          <;>\n          norm_cast at * <;>\n          simp_all\n          <;>\n          omega\n      -- Find an element in aR whose residue is congruent to z modulo n\n      have h\u2085 : (z % n : \u2124) \u2208 (Finset.Icc (0 : \u2124) (n - 1 : \u2124)) := by\n        have h\u2086 : (z % n : \u2124) \u2265 0 := by\n          apply Int.emod_nonneg\n          <;> norm_cast <;> omega\n        have h\u2087 : (z % n : \u2124) < n := by\n          have h\u2088 : (z % n : \u2124) < n := by\n            apply Int.emod_lt_of_pos\n            <;> norm_cast <;> omega\n          exact h\u2088\n        have h\u2088 : (z % n : \u2124) \u2264 (n - 1 : \u2124) := by\n          have h\u2089 : (z % n : \u2124) < n := h\u2087\n          have h\u2081\u2080 : (z % n : \u2124) \u2264 (n - 1 : \u2124) := by\n            omega\n          exact h\u2081\u2080\n        simp [Finset.mem_Icc]\n        <;>\n        (try omega) <;>\n        (try simp_all) <;>\n        (try linarith)\n      have h\u2086 : (z % n : \u2124) \u2208 (aR.image (fun s : \u2124 => s % n)) := by\n        rw [h\u2084] at *\n        exact h\u2085\n      -- Obtain the element in aR with the desired residue\n      obtain \u27e8r, hr, h\u2087\u27e9 := Finset.mem_image.mp h\u2086\n      use r\n      <;> simp_all [Int.ModEq]\n      <;>\n      (try omega) <;>\n      (try\n        {\n          have h\u2088 : (r : \u2124) % n = z % n := by simpa using h\u2087\n          have h\u2089 : (r : \u2124) \u2261 z [ZMOD n] := by\n            rw [Int.ModEq]\n            have h\u2081\u2080 : (r : \u2124) % n = z % n := h\u2088\n            omega\n          exact h\u2089.symm\n        })\n      <;>\n      (try\n        {\n          aesop\n        })\n  \n  have h_unique : \u2200 (z : \u2124) (r\u2081 r\u2082 : \u2124), r\u2081 \u2208 aR \u2192 r\u2082 \u2208 aR \u2192 z \u2261 r\u2081 [ZMOD n] \u2192 z \u2261 r\u2082 [ZMOD n] \u2192 r\u2081 = r\u2082 := by\n    intro z r\u2081 r\u2082 hr\u2081 hr\u2082 hz\u2081 hz\u2082\n    have h\u2081 : r\u2081 \u2261 r\u2082 [ZMOD n] := by\n      have h\u2082 : r\u2081 \u2261 z [ZMOD n] := by\n        -- Use the fact that z \u2261 r\u2081 [ZMOD n] to get r\u2081 \u2261 z [ZMOD n]\n        have h\u2083 : z \u2261 r\u2081 [ZMOD n] := hz\u2081\n        exact h\u2083.symm\n      have h\u2083 : z \u2261 r\u2082 [ZMOD n] := hz\u2082\n      -- Combine the congruences to get r\u2081 \u2261 r\u2082 [ZMOD n]\n      calc\n        r\u2081 \u2261 z [ZMOD n] := h\u2082\n        _ \u2261 r\u2082 [ZMOD n] := h\u2083\n    -- Use the injectivity of aR to conclude r\u2081 = r\u2082\n    have h\u2082 : r\u2081 = r\u2082 := h_injective r\u2081 r\u2082 hr\u2081 hr\u2082 h\u2081\n    exact h\u2082\n  \n  have h_final : \u2200 z : \u2124, \u2203! r \u2208 aR, z \u2261 r [ZMOD n] := by\n    intro z\n    have h\u2081 : \u2203 r \u2208 aR, z \u2261 r [ZMOD n] := h_main z\n    obtain \u27e8r, hr, hz\u27e9 := h\u2081\n    refine' \u27e8r, \u27e8hr, hz\u27e9, _\u27e9\n    rintro y \u27e8hy, hz'\u27e9\n    have h\u2082 : y = r := by\n      have h\u2083 : y \u2261 z [ZMOD n] := by\n        -- Use the symmetry of congruence to get y \u2261 z [ZMOD n]\n        have h\u2084 : z \u2261 y [ZMOD n] := hz'\n        exact h\u2084.symm\n      have h\u2084 : y \u2261 r [ZMOD n] := by\n        -- Combine y \u2261 z [ZMOD n] and z \u2261 r [ZMOD n] to get y \u2261 r [ZMOD n]\n        calc\n          y \u2261 z [ZMOD n] := h\u2083\n          _ \u2261 r [ZMOD n] := hz\n      -- Use the injectivity of aR to conclude y = r\n      have h\u2085 : y = r := h_injective y r hy hr h\u2084\n      exact h\u2085\n    exact h\u2082\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The completeness condition for R is correctly formalized with both cardinality and the existence-uniqueness property for residue representatives.", "The integer type and coprimality condition for a are properly captured.", "The general cancellation property is correctly formalized, though with multiplication order switched (y*c vs cy), which is mathematically equivalent.", "The set aR is properly defined using Finset.image, which correctly captures the set comprehension {ax : x \u2208 R}.", "The injectivity property on elements of R is correctly formalized.", "The pairwise incongruence property is properly captured through the injectivity condition on aR.", "The cardinality condition is directly and correctly translated.", "The conclusion that aR is a complete set of residues is properly formalized using the same structure as the premise for R's completeness."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    