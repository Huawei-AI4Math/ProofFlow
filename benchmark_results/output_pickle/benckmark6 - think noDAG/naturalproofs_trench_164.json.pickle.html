
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $f$ be continuous at $\mathbf{X}_1=(x_{11},x_{21}, \dots, x_{n1})$
and $\mathbf{X}_2=(x_{12},x_{22}, \dots,x_{n2})$ and differentiable on the
line segment $L$ from $\mathbf{X}_1$ to $\mathbf{X}_2.$ Then
\begin{equation} \label{eq:5.4.21}
f(\mathbf{X}_2)-f(\mathbf{X}_1)=\sum_{i=1}^n f_{x_i} (\mathbf{X}_0)(x_{i2}-x_{i1})=(d_{\mathbf{X}_0}f)(\mathbf{X}_2
-\mathbf{X}_1)
\end{equation}
for some $\mathbf{X}_0$ on $L$ distinct
from $\mathbf{X}_1$ and $\mathbf{X}_2$.

We can assume the following statement(s) without a proof. 

If $f$ is continuous on the closed interval $[a,b]$ and differentiable
on the open interval $(a,b),$ then
$$
f'(c)=\frac{f(b)-f(a)}{ b-a}
$$
for some $c$ in $(a,b).$

Proof: An equation of $L$ is
$$
\mathbf{X}=\mathbf{X}(t)=t\mathbf{X}_2+(1-t)\mathbf{X}_1,\quad 0\le t\le1.
$$
Our hypotheses imply that the function
$$
h(t)=f(\mathbf{X}(t))
$$
is continuous on $[0,1]$ and differentiable on $(0,1)$.  Since
$$
x_i(t)=tx_{i2}+(1-t)x_{i1},
$$
\eqref{eq:5.4.20} implies that
$$
h'(t)=\sum_{i=1}^n f_{x_i}(\mathbf{X}(t))(x_{i2}-x_{i1}),\quad 0<t<1.
$$
From the mean value theorem for functions of one variable
(Theorem~\ref{thmtype:2.3.11}),
$$
h(1)-h(0)=h'(t_0)
$$
for some $t_0\in (0,1)$.  Since $h(1)=f(\mathbf{X}_2)$ and
$h(0)=f(\mathbf{X}_1)$, this implies \eqref{eq:5.4.21} with
$\mathbf{X}_0=\mathbf{X}(t_0)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f$ be continuous at $\\mathbf{X}_1=(x_{11},x_{21}, \\dots, x_{n1})$\nand $\\mathbf{X}_2=(x_{12},x_{22}, \\dots,x_{n2})$ and differentiable on the\nline segment $L$ from $\\mathbf{X}_1$ to $\\mathbf{X}_2.$", "statement": "Premise:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function, with $\\mathbf{X}_1, \\mathbf{X}_2 \\in \\mathbb{R}^n$ [tc_1_p1].\n\u2022 $f$ is continuous at $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p2].\n\u2022 $f$ is differentiable on the line segment $L$ connecting $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p3].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  \u2203 X\u2080 \u2208 convexHull \u211d {X\u2081, X\u2082}, X\u2080 \u2260 X\u2081 \u2227 X\u2080 \u2260 X\u2082 \u2227 \n  f X\u2082 - f X\u2081 = (fderiv \u211d f X\u2080) (X\u2082 - X\u2081) := by sorry", "lean_pass": true, "error_msg": [], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language uses $\\mathbb{R}^n$ while Lean uses `Fin n \u2192 \u211d`. These represent the same mathematical concept (n-dimensional real vectors) but with different formal representations. `Fin n \u2192 \u211d` is Lean's standard way to represent finite-dimensional real vector spaces.", "Both versions state that f is continuous at X\u2081 and X\u2082. The Lean formalization captures this exactly with ContinuousAt predicates.", "The natural language mentions differentiability on the line segment L, and Lean uses `convexHull \u211d {X\u2081, X\u2082}` which is exactly the line segment connecting X\u2081 and X\u2082. This is a perfect mathematical match."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $f$ is continuous on the closed interval $[a,b]$ and differentiable on the open interval $(a,b),$ then\n$$\nf'(c)=\\frac{f(b)-f(a)}{ b-a}\n$$\nfor some $c$ in $(a,b).$", "statement": "Premise:\n\u2022 For any single-variable function $g: [a,b] \\to \\mathbb{R}$ that is continuous on $[a,b]$ and differentiable on $(a,b)$, there exists a $c \\in (a,b)$ such that $g'(c) = \\frac{g(b)-g(a)}{b-a}$ (Mean Value Theorem) [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (a b : \u211d) (hab : a < b) (g : \u211d \u2192 \u211d) \n  (hcont : ContinuousOn g (Set.Icc a b))\n  (hdiff : DifferentiableOn \u211d g (Set.Ioo a b)) :\n  \u2203 c \u2208 Set.Ioo a b, deriv g c = (g b - g a) / (b - a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization uses `g : \u211d \u2192 \u211d` which is a function from all reals to reals, but the domain is effectively restricted to `[a,b]` through the continuity and differentiability conditions. This captures the same mathematical meaning as the natural language.", "The Lean `ContinuousOn g (Set.Icc a b)` perfectly matches the natural language requirement that g is continuous on [a,b], where `Set.Icc a b` represents the closed interval [a,b].", "The Lean `DifferentiableOn \u211d g (Set.Ioo a b)` perfectly matches the natural language requirement that g is differentiable on (a,b), where `Set.Ioo a b` represents the open interval (a,b).", "The Lean conclusion `\u2203 c \u2208 Set.Ioo a b, deriv g c = (g b - g a) / (b - a)` perfectly matches the natural language conclusion, where `Set.Ioo a b` represents (a,b), `deriv g c` represents g'(c), and the equation matches exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "An equation of $L$ is\n$$\n\\mathbf{X}=\\mathbf{X}(t)=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1,\\quad 0\\le t\\le1.\n$$", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function, with $\\mathbf{X}_1, \\mathbf{X}_2 \\in \\mathbb{R}^n$ [tc_1_p1].\n\u2022 $f$ is continuous at $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p2].\n\u2022 $f$ is differentiable on the line segment $L$ connecting $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p3].\n\u2022 For any single-variable function $g: [a,b] \\to \\mathbb{R}$ that is continuous on $[a,b]$ and differentiable on $(a,b)$, there exists a $c \\in (a,b)$ such that $g'(c) = \\frac{g(b)-g(a)}{b-a}$ (Mean Value Theorem) [tc_2].\nDefinition:\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = t\\mathbf{X}_2 + (1-t)\\mathbf{X}_1$ for $t \\in [0,1]$ [def_1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef lineSegment (n : \u2115) (X\u2081 X\u2082 : Fin n \u2192 \u211d) : \n  \u211d \u2192 (Fin n \u2192 \u211d) := fun t => t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 := by sorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 52, "endLine": 8, "endColumn": 54, "data": "unexpected token ':='; expected command"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "the function\n$$\nh(t)=f(\\mathbf{X}(t))\n$$", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function, with $\\mathbf{X}_1, \\mathbf{X}_2 \\in \\mathbb{R}^n$ [tc_1_p1].\n\u2022 $f$ is continuous at $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p2].\n\u2022 $f$ is differentiable on the line segment $L$ connecting $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p3].\n\u2022 For any single-variable function $g: [a,b] \\to \\mathbb{R}$ that is continuous on $[a,b]$ and differentiable on $(a,b)$, there exists a $c \\in (a,b)$ such that $g'(c) = \\frac{g(b)-g(a)}{b-a}$ (Mean Value Theorem) [tc_2].\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = t\\mathbf{X}_2 + (1-t)\\mathbf{X}_1$ for $t \\in [0,1]$ [def_1].\nDefinition:\n\u2022 A new function $h: [0,1] \\to \\mathbb{R}$ is defined as $h(t) = f(\\mathbf{X}(t))$ [def_2].", "dependencies": ["tc_1", "tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t\u2080 = (f X\u2082 - f X\u2081) / (1 - 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean uses `Fin n \u2192 \u211d` to represent vectors in \u211d\u207f, which is a valid but different representation than the mathematical notation. This is a standard encoding in Lean but not a direct translation.", "The continuity conditions match exactly between natural language and Lean.", "The differentiability on the line segment is correctly captured using `convexHull \u211d {X\u2081, X\u2082}` which represents the line segment between the two points.", "The Mean Value Theorem is listed as a condition in the natural language but is not explicitly stated as a hypothesis in the Lean formalization, though it's implicitly used in the conclusion.", "The parameterization matches perfectly, with the Lean version correctly implementing the component-wise definition.", "The natural language states this as a definition/conclusion, but the Lean formalization goes beyond this by proving the existence of a point where the Mean Value Theorem holds, which is not mentioned in the natural language conclusion."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean uses `Fin n \u2192 \u211d` to represent vectors in \u211d\u207f, which is a valid but different representation than the mathematical notation. This is a standard encoding in Lean but not a direct translation.', 'The continuity conditions match exactly between natural language and Lean.', 'The differentiability on the line segment is correctly captured using `convexHull \u211d {X\u2081, X\u2082}` which represents the line segment between the two points.', \"The Mean Value Theorem is listed as a condition in the natural language but is not explicitly stated as a hypothesis in the Lean formalization, though it's implicitly used in the conclusion.\", 'The parameterization matches perfectly, with the Lean version correctly implementing the component-wise definition.', 'The natural language states this as a definition/conclusion, but the Lean formalization goes beyond this by proving the existence of a point where the Mean Value Theorem holds, which is not mentioned in the natural language conclusion.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Our hypotheses imply that the function\n$$\nh(t)=f(\\mathbf{X}(t))\n$$\nis continuous on $[0,1]$ and differentiable on $(0,1)$.", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function, with $\\mathbf{X}_1, \\mathbf{X}_2 \\in \\mathbb{R}^n$ [tc_1_p1].\n\u2022 $f$ is continuous at $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p2].\n\u2022 $f$ is differentiable on the line segment $L$ connecting $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p3].\n\u2022 For any single-variable function $g: [a,b] \\to \\mathbb{R}$ that is continuous on $[a,b]$ and differentiable on $(a,b)$, there exists a $c \\in (a,b)$ such that $g'(c) = \\frac{g(b)-g(a)}{b-a}$ (Mean Value Theorem) [tc_2].\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = t\\mathbf{X}_2 + (1-t)\\mathbf{X}_1$ for $t \\in [0,1]$ [def_1].\n\u2022 A new function $h: [0,1] \\to \\mathbb{R}$ is defined as $h(t) = f(\\mathbf{X}(t))$ [def_2].\nTherefore, we conclude:\n\u2022 The function $h(t)$ is continuous on $[0,1]$ and differentiable on $(0,1)$ [l1].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n  intro X h\n  have hX_cont : ContinuousOn (fun t : \u211d => X t) (Set.Icc 0 1) := by\n    have h\u2081 : Continuous fun t : \u211d => (fun i : Fin n => t * X\u2082 i + (1 - t) * X\u2081 i : Fin n \u2192 \u211d) := by\n      -- Prove that each component is continuous\n      have h\u2082 : \u2200 (i : Fin n), Continuous fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d) := by\n        intro i\n        continuity\n      -- Use the fact that each component is continuous to prove continuity of the function\n      apply continuous_pi\n      intro i\n      exact h\u2082 i\n    -- Restrict the continuity to the interval [0,1]\n    exact h\u2081.continuousOn\n  \n  have hX_subset : (Set.Icc 0 1).image (fun t : \u211d => X t) \u2286 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n    intro y hy\n    rw [Set.mem_image] at hy\n    rcases hy with \u27e8t, ht, rfl\u27e9\n    have h\u2081 : 0 \u2264 t := by exact ht.1\n    have h\u2082 : t \u2264 1 := by exact ht.2\n    have h\u2083 : X t = (1 - t) \u2022 X\u2081 + t \u2022 X\u2082 := by\n      funext i\n      simp [X]\n      <;> ring_nf\n      <;> simp_all [Finset.sum_range_succ]\n      <;> linarith\n    rw [h\u2083]\n    have h\u2084 : (1 - t : \u211d) \u2265 0 := by linarith\n    have h\u2085 : (t : \u211d) \u2265 0 := by linarith\n    have h\u2086 : (1 - t : \u211d) + t = 1 := by ring\n    -- Use the convex combination property to show membership in the convex hull\n    have h\u2087 : (1 - t : \u211d) \u2022 X\u2081 + t \u2022 X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n      -- Use the fact that the convex hull is closed under convex combinations\n      have h\u2088 : Convex \u211d (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) :=\n        convex_convexHull _\n      have h\u2089 : X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        apply convexHull_subset\n        simp [Set.subset_def]\n        <;>\n        (try aesop)\n        <;>\n        (try\n          {\n            cases n <;> simp_all [Fin.ext_iff]\n            <;>\n            (try aesop)\n          })\n      have h\u2081\u2080 : X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        apply convexHull_subset\n        simp [Set.subset_def]\n        <;>\n        (try aesop)\n        <;>\n        (try\n          {\n            cases n <;> simp_all [Fin.ext_iff]\n            <;>\n            (try aesop)\n          })\n      -- Use the convex combination property to show membership in the convex hull\n      have h\u2081\u2081 : (1 - t : \u211d) \u2022 X\u2081 + t \u2022 X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- Apply the convex combination lemma\n        have h\u2081\u2082 : 0 \u2264 (1 - t : \u211d) := by linarith\n        have h\u2081\u2083 : 0 \u2264 (t : \u211d) := by linarith\n        have h\u2081\u2084 : (1 - t : \u211d) + t = 1 := by ring\n        -- Use the convex combination property to show membership in the convex hull\n        have h\u2081\u2085 : (1 - t : \u211d) \u2022 X\u2081 + t \u2022 X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) :=\n          Convex.combo_mem' h\u2088 h\u2089 h\u2081\u2080 h\u2081\u2082 h\u2081\u2083 (by linarith)\n        exact h\u2081\u2085\n      exact h\u2081\u2081\n    exact h\u2087\n  \n  have hf_cont_on : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n    have h\u2081 : DifferentiableOn \u211d f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := hdiff\n    have h\u2082 : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := h\u2081.continuousOn\n    exact h\u2082\n  \n  have hh_cont_on : ContinuousOn h (Set.Icc 0 1) := by\n    have h\u2081 : ContinuousOn (fun t : \u211d => X t) (Set.Icc 0 1) := hX_cont\n    have h\u2082 : (Set.Icc 0 1).image (fun t : \u211d => X t) \u2286 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := hX_subset\n    have h\u2083 : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := hf_cont_on\n    have h\u2084 : ContinuousOn h (Set.Icc 0 1) := by\n      have h\u2085 : ContinuousOn (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc 0 1) := h\u2081\n      have h\u2086 : ContinuousOn (fun x : (Fin n \u2192 \u211d) => f x) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := h\u2083\n      have h\u2087 : ContinuousOn (fun t : \u211d => f (X t)) (Set.Icc 0 1) :=\n        ContinuousOn.comp h\u2086 h\u2085 (by\n          -- Show that the image of [0,1] under X is contained in the convex hull\n          intro x hx\n          simp only [Set.mem_image, Set.mem_Icc] at hx \u22a2\n          rcases hx with \u27e8t, ht, rfl\u27e9\n          have h\u2088 : (X t : Fin n \u2192 \u211d) \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) :=\n            hX_subset (Set.mem_image_of_mem (Set.mem_Icc.mpr \u27e8by linarith [ht.1], by linarith [ht.2]\u27e9))\n          exact h\u2088)\n      -- Simplify the expression to match the definition of h\n      simpa [h] using h\u2087\n    exact h\u2084\n  \n  have hX_diff_on : DifferentiableOn \u211d (fun t : \u211d => X t) (Set.Ioo 0 1) := by\n    have h\u2081 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) (Set.univ : Set \u211d) := by\n      intro i\n      apply DifferentiableOn.add\n      \u00b7 apply DifferentiableOn.mul\n        \u00b7 exact differentiableOn_id\n        \u00b7 exact differentiableOn_const _\n      \u00b7 apply DifferentiableOn.mul\n        \u00b7 apply DifferentiableOn.sub\n          \u00b7 exact differentiableOn_const _\n          \u00b7 exact differentiableOn_id\n        \u00b7 exact differentiableOn_const _\n    have h\u2082 : DifferentiableOn \u211d (fun t : \u211d => X t) (Set.Ioo 0 1) := by\n      -- Use the fact that each component is differentiable to show that the function is differentiable\n      have h\u2083 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t : \u211d => (X t i : \u211d)) (Set.Ioo 0 1) := by\n        intro i\n        have h\u2084 : DifferentiableOn \u211d (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) (Set.univ : Set \u211d) :=\n          h\u2081 i\n        have h\u2085 : DifferentiableOn \u211d (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) (Set.Ioo 0 1) := by\n          apply h\u2084.mono\n          intro x hx\n          trivial\n        have h\u2086 : (fun t : \u211d => (X t i : \u211d)) = (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) := by\n          funext t\n          simp [X]\n          <;> ring_nf\n        rw [h\u2086]\n        exact h\u2085\n      -- Use the fact that each component is differentiable to show that the function is differentiable\n      have h\u2087 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) := by\n        -- Use the fact that each component is differentiable to show that the function is differentiable\n        have h\u2088 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t : \u211d => (X t i : \u211d)) (Set.Ioo 0 1) := h\u2083\n        -- Use the fact that each component is differentiable to show that the function is differentiable\n        have h\u2089 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) := by\n          -- Use the fact that each component is differentiable to show that the function is differentiable\n          have h\u2081\u2080 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t : \u211d => (X t i : \u211d)) (Set.Ioo 0 1) := h\u2083\n          -- Use the fact that each component is differentiable to show that the function is differentiable\n          have h\u2081\u2081 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) := by\n            -- Use the fact that each component is differentiable to show that the function is differentiable\n            apply differentiableOn_pi\n            intro i\n            exact h\u2081\u2080 i\n          exact h\u2081\u2081\n        exact h\u2089\n      simpa using h\u2087\n    exact h\u2082\n  \n  have hh_diff_on : DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n    have h\u2081 : DifferentiableOn \u211d (fun t : \u211d => X t) (Set.Ioo 0 1) := hX_diff_on\n    have h\u2082 : (Set.Ioo 0 1).image (fun t : \u211d => X t) \u2286 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n      intro y hy\n      rw [Set.mem_image] at hy\n      rcases hy with \u27e8t, ht, rfl\u27e9\n      have h\u2083 : 0 < t := ht.1\n      have h\u2084 : t < 1 := ht.2\n      have h\u2085 : X t = (1 - t) \u2022 X\u2081 + t \u2022 X\u2082 := by\n        funext i\n        simp [X]\n        <;> ring_nf\n        <;> simp_all [Finset.sum_range_succ]\n        <;> linarith\n      rw [h\u2085]\n      have h\u2086 : (1 - t : \u211d) \u2265 0 := by linarith\n      have h\u2087 : (t : \u211d) \u2265 0 := by linarith\n      have h\u2088 : (1 - t : \u211d) + t = 1 := by ring\n      -- Use the convex combination property to show membership in the convex hull\n      have h\u2089 : (1 - t : \u211d) \u2022 X\u2081 + t \u2022 X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- Use the fact that the convex hull is closed under convex combinations\n        have h\u2081\u2080 : Convex \u211d (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) :=\n          convex_convexHull _\n        have h\u2081\u2081 : X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          apply convexHull_subset\n          simp [Set.subset_def]\n          <;>\n          (try aesop)\n          <;>\n          (try\n            {\n              cases n <;> simp_all [Fin.ext_iff]\n              <;>\n              (try aesop)\n            })\n        have h\u2081\u2082 : X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          apply convexHull_subset\n          simp [Set.subset_def]\n          <;>\n          (try aesop)\n          <;>\n          (try\n            {\n              cases n <;> simp_all [Fin.ext_iff]\n              <;>\n              (try aesop)\n            })\n        -- Use the convex combination property to show membership in the convex hull\n        have h\u2081\u2083 : (1 - t : \u211d) \u2022 X\u2081 + t \u2022 X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          -- Apply the convex combination lemma\n          have h\u2081\u2084 : 0 \u2264 (1 - t : \u211d) := by linarith\n          have h\u2081\u2085 : 0 \u2264 (t : \u211d) := by linarith\n          have h\u2081\u2086 : (1 - t : \u211d) + t = 1 := by ring\n          -- Use the convex combination property to show membership in the convex hull\n          have h\u2081\u2087 : (1 - t : \u211d) \u2022 X\u2081 + t \u2022 X\u2082 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) :=\n            Convex.combo_mem' h\u2081\u2080 h\u2081\u2081 h\u2081\u2082 h\u2081\u2084 h\u2081\u2085 (by linarith)\n          exact h\u2081\u2087\n        exact h\u2081\u2083\n      exact h\u2089\n    have h\u2083 : DifferentiableOn \u211d f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := hdiff\n    have h\u2084 : DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n      have h\u2085 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n        intro t ht\n        have h\u2086 : (X t : Fin n \u2192 \u211d) \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) :=\n          h\u2082 (Set.mem_image_of_mem ht)\n        exact h\u2086\n      have h\u2086 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) := by\n        simpa using h\u2081\n      have h\u2087 : DifferentiableOn \u211d (fun x : (Fin n \u2192 \u211d) => f x) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := h\u2083\n      have h\u2088 : DifferentiableOn \u211d (fun t : \u211d => f (X t)) (Set.Ioo 0 1) :=\n        DifferentiableOn.comp (Set.Ioo 0 1) h\u2087 h\u2086 h\u2085\n      simpa [h] using h\u2088\n    exact h\u2084\n  \n  exact \u27e8hh_cont_on, hh_diff_on\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 45, "column": 8, "endLine": 45, "endColumn": 27, "data": "type mismatch\n  convex_convexHull ?m.56752\nhas type\n  \u2200 (s : Set ?m.56753), Convex ?m.56752 ((convexHull ?m.56752) s) : Prop\nbut is expected to have type\n  Convex \u211d ((convexHull \u211d) {X\u2081, X\u2082}) : Prop"}, {"line": 47, "column": 14, "endLine": 47, "endColumn": 31, "data": "unknown identifier 'convexHull_subset'"}, {"line": 48, "column": 8, "endLine": 57, "endColumn": 12, "data": "no goals to be solved"}, {"line": 59, "column": 14, "endLine": 59, "endColumn": 31, "data": "unknown identifier 'convexHull_subset'"}, {"line": 60, "column": 8, "endLine": 69, "endColumn": 12, "data": "no goals to be solved"}, {"line": 78, "column": 10, "endLine": 78, "endColumn": 59, "data": "unknown constant 'Convex.combo_mem''"}, {"line": 100, "column": 25, "endLine": 100, "endColumn": 37, "data": "rcases tactic failed: right\u271d : Real.le\u271d x 1 is not an inductive datatype"}, {"line": 147, "column": 12, "endLine": 147, "endColumn": 37, "data": "tactic 'apply' failed, failed to unify\n  \u2200 [inst : (i : ?\u03b9) \u2192 NormedSpace ?\ud835\udd5c (?F' i)] {\u03a6 : ?E \u2192 (i : ?\u03b9) \u2192 ?F' i},\n    DifferentiableOn ?\ud835\udd5c \u03a6 ?s \u2194 \u2200 (i : ?\u03b9), DifferentiableOn ?\ud835\udd5c (fun x => \u03a6 x i) ?s\nwith\n  DifferentiableOn \u211d (fun t => X t) (Set.Ioo 0 1)\nn : \u2115\nf : (Fin n \u2192 \u211d) \u2192 \u211d\nX\u2081 X\u2082 : Fin n \u2192 \u211d\nhcont1 : ContinuousAt f X\u2081\nhcont2 : ContinuousAt f X\u2082\nhdiff : DifferentiableOn \u211d f ((convexHull \u211d) {X\u2081, X\u2082})\nX : \u211d \u2192 Fin n \u2192 \u211d := fun t i => t * X\u2082 i + (1 - t) * X\u2081 i\nh : \u211d \u2192 \u211d := fun t => f (X t)\nhX_cont : ContinuousOn (fun t => X t) (Set.Icc 0 1)\nhX_subset : (fun t => X t) '' Set.Icc 0 1 \u2286 (convexHull \u211d) {X\u2081, X\u2082}\nhf_cont_on : ContinuousOn f ((convexHull \u211d) {X\u2081, X\u2082})\nhh_cont_on : ContinuousOn h (Set.Icc 0 1)\nh\u2081 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t => t * X\u2082 i + (1 - t) * X\u2081 i) Set.univ\nh\u2083 h\u2088 h\u2081\u2080 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t => X t i) (Set.Ioo 0 1)\n\u22a2 DifferentiableOn \u211d (fun t => X t) (Set.Ioo 0 1)"}, {"line": 177, "column": 10, "endLine": 177, "endColumn": 29, "data": "type mismatch\n  convex_convexHull ?m.112713\nhas type\n  \u2200 (s : Set ?m.112714), Convex ?m.112713 ((convexHull ?m.112713) s) : Prop\nbut is expected to have type\n  Convex \u211d ((convexHull \u211d) {X\u2081, X\u2082}) : Prop"}, {"line": 179, "column": 16, "endLine": 179, "endColumn": 33, "data": "unknown identifier 'convexHull_subset'"}, {"line": 180, "column": 10, "endLine": 189, "endColumn": 14, "data": "no goals to be solved"}, {"line": 191, "column": 16, "endLine": 191, "endColumn": 33, "data": "unknown identifier 'convexHull_subset'"}, {"line": 192, "column": 10, "endLine": 201, "endColumn": 14, "data": "no goals to be solved"}, {"line": 210, "column": 12, "endLine": 210, "endColumn": 63, "data": "unknown constant 'Convex.combo_mem''"}, {"line": 219, "column": 13, "endLine": 219, "endColumn": 38, "data": "application type mismatch\n  h\u2082 (Set.mem_image_of_mem ?m.131857)\nargument\n  Set.mem_image_of_mem ?m.131857\nhas type\n  ?m.131858 \u2208 ?m.131859 \u2192 ?m.131857 ?m.131858 \u2208 ?m.131857 '' ?m.131859 : Prop\nbut is expected to have type\n  X t \u2208 (fun t => X t) '' Set.Ioo 0 1 : Prop"}, {"line": 219, "column": 35, "endLine": 219, "endColumn": 37, "data": "application type mismatch\n  @Set.mem_image_of_mem ?m.131388 ?m.131389 ht\nargument\n  ht\nhas type\n  t \u2208 Set.Ioo 0 1 : Prop\nbut is expected to have type\n  ?m.131388 \u2192 ?m.131389 : Type (max ?u.131386 ?u.131387)"}, {"line": 225, "column": 47, "endLine": 225, "endColumn": 49, "data": "application type mismatch\n  DifferentiableOn.comp ?m.142480 h\u2087 h\u2086\nargument\n  h\u2086\nhas type\n  DifferentiableOn \u211d (fun t => X t) (Set.Ioo 0 1) : Prop\nbut is expected to have type\n  Set.MapsTo (fun x => f x) ((convexHull \u211d) {X\u2081, X\u2082}) ?m.141829 : Prop"}, {"line": 225, "column": 30, "endLine": 225, "endColumn": 43, "data": "application type mismatch\n  DifferentiableOn.comp (Set.Ioo 0 1)\nargument\n  Set.Ioo 0 1\nhas type\n  Set \u2115 : Type\nbut is expected to have type\n  DifferentiableOn \u211d ?m.141828 ?m.141829 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function type and domain representation using Fin n \u2192 \u211d for \u211d\u207f is standard and correct in Lean.", "The continuity conditions are directly and correctly translated using ContinuousAt.", "Using convexHull \u211d {X\u2081, X\u2082} to represent the line segment is mathematically precise and correct.", "The Mean Value Theorem is not explicitly stated in the Lean code, but this is appropriate since it's available in Mathlib and not part of the theorem statement itself.", "The parameterization is correctly represented component-wise with the same mathematical formula.", "The composite function definition h(t) = f(X(t)) is directly and correctly translated.", "The conclusion correctly uses Set.Icc for closed interval [0,1] and Set.Ioo for open interval (0,1), with the conjunction properly representing both continuity and differentiability conditions.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  ContinuousOn h (Set.Icc 0 1) \u2227 DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n  intro X h\n  have h_main\u2081 : ContinuousOn h (Set.Icc 0 1) := by\n    have h\u2081 : ContinuousOn (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc 0 1) := by\n      -- Prove that X(t) is continuous on [0,1]\n      have h\u2082 : Continuous (fun t : \u211d => (X t : Fin n \u2192 \u211d)) := by\n        -- Each component of X(t) is linear in t, hence continuous\n        have h\u2083 : \u2200 i : Fin n, Continuous (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) := by\n          intro i\n          continuity\n        -- The function X(t) is continuous because each component is continuous\n        have h\u2084 : Continuous (fun t : \u211d => (X t : Fin n \u2192 \u211d)) := by\n          apply Continuous.prod_mk\n          <;>\n          (try simp_all [X]) <;>\n          (try continuity) <;>\n          (try\n            {\n              intro i\n              have h\u2085 := h\u2083 i\n              simpa [X] using h\u2085\n            })\n        exact h\u2084\n      -- Since X(t) is continuous everywhere, it is continuous on [0,1]\n      exact h\u2082.continuousOn\n    -- Prove that f is continuous on the convex hull of {X\u2081, X\u2082}\n    have h\u2082 : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n      -- f is differentiable on the convex hull, hence continuous\n      have h\u2083 : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) :=\n        hdiff.continuousOn\n      exact h\u2083\n    -- Prove that X([0,1]) \u2286 convexHull {X\u2081, X\u2082}\n    have h\u2083 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc 0 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n      intro t ht\n      have h\u2084 : t \u2208 Set.Icc (0 : \u211d) 1 := ht\n      have h\u2085 : (X t : Fin n \u2192 \u211d) \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- X(t) is a convex combination of X\u2081 and X\u2082\n        have h\u2086 : (X t : Fin n \u2192 \u211d) = (t : \u211d) \u2022 X\u2082 + (1 - t : \u211d) \u2022 X\u2081 := by\n          ext i\n          simp [X]\n          <;> ring\n          <;> simp_all [Finset.sum_range_succ]\n          <;> linarith\n        rw [h\u2086]\n        -- Use the fact that convexHull contains all convex combinations\n        have h\u2087 : (t : \u211d) \u2208 Set.Icc (0 : \u211d) 1 := by\n          constructor <;> linarith [h\u2084.1, h\u2084.2]\n        have h\u2088 : (t : \u211d) \u2022 X\u2082 + (1 - t : \u211d) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          -- Use the fact that the convex hull of two points contains all convex combinations\n          have h\u2089 : (t : \u211d) \u2022 X\u2082 + (1 - t : \u211d) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n            apply convex_hull_subset_convex_hull\n            <;>\n            (try simp_all [Set.mem_insert_iff, Set.mem_singleton_iff]) <;>\n            (try\n              {\n                use t\n                <;> simp_all [h\u2087]\n                <;> norm_num\n                <;> linarith\n              })\n            <;>\n            (try\n              {\n                simp_all [h\u2087]\n                <;> norm_num\n                <;> linarith\n              })\n          exact h\u2089\n        exact h\u2088\n      exact h\u2085\n    -- Since X is continuous on [0,1] and f is continuous on convexHull {X\u2081, X\u2082}, and X([0,1]) \u2286 convexHull {X\u2081, X\u2082}, h = f \u2218 X is continuous on [0,1]\n    have h\u2084 : ContinuousOn h (Set.Icc 0 1) := by\n      have h\u2085 : ContinuousOn (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc 0 1) := h\u2081\n      have h\u2086 : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := h\u2082\n      have h\u2087 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc 0 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := h\u2083\n      have h\u2088 : ContinuousOn (fun t : \u211d => f (X t)) (Set.Icc 0 1) :=\n        ContinuousOn.comp h\u2086 h\u2085 h\u2087\n      simpa [h] using h\u2088\n    exact h\u2084\n  \n  have h_main\u2082 : DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n    have h\u2081 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.univ : Set \u211d) := by\n      -- Prove that X(t) is differentiable everywhere\n      have h\u2082 : Differentiable \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) := by\n        -- Each component of X(t) is linear in t, hence differentiable\n        have h\u2083 : \u2200 i : Fin n, Differentiable \u211d (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) := by\n          intro i\n          apply Differentiable.add\n          \u00b7 -- Differentiate t * X\u2082 i\n            apply Differentiable.mul\n            \u00b7 exact differentiable_id\n            \u00b7 exact differentiable_const _\n          \u00b7 -- Differentiate (1 - t) * X\u2081 i\n            apply Differentiable.mul\n            \u00b7 -- Differentiate 1 - t\n              apply Differentiable.sub\n              \u00b7 exact differentiable_const _\n              \u00b7 exact differentiable_id\n            \u00b7 exact differentiable_const _\n        -- The function X(t) is differentiable because each component is differentiable\n        have h\u2084 : Differentiable \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) := by\n          apply Differentiable.prod_mk\n          <;>\n          (try simp_all [X]) <;>\n          (try\n            {\n              intro i\n              have h\u2085 := h\u2083 i\n              simpa [X] using h\u2085\n            })\n          <;>\n          (try continuity)\n        exact h\u2084\n      -- Since X(t) is differentiable everywhere, it is differentiable on Set.univ\n      exact h\u2082.differentiableOn\n    -- Restrict to (0,1)\n    have h\u2082 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) := by\n      apply h\u2081.mono\n      intro x hx\n      simp only [Set.mem_Ioo] at hx \u22a2\n      <;> trivial\n    -- Prove that for t \u2208 (0,1), X(t) \u2208 convexHull {X\u2081, X\u2082}\n    have h\u2083 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n      intro t ht\n      have h\u2084 : t \u2208 Set.Ioo (0 : \u211d) 1 := ht\n      have h\u2085 : (X t : Fin n \u2192 \u211d) \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- X(t) is a convex combination of X\u2081 and X\u2082\n        have h\u2086 : (X t : Fin n \u2192 \u211d) = (t : \u211d) \u2022 X\u2082 + (1 - t : \u211d) \u2022 X\u2081 := by\n          ext i\n          simp [X]\n          <;> ring\n          <;> simp_all [Finset.sum_range_succ]\n          <;> linarith [h\u2084.1, h\u2084.2]\n        rw [h\u2086]\n        -- Use the fact that convexHull contains all convex combinations\n        have h\u2087 : (t : \u211d) \u2208 Set.Icc (0 : \u211d) 1 := by\n          constructor <;> linarith [h\u2084.1, h\u2084.2]\n        have h\u2088 : (t : \u211d) \u2022 X\u2082 + (1 - t : \u211d) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          -- Use the fact that the convex hull of two points contains all convex combinations\n          have h\u2089 : (t : \u211d) \u2022 X\u2082 + (1 - t : \u211d) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n            apply convex_hull_subset_convex_hull\n            <;>\n            (try simp_all [Set.mem_insert_iff, Set.mem_singleton_iff]) <;>\n            (try\n              {\n                use t\n                <;> simp_all [h\u2087]\n                <;> norm_num\n                <;> linarith\n              })\n            <;>\n            (try\n              {\n                simp_all [h\u2087]\n                <;> norm_num\n                <;> linarith\n              })\n          exact h\u2089\n        exact h\u2088\n      exact h\u2085\n    -- Use the chain rule to prove that h is differentiable on (0,1)\n    have h\u2084 : DifferentiableOn \u211d h (Set.Ioo 0 1) := by\n      have h\u2085 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) := h\u2082\n      have h\u2086 : DifferentiableOn \u211d f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := hdiff\n      have h\u2087 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo 0 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := h\u2083\n      -- Apply the chain rule\n      have h\u2088 : DifferentiableOn \u211d (fun t : \u211d => f (X t)) (Set.Ioo 0 1) := by\n        apply DifferentiableOn.comp (Set.Ioo 0 1) h\u2086 h\u2085 h\u2087\n      simpa [h] using h\u2088\n    exact h\u2084\n  \n  exact \u27e8h_main\u2081, h_main\u2082\u27e9"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since\n$$\nx_i(t)=tx_{i2}+(1-t)x_{i1},\n$$\n\\eqref{eq:5.4.20} implies that\n$$\nh'(t)=\\sum_{i=1}^n f_{x_i}(\\mathbf{X}(t))(x_{i2}-x_{i1}),\\quad 0<t<1.\n$$", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function, with $\\mathbf{X}_1, \\mathbf{X}_2 \\in \\mathbb{R}^n$ [tc_1_p1].\n\u2022 $f$ is differentiable on the line segment $L$ connecting $\\mathbf{X}_1$ and $\\mathbf{X}_2$ [tc_1_p3].\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = t\\mathbf{X}_2 + (1-t)\\mathbf{X}_1$ for $t \\in [0,1]$ [def_1].\n\u2022 A new function $h: [0,1] \\to \\mathbb{R}$ is defined as $h(t) = f(\\mathbf{X}(t))$ [def_2].\n\u2022 The function $h(t)$ is differentiable on $(0,1)$ [l1].\nTherefore, we conclude:\n\u2022 For $t \\in (0,1)$, the derivative of $h(t)$ is $h'(t) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}(t))(x_{i2}-x_{i1})$ [l2].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  \u2200 t \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  \u2200 t \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i (1 : \u211d)) * (X\u2082 i - X\u2081 i) := by\n  intro X h t ht\n  have h\u2081 : X t \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by sorry\n  have h\u2082 : DifferentiableAt \u211d f (X t) := by sorry\n  have h\u2083 : HasDerivAt X (X\u2082 - X\u2081) t := by sorry\n  have h\u2084 : HasDerivAt h ((fderiv \u211d f (X t)) (X\u2082 - X\u2081)) t := by sorry\n  have h\u2085 : deriv h t = (fderiv \u211d f (X t)) (X\u2082 - X\u2081) := by sorry\n  have h\u2086 : (X\u2082 - X\u2081 : Fin n \u2192 \u211d) = \u2211 i : Fin n, (X\u2082 i - X\u2081 i) \u2022 (Pi.single i (1 : \u211d)) := by sorry\n  have h\u2087 : (fderiv \u211d f (X t)) (X\u2082 - X\u2081) = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i (1 : \u211d)) * (X\u2082 i - X\u2081 i) := by sorry\n  have h_main : deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i (1 : \u211d)) * (X\u2082 i - X\u2081 i) := by sorry\n  sorry", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 18, "column": 49, "endLine": 18, "endColumn": 86, "data": "failed to synthesize\n  HSMul \u211d ((j : Fin n) \u2192 ?m.10931 j) ?m.11762\n(deterministic) timeout at `typeclass`, maximum number of heartbeats (20000) has been reached\nUse `set_option synthInstance.maxHeartbeats <num>` to set the limit.\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 18, "column": 78, "endLine": 18, "endColumn": 85, "data": "application type mismatch\n  Pi.single i 1\nargument\n  1\nhas type\n  \u211d : Type\nbut is expected to have type\n  ?m.10931 i : Type ?u.10928"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Function type and variable declarations are correctly represented using Lean's equivalent types", "Differentiability on line segment is properly captured using convex hull", "Line segment parameterization is correctly translated component-wise", "Function h composition is properly defined, domain restriction handled in conclusion", "Differentiability condition is appropriately handled through the overall setup", "The derivative formula correctly uses fderiv with unit vectors to represent partial derivatives, and the summation structure matches exactly", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  \u2200 t \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i) := by\n  intro X h\n  intro t ht\n  have h_main : deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i) := by\n    have h\u2081 : HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i)) t := by\n      -- Prove that each component of X(t) has the derivative X\u2082 i - X\u2081 i\n      have h\u2082 : \u2200 i : Fin n, HasDerivAt (fun t : \u211d => X t i) (X\u2082 i - X\u2081 i) t := by\n        intro i\n        have h\u2083 : HasDerivAt (fun t : \u211d => (t : \u211d)) 1 t := by simpa using (hasDerivAt_id t)\n        have h\u2084 : HasDerivAt (fun t : \u211d => (1 - t : \u211d)) (-1 : \u211d) t := by\n          simpa using (hasDerivAt_const t (1 : \u211d)).sub (hasDerivAt_id t)\n        have h\u2085 : HasDerivAt (fun t : \u211d => (t * X\u2082 i : \u211d)) (1 * X\u2082 i) t := by\n          have h\u2086 : HasDerivAt (fun t : \u211d => (t : \u211d)) 1 t := by simpa using (hasDerivAt_id t)\n          have h\u2087 : HasDerivAt (fun t : \u211d => (t * X\u2082 i : \u211d)) (1 * X\u2082 i) t := by\n            convert HasDerivAt.mul h\u2086 (hasDerivAt_const t (X\u2082 i)) using 1 <;> ring\n          exact h\u2087\n        have h\u2088 : HasDerivAt (fun t : \u211d => ((1 - t : \u211d) * X\u2081 i : \u211d)) (-1 * X\u2081 i) t := by\n          have h\u2089 : HasDerivAt (fun t : \u211d => (1 - t : \u211d)) (-1 : \u211d) t := by\n            simpa using (hasDerivAt_const t (1 : \u211d)).sub (hasDerivAt_id t)\n          have h\u2081\u2080 : HasDerivAt (fun t : \u211d => ((1 - t : \u211d) * X\u2081 i : \u211d)) (-1 * X\u2081 i) t := by\n            convert HasDerivAt.mul h\u2089 (hasDerivAt_const t (X\u2081 i)) using 1 <;> ring\n          exact h\u2081\u2080\n        -- Combine the derivatives\n        have h\u2081\u2081 : HasDerivAt (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) (1 * X\u2082 i + (-1 * X\u2081 i)) t := by\n          convert h\u2085.add h\u2088 using 1 <;> ring\n        have h\u2081\u2082 : (fun t : \u211d => X t i) = (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) := by\n          funext t\n          simp [X]\n          <;> ring\n        rw [h\u2081\u2082]\n        convert h\u2081\u2081 using 1 <;> ring\n        <;> simp_all\n        <;> linarith\n      -- Use the fact that each component has the derivative X\u2082 i - X\u2081 i\n      -- to prove that X(t) has the derivative X\u2082 - X\u2081\n      have h\u2083 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := by\n        -- Use the fact that the derivative of a vector-valued function is the vector of the derivatives\n        have h\u2084 : \u2200 i : Fin n, HasDerivAt (fun t : \u211d => (X t i : \u211d)) (X\u2082 i - X\u2081 i) t := h\u2082\n        -- Use the fact that the derivative of a vector-valued function is the vector of the derivatives\n        have h\u2085 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := by\n          -- Use the fact that the derivative of a vector-valued function is the vector of the derivatives\n          have h\u2086 : \u2200 i : Fin n, HasDerivAt (fun t : \u211d => (X t i : \u211d)) (X\u2082 i - X\u2081 i) t := h\u2084\n          -- Use the fact that the derivative of a vector-valued function is the vector of the derivatives\n          have h\u2087 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := by\n            -- Use the fact that the derivative of a vector-valued function is the vector of the derivatives\n            convert hasDerivAt_pi (fun i : Fin n => h\u2086 i) using 1 <;> simp [X]\n            <;>\n            (try ext i) <;>\n            (try simp_all [Pi.single_apply, Fin.sum_univ_succ]) <;>\n            (try ring_nf) <;>\n            (try simp_all [Fin.sum_univ_succ]) <;>\n            (try linarith)\n          exact h\u2087\n        exact h\u2085\n      -- Use the chain rule to find the derivative of h(t) = f(X(t))\n      have h\u2084 : X t \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- Prove that X(t) is in the convex hull of {X\u2081, X\u2082}\n        have h\u2085 : 0 \u2264 t := by linarith [ht.1]\n        have h\u2086 : t \u2264 1 := by linarith [ht.2]\n        have h\u2087 : X t = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 := by\n          ext i\n          simp [X, smul_eq_mul]\n          <;> ring_nf\n          <;> simp_all\n          <;> linarith\n        rw [h\u2087]\n        -- Use the definition of convex hull\n        refine' convexHull_mem _ _ _\n        <;> simp_all [Set.mem_insert_iff, Set.mem_singleton_iff]\n        <;>\n        (try { aesop }) <;>\n        (try {\n          use t, 1 - t\n          <;> simp_all [Set.mem_insert_iff, Set.mem_singleton_iff]\n          <;> norm_num\n          <;>\n          (try linarith)\n          <;>\n          (try {\n            aesop\n          })\n        })\n      -- Prove that f is differentiable at X(t)\n      have h\u2085 : DifferentiableAt \u211d f (X t) := by\n        apply hdiff.differentiableAt\n        <;> aesop\n      -- Use the chain rule to find the derivative of h(t) = f(X(t))\n      have h\u2086 : HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i)) t := by\n        -- Use the fact that f is differentiable at X(t) and X(t) is differentiable at t\n        have h\u2087 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := h\u2083\n        have h\u2088 : HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i)) t := by\n          -- Use the chain rule for the derivative of h(t) = f(X(t))\n          have h\u2089 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := h\u2083\n          have h\u2081\u2080 : DifferentiableAt \u211d f (X t) := h\u2085\n          -- Use the chain rule to find the derivative of h(t) = f(X(t))\n          have h\u2081\u2081 : HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i)) t := by\n            -- Use the chain rule for the derivative of h(t) = f(X(t))\n            have h\u2081\u2082 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := h\u2083\n            have h\u2081\u2083 : HasFDerivAt f (fderiv \u211d f (X t)) (X t) := by\n              apply DifferentiableAt.hasFDerivAt\n              exact h\u2085\n            -- Use the chain rule to find the derivative of h(t) = f(X(t))\n            have h\u2081\u2084 : HasFDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d |>.symm (ContinuousLinearMap.smulRight (1 : \u211d) (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d))) t := by\n              -- Prove that the derivative of X(t) is ContinuousLinearMap.smulRight (1 : \u211d) (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d)\n              have h\u2081\u2085 : HasDerivAt (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (fun i : Fin n => (X\u2082 i - X\u2081 i)) t := h\u2083\n              -- Use the fact that the derivative of X(t) is (fun i : Fin n => (X\u2082 i - X\u2081 i))\n              convert (h\u2081\u2085.hasFDerivAt) using 1\n              <;> simp [ContinuousLinearMap.smulRight_apply]\n              <;>\n              (try simp_all [ContinuousLinearMap.smulRight_apply]) <;>\n              (try norm_num) <;>\n              (try ring_nf) <;>\n              (try simp_all [ContinuousLinearMap.smulRight_apply]) <;>\n              (try aesop)\n            -- Use the chain rule to find the derivative of h(t) = f(X(t))\n            have h\u2081\u2085 : HasFDerivAt h (fderiv \u211d f (X t) \u2218L (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d |>.symm (ContinuousLinearMap.smulRight (1 : \u211d) (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d)))) t := by\n              apply HasFDerivAt.comp t h\u2081\u2083 h\u2081\u2084\n            -- Convert the derivative to the form we need\n            have h\u2081\u2086 : (fderiv \u211d f (X t) \u2218L (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d |>.symm (ContinuousLinearMap.smulRight (1 : \u211d) (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d)))) = (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d |>.symm (ContinuousLinearMap.smulRight (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i)) (continuousLinearMapFintypeFinrank \u211d (Fin n) \u211d))) := by\n              -- Prove that the composition of the derivatives is the derivative we need\n              apply ContinuousLinearMap.ext\n              intro x\n              simp [ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.comp_apply, ContinuousLinearMap.fst]\n              <;>\n              (try simp_all [ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.comp_apply, ContinuousLinearMap.fst]) <;>\n              (try norm_num) <;>\n              (try ring_nf) <;>\n              (try simp_all [ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.comp_apply, ContinuousLinearMap.fst]) <;>\n              (try aesop)\n              <;>\n              (try {\n                simp_all [Finset.sum_apply]\n                <;>\n                simp_all [Pi.single_apply]\n                <;>\n                aesop\n              })\n            rw [h\u2081\u2086] at h\u2081\u2085\n            -- Convert the derivative to the form we need\n            have h\u2081\u2087 : HasDerivAt h (\u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i)) t := by\n              convert h\u2081\u2085.hasDerivAt using 1\n              <;> simp [ContinuousLinearMap.smulRight_apply]\n              <;>\n              (try simp_all [ContinuousLinearMap.smulRight_apply]) <;>\n              (try norm_num) <;>\n              (try ring_nf) <;>\n              (try simp_all [ContinuousLinearMap.smulRight_apply]) <;>\n              (try aesop)\n            exact h\u2081\u2087\n          exact h\u2081\u2081\n        exact h\u2088\n      exact h\u2086\n    -- Use the fact that h has the derivative to find the derivative of h\n    have h\u2082 : deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i) := by\n      -- Use the fact that h has the derivative to find the derivative of h\n      have h\u2083 : deriv h t = \u2211 i : Fin n, (fderiv \u211d f (X t)) (Pi.single i 1) * (X\u2082 i - X\u2081 i) := by\n        apply HasDerivAt.deriv\n        exact h\u2081\n      exact h\u2083\n    exact h\u2082\n  exact h_main"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "From the mean value theorem for functions of one variable\n(Theorem~\\ref{thmtype:2.3.11}),\n$$\nh(1)-h(0)=h'(t_0)\n$$\nfor some $t_0\\in (0,1)$.", "statement": "We assume:\n\u2022 For any single-variable function $g: [a,b] \\to \\mathbb{R}$ that is continuous on $[a,b]$ and differentiable on $(a,b)$, there exists a $c \\in (a,b)$ such that $g'(c) = \\frac{g(b)-g(a)}{b-a}$ (Mean Value Theorem) [tc_2].\n\u2022 The function $h(t)$ is continuous on $[0,1]$ and differentiable on $(0,1)$ [l1].\nTherefore, we conclude:\n\u2022 There exists some $t_0 \\in (0,1)$ such that $h(1)-h(0) = h'(t_0)$ [l3].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (h : \u211d \u2192 \u211d)\n  (hcont : ContinuousOn h (Set.Icc 0 1))\n  (hdiff : DifferentiableOn \u211d h (Set.Ioo 0 1)) :\n  \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t\u2080 = h 1 - h 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (h : \u211d \u2192 \u211d)\n  (hcont : ContinuousOn h (Set.Icc 0 1))\n  (hdiff : DifferentiableOn \u211d h (Set.Ioo 0 1)) :\n  \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t\u2080 = h 1 - h 0 := by\n  have h_main : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv h t\u2080 = (h 1 - h 0) / (1 - 0) := by\n    have h\u2081 : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv h t\u2080 = (h 1 - h 0) / (1 - 0) := by\n      -- Apply the Mean Value Theorem to find a point t\u2080 in (0,1) where the derivative equals the average rate of change\n      have h\u2082 : ContinuousOn h (Set.Icc 0 1) := hcont\n      have h\u2083 : DifferentiableOn \u211d h (Set.Ioo 0 1) := hdiff\n      have h\u2084 : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv h t\u2080 = (h 1 - h 0) / (1 - 0) := by\n        apply exists_deriv_eq_slope h\n        <;> norm_num\n        <;> (try assumption)\n        <;> (try exact h\u2082)\n        <;> (try exact h\u2083)\n        <;> (try norm_num)\n        <;> (try linarith)\n      exact h\u2084\n    exact h\u2081\n  \n  have h_final : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv h t\u2080 = h 1 - h 0 := by\n    obtain \u27e8t\u2080, ht\u2080, ht\u2080_eq\u27e9 := h_main\n    refine' \u27e8t\u2080, ht\u2080, _\u27e9\n    -- Simplify the expression (h 1 - h 0) / (1 - 0) to h 1 - h 0\n    have h\u2082 : (h 1 - h 0 : \u211d) / (1 - 0 : \u211d) = h 1 - h 0 := by\n      norm_num\n    rw [h\u2082] at ht\u2080_eq\n    -- Use the simplified expression to conclude the proof\n    exact ht\u2080_eq\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Mean Value Theorem assumption is implicitly available through Mathlib imports, which is standard practice in Lean", "The continuity and differentiability conditions are perfectly captured using the appropriate Lean notation for closed and open intervals", "The conclusion correctly formalizes the existence statement. The equation 'deriv h t\u2080 = h 1 - h 0' is mathematically equivalent to 'h(1)-h(0) = h'(t\u2080)' from the natural language, just with sides swapped"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Since $h(1)=f(\\mathbf{X}_2)$ and\n$h(0)=f(\\mathbf{X}_1)$", "statement": "We assume:\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = t\\mathbf{X}_2 + (1-t)\\mathbf{X}_1$ for $t \\in [0,1]$ [def_1].\n\u2022 A new function $h: [0,1] \\to \\mathbb{R}$ is defined as $h(t) = f(\\mathbf{X}(t))$ [def_2].\nTherefore, we conclude:\n\u2022 $h(1) = f(\\mathbf{X}_2)$ and $h(0) = f(\\mathbf{X}_1)$ [l4].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  h 1 = f X\u2082 \u2227 h 0 = f X\u2081 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  h 1 = f X\u2082 \u2227 h 0 = f X\u2081 := by\n  intro X h\n  have hX1 : X 1 = X\u2082 := by\n    funext i\n    simp only [X]\n    ring_nf\n    <;> simp [mul_comm]\n    <;> ring_nf\n    <;> norm_num\n  \n  have hX0 : X 0 = X\u2081 := by\n    funext i\n    simp only [X]\n    ring_nf\n    <;> simp [mul_comm]\n    <;> ring_nf\n    <;> norm_num\n  \n  have hh1 : h 1 = f X\u2082 := by\n    have h1 : h 1 = f (X 1) := rfl\n    rw [h1]\n    rw [hX1]\n    <;> simp_all\n  \n  have hh0 : h 0 = f X\u2081 := by\n    have h0 : h 0 = f (X 0) := rfl\n    rw [h0]\n    rw [hX0]\n    <;> simp_all\n  \n  exact \u27e8hh1, hh0\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The parameterization formula is mathematically identical. The domain extension from [0,1] to \u211d in Lean doesn't affect the logical content since only specific points are used.", "The function composition h(t) = f(X(t)) is correctly captured. Domain differences don't impact the mathematical meaning.", "The conclusion equations h(1) = f(X\u2082) and h(0) = f(X\u2081) are perfectly translated using logical conjunction.", "Additional continuity and differentiability assumptions in Lean are extra conditions that don't contradict the natural language and likely provide necessary mathematical context."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "this implies \\eqref{eq:5.4.21} with\n$\\mathbf{X}_0=\\mathbf{X}(t_0)$.", "statement": "We assume:\n\u2022 The line segment $L$ is parameterized by the function $\\mathbf{X}(t) = t\\mathbf{X}_2 + (1-t)\\mathbf{X}_1$ for $t \\in [0,1]$ [def_1].\n\u2022 For $t \\in (0,1)$, the derivative of $h(t)$ is $h'(t) = \\sum_{i=1}^n f_{x_i}(\\mathbf{X}(t))(x_{i2}-x_{i1})$ [l2].\n\u2022 There exists some $t_0 \\in (0,1)$ such that $h(1)-h(0) = h'(t_0)$ [l3].\n\u2022 $h(1) = f(\\mathbf{X}_2)$ and $h(0) = f(\\mathbf{X}_1)$ [l4].\nTherefore, we conclude:\n\u2022 There exists a point $\\mathbf{X}_0$ on the line segment $L$ distinct from $\\mathbf{X}_1$ and $\\mathbf{X}_2$, such that $f(\\mathbf{X}_2)-f(\\mathbf{X}_1)=\\sum_{i=1}^n f_{x_i} (\\mathbf{X}_0)(x_{i2}-x_{i1})=(d_{\\mathbf{X}_0}f)(\\mathbf{X}_2-\\mathbf{X}_1)$ [ts_1].", "dependencies": ["tc_1", "tc_2", "def_1", "def_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t\u2080 = f X\u2082 - f X\u2081 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {n : \u2115} (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2081 X\u2082 : Fin n \u2192 \u211d)\n  (hcont1 : ContinuousAt f X\u2081)\n  (hcont2 : ContinuousAt f X\u2082)\n  (hdiff : DifferentiableOn \u211d f (convexHull \u211d {X\u2081, X\u2082})) :\n  let X : \u211d \u2192 Fin n \u2192 \u211d := fun t => fun i => t * X\u2082 i + (1 - t) * X\u2081 i\n  let h : \u211d \u2192 \u211d := fun t => f (X t)\n  \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, \n    deriv h t\u2080 = f X\u2082 - f X\u2081 := by\n  intro X h\n  have h\u2081 : ContinuousOn (fun t : \u211d => f (X t)) (Set.Icc (0 : \u211d) 1) := by\n    have h\u2082 : ContinuousOn (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc (0 : \u211d) 1) := by\n      -- Prove that the parameterization X(t) is continuous\n      have h\u2083 : Continuous fun t : \u211d => (X t : Fin n \u2192 \u211d) := by\n        -- Show that each component is continuous\n        have h\u2084 : Continuous fun t : \u211d => (fun i : Fin n => t * X\u2082 i + (1 - t) * X\u2081 i : Fin n \u2192 \u211d) := by\n          apply Continuous.pi\n          intro i\n          continuity\n        simpa [X] using h\u2084\n      exact h\u2083.continuousOn\n    -- Prove that f is continuous on the convex hull\n    have h\u2084 : ContinuousOn f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n      -- Since f is differentiable on the convex hull, it is also continuous there\n      have h\u2085 : DifferentiableOn \u211d f (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := hdiff\n      exact h\u2085.continuousOn\n    -- Compose the two continuous functions\n    have h\u2085 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Icc (0 : \u211d) 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n      intro t ht\n      have h\u2086 : (X t : Fin n \u2192 \u211d) \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- Show that X(t) is in the convex hull\n        have h\u2087 : (X t : Fin n \u2192 \u211d) = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 := by\n          ext i\n          simp [X]\n          <;> ring_nf\n          <;> simp_all [Finset.sum_pair (show (X\u2081 : Fin n \u2192 \u211d) \u2260 X\u2082 by\n            intro h\n            have h\u2088 := congr_fun h (\u27e80, by\n              cases n <;> simp_all [Fin.ext_iff]\n              <;> omega\u27e9 : Fin n)\n            simp_all [X]\n            <;> ring_nf at *\n            <;> linarith)]\n          <;> field_simp\n          <;> ring_nf\n        rw [h\u2087]\n        -- Use the definition of convex hull\n        have h\u2088 : (t : \u211d) \u2022 X\u2082 + (1 - t) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          -- Prove that the point is in the convex hull\n          have h\u2089 : (t : \u211d) \u2022 X\u2082 + (1 - t) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n            -- Use the fact that the convex hull is convex\n            apply convexHull_min\n            \u00b7 -- Show that the set {X\u2081, X\u2082} is convex\n              intro x hx y hy a b ha hb hab\n              simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx hy\n              -- Consider the cases for x and y\n              rcases hx with (rfl | rfl) <;> rcases hy with (rfl | rfl) <;>\n                (try { contradiction }) <;>\n                (try {\n                  simp [convex_iff_forall_pos, Set.mem_insert_iff, Set.mem_singleton_iff]\n                  <;>\n                  (try { norm_num at * <;> aesop }) <;>\n                  (try {\n                    use 1\n                    <;> norm_num <;> aesop\n                  })\n                }) <;>\n                (try {\n                  simp_all [convex_iff_forall_pos, Set.mem_insert_iff, Set.mem_singleton_iff]\n                  <;>\n                  (try { norm_num at * <;> aesop }) <;>\n                  (try {\n                    use 1\n                    <;> norm_num <;> aesop\n                  })\n                })\n            \u00b7 -- Show that t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 is in the set {X\u2081, X\u2082}\n              simp only [Set.mem_insert_iff, Set.mem_singleton_iff]\n              <;>\n              (try {\n                cases n <;> simp_all [Fin.ext_iff]\n                <;> norm_num <;>\n                  (try {\n                    use 1\n                    <;> norm_num <;> aesop\n                  }) <;>\n                  (try {\n                    use 0\n                    <;> norm_num <;> aesop\n                  })\n              }) <;>\n              (try {\n                aesop\n              })\n          exact h\u2089\n        exact h\u2088\n      exact h\u2086\n    -- Use the fact that the image of [0,1] under X is in the convex hull to compose the continuous functions\n    have h\u2086 : ContinuousOn (fun t : \u211d => f (X t)) (Set.Icc (0 : \u211d) 1) := by\n      apply ContinuousOn.comp h\u2084 h\u2082 h\u2085\n    exact h\u2086\n  \n  have h\u2082 : DifferentiableOn \u211d (fun t : \u211d => f (X t)) (Set.Ioo (0 : \u211d) 1) := by\n    have h\u2083 : DifferentiableOn \u211d (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo (0 : \u211d) 1) := by\n      -- Prove that the parameterization X(t) is differentiable on (0,1)\n      have h\u2084 : \u2200 (i : Fin n), DifferentiableOn \u211d (fun t : \u211d => (t * X\u2082 i + (1 - t) * X\u2081 i : \u211d)) (Set.Ioo (0 : \u211d) 1) := by\n        intro i\n        apply DifferentiableOn.add\n        \u00b7 apply DifferentiableOn.mul\n          \u00b7 exact differentiableOn_id\n          \u00b7 exact differentiableOn_const _\n        \u00b7 apply DifferentiableOn.mul\n          \u00b7 apply DifferentiableOn.sub\n            \u00b7 exact differentiableOn_const _\n            \u00b7 exact differentiableOn_id\n          \u00b7 exact differentiableOn_const _\n      -- Use the fact that each component is differentiable to conclude that the function is differentiable\n      have h\u2085 : DifferentiableOn \u211d (fun t : \u211d => (fun i : Fin n => t * X\u2082 i + (1 - t) * X\u2081 i : Fin n \u2192 \u211d)) (Set.Ioo (0 : \u211d) 1) := by\n        apply DifferentiableOn.pi\n        intro i\n        exact h\u2084 i\n      simpa [X] using h\u2085\n    -- Prove that f is differentiable on the convex hull\n    have h\u2086 : Set.MapsTo (fun t : \u211d => (X t : Fin n \u2192 \u211d)) (Set.Ioo (0 : \u211d) 1) (convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d))) := by\n      intro t ht\n      have h\u2087 : (X t : Fin n \u2192 \u211d) \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n        -- Show that X(t) is in the convex hull\n        have h\u2088 : (X t : Fin n \u2192 \u211d) = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 := by\n          ext i\n          simp [X]\n          <;> ring_nf\n          <;> simp_all [Finset.sum_pair (show (X\u2081 : Fin n \u2192 \u211d) \u2260 X\u2082 by\n            intro h\n            have h\u2089 := congr_fun h (\u27e80, by\n              cases n <;> simp_all [Fin.ext_iff]\n              <;> omega\u27e9 : Fin n)\n            simp_all [X]\n            <;> ring_nf at *\n            <;> linarith)]\n          <;> field_simp\n          <;> ring_nf\n        rw [h\u2088]\n        -- Use the definition of convex hull\n        have h\u2089 : (t : \u211d) \u2022 X\u2082 + (1 - t) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n          -- Prove that the point is in the convex hull\n          have h\u2081\u2080 : (t : \u211d) \u2022 X\u2082 + (1 - t) \u2022 X\u2081 \u2208 convexHull \u211d ({X\u2081, X\u2082} : Set (Fin n \u2192 \u211d)) := by\n            -- Use the fact that the convex hull is convex\n            apply convexHull_min\n            \u00b7 -- Show that the set {X\u2081, X\u2082} is convex\n              intro x hx y hy a b ha hb hab\n              simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx hy\n              -- Consider the cases for x and y\n              rcases hx with (rfl | rfl) <;> rcases hy with (rfl | rfl) <;>\n                (try { contradiction }) <;>\n                (try {\n                  simp [convex_iff_forall_pos, Set.mem_insert_iff, Set.mem_singleton_iff]\n                  <;>\n                  (try { norm_num at * <;> aesop }) <;>\n                  (try {\n                    use 1\n                    <;> norm_num <;> aesop\n                  })\n                }) <;>\n                (try {\n                  simp_all [convex_iff_forall_pos, Set.mem_insert_iff, Set.mem_singleton_iff]\n                  <;>\n                  (try { norm_num at * <;> aesop }) <;>\n                  (try {\n                    use 1\n                    <;> norm_num <;> aesop\n                  })\n                })\n            \u00b7 -- Show that t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 is in the set {X\u2081, X\u2082}\n              simp only [Set.mem_insert_iff, Set.mem_singleton_iff]\n              <;>\n              (try {\n                cases n <;> simp_all [Fin.ext_iff]\n                <;> norm_num <;>\n                  (try {\n                    use 1\n                    <;> norm_num <;> aesop\n                  }) <;>\n                  (try {\n                    use 0\n                    <;> norm_num <;> aesop\n                  })\n              }) <;>\n              (try {\n                aesop\n              })\n          exact h\u2081\u2080\n        exact h\u2089\n      exact h\u2087\n    -- Use the chain rule to show that h is differentiable on (0,1)\n    have h\u2087 : DifferentiableOn \u211d (fun t : \u211d => f (X t)) (Set.Ioo (0 : \u211d) 1) := by\n      apply DifferentiableOn.comp hdiff h\u2083 h\u2086\n    exact h\u2087\n  \n  have h\u2083 : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv (fun t : \u211d => f (X t)) t\u2080 = (f X\u2082 - f X\u2081) := by\n    have h\u2084 : ContinuousOn (fun t : \u211d => f (X t)) (Set.Icc (0 : \u211d) 1) := h\u2081\n    have h\u2085 : DifferentiableOn \u211d (fun t : \u211d => f (X t)) (Set.Ioo (0 : \u211d) 1) := h\u2082\n    have h\u2086 : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv (fun t : \u211d => f (X t)) t\u2080 = (f X\u2082 - f X\u2081) := by\n      -- Apply the Mean Value Theorem\n      have h\u2087 : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv (fun t : \u211d => f (X t)) t\u2080 = (f X\u2082 - f X\u2081) := by\n        have h\u2088 : \u2203 t\u2080 \u2208 Set.Ioo (0 : \u211d) 1, deriv (fun t : \u211d => f (X t)) t\u2080 = ((f X\u2082 - f X\u2081) : \u211d) / (1 - (0 : \u211d)) := by\n          apply exists_deriv_eq_slope (fun t : \u211d => f (X t)) (by norm_num)\n          <;>\n            (try\n              {\n                exact h\u2084\n              })\n          <;>\n            (try\n              {\n                exact h\u2085\n              })\n          <;>\n            (try\n              {\n                simp_all [h]\n                <;>\n                  (try\n                    {\n                      norm_num\n                    })\n              })\n        obtain \u27e8t\u2080, ht\u2080, ht\u2080'\u27e9 := h\u2088\n        have h\u2089 : deriv (fun t : \u211d => f (X t)) t\u2080 = (f X\u2082 - f X\u2081) := by\n          have h\u2081\u2080 : deriv (fun t : \u211d => f (X t)) t\u2080 = ((f X\u2082 - f X\u2081) : \u211d) / (1 - (0 : \u211d)) := ht\u2080'\n          have h\u2081\u2081 : ((f X\u2082 - f X\u2081) : \u211d) / (1 - (0 : \u211d)) = (f X\u2082 - f X\u2081) := by norm_num\n          rw [h\u2081\u2080, h\u2081\u2081]\n        exact \u27e8t\u2080, ht\u2080, h\u2089\u27e9\n      exact h\u2087\n    exact h\u2086\n  \n  obtain \u27e8t\u2080, ht\u2080, ht\u2080'\u27e9 := h\u2083\n  refine' \u27e8t\u2080, ht\u2080, _\u27e9\n  simp_all [h]\n  <;>\n    (try\n      {\n        norm_num at *\n        <;>\n          (try\n            {\n              linarith\n            })\n      })\n  <;>\n    (try\n      {\n        aesop\n      })", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 16, "endLine": 19, "endColumn": 29, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  Continuous\nhas type\n  (?m.5813 \u2192 ?m.5814) \u2192 Prop"}, {"line": 20, "column": 10, "endLine": 20, "endColumn": 17, "data": "no goals to be solved"}, {"line": 54, "column": 12, "endLine": 54, "endColumn": 32, "data": "failed to synthesize\n  Module ?\ud835\udd5c (Fin n \u2192 \u211d)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 121, "column": 14, "endLine": 121, "endColumn": 33, "data": "unknown constant 'DifferentiableOn.pi'"}, {"line": 122, "column": 8, "endLine": 122, "endColumn": 15, "data": "no goals to be solved"}, {"line": 150, "column": 12, "endLine": 150, "endColumn": 32, "data": "failed to synthesize\n  Module ?\ud835\udd5c (Fin n \u2192 \u211d)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 208, "column": 10, "endLine": 208, "endColumn": 74, "data": "tactic 'apply' failed, failed to unify\n  \u2203 c \u2208 Set.Ioo ?m.47020 ?m.47021,\n    deriv (fun t => f (X t)) c = (f (X ?m.47021) - f (X ?m.47020)) / (?m.47021 - ?m.47020)\nwith\n  \u2203 t\u2080 \u2208 Set.Ioo 0 1, deriv (fun t => f (X t)) t\u2080 = (f X\u2082 - f X\u2081) / (1 - 0)\nn : \u2115\nf : (Fin n \u2192 \u211d) \u2192 \u211d\nX\u2081 X\u2082 : Fin n \u2192 \u211d\nhcont1 : ContinuousAt f X\u2081\nhcont2 : ContinuousAt f X\u2082\nhdiff : DifferentiableOn \u211d f ((convexHull \u211d) {X\u2081, X\u2082})\nX : \u211d \u2192 Fin n \u2192 \u211d := fun t i => t * X\u2082 i + (1 - t) * X\u2081 i\nh : \u211d \u2192 \u211d := fun t => f (X t)\nh\u2081 : ContinuousOn (fun t => f (X t)) (Set.Icc 0 1)\nh\u2082 : DifferentiableOn \u211d (fun t => f (X t)) (Set.Ioo 0 1)\nh\u2084 : ContinuousOn (fun t => f (X t)) (Set.Icc 0 1)\nh\u2085 : DifferentiableOn \u211d (fun t => f (X t)) (Set.Ioo 0 1)\n\u22a2 \u2203 t\u2080 \u2208 Set.Ioo 0 1, deriv (fun t => f (X t)) t\u2080 = (f X\u2082 - f X\u2081) / (1 - 0)"}, {"line": 208, "column": 62, "endLine": 208, "endColumn": 73, "data": "unsolved goals\nn : \u2115\nf : (Fin n \u2192 \u211d) \u2192 \u211d\nX\u2081 X\u2082 : Fin n \u2192 \u211d\nhcont1 : ContinuousAt f X\u2081\nhcont2 : ContinuousAt f X\u2082\nhdiff : DifferentiableOn \u211d f ((convexHull \u211d) {X\u2081, X\u2082})\nX : \u211d \u2192 Fin n \u2192 \u211d := fun t i => t * X\u2082 i + (1 - t) * X\u2081 i\nh : \u211d \u2192 \u211d := fun t => f (X t)\nh\u2081 : ContinuousOn (fun t => f (X t)) (Set.Icc 0 1)\nh\u2082 : DifferentiableOn \u211d (fun t => f (X t)) (Set.Ioo 0 1)\nh\u2084 : ContinuousOn (fun t => f (X t)) (Set.Icc 0 1)\nh\u2085 : DifferentiableOn \u211d (fun t => f (X t)) (Set.Ioo 0 1)\n\u22a2 ?m.47020 < ?m.47021"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The line segment parameterization X(t) = t*X\u2082 + (1-t)*X\u2081 is correctly captured in the Lean formalization.", "The derivative formula h'(t) = \u03a3f_{x_i}(X(t))(x_{i2}-x_{i1}) is not explicitly stated in the Lean code, though it's implicitly used through 'deriv h t\u2080'.", "The Mean Value Theorem application stating \u2203t\u2080\u2208(0,1) such that h(1)-h(0) = h'(t\u2080) is correctly formalized as the existence statement with deriv h t\u2080 = f X\u2082 - f X\u2081.", "The boundary conditions h(1) = f(X\u2082) and h(0) = f(X\u2081) are correctly captured through the definition of h and its usage in the conclusion.", "The final conclusion about the existence of point X\u2080 is captured, but the explicit gradient/directional derivative notation (d_{X\u2080}f)(X\u2082-X\u2081) is not shown in the Lean formalization, though the mathematical content is equivalent.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['The line segment parameterization X(t) = t*X\u2082 + (1-t)*X\u2081 is correctly captured in the Lean formalization.', \"The derivative formula h'(t) = \u03a3f_{x_i}(X(t))(x_{i2}-x_{i1}) is not explicitly stated in the Lean code, though it's implicitly used through 'deriv h t\u2080'.\", \"The Mean Value Theorem application stating \u2203t\u2080\u2208(0,1) such that h(1)-h(0) = h'(t\u2080) is correctly formalized as the existence statement with deriv h t\u2080 = f X\u2082 - f X\u2081.\", 'The boundary conditions h(1) = f(X\u2082) and h(0) = f(X\u2081) are correctly captured through the definition of h and its usage in the conclusion.', 'The final conclusion about the existence of point X\u2080 is captured, but the explicit gradient/directional derivative notation (d_{X\u2080}f)(X\u2082-X\u2081) is not shown in the Lean formalization, though the mathematical content is equivalent.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    