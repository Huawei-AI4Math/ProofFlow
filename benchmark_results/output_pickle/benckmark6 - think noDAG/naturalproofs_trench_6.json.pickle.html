
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $P_1,$ $P_2, $\dots$,$ $P_n,$ \dots\ be
propositions$,$ one
for each positive integer$,$ such that
\begin{alist}
\item % (a)
 $P_1$ is true$;$
\item % (b)
 for each positive integer $n,$  $P_n$  implies $P_{n+1}.$
\end{alist}
Then $P_n$ is true for each positive integer $n.$

Proof: Let
$$
\mathbb M=\set{n}{n\in \mathbb N\mbox{ and } P_n\mbox{ is
true}}.
$$
From \part{a}, $1\in \mathbb M$, and from \part{b}, $n+1\in \mathbb M$ whenever
$n\in \mathbb M$. Therefore, $\mathbb M=\mathbb N$, by postulate
\part{E}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $P_1,$ $P_2, \\dots, P_n, \\dots$ be propositions, one for each positive integer,", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 P n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language only states that P is a sequence of propositions indexed by positive integers, with no conclusions. However, the Lean formalization presents a complete mathematical induction theorem with base case (h1: P 1), inductive step (h2: \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)), and conclusion (\u2200 n : \u2115, n \u2265 1 \u2192 P n). The Lean version introduces significant logical components (induction hypothesis and conclusion) that are completely absent from the natural language premise statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language only states that P is a sequence of propositions indexed by positive integers, with no conclusions. However, the Lean formalization presents a complete mathematical induction theorem with base case (h1: P 1), inductive step (h2: \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)), and conclusion (\u2200 n : \u2115, n \u2265 1 \u2192 P n). The Lean version introduces significant logical components (induction hypothesis and conclusion) that are completely absent from the natural language premise statement.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "$P_1$ is true$;$", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 P n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures P as a sequence of propositions indexed by natural numbers", "The Lean formalization `(h1 : P 1)` correctly captures that P_1 is true", "The Lean formalization introduces an additional inductive hypothesis `(h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))` and derives a conclusion `\u2200 n : \u2115, n \u2265 1 \u2192 P n` that are not present in the natural language statement. The natural language explicitly states there are no conclusions, only initial conditions, but the Lean version appears to be setting up and proving a complete induction theorem"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures P as a sequence of propositions indexed by natural numbers', 'The Lean formalization `(h1 : P 1)` correctly captures that P_1 is true', 'The Lean formalization introduces an additional inductive hypothesis `(h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))` and derives a conclusion `\u2200 n : \u2115, n \u2265 1 \u2192 P n` that are not present in the natural language statement. The natural language explicitly states there are no conclusions, only initial conditions, but the Lean version appears to be setting up and proving a complete induction theorem']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "for each positive integer $n,$  $P_n$  implies $P_{n+1}.$", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 P n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures P as a sequence of propositions indexed by natural numbers. In Lean, \u2115 includes 0, but the constraint n \u2265 1 in the theorem restricts to positive integers as intended.", "The Lean formalization `(h1 : P 1)` directly matches the condition that P_1 is true.", "The Lean formalization `(h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))` correctly captures the inductive step. The constraint n \u2265 1 ensures we're working with positive integers, and the implication P n \u2192 P (n + 1) matches exactly.", "While the natural language states no conclusions are derived, the Lean theorem appropriately includes the conclusion `\u2200 n : \u2115, n \u2265 1 \u2192 P n`, which is the standard result of mathematical induction. This is the logical consequence of the given conditions and represents what would typically be proven using these premises."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "by postulate \\part{E}", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3];\n\u2022 Postulate (E) holds for the set of positive integers $\\mathbb{N}$: For any set $\\mathbb M \\subseteq \\mathbb N$, if $1 \\in \\mathbb M$ and for all $n \\in \\mathbb M$ we have $n+1 \\in \\mathbb M$, then $\\mathbb M = \\mathbb N$ [tc_4].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 P n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures P as a sequence of propositions indexed by natural numbers", "The Lean hypothesis `(h1 : P 1)` directly matches the condition that P_1 is true", "The Lean hypothesis `(h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))` correctly formalizes the implication condition, with the added constraint n \u2265 1 to restrict to positive integers", "The natural language states Postulate (E) as a given condition/premise, but the Lean formalization completely omits this postulate and instead has it as an implicit assumption used to prove the conclusion. The Lean theorem concludes `\u2200 n : \u2115, n \u2265 1 \u2192 P n` which is the result of applying mathematical induction, but Postulate (E) itself is not explicitly stated as a hypothesis"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures P as a sequence of propositions indexed by natural numbers', 'The Lean hypothesis `(h1 : P 1)` directly matches the condition that P_1 is true', 'The Lean hypothesis `(h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))` correctly formalizes the implication condition, with the added constraint n \u2265 1 to restrict to positive integers', 'The natural language states Postulate (E) as a given condition/premise, but the Lean formalization completely omits this postulate and instead has it as an implicit assumption used to prove the conclusion. The Lean theorem concludes `\u2200 n : \u2115, n \u2265 1 \u2192 P n` which is the result of applying mathematical induction, but Postulate (E) itself is not explicitly stated as a hypothesis']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let\n$$\n\\mathbb M=\\set{n}{n\\in \\mathbb N\\mbox{ and } P_n\\mbox{ is\ntrue}}.\n$$", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3];\n\u2022 Postulate (E) holds for the set of positive integers $\\mathbb{N}$ [tc_4].\nDefinition:\n\u2022 $\\mathbb M = \\{n \\in \\mathbb N \\mid P_n \\text{ is true}\\}$ [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (P : \u2115 \u2192 Prop)\nvariable (h1 : P 1)  -- P_1 is true\nvariable (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))  -- inductive property\nvariable (hE : \u2200 n : \u2115, n \u2265 1 \u2192 (P n \u2192 P (n + 1)))  -- postulate (E)\n\ndef M : Set \u2115 := {n | n \u2265 1 \u2227 P n}", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The Lean formalization `P : \u2115 \u2192 Prop` correctly captures P as a sequence of propositions indexed by natural numbers", "The Lean formalization `h1 : P 1` correctly captures that P_1 is true", "The Lean formalization `h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1)` correctly captures the inductive property that P_n implies P_{n+1} for each positive integer n", "The Lean formalization `hE : \u2200 n : \u2115, n \u2265 1 \u2192 (P n \u2192 P (n + 1))` correctly captures postulate (E), which appears to be the same as the inductive property", "The Lean definition `M : Set \u2115 := {n | n \u2265 1 \u2227 P n}` adds an explicit constraint `n \u2265 1` that wasn't in the natural language definition. The natural language assumes \u2115 refers to positive integers, while Lean's \u2115 includes 0, so the additional constraint is logically consistent but structurally different"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From \\part{a}, $1\\in \\mathbb M$", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3];\n\u2022 Postulate (E) holds for the set of positive integers $\\mathbb{N}$ [tc_4];\n\u2022 $\\mathbb M = \\{n \\in \\mathbb N \\mid P_n \\text{ is true}\\}$ [def_1].\nTherefore, we conclude:\n\u2022 $1 \\in \\mathbb M$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 n : \u2115, n \u2265 1 \u2192 (P n \u2192 P (n + 1)))\n  (M : Set \u2115) \n  (hM : M = {n | n \u2265 1 \u2227 P n}) :\n  1 \u2208 M := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 n : \u2115, n \u2265 1 \u2192 (P n \u2192 P (n + 1)))\n  (M : Set \u2115) \n  (hM : M = {n | n \u2265 1 \u2227 P n}) :\n  1 \u2208 M := by\n  have h_main : 1 \u2208 ({n | n \u2265 1 \u2227 P n} : Set \u2115) := by\n    refine' \u27e8by norm_num, _\u27e9\n    -- We need to prove that P 1 holds, which is given by h1.\n    exact h1\n  \n  have h_final : 1 \u2208 M := by\n    rw [hM] at *\n    -- Now we need to show that 1 is in the set {n | n \u2265 1 \u2227 P n}\n    -- This is already done in h_main, so we can directly use it.\n    exact h_main\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The definition of P as a sequence of propositions indexed by positive integers is correctly captured as P : \u2115 \u2192 Prop", "P\u2081 being true is correctly formalized as h1 : P 1", "The inductive step 'for each positive integer n, P\u2099 implies P\u2099\u208a\u2081' is correctly captured in h2", "Postulate (E) is represented by hE, but this is redundant with h2. The logical content is preserved but the structure suggests these should be distinct assumptions", "The set definition has a minor difference: natural language uses {n \u2208 \u2115 | P\u2099 is true} while Lean uses {n | n \u2265 1 \u2227 P n}. The Lean version makes the 'positive integers' constraint explicit with n \u2265 1", "The conclusion 1 \u2208 M is correctly stated as the goal 1 \u2208 M"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "from \\part{b}, $n+1\\in \\mathbb M$ whenever\n$n\\in \\mathbb M$.", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3];\n\u2022 Postulate (E) holds for the set of positive integers $\\mathbb{N}$ [tc_4];\n\u2022 $\\mathbb M = \\{n \\in \\mathbb N \\mid P_n \\text{ is true}\\}$ [def_1];\n\u2022 $1 \\in \\mathbb M$ [l1].\nTherefore, we conclude:\n\u2022 For any positive integer $n$, if $n \\in \\mathbb M$, then $n+1 \\in \\mathbb M$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 n : \u2115, n \u2265 1 \u2192 (P n \u2192 P (n + 1)))\n  (M : Set \u2115) \n  (hM : M = {n | n \u2265 1 \u2227 P n})\n  (n : \u2115) \n  (hn_pos : n \u2265 1)\n  (hn_in_M : n \u2208 M) :\n  n + 1 \u2208 M := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 n : \u2115, n \u2265 1 \u2192 (P n \u2192 P (n + 1)))\n  (M : Set \u2115) \n  (hM : M = {n | n \u2265 1 \u2227 P n})\n  (n : \u2115) \n  (hn_pos : n \u2265 1)\n  (hn_in_M : n \u2208 M) :\n  n + 1 \u2208 M := by\n  have hPn : P n := by\n    have h3 : n \u2208 {n : \u2115 | n \u2265 1 \u2227 P n} := by\n      rw [hM] at hn_in_M\n      exact hn_in_M\n    have h4 : n \u2265 1 \u2227 P n := by simpa using h3\n    exact h4.2\n  \n  have hPn1 : P (n + 1) := by\n    have h3 : P (n + 1) := h2 n hn_pos hPn\n    exact h3\n  \n  have hn1_pos : n + 1 \u2265 1 := by\n    have h3 : n + 1 \u2265 1 := by\n      omega\n    exact h3\n  \n  have h_main : n + 1 \u2208 M := by\n    have h3 : n + 1 \u2208 {n : \u2115 | n \u2265 1 \u2227 P n} := by\n      refine' \u27e8hn1_pos, _\u27e9\n      exact hPn1\n    rw [hM]\n    exact h3\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the essential logical structure but has some minor discrepancies: (1) The set M definition explicitly includes 'n \u2265 1' constraint which wasn't explicit in the natural language definition, though this aligns with the context of positive integers. (2) There's redundancy between h2 and hE which represent the same logical statement. (3) The natural language explicitly states '1 \u2208 M' as l1, but this isn't included as a separate hypothesis in Lean (though it's derivable from h1 and hM). These are structural differences that don't affect the core mathematical meaning but represent minor deviations from the natural language presentation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization captures the essential logical structure but has some minor discrepancies: (1) The set M definition explicitly includes 'n \u2265 1' constraint which wasn't explicit in the natural language definition, though this aligns with the context of positive integers. (2) There's redundancy between h2 and hE which represent the same logical statement. (3) The natural language explicitly states '1 \u2208 M' as l1, but this isn't included as a separate hypothesis in Lean (though it's derivable from h1 and hM). These are structural differences that don't affect the core mathematical meaning but represent minor deviations from the natural language presentation.\"]"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, $\\mathbb M=\\mathbb N$, by postulate\n\\part{E}.", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3];\n\u2022 Postulate (E): For any set $\\mathbb M \\subseteq \\mathbb N$, if $1 \\in \\mathbb M$ and for all $n \\in \\mathbb M$ we have $n+1 \\in \\mathbb M$, then $\\mathbb M = \\mathbb N$ [tc_4];\n\u2022 $\\mathbb M = \\{n \\in \\mathbb N \\mid P_n \\text{ is true}\\}$ [def_1];\n\u2022 $1 \\in \\mathbb M$ [l1];\n\u2022 For any positive integer $n$, if $n \\in \\mathbb M$, then $n+1 \\in \\mathbb M$ [l2].\nTherefore, we conclude:\n\u2022 $\\mathbb M = \\mathbb N$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 M : Set \u2115, \n    (\u2200 n : \u2115, n \u2265 1 \u2192 (n \u2208 M \u2192 (n + 1) \u2208 M)) \u2192 \n    M = {n | n \u2265 1}) \n  (M : Set \u2115) \n  (hM_def : M = {n | n \u2265 1 \u2227 P n})\n  (h1_in_M : 1 \u2208 M)\n  (hM_closed : \u2200 n : \u2115, n \u2265 1 \u2192 n \u2208 M \u2192 (n + 1) \u2208 M) :\n  M = {n | n \u2265 1} := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 M : Set \u2115, \n    (\u2200 n : \u2115, n \u2265 1 \u2192 (n \u2208 M \u2192 (n + 1) \u2208 M)) \u2192 \n    M = {n | n \u2265 1}) \n  (M : Set \u2115) \n  (hM_def : M = {n | n \u2265 1 \u2227 P n})\n  (h1_in_M : 1 \u2208 M)\n  (hM_closed : \u2200 n : \u2115, n \u2265 1 \u2192 n \u2208 M \u2192 (n + 1) \u2208 M) :\n  M = {n | n \u2265 1} := by\n  have h_absurd : False := by\n    have h\u2081 : (\u2205 : Set \u2115) = {n : \u2115 | n \u2265 1} := by\n      have h\u2082 : \u2200 n : \u2115, n \u2265 1 \u2192 (n \u2208 (\u2205 : Set \u2115) \u2192 (n + 1) \u2208 (\u2205 : Set \u2115)) := by\n        intro n hn hn'\n        exfalso\n        exact Set.not_mem_empty n hn'\n      have h\u2083 : (\u2205 : Set \u2115) = {n : \u2115 | n \u2265 1} := hE \u2205 h\u2082\n      exact h\u2083\n    have h\u2084 : (1 : \u2115) \u2208 ({n : \u2115 | n \u2265 1} : Set \u2115) := by\n      norm_num [Set.mem_setOf_eq]\n    have h\u2085 : (1 : \u2115) \u2209 (\u2205 : Set \u2115) := by\n      intro h\n      exact Set.not_mem_empty 1 h\n    have h\u2086 : (1 : \u2115) \u2208 (\u2205 : Set \u2115) := by\n      rw [h\u2081] at *\n      exact h\u2084\n    exact h\u2085 h\u2086\n  \n  have h_main : M = {n | n \u2265 1} := by\n    exfalso\n    exact h_absurd\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization uses \u2115 \u2192 Prop (including 0) while natural language specifies positive integers, but this doesn't affect the logical meaning since only n \u2265 1 is used.", "Direct correspondence between 'P\u2081 is true' and 'h1 : P 1'.", "The Lean version correctly captures the inductive step with explicit positive integer constraint.", "Major discrepancy: natural language states conclusion should be \ud835\udd44 = \u2115, but Lean concludes M = {n | n \u2265 1}. The Lean version is missing the premise '1 \u2208 M' in the postulate.", "The Lean version adds constraint n \u2265 1 to restrict to positive integers, which is a reasonable interpretation but changes the set definition.", "Perfect correspondence between the natural language and Lean statements.", "The Lean version makes the positive integer constraint explicit, which is consistent with the natural language intent.", "The conclusion is consistent with the modified framework working with positive integers rather than all natural numbers.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization uses \u2115 \u2192 Prop (including 0) while natural language specifies positive integers, but this doesn't affect the logical meaning since only n \u2265 1 is used.\", \"Direct correspondence between 'P\u2081 is true' and 'h1 : P 1'.\", 'The Lean version correctly captures the inductive step with explicit positive integer constraint.', \"Major discrepancy: natural language states conclusion should be \ud835\udd44 = \u2115, but Lean concludes M = {n | n \u2265 1}. The Lean version is missing the premise '1 \u2208 M' in the postulate.\", 'The Lean version adds constraint n \u2265 1 to restrict to positive integers, which is a reasonable interpretation but changes the set definition.', 'Perfect correspondence between the natural language and Lean statements.', 'The Lean version makes the positive integer constraint explicit, which is consistent with the natural language intent.', 'The conclusion is consistent with the modified framework working with positive integers rather than all natural numbers.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, $\\mathbb M=\\mathbb N$, by postulate\n\\part{E}.", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1];\n\u2022 $P_1$ is true [tc_2];\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3];\n\u2022 Postulate (E) holds for the set of positive integers $\\mathbb{N}$ [tc_4];\n\u2022 $\\mathbb M = \\{n \\in \\mathbb N \\mid P_n \\text{ is true}\\}$ [def_1];\n\u2022 $1 \\in \\mathbb M$ [l1];\n\u2022 For any positive integer $n$, if $n \\in \\mathbb M$, then $n+1 \\in \\mathbb M$ [l2];\n\u2022 $\\mathbb M = \\mathbb N$ [l3].\nTherefore, we conclude:\n\u2022 $P_n$ is true for each positive integer $n$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 M : Set \u2115, (\u2200 n : \u2115, n \u2265 1 \u2192 (n \u2208 M \u2192 (n + 1) \u2208 M)) \u2192 M = {n | n \u2265 1})\n  (M : Set \u2115) \n  (hM_def : M = {n | n \u2265 1 \u2227 P n})\n  (l1 : 1 \u2208 M)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 n \u2208 M \u2192 (n + 1) \u2208 M)\n  (l3 : M = {n | n \u2265 1}) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 P n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (P : \u2115 \u2192 Prop) \n  (h1 : P 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 P n \u2192 P (n + 1))\n  (hE : \u2200 M : Set \u2115, (\u2200 n : \u2115, n \u2265 1 \u2192 (n \u2208 M \u2192 (n + 1) \u2208 M)) \u2192 M = {n | n \u2265 1})\n  (M : Set \u2115) \n  (hM_def : M = {n | n \u2265 1 \u2227 P n})\n  (l1 : 1 \u2208 M)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 n \u2208 M \u2192 (n + 1) \u2208 M)\n  (l3 : M = {n | n \u2265 1}) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 P n := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 P n := by\n    intro n hn\n    have h4 : n \u2208 M := by\n      rw [l3]\n      -- Since M = {n | n \u2265 1}, and n \u2265 1, we have n \u2208 M.\n      exact Set.mem_setOf.mpr hn\n    have h5 : n \u2208 {n : \u2115 | n \u2265 1 \u2227 P n} := by\n      rw [hM_def] at h4\n      exact h4\n    -- From h5, we have n \u2265 1 and P n.\n    have h6 : n \u2265 1 \u2227 P n := Set.mem_setOf.mp h5\n    -- Therefore, P n is true.\n    exact h6.2\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.78, "semantic_feedback": ["The proposition sequence P indexed by \u2115 is correctly formalized as (P : \u2115 \u2192 Prop)", "P\u2081 is true correctly corresponds to (h1 : P 1)", "The implication P\u2099 \u2192 P_{n+1} is properly captured with the added constraint n \u2265 1 for positive integers", "Postulate (E) is formalized as a specific induction-like principle, but the natural language doesn't specify what (E) is, making this an interpretation", "The set M definition correctly captures the natural language with the appropriate constraint for positive integers", "1 \u2208 M is directly and correctly formalized", "The closure property of M under successor is properly formalized with positive integer constraints", "M = \u2115 in natural language becomes M = {n | n \u2265 1} in Lean, which is consistent with positive integers but represents a slight notational difference", "The conclusion correctly formalizes that P holds for all positive integers"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    