
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $z$ be a complex number. If $|z-i| = 1$ and $\operatorname{Arg}(z) = \pi/6$, then $z = \frac{\sqrt{3}}{2} + \frac{i}{2}$.

Proof: From the condition $\operatorname{Arg}(z) = \pi/6$, we can write $z$ in polar form as $z = r(\frac{\sqrt{3}}{2} + \frac{i}{2})$ for some $r>0$. From the condition $|z-i|=1$, we can write this in cartesian coordinates $x, y$ as $x^2+(y-1)^2=1$. By substituting the real and imaginary parts of $z$, namely $x=r\frac{\sqrt{3}}{2}$ and $y=r/2$, into the cartesian equation, we get $(r\frac{\sqrt{3}}{2})^2 + (r/2-1)^2 = 1$, which simplifies to $r^2-r=0$. Since the argument of $z$ is defined, $z$ must be non-zero, which implies $r>0$; therefore, the only valid solution is $r=1$. Substituting $r=1$ into the polar form gives the result $z = \frac{\sqrt{3}}{2} + \frac{i}{2}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $z$ be a complex number. If $|z-i| = 1$", "statement": "Premise:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(tc_1 : Complex.abs (z - Complex.I) = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (z : \u2102)' correctly captures that z is a complex number", "The Lean condition 'Complex.abs (z - Complex.I) = 1' perfectly translates the mathematical condition |z-i| = 1, where Complex.abs is the absolute value function and Complex.I is the imaginary unit"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "and $\\operatorname{Arg}(z) = \\pi/6$", "statement": "Premise:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (z : \u2102)\n(tc_1 : Complex.abs (z - Complex.I) = 1)\n(tc_2 : Complex.arg z = Real.pi / 6) := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 37, "endLine": 9, "endColumn": 39, "data": "unexpected token ':='; expected command"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "From the condition $\\operatorname{Arg}(z) = \\pi/6$, we can write $z$ in polar form as $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2].\nTherefore, we conclude:\n\u2022 $z$ can be written in polar form as $z = r(\\cos(\\pi/6) + i\\sin(\\pi/6)) = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$, where $r = |z|$ is the modulus of $z$ and $r>0$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (z : \u2102)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (z : \u2102)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n  have h\u2081 : z \u2260 0 := by\n    by_contra h\n    rw [h] at tc_2\n    have h\u2082 : Complex.arg (0 : \u2102) = Real.pi / 6 := by simpa using tc_2\n    have h\u2083 : Complex.arg (0 : \u2102) = 0 := by simp [Complex.arg_zero]\n    rw [h\u2083] at h\u2082\n    norm_num at h\u2082 \u22a2\n    <;> linarith [Real.pi_pos]\n  \n  have h\u2082 : z.re \u2265 0 := by\n    by_contra h\u2083\n    have h\u2084 : z.re < 0 := by linarith\n    have h\u2085 : Complex.arg z = Real.pi / 6 := tc_2\n    have h\u2086 : z.re < 0 := h\u2084\n    have h\u2087 : Complex.arg z > 0 := by\n      rw [h\u2085]\n      <;> linarith [Real.pi_pos]\n    have h\u2088 : Complex.arg z < Real.pi / 2 := by\n      rw [h\u2085]\n      <;> linarith [Real.pi_gt_three]\n    have h\u2089 : z.im \u2265 0 := by\n      by_contra h\u2081\u2080\n      have h\u2081\u2081 : z.im < 0 := by linarith\n      have h\u2081\u2082 : Complex.arg z < 0 := by\n        -- Use the fact that the argument of a complex number with negative real and imaginary parts is negative.\n        have h\u2081\u2083 : Complex.arg z < 0 := by\n          -- Use the polar form to find the argument\n          have h\u2081\u2084 : Complex.arg z = Complex.arg z := rfl\n          have h\u2081\u2085 : Complex.arg z < 0 := by\n            -- Use the properties of the argument of a complex number to show it is negative\n            have h\u2081\u2086 : z.re < 0 := h\u2086\n            have h\u2081\u2087 : z.im < 0 := h\u2081\u2081\n            have h\u2081\u2088 : Complex.arg z < 0 := by\n              -- Use the properties of the argument of a complex number to show it is negative\n              simp_all [Complex.arg, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n                sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv]\n              <;>\n                (try norm_num at *) <;>\n                (try linarith [Real.pi_pos]) <;>\n                (try {\n                  field_simp [h\u2081, Complex.ext_iff, Real.sqrt_eq_iff_sq_eq, sq, add_nonneg,\n                    mul_self_nonneg, div_eq_mul_inv] at *\n                  <;>\n                    ring_nf at *\n                  <;>\n                    norm_num at *\n                  <;>\n                    (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n                  <;>\n                    (try linarith [Real.pi_pos])\n                }) <;>\n                (try {\n                  cases' le_or_lt 0 (z.re) with h h <;>\n                    cases' le_or_lt 0 (z.im) with h' h' <;>\n                      simp_all [Complex.arg, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n                        sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv]\n                  <;>\n                    (try {\n                      norm_num at *\n                      <;>\n                        (try {\n                          nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n                        })\n                      <;>\n                        (try linarith [Real.pi_pos])\n                    })\n                })\n            exact h\u2081\u2088\n          exact h\u2081\u2085\n        exact h\u2081\u2083\n      have h\u2081\u2083 : Complex.arg z < 0 := h\u2081\u2082\n      have h\u2081\u2084 : Complex.arg z = Real.pi / 6 := h\u2085\n      linarith [Real.pi_pos]\n    have h\u2081\u2080 : z.im \u2265 0 := h\u2089\n    have h\u2081\u2081 : Complex.arg z = Real.pi / 6 := h\u2085\n    have h\u2081\u2082 : Complex.arg z > 0 := h\u2087\n    have h\u2081\u2083 : Complex.arg z < Real.pi / 2 := h\u2088\n    have h\u2081\u2084 : z.re < 0 := h\u2086\n    have h\u2081\u2085 : z.im \u2265 0 := h\u2089\n    -- Use the fact that the argument of a complex number with negative real part and non-negative imaginary part is in (\u03c0/2, \u03c0)\n    have h\u2081\u2086 : Complex.arg z > Real.pi / 2 := by\n      -- Use the polar form to find the argument\n      have h\u2081\u2087 : Complex.arg z > Real.pi / 2 := by\n        -- Use the properties of the argument of a complex number to show it is in (\u03c0/2, \u03c0)\n        have h\u2081\u2088 : z.re < 0 := h\u2086\n        have h\u2081\u2089 : z.im \u2265 0 := h\u2089\n        have h\u2082\u2080 : Complex.arg z > Real.pi / 2 := by\n          -- Use the properties of the argument of a complex number to show it is in (\u03c0/2, \u03c0)\n          simp_all [Complex.arg, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n            sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv]\n          <;>\n            (try norm_num at *) <;>\n            (try linarith [Real.pi_pos]) <;>\n            (try {\n              field_simp [h\u2081, Complex.ext_iff, Real.sqrt_eq_iff_sq_eq, sq, add_nonneg,\n                mul_self_nonneg, div_eq_mul_inv] at *\n              <;>\n                ring_nf at *\n              <;>\n                norm_num at *\n              <;>\n                (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n              <;>\n                (try linarith [Real.pi_pos])\n            }) <;>\n            (try {\n              cases' le_or_lt 0 (z.re) with h h <;>\n                cases' le_or_lt 0 (z.im) with h' h' <;>\n                  simp_all [Complex.arg, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n                    sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv]\n              <;>\n                (try {\n                  norm_num at *\n                  <;>\n                    (try {\n                      nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n                    })\n                  <;>\n                    (try linarith [Real.pi_pos])\n                })\n            })\n        exact h\u2082\u2080\n      exact h\u2081\u2087\n    have h\u2081\u2087 : Complex.arg z > Real.pi / 2 := h\u2081\u2086\n    have h\u2081\u2088 : Complex.arg z = Real.pi / 6 := h\u2085\n    linarith [Real.pi_pos]\n  \n  -- Use the given argument to find the polar form of z\n  have h\u2083 : \u2203 (r : \u211d), r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n    have h\u2084 : Complex.abs z > 0 := by\n      -- Prove that the modulus of z is positive\n      have h\u2085 : z \u2260 0 := h\u2081\n      have h\u2086 : Complex.abs z > 0 := by\n        apply Complex.abs.pos\n        exact h\u2085\n      exact h\u2086\n    -- Use the argument to find the polar form of z\n    have h\u2085 : z.re = Complex.abs z * Real.cos (Complex.arg z) := by\n      -- Prove that the real part of z is the modulus times the cosine of the argument\n      have h\u2086 : z.re = Complex.abs z * Real.cos (Complex.arg z) := by\n        -- Use the polar form of z to find the real part\n        simp [Complex.ext_iff, Complex.abs, Complex.normSq, Complex.arg, Real.cos, Real.sin,\n          Real.sqrt_eq_iff_sq_eq, sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv] at *\n        <;>\n          (try norm_num at *) <;>\n          (try linarith [Real.pi_pos]) <;>\n          (try {\n            field_simp [h\u2081, Complex.ext_iff, Real.sqrt_eq_iff_sq_eq, sq, add_nonneg,\n              mul_self_nonneg, div_eq_mul_inv] at *\n            <;>\n              ring_nf at *\n            <;>\n              norm_num at *\n            <;>\n              (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n            <;>\n              (try linarith [Real.pi_pos])\n          }) <;>\n          (try {\n            cases' le_or_lt 0 (z.re) with h h <;>\n              cases' le_or_lt 0 (z.im) with h' h' <;>\n                simp_all [Complex.arg, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n                  sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv]\n            <;>\n              (try {\n                norm_num at *\n                <;>\n                  (try {\n                    nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n                  })\n                <;>\n                  (try linarith [Real.pi_pos])\n              })\n          })\n      exact h\u2086\n    have h\u2086 : z.im = Complex.abs z * Real.sin (Complex.arg z) := by\n      -- Prove that the imaginary part of z is the modulus times the sine of the argument\n      have h\u2087 : z.im = Complex.abs z * Real.sin (Complex.arg z) := by\n        -- Use the polar form of z to find the imaginary part\n        simp [Complex.ext_iff, Complex.abs, Complex.normSq, Complex.arg, Real.cos, Real.sin,\n          Real.sqrt_eq_iff_sq_eq, sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv] at *\n        <;>\n          (try norm_num at *) <;>\n          (try linarith [Real.pi_pos]) <;>\n          (try {\n            field_simp [h\u2081, Complex.ext_iff, Real.sqrt_eq_iff_sq_eq, sq, add_nonneg,\n              mul_self_nonneg, div_eq_mul_inv] at *\n            <;>\n              ring_nf at *\n            <;>\n              norm_num at *\n            <;>\n              (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n            <;>\n              (try linarith [Real.pi_pos])\n          }) <;>\n          (try {\n            cases' le_or_lt 0 (z.re) with h h <;>\n              cases' le_or_lt 0 (z.im) with h' h' <;>\n                simp_all [Complex.arg, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n                  sq, add_nonneg, mul_self_nonneg, div_eq_mul_inv]\n            <;>\n              (try {\n                norm_num at *\n                <;>\n                  (try {\n                    nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n                  })\n                <;>\n                  (try linarith [Real.pi_pos])\n              })\n          })\n      exact h\u2087\n    -- Use the given argument to find the polar form of z\n    have h\u2087 : Complex.arg z = Real.pi / 6 := tc_2\n    have h\u2088 : Real.cos (Complex.arg z) = Real.cos (Real.pi / 6) := by rw [h\u2087]\n    have h\u2089 : Real.sin (Complex.arg z) = Real.sin (Real.pi / 6) := by rw [h\u2087]\n    have h\u2081\u2080 : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 := by norm_num\n    have h\u2081\u2081 : Real.sin (Real.pi / 6) = 1 / 2 := by norm_num\n    have h\u2081\u2082 : z.re = Complex.abs z * (Real.sqrt 3 / 2) := by\n      rw [h\u2085, h\u2088, h\u2081\u2080]\n      <;> ring_nf\n    have h\u2081\u2083 : z.im = Complex.abs z * (1 / 2) := by\n      rw [h\u2086, h\u2089, h\u2081\u2081]\n      <;> ring_nf\n    -- Prove that z can be written in the desired polar form\n    have h\u2081\u2084 : z = (Complex.abs z : \u2102) * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n      apply Complex.ext <;> simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, h\u2081\u2082, h\u2081\u2083]\n      <;> ring_nf at * <;> simp_all [Complex.ext_iff, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n        sq_nonneg, add_nonneg, mul_self_nonneg]\n      <;> field_simp [h\u2081] at * <;> ring_nf at * <;> norm_num at * <;>\n        (try linarith) <;> (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n      <;>\n        (try\n          {\n            nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)]\n          })\n    -- Conclude the proof\n    refine' \u27e8Complex.abs z, by positivity, _\u27e9\n    rw [h\u2081\u2084]\n    <;> simp [Complex.ext_iff, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n      sq_nonneg, add_nonneg, mul_self_nonneg]\n    <;> ring_nf at * <;> simp_all [Complex.ext_iff, Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq,\n      sq_nonneg, add_nonneg, mul_self_nonneg]\n    <;> field_simp [h\u2081] at * <;> ring_nf at * <;> norm_num at * <;>\n      (try linarith) <;> (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show (0 : \u211d) \u2264 3 by norm_num)])\n  \n  exact h\u2083", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 41, "column": 44, "endLine": 75, "endColumn": 18, "data": "unsolved goals\nz : \u2102\ntc_1 : 1 = z.re * z.re + (z.im - 1) * (z.im - 1)\nh\u2081 : \u00acz = 0\nh\u2081\u2086 : z.re < 0\nh\u2081\u2087 : z.im < 0\ntc_2 : -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) - \u03c0 = \u03c0 * (1 / 6)\nh\u2087 : 0 < if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) else \u03c0 * (1 / 6)\nh\u2088 : (if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) else \u03c0 * (1 / 6)) < \u03c0 * (1 / 2)\n\u22a2 (if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9)\n    else if 0 \u2264 z.im then -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0 else \u03c0 * (1 / 6)) <\n    0"}, {"line": 95, "column": 50, "endLine": 129, "endColumn": 14, "data": "unsolved goals\nz : \u2102\ntc_1 : 1 = z.re * z.re + (z.im - 1) * (z.im - 1)\nh\u2081 : \u00acz = 0\nh\u2081\u2088 : z.re < 0\nh\u2081\u2089 : 0 \u2264 z.im\ntc_2 : -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0 = \u03c0 * (1 / 6)\nh\u2087 : 0 < if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) else \u03c0 * (1 / 6)\nh\u2088 : (if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) else \u03c0 * (1 / 6)) < \u03c0 * (1 / 2)\n\u22a2 \u03c0 * (1 / 2) < if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) else \u03c0 * (1 / 6)"}, {"line": 148, "column": 67, "endLine": 182, "endColumn": 12, "data": "unsolved goals\nz : \u2102\ntc_1 : 1 = z.re * z.re + (z.im - 1) * (z.im - 1)\nh\u2081 : z.re = 0 \u2192 \u00acz.im = 0\nh\u2082 : 0 \u2264 z.re\nh\u2084 : 0 < z.re * z.re + z.im * z.im\ntc_2 :\n  (if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9)\n    else\n      if 0 \u2264 z.im then -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0\n      else -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) - \u03c0) =\n    \u03c0 * (1 / 6)\n\u22a2 z.re =\n    \u221a(z.re * z.re + z.im * z.im) *\n      (Complex.cos\n          \u2191(if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9)\n            else\n              if 0 \u2264 z.im then -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0\n              else -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) - \u03c0)).re"}, {"line": 186, "column": 67, "endLine": 220, "endColumn": 12, "data": "unsolved goals\nz : \u2102\ntc_1 : 1 = z.re * z.re + (z.im - 1) * (z.im - 1)\nh\u2081 : z.re = 0 \u2192 \u00acz.im = 0\nh\u2082 : 0 \u2264 z.re\nh\u2084 : 0 < z.re * z.re + z.im * z.im\nh\u2085 :\n  z.re =\n    \u221a(z.re * z.re + z.im * z.im) *\n      (Complex.cos\n          \u2191(if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9)\n            else\n              if 0 \u2264 z.im then -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0\n              else -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) - \u03c0)).re\ntc_2 :\n  (if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9)\n    else\n      if 0 \u2264 z.im then -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0\n      else -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) - \u03c0) =\n    \u03c0 * (1 / 6)\n\u22a2 z.im =\n    \u221a(z.re * z.re + z.im * z.im) *\n      (Complex.sin\n          \u2191(if 0 \u2264 z.re then arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9)\n            else\n              if 0 \u2264 z.im then -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) + \u03c0\n              else -arcsin (z.im * (\u221a(z.re * z.re + z.im * z.im))\u207b\u00b9) - \u03c0)).re"}, {"line": 251, "column": 25, "endLine": 252, "endColumn": 45, "data": "tactic 'simp' failed, nested error:\nmaximum recursion depth has been reached\nuse `set_option maxRecDepth <num>` to increase limit\nuse `set_option diagnostics true` to get diagnostic information"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The assumptions tc_1 and tc_2 are properly formalized. The conclusion correctly represents the polar form using the simplified trigonometric values. While the explicit statement 'r = |z|' is not included, this is implicit in the polar form representation and doesn't constitute a logical gap. The existential quantification appropriately captures that such an r exists with the required properties.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (z : \u2102)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n  have h_main : \u2203 (r : \u211d), r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n    use Complex.abs z\n    have h\u2081 : Complex.abs z > 0 := by\n      by_contra h\n      have h\u2082 : Complex.abs z \u2264 0 := by linarith\n      have h\u2083 : Complex.abs z = 0 := by\n        have h\u2084 : Complex.abs z \u2265 0 := Complex.abs.nonneg z\n        linarith\n      have h\u2084 : z = 0 := by\n        have h\u2085 : Complex.abs z = 0 := h\u2083\n        simp [Complex.abs, Complex.normSq, Real.sqrt_eq_zero'] at h\u2085 \u22a2\n        <;>\n        (try norm_num at h\u2085 \u22a2) <;>\n        (try simp_all [Complex.ext_iff]) <;>\n        (try nlinarith) <;>\n        (try ring_nf at h\u2085 \u22a2) <;>\n        (try simp_all [Complex.ext_iff]) <;>\n        (try nlinarith)\n      have h\u2085 : Complex.arg z = 0 := by\n        rw [h\u2084]\n        simp [Complex.arg_zero]\n      rw [h\u2085] at tc_2\n      have h\u2086 : (0 : \u211d) = Real.pi / 6 := by linarith\n      have h\u2087 : Real.pi > 0 := Real.pi_pos\n      linarith [Real.pi_gt_three]\n    constructor\n    \u00b7 exact h\u2081\n    \u00b7 have h\u2082 : z = Complex.abs z * (Real.cos (Complex.arg z) + Complex.I * Real.sin (Complex.arg z)) := by\n        have h\u2083 : z = Complex.abs z * Complex.exp (Complex.arg z * Complex.I) := by\n          rw [Complex.abs_mul_exp_arg_mul_I]\n        rw [h\u2083]\n        have h\u2084 : Complex.exp (Complex.arg z * Complex.I) = \u2191(Real.cos (Complex.arg z)) + Complex.I * \u2191(Real.sin (Complex.arg z)) := by\n          -- Prove that exp(i\u03b8) = cos \u03b8 + i sin \u03b8\n          have h\u2085 : Complex.exp (Complex.arg z * Complex.I) = \u2191(Real.cos (Complex.arg z)) + Complex.I * \u2191(Real.sin (Complex.arg z)) := by\n            rw [Complex.ext_iff]\n            simp [Complex.exp_re, Complex.exp_im, Complex.ext_iff, Real.cos, Real.sin]\n            <;>\n            (try ring_nf) <;>\n            (try simp [Complex.ext_iff, Real.cos, Real.sin]) <;>\n            (try norm_num) <;>\n            (try field_simp [Complex.ext_iff, Real.cos, Real.sin]) <;>\n            (try ring_nf) <;>\n            (try norm_num)\n            <;>\n            (try linarith [Real.cos_le_one (Complex.arg z), Real.sin_le_one (Complex.arg z)])\n            <;>\n            (try simp_all [Complex.ext_iff, Real.cos, Real.sin]) <;>\n            (try norm_num) <;>\n            (try linarith [Real.cos_le_one (Complex.arg z), Real.sin_le_one (Complex.arg z)])\n          rw [h\u2085]\n        rw [h\u2084]\n        <;> simp [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n        <;> ring_nf\n        <;> simp [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n        <;> norm_num\n      have h\u2083 : z = Complex.abs z * (Real.cos (Real.pi / 6) + Complex.I * Real.sin (Real.pi / 6)) := by\n        rw [h\u2082]\n        rw [tc_2]\n      have h\u2084 : Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 := by norm_num\n      have h\u2085 : Real.sin (Real.pi / 6) = 1 / 2 := by norm_num\n      have h\u2086 : z = Complex.abs z * (Real.sqrt 3 / 2 + Complex.I * (1 / 2 : \u211d)) := by\n        rw [h\u2083, h\u2084, h\u2085]\n        <;> ring_nf\n        <;> simp [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n        <;> norm_num\n      have h\u2087 : z = Complex.abs z * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n        calc\n          z = Complex.abs z * (Real.sqrt 3 / 2 + Complex.I * (1 / 2 : \u211d)) := h\u2086\n          _ = Complex.abs z * (Real.sqrt 3 / 2 + Complex.I / 2) := by\n            simp [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n            <;> ring_nf\n            <;> norm_num\n            <;> simp_all [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n            <;> norm_num\n            <;> linarith\n      rw [h\u2087]\n      <;> simp [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n      <;> ring_nf\n      <;> norm_num\n      <;> simp_all [Complex.ext_iff, Complex.I_re, Complex.I_im, mul_comm]\n      <;> norm_num\n      <;> linarith\n  exact h_main"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "From the condition $|z-i|=1$, we can write this in cartesian coordinates $x, y$ as $x^2+(y-1)^2=1$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2];\n\u2022 $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$ [l1].\nTherefore, we conclude:\n\u2022 Writing $z$ in Cartesian form as $z=x+iy$, the condition $|z-i|=1$ becomes $x^2 + (y-1)^2 = 1$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (z : \u2102)\n  (h : Complex.abs (z - Complex.I) = 1) :\n  let x := z.re\n  let y := z.im\n  x^2 + (y - 1)^2 = 1 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (z : \u2102)\n  (h : Complex.abs (z - Complex.I) = 1) :\n  let x := z.re\n  let y := z.im\n  x^2 + (y - 1)^2 = 1 := by\n  dsimp only\n  have h\u2081 : z.re ^ 2 + (z.im - 1) ^ 2 = 1 := by\n    have h\u2082 : Complex.abs (z - Complex.I) = Real.sqrt (z.re ^ 2 + (z.im - 1) ^ 2) := by\n      simp [Complex.abs, Complex.normSq, Complex.ext_iff, pow_two]\n      <;> ring_nf <;> simp [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n      <;> ring_nf <;> norm_num\n      <;> field_simp [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n      <;> ring_nf <;> norm_num\n      <;> linarith\n    rw [h\u2082] at h\n    have h\u2083 : Real.sqrt (z.re ^ 2 + (z.im - 1) ^ 2) = 1 := by rw [h]\n    have h\u2084 : z.re ^ 2 + (z.im - 1) ^ 2 = 1 := by\n      have h\u2085 : Real.sqrt (z.re ^ 2 + (z.im - 1) ^ 2) = 1 := h\u2083\n      have h\u2086 : 0 \u2264 z.re ^ 2 + (z.im - 1) ^ 2 := by positivity\n      have h\u2087 : Real.sqrt (z.re ^ 2 + (z.im - 1) ^ 2) ^ 2 = z.re ^ 2 + (z.im - 1) ^ 2 := by\n        rw [Real.sq_sqrt] <;> positivity\n      rw [h\u2085] at h\u2087\n      norm_num at h\u2087 \u22a2\n      <;> linarith\n    exact h\u2084\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the mathematical content of the natural language statement. It correctly formalizes the condition |z-i|=1, properly extracts the real and imaginary parts of z as x and y respectively, and states the correct conclusion that x^2 + (y-1)^2 = 1. The theorem focuses appropriately on the specific relationship being demonstrated (l2) while the broader context (tc_1, tc_2, l1) is handled separately as intended. The mathematical equivalence is preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "By substituting the real and imaginary parts of $z$, namely $x=r\\frac{\\sqrt{3}}{2}$ and $y=r/2$,", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2];\n\u2022 $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$ [l1];\n\u2022 Writing $z$ in Cartesian form as $z=x+iy$, the condition $|z-i|=1$ becomes $x^2 + (y-1)^2 = 1$ [l2].\nTherefore, we conclude:\n\u2022 The real part of $z$ is $x = r\\frac{\\sqrt{3}}{2}$ and the imaginary part is $y = r/2$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (z : \u2102)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6)\n  (l1 : \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : let x := z.re; let y := z.im; x^2 + (y - 1)^2 = 1) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) \u2227\n  z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (z : \u2102)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6)\n  (l1 : \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : let x := z.re; let y := z.im; x^2 + (y - 1)^2 = 1) :\n  \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) \u2227\n  z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2 := by\n  have h\u2081 : \u2203 r : \u211d, r > 0 \u2227 z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := l1\n  obtain \u27e8r, hr_pos, hr_eq\u27e9 := h\u2081\n  refine' \u27e8r, hr_pos, hr_eq, _, _\u27e9\n  \u00b7 -- Prove z.re = r * (Real.sqrt 3 / 2)\n    have h\u2082 : z.re = r * (Real.sqrt 3 / 2) := by\n      rw [hr_eq]\n      simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul,\n        Complex.ofReal_ofNat]\n      <;> ring_nf <;> norm_num <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> norm_num <;>\n        nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n    exact h\u2082\n  \u00b7 -- Prove z.im = r / 2\n    have h\u2083 : z.im = r / 2 := by\n      rw [hr_eq]\n      simp [Complex.ext_iff, Complex.mul_re, Complex.mul_im, Complex.ofReal_add, Complex.ofReal_mul,\n        Complex.ofReal_ofNat]\n      <;> ring_nf <;> norm_num <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> norm_num <;>\n        nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n    exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumptions tc_1 and tc_2 correctly formalize the complex modulus and argument conditions using appropriate Lean complex number operations.", "Assumption l1 properly captures the polar form representation with existential quantification over positive real r.", "Assumption l2 correctly formalizes the Cartesian form constraint using let bindings for real and imaginary parts.", "The conclusion correctly captures the relationships for real and imaginary parts. The inclusion of the original l1 assumption in the conclusion is logically consistent extra content that doesn't contradict the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "into the cartesian equation, we get $(r\\frac{\\sqrt{3}}{2})^2 + (r/2-1)^2 = 1$,", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2];\n\u2022 $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$ [l1];\n\u2022 The Cartesian form of the condition is $x^2 + (y-1)^2 = 1$ [l2];\n\u2022 The real and imaginary parts of $z$ are $x = r\\frac{\\sqrt{3}}{2}$ and $y = r/2$ [l3].\nTherefore, we conclude:\n\u2022 $(r\\frac{\\sqrt{3}}{2})^2 + (r/2 - 1)^2 = 1$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (z : \u2102) (r : \u211d)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6)\n  (l1 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : z.re^2 + (z.im - 1)^2 = 1)\n  (l3 : z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2) :\n  (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (z : \u2102) (r : \u211d)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6)\n  (l1 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : z.re^2 + (z.im - 1)^2 = 1)\n  (l3 : z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2) :\n  (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1 := by\n  have h4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1 := by\n    have h5 : z.re^2 + (z.im - 1)^2 = 1 := l2\n    have h6 : z.re = r * (Real.sqrt 3 / 2) := l3.1\n    have h7 : z.im = r / 2 := l3.2\n    have h8 : (z.re : \u211d)^2 + (z.im - 1 : \u211d)^2 = 1 := by\n      norm_cast at h5 \u22a2\n      <;> simp_all [Complex.ext_iff, pow_two]\n      <;> ring_nf at *\n      <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n    have h9 : (r * (Real.sqrt 3 / 2) : \u211d)^2 + (r / 2 - 1 : \u211d)^2 = 1 := by\n      rw [h6, h7] at h8\n      norm_num at h8 \u22a2\n      <;>\n      (try ring_nf at h8 \u22a2) <;>\n      (try norm_num at h8 \u22a2) <;>\n      (try linarith) <;>\n      (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]) <;>\n      (try\n        {\n          simp_all [Complex.ext_iff, pow_two]\n          <;> ring_nf at *\n          <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n        })\n      <;>\n      (try\n        {\n          nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n        })\n    norm_num at h9 \u22a2\n    <;>\n    (try ring_nf at h9 \u22a2) <;>\n    (try norm_num at h9 \u22a2) <;>\n    (try linarith) <;>\n    (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]) <;>\n    (try\n      {\n        simp_all [Complex.ext_iff, pow_two]\n        <;> ring_nf at *\n        <;> nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n      })\n    <;>\n    (try\n      {\n        nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n      })\n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.83, "semantic_feedback": ["The condition |z-i| = 1 is correctly formalized as Complex.abs (z - Complex.I) = 1", "The argument condition Arg(z) = \u03c0/6 is correctly formalized as Complex.arg z = Real.pi / 6", "The natural language specifies 'r > 0' but the Lean formalization only declares 'r : \u211d' without the positivity constraint", "The Cartesian form x\u00b2 + (y-1)\u00b2 = 1 is correctly expressed as z.re^2 + (z.im - 1)^2 = 1", "The real and imaginary parts are correctly expressed using conjunction in Lean", "The conclusion is perfectly matched between natural language and Lean formalization"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "which simplifies to $r^2-r=0$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2];\n\u2022 $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$ [l1];\n\u2022 The Cartesian form of the condition is $x^2 + (y-1)^2 = 1$ [l2];\n\u2022 The real and imaginary parts of $z$ are $x = r\\frac{\\sqrt{3}}{2}$ and $y = r/2$ [l3];\n\u2022 $(r\\frac{\\sqrt{3}}{2})^2 + (r/2 - 1)^2 = 1$ [l4].\nTherefore, we conclude:\n\u2022 $r^2 - r = 0$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (r : \u211d)\n  (tc_1 : Complex.abs (Complex.I * r - Complex.I) = 1)\n  (tc_2 : Complex.arg (Complex.I * r) = Real.pi / 6)\n  (l1 : \u2203 s : \u211d, s > 0 \u2227 Complex.I * r = s * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : (Complex.I * r).re^2 + ((Complex.I * r).im - 1)^2 = 1)\n  (l3 : (Complex.I * r).re = r * (Real.sqrt 3 / 2) \u2227 (Complex.I * r).im = r / 2)\n  (l4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1) :\n  r^2 - r = 0 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (r : \u211d)\n  (tc_1 : Complex.abs (Complex.I * r - Complex.I) = 1)\n  (tc_2 : Complex.arg (Complex.I * r) = Real.pi / 6)\n  (l1 : \u2203 s : \u211d, s > 0 \u2227 Complex.I * r = s * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : (Complex.I * r).re^2 + ((Complex.I * r).im - 1)^2 = 1)\n  (l3 : (Complex.I * r).re = r * (Real.sqrt 3 / 2) \u2227 (Complex.I * r).im = r / 2)\n  (l4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1) :\n  r^2 - r = 0 := by\n  have h\u2080 : r^2 - r = 0 := by\n    have h\u2081 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1 := l4\n    have h\u2082 : r^2 * 3 / 4 + (r / 2 - 1)^2 = 1 := by\n      ring_nf at h\u2081 \u22a2\n      <;>\n      (try norm_num at h\u2081 \u22a2) <;>\n      (try linarith [Real.sqrt_nonneg 3]) <;>\n      (try\n        nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num),\n          Real.sqrt_nonneg 3]) <;>\n      (try\n        {\n          field_simp [pow_two] at h\u2081 \u22a2 <;>\n          ring_nf at h\u2081 \u22a2 <;>\n          nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num),\n            Real.sqrt_nonneg 3]\n        }) <;>\n      (try\n        {\n          simp_all [Complex.ext_iff, pow_two]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num),\n            Real.sqrt_nonneg 3]\n        }) <;>\n      (try\n        {\n          nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num),\n            Real.sqrt_nonneg 3]\n        })\n      <;>\n      (try\n        {\n          linarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num),\n            Real.sqrt_nonneg 3]\n        })\n    have h\u2083 : r^2 - r = 0 := by\n      ring_nf at h\u2082 \u22a2\n      nlinarith [Real.sq_sqrt (show 0 \u2264 3 by norm_num),\n        Real.sqrt_nonneg 3]\n    exact h\u2083\n  exact h\u2080", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1: The Lean formalization uses z = Complex.I * r (meaning z = ir) instead of treating z as a general complex number. This fundamentally changes the mathematical setup.", "tc_2: Same issue as tc_1 - uses Complex.I * r instead of a general complex number z.", "l1: Uses existential quantification with variable s instead of directly stating z = r(\u221a3/2 + i/2). While mathematically equivalent, this is a structural difference from the natural language.", "l2: Applies the constraint to Complex.I * r, which is mathematically inconsistent with the natural language setup where z should have non-zero real part.", "l3: Claims (Complex.I * r).re = r * \u221a3/2, but Complex.I * r has real part 0, not r\u221a3/2. This creates a mathematical contradiction.", "l4: Inherits the mathematical inconsistency from l3, making the constraint mathematically impossible under the Lean's interpretation of z."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1: The Lean formalization uses z = Complex.I * r (meaning z = ir) instead of treating z as a general complex number. This fundamentally changes the mathematical setup.', 'tc_2: Same issue as tc_1 - uses Complex.I * r instead of a general complex number z.', 'l1: Uses existential quantification with variable s instead of directly stating z = r(\u221a3/2 + i/2). While mathematically equivalent, this is a structural difference from the natural language.', 'l2: Applies the constraint to Complex.I * r, which is mathematically inconsistent with the natural language setup where z should have non-zero real part.', 'l3: Claims (Complex.I * r).re = r * \u221a3/2, but Complex.I * r has real part 0, not r\u221a3/2. This creates a mathematical contradiction.', \"l4: Inherits the mathematical inconsistency from l3, making the constraint mathematically impossible under the Lean's interpretation of z.\"]"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since the argument of $z$ is defined, $z$ must be non-zero, which implies $r>0$; therefore, the only valid solution is $r=1$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2];\n\u2022 $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$ [l1];\n\u2022 The Cartesian form of the condition is $x^2 + (y-1)^2 = 1$ [l2];\n\u2022 The real and imaginary parts of $z$ are $x = r\\frac{\\sqrt{3}}{2}$ and $y = r/2$ [l3];\n\u2022 $(r\\frac{\\sqrt{3}}{2})^2 + (r/2 - 1)^2 = 1$ [l4];\n\u2022 $r^2 - r = 0$ [l5].\nTherefore, we conclude:\n\u2022 $r = 1$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (r : \u211d)\n  (tc_1 : \u2200 z : \u2102, Complex.abs (z - Complex.I) = 1 \u2192 \n    Complex.arg z = Real.pi / 6 \u2192 \n    \u2203 w : \u2102, w = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (tc_2 : \u2200 z : \u2102, Complex.arg z = Real.pi / 6 \u2192 \n    \u2203 w : \u2102, w = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l1 : \u2203 z : \u2102, z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : \u2200 z : \u2102, Complex.abs (z - Complex.I) = 1 \u2192 \n    let x := z.re; let y := z.im; x^2 + (y - 1)^2 = 1)\n  (l3 : \u2200 z : \u2102, z = r * (Real.sqrt 3 / 2 + Complex.I / 2) \u2192 \n    z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2)\n  (l4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1)\n  (l5 : r^2 - r = 0)\n  (h_pos : r > 0) :\n  r = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (r : \u211d)\n  (tc_1 : \u2200 z : \u2102, Complex.abs (z - Complex.I) = 1 \u2192 \n    Complex.arg z = Real.pi / 6 \u2192 \n    \u2203 w : \u2102, w = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (tc_2 : \u2200 z : \u2102, Complex.arg z = Real.pi / 6 \u2192 \n    \u2203 w : \u2102, w = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l1 : \u2203 z : \u2102, z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : \u2200 z : \u2102, Complex.abs (z - Complex.I) = 1 \u2192 \n    let x := z.re; let y := z.im; x^2 + (y - 1)^2 = 1)\n  (l3 : \u2200 z : \u2102, z = r * (Real.sqrt 3 / 2 + Complex.I / 2) \u2192 \n    z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2)\n  (l4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1)\n  (l5 : r^2 - r = 0)\n  (h_pos : r > 0) :\n  r = 1 := by\n  have h\u2081 : r = 1 := by\n    have h\u2082 : r ^ 2 - r = 0 := l5\n    have h\u2083 : r > 0 := h_pos\n    have h\u2084 : r = 1 := by\n      have h\u2085 : r * (r - 1) = 0 := by linarith\n      have h\u2086 : r = 0 \u2228 r - 1 = 0 := by\n        apply eq_zero_or_eq_zero_of_mul_eq_zero h\u2085\n      cases h\u2086 with\n      | inl h\u2086 =>\n        -- If r = 0, this contradicts r > 0.\n        exfalso\n        linarith\n      | inr h\u2086 =>\n        -- If r - 1 = 0, then r = 1.\n        have h\u2087 : r = 1 := by linarith\n        exact h\u2087\n    exact h\u2084\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1 is formalized as a conditional statement rather than asserting the existence of a complex number z with |z-i| = 1. The natural language presents this as a given condition.", "tc_2 is formalized as a conditional statement rather than asserting that the argument of z equals \u03c0/6. This should be a direct assertion about z.", "l1 correctly captures the form z = r(\u221a3/2 + i/2) but the existential statement lacks the constraint r > 0 mentioned in natural language (though this is added separately as h_pos).", "l2 correctly translates the Cartesian form condition x\u00b2 + (y-1)\u00b2 = 1.", "l3 correctly captures the relationship between z and its real/imaginary parts.", "l4 correctly represents the expanded equation (r\u221a3/2)\u00b2 + (r/2 - 1)\u00b2 = 1.", "l5 correctly represents the simplified equation r\u00b2 - r = 0.", "l6 correctly states the conclusion r = 1."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1 is formalized as a conditional statement rather than asserting the existence of a complex number z with |z-i| = 1. The natural language presents this as a given condition.', 'tc_2 is formalized as a conditional statement rather than asserting that the argument of z equals \u03c0/6. This should be a direct assertion about z.', 'l1 correctly captures the form z = r(\u221a3/2 + i/2) but the existential statement lacks the constraint r > 0 mentioned in natural language (though this is added separately as h_pos).', 'l2 correctly translates the Cartesian form condition x\u00b2 + (y-1)\u00b2 = 1.', 'l3 correctly captures the relationship between z and its real/imaginary parts.', 'l4 correctly represents the expanded equation (r\u221a3/2)\u00b2 + (r/2 - 1)\u00b2 = 1.', 'l5 correctly represents the simplified equation r\u00b2 - r = 0.', 'l6 correctly states the conclusion r = 1.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting $r=1$ into the polar form gives the result $z = \\frac{\\sqrt{3}}{2} + \\frac{i}{2}$.", "statement": "We assume:\n\u2022 $z$ is a complex number such that $|z-i| = 1$ [tc_1];\n\u2022 The argument of $z$ is $\\operatorname{Arg}(z) = \\pi/6$ [tc_2];\n\u2022 $z = r(\\frac{\\sqrt{3}}{2} + \\frac{i}{2})$ for some $r>0$ [l1];\n\u2022 The Cartesian form of the condition is $x^2 + (y-1)^2 = 1$ [l2];\n\u2022 The real and imaginary parts of $z$ are $x = r\\frac{\\sqrt{3}}{2}$ and $y = r/2$ [l3];\n\u2022 $(r\\frac{\\sqrt{3}}{2})^2 + (r/2 - 1)^2 = 1$ [l4];\n\u2022 $r^2 - r = 0$ [l5];\n\u2022 $r=1$ [l6].\nTherefore, we conclude:\n\u2022 $z = \\frac{\\sqrt{3}}{2} + \\frac{i}{2}$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (z : \u2102)\n  (r : \u211d)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6)\n  (l1 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : z.re^2 + (z.im - 1)^2 = 1)\n  (l3 : z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2)\n  (l4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1)\n  (l5 : r^2 - r = 0)\n  (l6 : r = 1) :\n  z = Real.sqrt 3 / 2 + Complex.I / 2 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (z : \u2102)\n  (r : \u211d)\n  (tc_1 : Complex.abs (z - Complex.I) = 1)\n  (tc_2 : Complex.arg z = Real.pi / 6)\n  (l1 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2))\n  (l2 : z.re^2 + (z.im - 1)^2 = 1)\n  (l3 : z.re = r * (Real.sqrt 3 / 2) \u2227 z.im = r / 2)\n  (l4 : (r * (Real.sqrt 3 / 2))^2 + (r / 2 - 1)^2 = 1)\n  (l5 : r^2 - r = 0)\n  (l6 : r = 1) :\n  z = Real.sqrt 3 / 2 + Complex.I / 2 := by\n  have h\u2080 : z = Real.sqrt 3 / 2 + Complex.I / 2 := by\n    have h\u2081 : z = r * (Real.sqrt 3 / 2 + Complex.I / 2) := l1\n    rw [h\u2081]\n    have h\u2082 : r = 1 := l6\n    rw [h\u2082]\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try simp [Complex.ext_iff, pow_two]) <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try field_simp [Complex.ext_iff, pow_two]) <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try simp_all [Complex.ext_iff, pow_two]) <;>\n    (try norm_num) <;>\n    (try nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)])\n    <;>\n    simp_all [Complex.ext_iff, pow_two]\n    <;>\n    norm_num\n    <;>\n    ring_nf\n    <;>\n    norm_num\n    <;>\n    nlinarith [Real.sqrt_nonneg 3, Real.sq_sqrt (show 0 \u2264 3 by norm_num)]\n  \n  exact h\u2080", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all the mathematical content from the natural language. Each assumption and conclusion is correctly translated using appropriate Lean syntax for complex numbers. The constraint 'r > 0' from the natural language is not explicitly stated but is satisfied by r = 1, and its omission doesn't affect the logical validity of the proof structure. All mathematical relationships, equations, and the final conclusion are preserved exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    