
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_n = \frac{3n+1}{n+1}$. The limit of the sequence $(a_n)$ is $3$.

Proof: To find the limit of the sequence $(a_n)$, we evaluate the expression $\lim_{n 	o \infty} \frac{3n+1}{n+1}$. We can divide both the numerator and the denominator by the highest power of $n$, which is $n$. This gives us $\lim_{n 	o \infty} \frac{(3n/n)+(1/n)}{(n/n)+(1/n)} = \lim_{n 	o \infty} \frac{3+1/n}{1+1/n}$. We know that as $n$ approaches infinity, the term $1/n$ approaches $0$. Therefore, we can substitute $0$ for $1/n$ in the expression, which gives us $\frac{3+0}{1+0}$. This simplifies to $3$. So, the limit of the sequence $(a_n)$ is $3$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_n = \\frac{3n+1}{n+1}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where for each natural number n, $a_n = \\frac{3n+1}{n+1}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, a n = (3 * n + 1) / (n + 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'a : \u2115 \u2192 \u211d' perfectly captures the concept of a sequence of real numbers indexed by natural numbers.", "The Lean formalization '\u2200 n : \u2115, a n = (3 * n + 1) / (n + 1)' exactly matches the mathematical statement 'for each natural number n, a_n = (3n+1)/(n+1)'.", "The conclusion about well-definedness is implicitly but perfectly captured by the Lean formalization through the type declaration and explicit formula constraint."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "We can divide both the numerator and the denominator by the highest power of $n$, which is $n$. This gives us $\\lim_{n \\to \\infty} \\frac{(3n/n)+(1/n)}{(n/n)+(1/n)} = \\lim_{n \\to \\infty} \\frac{3+1/n}{1+1/n}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for each natural number n, $a_n = \\frac{3n+1}{n+1}$ [tc_1].\nTherefore, we conclude:\n\u2022 For all natural numbers n, $\\frac{3n+1}{n+1} = \\frac{3+1/n}{1+1/n}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, a n = (3 * n + 1) / (n + 1))\n\ntheorem l1 :\n  \u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 :\n  \u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d)) := by\n  intro n\n  have h : False := by\n    have h\u2081 : False := by\n      have h\u2082 : (3 * (0 : \u2115) + 1) / (0 + 1) = (3 + 1 / (0 : \u211d)) / (1 + 1 / (0 : \u211d)) := by\n        have h\u2083 : \u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d)) := by\n          intro n\n          exfalso\n          <;>\n          (try contradiction)\n          <;>\n          (try\n            {\n              have h\u2084 : n = 0 := by\n                omega\n              simp_all [h\u2084]\n              <;>\n              norm_num\n              <;>\n              linarith\n            })\n        have h\u2084 := h\u2083 0\n        exact h\u2084\n      norm_num at h\u2082\n      <;>\n      simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_ofNat]\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    exact h\u2081\n  exfalso\n  exact h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 10, "column": 92, "endLine": 25, "endColumn": 14, "data": "unsolved goals\nn\u271d n : \u2115\n\u22a2 False"}, {"line": 27, "column": 8, "endLine": 27, "endColumn": 16, "data": "type mismatch\n  h\u2084\nhas type\n  (3 * \u21910 + 1) / (\u21910 + 1) = (3 + 1 / \u21910) / (1 + 1 / \u21910) : Prop\nbut is expected to have type\n  (3 * \u21910 + 1) / (0 + 1) = (3 + 1 / 0) / (1 + 1 / 0) : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition is correctly formalized. The variable declaration and constraint tc_1 accurately capture the mathematical definition of the sequence a_n = (3n+1)/(n+1).", "The theorem statement correctly formalizes the algebraic identity. The type coercion (n : \u211d) is a necessary technical detail to ensure the division operations are well-defined in the real number system, which is consistent with the mathematical intent.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem not_l1 : \n  \u00ac (\u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) := by\n  have h : (\u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) \u2192 False := by\n    intro h\u2081\n    have h\u2082 := h\u2081 0\n    norm_num [Nat.cast_zero, Nat.cast_one, Nat.cast_add, Nat.cast_mul, Nat.cast_ofNat] at h\u2082\n    <;>\n    (try contradiction) <;>\n    (try norm_num at h\u2082) <;>\n    (try linarith)\n  \n  exact h"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "We know that as $n$ approaches infinity, the term $1/n$ approaches $0$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for each natural number n, $a_n = \\frac{3n+1}{n+1}$ [tc_1];\n\u2022 For all natural numbers n, $\\frac{3n+1}{n+1} = \\frac{3+1/n}{1+1/n}$ [l1].\nTherefore, we conclude:\n\u2022 The limit of the sequence $(1/n)$ as n approaches infinity is 0, i.e., $\\lim_{n \\to \\infty} 1/n = 0$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 :\n  Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 :\n  Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n  have h_main : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n    have h\u2081 : Filter.Tendsto (fun n : \u2115 => (n : \u211d)) Filter.atTop Filter.atTop := by\n      -- The coercion from \u2115 to \u211d tends to infinity\n      exact tendsto_natCast_atTop_atTop\n    have h\u2082 : Filter.Tendsto (fun x : \u211d => (1 : \u211d) / x) Filter.atTop (nhds 0) := by\n      -- The function 1/x tends to 0 as x \u2192 \u221e\n      simpa using tendsto_inv_atTop_zero\n    -- Compose the two tendsto statements\n    have h\u2083 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := h\u2082.comp h\u2081\n    exact h\u2083\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition (a_n) = (3n+1)/(n+1) is completely missing from the Lean formalization, but it's explicitly stated as an assumption in the natural language.", "The algebraic identity (3n+1)/(n+1) = (3+1/n)/(1+1/n) is missing from the Lean formalization, but it's given as a key assumption [l1] in the natural language.", "The limit statement is correctly formalized using Filter.Tendsto, accurately capturing the mathematical meaning of lim(n\u2192\u221e) 1/n = 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The sequence definition (a_n) = (3n+1)/(n+1) is completely missing from the Lean formalization, but it's explicitly stated as an assumption in the natural language.\", \"The algebraic identity (3n+1)/(n+1) = (3+1/n)/(1+1/n) is missing from the Lean formalization, but it's given as a key assumption [l1] in the natural language.\", 'The limit statement is correctly formalized using Filter.Tendsto, accurately capturing the mathematical meaning of lim(n\u2192\u221e) 1/n = 0.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, we can substitute $0$ for $1/n$ in the expression, which gives us $\\frac{3+0}{1+0}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for each natural number n, $a_n = \\frac{3n+1}{n+1}$ [tc_1];\n\u2022 For all natural numbers n, $\\frac{3n+1}{n+1} = \\frac{3+1/n}{1+1/n}$ [l1];\n\u2022 The limit of the sequence $(1/n)$ as n approaches infinity is 0, i.e., $\\lim_{n \\to \\infty} 1/n = 0$ [l2].\nTherefore, we conclude:\n\u2022 The limit of the expression $\\frac{3+1/n}{1+1/n}$ as n approaches infinity is $\\frac{3+0}{1+0}$, i.e., $\\lim_{n \\to \\infty} \\frac{3+1/n}{1+1/n} = \\frac{3+0}{1+0}$ [l3].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 :\n  Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds 3) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 :\n  Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds 3) := by\n  have h\u2081 : Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds 3) := by\n    have h\u2082 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n      have h\u2083 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n        have h\u2084 : Filter.Tendsto (fun n : \u2115 => (n : \u211d)) Filter.atTop Filter.atTop := by\n          exact tendsto_natCast_atTop_atTop\n        have h\u2085 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n          -- Use the fact that 1/n tends to 0 as n tends to infinity\n          have h\u2086 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n            have h\u2087 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := by\n              simpa [div_eq_mul_inv] using\n                tendsto_const_nhds.div_atTop (tendsto_natCast_atTop_atTop)\n            exact h\u2087\n          exact h\u2086\n        exact h\u2085\n      exact h\u2083\n    -- Use the fact that the limit of a quotient is the quotient of the limits\n    have h\u2083 : Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds 3) := by\n      have h\u2084 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d) + 1 / (n : \u211d)) Filter.atTop (nhds (3 : \u211d)) := by\n        have h\u2085 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d) + 1 / (n : \u211d)) Filter.atTop (nhds ((3 : \u211d) + 0)) := by\n          have h\u2086 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := h\u2082\n          have h\u2087 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d) + 1 / (n : \u211d)) Filter.atTop (nhds ((3 : \u211d) + 0)) := by\n            convert Filter.Tendsto.const_add (3 : \u211d) h\u2086 using 1 <;> simp [add_assoc]\n          exact h\u2087\n        have h\u2088 : (3 : \u211d) + 0 = (3 : \u211d) := by norm_num\n        rw [h\u2088] at h\u2085\n        exact h\u2085\n      have h\u2085 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) + 1 / (n : \u211d)) Filter.atTop (nhds (1 : \u211d)) := by\n        have h\u2086 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) + 1 / (n : \u211d)) Filter.atTop (nhds ((1 : \u211d) + 0)) := by\n          have h\u2087 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0) := h\u2082\n          have h\u2088 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d) + 1 / (n : \u211d)) Filter.atTop (nhds ((1 : \u211d) + 0)) := by\n            convert Filter.Tendsto.const_add (1 : \u211d) h\u2087 using 1 <;> simp [add_assoc]\n          exact h\u2088\n        have h\u2089 : (1 : \u211d) + 0 = (1 : \u211d) := by norm_num\n        rw [h\u2089] at h\u2086\n        exact h\u2086\n      have h\u2086 : Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds (3 : \u211d)) := by\n        have h\u2087 : Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds ((3 : \u211d) / (1 : \u211d))) :=\n          Filter.Tendsto.div h\u2084 h\u2085 (by norm_num)\n        have h\u2088 : (3 : \u211d) / (1 : \u211d) = (3 : \u211d) := by norm_num\n        rw [h\u2088] at h\u2087\n        exact h\u2087\n      exact h\u2086\n    exact h\u2083\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization only captures the final conclusion [l3] about the limit of (3+1/n)/(1+1/n) approaching 3, but completely omits three key components from the natural language: (1) the original sequence definition a_n = (3n+1)/(n+1) [tc_1], (2) the algebraic identity showing these expressions are equal [l1], and (3) the basic limit fact that 1/n \u2192 0 [l2]. While the final limit statement is correctly formalized, missing the foundational mathematical context and reasoning chain constitutes a major inconsistency.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization only captures the final conclusion [l3] about the limit of (3+1/n)/(1+1/n) approaching 3, but completely omits three key components from the natural language: (1) the original sequence definition a_n = (3n+1)/(n+1) [tc_1], (2) the algebraic identity showing these expressions are equal [l1], and (3) the basic limit fact that 1/n \u2192 0 [l2]. While the final limit statement is correctly formalized, missing the foundational mathematical context and reasoning chain constitutes a major inconsistency.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "This simplifies to $3$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for each natural number n, $a_n = \\frac{3n+1}{n+1}$ [tc_1];\n\u2022 For all natural numbers n, $\\frac{3n+1}{n+1} = \\frac{3+1/n}{1+1/n}$ [l1];\n\u2022 The limit of the sequence $(1/n)$ as n approaches infinity is 0, i.e., $\\lim_{n \\to \\infty} 1/n = 0$ [l2];\n\u2022 The limit of the expression $\\frac{3+1/n}{1+1/n}$ as n approaches infinity is $\\frac{3+0}{1+0}$ [l3].\nTherefore, we conclude:\n\u2022 $\\frac{3+0}{1+0} = 3$ [l4].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 :\n  let a : \u2115 \u2192 \u211d := fun n => (3 * n + 1) / (n + 1)\n  (\u2200 n : \u2115, a n = (3 * n + 1) / (n + 1)) \u2192\n  (\u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) \u2192\n  (Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0)) \u2192\n  (Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds 3)) \u2192\n  (3 + 0) / (1 + 0) = 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 :\n  let a : \u2115 \u2192 \u211d := fun n => (3 * n + 1) / (n + 1)\n  (\u2200 n : \u2115, a n = (3 * n + 1) / (n + 1)) \u2192\n  (\u2200 n : \u2115, (3 * n + 1) / (n + 1) = (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) \u2192\n  (Filter.Tendsto (fun n : \u2115 => (1 : \u211d) / (n : \u211d)) Filter.atTop (nhds 0)) \u2192\n  (Filter.Tendsto (fun n : \u2115 => (3 + 1 / (n : \u211d)) / (1 + 1 / (n : \u211d))) Filter.atTop (nhds 3)) \u2192\n  (3 + 0) / (1 + 0) = 3 := by\n  intro a h\u2080 h\u2081 h\u2082 h\u2083\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly formalized with proper type annotations and universal quantification.", "The algebraic identity is accurately represented with appropriate type coercions from natural numbers to reals.", "The limit property is correctly expressed using Lean's filter-based limit notation.", "The limit evaluation correctly captures the mathematical meaning, with the limit directly stated as 3 rather than the intermediate expression, which is mathematically equivalent.", "The final arithmetic calculation is exactly represented."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "So, the limit of the sequence $(a_n)$ is $3$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where for each natural number n, $a_n = \\frac{3n+1}{n+1}$ [tc_1];\n\u2022 For all natural numbers n, $\\frac{3n+1}{n+1} = \\frac{3+1/n}{1+1/n}$ [l1];\n\u2022 The limit of the sequence $(1/n)$ as n approaches infinity is 0, i.e., $\\lim_{n \\to \\infty} 1/n = 0$ [l2];\n\u2022 The limit of the expression $\\frac{3+1/n}{1+1/n}$ as n approaches infinity is $\\frac{3+0}{1+0}$ [l3];\n\u2022 $\\frac{3+0}{1+0} = 3$ [l4].\nTherefore, we conclude:\n\u2022 The limit of the sequence $(a_n)$ is 3, i.e., $\\lim_{n \\to \\infty} a_n = 3$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 :\n  let a : \u2115 \u2192 \u211d := fun n => (3 * n + 1) / (n + 1)\n  Filter.Tendsto a Filter.atTop (nhds 3) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 :\n  let a : \u2115 \u2192 \u211d := fun n => (3 * n + 1) / (n + 1)\n  Filter.Tendsto a Filter.atTop (nhds 3) := by\n  intro a\n  have h\u2081 : Filter.Tendsto a Filter.atTop (nhds 3) := by\n    have h\u2082 : a = fun n : \u2115 => (3 * n + 1 : \u211d) / (n + 1 : \u211d) := rfl\n    rw [h\u2082]\n    have h\u2083 : Filter.Tendsto (fun n : \u2115 => (3 * n + 1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 3) := by\n      have h\u2084 : Filter.Tendsto (fun n : \u2115 => (3 * n + 1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 3) := by\n        -- Use the fact that the limit of (3n + 1)/(n + 1) as n \u2192 \u221e is 3\n        have h\u2085 : Filter.Tendsto (fun n : \u2115 => (3 * (n : \u211d) + 1) / ((n : \u211d) + 1)) Filter.atTop (nhds 3) := by\n          -- Prove that the limit of (3n + 1)/(n + 1) as n \u2192 \u221e is 3\n          have h\u2086 : Filter.Tendsto (fun n : \u2115 => (n : \u211d)) Filter.atTop Filter.atTop := by\n            exact tendsto_natCast_atTop_atTop\n          -- Use the fact that the limit of 1/n as n \u2192 \u221e is 0\n          have h\u2087 : Filter.Tendsto (fun n : \u2115 => (3 * (n : \u211d) + 1) / ((n : \u211d) + 1)) Filter.atTop (nhds 3) := by\n            -- Rewrite the expression to use the limit of 1/n\n            have h\u2088 : (fun n : \u2115 => (3 * (n : \u211d) + 1) / ((n : \u211d) + 1)) = (fun n : \u2115 => 3 - 2 / ((n : \u211d) + 1)) := by\n              funext n\n              have h\u2089 : (3 * (n : \u211d) + 1 : \u211d) / ((n : \u211d) + 1 : \u211d) = 3 - 2 / ((n : \u211d) + 1 : \u211d) := by\n                have h\u2081\u2080 : (n : \u211d) + 1 \u2260 0 := by positivity\n                field_simp [h\u2081\u2080]\n                <;> ring_nf\n                <;> field_simp [h\u2081\u2080]\n                <;> ring_nf\n                <;> linarith\n              rw [h\u2089]\n            rw [h\u2088]\n            -- Use the fact that the limit of 2/(n + 1) as n \u2192 \u221e is 0\n            have h\u2089 : Filter.Tendsto (fun n : \u2115 => (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds 0) := by\n              have h\u2081\u2080 : Filter.Tendsto (fun n : \u2115 => (n : \u211d)) Filter.atTop Filter.atTop := by\n                exact tendsto_natCast_atTop_atTop\n              have h\u2081\u2081 : Filter.Tendsto (fun n : \u2115 => (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds 0) := by\n                have h\u2081\u2082 : Filter.Tendsto (fun n : \u2115 => (n : \u211d) + 1) Filter.atTop Filter.atTop := by\n                  have h\u2081\u2083 : Filter.Tendsto (fun n : \u2115 => (n : \u211d)) Filter.atTop Filter.atTop := by\n                    exact tendsto_natCast_atTop_atTop\n                  have h\u2081\u2084 : Filter.Tendsto (fun n : \u2115 => (1 : \u211d)) Filter.atTop (nhds (1 : \u211d)) := by\n                    exact tendsto_const_nhds\n                  have h\u2081\u2085 : Filter.Tendsto (fun n : \u2115 => (n : \u211d) + 1) Filter.atTop Filter.atTop := by\n                    have h\u2081\u2086 : Filter.Tendsto (fun n : \u2115 => (n : \u211d) + 1) Filter.atTop Filter.atTop := by\n                      apply Filter.Tendsto.atTop_add\n                      \u00b7 exact tendsto_natCast_atTop_atTop\n                      \u00b7 exact tendsto_const_nhds\n                    exact h\u2081\u2086\n                  exact h\u2081\u2085\n                have h\u2081\u2086 : Filter.Tendsto (fun n : \u2115 => (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds 0) := by\n                  have h\u2081\u2087 : Filter.Tendsto (fun n : \u2115 => (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds 0) := by\n                    convert tendsto_const_nhds.div_atTop h\u2081\u2082 using 1\n                    <;> simp [div_eq_mul_inv]\n                    <;> field_simp\n                    <;> ring_nf\n                  exact h\u2081\u2087\n                exact h\u2081\u2086\n              exact h\u2081\u2081\n            -- Use the fact that the limit of 3 - 2/(n + 1) as n \u2192 \u221e is 3\n            have h\u2081\u2080 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d) - (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds (3 - 0)) := by\n              have h\u2081\u2081 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d)) Filter.atTop (nhds (3 : \u211d)) := by\n                exact tendsto_const_nhds\n              have h\u2081\u2082 : Filter.Tendsto (fun n : \u2115 => (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds 0) := h\u2089\n              have h\u2081\u2083 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d) - (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds (3 - 0)) := by\n                convert h\u2081\u2081.sub h\u2081\u2082 using 1 <;> simp\n              exact h\u2081\u2083\n            have h\u2081\u2081 : (3 : \u211d) - 0 = (3 : \u211d) := by norm_num\n            have h\u2081\u2082 : Filter.Tendsto (fun n : \u2115 => (3 : \u211d) - (2 : \u211d) / ((n : \u211d) + 1)) Filter.atTop (nhds (3 : \u211d)) := by\n              simpa [h\u2081\u2081] using h\u2081\u2080\n            exact h\u2081\u2082\n          exact h\u2087\n        -- Convert the limit from \u2115 to \u211d\n        have h\u2086 : Filter.Tendsto (fun n : \u2115 => (3 * (n : \u211d) + 1) / ((n : \u211d) + 1)) Filter.atTop (nhds 3) := h\u2085\n        have h\u2087 : Filter.Tendsto (fun n : \u2115 => (3 * n + 1 : \u211d) / (n + 1 : \u211d)) Filter.atTop (nhds 3) := by\n          convert h\u2086 using 1\n          <;> simp [Nat.cast_add, Nat.cast_mul, Nat.cast_one]\n          <;> field_simp\n          <;> ring_nf\n          <;> norm_cast\n          <;> simp_all\n          <;> field_simp\n          <;> ring_nf\n          <;> norm_cast\n        exact h\u2087\n      exact h\u2084\n    exact h\u2083\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly translated from mathematical notation to Lean syntax, preserving the exact formula (3n+1)/(n+1)", "The limit statement is properly formalized using Mathlib's Filter.Tendsto with atTop and nhds, which is the standard way to express sequence limits in Lean", "The intermediate algebraic steps and limit properties mentioned in the natural language represent mathematical reasoning that would appear in the proof, not necessarily in the theorem statement itself", "The overall structure correctly captures the main mathematical claim while using appropriate Lean conventions. The 'sorry' indicates an incomplete proof but doesn't affect the correctness of the statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    