
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = \frac{1}{n^2}$. Let $S_N = \sum_{n=1}^{N} a_n$ be the partial sum of the series. Then for any integer $N \geq 2$, the inequality $S_N \leq 2 - \frac{1}{N}$ holds.

Proof: The proof is by induction. First, for the base case $N=2$, we have $S_2 = \sum_{n=1}^{2} \frac{1}{n^2} = \frac{1}{1^2} + \frac{1}{2^2} = 1 + \frac{1}{4} = 1.25$. The right side of the inequality is $2-\frac{1}{2}=1.5$. Since $1.25 \leq 1.5$, the inequality holds for $N=2$. Now for the inductive step, assume the inequality holds for some integer $k \geq 2$, i.e., $S_k \leq 2 - \frac{1}{k}$. We want to show it holds for $k+1$, i.e., $S_{k+1} \leq 2 - \frac{1}{k+1}$. We know that $S_{k+1} = S_k + a_{k+1} = S_k + \frac{1}{(k+1)^2}$. From the inductive hypothesis, $S_k \leq 2 - \frac{1}{k}$. So we have $S_{k+1} \leq 2 - \frac{1}{k} + \frac{1}{(k+1)^2}$. To prove the inequality, we need to show that $2 - \frac{1}{k} + \frac{1}{(k+1)^2} \leq 2 - \frac{1}{k+1}$. This simplifies to showing that $-\frac{1}{k} + \frac{1}{(k+1)^2} \leq -\frac{1}{k+1}$. We can rearrange this to show $\frac{1}{k+1} - \frac{1}{k} + \frac{1}{(k+1)^2} \leq 0$. To combine these terms, we use a common denominator of $k(k+1)^2$. We get $\frac{k(k+1) - (k+1)^2 + k}{k(k+1)^2} \leq 0$. The numerator is $k^2+k-(k^2+2k+1)+k = k^2+k-k^2-2k-1+k = -1$. So we need to show that $\frac{-1}{k(k+1)^2} \leq 0$. Since $k \geq 2$, the denominator $k(k+1)^2$ is always positive. Therefore, the fraction is always negative, which is less than or equal to zero. Thus, the inequality holds for $k+1$ and by induction, for all $N \geq 2$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = \frac{1}{n^2}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures that (a_n) is a sequence of real numbers using the type \u2115 \u2192 \u211d", "Natural language mentions 'integer n \u2265 1' while Lean uses natural numbers. For sequence indexing with n \u2265 1, this is functionally equivalent but represents a slight type difference", "The formula a_n = 1/n\u00b2 is correctly captured in Lean with appropriate type coercion to ensure real number arithmetic"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $S_N = \\sum_{n=1}^{N} a_n$ be the partial sum of the series.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a_n = 1/n^2 for n \u2265 1, with appropriate type casting from \u2115 to \u211d", "The Lean formalization correctly defines S_N as the sum from 1 to N of a_n using Finset.Icc 1 N", "The natural language explicitly states there are no conclusions in this premise, but the Lean theorem includes a substantial conclusion about S_N \u2264 2 - 1/N for N \u2265 2, which contradicts the premise-only nature of the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a_n = 1/n^2 for n \u2265 1, with appropriate type casting from \u2115 to \u211d', 'The Lean formalization correctly defines S_N as the sum from 1 to N of a_n using Finset.Icc 1 N', 'The natural language explicitly states there are no conclusions in this premise, but the Lean theorem includes a substantial conclusion about S_N \u2264 2 - 1/N for N \u2265 2, which contradicts the premise-only nature of the natural language statement']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Then for any integer $N \\geq 2$, the inequality $S_N \\leq 2 - \frac{1}{N}$ holds.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2];\n\u2022 The theorem concerns any integer $N \\geq 2$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition with `a : \u2115 \u2192 \u211d` and the condition `h1` that for all n \u2265 1, a n = 1/(n:\u211d)^2, which matches the mathematical statement exactly.", "The Lean formalization correctly defines S as a function from \u2115 to \u211d and condition `h2` states that S N equals the sum from 1 to N of a n, using `Finset.Icc 1 N` which represents the closed interval [1,N]. This perfectly matches the partial sum definition.", "The natural language states this is only about establishing conditions for N \u2265 2 with no conclusions, but the Lean formalization introduces a new conclusion `S N \u2264 2 - 1 / (N : \u211d)` that was not mentioned in the natural language premise. This is a major addition of mathematical content not present in the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the sequence definition with `a : \u2115 \u2192 \u211d` and the condition `h1` that for all n \u2265 1, a n = 1/(n:\u211d)^2, which matches the mathematical statement exactly.', 'The Lean formalization correctly defines S as a function from \u2115 to \u211d and condition `h2` states that S N equals the sum from 1 to N of a n, using `Finset.Icc 1 N` which represents the closed interval [1,N]. This perfectly matches the partial sum definition.', 'The natural language states this is only about establishing conditions for N \u2265 2 with no conclusions, but the Lean formalization introduces a new conclusion `S N \u2264 2 - 1 / (N : \u211d)` that was not mentioned in the natural language premise. This is a major addition of mathematical content not present in the original statement.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, for the base case $N=2$, we have $S_2 = \\sum_{n=1}^{2} \frac{1}{n^2} = \frac{1}{1^2} + \frac{1}{2^2} = 1 + \frac{1}{4} = 1.25$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2];\n\u2022 The theorem concerns any integer $N \\geq 2$ [tc_3];\nTherefore, we conclude:\n\u2022 For N=2, the partial sum is $S_2 = 1.25$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, N \u2265 1 \u2192 S N = \u2211 n in Finset.Icc 1 N, a n) :\n  S 2 = 5/4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, N \u2265 1 \u2192 S N = \u2211 n in Finset.Icc 1 N, a n) :\n  S 2 = 5/4 := by\n  have h_sum : S 2 = \u2211 n in Finset.Icc 1 2, a n := by\n    have h3 : S 2 = \u2211 n in Finset.Icc 1 2, a n := by\n      have h4 : (2 : \u2115) \u2265 1 := by norm_num\n      have h5 : S 2 = \u2211 n in Finset.Icc 1 2, a n := h2 2 h4\n      exact h5\n    exact h3\n  \n  have h_a1 : a 1 = (1 : \u211d) := by\n    have h3 : a 1 = (1 : \u211d) := by\n      have h4 : a 1 = 1 / (1 : \u211d) ^ 2 := by\n        have h5 : (1 : \u2115) \u2265 1 := by norm_num\n        have h6 : a 1 = 1 / (1 : \u211d) ^ 2 := h1 1 h5\n        exact h6\n      -- Simplify the expression 1 / (1 : \u211d) ^ 2 to 1 using norm_num\n      have h7 : (1 : \u211d) / (1 : \u211d) ^ 2 = (1 : \u211d) := by norm_num\n      -- Use the fact that 1 / (1 : \u211d) ^ 2 is equal to 1 to conclude the proof\n      calc\n        a 1 = 1 / (1 : \u211d) ^ 2 := h4\n        _ = (1 : \u211d) / (1 : \u211d) ^ 2 := by norm_num\n        _ = (1 : \u211d) := by norm_num\n    exact h3\n  \n  have h_a2 : a 2 = (1 : \u211d) / 4 := by\n    have h3 : a 2 = (1 : \u211d) / 4 := by\n      have h4 : a 2 = 1 / (2 : \u211d) ^ 2 := by\n        have h5 : (2 : \u2115) \u2265 1 := by norm_num\n        have h6 : a 2 = 1 / (2 : \u211d) ^ 2 := h1 2 h5\n        exact h6\n      -- Simplify the expression 1 / (2 : \u211d) ^ 2 to 1 / 4 using norm_num\n      have h7 : (1 : \u211d) / (2 : \u211d) ^ 2 = (1 : \u211d) / 4 := by norm_num\n      -- Use the fact that 1 / (2 : \u211d) ^ 2 is equal to 1 / 4 to conclude the proof\n      calc\n        a 2 = 1 / (2 : \u211d) ^ 2 := h4\n        _ = (1 : \u211d) / (2 : \u211d) ^ 2 := by norm_num\n        _ = (1 : \u211d) / 4 := by norm_num\n    exact h3\n  \n  have h_sum_expanded : \u2211 n in Finset.Icc 1 2, a n = a 1 + a 2 := by\n    have h3 : \u2211 n in Finset.Icc 1 2, a n = a 1 + a 2 := by\n      norm_num [Finset.sum_Icc_succ_top]\n      <;>\n      simp [Finset.sum_range_succ, Finset.Icc_self]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n    rw [h3]\n  \n  have h_final : S 2 = 5 / 4 := by\n    rw [h_sum]\n    rw [h_sum_expanded]\n    rw [h_a1, h_a2]\n    <;> norm_num\n    <;> ring_nf\n    <;> norm_num\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 43, "endLine": 19, "endColumn": 50, "data": "type mismatch\n  h1 1 h5\nhas type\n  a 1 = 1 / \u21911 ^ 2 : Prop\nbut is expected to have type\n  a 1 = 1 / 1 ^ 2 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition a_n = 1/n\u00b2 for n \u2265 1 is correctly formalized as h1 with proper type coercion from \u2115 to \u211d", "The partial sum definition S_N = \u03a3(n=1 to N) a_n is correctly captured using Finset.Icc 1 N in h2", "The constraint N \u2265 2 is implicitly satisfied since the theorem proves a statement about N=2 specifically", "The conclusion S_2 = 1.25 is correctly formalized as S 2 = 5/4, since 5/4 = 1.25 mathematically", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, N \u2265 1 \u2192 S N = \u2211 n in Finset.Icc 1 N, a n) :\n  S 2 = 5/4 := by\n  have h3 : a 1 = 1 := by\n    have h3\u2081 : a 1 = 1 / (1 : \u211d) ^ 2 := by\n      have h3\u2082 : (1 : \u2115) \u2265 1 := by norm_num\n      have h3\u2083 : a 1 = 1 / (1 : \u211d) ^ 2 := by\n        specialize h1 1 (by norm_num)\n        norm_cast at h1 \u22a2\n        <;> simp_all\n        <;> norm_num\n        <;> linarith\n      exact h3\u2083\n    rw [h3\u2081]\n    <;> norm_num\n  \n  have h4 : a 2 = 1/4 := by\n    have h4\u2081 : a 2 = 1 / (2 : \u211d) ^ 2 := by\n      have h4\u2082 : (2 : \u2115) \u2265 1 := by norm_num\n      have h4\u2083 : a 2 = 1 / (2 : \u211d) ^ 2 := by\n        specialize h1 2 (by norm_num)\n        norm_cast at h1 \u22a2\n        <;> simp_all\n        <;> norm_num\n        <;> linarith\n      exact h4\u2083\n    rw [h4\u2081]\n    <;> norm_num\n  \n  have h5 : S 2 = a 1 + a 2 := by\n    have h5\u2081 : S 2 = \u2211 n in Finset.Icc 1 2, a n := by\n      apply h2\n      <;> norm_num\n    rw [h5\u2081]\n    have h5\u2082 : \u2211 n in Finset.Icc 1 2, a n = a 1 + a 2 := by\n      norm_num [Finset.sum_Icc_succ_top]\n      <;>\n      simp [Finset.sum_range_succ, Finset.sum_range_zero, add_assoc]\n      <;>\n      norm_num\n      <;>\n      rfl\n    rw [h5\u2082]\n    <;>\n    norm_num\n  \n  have h6 : S 2 = 5/4 := by\n    rw [h5]\n    rw [h3]\n    rw [h4]\n    <;> norm_num\n  \n  apply h6"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "The right side of the inequality is $2-\frac{1}{2}=1.5$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2];\n\u2022 The theorem concerns any integer $N \\geq 2$ [tc_3];\n\u2022 For N=2, the partial sum is $S_2 = 1.25$ [l1];\nTherefore, we conclude:\n\u2022 For N=2, the right side of the target inequality is $2 - 1/2 = 1.5$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 :\n  (2 : \u211d) - 1/2 = 3/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 :\n  (2 : \u211d) - 1/2 = 3/2 := by\n  have h : (2 : \u211d) - 1/2 = 3/2 := by\n    norm_num\n    <;>\n    simp_all\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  exact h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical statement from the natural language. While the natural language uses decimal notation (1.5) and Lean uses fractional notation (3/2), these represent the same mathematical value. The arithmetic operation 2 - 1/2 and the equality assertion are identical in both versions. This is a perfect semantic match with only notational differences."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since $1.25 \\leq 1.5$, the inequality holds for $N=2$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2];\n\u2022 The theorem concerns any integer $N \\geq 2$ [tc_3];\n\u2022 For N=2, the partial sum is $S_2 = 1.25$ [l1];\n\u2022 For N=2, the right side of the target inequality is $2 - 1/2 = 1.5$ [l2];\nTherefore, we conclude:\n\u2022 The inequality $S_N \\leq 2 - 1/N$ holds for the base case N=2, as $S_2 \\leq 2 - 1/2$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (l1 : S 2 = 5/4)\n  (l2 : (2 : \u211d) - 1/2 = 3/2) :\n  S 2 \u2264 (2 : \u211d) - 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (l1 : S 2 = 5/4)\n  (l2 : (2 : \u211d) - 1/2 = 3/2) :\n  S 2 \u2264 (2 : \u211d) - 1/2 := by\n  have h_main : S 2 \u2264 (2 : \u211d) - 1/2 := by\n    have h0 : S 2 = 5 / 4 := l1\n    have h1 : (5 : \u211d) / 4 \u2264 (2 : \u211d) - 1 / 2 := by\n      norm_num\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.83, "semantic_feedback": ["The sequence definition tc_1 correctly captures a_n = 1/n^2 for n \u2265 1 using proper Lean syntax with type coercion.", "The partial sum definition tc_2 accurately represents the summation from 1 to N using Finset.Icc.", "The constraint N \u2265 2 mentioned in natural language is not explicitly included as a hypothesis, though it's implicitly satisfied since the conclusion deals with N=2.", "The value S_2 = 1.25 is correctly represented as 5/4 in Lean, which are mathematically equivalent.", "The equation 2 - 1/2 = 1.5 is properly formalized as 2 - 1/2 = 3/2, with correct mathematical equivalence.", "The main inequality S_2 \u2264 2 - 1/2 is directly and accurately translated to Lean syntax."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the inequality holds for some integer $k \\geq 2$, i.e., $S_k \\leq 2 - \frac{1}{k}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2];\n\u2022 The theorem concerns any integer $N \\geq 2$ [tc_3];\n\u2022 The inequality holds for N=2 [l3];\nDefinition:\n\u2022 For the inductive step, assume for some integer $k \\geq 2$ that the inductive hypothesis $S_k \\leq 2 - 1/k$ holds [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem inductive_step (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 S k \u2264 2 - 1 / (k : \u211d) \u2192 S (k + 1) \u2264 2 - 1 / ((k + 1) : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition with the same formula and domain constraint", "The Lean formalization correctly defines the partial sum using Finset.Icc 1 N which represents the sum from 1 to N", "The natural language mentions the theorem concerns any integer N \u2265 2, but the Lean theorem is specifically about the inductive step from k to k+1, not a general statement about all N \u2265 2", "The natural language mentions that the inequality holds for N=2 as a base case, but this is completely missing from the Lean theorem which only proves the inductive step", "The natural language describes assuming the inductive hypothesis for some k \u2265 2, but the Lean theorem structure shows this as a premise in an implication rather than just an assumption. However, more critically, the Lean theorem proves the inductive step S(k+1) \u2264 2 - 1/(k+1) which is not mentioned in the natural language conditions"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the sequence definition with the same formula and domain constraint', 'The Lean formalization correctly defines the partial sum using Finset.Icc 1 N which represents the sum from 1 to N', 'The natural language mentions the theorem concerns any integer N \u2265 2, but the Lean theorem is specifically about the inductive step from k to k+1, not a general statement about all N \u2265 2', 'The natural language mentions that the inequality holds for N=2 as a base case, but this is completely missing from the Lean theorem which only proves the inductive step', 'The natural language describes assuming the inductive hypothesis for some k \u2265 2, but the Lean theorem structure shows this as a premise in an implication rather than just an assumption. However, more critically, the Lean theorem proves the inductive step S(k+1) \u2264 2 - 1/(k+1) which is not mentioned in the natural language conditions']"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "We know that $S_{k+1} = S_k + a_{k+1} = S_k + \frac{1}{(k+1)^2}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers where $a_n = 1/n^2$ for any integer $n \\geq 1$ [tc_1];\n\u2022 $S_N = \\sum_{n=1}^{N} a_n$ is the N-th partial sum of the series $(a_n)$ [tc_2];\n\u2022 For some integer $k \\geq 2$, we assume $S_k \\leq 2 - 1/k$ [def_1];\nTherefore, we conclude:\n\u2022 $S_{k+1} = S_k + 1/(k+1)^2$ [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 S k \u2264 2 - 1 / (k : \u211d))\n  (k : \u2115)\n  (hk : k \u2265 2) :\n  S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 S k \u2264 2 - 1 / (k : \u211d))\n  (k : \u2115)\n  (hk : k \u2265 2) :\n  S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2 := by\n  have h\u2081 : 1 \u2264 (k + 1 : \u2115) := by\n    have h\u2081\u2081 : k \u2265 2 := hk\n    have h\u2081\u2082 : (k : \u2115) + 1 \u2265 3 := by\n      omega\n    omega\n  \n  have h\u2082 : S (k + 1) = \u2211 n in Finset.Icc 1 (k + 1), a n := by\n    rw [tc_2]\n    <;> simp [Finset.Icc_eq_empty]\n    <;> norm_num\n    <;> linarith\n  \n  have h\u2083 : \u2211 n in Finset.Icc 1 (k + 1), a n = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by\n    have h\u2083\u2081 : \u2211 n in Finset.Icc 1 (k + 1), a n = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by\n      rw [Finset.sum_Icc_succ_top (by omega : 1 \u2264 k + 1)]\n      <;> simp [add_comm]\n    rw [h\u2083\u2081]\n  \n  have h\u2084 : S k = \u2211 n in Finset.Icc 1 k, a n := by\n    rw [tc_2]\n    <;> simp [Finset.Icc_eq_empty]\n    <;> norm_num\n    <;> linarith\n  \n  have h\u2085 : a (k + 1) = 1 / ((k + 1) : \u211d)^2 := by\n    have h\u2085\u2081 : (k + 1 : \u2115) \u2265 1 := by\n      omega\n    have h\u2085\u2082 : a (k + 1) = 1 / ((k + 1 : \u2115) : \u211d)^2 := by\n      apply tc_1\n      <;> omega\n    rw [h\u2085\u2082]\n    <;> norm_cast\n    <;> field_simp\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [Nat.cast_add, Nat.cast_one]\n    <;> field_simp\n    <;> ring_nf\n    <;> norm_num\n  \n  have h\u2086 : S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2 := by\n    calc\n      S (k + 1) = \u2211 n in Finset.Icc 1 (k + 1), a n := by rw [h\u2082]\n      _ = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by rw [h\u2083]\n      _ = S k + a (k + 1) := by\n        rw [h\u2084]\n        <;> ring\n      _ = S k + 1 / ((k + 1) : \u211d)^2 := by\n        rw [h\u2085]\n        <;> ring\n        <;> field_simp\n        <;> ring_nf\n        <;> norm_num\n  \n  apply h\u2086", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition tc_1 is correctly formalized with proper domain restriction n \u2265 1.", "The partial sum definition tc_2 correctly uses Finset.Icc 1 N to represent the summation from 1 to N.", "The assumption def_1 has a major logical inconsistency. The natural language states 'for some integer k \u2265 2' (existential quantification) but the Lean formalization uses universal quantification '\u2200 k : \u2115, k \u2265 2 \u2192', which is a fundamentally different logical statement.", "The conclusion l4 correctly formalizes the relationship S_{k+1} = S_k + 1/(k+1)^2.", "The variable k and its constraint k \u2265 2 are properly declared in the theorem statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition tc_1 is correctly formalized with proper domain restriction n \u2265 1.', 'The partial sum definition tc_2 correctly uses Finset.Icc 1 N to represent the summation from 1 to N.', \"The assumption def_1 has a major logical inconsistency. The natural language states 'for some integer k \u2265 2' (existential quantification) but the Lean formalization uses universal quantification '\u2200 k : \u2115, k \u2265 2 \u2192', which is a fundamentally different logical statement.\", 'The conclusion l4 correctly formalizes the relationship S_{k+1} = S_k + 1/(k+1)^2.', 'The variable k and its constraint k \u2265 2 are properly declared in the theorem statement.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "From the inductive hypothesis, $S_k \\leq 2 - \frac{1}{k}$. So we have $S_{k+1} \\leq 2 - \frac{1}{k} + \frac{1}{(k+1)^2}$.", "statement": "We assume:\n\u2022 For some integer $k \\geq 2$, we assume $S_k \\leq 2 - 1/k$ [def_1];\n\u2022 $S_{k+1} = S_k + 1/(k+1)^2$ [l4];\nTherefore, we conclude:\n\u2022 $S_{k+1} \\leq 2 - 1/k + 1/(k+1)^2$ [l5].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 S k \u2264 2 - 1 / (k : \u211d))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2)\n  (k : \u2115)\n  (hk : k \u2265 2) :\n  S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 S k \u2264 2 - 1 / (k : \u211d))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2)\n  (k : \u2115)\n  (hk : k \u2265 2) :\n  S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 := by\n  have h1 : S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2 := by\n    have h\u2081 : S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2 := l4 k hk\n    exact h\u2081\n  \n  have h2 : S k \u2264 2 - 1 / (k : \u211d) := by\n    have h\u2082 : S k \u2264 2 - 1 / (k : \u211d) := def_1 k hk\n    exact h\u2082\n  \n  have h3 : S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 := by\n    have h\u2083 : S (k + 1) = S k + 1 / ((k + 1) : \u211d)^2 := h1\n    rw [h\u2083]\n    have h\u2084 : S k \u2264 2 - 1 / (k : \u211d) := h2\n    have h\u2085 : (1 : \u211d) / ((k + 1 : \u2115) : \u211d) ^ 2 \u2265 0 := by positivity\n    linarith\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects, with standard type conversions from integers to natural numbers", "The explicit definition of S as a sum of 1/n\u00b2 terms is mathematically consistent with the implicit definition suggested by the recurrence relation in natural language", "The assumption def_1 is perfectly translated with proper quantification and type annotations", "The recurrence relation l4 is exactly captured in the Lean formalization", "The conclusion l5 matches the natural language statement exactly", "The overall logical structure as a theorem with hypotheses leading to a conclusion perfectly mirrors the natural language reasoning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "To prove the inequality, we need to show that $2 - \frac{1}{k} + \frac{1}{(k+1)^2} \\leq 2 - \frac{1}{k+1}$. This simplifies to showing that $-\frac{1}{k} + \frac{1}{(k+1)^2} \\leq -\frac{1}{k+1}$. We can rearrange this to show $\frac{1}{k+1} - \frac{1}{k} + \frac{1}{(k+1)^2} \\leq 0$. To combine these terms, we use a common denominator of $k(k+1)^2$. We get $\frac{k(k+1) - (k+1)^2 + k}{k(k+1)^2} \\leq 0$. The numerator is $k^2+k-(k^2+2k+1)+k = k^2+k-k^2-2k-1+k = -1$. So we need to show that $\frac{-1}{k(k+1)^2} \\leq 0$.", "statement": "We assume:\n\u2022 For some integer $k \\geq 2$, we assume $S_k \\leq 2 - 1/k$ [def_1];\nTherefore, we conclude:\n\u2022 The algebraic expression $(2 - 1/k + 1/(k+1)^2) - (2 - 1/(k+1))$ simplifies to $-1/(k(k+1)^2)$ [l6].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (k : \u2115) (hk : k \u2265 2) :\n  (2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2) - (2 - 1 / ((k + 1) : \u211d)) = -1 / ((k : \u211d) * ((k + 1) : \u211d)^2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (k : \u2115) (hk : k \u2265 2) :\n  (2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2) - (2 - 1 / ((k + 1) : \u211d)) = -1 / ((k : \u211d) * ((k + 1) : \u211d)^2) := by\n  have h\u2081 : (2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2) - (2 - 1 / ((k + 1) : \u211d)) = -1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 + 1 / ((k + 1) : \u211d) := by\n    have h\u2081\u2081 : (2 : \u211d) - 1 / (k : \u211d) + 1 / ((k + 1 : \u2115) : \u211d) ^ 2 - (2 - 1 / ((k + 1 : \u2115) : \u211d)) = -1 / (k : \u211d) + 1 / ((k + 1 : \u2115) : \u211d) ^ 2 + 1 / ((k + 1 : \u2115) : \u211d) := by\n      ring_nf\n      <;> field_simp\n      <;> ring_nf\n      <;> norm_cast\n      <;> field_simp\n      <;> ring_nf\n      <;> norm_cast\n      <;> linarith\n    simpa [add_assoc, add_comm, add_left_comm] using h\u2081\u2081\n  \n  have h\u2082 : -1 / (k : \u211d) + 1 / ((k + 1) : \u211d) = -1 / ((k : \u211d) * ((k + 1) : \u211d)) := by\n    have h\u2082\u2081 : (k : \u211d) \u2260 0 := by\n      norm_cast\n      <;> omega\n    have h\u2082\u2082 : ((k + 1 : \u2115) : \u211d) \u2260 0 := by\n      norm_cast\n      <;> omega\n    have h\u2082\u2083 : ((k : \u211d) * ((k + 1 : \u2115) : \u211d)) \u2260 0 := by positivity\n    have h\u2082\u2084 : -1 / (k : \u211d) + 1 / ((k + 1) : \u211d) = (-1 : \u211d) / ((k : \u211d) * ((k + 1) : \u211d)) := by\n      field_simp [h\u2082\u2081, h\u2082\u2082, h\u2082\u2083]\n      <;> ring_nf\n      <;> field_simp [h\u2082\u2081, h\u2082\u2082, h\u2082\u2083]\n      <;> ring_nf\n      <;> norm_cast\n      <;> field_simp [h\u2082\u2081, h\u2082\u2082, h\u2082\u2083]\n      <;> ring_nf\n      <;> norm_cast\n      <;> linarith\n    exact h\u2082\u2084\n  \n  have h\u2083 : -1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 + 1 / ((k + 1) : \u211d) = -1 / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d)^2 := by\n    have h\u2083\u2081 : -1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 + 1 / ((k + 1) : \u211d) = (-1 / (k : \u211d) + 1 / ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d)^2 := by ring\n    rw [h\u2083\u2081]\n    have h\u2083\u2082 : -1 / (k : \u211d) + 1 / ((k + 1) : \u211d) = -1 / ((k : \u211d) * ((k + 1) : \u211d)) := h\u2082\n    rw [h\u2083\u2082]\n    <;> ring\n    <;> field_simp\n    <;> ring\n  \n  have h\u2084 : -1 / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d)^2 = -1 / ((k : \u211d) * ((k + 1) : \u211d)^2) := by\n    have h\u2084\u2081 : (k : \u211d) \u2260 0 := by\n      norm_cast\n      <;> omega\n    have h\u2084\u2082 : ((k + 1 : \u2115) : \u211d) \u2260 0 := by\n      norm_cast\n      <;> omega\n    have h\u2084\u2083 : ((k : \u211d) * ((k + 1 : \u2115) : \u211d)) \u2260 0 := by positivity\n    have h\u2084\u2084 : ((k : \u211d) * ((k + 1 : \u2115) : \u211d) ^ 2) \u2260 0 := by positivity\n    have h\u2084\u2085 : -1 / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d) ^ 2 = -1 / ((k : \u211d) * ((k + 1) : \u211d) ^ 2) := by\n      have h\u2084\u2086 : -1 / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d) ^ 2 = (-1 : \u211d) / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d) ^ 2 := by norm_num\n      rw [h\u2084\u2086]\n      have h\u2084\u2087 : (-1 : \u211d) / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d) ^ 2 = (-1 : \u211d) / ((k : \u211d) * ((k + 1) : \u211d) ^ 2) := by\n        field_simp [h\u2084\u2081, h\u2084\u2082, h\u2084\u2083, h\u2084\u2084]\n        <;> ring_nf\n        <;> field_simp [h\u2084\u2081, h\u2084\u2082, h\u2084\u2083, h\u2084\u2084]\n        <;> ring_nf\n        <;> norm_cast\n        <;> field_simp [h\u2084\u2081, h\u2084\u2082, h\u2084\u2083, h\u2084\u2084]\n        <;> ring_nf\n        <;> norm_cast\n        <;> linarith\n      rw [h\u2084\u2087]\n      <;> norm_num\n    exact h\u2084\u2085\n  \n  have h\u2085 : (2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2) - (2 - 1 / ((k + 1) : \u211d)) = -1 / ((k : \u211d) * ((k + 1) : \u211d)^2) := by\n    calc\n      (2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d) ^ 2) - (2 - 1 / ((k + 1) : \u211d)) = -1 / (k : \u211d) + 1 / ((k + 1) : \u211d) ^ 2 + 1 / ((k + 1) : \u211d) := by rw [h\u2081]\n      _ = -1 / ((k : \u211d) * ((k + 1) : \u211d)) + 1 / ((k + 1) : \u211d) ^ 2 := by rw [h\u2083]\n      _ = -1 / ((k : \u211d) * ((k + 1) : \u211d) ^ 2) := by rw [h\u2084]\n  \n  rw [h\u2085]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization completely omits the assumption about $S_k \\leq 2 - 1/k$, which is explicitly stated as a premise in the natural language. This is a key logical component that is missing.", "The algebraic expression and its simplification are perfectly captured in the Lean formalization. The mathematical equality is correctly represented with appropriate type coercions.", "The constraint $k \\geq 2$ is properly captured. Using natural numbers instead of integers is acceptable since the constraint ensures positive values.", "The natural language presents this as a conclusion that follows from the $S_k$ assumption, but the Lean formalization treats it as a standalone algebraic identity, missing the logical dependency structure."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely omits the assumption about $S_k \\\\leq 2 - 1/k$, which is explicitly stated as a premise in the natural language. This is a key logical component that is missing.', 'The algebraic expression and its simplification are perfectly captured in the Lean formalization. The mathematical equality is correctly represented with appropriate type coercions.', 'The constraint $k \\\\geq 2$ is properly captured. Using natural numbers instead of integers is acceptable since the constraint ensures positive values.', 'The natural language presents this as a conclusion that follows from the $S_k$ assumption, but the Lean formalization treats it as a standalone algebraic identity, missing the logical dependency structure.']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Since $k \\geq 2$, the denominator $k(k+1)^2$ is always positive.", "statement": "We assume:\n\u2022 For some integer $k \\geq 2$, we assume $S_k \\leq 2 - 1/k$ [def_1];\nTherefore, we conclude:\n\u2022 The denominator $k(k+1)^2$ is positive [l7].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (k : \u2115) (hk : k \u2265 2) :\n  (k : \u211d) * ((k + 1) : \u211d)^2 > 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (k : \u2115) (hk : k \u2265 2) :\n  (k : \u211d) * ((k + 1) : \u211d)^2 > 0 := by\n  have h\u2081 : (k : \u211d) > 0 := by\n    norm_cast\n    <;>\n    (try omega) <;>\n    (try linarith) <;>\n    (try nlinarith)\n    <;>\n    (try\n      {\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp_all [Nat.succ_eq_add_one]\n            <;> norm_num\n            <;> linarith\n      })\n  \n  have h\u2082 : ((k + 1 : \u2115) : \u211d) > 0 := by\n    norm_cast\n    <;>\n    (try omega) <;>\n    (try linarith) <;>\n    (try nlinarith)\n    <;>\n    (try\n      {\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp_all [Nat.succ_eq_add_one]\n            <;> norm_num\n            <;> linarith\n      })\n  \n  have h\u2083 : ((k + 1 : \u2115) : \u211d)^2 > 0 := by\n    have h\u2083\u2081 : ((k + 1 : \u2115) : \u211d) > 0 := h\u2082\n    have h\u2083\u2082 : ((k + 1 : \u2115) : \u211d)^2 > 0 := by\n      -- Use the fact that the square of a positive number is positive.\n      have h\u2083\u2083 : ((k + 1 : \u2115) : \u211d) \u2260 0 := by linarith\n      have h\u2083\u2084 : ((k + 1 : \u2115) : \u211d)^2 > 0 := by\n        -- Use the property that the square of a non-zero real number is positive.\n        exact pow_pos h\u2083\u2081 2\n      exact h\u2083\u2084\n    exact h\u2083\u2082\n  \n  have h\u2084 : (k : \u211d) * ((k + 1) : \u211d)^2 > 0 := by\n    have h\u2084\u2081 : (k : \u211d) > 0 := h\u2081\n    have h\u2084\u2082 : ((k + 1 : \u2115) : \u211d)^2 > 0 := h\u2083\n    have h\u2084\u2083 : ((k + 1) : \u211d) = ((k + 1 : \u2115) : \u211d) := by\n      norm_cast\n    have h\u2084\u2084 : (k : \u211d) * ((k + 1) : \u211d)^2 = (k : \u211d) * (((k + 1 : \u2115) : \u211d))^2 := by\n      rw [h\u2084\u2083]\n      <;> ring_nf\n    rw [h\u2084\u2084]\n    -- Since both factors are positive, their product is positive.\n    have h\u2084\u2085 : (k : \u211d) * (((k + 1 : \u2115) : \u211d))^2 > 0 := by\n      -- Use the fact that the product of two positive numbers is positive.\n      have h\u2084\u2086 : (k : \u211d) > 0 := h\u2081\n      have h\u2084\u2087 : (((k + 1 : \u2115) : \u211d))^2 > 0 := h\u2083\n      positivity\n    exact h\u2084\u2085\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization is missing a crucial assumption from the natural language. The natural language explicitly states an assumption 'S_k \u2264 2 - 1/k [def_1]' which is completely absent from the Lean theorem. While the conclusion about k(k+1)\u00b2 being positive is correctly captured, and the condition k \u2265 2 is properly included, the missing assumption about S_k represents a major logical component that should be present in the formalization. This omission changes the logical structure of the statement significantly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization is missing a crucial assumption from the natural language. The natural language explicitly states an assumption 'S_k \u2264 2 - 1/k [def_1]' which is completely absent from the Lean theorem. While the conclusion about k(k+1)\u00b2 being positive is correctly captured, and the condition k \u2265 2 is properly included, the missing assumption about S_k represents a major logical component that should be present in the formalization. This omission changes the logical structure of the statement significantly.\"]"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Therefore, the fraction is always negative, which is less than or equal to zero.", "statement": "We assume:\n\u2022 The denominator $k(k+1)^2$ is positive [l7];\nTherefore, we conclude:\n\u2022 The fraction $-1/(k(k+1)^2)$ is less than or equal to zero [l8].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 (k : \u2115) (hk : k \u2265 2) :\n  -1 / ((k : \u211d) * ((k + 1) : \u211d)^2) \u2264 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 (k : \u2115) (hk : k \u2265 2) :\n  -1 / ((k : \u211d) * ((k + 1) : \u211d)^2) \u2264 0 := by\n  have h_denom_pos : (0 : \u211d) < (k : \u211d) * ((k : \u211d) + 1)^2 := by\n    have h\u2081 : (0 : \u211d) < (k : \u211d) := by\n      norm_cast\n      <;> omega\n    have h\u2082 : (0 : \u211d) < (k : \u211d) + 1 := by linarith\n    have h\u2083 : (0 : \u211d) < ((k : \u211d) + 1) ^ 2 := by positivity\n    have h\u2084 : (0 : \u211d) < (k : \u211d) * ((k : \u211d) + 1) ^ 2 := by positivity\n    exact h\u2084\n  \n  have h_num_nonpos : (-1 : \u211d) \u2264 0 := by\n    norm_num\n  \n  have h_denom_nonneg : (0 : \u211d) \u2264 (k : \u211d) * ((k : \u211d) + 1)^2 := by\n    have h\u2081 : (0 : \u211d) \u2264 (k : \u211d) := by\n      norm_cast\n      <;> linarith\n    have h\u2082 : (0 : \u211d) \u2264 (k : \u211d) + 1 := by linarith\n    have h\u2083 : (0 : \u211d) \u2264 ((k : \u211d) + 1) ^ 2 := by positivity\n    have h\u2084 : (0 : \u211d) \u2264 (k : \u211d) * ((k : \u211d) + 1) ^ 2 := by positivity\n    exact h\u2084\n  \n  have h_main : (-1 : \u211d) / ((k : \u211d) * ((k + 1) : \u211d)^2) \u2264 0 := by\n    have h\u2081 : (k : \u211d) * ((k + 1) : \u211d)^2 = (k : \u211d) * ((k : \u211d) + 1)^2 := by\n      norm_cast\n      <;> ring_nf\n      <;> field_simp\n      <;> norm_cast\n      <;> ring_nf\n      <;> simp [add_assoc]\n      <;> norm_cast\n      <;> linarith\n    rw [h\u2081]\n    -- Use the fact that the numerator is non-positive and the denominator is non-negative to conclude the division is non-positive.\n    have h\u2082 : (-1 : \u211d) / ((k : \u211d) * ((k : \u211d) + 1)^2) \u2264 0 := by\n      apply div_nonpos_of_nonpos_of_nonneg\n      \u00b7 -- Prove that the numerator is non-positive\n        linarith\n      \u00b7 -- Prove that the denominator is non-negative\n        linarith\n    exact h\u2082\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language explicitly states an assumption about the denominator being positive, but the Lean formalization uses the condition k \u2265 2 instead. While mathematically equivalent (k \u2265 2 implies k(k+1)\u00b2 > 0), the structural presentation differs from the natural language which directly mentions denominator positivity.", "The conclusion about the fraction being less than or equal to zero is perfectly captured in the Lean formalization, with correct mathematical notation and logical structure."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The natural language explicitly states an assumption about the denominator being positive, but the Lean formalization uses the condition k \u2265 2 instead. While mathematically equivalent (k \u2265 2 implies k(k+1)\u00b2 > 0), the structural presentation differs from the natural language which directly mentions denominator positivity.', 'The conclusion about the fraction being less than or equal to zero is perfectly captured in the Lean formalization, with correct mathematical notation and logical structure.']"}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "Thus, the inequality holds for $k+1$.", "statement": "We assume:\n\u2022 The expression $(2 - 1/k + 1/(k+1)^2) - (2 - 1/(k+1))$ simplifies to $-1/(k(k+1)^2)$ [l6];\n\u2022 The fraction $-1/(k(k+1)^2)$ is less than or equal to zero [l8];\nTherefore, we conclude:\n\u2022 The inequality $2 - 1/k + 1/(k+1)^2 \\leq 2 - 1/(k+1)$ holds [l9].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d)\n  (h1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (h2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by\n  have h_general : \u2200 (N : \u2115), N \u2265 1 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by\n    intro N hN\n    have h3 : \u2200 (k : \u2115), k \u2265 1 \u2192 S k \u2264 2 - 1 / (k : \u211d) := by\n      intro k hk\n      induction' hk with k hk IH\n      \u00b7 -- Base case: k = 1\n        norm_num [h2, h1, Finset.sum_Icc_succ_top]\n        <;>\n        simp_all [Finset.sum_range_succ, Finset.sum_range_zero]\n        <;>\n        norm_num\n      \u00b7 -- Inductive step: assume the statement holds for k, prove for k + 1\n        have h4 : S (k + 1) = S k + a (k + 1) := by\n          have h5 : S (k + 1) = \u2211 n in Finset.Icc 1 (k + 1), a n := by rw [h2]\n          have h6 : S k = \u2211 n in Finset.Icc 1 k, a n := by rw [h2]\n          have h7 : \u2211 n in Finset.Icc 1 (k + 1), a n = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by\n            have h8 : Finset.Icc 1 (k + 1) = Finset.Icc 1 k \u222a {k + 1} := by\n              ext x\n              simp [Finset.mem_Icc, Nat.lt_succ_iff]\n              <;>\n              (try omega) <;>\n              (try\n                {\n                  by_cases h : x \u2264 k <;>\n                  simp_all [Nat.lt_succ_iff] <;>\n                  omega\n                })\n            rw [h8]\n            have h9 : Disjoint (Finset.Icc 1 k) ({k + 1} : Finset \u2115) := by\n              rw [Finset.disjoint_left]\n              intro x hx1 hx2\n              simp only [Finset.mem_singleton] at hx2\n              simp [Finset.mem_Icc] at hx1\n              omega\n            rw [Finset.sum_union h9]\n            <;> simp [Finset.sum_singleton]\n            <;>\n            (try norm_num) <;>\n            (try linarith)\n          rw [h5, h7, h6]\n          <;>\n          ring\n        rw [h4]\n        have h5 : a (k + 1) = 1 / ((k + 1 : \u2115) : \u211d) ^ 2 := by\n          have h6 : (k + 1 : \u2115) \u2265 1 := by linarith\n          have h7 : a (k + 1) = 1 / ((k + 1 : \u2115) : \u211d) ^ 2 := by\n            apply h1\n            <;> simp_all [Nat.cast_add, Nat.cast_one]\n            <;> linarith\n          exact h7\n        rw [h5]\n        have h6 : (2 : \u211d) - 1 / (k : \u211d) + 1 / ((k + 1 : \u2115) : \u211d) ^ 2 \u2264 (2 : \u211d) - 1 / ((k + 1 : \u2115) : \u211d) := by\n          have h7 : (k : \u211d) \u2265 1 := by\n            exact_mod_cast hk\n          have h8 : (0 : \u211d) < (k : \u211d) := by linarith\n          have h9 : (0 : \u211d) < (k : \u211d) + 1 := by linarith\n          have h10 : (0 : \u211d) < ((k : \u211d) + 1) ^ 2 := by positivity\n          have h11 : (0 : \u211d) < (k : \u211d) * ((k : \u211d) + 1) ^ 2 := by positivity\n          field_simp\n          rw [div_le_div_iff (by positivity) (by positivity)]\n          ring_nf\n          nlinarith [sq_nonneg ((k : \u211d) - 1)]\n        linarith\n    exact h3 N hN\n  \n  have h_main : \u2200 (N : \u2115), N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by\n    intro N hN\n    have h\u2081 : N \u2265 1 := by linarith\n    have h\u2082 : S N \u2264 2 - 1 / (N : \u211d) := h_general N h\u2081\n    exact h\u2082\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization addresses a completely different mathematical problem than described in the natural language. The natural language presents a step-by-step algebraic argument involving the simplification of expressions with consecutive integers k and k+1, leading to a specific inequality. However, the Lean code formalizes a theorem about upper bounds for partial sums of the series \u2211(1/n\u00b2), which is an entirely different mathematical context. Additionally, the key logical components from the natural language (the algebraic simplification to -1/(k(k+1)\u00b2) and the sign analysis) are completely absent from the Lean formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization addresses a completely different mathematical problem than described in the natural language. The natural language presents a step-by-step algebraic argument involving the simplification of expressions with consecutive integers k and k+1, leading to a specific inequality. However, the Lean code formalizes a theorem about upper bounds for partial sums of the series \u2211(1/n\u00b2), which is an entirely different mathematical context. Additionally, the key logical components from the natural language (the algebraic simplification to -1/(k(k+1)\u00b2) and the sign analysis) are completely absent from the Lean formalization.']"}, "solved_negation": null, "type": "lemma"}, "l10": {"id": "l10", "natural_language": "Thus, the inequality holds for $k+1$.", "statement": "We assume:\n\u2022 $S_{k+1} \\leq 2 - 1/k + 1/(k+1)^2$ [l5];\n\u2022 $2 - 1/k + 1/(k+1)^2 \\leq 2 - 1/(k+1)$ [l9];\nTherefore, we conclude:\n\u2022 The inequality holds for k+1, i.e., $S_{k+1} \\leq 2 - 1/(k+1)$ [l10].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4", "l5", "l6", "l7", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2)\n  (l9 : 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 \u2264 2 - 1 / ((k + 1) : \u211d)) :\n  S (k + 1) \u2264 2 - 1 / ((k + 1) : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (l5 : S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2)\n  (l9 : 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d)^2 \u2264 2 - 1 / ((k + 1) : \u211d)) :\n  S (k + 1) \u2264 2 - 1 / ((k + 1) : \u211d) := by\n  have h_main : S (k + 1) \u2264 2 - 1 / ((k + 1) : \u211d) := by\n    have h1 : S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d) ^ 2 := l5\n    have h2 : 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d) ^ 2 \u2264 2 - 1 / ((k + 1) : \u211d) := l9\n    -- Use the transitivity of the \u2264 relation to combine the two inequalities\n    calc\n      S (k + 1) \u2264 2 - 1 / (k : \u211d) + 1 / ((k + 1) : \u211d) ^ 2 := h1\n      _ \u2264 2 - 1 / ((k + 1) : \u211d) := h2\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the logical structure of the natural language argument. While it includes additional mathematical context (definitions of sequences a and S, constraint k \u2265 2), these are consistent additions that provide necessary formalization details. The core inequalities l5, l9, and conclusion l10 are precisely translated, and the transitivity argument structure is preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Thus, the inequality holds for $k+1$ and by induction, for all $N \\geq 2$.", "statement": "We assume:\n\u2022 For any integer $N \\geq 2$ [tc_3];\n\u2022 The inequality holds for the base case N=2 [l3];\n\u2022 Assuming the inequality for $k \\geq 2$ [def_1] implies it holds for $k+1$ [l10];\nTherefore, we conclude:\n\u2022 For any integer $N \\geq 2$, the inequality $S_N \\leq 2 - 1/N$ holds [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "def_1", "l4", "l5", "l6", "l7", "l8", "l9", "l10"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (S : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2)\n  (tc_2 : \u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) :\n  \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by\n  have h_sum_split : \u2200 (N : \u2115), N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2) = (1 : \u211d) + \u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2 := by\n    intro N hN\n    have h\u2081 : Finset.Icc 1 N = {1} \u222a Finset.Icc 2 N := by\n      apply Finset.ext\n      intro x\n      simp [Finset.mem_Icc, Finset.mem_singleton]\n      <;>\n      (try omega) <;>\n      (try\n        {\n          by_cases hx : x = 1 <;> by_cases hx' : x \u2264 N <;> by_cases hx'' : x \u2265 2 <;> simp_all [hx, hx', hx'']\n          <;> omega\n        })\n      <;>\n      (try\n        {\n          omega\n        })\n    have h\u2082 : Disjoint ({1} : Finset \u2115) (Finset.Icc 2 N) := by\n      rw [Finset.disjoint_left]\n      intro x hx\u2081 hx\u2082\n      have h\u2083 : x = 1 := by\n        simp only [Finset.mem_singleton] at hx\u2081\n        tauto\n      have h\u2084 : x \u2208 Finset.Icc 2 N := hx\u2082\n      rw [h\u2083] at h\u2084\n      simp [Finset.mem_Icc] at h\u2084\n      <;> omega\n    calc\n      (\u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2) = \u2211 n in ({1} : Finset \u2115) \u222a Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2 := by rw [h\u2081]\n      _ = \u2211 n in ({1} : Finset \u2115), (1 : \u211d) / (n : \u211d)^2 + \u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2 := by\n        rw [Finset.sum_union h\u2082]\n      _ = (1 : \u211d) + \u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2 := by\n        simp [Finset.sum_singleton]\n        <;> norm_num\n        <;> field_simp\n        <;> ring_nf\n  \n  have h_main : \u2200 (N : \u2115), N \u2265 2 \u2192 (\u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2) \u2264 2 - 1 / (N : \u211d) := by\n    intro N hN\n    have h\u2081 : (\u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2) = (1 : \u211d) + \u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2 := by\n      have h\u2082 : N \u2265 1 := by linarith\n      exact h_sum_split N h\u2082\n    rw [h\u2081]\n    have h\u2082 : (\u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2) \u2264 1 - 1 / (N : \u211d) := by\n      have h\u2083 : \u2200 (n : \u2115), n \u2208 Finset.Icc 2 N \u2192 (1 : \u211d) / (n : \u211d)^2 \u2264 (1 : \u211d) / ((n : \u211d) * ((n : \u211d) - 1)) := by\n        intro n hn\n        have h\u2084 : 2 \u2264 n := by\n          simp [Finset.mem_Icc] at hn\n          linarith\n        have h\u2085 : (n : \u211d) \u2265 2 := by exact_mod_cast h\u2084\n        have h\u2086 : (n : \u211d) - 1 > 0 := by linarith\n        have h\u2087 : (n : \u211d) > 0 := by linarith\n        have h\u2088 : (n : \u211d)^2 \u2265 (n : \u211d) * ((n : \u211d) - 1) := by\n          nlinarith\n        have h\u2089 : (1 : \u211d) / (n : \u211d)^2 \u2264 (1 : \u211d) / ((n : \u211d) * ((n : \u211d) - 1)) := by\n          apply one_div_le_one_div_of_le\n          \u00b7 positivity\n          \u00b7 nlinarith\n        exact h\u2089\n      have h\u2084 : (\u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2) \u2264 \u2211 n in Finset.Icc 2 N, (1 : \u211d) / ((n : \u211d) * ((n : \u211d) - 1)) := by\n        apply Finset.sum_le_sum\n        intro n hn\n        exact h\u2083 n hn\n      have h\u2085 : \u2211 n in Finset.Icc 2 N, (1 : \u211d) / ((n : \u211d) * ((n : \u211d) - 1)) = \u2211 n in Finset.Icc 2 N, ((1 : \u211d) / ((n : \u211d) - 1) - (1 : \u211d) / (n : \u211d)) := by\n        apply Finset.sum_congr rfl\n        intro n hn\n        have h\u2086 : 2 \u2264 n := by\n          simp [Finset.mem_Icc] at hn\n          linarith\n        have h\u2087 : (n : \u211d) \u2265 2 := by exact_mod_cast h\u2086\n        have h\u2088 : (n : \u211d) - 1 > 0 := by linarith\n        have h\u2089 : (n : \u211d) > 0 := by linarith\n        have h\u2081\u2080 : (1 : \u211d) / ((n : \u211d) * ((n : \u211d) - 1)) = (1 : \u211d) / ((n : \u211d) - 1) - (1 : \u211d) / (n : \u211d) := by\n          have h\u2081\u2081 : (n : \u211d) \u2260 0 := by linarith\n          have h\u2081\u2082 : (n : \u211d) - 1 \u2260 0 := by linarith\n          field_simp [h\u2081\u2081, h\u2081\u2082]\n          <;> ring\n          <;> field_simp [h\u2081\u2081, h\u2081\u2082]\n          <;> ring\n        rw [h\u2081\u2080]\n      have h\u2086 : \u2211 n in Finset.Icc 2 N, ((1 : \u211d) / ((n : \u211d) - 1) - (1 : \u211d) / (n : \u211d)) = 1 - 1 / (N : \u211d) := by\n        have h\u2087 : \u2200 (N : \u2115), N \u2265 2 \u2192 \u2211 n in Finset.Icc 2 N, ((1 : \u211d) / ((n : \u211d) - 1) - (1 : \u211d) / (n : \u211d)) = 1 - 1 / (N : \u211d) := by\n          intro N hN\n          induction' hN with N hN IH\n          \u00b7 norm_num [Finset.sum_Icc_succ_top]\n          \u00b7 cases N with\n            | zero => contradiction\n            | succ N =>\n              cases N with\n              | zero => contradiction\n              | succ N =>\n                simp_all [Finset.sum_Icc_succ_top, Nat.cast_add, Nat.cast_one, Nat.cast_zero]\n                <;> field_simp\n                <;> ring_nf\n                <;> field_simp\n                <;> ring_nf\n                <;> norm_num\n                <;> linarith\n        exact h\u2087 N hN\n      calc\n        (\u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2) \u2264 \u2211 n in Finset.Icc 2 N, (1 : \u211d) / ((n : \u211d) * ((n : \u211d) - 1)) := h\u2084\n        _ = \u2211 n in Finset.Icc 2 N, ((1 : \u211d) / ((n : \u211d) - 1) - (1 : \u211d) / (n : \u211d)) := by rw [h\u2085]\n        _ = 1 - 1 / (N : \u211d) := by rw [h\u2086]\n    have h\u2083 : (1 : \u211d) + \u2211 n in Finset.Icc 2 N, (1 : \u211d) / (n : \u211d)^2 \u2264 (1 : \u211d) + (1 - 1 / (N : \u211d)) := by\n      linarith\n    have h\u2084 : (1 : \u211d) + (1 - 1 / (N : \u211d)) = 2 - 1 / (N : \u211d) := by ring\n    linarith\n  \n  have h_final : \u2200 N : \u2115, N \u2265 2 \u2192 S N \u2264 2 - 1 / (N : \u211d) := by\n    intro N hN\n    have h\u2081 : S N = \u2211 n in Finset.Icc 1 N, a n := tc_2 N\n    rw [h\u2081]\n    have h\u2082 : \u2211 n in Finset.Icc 1 N, a n = \u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2 := by\n      apply Finset.sum_congr rfl\n      intro n hn\n      have h\u2083 : n \u2208 Finset.Icc 1 N := hn\n      have h\u2084 : 1 \u2264 n := by\n        simp [Finset.mem_Icc] at h\u2083\n        linarith\n      have h\u2085 : a n = 1 / (n : \u211d)^2 := tc_1 n (by exact_mod_cast h\u2084)\n      rw [h\u2085]\n      <;> norm_cast\n      <;> field_simp\n      <;> ring_nf\n    rw [h\u2082]\n    have h\u2083 : (\u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2) \u2264 2 - 1 / (N : \u211d) := h_main N hN\n    exact h\u2083\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 105, "column": 20, "endLine": 105, "endColumn": 30, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the essential mathematical content of the natural language statement. While the natural language references abstract conditions [tc_3], [l3], [def_1], [l10] and describes proof strategy, the Lean code provides the concrete mathematical definitions (tc_1: a n = 1/n\u00b2, tc_2: S N as sum) and states the same theorem conclusion. The Lean formalization contains the necessary mathematical substance to prove the stated inequality, even though it uses different condition labels and doesn't include the proof steps. The core mathematical meaning - proving S_N \u2264 2 - 1/N for N \u2265 2 - is perfectly preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem negation_of_ts_1 : \u2203 (a : \u2115 \u2192 \u211d) (S : \u2115 \u2192 \u211d), (\u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 / (n : \u211d)^2) \u2227 (\u2200 N : \u2115, S N = \u2211 n in Finset.Icc 1 N, a n) \u2227 (\u2203 N : \u2115, N \u2265 2 \u2227 S N > 2 - 1 / (N : \u211d)) := by\n  use fun n => (1 : \u211d) / (n : \u211d)^2\n  use fun N => \u2211 n in Finset.Icc 1 N, (1 : \u211d) / (n : \u211d)^2\n  constructor\n  \u00b7 intro n hn\n    simp [hn]\n    <;> norm_num\n    <;> field_simp\n    <;> ring_nf\n    <;> norm_cast\n    <;> simp_all\n  \u00b7 constructor\n    \u00b7 intro N\n      rfl\n    \u00b7 -- We need to find N \u2265 2 such that S N > 2 - 1 / N\n      -- However, for all N \u2265 1, S N \u2264 2 - 1 / N, so no such N exists\n      -- This means we cannot complete the proof and must use `sorry`\n      sorry"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l10", "label": "l10", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    