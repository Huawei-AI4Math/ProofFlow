
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \cdot a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = 2^{F_{n-1}}$ where $F_n$ is the $n$-th Fibonacci number with $F_0=0$, $F_1=1$.

Proof: This proof uses **strong mathematical induction** because the recurrence relation depends on two previous terms. First, we verify the formula for the initial terms, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1 = 2^{F_{1-1}} = 2^{F_0} = 2^0 = 1$, which matches the given value. For $n=2$, the formula gives $a_2 = 2^{F_{2-1}} = 2^{F_1} = 2^1 = 2$, which also matches. Now for the inductive step, assume the formula holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{F_{j-1}}$ is true. We must now prove that the formula holds for $n=k+1$, i.e., $a_{k+1} = 2^{F_{k}}$. Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = a_k \cdot a_{k-1}$. By our inductive assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = (2^{F_{k-1}}) \cdot (2^{F_{k-2}})$. Using the laws of exponents, we add the powers: $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$. By the definition of the Fibonacci numbers, we know that $F_{k-1} + F_{k-2} = F_k$. Thus, $a_{k+1} = 2^{F_k}$. This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$, and the recurrence relation $a_n = a_{n-1} \\cdot a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence $(a_n)$ is defined by $a_1=1$, $a_2=2$, and $a_n = a_{n-1} \\cdot a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (h1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n, n \u2265 3 \u2192 a n = a (n-1) * a (n-2))\n  (h2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n, n \u2265 2 \u2192 F n = F (n-1) + F (n-2)) :\n  \u2200 n, n \u2265 1 \u2192 a n = (2 : \u211d) ^ (F (n-1) : \u211d) := by sorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 7, "endLine": 7, "endColumn": 9, "data": "unexpected token '('; expected identifier"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "where $F_n$ is the $n$-th Fibonacci number with $F_0=0$, $F_1=1$.", "statement": "Premise:\n\u2022 The sequence $(a_n)$ is defined by $a_1=1$, $a_2=2$, and $a_n = a_{n-1} \\cdot a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 The Fibonacci sequence $(F_n)$ is defined by $F_0=0$, $F_1=1$, and the recurrence relation $F_n = F_{n-1} + F_{n-2}$ for all integers $n \\geq 2$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (F : \u2115 \u2192 \u2115)\n(tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition $a_1 = 1$ is completely missing from the Lean formalization. There is no variable or definition for sequence $(a_n)$.", "The condition $a_2 = 2$ is completely missing from the Lean formalization. There is no variable or definition for sequence $(a_n)$.", "The recurrence relation $a_n = a_{n-1} \\cdot a_{n-2}$ for $n \\geq 3$ is completely missing from the Lean formalization. There is no variable or definition for sequence $(a_n)$.", "The Lean formalization correctly captures $F_0 = 0$ as `F 0 = 0` in the conjunction.", "The Lean formalization correctly captures $F_1 = 1$ as `F 1 = 1` in the conjunction.", "The Lean formalization correctly captures the Fibonacci recurrence relation as `\u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)`.", "The conclusion about sequence $(a_n)$ being well-defined is not addressed since the sequence $(a_n)$ is not even defined in the Lean formalization.", "The conclusion about the Fibonacci sequence being well-defined is implicitly captured by declaring `F : \u2115 \u2192 \u2115`, which establishes that F is a function from non-negative integers to non-negative integers, though this is not an explicit statement of well-definedness."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition $a_1 = 1$ is completely missing from the Lean formalization. There is no variable or definition for sequence $(a_n)$.', 'The condition $a_2 = 2$ is completely missing from the Lean formalization. There is no variable or definition for sequence $(a_n)$.', 'The recurrence relation $a_n = a_{n-1} \\\\cdot a_{n-2}$ for $n \\\\geq 3$ is completely missing from the Lean formalization. There is no variable or definition for sequence $(a_n)$.', 'The Lean formalization correctly captures $F_0 = 0$ as `F 0 = 0` in the conjunction.', 'The Lean formalization correctly captures $F_1 = 1$ as `F 1 = 1` in the conjunction.', 'The Lean formalization correctly captures the Fibonacci recurrence relation as `\u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2)`.', 'The conclusion about sequence $(a_n)$ being well-defined is not addressed since the sequence $(a_n)$ is not even defined in the Lean formalization.', 'The conclusion about the Fibonacci sequence being well-defined is implicitly captured by declaring `F : \u2115 \u2192 \u2115`, which establishes that F is a function from non-negative integers to non-negative integers, though this is not an explicit statement of well-definedness.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1 = 2^{F_{1-1}} = 2^{F_0} = 2^0 = 1$, which matches the given value.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined with $a_1=1$ [tc_1].\n\u2022 The Fibonacci sequence $(F_n)$ is defined with $F_0=0$ [tc_2].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=1$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d)\n  (F : \u2115 \u2192 \u2115)\n  (h_a1 : a 1 = 1)\n  (h_F0 : F 0 = 0) :\n  a 1 = 2^(F 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d)\n  (F : \u2115 \u2192 \u2115)\n  (h_a1 : a 1 = 1)\n  (h_F0 : F 0 = 0) :\n  a 1 = 2^(F 0) := by\n  have h_pow : (2 : \u211d) ^ (F 0 : \u2115) = 1 := by\n    have h1 : (F 0 : \u2115) = 0 := by\n      norm_cast\n      <;> simp [h_F0]\n    rw [h1]\n    <;> norm_num\n  \n  have h_main : a 1 = (2 : \u211d) ^ (F 0 : \u2115) := by\n    rw [h_a1]\n    <;>\n    (try norm_num at h_pow \u22a2) <;>\n    (try simp_all [h_F0]) <;>\n    (try norm_cast at h_pow \u22a2) <;>\n    (try simp_all [h_F0]) <;>\n    (try linarith) <;>\n    (try ring_nf at h_pow \u22a2) <;>\n    (try simp_all [h_F0]) <;>\n    (try nlinarith)\n    <;>\n    (try\n      {\n        simp_all [h_F0]\n        <;> norm_num\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h_F0]\n        <;> norm_num at *\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [h_F0]\n        <;> norm_num\n        <;> linarith\n      })\n  \n  -- We need to show that a 1 = 2^(F 0). We already have a 1 = (2 : \u211d)^(F 0 : \u2115) from h_main.\n  -- Now we need to connect (2 : \u211d)^(F 0 : \u2115) with 2^(F 0).\n  -- In Lean, 2^(F 0) is interpreted as (2 : \u211d)^(F 0 : \u2115) because a 1 is a real number.\n  -- Therefore, we can directly use h_main to conclude the proof.\n  norm_num at h_main \u22a2\n  <;>\n  (try simp_all [h_F0]) <;>\n  (try norm_cast at h_pow \u22a2) <;>\n  (try simp_all [h_F0]) <;>\n  (try linarith) <;>\n  (try ring_nf at h_pow \u22a2) <;>\n  (try simp_all [h_F0]) <;>\n  (try nlinarith)\n  <;>\n  (try\n    {\n      simp_all [h_F0]\n      <;> norm_num\n      <;> linarith\n    })\n  <;>\n  (try\n    {\n      simp_all [h_F0]\n      <;> norm_num at *\n      <;> linarith\n    })\n  <;>\n  (try\n    {\n      simp_all [h_F0]\n      <;> norm_num\n      <;> linarith\n    })\n  <;>\n  (try\n    {\n      norm_num [h_F0] at *\n      <;> simp_all [h_F0]\n      <;> norm_num\n      <;> linarith\n    })\n  <;>\n  (try\n    {\n      norm_cast at *\n      <;> simp_all [h_F0]\n      <;> norm_num\n      <;> linarith\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components from the natural language. The sequences a and F are properly defined with their initial conditions (a 1 = 1 and F 0 = 0). The conclusion that the formula a_n = 2^(F_{n-1}) holds for n=1 is correctly translated to the goal a 1 = 2^(F 0), which is the proper substitution of n=1 into the general formula. The mathematical relationship is preserved and the formalization is logically consistent with the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, the formula gives $a_2 = 2^{F_{2-1}} = 2^{F_1} = 2^1 = 2$, which also matches.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined with $a_2=2$ [tc_1].\n\u2022 The Fibonacci sequence $(F_n)$ is defined with $F_1=1$ [tc_2].\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=1$ [l1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for $n=2$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u211d)\n  (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 2 = 2)\n  (tc_2 : F 1 = 1)\n  (l1 : a 1 = 2^(F 0)) :\n  a 2 = 2^(F 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u211d)\n  (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 2 = 2)\n  (tc_2 : F 1 = 1)\n  (l1 : a 1 = 2^(F 0)) :\n  a 2 = 2^(F 1) := by\n  have h_main : (2 : \u211d) ^ (F 1 : \u2115) = (2 : \u211d) := by\n    have h\u2081 : (F 1 : \u2115) = 1 := by\n      norm_cast\n      <;> simp [tc_2]\n    rw [h\u2081]\n    <;> norm_num\n    <;> simp [pow_one]\n    <;> norm_num\n  \n  have h_final : a 2 = (2 : \u211d) ^ (F 1 : \u2115) := by\n    have h\u2082 : a 2 = (2 : \u211d) := by\n      norm_num [tc_1]\n    rw [h\u2082]\n    have h\u2083 : (2 : \u211d) ^ (F 1 : \u2115) = (2 : \u211d) := h_main\n    linarith\n  \n  have h\u2083 : a 2 = (2 : \u211d) ^ (F 1 : \u2115) := h_final\n  -- Since the exponentiation in the goal is coerced to real numbers, we can directly use h_final\n  norm_cast at h\u2083 \u22a2\n  <;> simp_all [pow_one]\n  <;> norm_num\n  <;> linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definitions and initial conditions are correctly formalized with appropriate types and values.", "The given formula condition for n=1 is accurately translated to Lean syntax.", "The conclusion for n=2 is properly formalized as the goal to prove.", "While the proof structure is logically sound, the assumption l1 is not needed to prove the goal - the conclusion follows directly from tc_1 and tc_2 since 2 = 2^1.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "assume the formula holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{F_{j-1}}$ is true.", "statement": "Definition:\n\u2022 For a fixed integer $k \\geq 2$, assume that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{F_{j-1}}$ holds. This is the strong induction hypothesis [def_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n(tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n(tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n(l1 : a 1 = 2^(F 0))\n(l2 : a 2 = 2^(F 1))\n\ntheorem def_1\n  (k : \u2115) (hk : k \u2265 2)\n  (h_strong : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1))) :\n  a (k + 1) = 2^(F k) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states 'k is a fixed integer' while Lean uses 'k : \u2115' (natural number). Natural numbers are a subset of integers, so this is a minor type difference that doesn't affect the mathematical meaning since k \u2265 2.", "The Lean formalization perfectly captures the condition that for all j with 1 \u2264 j \u2264 k, the formula a_j = 2^(F_{j-1}) holds.", "The natural language describes this as establishing a 'strong induction hypothesis' (a definition/assumption), but the Lean code presents it as a theorem with a conclusion 'a (k + 1) = 2^(F k)' that needs to be proved. The natural language is defining an assumption, while Lean is stating a theorem to prove."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states 'k is a fixed integer' while Lean uses 'k : \u2115' (natural number). Natural numbers are a subset of integers, so this is a minor type difference that doesn't affect the mathematical meaning since k \u2265 2.\", 'The Lean formalization perfectly captures the condition that for all j with 1 \u2264 j \u2264 k, the formula a_j = 2^(F_{j-1}) holds.', \"The natural language describes this as establishing a 'strong induction hypothesis' (a definition/assumption), but the Lean code presents it as a theorem with a conclusion 'a (k + 1) = 2^(F k)' that needs to be proved. The natural language is defining an assumption, while Lean is stating a theorem to prove.\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = a_k \\cdot a_{k-1}$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined by the recurrence $a_n = a_{n-1} \\cdot a_{n-2}$ for $n \\geq 3$ [tc_1].\n\u2022 For a fixed integer $k \\geq 2$, we are proving the inductive step [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = a_k \\cdot a_{k-1}$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (l1 : a 1 = 2^(F 0))\n  (l2 : a 2 = 2^(F 1))\n  (h_strong : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1))) :\n  a (k + 1) = a k * a (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (l1 : a 1 = 2^(F 0))\n  (l2 : a 2 = 2^(F 1))\n  (h_strong : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1))) :\n  a (k + 1) = a k * a (k - 1) := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : k + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h_recurrence : a (k + 1) = a ((k + 1) - 1) * a ((k + 1) - 2) := by\n    have h\u2082 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2) := tc_1.2.2\n    have h\u2083 : a (k + 1) = a ((k + 1) - 1) * a ((k + 1) - 2) := by\n      have h\u2084 : (k + 1 : \u2115) \u2265 3 := h_k_plus_1_ge_3\n      have h\u2085 : a (k + 1) = a ((k + 1) - 1) * a ((k + 1) - 2) := h\u2082 (k + 1) h\u2084\n      exact h\u2085\n    exact h\u2083\n  \n  have h_sub_1 : (k + 1) - 1 = k := by\n    have h\u2081 : (k + 1) - 1 = k := by\n      have h\u2082 : k + 1 \u2265 1 := by linarith\n      omega\n    exact h\u2081\n  \n  have h_sub_2 : (k + 1) - 2 = k - 1 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : (k + 1) - 2 = k - 1 := by\n      have h\u2083 : k + 1 \u2265 3 := by omega\n      have h\u2084 : (k + 1) - 2 = k - 1 := by\n        have h\u2085 : k \u2265 2 := hk\n        have h\u2086 : (k + 1) - 2 = k - 1 := by\n          omega\n        exact h\u2086\n      exact h\u2084\n    exact h\u2082\n  \n  have h_main : a (k + 1) = a k * a (k - 1) := by\n    have h\u2081 : a (k + 1) = a ((k + 1) - 1) * a ((k + 1) - 2) := h_recurrence\n    rw [h\u2081]\n    have h\u2082 : (k + 1) - 1 = k := h_sub_1\n    have h\u2083 : (k + 1) - 2 = k - 1 := h_sub_2\n    rw [h\u2082, h\u2083]\n    <;>\n    simp_all [Nat.add_assoc]\n    <;>\n    ring_nf at *\n    <;>\n    norm_num at *\n    <;>\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The recurrence relation a_n = a_{n-1} * a_{n-2} for n \u2265 3 is correctly captured in the tc_1 condition.", "The constraint k \u2265 2 is properly formalized, with k as a natural number which is appropriate for sequence indexing.", "The conclusion a_{k+1} = a_k * a_{k-1} is exactly represented. The additional mathematical context (initial conditions, Fibonacci sequence, inductive hypothesis) provides extra structure that enhances rather than contradicts the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By our inductive assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = (2^{F_{k-1}}) \\cdot (2^{F_{k-2}})$.", "statement": "We assume:\n\u2022 For a fixed integer $k \\geq 2$, assume that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{F_{j-1}}$ holds [def_1].\n\u2022 $a_{k+1} = a_k \\cdot a_{k-1}$ [l3].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_{k-1}} \\cdot 2^{F_{k-2}}$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (h_strong : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1)))\n  (h_rec : a (k + 1) = a k * a (k - 1)) :\n  a (k + 1) = 2^(F (k - 1)) * 2^(F (k - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (h_strong : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1)))\n  (h_rec : a (k + 1) = a k * a (k - 1)) :\n  a (k + 1) = 2^(F (k - 1)) * 2^(F (k - 2)) := by\n  have h_a_k : a k = (2 : \u211d) ^ (F (k - 1)) := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2082 : a k = (2 : \u211d) ^ (F (k - 1)) := by\n      have h\u2083 := h_strong k h\u2081\n      norm_cast at h\u2083 \u22a2\n      <;> simp_all [pow_mul]\n      <;>\n      (try ring_nf at * <;> simp_all)\n      <;>\n      (try norm_num at * <;> simp_all)\n      <;>\n      (try linarith)\n    exact h\u2082\n  \n  have h_a_k_sub_1 : a (k - 1) = (2 : \u211d) ^ (F (k - 2)) := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2084 : k \u2265 2 := hk\n        have h\u2085 : (k : \u2115) - 1 \u2265 1 := by\n          have h\u2086 : k \u2265 2 := hk\n          omega\n        omega\n      have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n        have h\u2085 : k \u2265 2 := hk\n        have h\u2086 : (k : \u2115) - 1 \u2264 k := by\n          omega\n        omega\n      exact \u27e8h\u2083, h\u2084\u27e9\n    have h\u2082 : a (k - 1) = (2 : \u211d) ^ (F ((k - 1 : \u2115) - 1)) := by\n      have h\u2083 := h_strong (k - 1) h\u2081\n      norm_cast at h\u2083 \u22a2\n      <;> simp_all [pow_mul]\n      <;>\n      (try ring_nf at * <;> simp_all)\n      <;>\n      (try norm_num at * <;> simp_all)\n      <;>\n      (try linarith)\n    have h\u2083 : (F ((k - 1 : \u2115) - 1) : \u2115) = F (k - 2) := by\n      have h\u2084 : (k - 1 : \u2115) - 1 = k - 2 := by\n        have h\u2085 : k \u2265 2 := hk\n        have h\u2086 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2085\n        have h\u2087 : (k - 1 : \u2115) \u2265 1 := by omega\n        have h\u2088 : (k - 1 : \u2115) - 1 = k - 2 := by\n          cases k with\n          | zero => omega\n          | succ k' =>\n            cases k' with\n            | zero => omega\n            | succ k'' =>\n              simp [Nat.succ_eq_add_one, Nat.add_assoc] at h\u2086 \u22a2\n              <;> ring_nf at *\n              <;> omega\n        exact h\u2088\n      rw [h\u2084]\n      <;> simp [Nat.cast_sub]\n      <;>\n      (try omega)\n    have h\u2084 : a (k - 1) = (2 : \u211d) ^ (F (k - 2)) := by\n      rw [h\u2082]\n      <;> norm_cast at *\n      <;> simp_all [h\u2083]\n      <;>\n      (try ring_nf at * <;> simp_all)\n      <;>\n      (try norm_num at * <;> simp_all)\n      <;>\n      (try linarith)\n    exact h\u2084\n  \n  have h_main : a (k + 1) = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by\n    calc\n      a (k + 1) = a k * a (k - 1) := by rw [h_rec]\n      _ = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by\n        rw [h_a_k, h_a_k_sub_1]\n        <;>\n        (try ring_nf)\n        <;>\n        (try norm_num)\n        <;>\n        (try simp_all)\n        <;>\n        (try linarith)\n  \n  have h_final : a (k + 1) = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by\n    exact h_main\n  \n  have h_cast : (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by rfl\n  \n  calc\n    a (k + 1) = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by rw [h_final]\n    _ = (2 : \u211d) ^ (F (k - 1)) * (2 : \u211d) ^ (F (k - 2)) := by rfl\n    _ = 2 ^ (F (k - 1)) * 2 ^ (F (k - 2)) := by\n      norm_cast\n      <;>\n      simp [pow_mul]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_ofNat]\n      <;>\n      linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.83, "semantic_feedback": ["The natural language specifies 'integer k' but Lean uses 'k : \u2115'. Since k \u2265 2, this is semantically equivalent but represents a minor notational difference.", "The universal quantification and formula are correctly captured with identical logical meaning.", "The recurrence relation is perfectly translated with exact semantic correspondence.", "The conclusion statement matches exactly in mathematical meaning.", "The additional context (tc_1, tc_2) provides necessary mathematical definitions that are logically consistent with the natural language, even though not explicitly stated.", "Type declarations are appropriate and consistent with the mathematical context, providing necessary formalization details."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Using the laws of exponents, we add the powers: $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$.", "statement": "We assume:\n\u2022 $a_{k+1} = 2^{F_{k-1}} \\cdot 2^{F_{k-2}}$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115) (k : \u2115)\n  (hk : k \u2265 2)\n  (l4 : a (k + 1) = 2^(F (k - 1)) * 2^(F (k - 2))) :\n  a (k + 1) = 2^(F (k - 1) + F (k - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115) (k : \u2115)\n  (hk : k \u2265 2)\n  (l4 : a (k + 1) = 2^(F (k - 1)) * 2^(F (k - 2))) :\n  a (k + 1) = 2^(F (k - 1) + F (k - 2)) := by\n  have h_pow : (2 : \u211d)^(F (k - 1)) * (2 : \u211d)^(F (k - 2)) = (2 : \u211d)^(F (k - 1) + F (k - 2)) := by\n    have h1 : (2 : \u211d)^(F (k - 1) + F (k - 2)) = (2 : \u211d)^(F (k - 1)) * (2 : \u211d)^(F (k - 2)) := by\n      rw [pow_add]\n      <;> norm_cast\n    -- Use the symmetric property of equality to get the desired form\n    linarith\n  \n  have h_main : a (k + 1) = (2 : \u211d)^(F (k - 1) + F (k - 2)) := by\n    have h1 : a (k + 1) = (2 : \u211d)^(F (k - 1)) * (2 : \u211d)^(F (k - 2)) := by\n      simpa using l4\n    rw [h1]\n    rw [h_pow]\n    <;> norm_cast\n  \n  -- The final step is to use the previously established equality to conclude the proof.\n  simpa using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the mathematical content and logical structure of the natural language. The assumption l4 is correctly represented as a hypothesis, the conclusion l5 is the theorem goal, and the logical relationship ('therefore, we conclude') is captured by the theorem structure. The additional constraint (hk : k \u2265 2) and explicit type declarations are appropriate mathematical details that ensure well-definedness without contradicting the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By the definition of the Fibonacci numbers, we know that $F_{k-1} + F_{k-2} = F_k$.", "statement": "We assume:\n\u2022 The Fibonacci sequence $(F_n)$ is defined by $F_n = F_{n-1} + F_{n-2}$ for $n \\geq 2$ [tc_2].\n\u2022 We are considering an integer $k \\geq 2$ [def_1].\nTherefore, we conclude:\n\u2022 $F_{k-1} + F_{k-2} = F_k$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (F : \u2115 \u2192 \u2115)\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (k : \u2115) (hk : k \u2265 2) :\n  F (k - 1) + F (k - 2) = F k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (F : \u2115 \u2192 \u2115)\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (k : \u2115) (hk : k \u2265 2) :\n  F (k - 1) + F (k - 2) = F k := by\n  have h_recurrence : F k = F (k - 1) + F (k - 2) := by\n    have h\u2081 : \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2) := tc_2.2.2\n    have h\u2082 : F k = F (k - 1) + F (k - 2) := h\u2081 k hk\n    exact h\u2082\n  \n  have h_main : F (k - 1) + F (k - 2) = F k := by\n    rw [h_recurrence]\n    <;> simp [add_comm, add_assoc, add_left_comm]\n    <;>\n    (try omega)\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try linarith)\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the Fibonacci recurrence relation. The natural language only mentions the recurrence for n\u22652, while Lean additionally specifies the base cases F(0)=0 and F(1)=1. These are standard and necessary base cases for the Fibonacci sequence, representing logically consistent extra details that don't contradict the natural language.", "The constraint k\u22652 is properly formalized. The natural language mentions 'integer k\u22652' while Lean uses natural numbers (\u2115), but since k\u22652, this is equivalent and appropriate for the Fibonacci context where indices are typically natural numbers.", "The conclusion F_{k-1} + F_{k-2} = F_k is exactly captured in Lean as F (k - 1) + F (k - 2) = F k. The equality is semantically identical, just with different notation for function application."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Thus, $a_{k+1} = 2^{F_k}$.", "statement": "We assume:\n\u2022 $a_{k+1} = 2^{F_{k-1} + F_{k-2}}$ [l5].\n\u2022 $F_{k-1} + F_{k-2} = F_k$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{F_k}$ [l7].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l5 : a (k + 1) = 2^(F (k - 1) + F (k - 2)))\n  (l6 : F (k - 1) + F (k - 2) = F k) :\n  a (k + 1) = 2^(F k) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (k : \u2115) (hk : k \u2265 2)\n  (l5 : a (k + 1) = 2^(F (k - 1) + F (k - 2)))\n  (l6 : F (k - 1) + F (k - 2) = F k) :\n  a (k + 1) = 2^(F k) := by\n  have h_main : (2 : \u211d) ^ (F (k - 1) + F (k - 2)) = (2 : \u211d) ^ (F k) := by\n    have h\u2081 : F (k - 1) + F (k - 2) = F k := l6\n    -- Use the fact that the exponents are equal in \u2115 to show the powers are equal in \u211d\n    rw [h\u2081]\n    <;> simp [pow_add]\n    <;> norm_cast\n  \n  have h_final : a (k + 1) = (2 : \u211d) ^ (F k) := by\n    have h\u2081 : a (k + 1) = (2 : \u211d) ^ (F (k - 1) + F (k - 2)) := by\n      -- Since `a (k + 1)` is a real number, Lean automatically casts `2 : \u2115` to `2 : \u211d`\n      norm_cast at l5 \u22a2\n      <;> simpa using l5\n    -- Substitute the expression from h\u2081 and use h_main to simplify\n    rw [h\u2081]\n    rw [h_main]\n  \n  -- Use the result from h_final to conclude the proof\n  norm_cast at h_final \u22a2\n  <;> simpa using h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures the mathematical content and logical structure. The function type declarations (a : \u2115 \u2192 \u211d) and (F : \u2115 \u2192 \u2115) are appropriate translations of the sequence notation. The additional constraint k \u2265 2 is mathematically sound given the use of k-1 and k-2 indices. All three statements (l5, l6, l7) are correctly formalized, and the logical flow from assumptions to conclusion is preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, by the principle of strong mathematical induction, the formula $a_n = 2^{F_{n-1}}$ is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The formula $a_n = 2^{F_{n-1}}$ holds for the base cases $n=1$ [l1] and $n=2$ [l2].\n\u2022 For any integer $k \\geq 2$, if we assume that $a_j = 2^{F_{j-1}}$ holds for all $1 \\leq j \\leq k$ [def_1], then it follows that $a_{k+1} = 2^{F_k}$ [l7].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the formula $a_n = 2^{F_{n-1}}$ is true [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (l1 : a 1 = 2^(F 0))\n  (l2 : a 2 = 2^(F 1))\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1))) \u2192 a (k + 1) = 2^(F k))\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = a k * a (k - 1))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = 2^(F (k - 1)) * 2^(F (k - 2)))\n  (l5 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = 2^(F (k - 1) + F (k - 2)))\n  (l6 : \u2200 k : \u2115, k \u2265 2 \u2192 F (k - 1) + F (k - 2) = F k)\n  (l7 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = 2^(F k)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(F (n - 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u211d) (F : \u2115 \u2192 \u2115)\n  (tc_1 : a 1 = 1 \u2227 a 2 = 2 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n - 1) * a (n - 2))\n  (tc_2 : F 0 = 0 \u2227 F 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 2 \u2192 F n = F (n - 1) + F (n - 2))\n  (l1 : a 1 = 2^(F 0))\n  (l2 : a 2 = 2^(F 1))\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(F (j - 1))) \u2192 a (k + 1) = 2^(F k))\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = a k * a (k - 1))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = 2^(F (k - 1)) * 2^(F (k - 2)))\n  (l5 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = 2^(F (k - 1) + F (k - 2)))\n  (l6 : \u2200 k : \u2115, k \u2265 2 \u2192 F (k - 1) + F (k - 2) = F k)\n  (l7 : \u2200 k : \u2115, k \u2265 2 \u2192 a (k + 1) = 2^(F k)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(F (n - 1)) := by\n  have h_base_1 : a 1 = (2 : \u211d) ^ (F 0 : \u2115) := by\n    norm_cast at l1 \u22a2\n    <;> simpa using l1\n  \n  have h_base_2 : a 2 = (2 : \u211d) ^ (F 1 : \u2115) := by\n    norm_cast at l2 \u22a2\n    <;> simpa using l2\n  \n  have h_inductive_step : \u2200 (n : \u2115), n \u2265 3 \u2192 a n = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n    intro n hn\n    have h\u2081 : n - 1 \u2265 2 := by\n      have h\u2082 : n \u2265 3 := hn\n      omega\n    have h\u2082 : a ( (n - 1) + 1 ) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n      have h\u2083 : (n - 1 : \u2115) \u2265 2 := h\u2081\n      have h\u2084 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n        have h\u2085 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n          have h\u2086 : (n - 1 : \u2115) \u2265 2 := h\u2081\n          have h\u2087 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n            -- Use l7 to get the desired result\n            have h\u2088 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n              have h\u2089 : (n - 1 : \u2115) \u2265 2 := h\u2081\n              have h\u2081\u2080 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n                -- Use l7 with k = n - 1\n                have h\u2081\u2081 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n                  have h\u2081\u2082 : (n - 1 : \u2115) \u2265 2 := h\u2081\n                  have h\u2081\u2083 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n                    -- Use l7 with k = n - 1\n                    have h\u2081\u2084 : a ((n - 1) + 1) = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n                      norm_cast at *\n                      <;>\n                      (try omega) <;>\n                      (try simp_all [l7, pow_add, pow_one, mul_assoc]) <;>\n                      (try ring_nf at *) <;>\n                      (try norm_num at *) <;>\n                      (try linarith)\n                      <;>\n                      (try\n                        {\n                          have h\u2081\u2085 := l7 (n - 1) (by omega)\n                          norm_cast at h\u2081\u2085 \u22a2\n                          <;> simp_all [Nat.cast_add, Nat.cast_one, pow_add, pow_one, mul_assoc]\n                          <;> ring_nf at *\n                          <;> norm_num at *\n                          <;> linarith\n                        })\n                    exact h\u2081\u2084\n                  exact h\u2081\u2083\n                exact h\u2081\u2081\n              exact h\u2081\u2080\n            exact h\u2088\n          exact h\u2087\n        exact h\u2085\n      exact h\u2084\n    have h\u2083 : (n - 1 : \u2115) + 1 = n := by\n      have h\u2084 : n \u2265 3 := hn\n      have h\u2085 : n - 1 + 1 = n := by\n        have h\u2086 : n \u2265 1 := by linarith\n        omega\n      exact h\u2085\n    rw [h\u2083] at h\u2082\n    exact h\u2082\n  \n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d) ^ (F (n - 1) : \u2115) := by\n    intro n hn\n    match n with\n    | 0 =>\n      -- This case is impossible because n \u2265 1\n      exfalso\n      linarith\n    | 1 =>\n      -- Base case n = 1\n      simpa using h_base_1\n    | 2 =>\n      -- Base case n = 2\n      simpa using h_base_2\n    | k + 3 =>\n      -- Inductive step for n \u2265 3\n      have h\u2081 : (k + 3 : \u2115) \u2265 3 := by\n        omega\n      have h\u2082 : a (k + 3) = (2 : \u211d) ^ (F ((k + 3) - 1) : \u2115) := by\n        apply h_inductive_step\n        <;> omega\n      simpa [add_assoc] using h\u2082\n  \n  intro n hn\n  have h\u2081 : a n = (2 : \u211d) ^ (F (n - 1) : \u2115) := h_main n hn\n  norm_cast at h\u2081 \u22a2\n  <;> simpa using h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures all the mathematical content from the natural language correctly, including the base cases, inductive step, and final conclusion. However, there is a structural inconsistency in how the inductive proof is represented. The natural language describes a standard inductive proof where the conclusion follows from the inductive step, but the Lean formalization assumes both the inductive step validity (def_1) and its conclusion (l7) as separate premises. This creates logical redundancy and doesn't properly reflect the proof structure described in natural language, where l7 should be derived from def_1 rather than assumed independently."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization captures all the mathematical content from the natural language correctly, including the base cases, inductive step, and final conclusion. However, there is a structural inconsistency in how the inductive proof is represented. The natural language describes a standard inductive proof where the conclusion follows from the inductive step, but the Lean formalization assumes both the inductive step validity (def_1) and its conclusion (l7) as separate premises. This creates logical redundancy and doesn't properly reflect the proof structure described in natural language, where l7 should be derived from def_1 rather than assumed independently.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    