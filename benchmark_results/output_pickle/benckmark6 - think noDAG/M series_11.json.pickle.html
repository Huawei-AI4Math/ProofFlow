
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1} = \sqrt{2a_n+3}$. Prove that for all integers $n \geq 1$, the inequality $a_n < 3$ holds.

Proof: We will prove this by mathematical induction on $n$. First, for the base case $n=1$, we are given $a_1=1$. Since $1 < 3$, the inequality holds. Now, for the inductive step, we assume the statement is true for some integer $k \geq 1$, which means $a_k < 3$. We want to show that the statement is true for $k+1$, i.e., $a_{k+1} < 3$. We have the recurrence relation $a_{k+1} = \sqrt{2a_k+3}$. From the inductive hypothesis, we know that $a_k < 3$. We can multiply this inequality by 2 to get $2a_k < 6$. Adding 3 to both sides gives $2a_k+3 < 9$. Taking the square root of both sides gives $\sqrt{2a_k+3} < \sqrt{9}$. This simplifies to $a_{k+1} < 3$. Since the statement is true for $k+1$, by the principle of mathematical induction, the inequality $a_n < 3$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1} = \\sqrt{2a_n+3}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : a 1 = 1)\n(tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence as a function from natural numbers to real numbers. While the natural language mentions 'integers n \u2265 1', this is equivalent to natural numbers starting from 1 in this context.", "The initial condition a_1 = 1 is exactly captured in Lean as 'a 1 = 1'.", "The recursive formula is perfectly captured with the universal quantifier over n \u2265 1 and the exact mathematical expression using Real.sqrt.", "The well-definedness of the sequence is implicitly established in Lean through the variable declaration and the conditions provided. The Lean type system ensures the sequence exists as a function satisfying these properties."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, for the base case $n=1$, we are given $a_1=1$. Since $1 < 3$, the inequality holds.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1].\nTherefore, we conclude:\n\u2022 $a_1 < 3$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3)) : \n  a 1 < 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3)) : \n  a 1 < 3 := by\n  have h_main : a 1 < 3 := by\n    rw [h1]\n    norm_num\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition with domain \u2115 \u2192 \u211d and initial condition a 1 = 1 correctly captures the mathematical meaning of a sequence of real numbers with a\u2081 = 1.", "The recurrence relation with universal quantification over n \u2265 1 accurately formalizes the mathematical statement a\u2099\u208a\u2081 = \u221a(2a\u2099 + 3), including the appropriate domain restriction.", "The conclusion a 1 < 3 is a direct and exact translation of the natural language statement a\u2081 < 3."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now, for the inductive step, we assume the statement is true for some integer $k \\geq 1$, which means $a_k < 3$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 $a_1 < 3$ [l1].\nDefinition:\n\u2022 For an integer $k \\geq 1$, we assume $a_k < 3$ [def_1].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1) \n  (hk_def : a k < 3) : \n  True := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization only declares a sequence of real numbers but completely omits the recursive definition with a_1=1 and a_{n+1} = \u221a(2a_n+3), which is a crucial part of the mathematical setup", "The Lean formalization completely omits the condition a_1 < 3, which is explicitly stated in the natural language", "The Lean formalization correctly captures that k \u2265 1 and a_k < 3 for an integer k \u2265 1", "The natural language states this is purely setup with no conclusions, but the Lean theorem proves 'True' which, while trivial, represents a different logical structure than pure assumption setup"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization only declares a sequence of real numbers but completely omits the recursive definition with a_1=1 and a_{n+1} = \u221a(2a_n+3), which is a crucial part of the mathematical setup', 'The Lean formalization completely omits the condition a_1 < 3, which is explicitly stated in the natural language', 'The Lean formalization correctly captures that k \u2265 1 and a_k < 3 for an integer k \u2265 1', \"The natural language states this is purely setup with no conclusions, but the Lean theorem proves 'True' which, while trivial, represents a different logical structure than pure assumption setup\"]"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "We have the recurrence relation $a_{k+1} = \\sqrt{2a_k+3}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 $a_1 < 3$ [l1];\n\u2022 For an integer $k \\geq 1$, we assume $a_k < 3$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = \\sqrt{2a_k+3}$ [l2].", "dependencies": ["tc_1", "l1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1) \n  (hk_def : a k < 3) \n  (tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3)) :\n  a (k + 1) = Real.sqrt (2 * a k + 3) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1) \n  (hk_def : a k < 3) \n  (tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3)) :\n  a (k + 1) = Real.sqrt (2 * a k + 3) := by\n  have h_main : a (k + 1) = Real.sqrt (2 * a k + 3) := by\n    have h\u2081 : a (k + 1) = Real.sqrt (2 * a k + 3) := by\n      have h\u2082 : k \u2265 1 := hk\n      have h\u2083 : a (k + 1) = Real.sqrt (2 * a k + 3) := tc_2 k h\u2082\n      exact h\u2083\n    exact h\u2081\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the essential logical structure. The recurrence relation tc_2 directly implies the conclusion for any k \u2265 1, which matches the natural language reasoning. While some assumptions from the natural language (like a_1 = 1 and a_1 < 3) are not explicitly included, they are not necessary for proving this specific theorem. The condition a_k < 3 is included but is actually redundant for the conclusion, which follows purely from the recurrence relation. The mathematical content and logical flow are faithfully represented."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "From the inductive hypothesis, we know that $a_k < 3$. We can multiply this inequality by 2 to get $2a_k < 6$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 $a_1 < 3$ [l1];\n\u2022 For an integer $k \\geq 1$, we assume $a_k < 3$ [def_1];\n\u2022 $a_{k+1} = \\sqrt{2a_k+3}$ [l2].\nTherefore, we conclude:\n\u2022 $2a_k < 6$ [l3].", "dependencies": ["tc_1", "l1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1)\n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (h3 : a 1 < 3)\n  (h4 : a k < 3) :\n  2 * a k < 6 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1)\n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (h3 : a 1 < 3)\n  (h4 : a k < 3) :\n  2 * a k < 6 := by\n  have h_main : 2 * a k < 6 := by\n    -- Multiply both sides of the inequality `a k < 3` by 2 to get `2 * a k < 6`.\n    have h5 : 2 * a k < 2 * (3 : \u211d) := by\n      -- Use the fact that multiplying both sides of an inequality by a positive number preserves the inequality.\n      have h6 : a k < (3 : \u211d) := by exact_mod_cast h4\n      nlinarith\n    -- Simplify the right-hand side to get the final result.\n    norm_num at h5 \u22a2\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The sequence definition, initial conditions, inductive hypothesis, and conclusion are all properly represented. The formalization appropriately uses the general recurrence relation rather than restating it as a separate assumption, which is mathematically equivalent and more elegant."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Adding 3 to both sides gives $2a_k+3 < 9$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 $a_1 < 3$ [l1];\n\u2022 For an integer $k \\geq 1$, we assume $a_k < 3$ [def_1];\n\u2022 $a_{k+1} = \\sqrt{2a_k+3}$ [l2];\n\u2022 $2a_k < 6$ [l3].\nTherefore, we conclude:\n\u2022 $2a_k+3 < 9$ [l4].", "dependencies": ["tc_1", "l1", "def_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1)\n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (h3 : a k < 3) :\n  2 * a k + 3 < 9 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1)\n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (h3 : a k < 3) :\n  2 * a k + 3 < 9 := by\n  have h4 : 2 * a k + 3 < 9 := by\n    -- Use linear arithmetic to prove the inequality directly from h3\n    linarith\n  \n  -- The result follows directly from h4\n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all essential mathematical content from the natural language. While the condition 'a_1 < 3' is not explicitly included as a hypothesis, this is not problematic since it's redundant given that a_1 = 1. The intermediate steps mentioned in the natural language are logically derivable from the stated hypotheses. The sequence definition, recurrence relation, inductive setup, and conclusion are all properly formalized.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Taking the square root of both sides gives $\\sqrt{2a_k+3} < \\sqrt{9}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 $a_1 < 3$ [l1];\n\u2022 For an integer $k \\geq 1$, we assume $a_k < 3$ [def_1];\n\u2022 $a_{k+1} = \\sqrt{2a_k+3}$ [l2];\n\u2022 $2a_k < 6$ [l3];\n\u2022 $2a_k+3 < 9$ [l4].\nTherefore, we conclude:\n\u2022 $\\sqrt{2a_k+3} < \\sqrt{9}$ [l5].", "dependencies": ["tc_1", "l1", "def_1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1)\n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (h3 : a k < 3) :\n  Real.sqrt (2 * a k + 3) < 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 1)\n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (h3 : a k < 3) :\n  Real.sqrt (2 * a k + 3) < 3 := by\n  have h4 : 2 * a k + 3 < 9 := by\n    have h4\u2081 : a k < 3 := h3\n    have h4\u2082 : 2 * a k < 6 := by linarith\n    linarith\n  \n  have h_main : Real.sqrt (2 * a k + 3) < 3 := by\n    by_cases h : 2 * a k + 3 < 0\n    \u00b7 -- Case: 2 * a k + 3 < 0\n      have h\u2081 : Real.sqrt (2 * a k + 3) = 0 := by\n        rw [Real.sqrt_eq_zero_of_nonpos] <;> linarith\n      rw [h\u2081]\n      norm_num\n    \u00b7 -- Case: 2 * a k + 3 \u2265 0\n      have h\u2081 : 0 \u2264 2 * a k + 3 := by linarith\n      have h\u2082 : Real.sqrt (2 * a k + 3) < 3 := by\n        rw [Real.sqrt_lt (by linarith)] <;> norm_num at h4 \u22a2 <;> nlinarith\n      exact h\u2082\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition is correctly captured with a : \u2115 \u2192 \u211d, a 1 = 1, and the recurrence relation \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3)", "The condition a_1 < 3 is implicitly satisfied since a 1 = 1 < 3, which is mathematically equivalent", "The assumption a_k < 3 is correctly represented as h3 : a k < 3", "The relation a_{k+1} = \u221a(2a_k+3) is captured by the general recurrence relation in h2", "The intermediate step 2a_k < 6 is completely missing from the Lean formalization", "The intermediate step 2a_k+3 < 9 is completely missing from the Lean formalization", "The conclusion \u221a(2a_k+3) < \u221a9 is stated as Real.sqrt (2 * a k + 3) < 3, but this changes the logical structure since \u221a9 = 3, making it appear as a direct conclusion rather than an application of square root monotonicity", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition is correctly captured with a : \u2115 \u2192 \u211d, a 1 = 1, and the recurrence relation \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3)', 'The condition a_1 < 3 is implicitly satisfied since a 1 = 1 < 3, which is mathematically equivalent', 'The assumption a_k < 3 is correctly represented as h3 : a k < 3', 'The relation a_{k+1} = \u221a(2a_k+3) is captured by the general recurrence relation in h2', 'The intermediate step 2a_k < 6 is completely missing from the Lean formalization', 'The intermediate step 2a_k+3 < 9 is completely missing from the Lean formalization', 'The conclusion \u221a(2a_k+3) < \u221a9 is stated as Real.sqrt (2 * a k + 3) < 3, but this changes the logical structure since \u221a9 = 3, making it appear as a direct conclusion rather than an application of square root monotonicity']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "This simplifies to $a_{k+1} < 3$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 $a_1 < 3$ [l1];\n\u2022 For an integer $k \\geq 1$, we assume $a_k < 3$ [def_1];\n\u2022 $a_{k+1} = \\sqrt{2a_k+3}$ [l2];\n\u2022 $2a_k < 6$ [l3];\n\u2022 $2a_k+3 < 9$ [l4];\n\u2022 $\\sqrt{2a_k+3} < \\sqrt{9}$ [l5].\nTherefore, we conclude:\n\u2022 $a_{k+1} < 3$ [l6].", "dependencies": ["tc_1", "l1", "def_1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (hk : k \u2265 1)\n  (h3 : a k < 3) :\n  a (k + 1) < 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1)\n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (hk : k \u2265 1)\n  (h3 : a k < 3) :\n  a (k + 1) < 3 := by\n  have h4 : 2 * a k + 3 < 9 := by\n    have h4\u2081 : 2 * a k < 6 := by\n      linarith\n    linarith\n  \n  have h5 : a (k + 1) < 3 := by\n    have h5\u2081 : a (k + 1) = Real.sqrt (2 * a k + 3) := by\n      apply h2\n      <;> assumption\n    rw [h5\u2081]\n    by_cases h\u2085 : 2 * a k + 3 < 0\n    \u00b7 -- Case: 2 * a k + 3 < 0\n      have h\u2085\u2081 : Real.sqrt (2 * a k + 3) = 0 := by\n        rw [Real.sqrt_eq_zero_of_nonpos] <;> linarith\n      rw [h\u2085\u2081]\n      norm_num\n    \u00b7 -- Case: 2 * a k + 3 \u2265 0\n      have h\u2085\u2081 : 0 \u2264 2 * a k + 3 := by linarith\n      have h\u2085\u2082 : Real.sqrt (2 * a k + 3) < 3 := by\n        rw [Real.sqrt_lt (by positivity)] <;> nlinarith\n      exact h\u2085\u2082\n  \n  exact h5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition, initial condition, and recurrence relation are correctly captured in Lean with appropriate types and quantifiers.", "The condition a\u2081 < 3 is mathematically derivable from a\u2081 = 1 but is not explicitly stated as a hypothesis in the Lean formalization, though this doesn't affect the logical validity.", "The inductive hypothesis that a\u2096 < 3 for k \u2265 1 is properly represented with the correct assumptions.", "The intermediate algebraic steps (l2-l5) are omitted in Lean, which is appropriate since they represent proof steps rather than premises.", "The conclusion a_{k+1} < 3 is correctly stated as the theorem's goal.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since the statement is true for $k+1$, by the principle of mathematical induction, the inequality $a_n < 3$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined for integers $n \\geq 1$ by $a_1=1$ and $a_{n+1} = \\sqrt{2a_n+3}$ [tc_1];\n\u2022 the base case $a_1 < 3$ holds [l1];\n\u2022 for any integer $k \\geq 1$, assuming $a_k < 3$ [def_1], it follows that $a_{k+1} < 3$ [l6].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $a_n < 3$ holds [ts_1].", "dependencies": ["tc_1", "l1", "def_1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (l1 : a 1 < 3)\n  (l6 : \u2200 k : \u2115, k \u2265 1 \u2192 a k < 3 \u2192 a (k + 1) < 3) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = Real.sqrt (2 * a n + 3))\n  (l1 : a 1 < 3)\n  (l6 : \u2200 k : \u2115, k \u2265 1 \u2192 a k < 3 \u2192 a (k + 1) < 3) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < 3 := by\n  have h_main : \u2200 n : \u2115, n \u2265 1 \u2192 a n < 3 := by\n    intro n hn\n    have h : \u2200 n : \u2115, n \u2265 1 \u2192 a n < 3 := by\n      intro n hn\n      induction' hn with n hn IH\n      \u00b7 -- Base case: n = 1\n        exact l1\n      \u00b7 -- Inductive step: assume the statement holds for n, prove for n + 1\n        exact l6 n hn IH\n    exact h n hn\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition, initial condition, and recurrence relation are correctly formalized. Using \u2115 instead of integers is appropriate for sequences indexed from 1.", "The base case a\u2081 < 3 is directly and correctly translated.", "The inductive step is properly formalized with the correct logical structure: for any k \u2265 1, if a\u2096 < 3 then a\u2096\u208a\u2081 < 3.", "The conclusion correctly states that for all n \u2265 1, a\u2099 < 3, which matches the natural language statement exactly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    