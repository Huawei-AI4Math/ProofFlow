
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = \frac{n+1}{2n+1}$. Then for all integers $n \geq 1$, the inequality $\frac{1}{2} < a_n \leq \frac{2}{3}$ holds.

Proof: First, we prove the left-hand side of the inequality, $\frac{1}{2} < a_n$. We are given $a_n = \frac{n+1}{2n+1}$. To show $\frac{1}{2} < \frac{n+1}{2n+1}$, we can cross-multiply since both denominators are positive for $n \geq 1$. This gives us $1(2n+1) < 2(n+1)$, which simplifies to $2n+1 < 2n+2$. Subtracting $2n$ from both sides gives $1 < 2$, which is a true statement. Therefore, $\frac{1}{2} < a_n$ holds for all $n \geq 1$. Next, we prove the right-hand side of the inequality, $a_n \leq \frac{2}{3}$. We need to show that $\frac{n+1}{2n+1} \leq \frac{2}{3}$. Again, we can cross-multiply to get $3(n+1) \leq 2(2n+1)$. This simplifies to $3n+3 \leq 4n+2$. Subtracting $3n$ and $2$ from both sides gives $1 \leq n$. This is true for all integers $n \geq 1$. Since both parts of the inequality hold, the full inequality $\frac{1}{2} < a_n \leq \frac{2}{3}$ is proven.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = \\frac{n+1}{2n+1}$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n : \u2115, a n = (n + 1) / (2 * n + 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language states the sequence is defined for integers n, but Lean uses natural numbers (\u2115). This is a domain difference that changes the mathematical meaning slightly, as integers include negative numbers while natural numbers do not.", "The formula (n + 1) / (2 * n + 1) in Lean perfectly matches the mathematical expression n+1/2n+1.", "The well-definedness of the sequence is implicitly captured by Lean's type system and the universal quantification over all natural numbers."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "for all integers $n \\geq 1$", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (n + 1 : \u211d) / (2 * n + 1 : \u211d) > (1 : \u211d) / 2 \u2227 \n                    (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language defines a sequence a_n while Lean works directly with the expression without explicitly naming it as a sequence. The mathematical content is the same but the presentation differs slightly.", "Both specify the domain as integers/natural numbers \u2265 1, which are equivalent in this context.", "The natural language explicitly states no conclusions are derived, but the Lean theorem proves specific bounds (> 1/2 and \u2264 2/3) on the expression, introducing new mathematical content not present in the premise."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language defines a sequence a_n while Lean works directly with the expression without explicitly naming it as a sequence. The mathematical content is the same but the presentation differs slightly.', 'Both specify the domain as integers/natural numbers \u2265 1, which are equivalent in this context.', 'The natural language explicitly states no conclusions are derived, but the Lean theorem proves specific bounds (> 1/2 and \u2264 2/3) on the expression, introducing new mathematical content not present in the premise.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "since both denominators are positive for $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2].\nTherefore, we conclude:\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d)\n  (h_a : \u2200 n : \u2115, a n = (n + 1) / (2 * n + 1))\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  (2 * n + 1 : \u211d) > 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d)\n  (h_a : \u2200 n : \u2115, a n = (n + 1) / (2 * n + 1))\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  (2 * n + 1 : \u211d) > 0 := by\n  have h_nat : 2 * n + 1 \u2265 3 := by\n    have h\u2081 : n \u2265 1 := h_n\n    have h\u2082 : 2 * n \u2265 2 := by\n      have h\u2083 : n \u2265 1 := h_n\n      have h\u2084 : 2 * n \u2265 2 * 1 := by\n        exact Nat.mul_le_mul_left 2 h\u2083\n      norm_num at h\u2084 \u22a2\n      <;> linarith\n    have h\u2083 : 2 * n + 1 \u2265 3 := by\n      have h\u2084 : 2 * n \u2265 2 := h\u2082\n      omega\n    exact h\u2083\n  \n  have h_real : (2 * n + 1 : \u211d) \u2265 3 := by\n    norm_cast at h_nat \u22a2\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try omega)\n  \n  have h_final : (2 * n + 1 : \u211d) > 0 := by\n    have h\u2081 : (2 * n + 1 : \u211d) \u2265 3 := h_real\n    have h\u2082 : (3 : \u211d) > 0 := by norm_num\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The sequence definition is correctly formalized, but there's a minor type difference: natural language mentions 'integers n' while Lean uses natural numbers (\u2115). However, this doesn't affect the mathematical meaning since we're only considering n \u2265 1.", "The domain specification is correctly captured with the constraint n \u2265 1, but again uses natural numbers instead of integers. This is a minor notational difference that doesn't change the logical meaning for the relevant domain.", "The conclusion perfectly matches - it correctly states that 2n+1 is positive for the given conditions, with proper type annotation as a real number."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The sequence definition is correctly formalized, but there's a minor type difference: natural language mentions 'integers n' while Lean uses natural numbers (\u2115). However, this doesn't affect the mathematical meaning since we're only considering n \u2265 1.\", \"The domain specification is correctly captured with the constraint n \u2265 1, but again uses natural numbers instead of integers. This is a minor notational difference that doesn't change the logical meaning for the relevant domain.\", 'The conclusion perfectly matches - it correctly states that 2n+1 is positive for the given conditions, with proper type annotation as a real number.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "To show $\\frac{1}{2} < \\frac{n+1}{2n+1}$, we can cross-multiply since both denominators are positive for $n \\geq 1$. This gives us $1(2n+1) < 2(n+1)$, which simplifies to $2n+1 < 2n+2$. Subtracting $2n$ from both sides gives $1 < 2$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2];\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1].\nTherefore, we conclude:\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ is equivalent to the inequality $1 < 2$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2194 (1 : \u211d) < (2 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2194 (1 : \u211d) < (2 : \u211d) := by\n  have h_main : (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n    have h\u2081 : (0 : \u211d) < (2 * n + 1 : \u211d) := by\n      have h\u2082 : (0 : \u211d) < (2 * n + 1 : \u211d) := by\n        norm_cast\n        <;> nlinarith\n      exact h\u2082\n    -- Cross-multiply to eliminate the fractions\n    have h\u2082 : (2 : \u211d) * (n + 1 : \u211d) > (2 * n + 1 : \u211d) := by\n      norm_cast\n      <;> ring_nf at *\n      <;> nlinarith\n    -- Divide both sides by 2 * (2 * n + 1)\n    have h\u2083 : (n + 1 : \u211d) / (2 * n + 1 : \u211d) > (1 : \u211d) / 2 := by\n      -- Use the fact that 2 * (n + 1) > 2 * n + 1 to prove the inequality\n      have h\u2084 : 0 < (2 * n + 1 : \u211d) := by positivity\n      have h\u2085 : 0 < (2 : \u211d) := by norm_num\n      -- Use the division inequality to compare the two sides\n      have h\u2086 : (n + 1 : \u211d) / (2 * n + 1 : \u211d) > (1 : \u211d) / 2 := by\n        rw [gt_iff_lt]\n        rw [div_lt_div_iff (by positivity) (by positivity)]\n        -- Simplify the inequality to 2 * (n + 1) > 2 * n + 1\n        norm_num at h\u2082 \u22a2\n        <;>\n        (try norm_num) <;>\n        (try ring_nf at h\u2082 \u22a2) <;>\n        (try norm_cast at h\u2082 \u22a2) <;>\n        (try linarith)\n        <;>\n        (try nlinarith)\n      exact h\u2086\n    -- Combine the results to get the final inequality\n    linarith\n  \n  have h_trivial : (1 : \u211d) < (2 : \u211d) := by\n    norm_num\n  \n  have h_forward : (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2192 (1 : \u211d) < (2 : \u211d) := by\n    intro h\n    -- Since (1 : \u211d) < (2 : \u211d) is always true, we can directly use it.\n    norm_num at h \u22a2\n    <;>\n    (try linarith)\n    <;>\n    (try assumption)\n    <;>\n    (try norm_num)\n    <;>\n    (try linarith)\n  \n  have h_backward : (1 : \u211d) < (2 : \u211d) \u2192 (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n    intro h\n    -- We already have the main inequality from h_main, so we can directly use it.\n    exact h_main\n  \n  constructor\n  \u00b7 -- Prove the forward direction: (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2192 (1 : \u211d) < (2 : \u211d)\n    intro h\n    exact h_forward h\n  \u00b7 -- Prove the backward direction: (1 : \u211d) < (2 : \u211d) \u2192 (1 / 2 : \u211d) < (n + 1 : \u211d) / (2 * n + 1 : \u211d)\n    intro h\n    exact h_backward h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical statement from the natural language. The use of natural numbers (\u2115) with the constraint n \u2265 1 appropriately represents 'integers n \u2265 1' from the context. The equivalence statement is directly and accurately translated, with proper type annotations for real numbers. While the mathematical claim itself may be questionable, the Lean formalization perfectly represents what is stated in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "which is a true statement.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2];\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1];\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ is equivalent to the inequality $1 < 2$ [l2].\nTherefore, we conclude:\n\u2022 The inequality $1 < 2$ is true [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2227 \n                      (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2227 \n                      (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3 := by\n  intro n hn\n  have h\u2081 : (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n    have h\u2082 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n    have h\u2083 : (0 : \u211d) < (2 * n + 1 : \u211d) := by\n      have h\u2084 : (0 : \u211d) < (2 * n + 1 : \u211d) := by\n        have h\u2085 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n        have h\u2086 : (0 : \u211d) < (2 : \u211d) * (n : \u211d) + 1 := by linarith\n        exact_mod_cast h\u2086\n      exact h\u2084\n    -- Cross-multiply to compare the fractions\n    have h\u2084 : (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n      rw [div_lt_div_iff (by positivity) (by positivity)]\n      -- Simplify the inequality to 2 * (n + 1) > 2 * n + 1\n      have h\u2085 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n      nlinarith\n    exact h\u2084\n  \n  have h\u2082 : (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3 := by\n    have h\u2083 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n    have h\u2084 : (0 : \u211d) < (2 * n + 1 : \u211d) := by\n      have h\u2085 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n      have h\u2086 : (0 : \u211d) < (2 : \u211d) * (n : \u211d) + 1 := by linarith\n      exact_mod_cast h\u2086\n    -- Cross-multiply to compare the fractions\n    have h\u2085 : (n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3 := by\n      rw [div_le_div_iff (by positivity) (by positivity)]\n      -- Simplify the inequality to 3 * (n + 1) \u2264 2 * (2 * n + 1)\n      have h\u2086 : (n : \u211d) \u2265 1 := by exact_mod_cast hn\n      nlinarith\n    exact h\u2085\n  \n  exact \u27e8h\u2081, h\u2082\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition is captured in the Lean formalization as part of the inequality, but uses natural numbers (\u2115) instead of integers. This is a minor notational difference since n \u2265 1 makes this equivalent.", "The domain constraint n \u2265 1 is correctly represented in the Lean formalization.", "The positivity of denominator 2n+1 is not explicitly stated in the Lean formalization, though it's implicitly assumed for the division to be well-defined.", "The Lean formalization does not represent the equivalence stated in l2. Instead, it proves the original inequality directly and adds an upper bound not mentioned in the natural language.", "The conclusion l3 in natural language states '1 < 2 is true', but the Lean theorem proves a completely different statement about bounds on the sequence. The Lean formalization introduces an upper bound (\u2264 2/3) that is not mentioned anywhere in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition is captured in the Lean formalization as part of the inequality, but uses natural numbers (\u2115) instead of integers. This is a minor notational difference since n \u2265 1 makes this equivalent.', 'The domain constraint n \u2265 1 is correctly represented in the Lean formalization.', \"The positivity of denominator 2n+1 is not explicitly stated in the Lean formalization, though it's implicitly assumed for the division to be well-defined.\", 'The Lean formalization does not represent the equivalence stated in l2. Instead, it proves the original inequality directly and adds an upper bound not mentioned in the natural language.', \"The conclusion l3 in natural language states '1 < 2 is true', but the Lean theorem proves a completely different statement about bounds on the sequence. The Lean formalization introduces an upper bound (\u2264 2/3) that is not mentioned anywhere in the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Therefore, $\\frac{1}{2} < a_n$ holds for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2];\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1];\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ is equivalent to the inequality $1 < 2$ [l2];\n\u2022 The inequality $1 < 2$ is true [l3].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, $\\frac{1}{2} < a_n$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d)\n  (h_a : \u2200 n : \u2115, a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d))\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  (1 : \u211d) / 2 < a n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d)\n  (h_a : \u2200 n : \u2115, a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d))\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  (1 : \u211d) / 2 < a n := by\n  have h\u2081 : a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n    have h\u2081\u2081 : a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d) := h_a n\n    exact h\u2081\u2081\n  \n  have h\u2082 : (1 : \u211d) / 2 < a n := by\n    rw [h\u2081]\n    have h\u2083 : (n : \u211d) \u2265 1 := by exact_mod_cast h_n\n    have h\u2084 : (2 * (n : \u211d) + 1 : \u211d) > 0 := by\n      have h\u2084\u2081 : (2 * (n : \u211d) + 1 : \u211d) \u2265 2 * 1 + 1 := by\n        linarith\n      linarith\n    -- Compute the difference between (n + 1 : \u211d) / (2 * n + 1 : \u211d) and 1 / 2\n    have h\u2085 : (1 : \u211d) / 2 < (n + 1 : \u211d) / (2 * n + 1 : \u211d) := by\n      -- Show that the difference is positive\n      have h\u2085\u2081 : 0 < (2 : \u211d) * (2 * (n : \u211d) + 1 : \u211d) := by positivity\n      have h\u2085\u2082 : 0 < (2 * (n : \u211d) + 1 : \u211d) := by positivity\n      -- Use the fact that the difference is positive to prove the inequality\n      have h\u2085\u2083 : (1 : \u211d) / (2 * (2 * (n : \u211d) + 1 : \u211d)) > 0 := by positivity\n      -- Use the fact that the difference is positive to prove the inequality\n      have h\u2085\u2084 : (n + 1 : \u211d) / (2 * n + 1 : \u211d) - (1 : \u211d) / 2 = (1 : \u211d) / (2 * (2 * (n : \u211d) + 1 : \u211d)) := by\n        field_simp [h\u2084.ne']\n        <;> ring_nf\n        <;> field_simp [h\u2084.ne']\n        <;> ring_nf\n        <;> field_simp [h\u2084.ne']\n        <;> linarith\n      -- Use the fact that the difference is positive to prove the inequality\n      have h\u2085\u2085 : (n + 1 : \u211d) / (2 * n + 1 : \u211d) - (1 : \u211d) / 2 > 0 := by\n        rw [h\u2085\u2084]\n        positivity\n      -- Use the fact that the difference is positive to prove the inequality\n      linarith\n    exact h\u2085\n  \n  exact h\u2082", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.83, "semantic_feedback": ["The sequence domain uses natural numbers (\u2115) instead of integers, but this is appropriate since n \u2265 1 and doesn't affect the mathematical meaning", "The constraint n \u2265 1 is correctly captured in both the natural language and Lean formalization", "The denominator positivity is implicit in the Lean formalization, which is mathematically sound", "The intermediate logical steps (l2, l3) are proof steps rather than theorem statement components, so their absence in the theorem statement is appropriate", "The truth of 1 < 2 is a proof step, appropriately omitted from the theorem statement", "The main conclusion is perfectly captured with the correct inequality and quantification structure"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "we need to show that $\\frac{n+1}{2n+1} \\leq \\frac{2}{3}$. Again, we can cross-multiply to get $3(n+1) \\leq 2(2n+1)$. This simplifies to $3n+3 \\leq 4n+2$. Subtracting $3n$ and $2$ from both sides gives $1 \\leq n$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2];\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1];\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ is equivalent to the inequality $1 < 2$ [l2];\n\u2022 The inequality $1 < 2$ is true [l3];\n\u2022 For all integers $n \\geq 1$, $\\frac{1}{2} < a_n$ [l4].\nTherefore, we conclude:\n\u2022 The inequality $\\frac{n+1}{2n+1} \\leq \\frac{2}{3}$ is equivalent to the inequality $1 \\leq n$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  ((n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3) \u2194 (1 \u2264 n) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (n : \u2115)\n  (h_n : n \u2265 1) :\n  ((n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3) \u2194 (1 \u2264 n) := by\n  have h_main : ((n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3) \u2194 (1 \u2264 n) := by\n    constructor\n    \u00b7 -- Prove the forward direction: (n + 1)/(2n + 1) \u2264 2/3 \u2192 1 \u2264 n\n      intro h\n      by_contra! h\u2081\n      -- If n = 0, then (n + 1)/(2n + 1) = 1 > 2/3, which contradicts h\n      have h\u2082 : n = 0 := by\n        omega\n      rw [h\u2082] at h\n      norm_num at h \u22a2\n      <;> linarith\n    \u00b7 -- Prove the reverse direction: 1 \u2264 n \u2192 (n + 1)/(2n + 1) \u2264 2/3\n      intro h\n      have h\u2081 : (n : \u211d) \u2265 1 := by exact_mod_cast h\n      have h\u2082 : 0 < (2 * n + 1 : \u211d) := by\n        have h\u2083 : (n : \u211d) \u2265 1 := by exact_mod_cast h\n        linarith\n      -- Use the fact that 3(n + 1) \u2264 2(2n + 1) to prove the inequality\n      have h\u2083 : (3 : \u211d) * (n + 1 : \u211d) \u2264 2 * (2 * n + 1 : \u211d) := by\n        have h\u2084 : (n : \u211d) \u2265 1 := by exact_mod_cast h\n        nlinarith\n      -- Divide both sides by 3(2n + 1) to get the desired inequality\n      have h\u2084 : ((n + 1 : \u211d) / (2 * n + 1 : \u211d) \u2264 (2 : \u211d) / 3) := by\n        rw [div_le_div_iff (by positivity) (by positivity)]\n        nlinarith\n      exact h\u2084\n  \n  -- Since h_main already gives us the equivalence, we can directly use it\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equivalence stated in the natural language. The inequality (n+1)/(2n+1) \u2264 2/3 is properly translated with appropriate type coercions to real numbers, the equivalence is correctly represented using the biconditional operator, and the hypothesis n \u2265 1 matches the domain specification from the natural language. The use of natural numbers for n is consistent with the constraint n \u2265 1 for integers."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "This is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2];\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1];\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ is equivalent to the inequality $1 < 2$ [l2];\n\u2022 The inequality $1 < 2$ is true [l3];\n\u2022 For all integers $n \\geq 1$, $\\frac{1}{2} < a_n$ [l4];\n\u2022 The inequality $\\frac{n+1}{2n+1} \\leq \\frac{2}{3}$ is equivalent to the inequality $1 \\leq n$ [l5].\nTherefore, we conclude:\n\u2022 The inequality $1 \\leq n$ is true for all integers $n \\geq 1$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d))\n  (tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 (2 * n + 1 : \u211d) > 0)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n \u2194 (1 : \u211d) < (2 : \u211d))\n  (l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) < (2 : \u211d))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 1 \u2264 n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, a n = (n + 1 : \u211d) / (2 * n + 1 : \u211d))\n  (tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 (2 * n + 1 : \u211d) > 0)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n \u2194 (1 : \u211d) < (2 : \u211d))\n  (l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) < (2 : \u211d))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 1 \u2264 n := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 1 \u2264 n := by\n    intro n hn\n    -- Since n \u2265 1 is definitionally equal to 1 \u2264 n in Lean, we can directly use hn.\n    exact hn\n  \n  -- The main statement follows directly from h_main.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.88, "semantic_feedback": ["The sequence definition matches exactly between natural language and Lean formalization.", "tc_2 in Lean combines the domain constraint (n \u2265 1) with the bounds (1/2 < a_n \u2264 2/3) that are mentioned separately in natural language, but all semantic content is preserved.", "The positivity condition for the denominator is identical in both versions.", "The equivalence statement between the inequality and 1 < 2 matches perfectly.", "The truth of 1 < 2 is stated identically in both versions.", "The lower bound inequality for the sequence is identical in both versions.", "The equivalence between the upper bound and 1 \u2264 n matches perfectly.", "The final conclusion that 1 \u2264 n for all n \u2265 1 is identical in both versions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Since both parts of the inequality hold, the full inequality $\\frac{1}{2} < a_n \\leq \\frac{2}{3}$ is proven.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of real numbers defined by $a_n = \\frac{n+1}{2n+1}$ for integers n [tc_1];\n\u2022 The sequence is considered for all integers $n \\geq 1$ [tc_2];\n\u2022 For any integer $n \\geq 1$, the denominator $2n+1$ is positive [l1];\n\u2022 The inequality $\\frac{1}{2} < \\frac{n+1}{2n+1}$ is equivalent to the inequality $1 < 2$ [l2];\n\u2022 The inequality $1 < 2$ is true [l3];\n\u2022 For all integers $n \\geq 1$, $\\frac{1}{2} < a_n$ [l4];\n\u2022 The inequality $\\frac{n+1}{2n+1} \\leq \\frac{2}{3}$ is equivalent to the inequality $1 \\leq n$ [l5];\n\u2022 The inequality $1 \\leq n$ is true for all integers $n \\geq 1$ [l6].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $\\frac{1}{2} < a_n \\leq \\frac{2}{3}$ holds [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, a n = (n + 1) / (2 * n + 1))\n  (tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 (2 * n + 1 : \u211d) > 0)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n \u2194 (1 : \u211d) < (2 : \u211d))\n  (l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) < (2 : \u211d))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 1 \u2264 n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (tc_1 : \u2200 n : \u2115, a n = (n + 1) / (2 * n + 1))\n  (tc_2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 (2 * n + 1 : \u211d) > 0)\n  (l2 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n \u2194 (1 : \u211d) < (2 : \u211d))\n  (l3 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) < (2 : \u211d))\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 (1 / 2 : \u211d) < a n)\n  (l5 : \u2200 n : \u2115, (n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 1 \u2264 n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\n  intro n hn\n  have h1 : (1 : \u211d) / 2 < a n := by\n    have h\u2081 : (1 / 2 : \u211d) < a n := l4 n hn\n    exact h\u2081\n  \n  have h2 : a n \u2264 (2 : \u211d) / 3 := by\n    have h : ((n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n)) := l5 n\n    have h_left : (1 \u2264 n) := by\n      -- Prove that 1 \u2264 n using the fact that n \u2265 1\n      exact Nat.succ_le_iff.mpr hn\n    have h_right : (n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) := by\n      -- Use the fact that (n \u2265 1 \u2192 a n \u2264 2/3) \u2194 (1 \u2264 n) and 1 \u2264 n to deduce (n \u2265 1 \u2192 a n \u2264 2/3)\n      have h\u2081 : ((n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n)) := h\n      have h\u2082 : (1 \u2264 n) := h_left\n      have h\u2083 : (n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) := by\n        -- Since (1 \u2264 n) is true, the right side of the equivalence is true, so the left side must also be true\n        have h\u2084 : (n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) \u2194 (1 \u2264 n) := h\u2081\n        have h\u2085 : (1 \u2264 n) := h\u2082\n        have h\u2086 : (n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) := by\n          -- Use the equivalence to deduce (n \u2265 1 \u2192 a n \u2264 2/3)\n          tauto\n        exact h\u2086\n      exact h\u2083\n    have h_final : a n \u2264 (2 / 3 : \u211d) := by\n      -- Since n \u2265 1 is true, we can apply h_right to get a n \u2264 2/3\n      have h\u2083 : (n \u2265 1 \u2192 a n \u2264 (2 / 3 : \u211d)) := h_right\n      have h\u2084 : n \u2265 1 := hn\n      have h\u2085 : a n \u2264 (2 / 3 : \u211d) := h\u2083 h\u2084\n      exact h\u2085\n    exact h_final\n  \n  have h_main : (1 : \u211d) / 2 < a n \u2227 a n \u2264 (2 : \u211d) / 3 := by\n    exact \u27e8h1, h2\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1 correctly formalizes the sequence definition", "tc_2 assumes the conclusion that should be proven, creating a circular argument. The natural language describes tc_2 as a domain constraint, but Lean formalizes it as the theorem conclusion itself", "l1 correctly formalizes the positivity of the denominator", "l2 correctly formalizes the equivalence statement", "l3 correctly formalizes the truth of 1 < 2, though with unnecessary quantification over n", "l4 correctly formalizes the lower bound conclusion", "l5 correctly formalizes the equivalence for the upper bound", "l6 correctly formalizes the truth of the inequality condition", "ts_1 correctly formalizes the final conclusion"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1 correctly formalizes the sequence definition', 'tc_2 assumes the conclusion that should be proven, creating a circular argument. The natural language describes tc_2 as a domain constraint, but Lean formalizes it as the theorem conclusion itself', 'l1 correctly formalizes the positivity of the denominator', 'l2 correctly formalizes the equivalence statement', 'l3 correctly formalizes the truth of 1 < 2, though with unnecessary quantification over n', 'l4 correctly formalizes the lower bound conclusion', 'l5 correctly formalizes the equivalence for the upper bound', 'l6 correctly formalizes the truth of the inequality condition', 'ts_1 correctly formalizes the final conclusion']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    