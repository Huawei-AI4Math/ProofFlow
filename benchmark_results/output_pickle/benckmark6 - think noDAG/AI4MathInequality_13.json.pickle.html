
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for any positive real numbers $a_1, a_2, \\ldots, a_n$, the following inequality holds:
$$ \\sum_{k=1}^{n} k a_{k} \\leq \\binom{n}{2} + \\sum_{k=1}^{n} a_{k}^{k} $$

Proof: For each positive integer $k$ and positive real number $a_k$, we apply the arithmetic meanâ€“geometric mean inequality to the numbers $a_k^k$ and $k-1$ copies of 1. This gives $$a_k^k + (k-1) \ge k a_k$$. This inequality holds for every $k = 1, 2, \dots, n$. Summing these inequalities over all $k$, we obtain $$\sum_{k=1}^{n} ig(a_k^k + (k-1)ig) \ge \sum_{k=1}^{n} k a_k$$.The sum of the integers $0, 1, \dots, n-1$ is $inom{n}{2}$, so we can write $$\sum_{k=1}^{n} a_k^k + inom{n}{2} \ge \sum_{k=1}^{n} k a_k$$. Rewriting this inequality gives the desired result: $$\sum_{k=1}^{n} k a_k \le inom{n}{2} + \sum_{k=1}^{n} a_k^k$$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "For any positive real numbers $a_1, a_2, \\ldots, a_n$, the following inequality holds", "statement": "Premise:\n\u2022 $a_1, a_2, \\ldots, a_n$ is a sequence of positive real numbers indexed from 1 to n [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\nvariable (tc_1 : \u2200 n, 0 < a n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language describes a finite sequence indexed from 1 to n, while Lean defines an infinite function from all natural numbers to reals. However, this is a common and acceptable formalization approach in Lean where we can later restrict to the relevant indices when needed.", "The positivity condition is perfectly captured - both state that all elements/values are positive real numbers."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The natural language describes a finite sequence indexed from 1 to n, while Lean defines an infinite function from all natural numbers to reals. However, this is a common and acceptable formalization approach in Lean where we can later restrict to the relevant indices when needed.', 'The positivity condition is perfectly captured - both state that all elements/values are positive real numbers.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For each positive integer $k$ and positive real number $a_k$, we apply the arithmetic mean\u2013geometric mean inequality to the numbers $a_k^k$ and $k-1$ copies of 1. This gives $$a_k^k + (k-1) \\ge k a_k$$.", "statement": "We assume:\n\u2022 $a_1, a_2, \\ldots, a_n$ is a sequence of positive real numbers indexed from 1 to n [tc_1].\nTherefore, we conclude:\n\u2022 For any integer $k \\in \\{1, 2, \\ldots, n\\}$, the inequality $a_k^k + (k-1) \\ge k a_k$ holds [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (n : \u2115) (a : \u2115 \u2192 \u211d) (hn : 0 < n) (tc_1 : \u2200 n, 0 < a n) :\n  \u2200 k : \u2115, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (n : \u2115) (a : \u2115 \u2192 \u211d) (hn : 0 < n) (tc_1 : \u2200 n, 0 < a n) :\n  \u2200 k : \u2115, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k := by\n  have h_main : \u2200 (x : \u211d) (k : \u2115), x > 0 \u2192 1 \u2264 k \u2192 x ^ k + (k - 1 : \u211d) \u2265 k * x := by\n    intro x k hx hk\n    have h\u2081 : x ^ k - 1 \u2265 (k : \u211d) * (x - 1) := by\n      have h\u2082 : x ^ k - 1 = (x - 1) * (\u2211 i in Finset.range k, x ^ i) := by\n        have h\u2083 : \u2211 i in Finset.range k, x ^ i = \u2211 i in Finset.range k, x ^ i := rfl\n        calc\n          x ^ k - 1 = (x - 1) * (\u2211 i in Finset.range k, x ^ i) := by\n            have h\u2084 : (x - 1) * (\u2211 i in Finset.range k, x ^ i) = x ^ k - 1 := by\n              calc\n                (x - 1) * (\u2211 i in Finset.range k, x ^ i) = (x - 1) * (\u2211 i in Finset.range k, x ^ i) := rfl\n                _ = (\u2211 i in Finset.range k, (x - 1) * x ^ i) := by\n                  rw [Finset.mul_sum]\n                  <;> simp [mul_sub, mul_comm]\n                _ = (\u2211 i in Finset.range k, (x ^ (i + 1) - x ^ i)) := by\n                  apply Finset.sum_congr rfl\n                  intro i _\n                  ring_nf\n                  <;> simp [pow_succ, mul_comm]\n                  <;> ring_nf\n                _ = x ^ k - 1 := by\n                  have h\u2085 : (\u2211 i in Finset.range k, (x ^ (i + 1) - x ^ i)) = x ^ k - 1 := by\n                    have h\u2086 : \u2200 n : \u2115, (\u2211 i in Finset.range n, (x ^ (i + 1) - x ^ i)) = x ^ n - 1 := by\n                      intro n\n                      induction n with\n                      | zero =>\n                        simp\n                      | succ n ih =>\n                        rw [Finset.sum_range_succ, ih]\n                        simp [pow_succ]\n                        <;> ring_nf\n                        <;> linarith\n                    exact h\u2086 k\n                  rw [h\u2085]\n            linarith\n          _ = (x - 1) * (\u2211 i in Finset.range k, x ^ i) := by rfl\n      rw [h\u2082]\n      have h\u2083 : (k : \u211d) \u2265 1 := by exact_mod_cast hk\n      by_cases h\u2084 : x \u2265 1\n      \u00b7 -- Case: x \u2265 1\n        have h\u2085 : (x - 1 : \u211d) \u2265 0 := by linarith\n        have h\u2086 : (\u2211 i in Finset.range k, x ^ i : \u211d) \u2265 k := by\n          have h\u2087 : \u2200 i \u2208 Finset.range k, (x : \u211d) ^ i \u2265 1 := by\n            intro i hi\n            have h\u2088 : i < k := Finset.mem_range.mp hi\n            have h\u2089 : (x : \u211d) \u2265 1 := by exact_mod_cast h\u2084\n            have h\u2081\u2080 : (x : \u211d) ^ i \u2265 1 := by\n              calc\n                (x : \u211d) ^ i \u2265 (1 : \u211d) ^ i := by gcongr <;> linarith\n                _ = 1 := by simp\n            exact h\u2081\u2080\n          calc\n            (\u2211 i in Finset.range k, x ^ i : \u211d) \u2265 \u2211 i in Finset.range k, (1 : \u211d) := Finset.sum_le_sum h\u2087\n            _ = (k : \u211d) := by\n              simp [Finset.sum_const]\n              <;> ring_nf\n              <;> field_simp\n              <;> linarith\n        have h\u2087 : (x - 1 : \u211d) * (\u2211 i in Finset.range k, x ^ i : \u211d) \u2265 (x - 1 : \u211d) * (k : \u211d) := by\n          exact mul_le_mul_of_nonneg_left h\u2086 h\u2085\n        linarith\n      \u00b7 -- Case: x < 1\n        have h\u2085 : (x - 1 : \u211d) < 0 := by linarith\n        have h\u2086 : (\u2211 i in Finset.range k, x ^ i : \u211d) \u2264 k := by\n          have h\u2087 : \u2200 i \u2208 Finset.range k, (x : \u211d) ^ i \u2264 1 := by\n            intro i hi\n            have h\u2088 : i < k := Finset.mem_range.mp hi\n            have h\u2089 : (x : \u211d) > 0 := by exact_mod_cast hx\n            have h\u2081\u2080 : (x : \u211d) < 1 := by linarith\n            have h\u2081\u2081 : (x : \u211d) ^ i \u2264 1 := by\n              calc\n                (x : \u211d) ^ i \u2264 (1 : \u211d) ^ i := by gcongr <;> linarith\n                _ = 1 := by simp\n            exact h\u2081\u2081\n          calc\n            (\u2211 i in Finset.range k, x ^ i : \u211d) \u2264 \u2211 i in Finset.range k, (1 : \u211d) := Finset.sum_le_sum h\u2087\n            _ = (k : \u211d) := by\n              simp [Finset.sum_const]\n              <;> ring_nf\n              <;> field_simp\n              <;> linarith\n        have h\u2087 : (x - 1 : \u211d) * (\u2211 i in Finset.range k, x ^ i : \u211d) \u2265 (x - 1 : \u211d) * (k : \u211d) := by\n          have h\u2088 : (x - 1 : \u211d) < 0 := by linarith\n          nlinarith\n        linarith\n    have h\u2082 : x ^ k + (k - 1 : \u211d) \u2265 k * x := by\n      have h\u2083 : x ^ k - 1 \u2265 (k : \u211d) * (x - 1) := h\u2081\n      have h\u2084 : x ^ k + (k - 1 : \u211d) \u2265 k * x := by\n        have h\u2085 : (k : \u211d) \u2265 1 := by exact_mod_cast hk\n        have h\u2086 : x ^ k - 1 \u2265 (k : \u211d) * (x - 1) := h\u2083\n        have h\u2087 : x ^ k + (k - 1 : \u211d) \u2265 k * x := by\n          linarith\n        exact h\u2087\n      exact h\u2084\n    exact h\u2082\n  \n  have h_final : \u2200 k : \u2115, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k := by\n    intro k hk1 hk2\n    have h\u2081 : (a k : \u211d) > 0 := by exact_mod_cast tc_1 k\n    have h\u2082 : (a k : \u211d) ^ k + (k - 1 : \u211d) \u2265 (k : \u211d) * (a k : \u211d) := by\n      have h\u2083 : (a k : \u211d) > 0 := by exact_mod_cast tc_1 k\n      have h\u2084 : 1 \u2264 (k : \u2115) := hk1\n      have h\u2085 : (a k : \u211d) ^ k + (k - 1 : \u211d) \u2265 (k : \u211d) * (a k : \u211d) := by\n        -- Use the main lemma to prove the inequality for a_k\n        have h\u2086 : (a k : \u211d) ^ k + (k - 1 : \u211d) \u2265 (k : \u211d) * (a k : \u211d) := by\n          have h\u2087 : (a k : \u211d) > 0 := by exact_mod_cast tc_1 k\n          have h\u2088 : 1 \u2264 (k : \u2115) := hk1\n          have h\u2089 : (a k : \u211d) ^ k + (k - 1 : \u211d) \u2265 (k : \u211d) * (a k : \u211d) := by\n            -- Use the main lemma to prove the inequality for a_k\n            exact h_main (a k) k (by exact_mod_cast tc_1 k) (by exact_mod_cast hk1)\n          exact h\u2089\n        exact h\u2086\n      exact h\u2085\n    -- Cast the result back to the required form\n    have h\u2083 : (a k : \u211d) ^ k + (k - 1 : \u211d) \u2265 (k : \u211d) * (a k : \u211d) := h\u2082\n    norm_cast at h\u2083 \u22a2\n    <;>\n    (try norm_num at h\u2083 \u22a2) <;>\n    (try linarith) <;>\n    (try simp_all [Nat.cast_le]) <;>\n    (try nlinarith) <;>\n    (try ring_nf at h\u2083 \u22a2) <;>\n    (try linarith)\n    <;>\n    (try\n      {\n        simp_all [Nat.cast_le]\n        <;>\n        nlinarith\n      })\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language describes a finite sequence indexed from 1 to n, while Lean defines a function over all natural numbers. However, the effective domain is correctly constrained through the theorem conditions.", "The index range is correctly captured. Using natural numbers instead of integers is appropriate since the range {1,2,...,n} consists of positive integers.", "The inequality is perfectly translated with only notational differences (type annotations and explicit multiplication operator).", "There is variable shadowing in 'tc_1 : \u2200 n, 0 < a n' where 'n' conflicts with the parameter name, but the logical meaning (all sequence values are positive) is preserved."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The natural language describes a finite sequence indexed from 1 to n, while Lean defines a function over all natural numbers. However, the effective domain is correctly constrained through the theorem conditions.', 'The index range is correctly captured. Using natural numbers instead of integers is appropriate since the range {1,2,...,n} consists of positive integers.', 'The inequality is perfectly translated with only notational differences (type annotations and explicit multiplication operator).', \"There is variable shadowing in 'tc_1 : \u2200 n, 0 < a n' where 'n' conflicts with the parameter name, but the logical meaning (all sequence values are positive) is preserved.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Summing these inequalities over all $k$, we obtain $$\\sum_{k=1}^{n} (a_k^k + (k-1)) \\ge \\sum_{k=1}^{n} k a_k$$.", "statement": "We assume:\n\u2022 $a_1, a_2, \\ldots, a_n$ is a sequence of positive real numbers indexed from 1 to n [tc_1];\n\u2022 For any integer $k \\in \\{1, 2, \\ldots, n\\}$, the inequality $a_k^k + (k-1) \\ge k a_k$ holds [l1].\nTherefore, we conclude:\n\u2022 $\\sum_{k=1}^{n} (a_k^k + (k-1)) \\ge \\sum_{k=1}^{n} k a_k$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (a : \u2115 \u2192 \u211d) (tc_1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k) \n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k) :\n  \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (n : \u2115) (a : \u2115 \u2192 \u211d) (tc_1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k) \n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k) :\n  \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n  have h_sum : \u2211 k in Finset.Icc 1 n, (k * a k : \u211d) \u2264 \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := by\n    have h\u2082 : \u2200 k \u2208 Finset.Icc 1 n, (k * a k : \u211d) \u2264 (a k ^ k + (k - 1 : \u211d)) := by\n      intro k hk\n      have h\u2083 : 1 \u2264 k := by\n        simp [Finset.mem_Icc] at hk\n        exact hk.1\n      have h\u2084 : k \u2264 n := by\n        simp [Finset.mem_Icc] at hk\n        exact hk.2\n      have h\u2085 : a k ^ k + (k - 1 : \u211d) \u2265 k * a k := l1 k h\u2083 h\u2084\n      linarith\n    -- Use the fact that each term in the first sum is less than or equal to the corresponding term in the second sum\n    calc\n      \u2211 k in Finset.Icc 1 n, (k * a k : \u211d) \u2264 \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := by\n        -- Apply the sum_le_sum lemma to compare the sums term-wise\n        apply Finset.sum_le_sum\n        intro k hk\n        exact h\u2082 k hk\n      _ = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := by rfl\n  \n  have h_final : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n    have h\u2083 : \u2211 k in Finset.Icc 1 n, (k * a k : \u211d) \u2264 \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := h_sum\n    -- Convert the sum of (k * a k : \u211d) to the sum of k * a k\n    have h\u2084 : \u2211 k in Finset.Icc 1 n, (k * a k : \u211d) = \u2211 k in Finset.Icc 1 n, k * a k := by\n      simp [mul_comm]\n      <;>\n      norm_cast\n      <;>\n      simp_all [Finset.sum_congr]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n    -- Use the fact that the sum of (k * a k : \u211d) is less than or equal to the sum of (a k ^ k + (k - 1 : \u211d))\n    have h\u2085 : \u2211 k in Finset.Icc 1 n, k * a k \u2264 \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := by\n      linarith\n    -- Conclude the proof by showing that the sum of (a k ^ k + (k - 1 : \u211d)) is greater than or equal to the sum of k * a k\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition correctly captures the domain [1,n] and positivity constraint using universal quantification with appropriate bounds.", "The individual inequality assumption l1 accurately translates the mathematical condition with proper type handling for the real number arithmetic.", "The sum inequality conclusion correctly uses Lean's finite set summation notation and preserves the exact mathematical relationship between the two sums."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "The sum of the integers $0, 1, \\dots, n-1$ is $\\binom{n}{2}$", "statement": "We assume:\n\u2022 $a_1, a_2, \\ldots, a_n$ is a sequence of positive real numbers indexed from 1 to n [tc_1];\n\u2022 For any integer $k \\in \\{1, 2, \\ldots, n\\}$, the inequality $a_k^k + (k-1) \\ge k a_k$ holds [l1];\n\u2022 $\\sum_{k=1}^{n} (a_k^k + (k-1)) \\ge \\sum_{k=1}^{n} k a_k$ [l2].\nTherefore, we conclude:\n\u2022 $\\sum_{k=1}^{n} (k-1) = \\binom{n}{2}$ [l3].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (n : \u2115) (a : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k)\n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k)\n  (l2 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k) :\n  \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (n : \u2115) (a : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k)\n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k)\n  (l2 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k) :\n  \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d) := by\n  have h_sum_k : \u2211 k in Finset.Icc 1 n, (k : \u211d) = (n : \u211d) * (n + 1 : \u211d) / 2 := by\n    have h\u2081 : \u2200 n : \u2115, \u2211 k in Finset.Icc 1 n, (k : \u211d) = (n : \u211d) * (n + 1 : \u211d) / 2 := by\n      intro n\n      induction n with\n      | zero =>\n        norm_num [Finset.sum_range_zero, Finset.Icc_self]\n      | succ n ih =>\n        rw [Finset.sum_Icc_succ_top (by norm_num : 1 \u2264 n.succ)]\n        rw [ih]\n        simp [Nat.cast_add, Nat.cast_one, add_assoc]\n        <;> ring_nf\n        <;> field_simp\n        <;> ring_nf\n        <;> norm_num\n        <;> linarith\n    exact h\u2081 n\n  \n  have h_sum_one : \u2211 k in Finset.Icc 1 n, (1 : \u211d) = (n : \u211d) := by\n    have h\u2081 : \u2211 k in Finset.Icc 1 n, (1 : \u211d) = (n : \u211d) := by\n      simp [Finset.sum_const, Finset.card_range]\n      <;>\n      (try cases n <;> simp_all [Finset.Icc_eq_empty, Finset.sum_range_zero, Nat.cast_zero]) <;>\n      (try ring_nf) <;>\n      (try norm_num) <;>\n      (try simp_all [Finset.Icc_eq_empty, Finset.sum_range_zero, Nat.cast_zero]) <;>\n      (try ring_nf) <;>\n      (try norm_num) <;>\n      (try linarith)\n      <;>\n      simp_all [Finset.Icc_eq_empty, Finset.sum_range_zero, Nat.cast_zero]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith\n    exact h\u2081\n  \n  have h_sum_k_sub_one : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n : \u211d) * (n + 1 : \u211d) / 2 - (n : \u211d) := by\n    calc\n      \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = \u2211 k in Finset.Icc 1 n, ((k : \u211d) - 1 : \u211d) := by\n        simp [sub_eq_add_neg]\n        <;> norm_cast\n      _ = \u2211 k in Finset.Icc 1 n, (k : \u211d) - \u2211 k in Finset.Icc 1 n, (1 : \u211d) := by\n        rw [Finset.sum_sub_distrib]\n      _ = (n : \u211d) * (n + 1 : \u211d) / 2 - (n : \u211d) := by\n        rw [h_sum_k, h_sum_one]\n        <;> ring_nf\n        <;> field_simp\n        <;> ring_nf\n  \n  have h_simplify : (n : \u211d) * (n + 1 : \u211d) / 2 - (n : \u211d) = (n : \u211d) * (n - 1 : \u211d) / 2 := by\n    have h\u2081 : (n : \u211d) * (n + 1 : \u211d) / 2 - (n : \u211d) = (n : \u211d) * (n - 1 : \u211d) / 2 := by\n      have h\u2082 : (n : \u211d) * (n + 1 : \u211d) / 2 - (n : \u211d) = (n : \u211d) * (n + 1 : \u211d) / 2 - (2 * (n : \u211d)) / 2 := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n      rw [h\u2082]\n      have h\u2083 : (n : \u211d) * (n + 1 : \u211d) / 2 - (2 * (n : \u211d)) / 2 = ((n : \u211d) * (n + 1 : \u211d) - 2 * (n : \u211d)) / 2 := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n      rw [h\u2083]\n      have h\u2084 : (n : \u211d) * (n + 1 : \u211d) - 2 * (n : \u211d) = (n : \u211d) * (n - 1 : \u211d) := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n        <;>\n        (try cases n <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_mul, Nat.cast_sub]) <;>\n        (try ring_nf at *) <;>\n        (try field_simp at *) <;>\n        (try norm_num at *) <;>\n        (try linarith)\n        <;>\n        (try nlinarith)\n      rw [h\u2084]\n      <;> ring_nf\n      <;> field_simp\n      <;> ring_nf\n    rw [h\u2081]\n  \n  have h_choose : (n : \u211d) * (n - 1 : \u211d) / 2 = (n.choose 2 : \u211d) := by\n    have h\u2081 : (n.choose 2 : \u211d) = (n : \u211d) * (n - 1 : \u211d) / 2 := by\n      have h\u2082 : \u2200 n : \u2115, (n.choose 2 : \u211d) = (n : \u211d) * (n - 1 : \u211d) / 2 := by\n        intro n\n        induction n using Nat.strong_induction_on with\n        | h n ih =>\n          match n with\n          | 0 =>\n            norm_num [Nat.choose_two_right]\n          | 1 =>\n            norm_num [Nat.choose_two_right]\n          | 2 =>\n            norm_num [Nat.choose_two_right]\n          | n + 3 =>\n            have h\u2083 := ih (n + 2) (by omega)\n            have h\u2084 := ih (n + 1) (by omega)\n            have h\u2085 := ih n (by omega)\n            simp [Nat.choose_succ_succ, Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_mul, Nat.cast_sub] at h\u2083 h\u2084 h\u2085 \u22a2\n            <;>\n            (try ring_nf at h\u2083 h\u2084 h\u2085 \u22a2) <;>\n            (try norm_num at h\u2083 h\u2084 h\u2085 \u22a2) <;>\n            (try linarith) <;>\n            (try nlinarith) <;>\n            (try ring_nf) <;>\n            (try field_simp) <;>\n            (try norm_num) <;>\n            (try linarith) <;>\n            (try nlinarith)\n            <;>\n            simp_all [Nat.choose_succ_succ, Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_mul, Nat.cast_sub]\n            <;>\n            ring_nf at *\n            <;>\n            norm_num at *\n            <;>\n            linarith\n      exact h\u2082 n\n    linarith\n  \n  have h_main : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d) := by\n    calc\n      \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n : \u211d) * (n + 1 : \u211d) / 2 - (n : \u211d) := by rw [h_sum_k_sub_one]\n      _ = (n : \u211d) * (n - 1 : \u211d) / 2 := by rw [h_simplify]\n      _ = (n.choose 2 : \u211d) := by rw [h_choose]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition correctly captures that a is a function from natural numbers to positive reals, with the domain restricted to [1,n]", "The individual inequality l1 is correctly formalized with proper quantification over the range and appropriate type casting", "The sum inequality l2 accurately represents the mathematical statement using Lean's finite set summation notation", "The conclusion l3 correctly states the identity between the sum of (k-1) and the binomial coefficient, with proper type casting to reals"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "so we can write $$\\sum_{k=1}^{n} a_k^k + \\binom{n}{2} \\ge \\sum_{k=1}^{n} k a_k$$.", "statement": "We assume:\n\u2022 $a_1, a_2, \\ldots, a_n$ is a sequence of positive real numbers indexed from 1 to n [tc_1];\n\u2022 For any integer $k \\in \\{1, 2, \\ldots, n\\}$, the inequality $a_k^k + (k-1) \\ge k a_k$ holds [l1];\n\u2022 $\\sum_{k=1}^{n} (a_k^k + (k-1)) \\ge \\sum_{k=1}^{n} k a_k$ [l2];\n\u2022 $\\sum_{k=1}^{n} (k-1) = \\binom{n}{2}$ [l3].\nTherefore, we conclude:\n\u2022 $\\sum_{k=1}^{n} a_k^k + \\binom{n}{2} \\ge \\sum_{k=1}^{n} k a_k$ [l4].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (n : \u2115) (a : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k)\n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k)\n  (l2 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k)\n  (l3 : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d)) :\n  \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (n : \u2115) (a : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k)\n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k)\n  (l2 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k)\n  (l3 : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d)) :\n  \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n  have h_sum_split : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) = (\u2211 k in Finset.Icc 1 n, a k ^ k) + \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) := by\n    calc\n      _ = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n      _ = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n      _ = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n      _ = (\u2211 k in Finset.Icc 1 n, a k ^ k) + \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) := by\n        have h\u2081 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n        rw [h\u2081]\n        -- Use the linearity of the sum to split the sum of the sum into the sum of the sums\n        have h\u2082 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n        rw [h\u2082]\n        -- Use the fact that the sum of the sum is the sum of the sums\n        have h\u2083 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) = (\u2211 k in Finset.Icc 1 n, a k ^ k) + \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) := by\n          -- Use the linearity of the sum to split the sum of the sum into the sum of the sums\n          calc\n            _ = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n            _ = \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) := rfl\n            _ = (\u2211 k in Finset.Icc 1 n, a k ^ k) + \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) := by\n              -- Use the linearity of the sum to split the sum of the sum into the sum of the sums\n              rw [Finset.sum_add_distrib]\n        rw [h\u2083]\n  \n  have h_main : (\u2211 k in Finset.Icc 1 n, a k ^ k) + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n    have h4 : (\u2211 k in Finset.Icc 1 n, a k ^ k) + \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n      linarith\n    have h5 : (\u2211 k in Finset.Icc 1 n, a k ^ k) + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n      have h6 : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d) := l3\n      have h7 : (\u2211 k in Finset.Icc 1 n, a k ^ k) + \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (\u2211 k in Finset.Icc 1 n, a k ^ k) + (n.choose 2 : \u211d) := by\n        rw [h6]\n        <;> ring_nf\n      linarith\n    exact h5\n  \n  have h_final : \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := by\n    simpa [add_assoc] using h_main\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly formalized. The natural language describes positive real numbers indexed from 1 to n, and the Lean code captures this with the appropriate type constraints and positivity condition.", "The individual inequality for each k is perfectly translated. The mathematical expression and the domain constraint are identical in meaning.", "The sum inequality l2 is correctly formalized using Finset.Icc 1 n to represent the summation from 1 to n, with all mathematical expressions matching exactly.", "The binomial coefficient identity is properly represented, with appropriate type coercions to real numbers for both the sum and the binomial coefficient.", "The conclusion l4 correctly captures the final inequality, properly separating the sum of powers from the binomial coefficient term, which matches the mathematical structure in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Rewriting this inequality gives the desired result: $$\\sum_{k=1}^{n} k a_k \\le \\binom{n}{2} + \\sum_{k=1}^{n} a_k^k$$.", "statement": "We assume:\n\u2022 $a_1, a_2, \\ldots, a_n$ is a sequence of positive real numbers indexed from 1 to n [tc_1];\n\u2022 For any integer $k \\in \\{1, 2, \\ldots, n\\}$, the inequality $a_k^k + (k-1) \\ge k a_k$ holds [l1];\n\u2022 $\\sum_{k=1}^{n} (a_k^k + (k-1)) \\ge \\sum_{k=1}^{n} k a_k$ [l2];\n\u2022 $\\sum_{k=1}^{n} (k-1) = \\binom{n}{2}$ [l3];\n\u2022 $\\sum_{k=1}^{n} a_k^k + \\binom{n}{2} \\ge \\sum_{k=1}^{n} k a_k$ [l4].\nTherefore, we conclude:\n\u2022 $\\sum_{k=1}^{n} k a_k \\le \\binom{n}{2} + \\sum_{k=1}^{n} a_k^k$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (n : \u2115) (a : \u2115 \u2192 \u211d) \n  (hc_pos : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k)\n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k)\n  (l2 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k)\n  (l3 : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d))\n  (l4 : \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k) :\n  \u2211 k in Finset.Icc 1 n, k * a k \u2264 (n.choose 2 : \u211d) + \u2211 k in Finset.Icc 1 n, a k ^ k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (n : \u2115) (a : \u2115 \u2192 \u211d) \n  (hc_pos : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 0 < a k)\n  (l1 : \u2200 k, 1 \u2264 k \u2192 k \u2264 n \u2192 a k ^ k + (k - 1 : \u211d) \u2265 k * a k)\n  (l2 : \u2211 k in Finset.Icc 1 n, (a k ^ k + (k - 1 : \u211d)) \u2265 \u2211 k in Finset.Icc 1 n, k * a k)\n  (l3 : \u2211 k in Finset.Icc 1 n, (k - 1 : \u211d) = (n.choose 2 : \u211d))\n  (l4 : \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k) :\n  \u2211 k in Finset.Icc 1 n, k * a k \u2264 (n.choose 2 : \u211d) + \u2211 k in Finset.Icc 1 n, a k ^ k := by\n  have h_main : \u2211 k in Finset.Icc 1 n, k * a k \u2264 (n.choose 2 : \u211d) + \u2211 k in Finset.Icc 1 n, a k ^ k := by\n    have h5 : \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) \u2265 \u2211 k in Finset.Icc 1 n, k * a k := l4\n    have h6 : \u2211 k in Finset.Icc 1 n, k * a k \u2264 \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) := by\n      linarith\n    have h7 : (n.choose 2 : \u211d) + \u2211 k in Finset.Icc 1 n, a k ^ k = \u2211 k in Finset.Icc 1 n, a k ^ k + (n.choose 2 : \u211d) := by\n      ring\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly formalized with appropriate type declarations and positivity constraints.", "The individual inequality l1 is accurately represented with proper quantification over the range [1,n].", "The sum inequality l2 correctly uses Lean's summation notation with the appropriate range.", "The binomial coefficient identity l3 is properly formalized with explicit type casting.", "The combined inequality l4 accurately represents the mathematical statement.", "The conclusion ts_1 correctly captures the final inequality, with mathematically equivalent term ordering."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    