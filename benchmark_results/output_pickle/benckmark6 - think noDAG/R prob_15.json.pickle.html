
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a continuous random variable with a probability density function (PDF) given by $f(x) = \lambda e^{-\lambda x}$ for $x \ge 0$ and $f(x) = 0$ for $x < 0$. We are given that the parameter $\lambda = 2$. Then, the expected value $E[X] = 1/2$, the variance $Var(X) = 1/4$, and the probability $P(X > 1) = e^{-2}$.

Proof: From the given conditions, the specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \ge 0$. To find the expected value, we compute the integral $E[X] = \int_0^\infty x f(x) dx = \int_0^\infty 2x e^{-2x} dx$. Using integration by parts, this integral evaluates to $1/2$. Therefore, the expected value is $E[X] = 1/2$. To find the variance, we first need the second moment $E[X^2] = \int_0^\infty x^2 f(x) dx = \int_0^\infty 2x^2 e^{-2x} dx$. Evaluating this integral using integration by parts yields $E[X^2] = 1/2$. The variance is then $Var(X) = E[X^2] - (E[X])^2 = 1/2 - (1/2)^2 = 1/4$. Finally, the probability $P(X > 1)$ is found by integrating the PDF from $1$ to $\infty$, which is $\int_1^\infty 2e^{-2x} dx = e^{-2}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a continuous random variable with a probability density function (PDF) given by $f(x) = \\lambda e^{-\\lambda x}$ for $x \\ge 0$ and $f(x) = 0$ for $x < 0$.", "statement": "Premise:\n\u2022 $X$ is a continuous random variable with a probability density function (PDF) given by $f(x) = \\lambda e^{-\\lambda x}$ for $x \\ge 0$ and $f(x) = 0$ for $x < 0$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 \n  (f : \u211d \u2192 \u211d) (k : \u211d)\n  (h1 : k = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = k * Real.exp (-k * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (h4 : \u222b x in Set.Ici 0, f x = 1) :\n  (\u222b x in Set.Ici 0, x * f x = 1/2) \u2227 \n  (\u222b x in Set.Ici 0, x^2 * f x - (1/2)^2 = 1/4) \u2227\n  (\u222b x in Set.Ici 1, f x = Real.exp (-2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization represents X implicitly through the function f, which is reasonable, but doesn't explicitly declare X as a continuous random variable", "The natural language uses a general parameter \u03bb, but Lean fixes k = 2. This is a major restriction that changes the generality of the statement", "Both versions correctly specify that f(x) = 0 for x < 0", "The natural language concludes that f is a PDF of X, but the Lean formalization concludes with specific integral computations (expectation, variance, tail probability). The Lean version does include the PDF condition implicitly through the integral constraint \u222bf = 1, but the main conclusions are completely different"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization represents X implicitly through the function f, which is reasonable, but doesn't explicitly declare X as a continuous random variable\", 'The natural language uses a general parameter \u03bb, but Lean fixes k = 2. This is a major restriction that changes the generality of the statement', 'Both versions correctly specify that f(x) = 0 for x < 0', 'The natural language concludes that f is a PDF of X, but the Lean formalization concludes with specific integral computations (expectation, variance, tail probability). The Lean version does include the PDF condition implicitly through the integral constraint \u222bf = 1, but the main conclusions are completely different']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "We are given that the parameter $\\lambda = 2$.", "statement": "Premise:\n\u2022 $X$ is a continuous random variable with a probability density function (PDF) given by $f(x) = \\lambda e^{-\\lambda x}$ for $x \\ge 0$ and $f(x) = 0$ for $x < 0$ [tc_1];\n\u2022 The parameter $\\lambda = 2$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (h4 : \u222b x in Set.Ici 0, f x = 1) :\n  (\u222b x in Set.Ici 0, x * f x = 1/2) \u2227 \n  (\u222b x in Set.Ici 0, x^2 * f x - (1/2)^2 = 1/4) \u2227\n  (\u222b x in Set.Ici 1, f x = Real.exp (-2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition lambda = 2 is perfectly captured in h1", "The PDF definition for x \u2265 0 is correctly formalized as h2", "The PDF definition for x < 0 is correctly formalized as h3", "The Lean adds an extra condition h4 about the integral being 1 (normalization condition for PDF), which is mathematically consistent but not explicitly stated in the natural language", "The Lean conclusion is completely different - it proves statements about integrals/moments rather than the explicit form f(x) = 2e^{-2x} that the natural language concludes"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition lambda = 2 is perfectly captured in h1', 'The PDF definition for x \u2265 0 is correctly formalized as h2', 'The PDF definition for x < 0 is correctly formalized as h3', 'The Lean adds an extra condition h4 about the integral being 1 (normalization condition for PDF), which is mathematically consistent but not explicitly stated in the natural language', 'The Lean conclusion is completely different - it proves statements about integrals/moments rather than the explicit form f(x) = 2e^{-2x} that the natural language concludes']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "From the given conditions, the specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \\ge 0$.", "statement": "We assume:\n\u2022 $X$ is a continuous random variable with a probability density function (PDF) given by $f(x) = \\lambda e^{-\\lambda x}$ for $x \\ge 0$ and $f(x) = 0$ for $x < 0$ [tc_1];\n\u2022 The parameter $\\lambda = 2$ [tc_2].\nTherefore, we conclude:\n\u2022 The specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \\ge 0$ and $f(x)=0$ for $x < 0$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  (\u2200 x : \u211d, x \u2265 0 \u2192 f x = 2 * Real.exp (-2 * x)) \u2227 \n  (\u2200 x : \u211d, x < 0 \u2192 f x = 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  (\u2200 x : \u211d, x \u2265 0 \u2192 f x = 2 * Real.exp (-2 * x)) \u2227 \n  (\u2200 x : \u211d, x < 0 \u2192 f x = 0) := by\n  have h4 : \u2200 (x : \u211d), x \u2265 0 \u2192 f x = 2 * Real.exp (-2 * x) := by\n    intro x hx\n    have h4\u2081 : f x = lambda * Real.exp (-lambda * x) := h2 x hx\n    rw [h4\u2081]\n    have h4\u2082 : lambda = 2 := h1\n    rw [h4\u2082]\n    <;> ring_nf\n    <;> field_simp [Real.exp_neg]\n    <;> ring_nf\n    <;> norm_num\n    <;>\n    simp_all [Real.exp_neg]\n    <;>\n    ring_nf\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h5 : (\u2200 x : \u211d, x \u2265 0 \u2192 f x = 2 * Real.exp (-2 * x)) \u2227 (\u2200 x : \u211d, x < 0 \u2192 f x = 0) := by\n    refine' \u27e8h4, _\u27e9\n    -- The second part of the conclusion is directly given by h3\n    intro x hx\n    exact h3 x hx\n  \n  exact h5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premises are correctly formalized with appropriate hypotheses capturing the general exponential distribution form, the zero condition for negative values, and the parameter specification \u03bb = 2.", "The conclusion correctly states the goal of deriving the specific PDF form f(x) = 2e^(-2x) for x \u2265 0 and f(x) = 0 for x < 0, which follows logically from substituting \u03bb = 2 into the general form."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "To find the expected value, we compute the integral $E[X] = \\int_0^\\infty x f(x) dx$", "statement": "We assume:\n\u2022 $X$ is a continuous random variable with a probability density function (PDF) given by $f(x) = \\lambda e^{-\\lambda x}$ for $x \\ge 0$ and $f(x) = 0$ for $x < 0$ [tc_1];\n\u2022 The parameter $\\lambda = 2$ [tc_2];\n\u2022 The specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \\ge 0$ and $f(x)=0$ for $x < 0$ [l1].\nDefinition:\n\u2022 The expected value of $X$ is $E[X] = \\int_0^\\infty x f(x) dx$ for a non-negative random variable [def_1].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem exponential_dist \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (h4 : \u222b x in Set.Ici 0, f x = 1) :\n  (\u222b x in Set.Ici 0, x * f x = 1/2) \u2227 \n  (\u222b x in Set.Ici 0, x^2 * f x - (1/2)^2 = 1/4) \u2227\n  (\u222b x in Set.Ici 1, f x = Real.exp (-2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean condition h2 perfectly captures the PDF definition f(x) = \u03bbe^(-\u03bbx) for x \u2265 0, and h3 captures f(x) = 0 for x < 0", "The Lean condition h1 exactly matches \u03bb = 2", "The natural language defines the expected value as E[X] = \u222b\u2080^\u221e x f(x) dx, but the Lean formalization includes h4: \u222b x in Set.Ici 0, f x = 1 (normalization condition) instead. The expected value definition is completely missing from the Lean conditions", "The natural language conclusion is that the specific PDF is f(x) = 2e^(-2x) for x \u2265 0 and f(x) = 0 for x < 0. However, the Lean conclusions are completely different: they compute the expected value (1/2), variance (1/4), and a tail probability (e^(-2)). The stated conclusion about the specific PDF form is missing entirely"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean condition h2 perfectly captures the PDF definition f(x) = \u03bbe^(-\u03bbx) for x \u2265 0, and h3 captures f(x) = 0 for x < 0', 'The Lean condition h1 exactly matches \u03bb = 2', 'The natural language defines the expected value as E[X] = \u222b\u2080^\u221e x f(x) dx, but the Lean formalization includes h4: \u222b x in Set.Ici 0, f x = 1 (normalization condition) instead. The expected value definition is completely missing from the Lean conditions', 'The natural language conclusion is that the specific PDF is f(x) = 2e^(-2x) for x \u2265 0 and f(x) = 0 for x < 0. However, the Lean conclusions are completely different: they compute the expected value (1/2), variance (1/4), and a tail probability (e^(-2)). The stated conclusion about the specific PDF form is missing entirely']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "$E[X] = \\int_0^\\infty x f(x) dx = \\int_0^\\infty 2x e^{-2x} dx$.", "statement": "We assume:\n\u2022 The specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \\ge 0$ and $f(x)=0$ for $x < 0$ [l1];\n\u2022 The expected value of $X$ is $E[X] = \\int_0^\\infty x f(x) dx$ for a non-negative random variable [def_1].\nTherefore, we conclude:\n\u2022 $E[X] = \\int_0^\\infty 2x e^{-2x} dx$ [l2].", "dependencies": ["tc_1", "tc_2", "l1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  (\u222b x in Set.Ici 0, x * f x) = (\u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  (\u222b x in Set.Ici 0, x * f x) = (\u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x)) := by\n  have h_integrand_eq : \u2200 (x : \u211d), x \u2208 Set.Ici 0 \u2192 x * f x = 2 * x * Real.exp (-2 * x) := by\n    intro x hx\n    have h4 : x \u2265 0 := by exact hx\n    have h5 : f x = lambda * Real.exp (-lambda * x) := h2 x h4\n    have h6 : lambda = 2 := h1\n    rw [h5, h6]\n    have h7 : (2 : \u211d) * Real.exp (-(2 : \u211d) * x) = 2 * Real.exp (-2 * x) := by ring_nf\n    have h8 : x * (2 * Real.exp (-(2 : \u211d) * x)) = 2 * x * Real.exp (-2 * x) := by\n      ring_nf at *\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try ring_nf) <;>\n      (try field_simp) <;>\n      (try norm_num) <;>\n      (try linarith)\n      <;>\n      ring_nf at *\n      <;>\n      linarith\n    have h9 : x * (2 * Real.exp (-(2 : \u211d) * x)) = 2 * x * Real.exp (-2 * x) := by\n      ring_nf at *\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try ring_nf) <;>\n      (try field_simp) <;>\n      (try norm_num) <;>\n      (try linarith)\n      <;>\n      ring_nf at *\n      <;>\n      linarith\n    calc\n      x * (2 * Real.exp (-(2 : \u211d) * x)) = 2 * x * Real.exp (-2 * x) := by\n        ring_nf at *\n        <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try ring_nf) <;>\n        (try field_simp) <;>\n        (try norm_num) <;>\n        (try linarith)\n        <;>\n        ring_nf at *\n        <;>\n        linarith\n      _ = 2 * x * Real.exp (-2 * x) := by rfl\n  \n  have h_main : (\u222b x in Set.Ici 0, x * f x) = (\u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x)) := by\n    have h4 : MeasurableSet (Set.Ici (0 : \u211d)) := by\n      apply measurableSet_Ici\n    -- Use the fact that the integrands are equal on the set to prove the integrals are equal\n    have h5 : (\u222b x in Set.Ici 0, x * f x) = (\u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x)) := by\n      -- Use the fact that the integrands are equal on the set to prove the integrals are equal\n      apply MeasureTheory.set_integral_congr h4 fun x hx => by\n        have h6 : x \u2208 Set.Ici 0 := hx\n        have h7 : x * f x = 2 * x * Real.exp (-2 * x) := h_integrand_eq x h6\n        rw [h7]\n    exact h5\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The PDF definition is correctly formalized using lambda parameter and conditional statements for different domains", "The expected value integral is properly represented using Set.Ici 0 for the integration domain [0,\u221e)", "The conclusion correctly shows the equality between the general expected value formula and the specific integral with the given PDF", "The logical flow from assumptions to conclusion is properly structured as a theorem with hypotheses leading to the desired equality"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Using integration by parts, this integral evaluates to $1/2$.", "statement": "We assume:\n\u2022 $E[X] = \\int_0^\\infty 2x e^{-2x} dx$ [l2].\nTherefore, we conclude:\n\u2022 The integral $\\int_0^\\infty 2x e^{-2x} dx$ evaluates to $1/2$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  (\u222b x in Set.Ici 0, x * f x) = 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  (\u222b x in Set.Ici 0, x * f x) = 1/2 := by\n  have h4 : (\u222b x in Set.Ici 0, x * f x) = (\u222b x in Set.Ici 0, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x)) := by\n    have h4\u2081 : (\u222b x in Set.Ici 0, x * f x) = \u222b x in Set.Ici 0, x * (2 : \u211d) * Real.exp (-(2 : \u211d) * x) := by\n      apply integral_congr_ae\n      have h4\u2082 : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Set.Ici 0), x * f x = x * (2 : \u211d) * Real.exp (-(2 : \u211d) * x) := by\n        filter_upwards [self_mem_ae_restrict (measurableSet_Ici : MeasurableSet (Set.Ici (0 : \u211d)))] with x hx\n        have h4\u2083 : x \u2208 Set.Ici (0 : \u211d) := hx\n        have h4\u2084 : x \u2265 0 := by exact h4\u2083\n        have h4\u2085 : f x = lambda * Real.exp (-lambda * x) := h2 x h4\u2084\n        have h4\u2086 : lambda = (2 : \u211d) := h1\n        rw [h4\u2085, h4\u2086]\n        <;> ring_nf\n        <;> field_simp [Real.exp_neg]\n        <;> ring_nf\n        <;> norm_num\n        <;> linarith\n      filter_upwards [h4\u2082] with x hx\n      linarith\n    have h4\u2087 : \u222b x in Set.Ici 0, x * (2 : \u211d) * Real.exp (-(2 : \u211d) * x) = \u222b x in Set.Ici 0, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) := by\n      apply integral_congr_ae\n      have h4\u2088 : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Set.Ici 0), x * (2 : \u211d) * Real.exp (-(2 : \u211d) * x) = (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) := by\n        filter_upwards [self_mem_ae_restrict (measurableSet_Ici : MeasurableSet (Set.Ici (0 : \u211d)))] with x hx\n        ring_nf\n      filter_upwards [h4\u2088] with x hx\n      linarith\n    calc\n      (\u222b x in Set.Ici 0, x * f x) = \u222b x in Set.Ici 0, x * (2 : \u211d) * Real.exp (-(2 : \u211d) * x) := h4\u2081\n      _ = \u222b x in Set.Ici 0, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) := h4\u2087\n  \n  have h5 : (\u222b x in Set.Ici 0, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x)) = 1 / 2 := by\n    have h\u2085 : (\u222b x in Set.Ici (0 : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x)) = 1 / 2 := by\n      -- Use the fact that the integral of x * exp(-a * x) from 0 to \u221e is 1 / a\u00b2\n      -- Here, a = 2, so the integral of x * exp(-2 * x) is 1 / 4\n      -- Multiplying by 2 gives 1 / 2\n      have h\u2081 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n        -- Use the antiderivative to compute the integral\n        have h\u2082 : \u222b (x : \u211d) in (0 : \u211d)..(1 : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = (- (1 : \u211d) - 1 / 2) * Real.exp (-(2 : \u211d) * (1 : \u211d)) - (- (0 : \u211d) - 1 / 2) * Real.exp (-(2 : \u211d) * (0 : \u211d)) := by\n          -- Compute the integral from 0 to 1 using the antiderivative\n          norm_num [intervalIntegral.integral_comp_mul_left (fun x => x * Real.exp (-x))]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          field_simp [Real.exp_neg]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith [Real.exp_pos 2]\n        -- Compute the integral from 0 to \u221e using the antiderivative and taking the limit\n        have h\u2083 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n          -- Use the fact that the integral from 0 to \u221e is 1 / 2\n          have h\u2084 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n            -- Use the fundamental theorem of calculus to evaluate the integral\n            have h\u2085 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n              -- Use the fact that the integral is 1 / 2\n              have h\u2086 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                -- Use the fundamental theorem of calculus\n                have h\u2087 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                  -- Use the fact that the integral is 1 / 2\n                  have h\u2088 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                    -- Use the fact that the integral of x * exp(-a * x) from 0 to \u221e is 1 / a\u00b2\n                    -- Here, a = 2, so the integral of x * exp(-2 * x) is 1 / 4\n                    -- Multiplying by 2 gives 1 / 2\n                    have h\u2089 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                      -- Use the fact that the integral of x * exp(-a * x) from 0 to \u221e is 1 / a\u00b2\n                      -- Here, a = 2, so the integral of x * exp(-2 * x) is 1 / 4\n                      -- Multiplying by 2 gives 1 / 2\n                      have h\u2081\u2080 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                        -- Use the fundamental theorem of calculus to evaluate the integral\n                        have h\u2081\u2081 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                          -- Use the fact that the integral is 1 / 2\n                          -- This step is non-trivial and requires knowing the integral of x * exp(-a x)\n                          -- Here, we use the fact that \u222b x * exp(-a x) dx from 0 to \u221e is 1 / a\u00b2\n                          -- For a = 2, \u222b x * exp(-2 x) dx from 0 to \u221e is 1 / 4\n                          -- Therefore, 2 * \u222b x * exp(-2 x) dx from 0 to \u221e is 1 / 2\n                          -- We use the fact that \u222b x * exp(-a x) dx from 0 to \u221e is 1 / a\u00b2\n                          -- Here, we have \u222b 2 * x * exp(-2 x) dx from 0 to \u221e = 2 * (1 / 4) = 1 / 2\n                          -- This is a known integral and is used here directly\n                          have h\u2081\u2082 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                            -- Use the fact that the integral of x * exp(-a x) from 0 to \u221e is 1 / a\u00b2\n                            -- Here, a = 2, so the integral of x * exp(-2 x) is 1 / 4\n                            -- Multiplying by 2 gives 1 / 2\n                            have h\u2081\u2083 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                              -- Use the fundamental theorem of calculus to evaluate the integral\n                              -- The antiderivative of 2 * x * exp(-2 * x) is - (x + 1 / 2) * exp(-2 * x)\n                              -- Evaluating from 0 to \u221e gives 0 - (-1 / 2) = 1 / 2\n                              -- Here, we use the fact that the integral is 1 / 2 directly\n                              have h\u2081\u2084 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = 1 / 2 := by\n                                -- Use the fundamental theorem of calculus\n                                -- The antiderivative of 2 * x * exp(-2 * x) is - (x + 1 / 2) * exp(-2 * x)\n                                -- Evaluating from 0 to \u221e gives 0 - (-1 / 2) = 1 / 2\n                                -- Here, we use the fact that the integral is 1 / 2 directly\n                                norm_num [integral_id_mul_exp_neg_mul, Real.rpow_two] at h\u2082 \u22a2\n                                <;>\n                                ring_nf at h\u2082 \u22a2 <;>\n                                norm_num at h\u2082 \u22a2 <;>\n                                linarith [Real.exp_pos 2]\n                              exact h\u2081\u2084\n                            exact h\u2081\u2083\n                          exact h\u2081\u2082\n                        exact h\u2081\u2081\n                      exact h\u2081\u2080\n                    exact h\u2089\n                  exact h\u2088\n                exact h\u2087\n              exact h\u2086\n            exact h\u2085\n          exact h\u2084\n        exact h\u2083\n      -- Relate the integral over Set.Ici to the interval integral\n      have h\u2082 : \u222b x in Set.Ici (0 : \u211d), (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) = \u222b (x : \u211d) in (0 : \u211d)..\u221e, (2 : \u211d) * x * Real.exp (-(2 : \u211d) * x) := by\n        -- Prove that the integral over Set.Ici is the same as the interval integral\n        rw [\u2190 intervalIntegral.integral_of_le (by norm_num : (0 : \u211d) \u2264 \u221e)]\n        <;> simp [Real.volume_Ici]\n        <;>\n          congr 1 <;>\n            ext1 x <;>\n              simp [Set.mem_Ici] <;>\n                by_cases h : x \u2265 0 <;>\n                  simp_all [h] <;>\n                    norm_num <;>\n                      linarith\n      rw [h\u2082]\n      exact h\u2081\n    exact h\u2085\n  \n  have h6 : (\u222b x in Set.Ici 0, x * f x) = 1/2 := by\n    rw [h4]\n    rw [h5]\n    <;> norm_num\n  \n  exact h6", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The integral expression is correctly captured. The Lean code defines f(x) = 2*exp(-2x) for x\u22650, making x*f(x) = 2x*exp(-2x), which matches the natural language integral exactly.", "The result value 1/2 is identical in both the natural language and Lean formalization.", "While the natural language frames this as an assumption followed by a conclusion, and the Lean code states it as a direct theorem, both are asserting the same mathematical fact: that the integral \u222b\u2080^\u221e 2x e^{-2x} dx equals 1/2. The additional technical details in Lean (function definition, lambda parameter, negative domain specification) are consistent enhancements that don't contradict the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3_negation : \u00ac (\u2200 (f : \u211d \u2192 \u211d) (lambda : \u211d), (lambda = 2) \u2192 (\u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x)) \u2192 (\u2200 x : \u211d, x < 0 \u2192 f x = 0) \u2192 (\u222b x in Set.Ici 0, x * f x) = 1/2) := by\n  have h_main : False := by\n    have h\u2081 : (\u2200 (f : \u211d \u2192 \u211d) (lambda : \u211d), (lambda = 2) \u2192 (\u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x)) \u2192 (\u2200 x : \u211d, x < 0 \u2192 f x = 0) \u2192 (\u222b x in Set.Ici 0, x * f x) = 1 / 2) := by\n      intro f lambda h_lambda h_f_nonneg h_f_neg\n      have h\u2082 : (\u222b x in Set.Ici 0, x * f x) = 1 / 2 := by\n        have h\u2083 : (\u222b x in Set.Ici 0, x * f x) = (\u222b x in (0 : \u211d)..\u221e, x * f x) := by\n          -- The integral over Set.Ici 0 is the same as the integral from 0 to \u221e for non-negative functions.\n          simp [intervalIntegral.integral_of_le (by norm_num : (0 : \u211d) \u2264 \u221e)]\n          <;>\n          simp_all [Set.Ici]\n          <;>\n          congr 1 <;> ext <;> simp [le_of_lt]\n          <;>\n          norm_num\n          <;>\n          linarith\n        rw [h\u2083]\n        have h\u2084 : (\u222b x in (0 : \u211d)..\u221e, x * f x) = (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) := by\n          -- Use the given form of f(x) for x \u2265 0\n          have h\u2085 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = 2 * Real.exp (-2 * x) := by\n            intro x hx\n            have h\u2086 : f x = lambda * Real.exp (-lambda * x) := h_f_nonneg x hx\n            rw [h\u2086]\n            have h\u2087 : lambda = 2 := h_lambda\n            rw [h\u2087]\n            <;> ring_nf\n            <;>\n            simp_all [Real.exp_neg]\n            <;>\n            field_simp [Real.exp_neg]\n            <;>\n            ring_nf\n          -- Use the fact that f(x) = 2 * exp(-2 * x) for x \u2265 0 to change the integrand\n          have h\u2088 : (\u222b x in (0 : \u211d)..\u221e, x * f x) = (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) := by\n            -- Use the fact that the integrands are equal for x \u2265 0\n            have h\u2089 : \u2200 x : \u211d, x \u2208 Set.Icc (0 : \u211d) \u221e \u2192 x * f x = x * (2 * Real.exp (-2 * x)) := by\n              intro x hx\n              have h\u2081\u2080 : x \u2265 0 := by\n                simp only [Set.mem_Icc] at hx\n                linarith\n              have h\u2081\u2081 : f x = 2 * Real.exp (-2 * x) := h\u2085 x h\u2081\u2080\n              rw [h\u2081\u2081]\n              <;> ring_nf\n            -- Use the fact that the integrands are equal almost everywhere\n            have h\u2081\u2082 : (\u222b x in (0 : \u211d)..\u221e, x * f x) = (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) := by\n              -- Use the fact that the integrands are equal almost everywhere\n              have h\u2081\u2083 : (\u222b x in (0 : \u211d)..\u221e, x * f x) = (\u222b x in (0 : \u211d)..\u221e, x * f x) := rfl\n              have h\u2081\u2084 : (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) = (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) := rfl\n              -- Use the fact that the integrands are equal almost everywhere\n              congr\n              <;>\n              ext x <;>\n              by_cases hx : x \u2208 Set.Icc (0 : \u211d) \u221e <;>\n              simp_all [Set.mem_Icc] <;>\n              (try { linarith }) <;>\n              (try { ring_nf at * <;> simp_all [h\u2085] }) <;>\n              (try {\n                have h\u2081\u2085 := h\u2085 x\n                have h\u2081\u2086 : x \u2265 0 := by linarith\n                have h\u2081\u2087 : f x = 2 * Real.exp (-2 * x) := h\u2081\u2085 h\u2081\u2086\n                simp_all [h\u2081\u2087]\n                <;>\n                ring_nf\n                <;>\n                simp_all [Real.exp_neg]\n                <;>\n                field_simp [Real.exp_neg]\n                <;>\n                ring_nf\n              }) <;>\n              (try {\n                simp_all [h\u2085]\n                <;>\n                ring_nf\n                <;>\n                simp_all [Real.exp_neg]\n                <;>\n                field_simp [Real.exp_neg]\n                <;>\n                ring_nf\n              })\n            exact h\u2081\u2082\n          exact h\u2088\n        rw [h\u2084]\n        -- Compute the integral of x * (2 * exp(-2 * x)) from 0 to \u221e\n        have h\u2085 : (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) = 1 / 2 := by\n          -- Use the fundamental theorem of calculus to evaluate the integral\n          have h\u2086 : (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) = 1 / 2 := by\n            -- Use the fundamental theorem of calculus to evaluate the integral\n            have h\u2087 : (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) = 1 / 2 := by\n              -- Use the fundamental theorem of calculus to evaluate the integral\n              have h\u2088 : (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) = 1 / 2 := by\n                -- Use the fundamental theorem of calculus to evaluate the integral\n                have h\u2089 : (\u222b x in (0 : \u211d)..\u221e, x * (2 * Real.exp (-2 * x))) = 1 / 2 := by\n                  -- Use the fundamental theorem of calculus to evaluate the integral\n                  have h\u2081\u2080 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                    -- Use the fundamental theorem of calculus to evaluate the integral\n                    have h\u2081\u2081 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                      -- Use the fundamental theorem of calculus to evaluate the integral\n                      have h\u2081\u2082 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                        -- Use the fundamental theorem of calculus to evaluate the integral\n                        have h\u2081\u2083 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                          -- Use the fundamental theorem of calculus to evaluate the integral\n                          have h\u2081\u2084 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                            -- Use the fundamental theorem of calculus to evaluate the integral\n                            have h\u2081\u2085 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                              -- Use the fundamental theorem of calculus to evaluate the integral\n                              have h\u2081\u2086 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                -- Use the fundamental theorem of calculus to evaluate the integral\n                                -- The antiderivative of x * 2 * exp(-2 * x) is -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                -- Evaluate from 0 to \u221e: 0 - (-1/2) = 1/2\n                                -- This can be verified by taking the derivative of -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                -- and confirming it equals x * 2 * exp(-2 * x)\n                                -- Alternatively, use integration by parts:\n                                -- Let u = x, dv = 2 * exp(-2 * x) dx, then du = dx, v = -exp(-2 * x)\n                                -- \u222b u dv = uv - \u222b v du = -x * exp(-2 * x) + \u222b exp(-2 * x) dx = -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                -- Then evaluate from 0 to \u221e.\n                                -- This can be done using the `integral_comp_mul_left` lemma in Lean.\n                                have h\u2081\u2087 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                  -- Use the fundamental theorem of calculus to evaluate the integral\n                                  have h\u2081\u2088 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                    -- Use the fundamental theorem of calculus to evaluate the integral\n                                    -- The antiderivative of x * 2 * exp(-2 * x) is -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                    -- Evaluate from 0 to \u221e: 0 - (-1/2) = 1/2\n                                    -- This can be verified by taking the derivative of -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                    -- and confirming it equals x * 2 * exp(-2 * x)\n                                    -- Alternatively, use integration by parts:\n                                    -- Let u = x, dv = 2 * exp(-2 * x) dx, then du = dx, v = -exp(-2 * x)\n                                    -- \u222b u dv = uv - \u222b v du = -x * exp(-2 * x) + \u222b exp(-2 * x) dx = -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                    -- Then evaluate from 0 to \u221e.\n                                    -- This can be done using the `integral_comp_mul_left` lemma in Lean.\n                                    have h\u2081\u2089 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                      -- Use the fundamental theorem of calculus to evaluate the integral\n                                      have h\u2082\u2080 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                        -- Use the fundamental theorem of calculus to evaluate the integral\n                                        -- The antiderivative of x * 2 * exp(-2 * x) is -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                        -- Evaluate from 0 to \u221e: 0 - (-1/2) = 1/2\n                                        -- This can be verified by taking the derivative of -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                        -- and confirming it equals x * 2 * exp(-2 * x)\n                                        -- Alternatively, use integration by parts:\n                                        -- Let u = x, dv = 2 * exp(-2 * x) dx, then du = dx, v = -exp(-2 * x)\n                                        -- \u222b u dv = uv - \u222b v du = -x * exp(-2 * x) + \u222b exp(-2 * x) dx = -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                        -- Then evaluate from 0 to \u221e.\n                                        -- This can be done using the `integral_comp_mul_left` lemma in Lean.\n                                        have h\u2082\u2081 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                          -- Use the fundamental theorem of calculus to evaluate the integral\n                                          have h\u2082\u2082 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                            -- Use the fundamental theorem of calculus to evaluate the integral\n                                            -- The antiderivative of x * 2 * exp(-2 * x) is -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                            -- Evaluate from 0 to \u221e: 0 - (-1/2) = 1/2\n                                            -- This can be verified by taking the derivative of -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                            -- and confirming it equals x * 2 * exp(-2 * x)\n                                            -- Alternatively, use integration by parts:\n                                            -- Let u = x, dv = 2 * exp(-2 * x) dx, then du = dx, v = -exp(-2 * x)\n                                            -- \u222b u dv = uv - \u222b v du = -x * exp(-2 * x) + \u222b exp(-2 * x) dx = -x * exp(-2 * x) - (1/2) * exp(-2 * x)\n                                            -- Then evaluate from 0 to \u221e.\n                                            -- This can be done using the `integral_comp_mul_left` lemma in Lean.\n                                            have h\u2082\u2083 : \u222b (x : \u211d) in (0 : \u211d)..(\u221e : \u211d), (x : \u211d) * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n                                              -- Use the fundamental theorem of calculus to evaluate the integral\n                                              norm_num [integral_comp_mul_left (fun x => x * Real.exp (-x))]\n                                              <;>\n                                              simp [Real.exp_neg]\n                                              <;>\n                                              norm_num\n                                              <;>\n                                              field_simp [Real.exp_ne_zero]\n                                              <;>\n                                              ring_nf\n                                              <;>\n                                              norm_num\n                                              <;>\n                                              linarith [Real.exp_pos 0]\n                                            exact h\u2082\u2083\n                                          exact h\u2082\u2082\n                                        exact h\u2082\u2081\n                                      exact h\u2082\u2080\n                                    exact h\u2081\u2089\n                                  exact h\u2081\u2088\n                                exact h\u2081\u2087\n                              exact h\u2081\u2086\n                            exact h\u2081\u2085\n                          exact h\u2081\u2084\n                        exact h\u2081\u2083\n                      exact h\u2081\u2082\n                    exact h\u2081\u2081\n                  exact h\u2081\u2080\n                exact h\u2089\n              exact h\u2088\n            exact h\u2087\n          exact h\u2086\n        rw [h\u2085]\n      exact h\u2082\n    -- Derive False from the assumption that the original statement is true\n    have h\u2082 : False := by\n      -- Use the fact that the integral is 1/2 to derive a contradiction\n      -- However, this is not possible because the integral is indeed 1/2\n      -- So we need to find another approach\n      -- Instead, we can use the fact that the integral of x * (2 * exp(-2 * x)) from 0 to \u221e is 1/2\n      -- and use this to show that the original statement is true, which contradicts the assumption that it is false\n      -- But this is not directly useful, so we need to find another approach\n      -- Alternatively, we can try to find a specific function f and lambda that satisfy the conditions but the integral is not 1/2\n      -- However, we have already shown that for the given conditions, the integral is 1/2\n      -- So we cannot find such a function f and lambda\n      -- Therefore, we cannot derive False from the assumption that the original statement is true\n      -- So we need to find another approach\n      -- The only way to derive False is to find a contradiction in the assumptions or in the conclusion\n      -- But the assumptions are correct and the conclusion is correct\n      -- Therefore, we cannot derive False\n      -- So we need to find another approach\n      -- However, we are asked to disprove the original statement, which means that we need to find a way to show that the original statement is false\n      -- But the original statement is true, so we cannot do this\n      -- Therefore, we cannot derive False\n      exfalso\n      have h\u2083 := h\u2081 (fun x => 2 * Real.exp (-2 * x)) 2 (by norm_num)\n      have h\u2084 := h\u2083 (by\n        intro x hx\n        simp [hx]\n        <;> ring_nf\n        <;>\n        simp_all [Real.exp_neg]\n        <;>\n        field_simp [Real.exp_neg]\n        <;>\n        ring_nf\n      ) (by\n        intro x hx\n        simp [hx]\n        <;> ring_nf\n        <;>\n        simp_all [Real.exp_neg]\n        <;>\n        field_simp [Real.exp_neg]\n        <;>\n        ring_nf\n      )\n      norm_num [intervalIntegral.integral_of_le (by norm_num : (0 : \u211d) \u2264 \u221e)] at h\u2084\n      <;>\n      simp_all [Set.Ici]\n      <;>\n      norm_num at *\n      <;>\n      linarith [Real.exp_pos 0]\n    exact h\u2082\n  \n  have h_contradiction : \u00ac (\u2200 (f : \u211d \u2192 \u211d) (lambda : \u211d), (lambda = 2) \u2192 (\u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x)) \u2192 (\u2200 x : \u211d, x < 0 \u2192 f x = 0) \u2192 (\u222b x in Set.Ici 0, x * f x) = 1/2) := by\n    exfalso\n    exact h_main\n  \n  exact h_contradiction"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, the expected value is $E[X] = 1/2$.", "statement": "We assume:\n\u2022 $E[X] = \\int_0^\\infty 2x e^{-2x} dx$ [l2];\n\u2022 The integral $\\int_0^\\infty 2x e^{-2x} dx$ evaluates to $1/2$ [l3].\nTherefore, we conclude:\n\u2022 $E[X] = 1/2$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (E_X : \u211d)\n  (h1 : E_X = \u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x))\n  (h2 : \u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x) = 1/2) :\n  E_X = 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (E_X : \u211d)\n  (h1 : E_X = \u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x))\n  (h2 : \u222b x in Set.Ici 0, 2 * x * Real.exp (-2 * x) = 1/2) :\n  E_X = 1/2 := by\n  have h3 : E_X = 1 / 2 := by\n    rw [h1]\n    rw [h2]\n    <;> norm_num\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The expected value definition is correctly formalized with appropriate Lean syntax for the integral over [0,\u221e) and the exponential function", "The integral evaluation statement is accurately translated with the same mathematical expression and result", "The conclusion E[X] = 1/2 is properly represented as the theorem goal", "The logical structure correctly captures the deductive reasoning from the two premises to the conclusion using transitivity of equality"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "def_2": {"id": "def_2", "natural_language": "To find the variance, we first need the second moment $E[X^2] = \\int_0^\\infty x^2 f(x) dx$", "statement": "We assume:\n\u2022 All previous steps [tc_1, tc_2, l1, def_1, l2, l3, ts_1].\nDefinition:\n\u2022 The second moment of $X$ is $E[X^2] = \\int_0^\\infty x^2 f(x) dx$ for a non-negative random variable [def_2].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  \u222b x in Set.Ici 0, x^2 * f x = 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language refers to 'all previous steps' as a condition, but the Lean theorem doesn't reference these previous steps at all. Instead, it introduces specific conditions about lambda and the exponential form of f(x).", "The natural language states 'X is a non-negative random variable' but the Lean theorem doesn't declare any random variable X. Instead, it works directly with a function f and specifies its exponential form.", "The natural language states 'f(x) is the probability density function of X' as a general condition, but the Lean theorem specifically defines f(x) as an exponential function with lambda = 2, which is much more restrictive than a general PDF.", "The natural language conclusion is a general definition stating that the second moment equals the integral formula. However, the Lean theorem concludes with a specific numerical result (1/2) for a particular exponential distribution, rather than establishing the general definitional relationship."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language refers to 'all previous steps' as a condition, but the Lean theorem doesn't reference these previous steps at all. Instead, it introduces specific conditions about lambda and the exponential form of f(x).\", \"The natural language states 'X is a non-negative random variable' but the Lean theorem doesn't declare any random variable X. Instead, it works directly with a function f and specifies its exponential form.\", \"The natural language states 'f(x) is the probability density function of X' as a general condition, but the Lean theorem specifically defines f(x) as an exponential function with lambda = 2, which is much more restrictive than a general PDF.\", 'The natural language conclusion is a general definition stating that the second moment equals the integral formula. However, the Lean theorem concludes with a specific numerical result (1/2) for a particular exponential distribution, rather than establishing the general definitional relationship.']"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "$E[X^2] = \\int_0^\\infty x^2 f(x) dx = \\int_0^\\infty 2x^2 e^{-2x} dx$.", "statement": "We assume:\n\u2022 The specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \\ge 0$ and $f(x)=0$ for $x < 0$ [l1];\n\u2022 The second moment of $X$ is $E[X^2] = \\int_0^\\infty x^2 f(x) dx$ [def_2].\nTherefore, we conclude:\n\u2022 $E[X^2] = \\int_0^\\infty 2x^2 e^{-2x} dx$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) := by\n  have h4 : \u2200 (x : \u211d), x \u2208 Set.Ici (0 : \u211d) \u2192 x^2 * f x = x^2 * (2 * Real.exp (-2 * x)) := by\n    intro x hx\n    have h5 : x \u2265 0 := by\n      simp only [Set.mem_Ici] at hx\n      exact hx\n    have h6 : f x = lambda * Real.exp (-lambda * x) := h2 x h5\n    have h7 : f x = 2 * Real.exp (-2 * x) := by\n      rw [h6]\n      rw [h1]\n      <;> ring_nf\n      <;> simp [Real.exp_neg]\n      <;> field_simp [Real.exp_neg]\n      <;> ring_nf\n    calc\n      x ^ 2 * f x = x ^ 2 * (2 * Real.exp (-2 * x)) := by rw [h7]\n      _ = x ^ 2 * (2 * Real.exp (-2 * x)) := by rfl\n  \n  have h5 : \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) := by\n    have h6 : \u222b x in Set.Ici (0 : \u211d), x^2 * f x = \u222b x in Set.Ici (0 : \u211d), x^2 * (2 * Real.exp (-2 * x)) := by\n      -- Use the fact that the functions are equal on the set to show the integrals are equal\n      have h7 : \u2200 x \u2208 Set.Ici (0 : \u211d), x^2 * f x = x^2 * (2 * Real.exp (-2 * x)) := by\n        intro x hx\n        exact h4 x hx\n      -- Use the set_integral_congr lemma to show the integrals are equal\n      have h8 : \u222b x in Set.Ici (0 : \u211d), x^2 * f x = \u222b x in Set.Ici (0 : \u211d), x^2 * (2 * Real.exp (-2 * x)) := by\n        -- Use the fact that the functions are equal on the set to show the integrals are equal\n        have h9 : (fun x : \u211d => x^2 * f x) =\u1d50[MeasureTheory.ae_restrict (measurableSet_Ici : MeasurableSet (Set.Ici (0 : \u211d)))] (fun x : \u211d => x^2 * (2 * Real.exp (-2 * x))) := by\n          filter_upwards [self_mem_ae_restrict (measurableSet_Ici : MeasurableSet (Set.Ici (0 : \u211d)))] with x hx using by\n            have h10 : x \u2208 Set.Ici (0 : \u211d) := hx\n            have h11 : x^2 * f x = x^2 * (2 * Real.exp (-2 * x)) := h7 x h10\n            exact h11\n        -- Use the fact that the functions are equal almost everywhere to conclude the integrals are equal\n        have h10 : \u222b x in Set.Ici (0 : \u211d), x^2 * f x = \u222b x in Set.Ici (0 : \u211d), x^2 * (2 * Real.exp (-2 * x)) := by\n          apply MeasureTheory.set_integral_congr_ae (measurableSet_Ici : MeasurableSet (Set.Ici (0 : \u211d)))\n          exact h9\n        exact h10\n      exact h8\n    -- Conclude the proof by using the established equality\n    simpa using h6\n  \n  exact h5", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 36, "column": 46, "endLine": 36, "endColumn": 71, "data": "unknown identifier 'MeasureTheory.ae_restrict'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The PDF definition is correctly formalized using lambda parameter and appropriate conditions for both non-negative and negative domains", "The second moment integral is properly represented using Set.Ici 0 for the integration domain [0,\u221e) and correct integrand structure", "The conclusion correctly substitutes the specific PDF form into the integral, maintaining mathematical equivalence", "The overall theorem structure logically connects the assumptions to the conclusion, establishing the desired equality through proper substitution", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) := by\n  have h_main : \u2200 (x : \u211d), x \u2208 Set.Ici 0 \u2192 x^2 * f x = x^2 * (2 * Real.exp (-2 * x)) := by\n    intro x hx\n    have h4 : x \u2265 0 := by exact hx\n    have h5 : f x = lambda * Real.exp (-lambda * x) := h2 x h4\n    have h6 : lambda = 2 := h1\n    rw [h5, h6]\n    have h7 : (2 : \u211d) * Real.exp (-(2 : \u211d) * x) = 2 * Real.exp (-2 * x) := by ring_nf\n    rw [h7]\n    <;>\n    (try norm_num) <;>\n    (try ring_nf) <;>\n    (try simp_all [Set.mem_Ici]) <;>\n    (try norm_num) <;>\n    (try linarith)\n  \n  have h_integral_eq : \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) := by\n    have h4 : \u2200 (x : \u211d), x \u2208 Set.Ici 0 \u2192 x^2 * f x = x^2 * (2 * Real.exp (-2 * x)) := h_main\n    have h5 : \u222b x in Set.Ici 0, x ^ 2 * f x = \u222b x in Set.Ici 0, x ^ 2 * (2 * Real.exp (-2 * x)) := by\n      -- Use the fact that the functions are equal on [0, \u221e)\n      apply set_integral_congr\n      <;> intro x hx\n      <;> have h7 : x \u2208 Set.Ici 0 := hx\n      <;> have h8 : x ^ 2 * f x = x ^ 2 * (2 * Real.exp (-2 * x)) := h4 x h7\n      <;> simp_all [h8]\n    exact h5\n  \n  apply h_integral_eq"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Evaluating this integral using integration by parts yields $E[X^2] = 1/2$.", "statement": "We assume:\n\u2022 $E[X^2] = \\int_0^\\infty 2x^2 e^{-2x} dx$ [l4].\nTherefore, we conclude:\n\u2022 $E[X^2] = 1/2$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (l4 : \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x))) :\n  \u222b x in Set.Ici 0, x^2 * f x = 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (l4 : \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x))) :\n  \u222b x in Set.Ici 0, x^2 * f x = 1/2 := by\n  have h_integral : \u222b (x : \u211d) in Set.Ici 0, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n    have h\u2081 : \u222b (x : \u211d) in Set.Ici 0, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) := by\n      -- The integral over [0, \u221e) is equal to the integral from 0 to \u221e in the interval integral sense.\n      simp [MeasureTheory.integral_Ici_eq_integral_Ioi, Real.volume_Ioi, intervalIntegral.integral_of_le (by norm_num : (0 : \u211d) \u2264 \u221e)]\n      <;>\n      congr 1 <;>\n      ext1 x <;>\n      simp [Real.exp_neg] <;>\n      ring_nf <;>\n      field_simp <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith\n    rw [h\u2081]\n    -- Compute the integral using the fundamental theorem of calculus\n    have h\u2082 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = 1 / 2 := by\n      -- Use the fact that the integral of x^2 * exp(-2x) from 0 to \u221e is 1/4\n      have h\u2083 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = 2 * \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) := by\n        -- Factor out the constant 2 from the integral\n        have h\u2084 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = \u222b (x : \u211d) in (0 : \u211d)..\u221e, 2 * ((x : \u211d)^2 * Real.exp (-2 * x)) := by\n          congr\n          ext x\n          ring\n        rw [h\u2084]\n        -- Use the linearity of the integral to factor out the constant 2\n        have h\u2085 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (2 : \u211d) * ((x : \u211d)^2 * Real.exp (-2 * x)) = 2 * \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) := by\n          -- Use the linearity of the integral\n          simp [intervalIntegral.integral_comp_mul_left (fun x => (x : \u211d)^2 * Real.exp (-2 * x))]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          field_simp\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith\n        rw [h\u2085]\n      rw [h\u2083]\n      -- Compute the integral of x^2 * exp(-2x) from 0 to \u221e\n      have h\u2084 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n        -- Use the fundamental theorem of calculus to compute the integral\n        have h\u2085 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n          -- Use the fundamental theorem of calculus to compute the integral\n          have h\u2086 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n            -- Use the fundamental theorem of calculus to compute the integral\n            have h\u2087 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n              -- Use the fundamental theorem of calculus to compute the integral\n              have h\u2088 : \u222b (x : \u211d) in (0 : \u211d)..(100 : \u211d), (x : \u211d)^2 * Real.exp (-2 * x) = (-(100 : \u211d)^2 / 2 - (100 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (100 : \u211d)) + 1 / 4 := by\n                -- Compute the integral from 0 to 100 using the antiderivative\n                norm_num [intervalIntegral.integral_comp_mul_left (fun x => (x : \u211d)^2 * Real.exp (-2 * x))]\n                <;>\n                ring_nf\n                <;>\n                norm_num\n                <;>\n                field_simp [Real.exp_neg]\n                <;>\n                ring_nf\n                <;>\n                norm_num\n                <;>\n                linarith [Real.exp_pos (-200 : \u211d)]\n              have h\u2089 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n                -- Take the limit as the upper bound approaches infinity\n                have h\u2081\u2080 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n                  -- Use the fact that the integral from 0 to infinity is 1/4\n                  have h\u2081\u2081 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n                    -- Use the fundamental theorem of calculus to compute the integral\n                    have h\u2081\u2082 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n                      -- Use the fundamental theorem of calculus to compute the integral\n                      have h\u2081\u2083 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n                        -- Use the fundamental theorem of calculus to compute the integral\n                        have h\u2081\u2084 : \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 1 / 4 := by\n                          -- Use the fundamental theorem of calculus to compute the integral\n                          have h\u2081\u2085 : \u2200 (b : \u211d), \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                            intro b\n                            have h\u2081\u2086 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                              -- Use the fundamental theorem of calculus to compute the integral\n                              have h\u2081\u2087 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                                -- Use the fundamental theorem of calculus to compute the integral\n                                have h\u2081\u2088 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                                  -- Use the fundamental theorem of calculus to compute the integral\n                                  have h\u2081\u2089 : (\u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x)) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                                    -- Use the fundamental theorem of calculus to compute the integral\n                                    have h\u2082\u2080 : (\u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x)) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                                      -- Use the fundamental theorem of calculus to compute the integral\n                                      have h\u2082\u2081 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((b : \u211d)^2 * Real.exp (-2 * (b : \u211d))) b := by\n                                        -- Compute the derivative of the antiderivative\n                                        have h\u2082\u2082 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((b : \u211d)^2 * Real.exp (-2 * (b : \u211d))) b := by\n                                          -- Compute the derivative of the antiderivative\n                                          have h\u2082\u2083 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4)) (-(b : \u211d) - 1 / 2) b := by\n                                            -- Compute the derivative of the polynomial part\n                                            have h\u2082\u2084 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4)) (-(b : \u211d) - 1 / 2) b := by\n                                              -- Compute the derivative of the polynomial part\n                                              simpa using ((hasDerivAt_pow 2 b).const_mul (-1 / 2)).sub ((hasDerivAt_id b).const_mul (1 / 2)).sub (hasDerivAt_const b (1 / 4))\n                                            exact h\u2082\u2084\n                                          have h\u2082\u2085 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (-2 * Real.exp (-2 * (b : \u211d))) b := by\n                                            -- Compute the derivative of the exponential part\n                                            have h\u2082\u2086 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (-2 * Real.exp (-2 * (b : \u211d))) b := by\n                                              -- Compute the derivative of the exponential part\n                                              have h\u2082\u2087 : HasDerivAt (fun x : \u211d => (-2 : \u211d) * (x : \u211d)) (-2 : \u211d) b := by\n                                                simpa using (hasDerivAt_id b).const_mul (-2 : \u211d)\n                                              have h\u2082\u2088 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (Real.exp (-2 * (b : \u211d)) * (-2 : \u211d)) b := by\n                                                -- Use the chain rule to compute the derivative of the exponential part\n                                                have h\u2082\u2089 : HasDerivAt (fun x : \u211d => (-2 : \u211d) * (x : \u211d)) (-2 : \u211d) b := h\u2082\u2087\n                                                have h\u2083\u2080 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (Real.exp (-2 * (b : \u211d)) * (-2 : \u211d)) b := by\n                                                  -- Use the chain rule to compute the derivative of the exponential part\n                                                  simpa using (Real.hasDerivAt_exp (-2 * (b : \u211d))).comp b h\u2082\u2089\n                                                exact h\u2083\u2080\n                                              convert h\u2082\u2088 using 1 <;> ring_nf <;> simp [Real.exp_neg]\n                                              <;> field_simp <;> ring_nf <;> linarith\n                                            exact h\u2082\u2086\n                                          have h\u2083\u2081 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((-(b : \u211d) - 1 / 2) * Real.exp (-2 * (b : \u211d)) + (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * (-2 * Real.exp (-2 * (b : \u211d)))) b := by\n                                            -- Use the product rule to compute the derivative of the antiderivative\n                                            have h\u2083\u2082 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4)) (-(b : \u211d) - 1 / 2) b := h\u2082\u2083\n                                            have h\u2083\u2083 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (-2 * Real.exp (-2 * (b : \u211d))) b := h\u2082\u2085\n                                            have h\u2083\u2084 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((-(b : \u211d) - 1 / 2) * Real.exp (-2 * (b : \u211d)) + (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * (-2 * Real.exp (-2 * (b : \u211d)))) b := by\n                                              -- Use the product rule to compute the derivative of the antiderivative\n                                              convert h\u2083\u2082.mul h\u2083\u2083 using 1 <;>\n                                              ring_nf <;>\n                                              simp [Real.exp_neg] <;>\n                                              field_simp <;>\n                                              ring_nf <;>\n                                              linarith\n                                            exact h\u2083\u2084\n                                          have h\u2083\u2085 : ((-(b : \u211d) - 1 / 2) * Real.exp (-2 * (b : \u211d)) + (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * (-2 * Real.exp (-2 * (b : \u211d)))) = (b : \u211d)^2 * Real.exp (-2 * (b : \u211d)) := by\n                                            -- Simplify the expression to match the integrand\n                                            ring_nf at *\n                                            <;>\n                                            field_simp [Real.exp_neg] at *\n                                            <;>\n                                            ring_nf at *\n                                            <;>\n                                            nlinarith [Real.exp_pos (-2 * (b : \u211d))]\n                                          have h\u2083\u2086 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((b : \u211d)^2 * Real.exp (-2 * (b : \u211d))) b := by\n                                            -- Use the simplified expression to match the integrand\n                                            convert h\u2083\u2081 using 1 <;>\n                                            rw [h\u2083\u2085]\n                                          exact h\u2083\u2086\n                                        exact h\u2082\u2082\n                                      have h\u2083\u2087 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                                        -- Use the fundamental theorem of calculus to compute the integral\n                                        have h\u2083\u2088 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                          -- Use the fundamental theorem of calculus to compute the integral\n                                          have h\u2083\u2089 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                            -- Use the fundamental theorem of calculus to compute the integral\n                                            have h\u2084\u2080 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                              -- Use the fundamental theorem of calculus to compute the integral\n                                              have h\u2084\u2081 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                -- Use the fundamental theorem of calculus to compute the integral\n                                                have h\u2084\u2082 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                  -- Use the fundamental theorem of calculus to compute the integral\n                                                  have h\u2084\u2083 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                    -- Use the fundamental theorem of calculus to compute the integral\n                                                    have h\u2084\u2084 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                      -- Use the fundamental theorem of calculus to compute the integral\n                                                      have h\u2084\u2085 : (\u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x)) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                        -- Use the fundamental theorem of calculus to compute the integral\n                                                        have h\u2084\u2086 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                          -- Use the fundamental theorem of calculus to compute the integral\n                                                          have h\u2084\u2087 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((b : \u211d)^2 * Real.exp (-2 * (b : \u211d))) b := h\u2082\u2081\n                                                          have h\u2084\u2088 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                            -- Use the fundamental theorem of calculus to compute the integral\n                                                            have h\u2084\u2089 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                              -- Use the fundamental theorem of calculus to compute the integral\n                                                              have h\u2085\u2080 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                                -- Use the fundamental theorem of calculus to compute the integral\n                                                                have h\u2085\u2081 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                                  -- Use the fundamental theorem of calculus to compute the integral\n                                                                  have h\u2085\u2082 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                                    -- Use the fundamental theorem of calculus to compute the integral\n                                                                    have h\u2085\u2083 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                                      -- Use the fundamental theorem of calculus to compute the integral\n                                                                      have h\u2085\u2084 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                                        -- Use the fundamental theorem of calculus to compute the integral\n                                                                        have h\u2085\u2085 := intervalIntegral.integral_eq_sub_of_hasDerivAt (fun x hx => by\n                                                                          have h\u2085\u2086 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((x : \u211d)^2 * Real.exp (-2 * (x : \u211d))) x := by\n                                                                            have h\u2085\u2087 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4)) (-(x : \u211d) - 1 / 2) x := by\n                                                                              simpa using ((hasDerivAt_pow 2 x).const_mul (-1 / 2)).sub ((hasDerivAt_id x).const_mul (1 / 2)).sub (hasDerivAt_const x (1 / 4))\n                                                                            have h\u2085\u2088 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (-2 * Real.exp (-2 * (x : \u211d))) x := by\n                                                                              have h\u2085\u2089 : HasDerivAt (fun x : \u211d => (-2 : \u211d) * (x : \u211d)) (-2 : \u211d) x := by\n                                                                                simpa using (hasDerivAt_id x).const_mul (-2 : \u211d)\n                                                                              have h\u2086\u2080 : HasDerivAt (fun x : \u211d => Real.exp (-2 * (x : \u211d))) (Real.exp (-2 * (x : \u211d)) * (-2 : \u211d)) x := by\n                                                                                simpa using (Real.hasDerivAt_exp (-2 * (x : \u211d))).comp x h\u2085\u2089\n                                                                              convert h\u2086\u2080 using 1 <;> ring_nf <;> simp [Real.exp_neg]\n                                                                              <;> field_simp <;> ring_nf <;> linarith\n                                                                            have h\u2086\u2081 : HasDerivAt (fun x : \u211d => (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (x : \u211d))) ((-(x : \u211d) - 1 / 2) * Real.exp (-2 * (x : \u211d)) + (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * (-2 * Real.exp (-2 * (x : \u211d)))) x := by\n                                                                              convert h\u2085\u2087.mul h\u2085\u2088 using 1 <;> ring_nf <;> simp [Real.exp_neg] <;> field_simp <;> ring_nf <;> linarith\n                                                                            have h\u2086\u2082 : ((-(x : \u211d) - 1 / 2) * Real.exp (-2 * (x : \u211d)) + (-(x : \u211d)^2 / 2 - (x : \u211d) / 2 - 1 / 4) * (-2 * Real.exp (-2 * (x : \u211d)))) = (x : \u211d)^2 * Real.exp (-2 * (x : \u211d)) := by\n                                                                              ring_nf at *\n                                                                              <;>\n                                                                              field_simp [Real.exp_neg] at *\n                                                                              <;>\n                                                                              ring_nf at *\n                                                                              <;>\n                                                                              nlinarith [Real.exp_pos (-2 * (x : \u211d))]\n                                                                            convert h\u2086\u2081 using 1 <;> rw [h\u2086\u2082]\n                                                                          exact h\u2085\u2086) (by\n                                                                            continuity\n                                                                          )\n                                                                        have h\u2086\u2083 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) - (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) := by\n                                                                          -- Use the fundamental theorem of calculus to compute the integral\n                                                                          simpa [sub_eq_add_neg] using h\u2085\u2085\n                                                                        exact h\u2086\u2083\n                                                                      exact h\u2085\u2084\n                                                                    exact h\u2085\u2083\n                                                                  exact h\u2085\u2082\n                                                                exact h\u2085\u2081\n                                                              exact h\u2085\u2080\n                                                            exact h\u2084\u2089\n                                                          exact h\u2084\u2088\n                                                        exact h\u2084\u2086\n                                                      exact h\u2084\u2085\n                                                    exact h\u2084\u2084\n                                                  exact h\u2084\u2083\n                                                exact h\u2084\u2082\n                                              exact h\u2084\u2081\n                                            exact h\u2084\u2080\n                                          exact h\u2083\u2089\n                                        exact h\u2083\u2088\n                                      have h\u2084\u2080 : (-( (0 : \u211d)^2 / 2 - (0 : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (0 : \u211d))) = -1 / 4 := by\n                                        -- Simplify the expression at the lower bound\n                                        norm_num [Real.exp_zero]\n                                        <;>\n                                        ring_nf at *\n                                        <;>\n                                        norm_num at *\n                                        <;>\n                                        linarith\n                                      have h\u2084\u2081 : \u222b (x : \u211d) in (0 : \u211d)..b, (x : \u211d)^2 * Real.exp (-2 * x) = (-(b : \u211d)^2 / 2 - (b : \u211d) / 2 - 1 / 4) * Real.exp (-2 * (b : \u211d)) + 1 / 4 := by\n                                        -- Combine the results to get the final expression\n                                        linarith\n                                      exact h\u2084\u2081\n                                    exact h\u2083\u2087\n                                  exact h\u2081\u2089\n                                exact h\u2081\u2088\n                              exact h\u2081\u2087\n                            exact h\u2081\u2086\n                          have h\u2082\u2080 := h\u2081\u2085 (100 : \u211d)\n                          norm_num at h\u2082\u2080 \u22a2\n                          <;>\n                          linarith\n                        exact h\u2081\u2084\n                      exact h\u2081\u2083\n                    exact h\u2081\u2082\n                  exact h\u2081\u2081\n                exact h\u2081\u2080\n              exact h\u2089\n            exact h\u2087\n          exact h\u2086\n        exact h\u2085\n      have h\u2085 : 2 * \u222b (x : \u211d) in (0 : \u211d)..\u221e, (x : \u211d)^2 * Real.exp (-2 * x) = 2 * (1 / 4 : \u211d) := by\n        rw [h\u2084]\n        <;> ring_nf\n      have h\u2086 : 2 * (1 / 4 : \u211d) = 1 / 2 := by norm_num\n      linarith\n    rw [h\u2082]\n  \n  have h_main : \u222b x in Set.Ici 0, x^2 * f x = 1 / 2 := by\n    calc\n      \u222b x in Set.Ici 0, x ^ 2 * f x = \u222b x in Set.Ici 0, x ^ 2 * (2 * Real.exp (-2 * x)) := by\n        rw [l4]\n      _ = \u222b (x : \u211d) in Set.Ici 0, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) := by\n        simp [pow_two]\n      _ = 1 / 2 := by\n        rw [h_integral]\n        <;> simp [pow_two]\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 4}, "score": {"semantic_score": 0, "semantic_feedback": ["The premise is correctly captured. The natural language assumption that E[X\u00b2] equals the integral \u222b\u2080^\u221e 2x\u00b2e^{-2x} dx is properly formalized in Lean as l4, with E[X\u00b2] represented as \u222b x in Set.Ici 0, x^2 * f x and the right-hand side correctly matching the given integral expression.", "The conclusion is perfectly captured. Both the natural language and Lean formalization conclude that E[X\u00b2] = 1/2, using consistent representations. The additional hypotheses in Lean (h1, h2, h3) provide helpful mathematical context by defining f as an exponential distribution density function, which is logically consistent and doesn't contradict the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (l4 : \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x))) :\n  \u222b x in Set.Ici 0, x^2 * f x = 1/2 := by\n  have h5 : \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) = 1/2 := by\n    have h\u2080 : \u222b x in Set.Ici (0 : \u211d), (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) := by\n      simp [intervalIntegral.integral_of_le (by norm_num : (0 : \u211d) \u2264 \u221e)]\n      <;>\n      simp_all [Real.volume_Ici]\n      <;>\n      norm_num\n    rw [h\u2080]\n    have h\u2081 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n      have h\u2082 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n        -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n        -- This can be derived using integration by parts or by recognizing it as a known integral\n        have h\u2083 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n          -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n          -- This can be derived using integration by parts or by recognizing it as a known integral\n          -- For simplicity, we use the fact that the integral is 1/2\n          have h\u2084 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n            -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n            -- This can be derived using integration by parts or by recognizing it as a known integral\n            -- For simplicity, we use the fact that the integral is 1/2\n            have h\u2085 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n              -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n              -- This can be derived using integration by parts or by recognizing it as a known integral\n              -- For simplicity, we use the fact that the integral is 1/2\n              have h\u2086 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n                -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n                -- This can be derived using integration by parts or by recognizing it as a known integral\n                -- For simplicity, we use the fact that the integral is 1/2\n                have h\u2087 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n                  -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n                  -- This can be derived using integration by parts or by recognizing it as a known integral\n                  -- For simplicity, we use the fact that the integral is 1/2\n                  have h\u2088 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n                    -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n                    -- This can be derived using integration by parts or by recognizing it as a known integral\n                    -- For simplicity, we use the fact that the integral is 1/2\n                    have h\u2089 : \u222b x in (0 : \u211d)..\u221e, (x : \u211d)^2 * (2 * Real.exp (-2 * x)) = (1 / 2 : \u211d) := by\n                      -- Use the fact that the integral of x^2 * 2 * exp(-2x) from 0 to \u221e is 1/2\n                      -- This can be derived using integration by parts or by recognizing it as a known integral\n                      -- For simplicity, we use the fact that the integral is 1/2\n                      norm_num [mul_comm]\n                      <;>\n                      simp [intervalIntegral.integral_comp_mul_left (fun x => x ^ 2 * Real.exp (-x))]\n                      <;>\n                      norm_num\n                      <;>\n                      ring_nf\n                      <;>\n                      norm_num\n                      <;>\n                      field_simp\n                      <;>\n                      norm_num\n                      <;>\n                      linarith [Real.exp_pos 0]\n                    exact h\u2089\n                  exact h\u2088\n                exact h\u2087\n              exact h\u2086\n            exact h\u2085\n          exact h\u2084\n        exact h\u2083\n      exact h\u2082\n    rw [h\u2081]\n    <;> norm_num\n  \n  have h6 : \u222b x in Set.Ici 0, x^2 * f x = 1/2 := by\n    have h\u2080 : \u222b x in Set.Ici 0, x^2 * f x = \u222b x in Set.Ici 0, x^2 * (2 * Real.exp (-2 * x)) := by\n      apply l4\n    rw [h\u2080]\n    rw [h5]\n    <;> norm_num\n  \n  apply h6"}, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "The variance is then $Var(X) = E[X^2] - (E[X])^2$", "statement": "We assume:\n\u2022 All previous steps [tc_1, tc_2, l1, def_1, l2, l3, ts_1, def_2, l4, l5].\nDefinition:\n\u2022 The variance of $X$ is $Var(X) = E[X^2] - (E[X])^2$ [def_3].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (E_X : \u211d) (h4 : E_X = \u222b x in Set.Ici 0, x * f x)\n  (E_X2 : \u211d) (h5 : E_X2 = \u222b x in Set.Ici 0, x^2 * f x) :\n  E_X2 - E_X^2 = 1/4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language condition refers to 'All previous steps [tc_1, tc_2, l1, def_1, l2, l3, ts_1, def_2, l4, l5]' which is a general reference to prior work. However, the Lean formalization introduces very specific conditions about an exponential distribution with lambda=2, a specific function f, and specific definitions of E_X and E_X2. These are concrete mathematical conditions that are not mentioned in the natural language statement.", "The natural language conclusion states a general definition: 'The variance of X is Var(X) = E[X^2] - (E[X])^2', which is the standard formula for variance. However, the Lean formalization concludes with a specific numerical result 'E_X2 - E_X^2 = 1/4', which is a concrete calculation rather than a general definition. The Lean version is proving that for this specific exponential distribution, the variance equals 1/4, not defining what variance is in general."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language condition refers to 'All previous steps [tc_1, tc_2, l1, def_1, l2, l3, ts_1, def_2, l4, l5]' which is a general reference to prior work. However, the Lean formalization introduces very specific conditions about an exponential distribution with lambda=2, a specific function f, and specific definitions of E_X and E_X2. These are concrete mathematical conditions that are not mentioned in the natural language statement.\", \"The natural language conclusion states a general definition: 'The variance of X is Var(X) = E[X^2] - (E[X])^2', which is the standard formula for variance. However, the Lean formalization concludes with a specific numerical result 'E_X2 - E_X^2 = 1/4', which is a concrete calculation rather than a general definition. The Lean version is proving that for this specific exponential distribution, the variance equals 1/4, not defining what variance is in general.\"]"}, "type": "definition"}, "ts_2": {"id": "ts_2", "natural_language": "$Var(X) = E[X^2] - (E[X])^2 = 1/2 - (1/2)^2 = 1/4$.", "statement": "We assume:\n\u2022 $E[X] = 1/2$ [ts_1];\n\u2022 $E[X^2] = 1/2$ [l5];\n\u2022 The variance of $X$ is $Var(X) = E[X^2] - (E[X])^2$ [def_3].\nTherefore, we conclude:\n\u2022 $Var(X) = 1/4$ [ts_2].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2", "l4", "l5", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (E_X : \u211d) (E_X2 : \u211d) (Var_X : \u211d)\n  (ts_1 : E_X = 1/2)\n  (l5 : E_X2 = 1/2)\n  (def_3 : Var_X = E_X2 - E_X^2) :\n  Var_X = 1/4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (E_X : \u211d) (E_X2 : \u211d) (Var_X : \u211d)\n  (ts_1 : E_X = 1/2)\n  (l5 : E_X2 = 1/2)\n  (def_3 : Var_X = E_X2 - E_X^2) :\n  Var_X = 1/4 := by\n  have h_E_X_sq : E_X ^ 2 = 1 / 4 := by\n    rw [ts_1]\n    norm_num\n    <;>\n    ring_nf\n    <;>\n    norm_num\n  \n  have h_main : Var_X = 1 / 4 := by\n    rw [def_3]\n    rw [l5]\n    rw [h_E_X_sq]\n    <;> norm_num\n    <;>\n    ring_nf\n    <;>\n    norm_num\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and assumptions are correctly formalized with appropriate real number types and corresponding hypotheses", "All mathematical relationships from the natural language are accurately captured in Lean, with appropriate notational adaptations (E_X for E[X], E_X2 for E[X\u00b2], etc.)", "The conclusion Var_X = 1/4 perfectly matches the natural language conclusion Var(X) = 1/4"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "def_4": {"id": "def_4", "natural_language": "Finally, the probability $P(X > 1)$ is found by integrating the PDF from $1$ to $\\infty$", "statement": "We assume:\n\u2022 All previous steps [tc_1, tc_2, l1, def_1, l2, l3, ts_1, def_2, l4, l5, def_3, ts_2].\nDefinition:\n\u2022 The probability $P(X > a)$ is given by $\\int_a^\\infty f(x) dx$ [def_4].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2", "l4", "l5", "def_3", "ts_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem exponential_dist \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0)\n  (h4 : \u222b x in Set.Ici 0, f x = 1) :\n  (\u222b x in Set.Ici 0, x * f x = 1/2) \u2227 \n  (\u222b x in Set.Ici 0, x^2 * f x - (1/2)^2 = 1/4) \u2227\n  (\u222b x in Set.Ici 1, f x = Real.exp (-2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean theorem provides specific mathematical conditions (lambda = 2, exponential distribution definition, normalization) while the natural language only references 'all previous steps' without specifying what those steps contain. There's no way to verify if the Lean conditions correspond to the referenced steps.", "The natural language concludes with a general definition of tail probability P(X > a) = \u222b_a^\u221e f(x) dx, but the Lean theorem concludes with three specific numerical calculations: expectation = 1/2, variance = 1/4, and P(X > 1) = exp(-2). The Lean theorem doesn't establish the general probability formula stated in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean theorem provides specific mathematical conditions (lambda = 2, exponential distribution definition, normalization) while the natural language only references 'all previous steps' without specifying what those steps contain. There's no way to verify if the Lean conditions correspond to the referenced steps.\", \"The natural language concludes with a general definition of tail probability P(X > a) = \u222b_a^\u221e f(x) dx, but the Lean theorem concludes with three specific numerical calculations: expectation = 1/2, variance = 1/4, and P(X > 1) = exp(-2). The Lean theorem doesn't establish the general probability formula stated in the natural language.\"]"}, "type": "definition"}, "l6": {"id": "l6", "natural_language": "which is $\\int_1^\\infty 2e^{-2x} dx$", "statement": "We assume:\n\u2022 The specific PDF of $X$ is $f(x) = 2e^{-2x}$ for $x \\ge 0$ [l1];\n\u2022 The probability $P(X > a)$ is given by $\\int_a^\\infty f(x) dx$ [def_4].\nTherefore, we conclude:\n\u2022 $P(X > 1) = \\int_1^\\infty 2e^{-2x} dx$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2", "l4", "l5", "def_3", "ts_2", "def_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  \u222b x in Set.Ici 1, f x = \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (f : \u211d \u2192 \u211d) (lambda : \u211d)\n  (h1 : lambda = 2)\n  (h2 : \u2200 x : \u211d, x \u2265 0 \u2192 f x = lambda * Real.exp (-lambda * x))\n  (h3 : \u2200 x : \u211d, x < 0 \u2192 f x = 0) :\n  \u222b x in Set.Ici 1, f x = \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) := by\n  have h_main : \u2200 (x : \u211d), x \u2208 Set.Ici 1 \u2192 f x = 2 * Real.exp (-2 * x) := by\n    intro x hx\n    have h4 : x \u2265 1 := by exact hx\n    have h5 : x \u2265 0 := by linarith\n    have h6 : f x = lambda * Real.exp (-lambda * x) := h2 x h5\n    have h7 : lambda = 2 := h1\n    rw [h6, h7]\n    <;> ring_nf\n    <;> field_simp [Real.exp_neg]\n    <;> ring_nf\n    <;> simp_all [Real.exp_neg]\n    <;> field_simp [Real.exp_neg]\n    <;> ring_nf\n  \n  have h_final : \u222b x in Set.Ici 1, f x = \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) := by\n    -- Use the fact that the functions are equal on the set to show their integrals are equal\n    have h8 : \u222b x in Set.Ici (1 : \u211d), f x = \u222b x in Set.Ici (1 : \u211d), 2 * Real.exp (-2 * x) := by\n      -- Apply the lemma that if two functions are equal on a set, their integrals over that set are equal\n      apply MeasureTheory.set_integral_congr (by\n        -- Prove that the set is measurable\n        exact measurableSet_Ici) (by\n        -- Prove that the functions are equal on the set\n        intro x hx\n        have h9 : x \u2208 Set.Ici (1 : \u211d) := hx\n        have h10 : f x = 2 * Real.exp (-2 * x) := h_main x h9\n        exact h10)\n    exact h8\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The PDF definition is correctly captured through hypotheses h1, h2, and h3. The additional condition for negative x values is a reasonable extension.", "The general probability definition P(X > a) = \u222b_a^\u221e f(x) dx is not explicitly stated in the Lean hypotheses, though it's implicitly used in the conclusion.", "The conclusion is correctly formalized, with Set.Ici 1 properly representing the integration from 1 to infinity, and the integral expressions matching the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_3": {"id": "ts_3", "natural_language": "$\\int_1^\\infty 2e^{-2x} dx = e^{-2}$.", "statement": "We assume:\n\u2022 $P(X > 1) = \\int_1^\\infty 2e^{-2x} dx$ [l6].\nTherefore, we conclude:\n\u2022 $P(X > 1) = e^{-2}$ [ts_3].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "ts_1", "def_2", "l4", "l5", "def_3", "ts_2", "def_4", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = Real.exp (-2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n  have h_main : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n    have h\u2080 : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) := by\n      simp [Real.volume_Ici]\n      <;>\n      simp_all [MeasureTheory.integral_Ici_eq_integral_Ioc]\n      <;>\n      congr 1 <;>\n      ext1 x <;>\n      simp [le_of_lt] <;>\n      <;>\n      ring_nf <;>\n      <;>\n      norm_num <;>\n      <;>\n      linarith\n    rw [h\u2080]\n    -- Compute the integral using the fundamental theorem of calculus\n    have h\u2081 : \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n      -- Use the fact that the antiderivative of 2 * exp(-2 * x) is -exp(-2 * x)\n      have h\u2082 : \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n        -- Use the fundamental theorem of calculus to evaluate the integral\n        have h\u2083 : \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n          -- Use the fact that the antiderivative of 2 * exp(-2 * x) is -exp(-2 * x)\n          have h\u2084 : (\u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n            -- Use the fundamental theorem of calculus to evaluate the integral\n            have h\u2085 : (\u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n              -- Use the fact that the antiderivative of 2 * exp(-2 * x) is -exp(-2 * x)\n              have h\u2086 : (\u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n                -- Use the fundamental theorem of calculus to evaluate the integral\n                calc\n                  (\u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x)) = \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) := rfl\n                  _ = Real.exp (-2) := by\n                    -- Use the fact that the antiderivative of 2 * exp(-2 * x) is -exp(-2 * x)\n                    have h\u2087 : \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n                      -- Use the fundamental theorem of calculus to evaluate the integral\n                      have h\u2088 : \u222b (x : \u211d) in (1 : \u211d)..\u221e, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n                        -- Use the fact that the antiderivative of 2 * exp(-2 * x) is -exp(-2 * x)\n                        simp [intervalIntegral.integral_comp_mul_left (fun x => Real.exp (-x))]\n                        <;>\n                        norm_num <;>\n                        field_simp [Real.exp_neg, Real.exp_log] <;>\n                        ring_nf <;>\n                        norm_num <;>\n                        linarith [Real.exp_pos (-2 : \u211d)]\n                      exact h\u2088\n                    exact h\u2087\n              exact h\u2086\n            exact h\u2085\n          exact h\u2084\n        exact h\u2083\n      exact h\u2082\n    rw [h\u2081]\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equality between the integral \u222b\u2081^\u221e 2e^(-2x) dx and e^(-2). The use of Set.Ici 1 properly represents the interval [1,\u221e), and the integrand and result are accurately formalized. While the probabilistic context P(X > 1) is not explicitly mentioned in the Lean code, the core mathematical statement is completely preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n  have h\u2081 : \u2200 (b : \u211d), 1 \u2264 b \u2192 (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x)) = Real.exp (-2) - Real.exp (-2 * b) := by\n    intro b hb\n    have h\u2082 : (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x)) = Real.exp (-2) - Real.exp (-2 * b) := by\n      have h\u2083 : (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x)) = -Real.exp (-2 * b) - -Real.exp (-2 * (1 : \u211d)) := by\n        have h\u2084 : (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x)) = (\u222b x in (1 : \u211d)..b, (deriv (fun x : \u211d => -Real.exp (-2 * x)) x)) := by\n          congr\n          funext x\n          have h\u2085 : deriv (fun x : \u211d => -Real.exp (-2 * x)) x = 2 * Real.exp (-2 * x) := by\n            -- Prove that the derivative of -exp(-2x) is 2 * exp(-2x)\n            have h\u2086 : HasDerivAt (fun x : \u211d => -Real.exp (-2 * x)) (2 * Real.exp (-2 * x)) x := by\n              have h\u2087 : HasDerivAt (fun x : \u211d => Real.exp (-2 * x)) (-2 * Real.exp (-2 * x)) x := by\n                have h\u2088 : HasDerivAt (fun x : \u211d => -2 * x) (-2 : \u211d) x := by\n                  simpa using (hasDerivAt_id x).const_mul (-2 : \u211d)\n                have h\u2089 : HasDerivAt (fun x : \u211d => Real.exp (-2 * x)) (Real.exp (-2 * x) * (-2 : \u211d)) x := by\n                  have h\u2081\u2080 : HasDerivAt (fun x : \u211d => -2 * x) (-2 : \u211d) x := by\n                    simpa using (hasDerivAt_id x).const_mul (-2 : \u211d)\n                  have h\u2081\u2081 : HasDerivAt (fun x : \u211d => Real.exp (-2 * x)) (Real.exp (-2 * x) * (-2 : \u211d)) x := by\n                    simpa using (Real.hasDerivAt_exp (-2 * x)).comp x h\u2081\u2080\n                  convert h\u2081\u2081 using 1 <;> ring\n                convert h\u2089 using 1 <;> ring\n              have h\u2081\u2082 : HasDerivAt (fun x : \u211d => -Real.exp (-2 * x)) (2 * Real.exp (-2 * x)) x := by\n                convert h\u2087.neg using 1 <;>\n                  ring_nf <;>\n                  field_simp [Real.exp_neg] <;>\n                  ring_nf <;>\n                  linarith\n              exact h\u2081\u2082\n            have h\u2081\u2083 : deriv (fun x : \u211d => -Real.exp (-2 * x)) x = 2 * Real.exp (-2 * x) := by\n              apply HasDerivAt.deriv\n              exact h\u2086\n            rw [h\u2081\u2083]\n          rw [h\u2085]\n          <;> ring_nf\n          <;> field_simp [Real.exp_neg]\n          <;> ring_nf\n          <;> linarith\n        rw [h\u2084]\n        -- Use the fundamental theorem of calculus to evaluate the integral\n        have h\u2085 : (\u222b x in (1 : \u211d)..b, (deriv (fun x : \u211d => -Real.exp (-2 * x)) x)) = -Real.exp (-2 * b) - -Real.exp (-2 * (1 : \u211d)) := by\n          rw [intervalIntegral.integral_deriv_eq_sub']\n          <;>\n          (try\n            {\n              -- Prove that the function is continuous\n              apply ContinuousOn.neg\n              apply ContinuousOn.exp\n              apply ContinuousOn.mul\n              exact continuousOn_const\n              exact continuousOn_id\n            })\n          <;>\n          (try\n            {\n              -- Prove that the derivative is integrable\n              intro x hx\n              have h\u2086 : x \u2208 Set.Icc (1 : \u211d) b := hx\n              have h\u2087 : 1 \u2264 x := by linarith [h\u2086.1]\n              have h\u2088 : x \u2264 b := by linarith [h\u2086.2]\n              have h\u2089 : HasDerivAt (fun x : \u211d => -Real.exp (-2 * x)) (2 * Real.exp (-2 * x)) x := by\n                have h\u2081\u2080 : HasDerivAt (fun x : \u211d => Real.exp (-2 * x)) (-2 * Real.exp (-2 * x)) x := by\n                  have h\u2081\u2081 : HasDerivAt (fun x : \u211d => -2 * x) (-2 : \u211d) x := by\n                    simpa using (hasDerivAt_id x).const_mul (-2 : \u211d)\n                  have h\u2081\u2082 : HasDerivAt (fun x : \u211d => Real.exp (-2 * x)) (Real.exp (-2 * x) * (-2 : \u211d)) x := by\n                    have h\u2081\u2083 : HasDerivAt (fun x : \u211d => -2 * x) (-2 : \u211d) x := by\n                      simpa using (hasDerivAt_id x).const_mul (-2 : \u211d)\n                    have h\u2081\u2084 : HasDerivAt (fun x : \u211d => Real.exp (-2 * x)) (Real.exp (-2 * x) * (-2 : \u211d)) x := by\n                      simpa using (Real.hasDerivAt_exp (-2 * x)).comp x h\u2081\u2083\n                    convert h\u2081\u2084 using 1 <;> ring\n                  convert h\u2081\u2082 using 1 <;> ring\n                have h\u2081\u2085 : HasDerivAt (fun x : \u211d => -Real.exp (-2 * x)) (2 * Real.exp (-2 * x)) x := by\n                  convert h\u2081\u2080.neg using 1 <;>\n                    ring_nf <;>\n                    field_simp [Real.exp_neg] <;>\n                    ring_nf <;>\n                    linarith\n                exact h\u2081\u2085\n              exact h\u2089.differentiableAt\n            })\n          <;>\n          (try\n            {\n              -- Prove the bounds for the interval\n              norm_num at hb \u22a2 <;>\n                (try\n                  {\n                    linarith\n                  }) <;>\n                (try\n                  {\n                    exact \u27e8by linarith, by linarith\u27e9\n                  })\n            })\n          <;>\n          (try\n            {\n              -- Prove that the function is continuous\n              apply ContinuousOn.neg\n              apply ContinuousOn.exp\n              apply ContinuousOn.mul\n              exact continuousOn_const\n              exact continuousOn_id\n            })\n        rw [h\u2085]\n        <;>\n          (try\n            {\n              norm_num at hb \u22a2 <;>\n                (try\n                  {\n                    linarith\n                  }) <;>\n                (try\n                  {\n                    exact \u27e8by linarith, by linarith\u27e9\n                  })\n            })\n      rw [h\u2083]\n      <;>\n      (try\n        {\n          ring_nf\n          <;>\n          field_simp [Real.exp_neg]\n          <;>\n          ring_nf\n          <;>\n          linarith\n        })\n      <;>\n      (try\n        {\n          norm_num at hb \u22a2 <;>\n            (try\n              {\n                linarith\n              }) <;>\n            (try\n              {\n                exact \u27e8by linarith, by linarith\u27e9\n              })\n        })\n    exact h\u2082\n  \n  have h\u2082 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2 * b)) Filter.atTop (nhds 0) := by\n    have h\u2083 : Filter.Tendsto (fun (b : \u211d) => (-2 : \u211d) * b) Filter.atTop Filter.atBot := by\n      -- Show that (-2) * b tends to -\u221e as b tends to +\u221e\n      have h\u2084 : Filter.Tendsto (fun (b : \u211d) => (-2 : \u211d) * b) Filter.atTop Filter.atBot := by\n        -- Use the fact that multiplying by a negative number flips the direction of the limit\n        have h\u2085 : Filter.Tendsto (fun (b : \u211d) => (b : \u211d)) Filter.atTop Filter.atTop := by\n          exact Filter.tendsto_id\n        have h\u2086 : Filter.Tendsto (fun (b : \u211d) => (-2 : \u211d) * b) Filter.atTop Filter.atBot := by\n          -- Use the fact that multiplying by a negative number flips the direction of the limit\n          convert Filter.Tendsto.const_mul_atBot (by norm_num : (-2 : \u211d) < 0) h\u2085 using 1 <;>\n            ext <;> ring\n        exact h\u2086\n      exact h\u2084\n    -- Use the fact that exp(x) tends to 0 as x tends to -\u221e\n    have h\u2087 : Filter.Tendsto Real.exp Filter.atBot (nhds 0) := by\n      -- Use the known limit of exp(x) as x tends to -\u221e\n      have h\u2088 : Filter.Tendsto Real.exp Filter.atBot (nhds 0) := by\n        simpa using tendsto_exp_atBot\n      exact h\u2088\n    -- Combine the two results to get the final limit\n    have h\u2089 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2 * b)) Filter.atTop (nhds 0) := by\n      have h\u2081\u2080 : Filter.Tendsto (fun (b : \u211d) => (-2 : \u211d) * b) Filter.atTop Filter.atBot := h\u2083\n      have h\u2081\u2081 : Filter.Tendsto Real.exp Filter.atBot (nhds 0) := h\u2087\n      have h\u2081\u2082 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2 * b)) Filter.atTop (nhds 0) :=\n        h\u2081\u2081.comp h\u2081\u2080\n      exact h\u2081\u2082\n    exact h\u2089\n  \n  have h\u2083 : Filter.Tendsto (fun (b : \u211d) => (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x))) Filter.atTop (nhds (Real.exp (-2))) := by\n    have h\u2084 : Filter.Tendsto (fun (b : \u211d) => (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x))) Filter.atTop (nhds (Real.exp (-2))) := by\n      have h\u2085 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2) - Real.exp (-2 * b)) Filter.atTop (nhds (Real.exp (-2))) := by\n        have h\u2086 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2 * b)) Filter.atTop (nhds 0) := h\u2082\n        have h\u2087 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2) - Real.exp (-2 * b)) Filter.atTop (nhds (Real.exp (-2) - 0)) := by\n          have h\u2088 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2)) Filter.atTop (nhds (Real.exp (-2))) := by\n            apply tendsto_const_nhds\n          have h\u2089 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2) - Real.exp (-2 * b)) Filter.atTop (nhds (Real.exp (-2) - 0)) := by\n            have h\u2081\u2080 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2 * b)) Filter.atTop (nhds 0) := h\u2082\n            have h\u2081\u2081 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2) - Real.exp (-2 * b)) Filter.atTop (nhds (Real.exp (-2) - 0)) :=\n              h\u2088.sub h\u2081\u2080\n            exact h\u2081\u2081\n          exact h\u2089\n        have h\u2081\u2080 : Real.exp (-2) - 0 = Real.exp (-2) := by ring\n        have h\u2081\u2081 : Filter.Tendsto (fun (b : \u211d) => Real.exp (-2) - Real.exp (-2 * b)) Filter.atTop (nhds (Real.exp (-2))) := by\n          simpa [h\u2081\u2080] using h\u2087\n        exact h\u2081\u2081\n      have h\u2086 : \u2200\u1da0 (b : \u211d) in Filter.atTop, (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x)) = Real.exp (-2) - Real.exp (-2 * b) := by\n        filter_upwards [Filter.eventually_ge_atTop 1] with b hb\n        have h\u2087 : (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x)) = Real.exp (-2) - Real.exp (-2 * b) := h\u2081 b hb\n        exact h\u2087\n      have h\u2087 : Filter.Tendsto (fun (b : \u211d) => (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x))) Filter.atTop (nhds (Real.exp (-2))) := by\n        have h\u2088 : Filter.Tendsto (fun (b : \u211d) => (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x))) Filter.atTop (nhds (Real.exp (-2))) := by\n          apply Filter.Tendsto.congr' _ h\u2085\n          filter_upwards [h\u2086] with b hb\n          rw [hb]\n        exact h\u2088\n      exact h\u2087\n    exact h\u2084\n  \n  have h\u2084 : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n    have h\u2085 : \u222b x in Set.Ici 1, 2 * Real.exp (-2 * x) = Real.exp (-2) := by\n      -- Use the fact that the function is non-negative to apply the integral over the interval\n      have h\u2086 : 0 \u2264 (fun x : \u211d => 2 * Real.exp (-2 * x)) := by\n        intro x\n        have h\u2087 : 0 \u2264 Real.exp (-2 * x) := Real.exp_pos (-2 * x) |>.le\n        have h\u2088 : 0 \u2264 2 * Real.exp (-2 * x) := by positivity\n        exact h\u2088\n      -- Use the fact that the function is non-negative to apply the integral over the interval\n      have h\u2087 : \u222b x in Set.Ici (1 : \u211d), (2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n        -- Use the fact that the function is non-negative to apply the integral over the interval\n        have h\u2088 : \u222b x in Set.Ici (1 : \u211d), (2 * Real.exp (-2 * x)) = \u222b x in (1 : \u211d)..\u221e, (2 * Real.exp (-2 * x)) := by\n          -- Use the fact that the function is non-negative to apply the integral over the interval\n          simp [MeasureTheory.integral_Ici_eq_integral_Ioi]\n          <;>\n          simp_all [MeasureTheory.integral_Ioi_eq_integral_Icc]\n          <;>\n          simp_all [MeasureTheory.integral_Icc_eq_integral_Ioc]\n          <;>\n          simp_all [MeasureTheory.integral_Ioc_eq_integral_Ioo]\n          <;>\n          simp_all [MeasureTheory.integral_Ioo_eq_integral_Ico]\n          <;>\n          simp_all [MeasureTheory.integral_Ico_eq_integral_Icc]\n          <;>\n          simp_all [MeasureTheory.integral_Icc_eq_integral_Ioc]\n          <;>\n          simp_all [MeasureTheory.integral_Ioc_eq_integral_Ioo]\n          <;>\n          simp_all [MeasureTheory.integral_Ioo_eq_integral_Ico]\n          <;>\n          simp_all [MeasureTheory.integral_Ico_eq_integral_Icc]\n          <;>\n          simp_all [MeasureTheory.integral_Icc_eq_integral_Ioc]\n          <;>\n          simp_all [MeasureTheory.integral_Ioc_eq_integral_Ioo]\n          <;>\n          simp_all [MeasureTheory.integral_Ioo_eq_integral_Ico]\n          <;>\n          simp_all [MeasureTheory.integral_Ico_eq_integral_Icc]\n          <;>\n          simp_all [MeasureTheory.integral_Icc_eq_integral_Ioc]\n          <;>\n          simp_all [MeasureTheory.integral_Ioc_eq_integral_Ioo]\n          <;>\n          simp_all [MeasureTheory.integral_Ioo_eq_integral_Ico]\n          <;>\n          simp_all [MeasureTheory.integral_Ico_eq_integral_Icc]\n        rw [h\u2088]\n        -- Use the fact that the function is non-negative to apply the integral over the interval\n        have h\u2089 : \u222b x in (1 : \u211d)..\u221e, (2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n          -- Use the fact that the function is non-negative to apply the integral over the interval\n          have h\u2081\u2080 : Filter.Tendsto (fun (b : \u211d) => (\u222b x in (1 : \u211d)..b, 2 * Real.exp (-2 * x))) Filter.atTop (nhds (Real.exp (-2))) := h\u2083\n          -- Use the fact that the function is non-negative to apply the integral over the interval\n          have h\u2081\u2081 : \u222b x in (1 : \u211d)..\u221e, (2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n            -- Use the fact that the function is non-negative to apply the integral over the interval\n            have h\u2081\u2082 : \u222b x in (1 : \u211d)..\u221e, (2 * Real.exp (-2 * x)) = Real.exp (-2) := by\n              -- Use the fact that the function is non-negative to apply the integral over the interval\n              simp_all [intervalIntegral.integral_of_le (by norm_num : (1 : \u211d) \u2264 \u221e)]\n            exact h\u2081\u2082\n          exact h\u2081\u2081\n        rw [h\u2089]\n      exact h\u2087\n    exact h\u2085\n  \n  apply h\u2084"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_4", "label": "def_4", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_3", "label": "ts_3", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    