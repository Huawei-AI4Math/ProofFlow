
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence such that $a_n = 3n^2 - 3n + 1$. Let the partial sum be $S_N = \sum_{n=1}^{N} a_n$. Prove that $S_N = N^3$ for all integers $N \geq 1$.

Proof: We will prove this by induction on $N$. First, for the base case $N=1$, we have $S_1 = a_1$. We calculate $a_1=3(1)^2-3(1)+1 = 3-3+1 = 1$. The formula for the sum gives $1^3=1$. So $S_1 = 1^3$, which holds. Now, for the inductive step, we assume the statement is true for some integer $k \geq 1$, which means $S_k = k^3$. We want to show that the statement is true for $k+1$, i.e., $S_{k+1} = (k+1)^3$. We know that $S_{k+1} = S_k + a_{k+1}$. From the inductive hypothesis, $S_k = k^3$, and we have $a_{k+1} = 3(k+1)^2-3(k+1)+1$. So we need to show that $k^3 + 3(k+1)^2-3(k+1)+1 = (k+1)^3$. We expand the terms on the left side: $3(k+1)^2 = 3(k^2+2k+1) = 3k^2+6k+3$. Also, $-3(k+1) = -3k-3$. So the left side becomes $k^3 + (3k^2+6k+3) + (-3k-3) + 1 = k^3 + 3k^2+3k+1$. The right side is $(k+1)^3 = k^3+3k^2+3k+1$. Since the left side equals the right side, the statement is true for $k+1$. By the principle of mathematical induction, the statement is true for all integers $N \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence such that $a_n = 3n^2 - 3n + 1$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2124)\n(tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `(a : \u2115 \u2192 \u2124)` perfectly captures the concept of a sequence of integers, with the domain restriction handled in the conditional statement.", "The Lean formalization `\u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1` exactly matches the mathematical statement, including the domain restriction n \u2265 1 and the explicit formula.", "The conclusion is perfectly captured by the Lean formalization, which states the explicit formula for all n \u2265 1."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let the partial sum be $S_N = \\sum_{n=1}^{N} a_n$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 : \n  \u2200 (a : \u2115 \u2192 \u2124), \n  (\u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1) \u2192\n  \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = N^3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition with the same formula and domain constraints", "The Lean formalization correctly represents the partial sum definition using Finset.Icc 1 N which corresponds to summing from n=1 to N", "The natural language states this is just a premise with definitions and no conclusions, but the Lean theorem introduces a major conclusion that S_N = N^3, which is not mentioned in the natural language at all"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the sequence definition with the same formula and domain constraints', 'The Lean formalization correctly represents the partial sum definition using Finset.Icc 1 N which corresponds to summing from n=1 to N', 'The natural language states this is just a premise with definitions and no conclusions, but the Lean theorem introduces a major conclusion that S_N = N^3, which is not mentioned in the natural language at all']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "for the base case $N=1$, we have $S_1 = a_1$. We calculate $a_1=3(1)^2-3(1)+1 = 3-3+1 = 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2].\nTherefore, we conclude:\n\u2022 $S_1 = 1$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1) :\n  (\u2211 n in Finset.Icc 1 1, a n) = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1) :\n  (\u2211 n in Finset.Icc 1 1, a n) = 1 := by\n  have h_sum : (\u2211 n in Finset.Icc 1 1, a n) = a 1 := by\n    simp [Finset.sum_singleton]\n    <;>\n    rfl\n  \n  have h_a1 : a 1 = 1 := by\n    have h1 : a 1 = 3 * (1 : \u2115)^2 - 3 * (1 : \u2115) + 1 := by\n      have h2 : (1 : \u2115) \u2265 1 := by norm_num\n      have h3 : a 1 = 3 * (1 : \u2115)^2 - 3 * (1 : \u2115) + 1 := by\n        specialize tc_1 1 (by norm_num)\n        norm_num at tc_1 \u22a2\n        <;> simp_all [tc_1]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      exact h3\n    norm_num [h1]\n    <;>\n    simp_all\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h_final : (\u2211 n in Finset.Icc 1 1, a n) = 1 := by\n    rw [h_sum]\n    rw [h_a1]\n    <;>\n    norm_num\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The sequence definition tc_1 is correctly formalized with the proper domain restriction and formula.", "The partial sum definition tc_2 is mentioned in natural language but not explicitly formalized as a separate assumption in Lean. However, the concept is correctly applied in the conclusion.", "The conclusion l1 correctly represents S_1 = 1 using the appropriate Lean syntax for finite summation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "The formula for the sum gives $1^3=1$. So $S_1 = 1^3$, which holds.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1].\nTherefore, we conclude:\n\u2022 $S_1 = 1^3$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = N^3)\n  (l1 : (\u2211 n in Finset.Icc 1 1, a n) = 1) :\n  (\u2211 n in Finset.Icc 1 1, a n) = 1^3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u2124)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (tc_2 : \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = N^3)\n  (l1 : (\u2211 n in Finset.Icc 1 1, a n) = 1) :\n  (\u2211 n in Finset.Icc 1 1, a n) = 1^3 := by\n  have h : (1 : \u2124) = (1 : \u2124)^3 := by\n    norm_num\n    <;> simp [pow_three]\n    <;> norm_num\n  \n  have h_main : (\u2211 n in Finset.Icc 1 1, a n) = 1^3 := by\n    have h\u2082 : (\u2211 n in Finset.Icc 1 1, a n) = 1 := l1\n    have h\u2083 : (1 : \u2124) = (1 : \u2124)^3 := h\n    calc\n      (\u2211 n in Finset.Icc 1 1, a n) = 1 := by rw [h\u2082]\n      _ = 1^3 := by\n        norm_num at h\u2083 \u22a2\n        <;> simp_all [pow_three]\n        <;> norm_num\n        <;> linarith\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition with domain constraint n \u2265 1 is correctly formalized.", "The natural language only defines what S_N means (partial sum), but the Lean formalization assumes S_N = N^3 as a given fact. This introduces a major mathematical assumption not present in the natural language.", "The given condition S_1 = 1 is correctly represented using the sum notation.", "The conclusion S_1 = 1^3 is correctly formalized."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition with domain constraint n \u2265 1 is correctly formalized.', 'The natural language only defines what S_N means (partial sum), but the Lean formalization assumes S_N = N^3 as a given fact. This introduces a major mathematical assumption not present in the natural language.', 'The given condition S_1 = 1 is correctly represented using the sum notation.', 'The conclusion S_1 = 1^3 is correctly formalized.']"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "for the inductive step, we assume the statement is true for some integer $k \\geq 1$, which means $S_k = k^3$.", "statement": "Definition:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1];\n\u2022 $S_1 = 1^3$ [l2];\n\u2022 We assume as the inductive hypothesis for some integer $k \\geq 1$ that $S_k = k^3$ [def_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1\n  (a : \u2115 \u2192 \u2124) (k : \u2115)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (h : k \u2265 1)\n  (S_k : \u2124) (S_k_def : S_k = \u2211 n in Finset.Icc 1 k, a n) :\n  S_k = (k : \u2124)^3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization perfectly captures the sequence definition with the same formula and domain constraint", "The Lean sum definition using Finset.Icc 1 k correctly represents the partial sum from 1 to k", "The specific case S_1 = 1 is not explicitly stated in Lean but follows from the general definition, which is acceptable", "The natural language treats S_1 = 1^3 as a separate conclusion, but Lean doesn't explicitly state this - it's implied in the general theorem", "The natural language presents S_k = k^3 as an inductive hypothesis (assumption), but Lean treats it as the theorem conclusion to be proved. This is a fundamental logical difference in how the statement is structured"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization perfectly captures the sequence definition with the same formula and domain constraint', 'The Lean sum definition using Finset.Icc 1 k correctly represents the partial sum from 1 to k', 'The specific case S_1 = 1 is not explicitly stated in Lean but follows from the general definition, which is acceptable', \"The natural language treats S_1 = 1^3 as a separate conclusion, but Lean doesn't explicitly state this - it's implied in the general theorem\", 'The natural language presents S_k = k^3 as an inductive hypothesis (assumption), but Lean treats it as the theorem conclusion to be proved. This is a fundamental logical difference in how the statement is structured']"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "We know that $S_{k+1} = S_k + a_{k+1}$. From the inductive hypothesis, $S_k = k^3$, and we have $a_{k+1} = 3(k+1)^2-3(k+1)+1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1];\n\u2022 $S_1 = 1^3$ [l2];\n\u2022 We assume as the inductive hypothesis for some integer $k \\geq 1$ that $S_k = k^3$ [def_1].\nTherefore, we conclude:\n\u2022 $S_{k+1} = k^3 + 3(k+1)^2 - 3(k+1) + 1$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u2124) (k : \u2115)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (h : k \u2265 1)\n  (S_k : \u2124) (S_k_def : S_k = \u2211 n in Finset.Icc 1 k, a n)\n  (def_1 : S_k = (k : \u2124)^3) :\n  \u2211 n in Finset.Icc 1 (k + 1), a n = (k : \u2124)^3 + 3 * (k + 1)^2 - 3 * (k + 1) + 1 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u2124) (k : \u2115)\n  (tc_1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (h : k \u2265 1)\n  (S_k : \u2124) (S_k_def : S_k = \u2211 n in Finset.Icc 1 k, a n)\n  (def_1 : S_k = (k : \u2124)^3) :\n  \u2211 n in Finset.Icc 1 (k + 1), a n = (k : \u2124)^3 + 3 * (k + 1)^2 - 3 * (k + 1) + 1 := by\n  have h\u2081 : (k + 1 : \u2115) \u2265 1 := by\n    have h\u2082 : k \u2265 1 := h\n    have h\u2083 : (k + 1 : \u2115) \u2265 1 := by\n      omega\n    exact h\u2083\n  \n  have h\u2082 : \u2211 n in Finset.Icc 1 (k + 1), a n = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by\n    have h\u2083 : \u2211 n in Finset.Icc 1 (k + 1), a n = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by\n      rw [Finset.sum_Icc_succ_top (by omega : 1 \u2264 k + 1)]\n      <;> simp [add_assoc]\n    exact h\u2083\n  \n  have h\u2083 : a (k + 1) = 3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 := by\n    have h\u2084 : (k + 1 : \u2115) \u2265 1 := by\n      omega\n    have h\u2085 : a (k + 1) = 3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 := by\n      have h\u2086 := tc_1 (k + 1) (by omega)\n      norm_cast at h\u2086 \u22a2\n      <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_pow]\n      <;> ring_nf at *\n      <;> linarith\n    exact h\u2085\n  \n  have h\u2084 : (a (k + 1) : \u2124) = 3 * (k + 1 : \u2124)^2 - 3 * (k + 1 : \u2124) + 1 := by\n    have h\u2085 : a (k + 1) = 3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 := h\u2083\n    have h\u2086 : (a (k + 1) : \u2124) = (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 : \u2124) := by\n      norm_cast\n      <;> simp [h\u2085]\n    rw [h\u2086]\n    <;> norm_cast\n    <;> simp [pow_two]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_mul]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h\u2085 : \u2211 n in Finset.Icc 1 (k + 1), a n = (k : \u2124)^3 + 3 * (k + 1 : \u2124)^2 - 3 * (k + 1 : \u2124) + 1 := by\n    calc\n      \u2211 n in Finset.Icc 1 (k + 1), a n = \u2211 n in Finset.Icc 1 k, a n + a (k + 1) := by rw [h\u2082]\n      _ = S_k + a (k + 1) := by\n        rw [\u2190 S_k_def]\n        <;> simp [Finset.sum_range_succ]\n      _ = (k : \u2124)^3 + a (k + 1) := by\n        rw [def_1]\n      _ = (k : \u2124)^3 + (3 * (k + 1 : \u2124)^2 - 3 * (k + 1 : \u2124) + 1) := by\n        rw [h\u2084]\n      _ = (k : \u2124)^3 + 3 * (k + 1 : \u2124)^2 - 3 * (k + 1 : \u2124) + 1 := by\n        ring_nf\n        <;> simp [add_assoc]\n        <;> norm_num\n        <;> linarith\n  \n  simpa using h\u2085", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all components of the natural language premise. The sequence definition, partial sum definition, inductive hypothesis with the constraint k \u2265 1, and the conclusion are all correctly represented. The mathematical formulas are identical, and the logical structure of the inductive step is preserved. The use of Finset.Icc for summation notation and type coercions are appropriate technical implementations that don't alter the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "We expand the terms on the left side: $3(k+1)^2 = 3(k^2+2k+1) = 3k^2+6k+3$. Also, $-3(k+1) = -3k-3$. So the left side becomes $k^3 + (3k^2+6k+3) + (-3k-3) + 1 = k^3 + 3k^2+3k+1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1];\n\u2022 $S_1 = 1^3$ [l2];\n\u2022 We assume as the inductive hypothesis for some integer $k \\geq 1$ that $S_k = k^3$ [def_1];\n\u2022 $S_{k+1} = k^3 + 3(k+1)^2 - 3(k+1) + 1$ [l3].\nTherefore, we conclude:\n\u2022 $k^3 + 3(k+1)^2 - 3(k+1) + 1 = k^3 + 3k^2 + 3k + 1$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (k : \u2115) (hk : k \u2265 1) : \n  k^3 + 3 * (k + 1)^2 - 3 * (k + 1) + 1 = k^3 + 3 * k^2 + 3 * k + 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (k : \u2115) (hk : k \u2265 1) : \n  k^3 + 3 * (k + 1)^2 - 3 * (k + 1) + 1 = k^3 + 3 * k^2 + 3 * k + 1 := by\n  have h\u2081 : k^3 + 3 * (k + 1)^2 - 3 * (k + 1) + 1 = k^3 + 3 * k^2 + 3 * k + 1 := by\n    have h\u2082 : 3 * (k + 1) ^ 2 = 3 * k ^ 2 + 6 * k + 3 := by\n      calc\n        3 * (k + 1) ^ 2 = 3 * (k ^ 2 + 2 * k + 1) := by\n          ring_nf\n          <;> simp [add_assoc, add_comm, add_left_comm]\n          <;> ring_nf\n        _ = 3 * k ^ 2 + 6 * k + 3 := by\n          ring_nf\n          <;> simp [add_assoc, add_comm, add_left_comm]\n          <;> ring_nf\n          <;> omega\n    \n    have h\u2083 : k ^ 3 + 3 * (k + 1) ^ 2 \u2265 3 * (k + 1) := by\n      have h\u2084 : k \u2265 1 := hk\n      have h\u2085 : k ^ 3 + 3 * (k + 1) ^ 2 \u2265 3 * (k + 1) := by\n        cases k with\n        | zero =>\n          -- This case is impossible because k \u2265 1\n          exfalso\n          linarith\n        | succ k' =>\n          simp [h\u2082, Nat.mul_add, Nat.add_mul, Nat.pow_succ, Nat.mul_one, Nat.mul_zero] at *\n          <;> ring_nf at *\n          <;> nlinarith\n      exact h\u2085\n    \n    have h\u2084 : k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1 := by\n      have h\u2085 : k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) = k ^ 3 + 3 * k ^ 2 + 3 * k := by\n        have h\u2086 : 3 * (k + 1) ^ 2 = 3 * k ^ 2 + 6 * k + 3 := h\u2082\n        have h\u2087 : k ^ 3 + 3 * (k + 1) ^ 2 \u2265 3 * (k + 1) := h\u2083\n        have h\u2088 : k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) = k ^ 3 + 3 * k ^ 2 + 3 * k := by\n          rw [h\u2086]\n          have h\u2089 : k ^ 3 + (3 * k ^ 2 + 6 * k + 3) \u2265 3 * (k + 1) := by\n            cases k with\n            | zero =>\n              -- This case is impossible because k \u2265 1\n              exfalso\n              linarith\n            | succ k' =>\n              simp [Nat.mul_add, Nat.add_mul, Nat.pow_succ, Nat.mul_one, Nat.mul_zero] at *\n              <;> ring_nf at *\n              <;> nlinarith\n          -- Use the fact that the expression is greater than or equal to 3(k + 1) to simplify the subtraction\n          have h\u2081\u2080 : k ^ 3 + (3 * k ^ 2 + 6 * k + 3) - 3 * (k + 1) = k ^ 3 + 3 * k ^ 2 + 3 * k := by\n            cases k with\n            | zero =>\n              -- This case is impossible because k \u2265 1\n              exfalso\n              linarith\n            | succ k' =>\n              simp [Nat.mul_add, Nat.add_mul, Nat.pow_succ, Nat.mul_one, Nat.mul_zero] at *\n              <;> ring_nf at *\n              <;> norm_num at *\n              <;>\n                (try omega) <;>\n                (try\n                  {\n                    simp_all [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]\n                    <;> ring_nf at *\n                    <;> omega\n                  })\n              <;>\n                (try\n                  {\n                    omega\n                  })\n          -- Simplify the expression using the above result\n          omega\n        exact h\u2088\n      -- Add 1 to both sides to get the final result\n      have h\u2089 : k ^ 3 + 3 * (k + 1) ^ 2 - 3 * (k + 1) + 1 = k ^ 3 + 3 * k ^ 2 + 3 * k + 1 := by\n        rw [h\u2085]\n        <;> ring_nf\n        <;> omega\n      exact h\u2089\n    exact h\u2084\n  \n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical equation k\u00b3 + 3(k+1)\u00b2 - 3(k+1) + 1 = k\u00b3 + 3k\u00b2 + 3k + 1 with the constraint k \u2265 1. The use of natural numbers (\u2115) with k \u2265 1 is mathematically equivalent to positive integers in this context. The formalization focuses appropriately on the specific algebraic identity being claimed, abstracting away the broader proof context which is not necessary for this particular theorem statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "The right side is $(k+1)^3 = k^3+3k^2+3k+1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1];\n\u2022 $S_1 = 1^3$ [l2];\n\u2022 We assume as the inductive hypothesis for some integer $k \\geq 1$ that $S_k = k^3$ [def_1];\n\u2022 $S_{k+1} = k^3 + 3(k+1)^2 - 3(k+1) + 1$ [l3];\n\u2022 $k^3 + 3(k+1)^2 - 3(k+1) + 1 = k^3 + 3k^2 + 3k + 1$ [l4].\nTherefore, we conclude:\n\u2022 $(k+1)^3 = k^3 + 3k^2 + 3k + 1$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (k : \u2115) : \n  (k + 1)^3 = k^3 + 3 * k^2 + 3 * k + 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (k : \u2115) : \n  (k + 1)^3 = k^3 + 3 * k^2 + 3 * k + 1 := by\n  have h_main : (k + 1)^3 = k^3 + 3 * k^2 + 3 * k + 1 := by\n    ring_nf\n    <;> simp [pow_two, pow_three, mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm]\n    <;> ring_nf\n    <;> omega\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization only captures the final conclusion (l5) but completely omits all the essential context described in the natural language, including the sequence definition (tc_1), partial sum definition (tc_2), base cases (l1, l2), inductive hypothesis (def_1), and intermediate steps (l3, l4). While the mathematical statement of l5 is correctly formalized, the missing context represents a major gap since the natural language describes a complete proof framework that is not reflected in the Lean code."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization only captures the final conclusion (l5) but completely omits all the essential context described in the natural language, including the sequence definition (tc_1), partial sum definition (tc_2), base cases (l1, l2), inductive hypothesis (def_1), and intermediate steps (l3, l4). While the mathematical statement of l5 is correctly formalized, the missing context represents a major gap since the natural language describes a complete proof framework that is not reflected in the Lean code.']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since the left side equals the right side, the statement is true for $k+1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1];\n\u2022 $S_1 = 1^3$ [l2];\n\u2022 We assume as the inductive hypothesis for some integer $k \\geq 1$ that $S_k = k^3$ [def_1];\n\u2022 $S_{k+1} = k^3 + 3(k+1)^2 - 3(k+1) + 1$ [l3];\n\u2022 The expression for $S_{k+1}$ simplifies to $k^3 + 3k^2 + 3k + 1$ [l4];\n\u2022 $(k+1)^3$ expands to $k^3 + 3k^2 + 3k + 1$ [l5].\nTherefore, we conclude:\n\u2022 $S_{k+1} = (k+1)^3$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u2124) (k : \u2115)\n  (h_k : k \u2265 1)\n  (h_seq : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (h_sum : \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = (N : \u2124)^3)\n  (h_ind : (\u2211 n in Finset.Icc 1 k, a n) = (k : \u2124)^3) :\n  (\u2211 n in Finset.Icc 1 (k + 1), a n) = (k + 1 : \u2124)^3 := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u2124) (k : \u2115)\n  (h_k : k \u2265 1)\n  (h_seq : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1)\n  (h_sum : \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = (N : \u2124)^3)\n  (h_ind : (\u2211 n in Finset.Icc 1 k, a n) = (k : \u2124)^3) :\n  (\u2211 n in Finset.Icc 1 (k + 1), a n) = (k + 1 : \u2124)^3 := by\n  have h_main : (\u2211 n in Finset.Icc 1 (k + 1), a n) = (k + 1 : \u2124)^3 := by\n    have h\u2081 : (k + 1 : \u2115) \u2265 1 := by\n      omega\n    have h\u2082 : (\u2211 n in Finset.Icc 1 (k + 1), a n) = ((k + 1 : \u2115) : \u2124)^3 := by\n      apply h_sum\n      <;> simp_all [h\u2081]\n      <;> norm_num\n      <;> linarith\n    -- Convert the sum to the required form\n    norm_cast at h\u2082 \u22a2\n    <;> simp_all [pow_three]\n    <;> ring_nf at *\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the essential mathematical content of the natural language premise. While it includes an additional general hypothesis (h_sum) that represents the overall theorem being proved, and doesn't explicitly state the intermediate algebraic steps as separate hypotheses, the core logical structure of the inductive proof is preserved. The sequence definition, inductive hypothesis, and conclusion are all accurately represented. The intermediate steps (l3-l5) would naturally be part of the proof implementation rather than separate hypotheses, which is appropriate in Lean's proof structure.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of mathematical induction, the statement is true for all integers $N \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers for $n \\geq 1$ defined by $a_n = 3n^2 - 3n + 1$ [tc_1];\n\u2022 The partial sum of the sequence $(a_n)$ is defined as $S_N = \\sum_{n=1}^{N} a_n$ for integers $N \\geq 1$ [tc_2];\n\u2022 $S_1 = 1$ [l1];\n\u2022 The base case $S_1 = 1^3$ holds [l2];\n\u2022 We assume as the inductive hypothesis for some integer $k \\geq 1$ that $S_k = k^3$ [def_1];\n\u2022 $S_{k+1} = k^3 + 3(k+1)^2 - 3(k+1) + 1$ [l3];\n\u2022 $k^3 + 3(k+1)^2 - 3(k+1) + 1 = k^3 + 3k^2 + 3k + 1$ [l4];\n\u2022 $(k+1)^3 = k^3 + 3k^2 + 3k + 1$ [l5];\n\u2022 The inductive step $S_{k+1} = (k+1)^3$ holds [l6].\nTherefore, we conclude:\n\u2022 $S_N = N^3$ for all integers $N \\geq 1$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u2124) \n  (h_seq : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1) :\n  \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = (N : \u2124)^3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u2124) \n  (h_seq : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 3 * n^2 - 3 * n + 1) :\n  \u2200 N : \u2115, N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = (N : \u2124)^3 := by\n  have h_base : (\u2211 n in Finset.Icc 1 1, a n) = (1 : \u2124)^3 := by\n    have h\u2081 : (\u2211 n in Finset.Icc 1 1, a n) = a 1 := by\n      simp [Finset.sum_singleton]\n    rw [h\u2081]\n    have h\u2082 : a 1 = (1 : \u2124) := by\n      have h\u2083 : a 1 = 3 * (1 : \u2115)^2 - 3 * (1 : \u2115) + 1 := by\n        apply h_seq\n        <;> norm_num\n      rw [h\u2083]\n      <;> norm_num\n      <;> simp [pow_two]\n      <;> ring_nf\n      <;> norm_cast\n    rw [h\u2082]\n    <;> norm_num\n  \n  have h_inductive_step : \u2200 (k : \u2115), k \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 k, a n) = (k : \u2124)^3 \u2192 (\u2211 n in Finset.Icc 1 (k + 1), a n) = ((k + 1 : \u2115) : \u2124)^3 := by\n    intro k hk h_sum\n    have h\u2081 : (\u2211 n in Finset.Icc 1 (k + 1), a n) = (\u2211 n in Finset.Icc 1 k, a n) + a (k + 1) := by\n      rw [Finset.sum_Icc_succ_top (by omega : 1 \u2264 k + 1)]\n      <;> simp [add_assoc]\n    rw [h\u2081]\n    have h\u2082 : a (k + 1) = 3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 := by\n      have h\u2083 : (k + 1 : \u2115) \u2265 1 := by linarith\n      have h\u2084 : a (k + 1) = 3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 := by\n        apply h_seq\n        <;> omega\n      exact h\u2084\n    rw [h\u2082]\n    have h\u2083 : (\u2211 n in Finset.Icc 1 k, a n) = (k : \u2124)^3 := h_sum\n    rw [h\u2083]\n    have h\u2084 : ((k : \u2124) : \u2124)^3 + (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 : \u2124) = ((k + 1 : \u2115) : \u2124)^3 := by\n      have h\u2085 : (3 * (k + 1 : \u2115)^2 : \u2115) \u2265 3 * (k + 1 : \u2115) := by\n        have h\u2085\u2081 : (k + 1 : \u2115) \u2265 1 := by linarith\n        have h\u2085\u2082 : (k + 1 : \u2115)^2 \u2265 (k + 1 : \u2115) := by\n          nlinarith\n        nlinarith\n      have h\u2086 : (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) : \u2115) = 3 * k^2 + 3 * k := by\n        have h\u2086\u2081 : (3 * (k + 1 : \u2115)^2 : \u2115) = 3 * (k^2 + 2 * k + 1) := by\n          ring_nf\n          <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> nlinarith\n        have h\u2086\u2082 : (3 * (k + 1 : \u2115) : \u2115) = 3 * k + 3 := by\n          ring_nf\n          <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> nlinarith\n        rw [h\u2086\u2081, h\u2086\u2082]\n        have h\u2086\u2083 : 3 * (k ^ 2 + 2 * k + 1) \u2265 3 * k + 3 := by\n          cases k with\n          | zero => contradiction\n          | succ k' =>\n            simp [Nat.succ_eq_add_one, pow_two, mul_add, mul_one, add_mul, add_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> nlinarith\n        have h\u2086\u2084 : 3 * (k ^ 2 + 2 * k + 1) - (3 * k + 3) = 3 * k ^ 2 + 3 * k := by\n          have h\u2086\u2085 : 3 * (k ^ 2 + 2 * k + 1) = 3 * k ^ 2 + 6 * k + 3 := by\n            ring_nf\n            <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> nlinarith\n          rw [h\u2086\u2085]\n          have h\u2086\u2086 : 3 * k ^ 2 + 6 * k + 3 \u2265 3 * k + 3 := by\n            cases k with\n            | zero => contradiction\n            | succ k' =>\n              simp [Nat.succ_eq_add_one, pow_two, mul_add, mul_one, add_mul, add_assoc]\n              <;> ring_nf at *\n              <;> norm_num at *\n              <;> nlinarith\n          have h\u2086\u2087 : 3 * k ^ 2 + 6 * k + 3 - (3 * k + 3) = 3 * k ^ 2 + 3 * k := by\n            have h\u2086\u2088 : 3 * k ^ 2 + 6 * k + 3 = 3 * k ^ 2 + 3 * k + (3 * k + 3) := by\n              ring_nf\n              <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n              <;> ring_nf at *\n              <;> norm_num at *\n              <;> nlinarith\n            rw [h\u2086\u2088]\n            <;> simp [Nat.add_sub_cancel]\n          rw [h\u2086\u2087]\n          <;> ring_nf\n          <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> nlinarith\n        rw [h\u2086\u2084]\n        <;> ring_nf\n        <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> nlinarith\n      have h\u2087 : (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 : \u2115) = 3 * k^2 + 3 * k + 1 := by\n        have h\u2087\u2081 : (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) : \u2115) = 3 * k^2 + 3 * k := by\n          exact h\u2086\n        have h\u2087\u2082 : (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 : \u2115) = (3 * k^2 + 3 * k) + 1 := by\n          rw [h\u2087\u2081]\n          <;> ring_nf at *\n          <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc] at *\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> omega\n        have h\u2087\u2083 : (3 * k^2 + 3 * k) + 1 = 3 * k^2 + 3 * k + 1 := by\n          ring_nf\n          <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> omega\n        rw [h\u2087\u2082, h\u2087\u2083]\n        <;> ring_nf\n        <;> simp [pow_two, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> omega\n      have h\u2088 : (3 * (k + 1 : \u2115)^2 - 3 * (k + 1 : \u2115) + 1 : \u2124) = (3 * k^2 + 3 * k + 1 : \u2124) := by\n        norm_cast at h\u2087 \u22a2\n        <;> simp [h\u2087]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> omega\n      rw [h\u2088]\n      norm_cast\n      <;> ring_nf\n      <;> norm_num\n      <;>\n      (try omega) <;>\n      (try\n        {\n          cases k with\n          | zero => contradiction\n          | succ k' =>\n            simp [Nat.succ_eq_add_one, pow_two, pow_three] at *\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> nlinarith\n        }) <;>\n      (try\n        {\n          simp [pow_two, pow_three] at *\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> nlinarith\n        })\n    rw [h\u2084]\n    <;> simp [add_assoc]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp_all [Finset.sum_Icc_succ_top]\n    <;> linarith\n  \n  have h_main : \u2200 (N : \u2115), N \u2265 1 \u2192 (\u2211 n in Finset.Icc 1 N, a n) = (N : \u2124)^3 := by\n    intro N hN\n    induction' hN with N hN IH\n    \u00b7 -- Base case: N = 1\n      simpa using h_base\n    \u00b7 -- Inductive step: assume the statement holds for N, prove for N + 1\n      simpa using h_inductive_step N hN IH\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition and the main theorem statement (S_N = N^3), but it omits the detailed inductive proof steps that are explicitly described in the natural language. While the mathematical content of the final result is accurately represented, the natural language presents this as a complete proof with intermediate steps (base case, inductive hypothesis, inductive step), whereas the Lean code only provides the theorem statement with 'by sorry'. The core mathematical meaning is preserved, but the proof structure described in the natural language is not reflected in the formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the sequence definition and the main theorem statement (S_N = N^3), but it omits the detailed inductive proof steps that are explicitly described in the natural language. While the mathematical content of the final result is accurately represented, the natural language presents this as a complete proof with intermediate steps (base case, inductive hypothesis, inductive step), whereas the Lean code only provides the theorem statement with 'by sorry'. The core mathematical meaning is preserved, but the proof structure described in the natural language is not reflected in the formalization.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    