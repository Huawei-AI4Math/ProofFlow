
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for positive real numbers $a, b, c$ such that $a + b + c = 6$, the following inequality holds: $$ \\sqrt[3]{a b + b c} + \\sqrt[3]{b c + c a} + \\sqrt[3]{c a + a b} \\leq 6 $$

Proof: Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$. By the power mean inequality for non-negative numbers, $rac{\sqrt[3]{x} + \sqrt[3]{y} + \sqrt[3]{z}}{3} \leq \sqrt[3]{rac{x+y+z}{3}}$. We have $x+y+z = 2(ab+bc+ca)$ and $ab+bc+ca \leq rac{(a+b+c)^2}{3}$. Given $a+b+c=6$, it follows that $x+y+z \leq 24$. Therefore, $\sqrt[3]{x} + \sqrt[3]{y} + \sqrt[3]{z} \leq 3\sqrt[3]{8} = 6$, which implies $\sqrt[3]{ab+bc} + \sqrt[3]{bc+ca} + \sqrt[3]{ca+ab} \leq 6$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "for positive real numbers $a, b, c$", "statement": "Premise:\n\u2022 $a, b, c$ are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :\n  \u2200 (a b c : \u211d), 0 < a \u2192 0 < b \u2192 0 < c \u2192 \n  a + b + c = 6 \u2192 \n  (a * b + b * c) ^ (1/3 : \u211d) + (b * c + c * a) ^ (1/3 : \u211d) + (c * a + a * b) ^ (1/3 : \u211d) \u2264 6 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c are positive real numbers through the type declarations (a b c : \u211d) and positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)", "The natural language explicitly states there are no conclusions in this premise step, but the Lean formalization introduces a complex mathematical statement involving the constraint a + b + c = 6 and an inequality about cube roots. This contradicts the natural language which indicates this is just a premise with no derived conclusions"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c are positive real numbers through the type declarations (a b c : \u211d) and positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)', 'The natural language explicitly states there are no conclusions in this premise step, but the Lean formalization introduces a complex mathematical statement involving the constraint a + b + c = 6 and an inequality about cube roots. This contradicts the natural language which indicates this is just a premise with no derived conclusions']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "such that $a + b + c = 6$", "statement": "Premise:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  (a * b + b * c) ^ (1/3 : \u211d) + (b * c + c * a) ^ (1/3 : \u211d) + (c * a + a * b) ^ (1/3 : \u211d) \u2264 6 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c are positive real numbers through the type declaration and positivity constraints", "The sum condition a + b + c = 6 is perfectly matched in both versions", "The natural language explicitly states this is just a premise with no conclusions, but the Lean theorem introduces a complex inequality conclusion involving cube roots that is not mentioned in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c are positive real numbers through the type declaration and positivity constraints', 'The sum condition a + b + c = 6 is perfectly matched in both versions', 'The natural language explicitly states this is just a premise with no conclusions, but the Lean theorem introduces a complex inequality conclusion involving cube roots that is not mentioned in the natural language statement']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2].\nDefinition:\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d) \u2264 6 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean headers correctly capture that a, b, c are real numbers with positivity constraints ha : 0 < a, hb : 0 < b, hc : 0 < c", "The Lean header h_sum : a + b + c = 6 exactly matches the natural language condition", "The Lean definition x := a * b + b * c exactly matches x = ab + bc from the natural language", "The Lean definition y := b * c + c * a exactly matches y = bc + ca from the natural language", "The Lean definition z := c * a + a * b exactly matches z = ca + ab from the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "By the power mean inequality for non-negative numbers, $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2];\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1].\nTherefore, we conclude:\n\u2022 $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$ [l1].", "dependencies": ["tc_1", "tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := by\n  intro x y z\n  have hx_pos : 0 < x := by\n    dsimp only [x]\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < b * c := mul_pos hb hc\n    linarith\n  \n  have hy_pos : 0 < y := by\n    dsimp only [y]\n    have h\u2081 : 0 < b * c := mul_pos hb hc\n    have h\u2082 : 0 < c * a := mul_pos hc ha\n    linarith\n  \n  have hz_pos : 0 < z := by\n    dsimp only [z]\n    have h\u2081 : 0 < c * a := mul_pos hc ha\n    have h\u2082 : 0 < a * b := mul_pos ha hb\n    linarith\n  \n  have h_main : (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := by\n    have h\u2081 : 0 < x := hx_pos\n    have h\u2082 : 0 < y := hy_pos\n    have h\u2083 : 0 < z := hz_pos\n    -- Use the fact that the cube root function is concave on [0, \u221e)\n    -- to prove the inequality using the definition of concavity.\n    -- For any concave function f, we have f((x + y + z)/3) \u2265 (f(x) + f(y) + f(z))/3.\n    -- Here, f(t) = t^(1/3).\n    -- We can use this property to directly prove the inequality.\n    -- However, since Lean does not have this property directly, we use the fact that\n    -- the cube root function is concave and use the definition of concavity.\n    -- Specifically, we use that for any \u03bb \u2208 [0,1], f(\u03bbx + (1-\u03bb)y) \u2265 \u03bbf(x) + (1-\u03bb)f(y).\n    -- We apply this twice to get the desired inequality for three points.\n    -- For simplicity, we use the fact that the inequality holds due to concavity and\n    -- directly apply it here.\n    have h\u2084 : (x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1 / 3 : \u211d) := by\n      -- Use the fact that the cube root function is concave on [0, \u221e)\n      -- to prove the inequality using the definition of concavity.\n      -- For any concave function f, we have f((x + y + z)/3) \u2265 (f(x) + f(y) + f(z))/3.\n      -- Here, f(t) = t^(1/3).\n      -- We can use this property to directly prove the inequality.\n      -- However, since Lean does not have this property directly, we use the fact that\n      -- the cube root function is concave and use the definition of concavity.\n      -- Specifically, we use that for any \u03bb \u2208 [0,1], f(\u03bbx + (1-\u03bb)y) \u2265 \u03bbf(x) + (1-\u03bb)f(y).\n      -- We apply this twice to get the desired inequality for three points.\n      -- For simplicity, we use the fact that the inequality holds due to concavity and\n      -- directly apply it here.\n      have h\u2085 : 0 < x := hx_pos\n      have h\u2086 : 0 < y := hy_pos\n      have h\u2087 : 0 < z := hz_pos\n      -- Use the fact that the cube root function is concave on [0, \u221e)\n      -- to prove the inequality using the definition of concavity.\n      -- For any concave function f, we have f((x + y + z)/3) \u2265 (f(x) + f(y) + f(z))/3.\n      -- Here, f(t) = t^(1/3).\n      -- We can use this property to directly prove the inequality.\n      -- However, since Lean does not have this property directly, we use the fact that\n      -- the cube root function is concave and use the definition of concavity.\n      -- Specifically, we use that for any \u03bb \u2208 [0,1], f(\u03bbx + (1-\u03bb)y) \u2265 \u03bbf(x) + (1-\u03bb)f(y).\n      -- We apply this twice to get the desired inequality for three points.\n      -- For simplicity, we use the fact that the inequality holds due to concavity and\n      -- directly apply it here.\n      -- This is a placeholder for the actual proof, which would involve more detailed analysis.\n      -- In practice, this step would require using properties of concave functions and possibly\n      -- some inequalities specific to the cube root function.\n      -- For the purpose of this example, we assume the inequality holds based on the concavity of the cube root function.\n      have h\u2088 : (x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1 / 3 : \u211d) := by\n        -- Use the fact that the cube root function is concave on [0, \u221e)\n        -- to prove the inequality using the definition of concavity.\n        -- For any concave function f, we have f((x + y + z)/3) \u2265 (f(x) + f(y) + f(z))/3.\n        -- Here, f(t) = t^(1/3).\n        -- We can use this property to directly prove the inequality.\n        -- However, since Lean does not have this property directly, we use the fact that\n        -- the cube root function is concave and use the definition of concavity.\n        -- Specifically, we use that for any \u03bb \u2208 [0,1], f(\u03bbx + (1-\u03bb)y) \u2265 \u03bbf(x) + (1-\u03bb)f(y).\n        -- We apply this twice to get the desired inequality for three points.\n        -- For simplicity, we use the fact that the inequality holds due to concavity and\n        -- directly apply it here.\n        -- This is a placeholder for the actual proof, which would involve more detailed analysis.\n        -- In practice, this step would require using properties of concave functions and possibly\n        -- some inequalities specific to the cube root function.\n        -- For the purpose of this example, we assume the inequality holds based on the concavity of the cube root function.\n        norm_num [hx_pos, hy_pos, hz_pos] at *\n        <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try\n          {\n            -- Use nlinarith to handle nonlinear arithmetic, but this might not work directly\n            nlinarith [sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x)]\n          }) <;>\n        (try\n          {\n            -- Use the fact that the cube root function is concave\n            -- This step is a placeholder and would require actual proof in Lean\n            -- For the purpose of this example, we assume the inequality holds\n            ring_nf at *\n            <;>\n            norm_num at *\n            <;>\n            linarith\n          })\n      exact h\u2088\n    exact h\u2084\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 73, "column": 111, "endLine": 108, "endColumn": 12, "data": "unsolved goals\na b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\nh_sum : a + b + c = 6\nx : \u211d := a * b + b * c\ny : \u211d := b * c + c * a\nz : \u211d := c * a + a * b\nhx_pos hy_pos hz_pos h\u2081 h\u2082 h\u2083 h\u2085 h\u2086 h\u2087 : True\n\u22a2 (x ^ (1 / 3) + y ^ (1 / 3) + z ^ (1 / 3)) / 3 \u2264 ((x + y + z) / 3) ^ (1 / 3)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with explicit type annotations and inequality constraints.", "The sum constraint a + b + c = 6 is directly and accurately translated.", "All three variable definitions (x, y, z) are precisely captured with correct arithmetic expressions using Lean's multiplication notation.", "The main inequality statement perfectly preserves the mathematical meaning, correctly translating cube roots to fractional exponents and maintaining the exact structure of the inequality.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := by\n  have h_main_inequality : \u2200 (a b c : \u211d), 0 \u2264 a \u2192 0 \u2264 b \u2192 0 \u2264 c \u2192 (a + b + c) ^ 3 \u2264 9 * (a ^ 3 + b ^ 3 + c ^ 3) := by\n    intro a b c ha hb hc\n    nlinarith [sq_nonneg (a - b), sq_nonneg (b - c), sq_nonneg (c - a),\n      mul_nonneg ha (sq_nonneg (a - b)), mul_nonneg hb (sq_nonneg (b - c)),\n      mul_nonneg hc (sq_nonneg (c - a)), mul_nonneg ha (sq_nonneg (a - 2 * b + c)),\n      mul_nonneg hb (sq_nonneg (2 * a - b - c)), mul_nonneg hc (sq_nonneg (a + b - 2 * c))]\n  \n  intro x y z\n  have h\u2082 : 0 \u2264 x := by\n    have h\u2082\u2081 : 0 \u2264 a * b := by positivity\n    have h\u2082\u2082 : 0 \u2264 b * c := by positivity\n    have h\u2082\u2083 : 0 \u2264 a * b + b * c := by linarith\n    exact h\u2082\u2083\n  \n  have h\u2083 : 0 \u2264 y := by\n    have h\u2083\u2081 : 0 \u2264 b * c := by positivity\n    have h\u2083\u2082 : 0 \u2264 c * a := by positivity\n    have h\u2083\u2083 : 0 \u2264 b * c + c * a := by linarith\n    exact h\u2083\u2083\n  \n  have h\u2084 : 0 \u2264 z := by\n    have h\u2084\u2081 : 0 \u2264 c * a := by positivity\n    have h\u2084\u2082 : 0 \u2264 a * b := by positivity\n    have h\u2084\u2083 : 0 \u2264 c * a + a * b := by linarith\n    exact h\u2084\u2083\n  \n  have h\u2085 : (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := by\n    have h\u2085\u2081 : 0 \u2264 x := h\u2082\n    have h\u2085\u2082 : 0 \u2264 y := h\u2083\n    have h\u2085\u2083 : 0 \u2264 z := h\u2084\n    -- Use the fact that the cube root function is concave and apply Jensen's inequality\n    have h\u2085\u2084 : (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := by\n      -- Use the fact that the cube root function is concave\n      have h\u2085\u2085 : 0 \u2264 (x : \u211d) := by positivity\n      have h\u2085\u2086 : 0 \u2264 (y : \u211d) := by positivity\n      have h\u2085\u2087 : 0 \u2264 (z : \u211d) := by positivity\n      -- Use the fact that the cube function is convex and the inequality derived from it\n      have h\u2085\u2088 : ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) ^ 3 \u2264 9 * (x + y + z) := by\n        -- Prove that (a + b + c)^3 \u2264 9(a^3 + b^3 + c^3) for a = x^(1/3), etc.\n        have h\u2085\u2088\u2081 : 0 \u2264 (x : \u211d) ^ (1 / 3 : \u211d) := by positivity\n        have h\u2085\u2088\u2082 : 0 \u2264 (y : \u211d) ^ (1 / 3 : \u211d) := by positivity\n        have h\u2085\u2088\u2083 : 0 \u2264 (z : \u211d) ^ (1 / 3 : \u211d) := by positivity\n        have h\u2085\u2088\u2084 : ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) ^ 3 \u2264 9 * (((x : \u211d) ^ (1 / 3 : \u211d)) ^ 3 + ((y : \u211d) ^ (1 / 3 : \u211d)) ^ 3 + ((z : \u211d) ^ (1 / 3 : \u211d)) ^ 3) := by\n          -- Use the inequality (a + b + c)^3 \u2264 9(a^3 + b^3 + c^3)\n          have h\u2085\u2088\u2085 := h_main_inequality ((x : \u211d) ^ (1 / 3 : \u211d)) ((y : \u211d) ^ (1 / 3 : \u211d)) ((z : \u211d) ^ (1 / 3 : \u211d)) (by positivity) (by positivity) (by positivity)\n          -- Simplify the expression using the properties of exponents\n          ring_nf at h\u2085\u2088\u2085 \u22a2\n          <;>\n          nlinarith [sq_nonneg ((x : \u211d) ^ (1 / 3 : \u211d) - (y : \u211d) ^ (1 / 3 : \u211d)),\n            sq_nonneg ((y : \u211d) ^ (1 / 3 : \u211d) - (z : \u211d) ^ (1 / 3 : \u211d)),\n            sq_nonneg ((z : \u211d) ^ (1 / 3 : \u211d) - (x : \u211d) ^ (1 / 3 : \u211d))]\n        -- Simplify the right-hand side using the properties of exponents\n        have h\u2085\u2088\u2085 : (((x : \u211d) ^ (1 / 3 : \u211d)) ^ 3 + ((y : \u211d) ^ (1 / 3 : \u211d)) ^ 3 + ((z : \u211d) ^ (1 / 3 : \u211d)) ^ 3 : \u211d) = x + y + z := by\n          have h\u2085\u2088\u2085\u2081 : ((x : \u211d) ^ (1 / 3 : \u211d)) ^ 3 = x := by\n            rw [\u2190 Real.rpow_nat_cast]\n            rw [\u2190 Real.rpow_mul] <;> norm_num <;>\n            (try positivity) <;>\n            (try linarith)\n          have h\u2085\u2088\u2085\u2082 : ((y : \u211d) ^ (1 / 3 : \u211d)) ^ 3 = y := by\n            rw [\u2190 Real.rpow_nat_cast]\n            rw [\u2190 Real.rpow_mul] <;> norm_num <;>\n            (try positivity) <;>\n            (try linarith)\n          have h\u2085\u2088\u2085\u2083 : ((z : \u211d) ^ (1 / 3 : \u211d)) ^ 3 = z := by\n            rw [\u2190 Real.rpow_nat_cast]\n            rw [\u2190 Real.rpow_mul] <;> norm_num <;>\n            (try positivity) <;>\n            (try linarith)\n          linarith\n        -- Combine the inequalities to get the final result\n        linarith\n      -- Use the inequality to prove the original statement\n      have h\u2085\u2089 : 0 \u2264 (x + y + z : \u211d) := by positivity\n      have h\u2085\u2081\u2080 : 0 \u2264 ((x + y + z : \u211d) / 3 : \u211d) := by positivity\n      have h\u2085\u2081\u2081 : 0 \u2264 ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) := by positivity\n      -- Use the fact that the cube function is increasing to take cube roots\n      have h\u2085\u2081\u2082 : ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d) := by\n        -- Use the fact that the cube function is increasing\n        have h\u2085\u2081\u2083 : 0 \u2264 ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 := by positivity\n        have h\u2085\u2081\u2084 : 0 \u2264 ((x + y + z : \u211d) / 3 : \u211d) := by positivity\n        -- Use the fact that the cube function is increasing\n        have h\u2085\u2081\u2085 : (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 \u2264 ((x + y + z : \u211d) / 3) := by\n          calc\n            (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 = (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) ^ 3) / 27 := by\n              ring_nf\n              <;> field_simp\n              <;> ring_nf\n            _ \u2264 (9 * (x + y + z)) / 27 := by\n              gcongr <;> nlinarith\n            _ = (x + y + z) / 3 := by ring\n            _ = ((x + y + z : \u211d) / 3) := by ring\n        -- Use the fact that the cube function is increasing\n        have h\u2085\u2081\u2086 : ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d) := by\n          -- Use the fact that the cube function is increasing\n          have h\u2085\u2081\u2087 : 0 \u2264 ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 := by positivity\n          have h\u2085\u2081\u2088 : 0 \u2264 ((x + y + z : \u211d) / 3 : \u211d) := by positivity\n          -- Use the fact that the cube function is increasing\n          have h\u2085\u2081\u2089 : (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 \u2264 ((x + y + z : \u211d) / 3) := by\n            exact h\u2085\u2081\u2085\n          -- Use the fact that the cube function is increasing\n          have h\u2085\u2082\u2080 : ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d) := by\n            -- Use the fact that the cube function is increasing\n            have h\u2085\u2082\u2081 : 0 \u2264 ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 := by positivity\n            have h\u2085\u2082\u2082 : 0 \u2264 ((x + y + z : \u211d) / 3 : \u211d) := by positivity\n            -- Use the fact that the cube function is increasing\n            have h\u2085\u2082\u2083 : (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 \u2264 ((x + y + z : \u211d) / 3) := by\n              exact h\u2085\u2081\u2085\n            -- Use the fact that the cube function is increasing\n            have h\u2085\u2082\u2084 : ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d) := by\n              -- Use the fact that the cube function is increasing\n              by_contra h\n              have h\u2085\u2082\u2085 : ((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d) < ((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3 := by linarith\n              have h\u2085\u2082\u2086 : (((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d)) ^ 3 < (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 := by\n                gcongr <;>\n                  (try positivity) <;>\n                  (try linarith)\n              have h\u2085\u2082\u2087 : ((x + y + z : \u211d) / 3) < (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 := by\n                calc\n                  ((x + y + z : \u211d) / 3) = (((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d)) ^ 3 := by\n                    have h\u2081 : 0 \u2264 ((x + y + z : \u211d) / 3 : \u211d) := by positivity\n                    have h\u2082 : (((x + y + z : \u211d) / 3) ^ (1 / 3 : \u211d)) ^ 3 = (x + y + z : \u211d) / 3 := by\n                      rw [\u2190 Real.rpow_nat_cast]\n                      rw [\u2190 Real.rpow_mul] <;>\n                      (try norm_num) <;>\n                      (try linarith) <;>\n                      (try positivity)\n                    linarith\n                  _ < (((x : \u211d) ^ (1 / 3 : \u211d) + (y : \u211d) ^ (1 / 3 : \u211d) + (z : \u211d) ^ (1 / 3 : \u211d)) / 3) ^ 3 := by\n                    linarith\n              nlinarith\n            exact h\u2085\u2082\u2084\n          exact h\u2085\u2082\u2080\n        exact h\u2085\u2081\u2086\n      exact h\u2085\u2081\u2082\n    exact h\u2085\u2084\n  \n  exact h\u2085"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "We have $x+y+z = 2(ab+bc+ca)$", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2];\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1];\n\u2022 $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$ [l1].\nTherefore, we conclude:\n\u2022 $x+y+z = 2(ab+bc+ca)$ [l2].", "dependencies": ["tc_1", "tc_2", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  x + y + z = 2 * (a * b + b * c + c * a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  x + y + z = 2 * (a * b + b * c + c * a) := by\n  intro x y z\n  have h_main : x + y + z = 2 * (a * b + b * c + c * a) := by\n    dsimp only [x, y, z] at *\n    ring_nf\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try nlinarith [ha, hb, hc, h_sum]) <;>\n    (try ring_nf at * <;> linarith)\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations with positivity constraints are correctly formalized", "The sum constraint a + b + c = 6 is perfectly captured", "The definitions of x, y, z are correctly translated to Lean syntax", "The inequality assumption from [l1] is completely missing from the Lean formalization, which is a major omission since it's explicitly listed as an assumption in the natural language", "The conclusion equation is perfectly formalized"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations with positivity constraints are correctly formalized', 'The sum constraint a + b + c = 6 is perfectly captured', 'The definitions of x, y, z are correctly translated to Lean syntax', \"The inequality assumption from [l1] is completely missing from the Lean formalization, which is a major omission since it's explicitly listed as an assumption in the natural language\", 'The conclusion equation is perfectly formalized']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "and $ab+bc+ca \\leq \\frac{(a+b+c)^2}{3}$.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2];\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1];\n\u2022 $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$ [l1];\n\u2022 $x+y+z = 2(ab+bc+ca)$ [l2].\nTherefore, we conclude:\n\u2022 $ab+bc+ca \\leq \\frac{(a+b+c)^2}{3}$ [l3].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  ((x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d)) \u2192\n  (x + y + z = 2 * (a * b + b * c + c * a)) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  ((x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d)) \u2192\n  (x + y + z = 2 * (a * b + b * c + c * a)) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 := by\n  intro x y z h1 h2\n  have h_sum_sq : (a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a) := by\n    have h3 : (a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a) := by\n      ring\n    rw [h3]\n    <;>\n    norm_num\n  \n  have h_ineq : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := by\n    have h3 : 0 \u2264 (a - b)^2 + (b - c)^2 + (c - a)^2 := by positivity\n    have h4 : (a - b)^2 + (b - c)^2 + (c - a)^2 = 2 * (a^2 + b^2 + c^2 - (a*b + b*c + c*a)) := by\n      ring\n    have h5 : 0 \u2264 2 * (a^2 + b^2 + c^2 - (a*b + b*c + c*a)) := by linarith\n    have h6 : 0 \u2264 a^2 + b^2 + c^2 - (a*b + b*c + c*a) := by linarith\n    linarith\n  \n  have h_main : (a + b + c)^2 \u2265 3*(a*b + b*c + c*a) := by\n    have h3 : (a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a) := h_sum_sq\n    have h4 : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := h_ineq\n    nlinarith\n  \n  have h_final : a*b + b*c + c*a \u2264 (a + b + c)^2 / 3 := by\n    have h3 : (a + b + c)^2 \u2265 3*(a*b + b*c + c*a) := h_main\n    have h4 : a*b + b*c + c*a \u2264 (a + b + c)^2 / 3 := by\n      linarith\n    exact h4\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured with appropriate Lean syntax for real numbers and strict inequalities.", "The sum constraint a + b + c = 6 is exactly represented in the hypothesis h_sum.", "The variable definitions for x, y, z are correctly translated using let bindings with proper multiplication notation.", "The cube root inequality is properly formalized using exponentiation with (1/3 : \u211d) and structured as an implication hypothesis.", "The algebraic identity x + y + z = 2(ab + bc + ca) is correctly represented as an implication hypothesis.", "The final conclusion inequality is accurately captured with proper exponentiation and division notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Given $a+b+c=6$, it follows that $x+y+z \\leq 24$.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2];\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1];\n\u2022 $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$ [l1];\n\u2022 $x+y+z = 2(ab+bc+ca)$ [l2];\n\u2022 $ab+bc+ca \\leq \\frac{(a+b+c)^2}{3}$ [l3].\nTherefore, we conclude:\n\u2022 $x+y+z \\leq 24$ [l4].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) \u2192\n  x + y + z = 2 * (a * b + b * c + c * a) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 \u2192\n  x + y + z \u2264 24 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) \u2192\n  x + y + z = 2 * (a * b + b * c + c * a) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 \u2192\n  x + y + z \u2264 24 := by\n  intro x y z h1 h2 h3\n  have h_sum_sq : (a + b + c)^2 = 36 := by\n    have h4 : (a + b + c) = 6 := h_sum\n    rw [h4]\n    norm_num\n  \n  have h_ab_bc_ca_le : a * b + b * c + c * a \u2264 12 := by\n    have h4 : a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 := h3\n    have h5 : (a + b + c)^2 = 36 := h_sum_sq\n    have h6 : a * b + b * c + c * a \u2264 36 / 3 := by\n      linarith\n    linarith\n  \n  have h_main : x + y + z \u2264 24 := by\n    have h4 : x + y + z = 2 * (a * b + b * c + c * a) := h2\n    have h5 : a * b + b * c + c * a \u2264 12 := h_ab_bc_ca_le\n    have h6 : x + y + z \u2264 24 := by\n      linarith\n    exact h6\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and constraints are correctly formalized with proper type annotations and positivity constraints", "Variable definitions for x, y, z perfectly match the natural language definitions using standard Lean multiplication notation", "Assumption l1 correctly translates cube roots using exponentiation with 1/3 and maintains the inequality structure", "Assumptions l2 and l3 are perfectly translated with correct arithmetic operations and exponentiation", "The conclusion l4 is exactly as stated, and the overall theorem structure correctly captures the logical flow from premises to conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Therefore, $\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z} \\leq 3\\sqrt[3]{8} = 6$.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2];\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1];\n\u2022 $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$ [l1];\n\u2022 $x+y+z = 2(ab+bc+ca)$ [l2];\n\u2022 $ab+bc+ca \\leq \\frac{(a+b+c)^2}{3}$ [l3];\n\u2022 $x+y+z \\leq 24$ [l4].\nTherefore, we conclude:\n\u2022 $\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z} \\leq 6$ [l5].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) \u2192\n  x + y + z = 2 * (a * b + b * c + c * a) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 \u2192\n  x + y + z \u2264 24 \u2192\n  x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d) \u2264 6 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) \u2192\n  x + y + z = 2 * (a * b + b * c + c * a) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 \u2192\n  x + y + z \u2264 24 \u2192\n  x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d) \u2264 6 := by\n  intro x y z h1 h2 h3 h4\n  have h_pos_x : 0 < x := by\n    dsimp only [x]\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < b * c := mul_pos hb hc\n    linarith\n  \n  have h_pos_y : 0 < y := by\n    dsimp only [y] at *\n    have h\u2081 : 0 < b * c := mul_pos hb hc\n    have h\u2082 : 0 < c * a := mul_pos hc ha\n    linarith\n  \n  have h_pos_z : 0 < z := by\n    dsimp only [z] at *\n    have h\u2081 : 0 < c * a := mul_pos hc ha\n    have h\u2082 : 0 < a * b := mul_pos ha hb\n    linarith\n  \n  have h_pos_sum : 0 < x + y + z := by\n    have h\u2081 : 0 < x := h_pos_x\n    have h\u2082 : 0 < y := h_pos_y\n    have h\u2083 : 0 < z := h_pos_z\n    linarith\n  \n  have h_sum_div_le : (x + y + z) / 3 \u2264 8 := by\n    have h\u2085 : x + y + z \u2264 24 := h4\n    linarith\n  \n  have h_cube_root_sum_div_le : ((x + y + z) / 3 : \u211d) ^ (1 / 3 : \u211d) \u2264 2 := by\n    have h\u2085 : (x + y + z : \u211d) / 3 \u2264 8 := by exact_mod_cast h_sum_div_le\n    have h\u2086 : 0 \u2264 (x + y + z : \u211d) / 3 := by\n      have h\u2087 : 0 < (x + y + z : \u211d) := by exact_mod_cast h_pos_sum\n      linarith\n    -- Use the fact that the cube root function is increasing on [0, \u221e)\n    have h\u2087 : ((x + y + z : \u211d) / 3 : \u211d) ^ (1 / 3 : \u211d) \u2264 (8 : \u211d) ^ (1 / 3 : \u211d) := by\n      apply Real.rpow_le_rpow\n      \u00b7 linarith\n      \u00b7 linarith\n      \u00b7 norm_num\n    -- Calculate 8^(1/3)\n    have h\u2088 : (8 : \u211d) ^ (1 / 3 : \u211d) = 2 := by\n      have h\u2089 : (8 : \u211d) ^ (1 / 3 : \u211d) = 2 := by\n        rw [show (8 : \u211d) = (2 : \u211d) ^ (3 : \u211d) by norm_num]\n        rw [\u2190 Real.rpow_mul] <;>\n        norm_num\n        <;>\n        linarith\n      rw [h\u2089]\n    rw [h\u2088] at h\u2087\n    linarith\n  \n  have h_main : (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 2 := by\n    have h\u2085 : (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) := h1\n    have h\u2086 : ((x + y + z) / 3 : \u211d) ^ (1 / 3 : \u211d) \u2264 2 := h_cube_root_sum_div_le\n    linarith\n  \n  have h_final : x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d) \u2264 6 := by\n    have h\u2085 : (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 2 := h_main\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture that a, b, c are positive real numbers", "The sum constraint a + b + c = 6 is correctly formalized", "The definitions of x, y, z correctly match the natural language using multiplication notation", "The cube root inequality l1 is correctly represented as a hypothesis in the implication", "The equality l2 relating x+y+z to 2(ab+bc+ca) is correctly included as a hypothesis", "The inequality l3 for ab+bc+ca is correctly formalized as a hypothesis", "The inequality l4 stating x+y+z \u2264 24 is correctly included as a hypothesis", "The final conclusion l5 about the sum of cube roots being \u2264 6 is correctly stated as the goal"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "which implies $\\sqrt[3]{ab+bc} + \\sqrt[3]{bc+ca} + \\sqrt[3]{ca+ab} \\leq 6$.", "statement": "We assume:\n\u2022 $a, b, c$ are positive real numbers [tc_1];\n\u2022 $a + b + c = 6$ [tc_2];\n\u2022 Let $x = ab+bc$, $y = bc+ca$, and $z = ca+ab$ [def_1];\n\u2022 $\\frac{\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z}}{3} \\leq \\sqrt[3]{\\frac{x+y+z}{3}}$ [l1];\n\u2022 $x+y+z = 2(ab+bc+ca)$ [l2];\n\u2022 $ab+bc+ca \\leq \\frac{(a+b+c)^2}{3}$ [l3];\n\u2022 $x+y+z \\leq 24$ [l4];\n\u2022 $\\sqrt[3]{x} + \\sqrt[3]{y} + \\sqrt[3]{z} \\leq 6$ [l5].\nTherefore, we conclude:\n\u2022 $\\sqrt[3]{ab+bc} + \\sqrt[3]{bc+ca} + \\sqrt[3]{ca+ab} \\leq 6$ [ts_1].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) \u2192\n  x + y + z = 2 * (a * b + b * c + c * a) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 \u2192\n  x + y + z \u2264 24 \u2192\n  x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d) \u2264 6 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_sum : a + b + c = 6) :\n  let x := a * b + b * c\n  let y := b * c + c * a  \n  let z := c * a + a * b\n  (x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1/3 : \u211d) \u2192\n  x + y + z = 2 * (a * b + b * c + c * a) \u2192\n  a * b + b * c + c * a \u2264 (a + b + c)^2 / 3 \u2192\n  x + y + z \u2264 24 \u2192\n  x ^ (1/3 : \u211d) + y ^ (1/3 : \u211d) + z ^ (1/3 : \u211d) \u2264 6 := by\n  intro x y z h\u2081 h\u2082 h\u2083 h\u2084\n  have h\u2085 : ((x + y + z : \u211d) / 3 : \u211d) \u2264 8 := by\n    have h\u2085\u2081 : (x + y + z : \u211d) \u2264 24 := by\n      exact_mod_cast h\u2084\n    linarith\n  \n  have h\u2086 : ((x + y + z : \u211d) / 3 : \u211d) ^ (1 / 3 : \u211d) \u2264 2 := by\n    have h\u2086\u2081 : 0 \u2264 ((x + y + z : \u211d) / 3 : \u211d) := by\n      have h\u2086\u2082 : 0 \u2264 (x + y + z : \u211d) := by\n        have h\u2086\u2083 : 0 \u2264 x := by\n          dsimp only [x]\n          nlinarith [mul_nonneg ha.le hb.le, mul_nonneg hb.le hc.le]\n        have h\u2086\u2084 : 0 \u2264 y := by\n          dsimp only [y]\n          nlinarith [mul_nonneg hb.le hc.le, mul_nonneg hc.le ha.le]\n        have h\u2086\u2085 : 0 \u2264 z := by\n          dsimp only [z]\n          nlinarith [mul_nonneg hc.le ha.le, mul_nonneg ha.le hb.le]\n        linarith\n      linarith\n    -- Use the fact that the cube root function is increasing to bound the expression\n    have h\u2086\u2082 : ((x + y + z : \u211d) / 3 : \u211d) \u2264 8 := h\u2085\n    have h\u2086\u2083 : ((x + y + z : \u211d) / 3 : \u211d) ^ (1 / 3 : \u211d) \u2264 (8 : \u211d) ^ (1 / 3 : \u211d) := by\n      apply Real.rpow_le_rpow\n      \u00b7 linarith\n      \u00b7 linarith\n      \u00b7 norm_num\n    -- Calculate the cube root of 8\n    have h\u2086\u2084 : (8 : \u211d) ^ (1 / 3 : \u211d) = 2 := by\n      have h\u2086\u2085 : (8 : \u211d) ^ (1 / 3 : \u211d) = 2 := by\n        rw [show (8 : \u211d) = (2 : \u211d) ^ (3 : \u211d) by norm_num]\n        rw [\u2190 Real.rpow_mul] <;>\n        (try norm_num) <;>\n        (try linarith) <;>\n        (try ring_nf) <;>\n        (try norm_num)\n        <;>\n        linarith\n      rw [h\u2086\u2085]\n    rw [h\u2086\u2084] at h\u2086\u2083\n    linarith\n  \n  have h\u2087 : 3 * (((x + y + z : \u211d) / 3 : \u211d) ^ (1 / 3 : \u211d)) \u2264 6 := by\n    have h\u2087\u2081 : ((x + y + z : \u211d) / 3 : \u211d) ^ (1 / 3 : \u211d) \u2264 2 := h\u2086\n    linarith\n  \n  have h\u2088 : x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d) \u2264 3 * (((x + y + z : \u211d) / 3 : \u211d) ^ (1 / 3 : \u211d)) := by\n    have h\u2088\u2081 : (x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d)) / 3 \u2264 ((x + y + z) / 3) ^ (1 / 3 : \u211d) := h\u2081\n    have h\u2088\u2082 : x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d) \u2264 3 * (((x + y + z) / 3) ^ (1 / 3 : \u211d)) := by\n      calc\n        x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d) = 3 * ((x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d)) / 3) := by ring\n        _ \u2264 3 * (((x + y + z) / 3) ^ (1 / 3 : \u211d)) := by\n          gcongr\n          <;> simp_all [div_eq_mul_inv]\n          <;> ring_nf at *\n          <;> nlinarith\n    simpa using h\u2088\u2082\n  \n  have h\u2089 : x ^ (1 / 3 : \u211d) + y ^ (1 / 3 : \u211d) + z ^ (1 / 3 : \u211d) \u2264 6 := by\n    linarith\n  \n  exact h\u2089", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. While the natural language presents l5 and ts_1 as separate statements, they are mathematically identical when the definitions of x, y, z are substituted. The Lean code appropriately treats the logical relationships as implications leading to the final conclusion. The variable declarations, constraints, definitions, and logical flow all correspond correctly to the natural language description."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    