
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $f$ is differentiable at $\mathbf{X}_0,$ then $f$
is continuous at $\mathbf{X}_0$.

Proof: From \eqref{eq:5.3.19} and Schwarz's inequality,
$$
|L(\mathbf{X}-\mathbf{X}_0)|\le M|\mathbf{X}-\mathbf{X}_0|,
$$
where
$$
M=(m^2_1+m^2_2+\cdots+m^2_n)^{1/2}.
$$
This and \eqref{eq:5.3.20} imply that
$$
|f(\mathbf{X})-f(\mathbf{X}_0)|\le(M+|E(\mathbf{X})|)
|\mathbf{X}-\mathbf{X}_0|,
$$
which, with \eqref{eq:5.3.21}, implies that $f$ is continuous at $\mathbf{X}_0$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $f$ is differentiable at $\\mathbf{X}_0,$", "statement": "Premise:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : DifferentiableAt \u211d f X\u2080)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents $f: \\mathbb{R}^n \\to \\mathbb{R}$ using the type (Fin n \u2192 \u211d) \u2192 \u211d, which is the standard representation of functions from $\\mathbb{R}^n$ to $\\mathbb{R}$ in Lean. The natural number n is appropriately declared.", "The Lean formalization correctly captures both parts: X\u2080 is declared as an element of Fin n \u2192 \u211d (representing $\\mathbb{R}^n$), and tc_1 states that f is differentiable at X\u2080 using the standard DifferentiableAt predicate."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "From \\eqref{eq:5.3.19} and Schwarz's inequality,", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1].\nDefinition:\n\u2022 A consequence of $f$ being differentiable at $\\mathbf{X}_0$ is the existence of a linear map $L$ which can be represented by a vector $\\mathbf{m} = (m_1, ..., m_n)$ such that $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ for any $\\mathbf{h} \\in \\mathbb{R}^n$. This corresponds to the referenced equation 5.3.19 [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : DifferentiableAt \u211d f X\u2080)\n\nvariable (m : Fin n \u2192 \u211d)\ndef_1 : \u2203 L : (Fin n \u2192 \u211d) \u2192\u2097[\u211d] \u211d, \n  (\u2200 h : Fin n \u2192 \u211d, L h = \u2211 i, m i * h i) \u2227\n  (\u2203 C : \u211d, \u2200 h : Fin n \u2192 \u211d, |f (X\u2080 + h) - f X\u2080 - L h| \u2264 C * \u2016h\u2016) := by sorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 0, "endLine": 11, "endColumn": 5, "data": "unexpected identifier; expected command"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "where\n$$\nM=(m^2_1+m^2_2+\\cdots+m^2_n)^{1/2}.\n$$", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The linear map component of the derivative is $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ [def_1].\nDefinition:\n\u2022 We define $M$ to be the Euclidean norm of the vector $\\mathbf{m}$, i.e., $M=(m^2_1+m^2_2+\\cdots+m^2_n)^{1/2}$ [def_2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2 \n  (n : \u2115) (m : Fin n \u2192 \u211d) (M : \u211d) :\n  M = Real.sqrt (\u2211 i, (m i)^2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization completely omits the condition about function f being differentiable at X_0, which is a key component of the natural language statement", "The Lean formalization completely omits the condition about the linear map component L(h) = m\u00b7h, which is another key component of the natural language statement", "The Lean proposition M = Real.sqrt (\u2211 i, (m i)^2) perfectly captures the mathematical meaning of M = (m\u00b2\u2081+m\u00b2\u2082+\u22ef+m\u00b2\u2099)^(1/2), with equivalent notation for the sum and square root operations"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely omits the condition about function f being differentiable at X_0, which is a key component of the natural language statement', 'The Lean formalization completely omits the condition about the linear map component L(h) = m\u00b7h, which is another key component of the natural language statement', 'The Lean proposition M = Real.sqrt (\u2211 i, (m i)^2) perfectly captures the mathematical meaning of M = (m\u00b2\u2081+m\u00b2\u2082+\u22ef+m\u00b2\u2099)^(1/2), with equivalent notation for the sum and square root operations']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From \\eqref{eq:5.3.19} and Schwarz's inequality,\n$$\n|L(\\mathbf{X}-\\mathbf{X}_0)|\\le M|\\mathbf{X}-\\mathbf{X}_0|,\n$$", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The linear map component of the derivative is $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ [def_1];\n\u2022 $M$ is the Euclidean norm of $\\mathbf{m}$, i.e., $M=(m^2_1+m^2_2+\\cdots+m^2_n)^{1/2}$ [def_2].\nTherefore, we conclude:\n\u2022 $|L(\\mathbf{X}-\\mathbf{X}_0)| \\le M|\\mathbf{X}-\\mathbf{X}_0|$ [l1].", "dependencies": ["tc_1", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2)) :\n  \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2)) :\n  \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n  have h_sum_le : \u2200 (X : Fin n \u2192 \u211d), |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := by\n    intro X\n    have h\u2081 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 \u2211 i : Fin n, |m i * (X i - X\u2080 i)| := by\n      calc\n        |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 \u2211 i : Fin n, |m i * (X i - X\u2080 i)| := by\n          exact Finset.abs_sum_le_sum_abs _ _\n        _ = \u2211 i : Fin n, |m i * (X i - X\u2080 i)| := by rfl\n    have h\u2082 : \u2211 i : Fin n, |m i * (X i - X\u2080 i)| \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := by\n      calc\n        \u2211 i : Fin n, |m i * (X i - X\u2080 i)| = \u2211 i : Fin n, |m i| * |(X i - X\u2080 i)| := by\n          simp [abs_mul]\n        _ \u2264 \u2211 i : Fin n, |m i| * \u2016X - X\u2080\u2016 := by\n          apply Finset.sum_le_sum\n          intro i _\n          have h\u2083 : |(X i - X\u2080 i)| \u2264 \u2016X - X\u2080\u2016 := by\n            -- Use the property that the absolute value of each component is less than or equal to the norm of the vector\n            have h\u2084 : |(X i - X\u2080 i)| \u2264 \u2016X - X\u2080\u2016 := by\n              -- Since \u2016X - X\u2080\u2016 is the max norm, it is at least |(X i - X\u2080 i)|\n              calc\n                |(X i - X\u2080 i)| = \u2016(X - X\u2080) i\u2016 := by simp [Pi.norm_def, Real.norm_eq_abs]\n                _ \u2264 \u2016X - X\u2080\u2016 := by\n                  -- The norm of a component is less than or equal to the norm of the vector\n                  simp [Pi.norm_def, Real.norm_eq_abs]\n                  <;>\n                  exact Finset.le_sup (Finset.mem_univ i)\n            exact h\u2084\n          have h\u2085 : 0 \u2264 |m i| := abs_nonneg (m i)\n          have h\u2086 : 0 \u2264 \u2016X - X\u2080\u2016 := norm_nonneg _\n          nlinarith\n        _ = (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := by\n          simp [Finset.sum_mul]\n    calc\n      |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 \u2211 i : Fin n, |m i * (X i - X\u2080 i)| := h\u2081\n      _ \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := h\u2082\n  \n  have h_M_le_sum : M \u2264 \u2211 i : Fin n, |m i| := by\n    have h\u2081 : M = Real.sqrt (\u2211 i : Fin n, (m i)^2) := by\n      simpa using def_2\n    rw [h\u2081]\n    have h\u2082 : Real.sqrt (\u2211 i : Fin n, (m i)^2) \u2264 \u2211 i : Fin n, |m i| := by\n      have h\u2083 : (\u2211 i : Fin n, (m i)^2) \u2264 (\u2211 i : Fin n, |m i|)^2 := by\n        have h\u2084 : \u2200 i : Fin n, (m i)^2 \u2264 (|m i|)^2 := by\n          intro i\n          simp [sq_abs]\n          <;>\n          nlinarith [abs_nonneg (m i)]\n        have h\u2085 : (\u2211 i : Fin n, (m i)^2) \u2264 \u2211 i : Fin n, (|m i|)^2 := by\n          apply Finset.sum_le_sum\n          intro i _\n          exact h\u2084 i\n        have h\u2086 : \u2211 i : Fin n, (|m i|)^2 \u2264 (\u2211 i : Fin n, |m i|)^2 := by\n          have h\u2087 : \u2200 i : Fin n, 0 \u2264 |m i| := by intro i; exact abs_nonneg (m i)\n          have h\u2088 : \u2211 i : Fin n, (|m i|)^2 \u2264 (\u2211 i : Fin n, |m i|)^2 := by\n            calc\n              \u2211 i : Fin n, (|m i|)^2 \u2264 \u2211 i : Fin n, (|m i| * \u2211 j : Fin n, |m j|) := by\n                apply Finset.sum_le_sum\n                intro i _\n                have h\u2089 : (|m i| : \u211d) \u2265 0 := abs_nonneg (m i)\n                have h\u2081\u2080 : (|m i| : \u211d) \u2264 \u2211 j : Fin n, |m j| := by\n                  apply Finset.single_le_sum (fun j _ => abs_nonneg (m j)) (Finset.mem_univ i)\n                nlinarith\n              _ = (\u2211 i : Fin n, |m i|) * (\u2211 j : Fin n, |m j|) := by\n                simp [Finset.sum_mul]\n              _ = (\u2211 i : Fin n, |m i|)^2 := by ring\n          exact h\u2088\n        linarith\n      have h\u2089 : 0 \u2264 \u2211 i : Fin n, |m i| := by\n        apply Finset.sum_nonneg\n        intro i _\n        exact abs_nonneg (m i)\n      apply Real.sqrt_le_iff.mpr\n      constructor\n      \u00b7 positivity\n      \u00b7 nlinarith\n    linarith\n  \n  have h_main : \u2200 (X : Fin n \u2192 \u211d), |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n    intro X\n    have h\u2081 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := h_sum_le X\n    have h\u2082 : M \u2264 \u2211 i : Fin n, |m i| := h_M_le_sum\n    have h\u2083 : 0 \u2264 \u2016X - X\u2080\u2016 := norm_nonneg _\n    have h\u2084 : 0 \u2264 \u2211 i : Fin n, |m i| := by\n      apply Finset.sum_nonneg\n      intro i _\n      exact abs_nonneg (m i)\n    have h\u2085 : 0 \u2264 M := by\n      rw [def_2]\n      apply Real.sqrt_nonneg\n    -- Use the fact that M \u2264 \u2211 |m_i| and the previous inequality to get the desired result\n    have h\u2086 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n      calc\n        |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := h\u2081\n        _ \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := by linarith\n        _ \u2264 M * \u2016X - X\u2080\u2016 := by\n          have h\u2087 : (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 \u2264 M * \u2016X - X\u2080\u2016 := by\n            -- Use the fact that (\u2211 |m_i|) \u2265 M and \u2016X - X\u2080\u2016 \u2265 0\n            have h\u2088 : M \u2264 \u2211 i : Fin n, |m i| := h_M_le_sum\n            have h\u2089 : 0 \u2264 \u2016X - X\u2080\u2016 := norm_nonneg _\n            -- Multiply both sides of M \u2264 \u2211 |m_i| by \u2016X - X\u2080\u2016 \u2265 0\n            have h\u2081\u2080 : 0 \u2264 \u2211 i : Fin n, |m i| := by positivity\n            have h\u2081\u2081 : 0 \u2264 M := by positivity\n            have h\u2081\u2082 : M * \u2016X - X\u2080\u2016 \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 := by\n              nlinarith\n            linarith\n          linarith\n    exact h\u2086\n  \n  intro X\n  exact h_main X", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 34, "column": 24, "endLine": 34, "endColumn": 57, "data": "typeclass instance problem is stuck, it is often due to metavariables\n  OrderBot ?m.44730"}, {"line": 113, "column": 12, "endLine": 113, "endColumn": 20, "data": "linarith failed to find a contradiction\ncase a\nn : \u2115\nf : (Fin n \u2192 \u211d) \u2192 \u211d\nX\u2080 m : Fin n \u2192 \u211d\nM : \u211d\ntc_1 : DifferentiableAt \u211d f X\u2080\ndef_1 : \u2200 (h : Fin n \u2192 \u211d), (fderiv \u211d f X\u2080) h = \u2211 i : Fin n, m i * h i\ndef_2 : M = \u221a(\u2211 i : Fin n, m i ^ 2)\nh_sum_le : \u2200 (X : Fin n \u2192 \u211d), |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016\nh_M_le_sum : M \u2264 \u2211 i : Fin n, |m i|\nX : Fin n \u2192 \u211d\nh\u2081 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016\nh\u2082 : M \u2264 \u2211 i : Fin n, |m i|\nh\u2083 : 0 \u2264 \u2016X - X\u2080\u2016\nh\u2084 : 0 \u2264 \u2211 i : Fin n, |m i|\nh\u2085 : 0 \u2264 M\nh\u2088 : M \u2264 \u2211 i : Fin n, |m i|\nh\u2089 : 0 \u2264 \u2016X - X\u2080\u2016\nh\u2081\u2080 : 0 \u2264 \u2211 i : Fin n, |m i|\nh\u2081\u2081 : 0 \u2264 M\nh\u2081\u2082 : M * \u2016X - X\u2080\u2016 \u2264 (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016\na\u271d : (\u2211 i : Fin n, |m i|) * \u2016X - X\u2080\u2016 > M * \u2016X - X\u2080\u2016\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The differentiability condition is correctly captured using DifferentiableAt, and the function type (Fin n \u2192 \u211d) \u2192 \u211d properly represents \u211d\u207f \u2192 \u211d in Lean.", "The linear map definition correctly translates the dot product m\u00b7h as the sum \u2211 i, m i * h i, and properly uses fderiv to represent the derivative.", "The Euclidean norm definition M = \u221a(\u2211\u1d62 m\u1d62\u00b2) is perfectly captured using Real.sqrt and the sum over squared components.", "The conclusion correctly represents L(X-X\u2080) using the linear map definition, and uses standard Lean norm notation \u2016X - X\u2080\u2016 for the Euclidean distance.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2)) :\n  \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n  intro X\n  have h\u2081 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n    have h\u2081 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n      classical\n      by_cases h : (\u2211 i : Fin n, (m i) ^ 2) = 0\n      \u00b7 -- Case: \u2211 m_i\u00b2 = 0\n        have h\u2082 : \u2200 i : Fin n, m i = 0 := by\n          intro i\n          have h\u2083 : 0 \u2264 (m i) ^ 2 := sq_nonneg (m i)\n          have h\u2084 : \u2211 i : Fin n, (m i) ^ 2 = 0 := h\n          have h\u2085 : (m i) ^ 2 \u2264 \u2211 i : Fin n, (m i) ^ 2 := by\n            apply Finset.single_le_sum (fun i _ => sq_nonneg (m i)) (Finset.mem_univ i)\n          have h\u2086 : (m i) ^ 2 = 0 := by linarith\n          nlinarith\n        -- All m_i are zero, so the left side is zero\n        have h\u2083 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) = 0 := by\n          calc\n            (\u2211 i : Fin n, m i * (X i - X\u2080 i)) = \u2211 i : Fin n, (0 : \u211d) * (X i - X\u2080 i) := by\n              apply Finset.sum_congr rfl\n              intro i _\n              rw [h\u2082 i]\n            _ = 0 := by simp\n        -- The right side is also zero\n        have h\u2084 : (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) = 0 := by\n          rw [h]\n          <;> simp\n        -- Therefore, the inequality holds\n        rw [h\u2083]\n        <;> nlinarith\n      \u00b7 -- Case: \u2211 m_i\u00b2 \u2260 0\n        have h\u2082 : 0 < \u2211 i : Fin n, (m i) ^ 2 := by\n          by_contra h\u2083\n          have h\u2084 : \u2211 i : Fin n, (m i) ^ 2 \u2264 0 := by linarith\n          have h\u2085 : \u2211 i : Fin n, (m i) ^ 2 = 0 := by\n            have h\u2086 : 0 \u2264 \u2211 i : Fin n, (m i) ^ 2 := by\n              apply Finset.sum_nonneg\n              intro i _\n              exact sq_nonneg (m i)\n            linarith\n          contradiction\n        -- Use the fact that the square of any real number is non-negative to prove the inequality\n        have h\u2083 : 0 \u2264 \u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) - (X i - X\u2080 i)) ^ 2 := by\n          apply Finset.sum_nonneg\n          intro i _\n          nlinarith [sq_nonneg (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) - (X i - X\u2080 i))]\n        -- Expand the sum of squares and simplify to get the desired inequality\n        have h\u2084 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n          have h\u2085 : \u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) - (X i - X\u2080 i)) ^ 2 = (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) - (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2) := by\n            calc\n              \u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) - (X i - X\u2080 i)) ^ 2 = \u2211 i : Fin n, ( (m i) ^ 2 * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2 - 2 * (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i) + (X i - X\u2080 i) ^ 2 ) := by\n                apply Finset.sum_congr rfl\n                intro i _\n                ring_nf\n                <;>\n                field_simp [sq]\n                <;>\n                ring_nf\n              _ = \u2211 i : Fin n, ( (m i) ^ 2 * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2 ) - \u2211 i : Fin n, ( 2 * (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i) ) + \u2211 i : Fin n, ( (X i - X\u2080 i) ^ 2 ) := by\n                rw [Finset.sum_sub_distrib, Finset.sum_add_distrib]\n              _ = (\u2211 i : Fin n, (m i) ^ 2) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2 - 2 * ((\u2211 i : Fin n, m i * (X i - X\u2080 i)) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) + \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := by\n                calc\n                  (\u2211 i : Fin n, (m i) ^ 2 * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2) - \u2211 i : Fin n, (2 * (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i)) + \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 = (\u2211 i : Fin n, (m i) ^ 2 * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2) - 2 * (\u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i)) + \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := by ring\n                  _ = (\u2211 i : Fin n, (m i) ^ 2) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2 - 2 * (\u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i)) + \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := by\n                    simp [Finset.sum_mul]\n                    <;>\n                    field_simp [h\u2082.ne']\n                    <;>\n                    ring_nf\n                  _ = (\u2211 i : Fin n, (m i) ^ 2) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2 - 2 * ((\u2211 i : Fin n, m i * (X i - X\u2080 i)) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) + \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := by\n                    have h\u2086 : (\u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i)) = (\u2211 i : Fin n, m i * (X i - X\u2080 i)) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) := by\n                      calc\n                        (\u2211 i : Fin n, (m i * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) * (X i - X\u2080 i)) = (\u2211 i : Fin n, (m i * (X i - X\u2080 i)) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) := by\n                          apply Finset.sum_congr rfl\n                          intro i _\n                          ring_nf\n                        _ = (\u2211 i : Fin n, m i * (X i - X\u2080 i)) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) := by\n                          simp [Finset.sum_mul]\n                          <;>\n                          field_simp [h\u2082.ne']\n                          <;>\n                          ring_nf\n                    rw [h\u2086]\n                    <;>\n                    ring_nf\n              _ = (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) - (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2) := by\n                have h\u2087 : (\u2211 i : Fin n, (m i) ^ 2) \u2260 0 := by linarith\n                have h\u2088 : (\u2211 i : Fin n, (m i) ^ 2) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2)) ^ 2 - 2 * ((\u2211 i : Fin n, m i * (X i - X\u2080 i)) * ((\u2211 j : Fin n, m j * (X j - X\u2080 j)) / (\u2211 j : Fin n, (m j) ^ 2))) + \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 = (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) - (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2) := by\n                  have h\u2089 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) = (\u2211 i : Fin n, m i * (X i - X\u2080 i)) := rfl\n                  field_simp [h\u2087]\n                  <;>\n                  ring_nf\n                  <;>\n                  field_simp [h\u2087]\n                  <;>\n                  ring_nf\n                  <;>\n                  nlinarith\n                linarith\n          have h\u2086 : (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) - (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2) \u2265 0 := by\n            linarith\n          have h\u2087 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2) \u2264 \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := by\n            linarith\n          have h\u2088 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n            have h\u2089 : 0 < \u2211 i : Fin n, (m i) ^ 2 := h\u2082\n            have h\u2081\u2080 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2) \u2264 \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := h\u2087\n            have h\u2081\u2081 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n              calc\n                (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 = ((\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 / (\u2211 i : Fin n, (m i) ^ 2)) * (\u2211 i : Fin n, (m i) ^ 2) := by\n                  field_simp [h\u2089.ne']\n                  <;>\n                  ring_nf\n                _ \u2264 (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) * (\u2211 i : Fin n, (m i) ^ 2) := by\n                  gcongr\n                  <;>\n                  linarith\n                _ = (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by ring\n            exact h\u2081\u2081\n          linarith\n        exact h\u2084\n    exact h\u2081\n  \n  have h\u2082 : 0 \u2264 \u2211 i : Fin n, (m i) ^ 2 := by\n    apply Finset.sum_nonneg\n    intro i _\n    nlinarith [sq_nonneg (m i)]\n  \n  have h\u2083 : 0 \u2264 \u2211 i : Fin n, (X i - X\u2080 i) ^ 2 := by\n    apply Finset.sum_nonneg\n    intro i _\n    nlinarith [sq_nonneg (X i - X\u2080 i)]\n  \n  have h\u2084 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n    have h\u2084\u2081 : 0 \u2264 Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) := Real.sqrt_nonneg _\n    have h\u2084\u2082 : 0 \u2264 Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := Real.sqrt_nonneg _\n    have h\u2084\u2083 : 0 \u2264 Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by positivity\n    have h\u2084\u2084 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := h\u2081\n    have h\u2084\u2085 : (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)) ^ 2 := by\n      calc\n        (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 \u2264 (\u2211 i : Fin n, (m i) ^ 2) * (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := h\u2084\u2084\n        _ = (Real.sqrt (\u2211 i : Fin n, (m i) ^ 2)) ^ 2 * (Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)) ^ 2 := by\n          rw [Real.sq_sqrt (by positivity), Real.sq_sqrt (by positivity)]\n        _ = (Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)) ^ 2 := by\n          ring_nf\n          <;>\n          simp [mul_pow]\n          <;>\n          ring_nf\n    have h\u2084\u2086 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n      have h\u2084\u2087 : 0 \u2264 Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by positivity\n      have h\u2084\u2088 : (|\u2211 i : Fin n, m i * (X i - X\u2080 i)| : \u211d) ^ 2 \u2264 (Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)) ^ 2 := by\n        calc\n          (|\u2211 i : Fin n, m i * (X i - X\u2080 i)| : \u211d) ^ 2 = (\u2211 i : Fin n, m i * (X i - X\u2080 i)) ^ 2 := by\n            simp [sq_abs]\n          _ \u2264 (Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)) ^ 2 := by\n            exact h\u2084\u2085\n          _ = (Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)) ^ 2 := by rfl\n      have h\u2084\u2089 : 0 \u2264 |\u2211 i : Fin n, m i * (X i - X\u2080 i)| := abs_nonneg _\n      nlinarith [sq_nonneg (|\u2211 i : Fin n, m i * (X i - X\u2080 i)| - Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2))]\n    exact h\u2084\u2086\n  \n  have h\u2085 : Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) = M := by\n    rw [def_2]\n    <;>\n    simp [Real.sqrt_eq_iff_sq_eq] <;>\n    ring_nf <;>\n    simp_all [Finset.sum_range_succ, add_assoc] <;>\n    nlinarith [Real.sqrt_nonneg (\u2211 i : Fin n, (m i) ^ 2)]\n  \n  have h\u2086 : Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) = \u2016X - X\u2080\u2016 := by\n    have h\u2086\u2081 : \u2016X - X\u2080\u2016 = Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n      simp [Pi.norm_def, Real.norm_eq_abs, abs_of_nonneg, Finset.sum_nonneg, sq_nonneg]\n      <;>\n      congr 1 <;>\n      ext i <;>\n      simp [sq]\n      <;>\n      ring_nf\n      <;>\n      simp_all [Real.sqrt_eq_iff_sq_eq]\n      <;>\n      nlinarith [Real.sqrt_nonneg (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)]\n    linarith\n  \n  have h\u2087 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n    calc\n      |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 Real.sqrt (\u2211 i : Fin n, (m i) ^ 2) * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := h\u2084\n      _ = M * Real.sqrt (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2) := by\n        rw [h\u2085]\n      _ = M * \u2016X - X\u2080\u2016 := by\n        rw [h\u2086]\n        <;>\n        simp_all [Real.sqrt_eq_iff_sq_eq]\n        <;>\n        nlinarith [Real.sqrt_nonneg (\u2211 i : Fin n, (X i - X\u2080 i) ^ 2)]\n  \n  simpa using h\u2087"}, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "This and \\eqref{eq:5.3.20} imply that", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The linear map component of the derivative is $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ [def_1];\n\u2022 $M$ is the Euclidean norm of $\\mathbf{m}$ [def_2];\n\u2022 $|L(\\mathbf{X}-\\mathbf{X}_0)| \\le M|\\mathbf{X}-\\mathbf{X}_0|$ [l1].\nDefinition:\n\u2022 The definition of $f$ being differentiable at $\\mathbf{X}_0$ states that $f(\\mathbf{X})-f(\\mathbf{X}_0) = L(\\mathbf{X}-\\mathbf{X}_0) + E(\\mathbf{X})|\\mathbf{X}-\\mathbf{X}_0|$ for some function $E$. This corresponds to the referenced equation 5.3.20 [def_3].", "dependencies": ["tc_1", "def_1", "def_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (M : \u211d)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2))\n  (l1 : \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016) :\n  ContinuousAt f X\u2080 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean `DifferentiableAt \u211d f X\u2080` correctly captures that f is differentiable at X\u2080, with the domain being `Fin n \u2192 \u211d` (equivalent to \u211d\u207f)", "The Lean formalization `(fderiv \u211d f X\u2080) h = \u2211 i, m i * h i` correctly represents the linear map L(h) = m\u00b7h using the dot product as a sum", "The Lean `M = Real.sqrt (\u2211 i, (m i)^2)` correctly represents the Euclidean norm of vector m", "The Lean inequality `|\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016` correctly captures |L(X-X\u2080)| \u2264 M|X-X\u2080|, where the sum represents the dot product", "The natural language describes this as a condition about the definition of differentiability (involving error term E), but the Lean theorem concludes `ContinuousAt f X\u2080` instead. The differentiability definition with error term E is not present in the Lean formalization - instead it's replaced by a different conclusion"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean `DifferentiableAt \u211d f X\u2080` correctly captures that f is differentiable at X\u2080, with the domain being `Fin n \u2192 \u211d` (equivalent to \u211d\u207f)', 'The Lean formalization `(fderiv \u211d f X\u2080) h = \u2211 i, m i * h i` correctly represents the linear map L(h) = m\u00b7h using the dot product as a sum', 'The Lean `M = Real.sqrt (\u2211 i, (m i)^2)` correctly represents the Euclidean norm of vector m', 'The Lean inequality `|\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016` correctly captures |L(X-X\u2080)| \u2264 M|X-X\u2080|, where the sum represents the dot product', \"The natural language describes this as a condition about the definition of differentiability (involving error term E), but the Lean theorem concludes `ContinuousAt f X\u2080` instead. The differentiability definition with error term E is not present in the Lean formalization - instead it's replaced by a different conclusion\"]"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "This and \\eqref{eq:5.3.20} imply that\n$$\n|f(\\mathbf{X})-f(\\mathbf{X}_0)|\\le(M+|E(\\mathbf{X})|)\n|\\mathbf{X}-\\mathbf{X}_0|,\n$$", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The linear map component of the derivative is $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ [def_1];\n\u2022 $M$ is the Euclidean norm of $\\mathbf{m}$ [def_2];\n\u2022 $|L(\\mathbf{X}-\\mathbf{X}_0)| \\le M|\\mathbf{X}-\\mathbf{X}_0|$ [l1];\n\u2022 The differentiability equation is $f(\\mathbf{X})-f(\\mathbf{X}_0) = L(\\mathbf{X}-\\mathbf{X}_0) + E(\\mathbf{X})|\\mathbf{X}-\\mathbf{X}_0|$ [def_3].\nTherefore, we conclude:\n\u2022 $|f(\\mathbf{X})-f(\\mathbf{X}_0)| \\le (M+|E(\\mathbf{X})|)|\\mathbf{X}-\\mathbf{X}_0|$ [l2].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d) (E : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2))\n  (l1 : \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016)\n  (def_3 : \u2200 X, f X - f X\u2080 = \u2211 i, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016) :\n  \u2200 X, |f X - f X\u2080| \u2264 (M + |E X|) * \u2016X - X\u2080\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d) (E : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2))\n  (l1 : \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016)\n  (def_3 : \u2200 X, f X - f X\u2080 = \u2211 i, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016) :\n  \u2200 X, |f X - f X\u2080| \u2264 (M + |E X|) * \u2016X - X\u2080\u2016 := by\n  intro X\n  have h_triangle : |f X - f X\u2080| \u2264 |\u2211 i : Fin n, m i * (X i - X\u2080 i)| + |E X * \u2016X - X\u2080\u2016| := by\n    have h\u2081 : f X - f X\u2080 = \u2211 i : Fin n, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016 := by\n      simpa using def_3 X\n    rw [h\u2081]\n    -- Apply the triangle inequality to the sum of two terms\n    calc\n      |\u2211 i : Fin n, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016| \u2264\n          |\u2211 i : Fin n, m i * (X i - X\u2080 i)| + |E X * \u2016X - X\u2080\u2016| := by\n        -- Use the triangle inequality for absolute values\n        apply abs_add\n      _ = |\u2211 i : Fin n, m i * (X i - X\u2080 i)| + |E X * \u2016X - X\u2080\u2016| := by rfl\n  \n  have h_bound_linear : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n    have h\u2082 : |\u2211 i : Fin n, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016 := by\n      -- Use the given inequality l1 to bound the sum\n      have h\u2083 := l1 X\n      simpa using h\u2083\n    exact h\u2082\n  \n  have h_bound_error : |E X * \u2016X - X\u2080\u2016| = |E X| * \u2016X - X\u2080\u2016 := by\n    have h\u2083 : 0 \u2264 \u2016X - X\u2080\u2016 := by\n      -- The norm is always non-negative\n      exact norm_nonneg _\n    -- Use the property of absolute values for non-negative numbers\n    calc\n      |E X * \u2016X - X\u2080\u2016| = |E X| * \u2016X - X\u2080\u2016 := by\n        rw [abs_mul, abs_of_nonneg h\u2083]\n        <;>\n        simp [abs_mul, abs_of_nonneg h\u2083]\n      _ = |E X| * \u2016X - X\u2080\u2016 := by rfl\n  \n  have h_combine : |f X - f X\u2080| \u2264 M * \u2016X - X\u2080\u2016 + |E X| * \u2016X - X\u2080\u2016 := by\n    calc\n      |f X - f X\u2080| \u2264 |\u2211 i : Fin n, m i * (X i - X\u2080 i)| + |E X * \u2016X - X\u2080\u2016| := h_triangle\n      _ \u2264 M * \u2016X - X\u2080\u2016 + |E X * \u2016X - X\u2080\u2016| := by\n        gcongr\n        <;>\n        simp_all [abs_mul]\n      _ = M * \u2016X - X\u2080\u2016 + |E X| * \u2016X - X\u2080\u2016 := by\n        rw [h_bound_error]\n        <;>\n        ring_nf\n  \n  have h_final : |f X - f X\u2080| \u2264 (M + |E X|) * \u2016X - X\u2080\u2016 := by\n    have h\u2084 : 0 \u2264 \u2016X - X\u2080\u2016 := by\n      exact norm_nonneg _\n    have h\u2085 : M * \u2016X - X\u2080\u2016 + |E X| * \u2016X - X\u2080\u2016 = (M + |E X|) * \u2016X - X\u2080\u2016 := by\n      ring\n    calc\n      |f X - f X\u2080| \u2264 M * \u2016X - X\u2080\u2016 + |E X| * \u2016X - X\u2080\u2016 := h_combine\n      _ = (M + |E X|) * \u2016X - X\u2080\u2016 := by rw [h\u2085]\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The differentiability condition is correctly captured using DifferentiableAt in Lean, which corresponds exactly to the natural language statement.", "The linear map component is properly formalized using fderiv and dot product as summation, which is the standard representation in Lean.", "The Euclidean norm definition is correctly expressed as the square root of sum of squares, matching the mathematical definition.", "The linear map bound inequality is accurately translated, with the dot product represented as summation and norm notation preserved.", "The differentiability equation is correctly formalized with all terms properly represented using summation for the linear part.", "The final conclusion inequality is perfectly captured with correct precedence and structure matching the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_4": {"id": "def_4", "natural_language": "which, with \\eqref{eq:5.3.21}, implies that $f$ is continuous at $\\mathbf{X}_0$.", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The linear map component of the derivative is $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ [def_1];\n\u2022 $M$ is the Euclidean norm of $\\mathbf{m}$ [def_2];\n\u2022 $|L(\\mathbf{X}-\\mathbf{X}_0)| \\le M|\\mathbf{X}-\\mathbf{X}_0|$ [l1];\n\u2022 The differentiability equation is $f(\\mathbf{X})-f(\\mathbf{X}_0) = L(\\mathbf{X}-\\mathbf{X}_0) + E(\\mathbf{X})|\\mathbf{X}-\\mathbf{X}_0|$ [def_3];\n\u2022 $|f(\\mathbf{X})-f(\\mathbf{X}_0)| \\le (M+|E(\\mathbf{X})|)|\\mathbf{X}-\\mathbf{X}_0|$ [l2].\nDefinition:\n\u2022 A condition for $f$ being differentiable at $\\mathbf{X}_0$ is that the error function $E$ satisfies $\\lim_{\\mathbf{X} \\to \\mathbf{X}_0} E(\\mathbf{X}) = 0$. This corresponds to the referenced equation 5.3.21 [def_4].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "def_3", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_4\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (E : (Fin n \u2192 \u211d) \u2192 \u211d) :\n  Filter.Tendsto E (nhds X\u2080) (nhds 0) \u2192\n  ContinuousAt f X\u2080 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean theorem has no condition stating that f is differentiable at X\u2080. This is a fundamental missing condition.", "The Lean theorem has no definition or condition about the linear map component L(h) = m\u00b7h. This linear map is completely absent.", "The Lean theorem has no definition of M as the Euclidean norm of m. Neither M nor m appear in the Lean formalization.", "The Lean theorem has no condition |L(X-X\u2080)| \u2264 M|X-X\u2080|. This inequality constraint is completely missing.", "The Lean theorem has no differentiability equation f(X)-f(X\u2080) = L(X-X\u2080) + E(X)|X-X\u2080|. This fundamental equation is absent.", "The Lean theorem has no condition |f(X)-f(X\u2080)| \u2264 (M+|E(X)|)|X-X\u2080|. This inequality is missing.", "The natural language conclusion states that lim E(X)\u21920 is a condition for differentiability, but the Lean theorem concludes with continuity (ContinuousAt f X\u2080) rather than differentiability. Additionally, the Lean treats the limit condition as a premise leading to continuity, not as a characterization of differentiability."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean theorem has no condition stating that f is differentiable at X\u2080. This is a fundamental missing condition.', 'The Lean theorem has no definition or condition about the linear map component L(h) = m\u00b7h. This linear map is completely absent.', 'The Lean theorem has no definition of M as the Euclidean norm of m. Neither M nor m appear in the Lean formalization.', 'The Lean theorem has no condition |L(X-X\u2080)| \u2264 M|X-X\u2080|. This inequality constraint is completely missing.', 'The Lean theorem has no differentiability equation f(X)-f(X\u2080) = L(X-X\u2080) + E(X)|X-X\u2080|. This fundamental equation is absent.', 'The Lean theorem has no condition |f(X)-f(X\u2080)| \u2264 (M+|E(X)|)|X-X\u2080|. This inequality is missing.', 'The natural language conclusion states that lim E(X)\u21920 is a condition for differentiability, but the Lean theorem concludes with continuity (ContinuousAt f X\u2080) rather than differentiability. Additionally, the Lean treats the limit condition as a premise leading to continuity, not as a characterization of differentiability.']"}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "which, with \\eqref{eq:5.3.21}, implies that $f$ is continuous at $\\mathbf{X}_0$.", "statement": "We assume:\n\u2022 $f: \\mathbb{R}^n \\to \\mathbb{R}$ is a function that is differentiable at $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The linear map component of the derivative is $L(\\mathbf{h}) = \\mathbf{m} \\cdot \\mathbf{h}$ [def_1];\n\u2022 $M$ is the Euclidean norm of $\\mathbf{m}$ [def_2];\n\u2022 $|L(\\mathbf{X}-\\mathbf{X}_0)| \\le M|\\mathbf{X}-\\mathbf{X}_0|$ [l1];\n\u2022 The differentiability equation is $f(\\mathbf{X})-f(\\mathbf{X}_0) = L(\\mathbf{X}-\\mathbf{X}_0) + E(\\mathbf{X})|\\mathbf{X}-\\mathbf{X}_0|$ [def_3];\n\u2022 $|f(\\mathbf{X})-f(\\mathbf{X}_0)| \\le (M+|E(\\mathbf{X})|)|\\mathbf{X}-\\mathbf{X}_0|$ [l2];\n\u2022 The error term satisfies $\\lim_{\\mathbf{X} \\to \\mathbf{X}_0} E(\\mathbf{X}) = 0$ [def_4].\nTherefore, we conclude:\n\u2022 $f$ is continuous at $\\mathbf{X}_0$ [ts_1].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "def_3", "l2", "def_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d) (E : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2))\n  (l1 : \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016)\n  (def_3 : \u2200 X, f X - f X\u2080 = \u2211 i, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016)\n  (l2 : \u2200 X, |f X - f X\u2080| \u2264 (M + |E X|) * \u2016X - X\u2080\u2016)\n  (def_4 : Filter.Tendsto E (nhds X\u2080) (nhds 0)) :\n  ContinuousAt f X\u2080 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (n : \u2115) (f : (Fin n \u2192 \u211d) \u2192 \u211d) (X\u2080 : Fin n \u2192 \u211d) (m : Fin n \u2192 \u211d) (M : \u211d) (E : (Fin n \u2192 \u211d) \u2192 \u211d)\n  (tc_1 : DifferentiableAt \u211d f X\u2080)\n  (def_1 : \u2200 h, (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i)\n  (def_2 : M = Real.sqrt (\u2211 i, (m i)^2))\n  (l1 : \u2200 X, |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016)\n  (def_3 : \u2200 X, f X - f X\u2080 = \u2211 i, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016)\n  (l2 : \u2200 X, |f X - f X\u2080| \u2264 (M + |E X|) * \u2016X - X\u2080\u2016)\n  (def_4 : Filter.Tendsto E (nhds X\u2080) (nhds 0)) :\n  ContinuousAt f X\u2080 := by\n  have h_main : ContinuousAt f X\u2080 := by\n    -- Use the fact that differentiability implies continuity\n    exact tc_1.continuousAt\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["tc_1: The differentiability assumption is correctly captured using DifferentiableAt \u211d f X\u2080, which precisely matches the natural language statement that f is differentiable at X\u2080.", "def_1: The linear map component L(h) = m\u00b7h is accurately formalized as (fderiv \u211d f X\u2080) h = \u2211 i, m i * h i, correctly representing the dot product using summation notation.", "def_2: The definition of M as the Euclidean norm of m is properly captured as M = Real.sqrt (\u2211 i, (m i)^2), which is the standard formula for Euclidean norm.", "l1: The inequality |L(X-X\u2080)| \u2264 M|X-X\u2080| is correctly formalized as |\u2211 i, m i * (X i - X\u2080 i)| \u2264 M * \u2016X - X\u2080\u2016, maintaining the mathematical relationship.", "def_3: The differentiability equation f(X)-f(X\u2080) = L(X-X\u2080) + E(X)|X-X\u2080| is accurately represented as f X - f X\u2080 = \u2211 i, m i * (X i - X\u2080 i) + E X * \u2016X - X\u2080\u2016.", "l2: The inequality |f(X)-f(X\u2080)| \u2264 (M+|E(X)|)|X-X\u2080| is correctly formalized as |f X - f X\u2080| \u2264 (M + |E X|) * \u2016X - X\u2080\u2016.", "def_4: The limit condition lim_{X\u2192X\u2080} E(X) = 0 is properly captured using Filter.Tendsto E (nhds X\u2080) (nhds 0), which is the standard way to express limits in Lean.", "ts_1: The conclusion that f is continuous at X\u2080 is correctly stated as ContinuousAt f X\u2080, which directly corresponds to the natural language conclusion.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_4", "label": "def_4", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    