
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}_1$ and $\mathbf{X}_2$ are in $S_r(\mathbf{X}_0)$ for some $r>0$,
then so is every point on
the line segment from $\mathbf{X}_1$ to $\mathbf{X}_2.$

Proof: The line segment is given by
$$
\mathbf{X}=t\mathbf{X}_2+(1-t)\mathbf{X}_1,\quad 0<t<1.
$$
Suppose that $r>0$. If
$$
|\mathbf{X}_1-\mathbf{X}_0|<r,\quad |\mathbf{X}_2-\mathbf{X}_0|<r,
$$
and $0<t<1$, then
\begin{eqnarray*}
|\mathbf{X}-\mathbf{X}_0|\ar=|t\mathbf{X}_2+(1-t)\mathbf{X}_1-t\mathbf{X}_0-(1-t)\mathbf{X}_0|\\
\ar=|t(\mathbf{X}_2-\mathbf{X}_0)+(1-t)\mathbf{X}_1-\mathbf{X}_0)|\\
\ar\le  t|\mathbf{X}_2-\mathbf{X}_0|+(1-t)|\mathbf{X}_1-\mathbf{X}_0|\\
\ar< tr+(1-t)r=r.
\end{eqnarray*}
\vskip-2em
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Suppose that $r>0$. If $|\\mathbf{X}_1-\\mathbf{X}_0|<r,\\quad |\\mathbf{X}_2-\\mathbf{X}_0|<r,$", "statement": "Premise:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d)\n    (hr : 0 < r)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that X\u2080, X\u2081, X\u2082 are vectors in a real normed vector space V. The type classes [NormedAddCommGroup V] [NormedSpace \u211d V] properly establish V as a real normed vector space, and (X\u2080 X\u2081 X\u2082 : V) declares the three vectors as elements of V.", "The condition r > 0 is perfectly captured by (r : \u211d) declaring r as a real number and (hr : 0 < r) stating the positivity constraint.", "The condition |\ud835\udc17\u2081 - \ud835\udc17\u2080| < r is perfectly captured by (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r), where \u2016\u00b7\u2016 is the standard notation for norm in Lean.", "The condition |\ud835\udc17\u2082 - \ud835\udc17\u2080| < r is perfectly captured by (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r), where \u2016\u00b7\u2016 is the standard notation for norm in Lean."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The line segment is given by\n$$\n\\mathbf{X}=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1,\\quad 0<t<1.\n$$", "statement": "Definition:\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes X as a point on a line segment, but the Lean theorem doesn't define or mention X at all. Instead, it introduces extra variables X\u2080, r and conditions about norms that are completely absent from the natural language.", "The condition on t being a real number with 0 < t < 1 matches perfectly between natural language and Lean (ht : 0 < t \u2227 t < 1).", "The natural language concludes with a definition X = tX\u2082 + (1-t)X\u2081, but the Lean theorem concludes with a norm inequality \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r, which is a completely different mathematical statement involving norms and bounds rather than a simple definition."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language describes X as a point on a line segment, but the Lean theorem doesn't define or mention X at all. Instead, it introduces extra variables X\u2080, r and conditions about norms that are completely absent from the natural language.\", 'The condition on t being a real number with 0 < t < 1 matches perfectly between natural language and Lean (ht : 0 < t \u2227 t < 1).', 'The natural language concludes with a definition X = tX\u2082 + (1-t)X\u2081, but the Lean theorem concludes with a norm inequality \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r, which is a completely different mathematical statement involving norms and bounds rather than a simple definition.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "$|\\mathbf{X}-\\mathbf{X}_0|\\ar=|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|$", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n  have h_main : t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n    calc\n      t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (t \u2022 X\u2080 + (1 - t) \u2022 X\u2080) := by\n        have h\u2081 : X\u2080 = t \u2022 X\u2080 + (1 - t) \u2022 X\u2080 := by\n          calc\n            X\u2080 = (t + (1 - t)) \u2022 X\u2080 := by\n              rw [add_sub_cancel]\n              <;> simp [one_smul]\n            _ = t \u2022 X\u2080 + (1 - t) \u2022 X\u2080 := by\n              rw [add_smul]\n              <;> ring_nf\n              <;> simp [one_smul]\n        rw [h\u2081]\n        <;> simp [sub_add]\n      _ = (t \u2022 X\u2082 - t \u2022 X\u2080) + ((1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080) := by\n        abel\n      _ = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n        have h\u2082 : t \u2022 X\u2082 - t \u2022 X\u2080 = t \u2022 (X\u2082 - X\u2080) := by\n          rw [\u2190 smul_sub]\n          <;> simp [sub_smul]\n        have h\u2083 : (1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080 = (1 - t) \u2022 (X\u2081 - X\u2080) := by\n          rw [\u2190 smul_sub]\n          <;> simp [sub_smul]\n        rw [h\u2082, h\u2083]\n        <;> simp [add_assoc]\n  \n  have h_final : \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n    rw [h_main]\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The vector space setup is correctly formalized with appropriate type classes for normed vector spaces over reals.", "All variables are properly declared with correct types matching the natural language description.", "The distance constraints are accurately captured using norm notation, which is equivalent to the absolute value notation in the natural language.", "The parameter constraints 0<t<1 are correctly formalized using conjunction.", "The point definition is handled appropriately - while not explicitly defined as a separate variable, the expression is used directly in the theorem statement which is mathematically equivalent.", "The main conclusion is mathematically equivalent to the natural language statement. The right-hand side in Lean is an algebraically equivalent form that factors out the differences from X\u2080, which matches the mathematical intent of the original expression."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "\\ar=|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)\\mathbf{X}_1-\\mathbf{X}_0)|", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|$ [l1].\nTherefore, we conclude:\n\u2022 $|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l2].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n  have h_main : t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 := by\n    calc\n      t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) = (t \u2022 X\u2082 - t \u2022 X\u2080) + ((1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080) := by\n        -- Distribute scalar multiplication over subtraction\n        rw [smul_sub, smul_sub]\n        <;> simp [sub_eq_add_neg]\n        <;> abel\n      _ = t \u2022 X\u2082 - t \u2022 X\u2080 + (1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080 := by\n        -- Reassociate and rearrange terms\n        abel\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (t \u2022 X\u2080 + (1 - t) \u2022 X\u2080) := by\n        -- Reassociate and rearrange terms\n        abel\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - ((t + (1 - t)) \u2022 X\u2080) := by\n        -- Factor out X\u2080\n        rw [add_smul]\n        <;> ring_nf\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (1 \u2022 X\u2080) := by\n        -- Simplify coefficients\n        have h\u2081 : (t + (1 - t) : \u211d) = 1 := by ring\n        rw [h\u2081]\n        <;> simp\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 := by\n        -- Simplify scalar multiplication\n        simp [one_smul]\n  \n  have h_final : \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n    rw [h_main]\n    <;>\n    simp_all [norm_sub_rev]\n    <;>\n    linarith\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the mathematical essence correctly but skips an intermediate algebraic step that is explicitly shown in the natural language. The natural language shows the step |t\ud835\udc17\u2082+(1-t)\ud835\udc17\u2081-t\ud835\udc17\u2080-(1-t)\ud835\udc17\u2080| before simplifying to the final form, while Lean directly uses the simplified form |t\u2022X\u2082+(1-t)\u2022X\u2081-X\u2080|. This represents a structural difference in the logical presentation, though the mathematical content is equivalent."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization captures the mathematical essence correctly but skips an intermediate algebraic step that is explicitly shown in the natural language. The natural language shows the step |t\ud835\udc17\u2082+(1-t)\ud835\udc17\u2081-t\ud835\udc17\u2080-(1-t)\ud835\udc17\u2080| before simplifying to the final form, while Lean directly uses the simplified form |t\u2022X\u2082+(1-t)\u2022X\u2081-X\u2080|. This represents a structural difference in the logical presentation, though the mathematical content is equivalent.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "\\ar\\le  t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|$ [l1].\n\u2022 $|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l2].\nTherefore, we conclude:\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l3].", "dependencies": ["tc_1", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n  (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n  (hr : 0 < r)\n  (ht : 0 < t \u2227 t < 1)\n  (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n  (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n  \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n  (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n  (hr : 0 < r)\n  (ht : 0 < t \u2227 t < 1)\n  (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n  (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n  \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n  have h\u2081 : 0 < 1 - t := by\n    have h\u2081 : t < 1 := ht.2\n    linarith\n\n  have h\u2082 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n    -- Apply the triangle inequality to the sum of the two vectors\n    calc\n      \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n        -- Use the triangle inequality for norms\n        apply norm_add_le\n      _ = \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by rfl\n\n  have h\u2083 : \u2016t \u2022 (X\u2082 - X\u2080)\u2016 = t * \u2016X\u2082 - X\u2080\u2016 := by\n    -- Use the property of norms for scalar multiplication\n    calc\n      \u2016t \u2022 (X\u2082 - X\u2080)\u2016 = |t| * \u2016X\u2082 - X\u2080\u2016 := by\n        -- Apply the norm_smul lemma\n        rw [norm_smul]\n        <;> simp [Real.norm_eq_abs]\n      _ = t * \u2016X\u2082 - X\u2080\u2016 := by\n        -- Since t > 0, |t| = t\n        have h\u2083 : 0 < t := ht.1\n        rw [abs_of_nonneg (le_of_lt h\u2083)]\n        <;> ring\n\n  have h\u2084 : \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 = (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    -- Use the property of norms for scalar multiplication\n    calc\n      \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 = |(1 - t : \u211d)| * \u2016X\u2081 - X\u2080\u2016 := by\n        -- Apply the norm_smul lemma\n        rw [norm_smul]\n        <;> simp [Real.norm_eq_abs]\n      _ = (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n        -- Since 1 - t > 0, |1 - t| = 1 - t\n        have h\u2084 : 0 < (1 - t : \u211d) := by exact_mod_cast h\u2081\n        rw [abs_of_nonneg (le_of_lt h\u2084)]\n        <;> ring\n\n  have h\u2085 : \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 = t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    -- Substitute the results from h\u2083 and h\u2084 into the sum\n    rw [h\u2083, h\u2084]\n    <;> ring\n\n  have h\u2086 : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    -- Combine the inequalities using the previous steps\n    calc\n      \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := h\u2082\n      _ = t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by rw [h\u2085]\n\n  exact h\u2086", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The vector space setup and basic assumptions are correctly formalized with appropriate type classes and constraints.", "The parameter constraints for the line segment are properly captured, though the explicit point X is not defined (which is fine since it's used implicitly in the conclusion).", "The intermediate algebraic steps are not shown in Lean but lead to the same mathematical expression used in the conclusion.", "The triangle inequality conclusion is correctly formalized with equivalent mathematical meaning, using appropriate Lean notation for scalar multiplication and norms."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "\\ar< tr+(1-t)r", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l3].\nTherefore, we conclude:\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < tr+(1-t)r$ [l4].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n  (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n  (hr : 0 < r)\n  (ht : 0 < t \u2227 t < 1)\n  (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n  (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r)\n  (h_triangle : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016) :\n  t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n  (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n  (hr : 0 < r)\n  (ht : 0 < t \u2227 t < 1)\n  (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n  (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r)\n  (h_triangle : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016) :\n  t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n  have h1 : t * \u2016X\u2082 - X\u2080\u2016 < t * r := by\n    have h\u2081 : 0 < t := ht.1\n    have h\u2082 : \u2016X\u2082 - X\u2080\u2016 < r := hX\u2082\n    have h\u2083 : 0 \u2264 \u2016X\u2082 - X\u2080\u2016 := norm_nonneg _\n    have h\u2084 : 0 \u2264 r := by linarith\n    -- Multiply both sides of the inequality by the positive number t\n    nlinarith\n  \n  have h2 : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := by\n    have h\u2082 : t < 1 := ht.2\n    have h\u2083 : 0 < 1 - t := by linarith\n    have h\u2084 : \u2016X\u2081 - X\u2080\u2016 < r := hX\u2081\n    have h\u2085 : 0 \u2264 \u2016X\u2081 - X\u2080\u2016 := norm_nonneg _\n    have h\u2086 : 0 \u2264 r := by linarith\n    -- Multiply both sides of the inequality by the positive number (1 - t)\n    nlinarith\n  \n  have h3 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n    -- Add the two inequalities h1 and h2\n    have h\u2083 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n      linarith\n    exact h\u2083\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical content from the natural language. While the definition of point X on the line segment is omitted, this doesn't affect the logical correctness since X is not used in the theorem statement being proven. All assumptions (vector space structure, constraints on r and t, distance bounds, triangle inequality) and the conclusion are accurately represented. The use of appropriate Lean notation (\u2016\u00b7\u2016 for norms, \u2022 for scalar multiplication, * for real multiplication) correctly translates the mathematical expressions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "=r.", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < tr+(1-t)r$ [l4].\nTherefore, we conclude:\n\u2022 $tr+(1-t)r = r$ [l5].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n  (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n  (hr : 0 < r)\n  (ht : 0 < t \u2227 t < 1)\n  (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n  (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r)\n  (h_triangle : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016) :\n  t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n  (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n  (hr : 0 < r)\n  (ht : 0 < t \u2227 t < 1)\n  (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n  (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r)\n  (h_triangle : \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016) :\n  t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n  have h1 : t * \u2016X\u2082 - X\u2080\u2016 < t * r := by\n    have h\u2081 : 0 < t := ht.1\n    have h\u2082 : \u2016X\u2082 - X\u2080\u2016 < r := hX\u2082\n    have h\u2083 : 0 \u2264 \u2016X\u2082 - X\u2080\u2016 := norm_nonneg _\n    have h\u2084 : 0 \u2264 r := by linarith\n    -- Multiply both sides of the inequality by t > 0\n    nlinarith\n  \n  have h2 : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := by\n    have h\u2082 : 0 < 1 - t := by linarith [ht.2]\n    have h\u2083 : \u2016X\u2081 - X\u2080\u2016 < r := hX\u2081\n    have h\u2084 : 0 \u2264 \u2016X\u2081 - X\u2080\u2016 := norm_nonneg _\n    have h\u2085 : 0 \u2264 r := by linarith\n    -- Multiply both sides of the inequality by (1 - t) > 0\n    nlinarith\n  \n  have h3 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n    have h\u2083 : t * \u2016X\u2082 - X\u2080\u2016 < t * r := h1\n    have h\u2084 : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := h2\n    -- Add the two inequalities\n    linarith\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations and basic constraints (r > 0, distance bounds) are correctly captured in Lean with appropriate type declarations for normed vector space.", "The constraint 0 < t < 1 is properly formalized as a conjunction in Lean.", "The inequality l4 is correctly represented with proper notation for norms and arithmetic operations.", "The main conclusion l5 (tr + (1-t)r = r) is completely missing from the Lean formalization. Instead, the Lean proves the inequality l4, which contradicts the natural language structure where l4 is a premise and l5 is the conclusion.", "The triangle inequality assumption in Lean is mathematically sound and provides necessary context, even though not explicitly mentioned in natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations and basic constraints (r > 0, distance bounds) are correctly captured in Lean with appropriate type declarations for normed vector space.', 'The constraint 0 < t < 1 is properly formalized as a conjunction in Lean.', 'The inequality l4 is correctly represented with proper notation for norms and arithmetic operations.', 'The main conclusion l5 (tr + (1-t)r = r) is completely missing from the Lean formalization. Instead, the Lean proves the inequality l4, which contradicts the natural language structure where l4 is a premise and l5 is the conclusion.', 'The triangle inequality assumption in Lean is mathematically sound and provides necessary context, even though not explicitly mentioned in natural language.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "then so is every point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2.$", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be vectors in a real normed vector space $V$. We assume $r>0$, $|\\mathbf{X}_1-\\mathbf{X}_0|<r$, and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [tc_1].\n\u2022 Let $\\mathbf{X}$ be a point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for a real number $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ follows by combining [l1] and [l2].\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l3].\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < tr+(1-t)r$ [l4].\n\u2022 $tr+(1-t)r = r$ [l5].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| < r$ [ts_1].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]\n    (X\u2080 X\u2081 X\u2082 : V) (r : \u211d) (t : \u211d)\n    (hr : 0 < r)\n    (ht : 0 < t \u2227 t < 1)\n    (hX\u2081 : \u2016X\u2081 - X\u2080\u2016 < r)\n    (hX\u2082 : \u2016X\u2082 - X\u2080\u2016 < r) :\n    \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r := by\n  have h\u2081 : t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n    calc\n      t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080 = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (1 : \u211d) \u2022 X\u2080 := by simp [one_smul]\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (t + (1 - t)) \u2022 X\u2080 := by\n        have h\u2082 : (1 : \u211d) = t + (1 - t) := by linarith\n        rw [h\u2082]\n        <;> simp [add_smul]\n      _ = t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - (t \u2022 X\u2080 + (1 - t) \u2022 X\u2080) := by\n        simp [add_smul]\n        <;> abel\n      _ = (t \u2022 X\u2082 - t \u2022 X\u2080) + ((1 - t) \u2022 X\u2081 - (1 - t) \u2022 X\u2080) := by\n        abel\n      _ = t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080) := by\n        simp [sub_smul, smul_sub]\n        <;> abel\n  \n  have h\u2082 : \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n    calc\n      \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 = \u2016t \u2022 (X\u2082 - X\u2080) + (1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by rw [h\u2081]\n      _ \u2264 \u2016t \u2022 (X\u2082 - X\u2080)\u2016 + \u2016(1 - t) \u2022 (X\u2081 - X\u2080)\u2016 := by\n        apply norm_add_le\n      _ = |t| * \u2016X\u2082 - X\u2080\u2016 + |(1 - t : \u211d)| * \u2016X\u2081 - X\u2080\u2016 := by\n        simp [norm_smul, Real.norm_eq_abs]\n        <;>\n        ring_nf\n      _ = t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := by\n        have h\u2083 : 0 < t := ht.1\n        have h\u2084 : t < 1 := ht.2\n        have h\u2085 : 0 < (1 - t : \u211d) := by linarith\n        have h\u2086 : |t| = t := abs_of_pos h\u2083\n        have h\u2087 : |(1 - t : \u211d)| = (1 - t : \u211d) := abs_of_pos (by linarith)\n        rw [h\u2086, h\u2087]\n        <;>\n        ring_nf\n  \n  have h\u2083 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < r := by\n    have h\u2083\u2081 : t * \u2016X\u2082 - X\u2080\u2016 < t * r := by\n      -- Multiply both sides of the inequality \u2016X\u2082 - X\u2080\u2016 < r by t (which is positive)\n      have h\u2083\u2081\u2081 : 0 < t := ht.1\n      have h\u2083\u2081\u2082 : \u2016X\u2082 - X\u2080\u2016 < r := hX\u2082\n      nlinarith\n    have h\u2083\u2082 : (1 - t) * \u2016X\u2081 - X\u2080\u2016 < (1 - t) * r := by\n      -- Multiply both sides of the inequality \u2016X\u2081 - X\u2080\u2016 < r by (1 - t) (which is positive)\n      have h\u2083\u2082\u2081 : 0 < (1 - t : \u211d) := by linarith [ht.2]\n      have h\u2083\u2082\u2082 : \u2016X\u2081 - X\u2080\u2016 < r := hX\u2081\n      nlinarith\n    -- Combine the two inequalities using linear arithmetic\n    have h\u2083\u2083 : t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 < t * r + (1 - t) * r := by\n      linarith\n    -- Simplify the right-hand side\n    have h\u2083\u2084 : t * r + (1 - t) * r = r := by\n      ring_nf\n      <;>\n      linarith [ht.1, ht.2]\n    -- Conclude the proof\n    linarith\n  \n  have h\u2084 : \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r := by\n    calc\n      \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 \u2264 t * \u2016X\u2082 - X\u2080\u2016 + (1 - t) * \u2016X\u2081 - X\u2080\u2016 := h\u2082\n      _ < r := h\u2083\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The vector space structure is properly formalized with NormedAddCommGroup and NormedSpace over reals. All assumptions (r > 0, distance bounds, parameter constraints 0 < t < 1) are accurately represented. The conclusion \u2016t \u2022 X\u2082 + (1 - t) \u2022 X\u2081 - X\u2080\u2016 < r perfectly matches the natural language goal |X - X\u2080| < r where X = tX\u2082 + (1-t)X\u2081. The use of \u2022 for scalar multiplication and \u2016\u00b7\u2016 for norms follows standard Lean conventions and is semantically equivalent to the natural language notation.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    