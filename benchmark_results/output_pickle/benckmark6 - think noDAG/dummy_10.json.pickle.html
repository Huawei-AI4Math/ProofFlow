
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $A$ and $B$ be $n 	imes n$ matrices. If $AB = I$ where $I$ is the identity matrix, then $\det(A) 
eq 0$ and $\det(B) = rac{1}{\det(A)}$.

Proof: Since $AB = I$, we can take the determinant of both sides: $\det(AB) = \det(I)$. We know that $\det(I) = 1$ for any identity matrix. By the multiplicative property of determinants, $\det(AB) = \det(A) \cdot \det(B)$. Therefore, $\det(A) \cdot \det(B) = 1$. For this equation to hold, we need $\det(A) 
eq 0$ (otherwise the product would be $0$, not $1$). Since $\det(A) \cdot \det(B) = 1$ and $\det(A) 
eq 0$, we can divide both sides by $\det(A)$ to get $\det(B) = rac{1}{\det(A)}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let A and B be n x n matrices.", "statement": "Premise:\n\u2022 A and B are n\u00d7n matrices [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det A \u2260 0 \u2227 Matrix.det B = (Matrix.det A)\u207b\u00b9 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that A and B are n\u00d7n matrices, with the additional type specification over reals being an acceptable detail", "The Lean introduces an additional condition 'A * B = 1' that is completely absent from the natural language statement", "The natural language explicitly states no conclusions are derived, but the Lean formalization includes conclusions about matrix determinants"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that A and B are n\u00d7n matrices, with the additional type specification over reals being an acceptable detail', \"The Lean introduces an additional condition 'A * B = 1' that is completely absent from the natural language statement\", 'The natural language explicitly states no conclusions are derived, but the Lean formalization includes conclusions about matrix determinants']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If AB = I where I is the identity matrix", "statement": "Premise:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1)\ntheorem tc_1 : Matrix.det A \u2260 0 \u2227 Matrix.det B = (Matrix.det A)\u207b\u00b9 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean theorem does not state the fundamental conditions that A and B are n\u00d7n matrices and that AB = I. Instead, it jumps directly to conclusions about determinants without establishing the premises.", "The Lean theorem proves properties about determinants (det A \u2260 0 and det B = (det A)\u207b\u00b9) that are not mentioned in the natural language statement. While these may be logical consequences of the given conditions, they represent new conclusions not present in the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean theorem does not state the fundamental conditions that A and B are n\u00d7n matrices and that AB = I. Instead, it jumps directly to conclusions about determinants without establishing the premises.', 'The Lean theorem proves properties about determinants (det A \u2260 0 and det B = (det A)\u207b\u00b9) that are not mentioned in the natural language statement. While these may be logical consequences of the given conditions, they represent new conclusions not present in the original statement.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since AB = I, we can take the determinant of both sides: det(AB) = det(I).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2].\nTherefore, we conclude:\n\u2022 det(AB) = det(I) [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det (A * B) = Matrix.det 1 := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 23, "endLine": 9, "endColumn": 35, "data": "typeclass instance problem is stuck, it is often due to metavariables\n  Fintype ?m.358"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det (A * B) = Matrix.det 1 := by\n  have h_main : Matrix.det (A * B) = Matrix.det 1 := by\n    rw [h]\n    <;>\n    simp [Matrix.det_one]\n    <;>\n    infer_instance\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 6, "column": 23, "endLine": 6, "endColumn": 35, "data": "typeclass instance problem is stuck, it is often due to metavariables\n  Fintype ?m.358"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "We know that det(I) = 1 for any identity matrix.", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1].\nTherefore, we conclude:\n\u2022 det(I) = 1 [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) \n  (l1 : Matrix.det (A * B) = Matrix.det 1) :\n  Matrix.det 1 = 1 := by sorry", "lean_pass": false, "error_msg": [{"line": 10, "column": 2, "endLine": 10, "endColumn": 14, "data": "failed to synthesize\n  CommRing \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) \n  (l1 : Matrix.det (A * B) = Matrix.det 1) :\n  Matrix.det 1 = 1 := by\n  have h_main : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1 := by\n    apply @Matrix.det_one (Fin n) \u211d\n    <;>\n    infer_instance\n  simpa using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "By the multiplicative property of determinants, det(AB) = det(A) * det(B).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2].\nTherefore, we conclude:\n\u2022 det(AB) = det(A) * det(B) [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem Matrix.det_inv {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det A \u2260 0 \u2227 Matrix.det B = (Matrix.det A)\u207b\u00b9 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem Matrix.det_inv {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det A \u2260 0 \u2227 Matrix.det B = (Matrix.det A)\u207b\u00b9 := by\n  have h_det_mul : Matrix.det A * Matrix.det B = 1 := by\n    have h1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) := by rw [h]\n    have h2 : Matrix.det (A * B) = Matrix.det A * Matrix.det B := by\n      apply Matrix.det_mul\n    have h3 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = (1 : \u211d) := by\n      simp [Matrix.det_one]\n    rw [h2] at h1\n    rw [h3] at h1\n    norm_num at h1 \u22a2\n    <;> linarith\n  \n  have h_det_A_ne_zero : Matrix.det A \u2260 0 := by\n    by_contra h\u2081\n    have h\u2082 : Matrix.det A = 0 := by simpa using h\u2081\n    have h\u2083 : Matrix.det A * Matrix.det B = 1 := h_det_mul\n    rw [h\u2082] at h\u2083\n    norm_num at h\u2083 \u22a2\n    <;> simp_all\n  \n  have h_det_B_inv : Matrix.det B = (Matrix.det A)\u207b\u00b9 := by\n    have h\u2081 : Matrix.det A * Matrix.det B = 1 := h_det_mul\n    have h\u2082 : Matrix.det A \u2260 0 := h_det_A_ne_zero\n    have h\u2083 : Matrix.det B = (Matrix.det A)\u207b\u00b9 := by\n      apply Eq.symm\n      apply Eq.symm\n      field_simp [h\u2082] at h\u2081 \u22a2\n      <;> nlinarith\n    exact h\u2083\n  \n  exact \u27e8h_det_A_ne_zero, h_det_B_inv\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The matrix setup and fundamental premise AB = I are correctly captured in the Lean formalization with appropriate type declarations.", "While the natural language shows intermediate steps (det(AB) = det(I) = 1) and the Lean formalization omits these, both arrive at mathematically equivalent conclusions through valid reasoning paths.", "The conclusion det(B) = (det(A))\u207b\u00b9 in Lean is mathematically equivalent to the natural language conclusion det(AB) = det(A) * det(B) given the premise AB = I. The Lean version also includes the additional logical consequence that det(A) \u2260 0, which is implicit but necessary in the natural language reasoning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Therefore, det(A) * det(B) = 1.", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2];\n\u2022 det(AB) = det(A) * det(B) [l3].\nTherefore, we conclude:\n\u2022 det(A) * det(B) = 1 [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem Matrix.det_inv {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det A \u2260 0 \u2227 Matrix.det B = (Matrix.det A)\u207b\u00b9 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem Matrix.det_inv {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d) \n  (h : A * B = 1) : \n  Matrix.det A \u2260 0 \u2227 Matrix.det B = (Matrix.det A)\u207b\u00b9 := by\n  have h_det_mul : Matrix.det A * Matrix.det B = 1 := by\n    have h1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) := by rw [h]\n    have h2 : Matrix.det (A * B) = Matrix.det A * Matrix.det B := by\n      apply Matrix.det_mul\n    have h3 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = (1 : \u211d) := by\n      simp [Matrix.det_one]\n    rw [h2] at h1\n    rw [h3] at h1\n    exact h1\n  \n  have h_det_A_ne_zero : Matrix.det A \u2260 0 := by\n    by_contra h\u2081\n    have h\u2082 : Matrix.det A = 0 := by simpa using h\u2081\n    rw [h\u2082] at h_det_mul\n    norm_num at h_det_mul\n    <;> simp_all\n  \n  have h_det_B : Matrix.det B = (Matrix.det A)\u207b\u00b9 := by\n    have h\u2081 : Matrix.det A * Matrix.det B = 1 := h_det_mul\n    have h\u2082 : Matrix.det A \u2260 0 := h_det_A_ne_zero\n    have h\u2083 : Matrix.det B = (Matrix.det A)\u207b\u00b9 := by\n      apply eq_inv_of_mul_eq_one_left\n      linarith\n    exact h\u2083\n  \n  exact \u27e8h_det_A_ne_zero, h_det_B\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language. While the natural language concludes det(A) * det(B) = 1 and the Lean version states det(B) = (det(A))\u207b\u00b9, these are mathematically equivalent. The additional constraint det(A) \u2260 0 in the Lean version is a logically consistent and necessary consequence of the hypothesis A * B = 1, making this an acceptable enhancement that doesn't contradict the original reasoning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "For this equation to hold, we need det(A) != 0 (otherwise the product would be 0, not 1).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2];\n\u2022 det(AB) = det(A) * det(B) [l3];\n\u2022 det(A) * det(B) = 1 [l4].\nTherefore, we conclude:\n\u2022 det(A) \u2260 0 [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (h : A * B = 1)\n  (l1 : (A * B).det = (1 : Matrix (Fin n) (Fin n) \u211d).det)\n  (l2 : (1 : Matrix (Fin n) (Fin n) \u211d).det = 1)\n  (l3 : (A * B).det = A.det * B.det)\n  (l4 : A.det * B.det = 1) :\n  A.det \u2260 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (h : A * B = 1)\n  (l1 : (A * B).det = (1 : Matrix (Fin n) (Fin n) \u211d).det)\n  (l2 : (1 : Matrix (Fin n) (Fin n) \u211d).det = 1)\n  (l3 : (A * B).det = A.det * B.det)\n  (l4 : A.det * B.det = 1) :\n  A.det \u2260 0 := by\n  have h_main : A.det \u2260 0 := by\n    by_contra h5\n    -- Assume A.det = 0 and derive a contradiction\n    have h6 : A.det = 0 := by simpa using h5\n    have h7 : A.det * B.det = 0 := by\n      rw [h6]\n      ring\n    -- From l4, A.det * B.det = 1, but we have A.det * B.det = 0, which is a contradiction\n    linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Matrix type declaration correctly captures n\u00d7n matrices with additional real number specification", "Matrix multiplication and identity correctly represented using Lean's matrix notation", "Determinant equality statement correctly formalized", "Identity matrix determinant property correctly stated", "Multiplicative property of determinants correctly formalized", "Derived equality correctly stated as hypothesis", "Conclusion correctly formalized as non-zero determinant"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "ts_2": {"id": "ts_2", "natural_language": "Since det(A) * det(B) = 1 and det(A) != 0, we can divide both sides by det(A) to get det(B) = 1/det(A).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I where I is the identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2];\n\u2022 det(AB) = det(A) * det(B) [l3];\n\u2022 det(A) * det(B) = 1 [l4];\n\u2022 det(A) \u2260 0 [ts_1].\nTherefore, we conclude:\n\u2022 det(B) = 1 / det(A) [ts_2].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (l1 : (A * B).det = (1 : Matrix (Fin n) (Fin n) \u211d).det)\n  (l2 : (1 : Matrix (Fin n) (Fin n) \u211d).det = 1)\n  (l3 : (A * B).det = A.det * B.det)\n  (l4 : A.det * B.det = 1)\n  (ts_1 : A.det \u2260 0) :\n  B.det = (A.det)\u207b\u00b9 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (l1 : (A * B).det = (1 : Matrix (Fin n) (Fin n) \u211d).det)\n  (l2 : (1 : Matrix (Fin n) (Fin n) \u211d).det = 1)\n  (l3 : (A * B).det = A.det * B.det)\n  (l4 : A.det * B.det = 1)\n  (ts_1 : A.det \u2260 0) :\n  B.det = (A.det)\u207b\u00b9 := by\n  have h_main : B.det = (A.det)\u207b\u00b9 := by\n    have h5 : (A.det)\u207b\u00b9 * (A.det * B.det) = (A.det)\u207b\u00b9 * 1 := by\n      rw [l4]\n    have h6 : (A.det)\u207b\u00b9 * (A.det * B.det) = B.det := by\n      calc\n        (A.det)\u207b\u00b9 * (A.det * B.det) = ((A.det)\u207b\u00b9 * A.det) * B.det := by ring\n        _ = 1 * B.det := by\n          have h7 : (A.det)\u207b\u00b9 * A.det = 1 := by\n            field_simp [ts_1]\n          rw [h7]\n        _ = B.det := by ring\n    have h7 : (A.det)\u207b\u00b9 * 1 = (A.det)\u207b\u00b9 := by ring\n    calc\n      B.det = (A.det)\u207b\u00b9 * (A.det * B.det) := by rw [h6]\n      _ = (A.det)\u207b\u00b9 * 1 := by rw [h5]\n      _ = (A.det)\u207b\u00b9 := by rw [h7]\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.88, "semantic_feedback": ["Matrix type declarations correctly capture n\u00d7n matrices with appropriate type specification", "The assumption AB = I [tc_2] is missing from the Lean formalization, though it's logically derivable from l1 and l2", "det(AB) = det(I) is correctly formalized as (A * B).det = (1 : Matrix (Fin n) (Fin n) \u211d).det", "det(I) = 1 is correctly formalized as (1 : Matrix (Fin n) (Fin n) \u211d).det = 1", "The multiplicativity property det(AB) = det(A) * det(B) is correctly captured", "The equation det(A) * det(B) = 1 is correctly formalized", "The non-zero determinant condition det(A) \u2260 0 is correctly captured", "The conclusion uses multiplicative inverse notation (A.det)\u207b\u00b9 which is mathematically equivalent to 1 / det(A)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    