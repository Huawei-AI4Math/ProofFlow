
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: (a) Union of open sets is open. (b) Intersection of closed sets is closed.

Proof: (a) Let G be a collection of open sets, S = ∪G. If x₀ ∈ S, then x₀ ∈ some open G₀, so ∃ ε-nbhd in G₀ ⊆ S ⇒ S open. (b) If F is a collection of closed sets, T = ∩F ⇒ Tᶜ = ∪Fᶜ. Each Fᶜ open ⇒ Tᶜ open ⇒ T closed.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let G be a collection of open sets", "statement": "Premise:\n\u2022 G is a collection of open sets in a topological space X [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [TopologicalSpace X] (G : Set (Set X))\n(tc_1 : \u2200 S \u2208 G, IsOpen S)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the natural language statement. The topological space X is declared with `{X : Type*} [TopologicalSpace X]`, G is declared as a collection of sets with `(G : Set (Set X))`, and the condition that all sets in G are open is expressed with `(tc_1 : \u2200 S \u2208 G, IsOpen S)`. This completely and accurately formalizes the mathematical meaning that G is a collection of open sets in topological space X."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "S = \u222aG", "statement": "We assume:\n\u2022 G is a collection of open sets in a topological space X [tc_1].\nDefinition:\n\u2022 S is the union of all sets in the collection G, i.e., S = \u22c3_{G\u2080 \u2208 G} G\u2080 [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 {X : Type*} [TopologicalSpace X] (G : Set (Set X))\n  (tc_1 : \u2200 S \u2208 G, IsOpen S) :\n  let S := \u22c3 G\u2080 \u2208 G, G\u2080\n  S = \u22c3 G\u2080 \u2208 G, G\u2080 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that G is a collection of open sets in topological space X. The type declarations `X : Type*` with `[TopologicalSpace X]` establish the topological space, `G : Set (Set X)` makes G a collection of sets, and `tc_1 : \u2200 S \u2208 G, IsOpen S` ensures all sets in G are open.", "The Lean proposition `S = \u22c3 G\u2080 \u2208 G, G\u2080` is a tautology since S is defined as exactly `\u22c3 G\u2080 \u2208 G, G\u2080` in the let statement. This doesn't capture the meaningful content of the natural language conclusion, which should be stating that S is defined as this union, not proving an identity that's true by definition."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that G is a collection of open sets in topological space X. The type declarations `X : Type*` with `[TopologicalSpace X]` establish the topological space, `G : Set (Set X)` makes G a collection of sets, and `tc_1 : \u2200 S \u2208 G, IsOpen S` ensures all sets in G are open.', \"The Lean proposition `S = \u22c3 G\u2080 \u2208 G, G\u2080` is a tautology since S is defined as exactly `\u22c3 G\u2080 \u2208 G, G\u2080` in the let statement. This doesn't capture the meaningful content of the natural language conclusion, which should be stating that S is defined as this union, not proving an identity that's true by definition.\"]"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If x\u2080 \u2208 S, then x\u2080 \u2208 some open G\u2080", "statement": "We assume:\n\u2022 G is a collection of open sets in a topological space X [tc_1];\n\u2022 S is the union of all sets in the collection G, i.e., S = \u22c3_{G\u2080 \u2208 G} G\u2080 [def_1].\nTherefore, we conclude:\n\u2022 For any element x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S) :\n  \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S) :\n  \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by\n  have h1 : x\u2080 \u2208 \u22c3 G\u2080 \u2208 G, G\u2080 := by\n    rw [hS_def] at hx\u2080\n    exact hx\u2080\n  \n  have h2 : x\u2080 \u2208 \u22c3 (G\u2080 : Set X) (_ : G\u2080 \u2208 G), G\u2080 := by\n    -- Prove that \u22c3 G\u2080 \u2208 G, G\u2080 is equal to \u22c3 (G\u2080 : Set X) (_ : G\u2080 \u2208 G), G\u2080\n    have h3 : (\u22c3 G\u2080 \u2208 G, G\u2080 : Set X) = \u22c3 (G\u2080 : Set X) (_ : G\u2080 \u2208 G), G\u2080 := by\n      rfl\n    -- Use the equality to rewrite h1\n    rw [h3] at h1\n    -- Now h1 is exactly the statement we need\n    exact h1\n  \n  have h3 : \u2203 (G\u2080 : Set X) (_ : G\u2080 \u2208 G), x\u2080 \u2208 G\u2080 := by\n    -- Use the fact that x\u2080 is in the union to find a set G\u2080 in G that contains x\u2080\n    have h4 : x\u2080 \u2208 \u22c3 (G\u2080 : Set X) (_ : G\u2080 \u2208 G), G\u2080 := h2\n    -- Use the property of unions to get the existence of G\u2080\n    have h5 : \u2203 (G\u2080 : Set X) (_ : G\u2080 \u2208 G), x\u2080 \u2208 G\u2080 := by\n      -- Use the lemma that characterizes membership in a union\n      simpa using h4\n    -- The result follows directly from the lemma\n    exact h5\n  \n  have h4 : \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by\n    obtain \u27e8G\u2080, hG\u2080_in_G, hx\u2080_in_G\u2080\u27e9 := h3\n    refine' \u27e8G\u2080, hG\u2080_in_G, _\u27e9\n    exact hx\u2080_in_G\u2080\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The topological space and collection of open sets are correctly formalized. The additional hG_open constraint appropriately captures that G contains open sets.", "The union definition S = \u22c3 G\u2080 \u2208 G, G\u2080 perfectly matches the mathematical notation in the natural language.", "The element membership premise x\u2080 \u2208 S is correctly represented as a hypothesis.", "The existential conclusion correctly captures the existence of a set G\u2080 in collection G containing x\u2080."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "x\u2080 \u2208 some open G\u2080, so \u2203 \u03b5-nbhd in G\u2080", "statement": "We assume:\n\u2022 G is a collection of open sets in a topological space X [tc_1];\n\u2022 S is the union of all sets in the collection G, i.e., S = \u22c3_{G\u2080 \u2208 G} G\u2080 [def_1];\n\u2022 For any element x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1].\nTherefore, we conclude:\n\u2022 Since G\u2080 is an open set and x\u2080 \u2208 G\u2080, by the definition of an open set, there exists an open neighborhood N of x\u2080 such that N \u2286 G\u2080 [l2].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S)\n  (G\u2080 : Set X)\n  (hG\u2080 : G\u2080 \u2208 G)\n  (hx\u2080_in_G\u2080 : x\u2080 \u2208 G\u2080) :\n  \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S)\n  (G\u2080 : Set X)\n  (hG\u2080 : G\u2080 \u2208 G)\n  (hx\u2080_in_G\u2080 : x\u2080 \u2208 G\u2080) :\n  \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080 := by\n  have hG\u2080_open : IsOpen G\u2080 := by\n    have h\u2081 : IsOpen G\u2080 := hG_open G\u2080 hG\u2080\n    exact h\u2081\n  \n  have h_main : \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080 := by\n    refine' \u27e8G\u2080, hG\u2080_open, hx\u2080_in_G\u2080, _\u27e9\n    -- We need to show that G\u2080 \u2286 G\u2080, which is trivially true.\n    <;> simp [Set.Subset.refl]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The topological space setup and openness conditions are correctly formalized with appropriate type constraints and hypotheses.", "The union definition is precisely captured using Lean's indexed union notation, maintaining the exact mathematical meaning.", "The membership and existence relationships are properly formalized, with the Lean version making the existential witness explicit as a parameter.", "The conclusion correctly formalizes the existence of an open neighborhood with the required properties, capturing the essence of the topological argument."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "\u2203 \u03b5-nbhd in G\u2080 \u2286 S", "statement": "We assume:\n\u2022 G is a collection of open sets in a topological space X [tc_1];\n\u2022 S is the union of all sets in the collection G, i.e., S = \u22c3_{G\u2080 \u2208 G} G\u2080 [def_1];\n\u2022 For any element x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For such a G\u2080 and x\u2080, there exists an open neighborhood N of x\u2080 such that N \u2286 G\u2080 [l2].\nTherefore, we conclude:\n\u2022 Since N \u2286 G\u2080 and G\u2080 \u2286 S (as G\u2080 is a member of the collection G), it follows that N \u2286 S [l3].", "dependencies": ["tc_1", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [TopologicalSpace X] (G : Set (Set X))\n(tc_1 : \u2200 S \u2208 G, IsOpen S)\n\ntheorem def_1 {X : Type*} [TopologicalSpace X] (G : Set (Set X))\n  (tc_1 : \u2200 S \u2208 G, IsOpen S) :\n  let S := \u22c3 G\u2080 \u2208 G, G\u2080\n  S = \u22c3 G\u2080 \u2208 G, G\u2080 := by sorry\n\ntheorem l1 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S) :\n  \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by sorry\n\ntheorem l2 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S)\n  (G\u2080 : Set X)\n  (hG\u2080 : G\u2080 \u2208 G)\n  (hx\u2080_in_G\u2080 : x\u2080 \u2208 G\u2080) :\n  \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080 := by sorry\n\ntheorem l3 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S)\n  (G\u2080 : Set X)\n  (hG\u2080 : G\u2080 \u2208 G)\n  (hx\u2080_in_G\u2080 : x\u2080 \u2208 G\u2080)\n  (N : Set X)\n  (hN : IsOpen N)\n  (hx\u2080_in_N : x\u2080 \u2208 N)\n  (hN_subset_G\u2080 : N \u2286 G\u2080) :\n  N \u2286 S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 {X : Type*} [TopologicalSpace X] (G : Set (Set X))\n  (tc_1 : \u2200 S \u2208 G, IsOpen S) :\n  let S := \u22c3 G\u2080 \u2208 G, G\u2080\n  S = \u22c3 G\u2080 \u2208 G, G\u2080 := by\n  intro S\n  have h_main : S = \u22c3 G\u2080 \u2208 G, G\u2080 := by\n    rfl\n  exact h_main\n\ntheorem l1 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S) :\n  \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by\n  have h_main : \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by\n    have h\u2081 : x\u2080 \u2208 \u22c3 G\u2080 \u2208 G, G\u2080 := by\n      rw [hS_def] at hx\u2080\n      exact hx\u2080\n    -- Use the property of unions to find the required G\u2080\n    rcases Set.mem_iUnion\u2082.mp h\u2081 with \u27e8G\u2080, hG\u2080, hx\u2080_in_G\u2080\u27e9\n    exact \u27e8G\u2080, hG\u2080, hx\u2080_in_G\u2080\u27e9\n  exact h_main\n\ntheorem l2 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S)\n  (G\u2080 : Set X)\n  (hG\u2080 : G\u2080 \u2208 G)\n  (hx\u2080_in_G\u2080 : x\u2080 \u2208 G\u2080) :\n  \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080 := by\n  have h_main : \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080 := by\n    refine' \u27e8G\u2080, _, hx\u2080_in_G\u2080, _\u27e9\n    \u00b7 -- Prove that G\u2080 is open\n      exact hG_open G\u2080 hG\u2080\n    \u00b7 -- Prove that G\u2080 \u2286 G\u2080\n      exact Set.Subset.refl G\u2080\n  exact h_main\n\ntheorem l3 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (x\u2080 : X)\n  (hx\u2080 : x\u2080 \u2208 S)\n  (G\u2080 : Set X)\n  (hG\u2080 : G\u2080 \u2208 G)\n  (hx\u2080_in_G\u2080 : x\u2080 \u2208 G\u2080)\n  (N : Set X)\n  (hN : IsOpen N)\n  (hx\u2080_in_N : x\u2080 \u2208 N)\n  (hN_subset_G\u2080 : N \u2286 G\u2080) :\n  N \u2286 S := by\n  have h_main : N \u2286 S := by\n    have h\u2081 : G\u2080 \u2286 S := by\n      -- Prove that G\u2080 is a subset of S\n      have h\u2082 : G\u2080 \u2286 \u22c3 G\u2080 \u2208 G, G\u2080 := by\n        -- Since G\u2080 is in G, it is a subset of the union of all sets in G\n        intro x hx\n        -- For any x in G\u2080, x is in the union because G\u2080 is in G\n        exact Set.mem_iUnion\u2082.mpr \u27e8G\u2080, hG\u2080, hx\u27e9\n      -- Since S is the union of all sets in G, G\u2080 is a subset of S\n      rw [hS_def] at *\n      exact h\u2082\n    -- Use the fact that N is a subset of G\u2080 and G\u2080 is a subset of S to conclude N is a subset of S\n    have h\u2083 : N \u2286 G\u2080 := hN_subset_G\u2080\n    have h\u2084 : N \u2286 S := Set.Subset.trans h\u2083 h\u2081\n    exact h\u2084\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations correctly capture that X is a topological space and G is a collection of open sets.", "The definition correctly establishes S as the union of all sets in G, though the theorem statement is tautological by construction.", "Theorem l1 perfectly formalizes the statement that any element in S must belong to some set in the collection G.", "Theorem l2 correctly captures the existence of an open neighborhood N of x\u2080 contained in G\u2080, with all necessary conditions explicitly stated.", "Theorem l3 properly formalizes the transitivity argument showing N \u2286 S, with all required hypotheses including N \u2286 G\u2080 explicitly provided."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "S open", "statement": "We assume:\n\u2022 G is a collection of open sets in a topological space X [tc_1];\n\u2022 S is the union of all sets in the collection G, i.e., S = \u22c3_{G\u2080 \u2208 G} G\u2080 [def_1];\n\u2022 For any element x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For such a G\u2080 and x\u2080, there exists an open neighborhood N of x\u2080 such that N \u2286 G\u2080 [l2];\n\u2022 This neighborhood N is also a subset of S, N \u2286 S [l3].\nTherefore, we conclude:\n\u2022 Since for an arbitrary x\u2080 \u2208 S, we have found an open neighborhood of x\u2080 contained in S, S is an open set [ts_1].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (h_property : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 \u2227 \n    \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080) :\n  IsOpen S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 {X : Type*} [TopologicalSpace X] \n  (G : Set (Set X)) \n  (hG_open : \u2200 S \u2208 G, IsOpen S)\n  (S : Set X)\n  (hS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080)\n  (h_property : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 \u2227 \n    \u2203 N : Set X, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080) :\n  IsOpen S := by\n  have h_main : IsOpen (\u22c3 G\u2080 \u2208 G, G\u2080) := by\n    classical\n    have h\u2081 : IsOpen (\u22c3 s \u2208 G, s) := by\n      apply isOpen_iUnion\n      intro s hs\n      have h\u2082 : IsOpen s := hG_open s hs\n      exact h\u2082\n    have h\u2082 : (\u22c3 s \u2208 G, s) = (\u22c3 G\u2080 \u2208 G, G\u2080) := by\n      simp [Set.biUnion_eq_iUnion]\n      <;>\n      aesop\n    rw [h\u2082] at h\u2081\n    exact h\u2081\n  \n  have h_final : IsOpen S := by\n    rw [hS_def]\n    exact h_main\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 6, "endLine": 16, "endColumn": 16, "data": "tactic 'introN' failed, insufficient number of binders\ncase h\nX : Type u_1\ninst\u271d : TopologicalSpace X\nG : Set (Set X)\nhG_open : \u2200 S \u2208 G, IsOpen S\nS : Set X\nhS_def : S = \u22c3 G\u2080 \u2208 G, G\u2080\nh_property : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 \u2227 \u2203 N, IsOpen N \u2227 x\u2080 \u2208 N \u2227 N \u2286 G\u2080\ns : Set X\n\u22a2 IsOpen (\u22c3 (_ : s \u2208 G), s)"}, {"line": 20, "column": 6, "endLine": 20, "endColumn": 34, "data": "tactic 'simp' failed, nested error:\nmaximum recursion depth has been reached\nuse `set_option maxRecDepth <num>` to increase limit\nuse `set_option diagnostics true` to get diagnostic information"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The topological space setup and the condition that G contains only open sets are correctly formalized.", "The definition of S as the union of all sets in G is perfectly captured using bigunion notation.", "The existence of G\u2080 containing x\u2080 for any x\u2080 \u2208 S is correctly embedded in the combined hypothesis.", "The existence of an open neighborhood N of x\u2080 contained in G\u2080 is properly formalized.", "The crucial condition N \u2286 S is completely missing from the Lean formalization. This is a key logical component needed for the proof that S is open.", "The conclusion that S is open is correctly stated as the theorem goal.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The topological space setup and the condition that G contains only open sets are correctly formalized.', 'The definition of S as the union of all sets in G is perfectly captured using bigunion notation.', 'The existence of G\u2080 containing x\u2080 for any x\u2080 \u2208 S is correctly embedded in the combined hypothesis.', 'The existence of an open neighborhood N of x\u2080 contained in G\u2080 is properly formalized.', 'The crucial condition N \u2286 S is completely missing from the Lean formalization. This is a key logical component needed for the proof that S is open.', 'The conclusion that S is open is correctly stated as the theorem goal.']"}, "solved_negation": null, "type": "solution"}, "tc_2": {"id": "tc_2", "natural_language": "If F is a collection of closed sets", "statement": "Premise:\n\u2022 F is a collection of closed sets in a topological space X [tc_2].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [TopologicalSpace X] (F : Set (Set X))\n(tc_2 : \u2200 S \u2208 F, IsClosed S)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures X as a topological space using the standard Lean syntax for type classes", "The Lean formalization correctly represents F as a collection (Set (Set X)) and ensures all elements are closed sets through the condition tc_2"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_2": {"id": "def_2", "natural_language": "T = \u2229F", "statement": "We assume:\n\u2022 G is a collection of open sets [tc_1];\n\u2022 S = \u22c3G is open [ts_1];\n\u2022 F is a collection of closed sets [tc_2].\nDefinition:\n\u2022 T is the intersection of all sets in the collection F, i.e., T = \u22c2_{F\u2080 \u2208 F} F\u2080 [def_2].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "ts_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2 {X : Type*} [TopologicalSpace X] (F : Set (Set X))\n  (hF_closed : \u2200 S \u2208 F, IsClosed S) :\n  let T := \u22c2 S \u2208 F, S\n  IsClosed T := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language mentions G as a collection of open sets, but the Lean formalization completely omits any reference to G or open sets", "The natural language states S = \u22c3G is open, but this condition is entirely missing from the Lean formalization", "Both the natural language and Lean correctly state that F is a collection of closed sets", "The natural language only defines T as the intersection of sets in F, but the Lean formalization goes further to prove that T is closed, which is not stated as a conclusion in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language mentions G as a collection of open sets, but the Lean formalization completely omits any reference to G or open sets', 'The natural language states S = \u22c3G is open, but this condition is entirely missing from the Lean formalization', 'Both the natural language and Lean correctly state that F is a collection of closed sets', 'The natural language only defines T as the intersection of sets in F, but the Lean formalization goes further to prove that T is closed, which is not stated as a conclusion in the natural language']"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "T\u1d9c = \u222aF\u1d9c", "statement": "We assume:\n\u2022 G is a collection of open sets [tc_1];\n\u2022 S = \u22c3G is open [ts_1];\n\u2022 F is a collection of closed sets [tc_2];\n\u2022 T is the intersection of all sets in F [def_2].\nTherefore, we conclude:\n\u2022 By De Morgan's laws, the complement of T, denoted T\u1d9c, is the union of the complements of the sets in F: T\u1d9c = \u22c3_{F\u2080 \u2208 F} F\u2080\u1d9c [l4].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "ts_1", "tc_2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {X : Type*} [TopologicalSpace X] \n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S)\n  (T : Set X)\n  (hT_def : T = \u22c2 S \u2208 F, S) :\n  T\u1d9c = \u22c3 S \u2208 F, S\u1d9c := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 {X : Type*} [TopologicalSpace X] \n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S)\n  (T : Set X)\n  (hT_def : T = \u22c2 S \u2208 F, S) :\n  T\u1d9c = \u22c3 S \u2208 F, S\u1d9c := by\n  have h_main : (\u22c2 S \u2208 F, S)\u1d9c = \u22c3 S \u2208 F, S\u1d9c := by\n    apply Set.ext\n    intro x\n    simp only [Set.mem_compl_iff, Set.mem_iUnion, Set.mem_iInter, Set.mem_compl_iff]\n    <;>\n    by_cases h : \u2203 (S : Set X), S \u2208 F \u2227 x \u2209 S <;>\n    by_cases h' : \u2200 (S : Set X), S \u2208 F \u2192 x \u2208 S <;>\n    simp_all [not_forall, not_exists, not_not]\n    <;>\n    (try { tauto }) <;>\n    (try {\n      obtain \u27e8S, hS, hx\u27e9 := h\n      exact \u27e8S, hS, hx\u27e9\n    }) <;>\n    (try {\n      exfalso\n      obtain \u27e8S, hS, hx\u27e9 := h\n      have h\u2081 : x \u2208 S := h' S hS\n      contradiction\n    })\n  \n  have h_final : T\u1d9c = \u22c3 S \u2208 F, S\u1d9c := by\n    rw [hT_def]\n    rw [h_main]\n    <;>\n    simp_all\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures F as a collection of sets with the closedness condition properly expressed as a hypothesis.", "The definition of T as the intersection of all sets in F is accurately formalized using the indexed intersection notation.", "The main theorem statement perfectly captures De Morgan's law for the complement of an intersection being the union of complements, with correct notation and quantification.", "The Lean formalization appropriately focuses only on the relevant assumptions needed for the conclusion, correctly omitting the unused assumptions about G and S."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Each F\u1d9c open", "statement": "We assume:\n\u2022 G is a collection of open sets [tc_1];\n\u2022 S = \u22c3G is open [ts_1];\n\u2022 F is a collection of closed sets [tc_2];\n\u2022 T is the intersection of all sets in F [def_2];\n\u2022 T\u1d9c = \u22c3_{F\u2080 \u2208 F} F\u2080\u1d9c [l4].\nTherefore, we conclude:\n\u2022 By the definition of a closed set, the complement of each closed set F\u2080 in F is an open set. Thus, {F\u2080\u1d9c | F\u2080 \u2208 F} is a collection of open sets [l5].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "ts_1", "tc_2", "def_2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {X : Type*} [TopologicalSpace X] \n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S) :\n  \u2200 F\u2080 \u2208 F, IsOpen F\u2080\u1d9c := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 {X : Type*} [TopologicalSpace X] \n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S) :\n  \u2200 F\u2080 \u2208 F, IsOpen F\u2080\u1d9c := by\n  intro F\u2080 hF\u2080\n  have h_closed : IsClosed F\u2080 := by\n    apply hF_closed F\u2080 hF\u2080\n  \n  have h_open : IsOpen F\u2080\u1d9c := by\n    have h\u2081 : IsOpen F\u2080\u1d9c := h_closed.isOpen_compl\n    exact h\u2081\n  \n  exact h_open", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization perfectly captures the mathematical content of conclusion [l5] from the natural language. It correctly formalizes that given a collection F of closed sets, the complement of each closed set in F is open. The theorem statement precisely matches the logical structure and mathematical meaning described in the natural language conclusion, with appropriate type declarations and hypothesis formatting for Lean."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "T\u1d9c open", "statement": "We assume:\n\u2022 The union of any collection of open sets is open [ts_1];\n\u2022 F is a collection of closed sets [tc_2];\n\u2022 T is the intersection of all sets in F [def_2];\n\u2022 T\u1d9c is the union of the complements of the sets in F, {F\u2080\u1d9c | F\u2080 \u2208 F} [l4];\n\u2022 Each complement F\u2080\u1d9c is an open set [l5].\nTherefore, we conclude:\n\u2022 Since T\u1d9c is the union of a collection of open sets, T\u1d9c is itself an open set [l6].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "ts_1", "tc_2", "def_2", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S)\n  (T : Set X)\n  (hT_def : T = \u22c2 S \u2208 F, S)\n  (hT_c_def : T\u1d9c = \u22c3 S \u2208 F, S\u1d9c)\n  (h_comp_open : \u2200 S \u2208 F, IsOpen (S\u1d9c)) :\n  IsOpen (T\u1d9c) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S)\n  (T : Set X)\n  (hT_def : T = \u22c2 S \u2208 F, S)\n  (hT_c_def : T\u1d9c = \u22c3 S \u2208 F, S\u1d9c)\n  (h_comp_open : \u2200 S \u2208 F, IsOpen (S\u1d9c)) :\n  IsOpen (T\u1d9c) := by\n  have h_union_open : IsOpen (\u22c3 S \u2208 F, S\u1d9c) := by\n    classical\n    let \u03b9 := {S : Set X | S \u2208 F}\n    have h\u2081 : IsOpen (\u22c3 (i : \u03b9), (i : Set X)\u1d9c) := by\n      apply isOpen_iUnion\n      intro i\n      have h\u2082 : IsOpen (i : Set X)\u1d9c := by\n        have h\u2083 : (i : Set X) \u2208 F := i.prop\n        exact h_comp_open (i : Set X) h\u2083\n      exact h\u2082\n    have h\u2082 : (\u22c3 (i : \u03b9), (i : Set X)\u1d9c) = (\u22c3 S \u2208 F, S\u1d9c) := by\n      apply Set.ext\n      intro x\n      simp only [Set.mem_iUnion, Set.mem_setOf_eq]\n      <;>\n      constructor <;>\n      intro h <;>\n      (try {\n        obtain \u27e8i, hi\u27e9 := h\n        refine' \u27e8(i : Set X), i.prop, _\u27e9\n        simpa using hi\n      }) <;>\n      (try {\n        obtain \u27e8S, hS, hx\u27e9 := h\n        refine' \u27e8\u27e8S, hS\u27e9, _\u27e9\n        simpa using hx\n      })\n    rw [h\u2082] at h\u2081\n    exact h\u2081\n  \n  have h_main : IsOpen (T\u1d9c) := by\n    rw [hT_c_def]\n    exact h_union_open\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language premise. The collection F of closed sets, the definition of T as their intersection, the characterization of T\u1d9c as the union of complements, the openness of each complement, and the final conclusion are all properly formalized. The assumption about unions of open sets being open is implicitly captured through the TopologicalSpace typeclass. The explicit assumption hT_c_def about T\u1d9c being the union of complements is mathematically sound and helps make the proof structure clear.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "T closed", "statement": "We assume:\n\u2022 F is a collection of closed sets [tc_2];\n\u2022 T is the intersection of all sets in F [def_2];\n\u2022 The complement of T, T\u1d9c, is an open set [l6].\nTherefore, we conclude:\n\u2022 By the definition of a closed set (a set whose complement is open), T is a closed set [ts_2].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "ts_1", "tc_2", "def_2", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S)\n  (T : Set X)\n  (hT_def : T = \u22c2 S \u2208 F, S)\n  (hT_c_open : IsOpen (T\u1d9c)) :\n  IsClosed T := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2\n  {X : Type*} [TopologicalSpace X]\n  (F : Set (Set X)) \n  (hF_closed : \u2200 S \u2208 F, IsClosed S)\n  (T : Set X)\n  (hT_def : T = \u22c2 S \u2208 F, S)\n  (hT_c_open : IsOpen (T\u1d9c)) :\n  IsClosed T := by\n  have h_main : IsClosed T := by\n    rw [isOpen_compl_iff] at *\n    exact hT_c_open\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["F is correctly formalized as a collection of sets with the constraint that all sets in F are closed", "T is correctly defined as the intersection of all sets in F using proper Lean notation", "The complement of T being open is correctly captured with IsOpen (T\u1d9c)", "The conclusion that T is closed is correctly stated as IsClosed T", "The logical structure properly reflects the reasoning from the given premises to the conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    