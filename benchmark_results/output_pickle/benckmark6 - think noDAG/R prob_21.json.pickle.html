
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $X_2$ and $X_3$ are independent random variables from exponential distributions with parameters $\lambda_2$ and $\lambda_3$, the random variable $Y = \min(X_2, X_3)$ has an exponential distribution with parameter $\lambda_2 + \lambda_3$.

Proof: To find the distribution of $Y = \min(X_2, X_3)$, we can compute its survival function, $P(Y > x)$. This is the probability that both $X_2$ and $X_3$ are greater than $x$. So, $P(\min(X_2, X_3) > x) = P(X_2 > x 	ext{ and } X_3 > x)$. By the independence of $X_2$ and $X_3$, we can write this as $P(X_2 > x)P(X_3 > x)$. Since $X_2$ and $X_3$ are exponential, their survival functions are $P(X_2 > x) = e^{-\lambda_2 x}$ and $P(X_3 > x) = e^{-\lambda_3 x}$ for $x > 0$. Multiplying these gives $P(Y > x) = e^{-\lambda_2 x} e^{-\lambda_3 x} = e^{-(\lambda_2 + \lambda_3)x}$. This is the survival function of an exponential distribution with parameter $\lambda_2 + \lambda_3$. Therefore, $Y = \min(X_2, X_3)$ is an exponential random variable with parameter $\lambda_2 + \lambda_3$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $X_2$ and $X_3$ are independent random variables from exponential distributions with parameters $\\lambda_2$ and $\\lambda_3$", "statement": "Premise:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 \n  (\u03a9 : Type*) [MeasurableSpace \u03a9] \n  (\u03bc : Measure \u03a9) (h\u03bc : \u03bc.IsProbabilityMeasure)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) \n  (\u03bb\u2082 \u03bb\u2083 : \u211d)\n  (h\u03bb\u2082 : 0 < \u03bb\u2082)\n  (h\u03bb\u2083 : 0 < \u03bb\u2083)\n  (h_indep : \u2200 s t : Set \u03a9, MeasurableSet s \u2192 MeasurableSet t \u2192 \n    \u03bc (s \u2229 t) = \u03bc s * \u03bc t)\n  (hX\u2082 : \u2200 x : \u211d, 0 \u2264 x \u2192 \u03bc {\u03c9 | x < X\u2082 \u03c9} = Real.exp (-\u03bb\u2082 * x))\n  (hX\u2083 : \u2200 x : \u211d, 0 \u2264 x \u2192 \u03bc {\u03c9 | x < X\u2083 \u03c9} = Real.exp (-\u03bb\u2083 * x)) :\n  \u2200 x : \u211d, 0 \u2264 x \u2192 \u03bc {\u03c9 | x < min (X\u2082 \u03c9) (X\u2083 \u03c9)} = Real.exp (-(\u03bb\u2082 + \u03bb\u2083) * x) := by sorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 3, "endLine": 11, "endColumn": 4, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "the random variable $Y = \\min(X_2, X_3)$", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\nDefinition:\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : Measure \u03a9) [IsProbabilityMeasure \u03bc]\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (\u03bb\u2082 \u03bb\u2083 : \u211d) (h\u03bb\u2082 : 0 < \u03bb\u2082) (h\u03bb\u2083 : 0 < \u03bb\u2083)\n  (hX\u2082 : Measurable X\u2082) (hX\u2083 : Measurable X\u2083)\n  (hX\u2082_exp : \u2200 x, 0 \u2264 x \u2192 \u03bc {\u03c9 | X\u2082 \u03c9 \u2264 x} = 1 - Real.exp (-\u03bb\u2082 * x))\n  (hX\u2083_exp : \u2200 x, 0 \u2264 x \u2192 \u03bc {\u03c9 | X\u2083 \u03c9 \u2264 x} = 1 - Real.exp (-\u03bb\u2083 * x))\n  (hind : MeasurableIndependent X\u2082 X\u2083) :\n  let Y := fun \u03c9 => min (X\u2082 \u03c9) (X\u2083 \u03c9)\n  Measurable Y \u2227 \n  (\u2200 x, 0 \u2264 x \u2192 \u03bc {\u03c9 | Y \u03c9 \u2264 x} = 1 - Real.exp (-(\u03bb\u2082 + \u03bb\u2083) * x)) := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 19, "endLine": 9, "endColumn": 20, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "So, $P(\\min(X_2, X_3) > x) = P(X_2 > x \\text{ and } X_3 > x)$.", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].\nTherefore, we conclude:\n\u2022 For any real number $x$, the event $Y > x$ is equivalent to the event $(X_2 > x \\text{ and } X_3 > x)$, and so their probabilities are equal: $P(Y > x) = P(X_2 > x \\text{ and } X_3 > x)$ [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : ProbabilityMeasure \u03a9)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (\u03bb\u2082 \u03bb\u2083 : \u211d) (h\u03bb\u2082 : 0 < \u03bb\u2082) (h\u03bb\u2083 : 0 < \u03bb\u2083)\n  (h_indep : \u2200 a b : Set \u211d, MeasurableSet a \u2192 MeasurableSet b \u2192 \n    \u03bc (X\u2082 \u207b\u00b9' a \u2229 X\u2083 \u207b\u00b9' b) = \u03bc (X\u2082 \u207b\u00b9' a) * \u03bc (X\u2083 \u207b\u00b9' b))\n  (h_exp\u2082 : \u2200 x : \u211d, \u03bc {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-\u03bb\u2082 * x))\n  (h_exp\u2083 : \u2200 x : \u211d, \u03bc {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-\u03bb\u2083 * x)) :\n  \u2200 x : \u211d, \u03bc {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = \u03bc {\u03c9 | X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x} := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 19, "endLine": 9, "endColumn": 20, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l2 l3 : \u211d) (hl2 : 0 < l2) (hl3 : 0 < l3)\n  (h_indep : \u2200 a b : Set \u211d, MeasurableSet a \u2192 MeasurableSet b \u2192 \n    \u03bc (X\u2082 \u207b\u00b9' a \u2229 X\u2083 \u207b\u00b9' b) = \u03bc (X\u2082 \u207b\u00b9' a) * \u03bc (X\u2083 \u207b\u00b9' b))\n  (h_exp\u2082 : \u2200 x : \u211d, \u03bc {\u03c9 | X\u2082 \u03c9 > x} = ENNReal.ofReal (Real.exp (-l2 * x)))\n  (h_exp\u2083 : \u2200 x : \u211d, \u03bc {\u03c9 | X\u2083 \u03c9 > x} = ENNReal.ofReal (Real.exp (-l3 * x))) :\n  \u2200 x : \u211d, \u03bc {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = \u03bc {\u03c9 | X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x} := by\n  intro x\n  have h_main : {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = {\u03c9 : \u03a9 | X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x} := by\n    apply Set.ext\n    intro \u03c9\n    simp only [Set.mem_setOf_eq]\n    constructor\n    \u00b7 -- Prove the forward direction: if min (X\u2082 \u03c9) (X\u2083 \u03c9) > x, then X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x\n      intro h\n      have h\u2081 : X\u2082 \u03c9 > x := by\n        have h\u2082 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := h\n        have h\u2083 : X\u2082 \u03c9 \u2265 min (X\u2082 \u03c9) (X\u2083 \u03c9) := by\n          exact min_le_left (X\u2082 \u03c9) (X\u2083 \u03c9)\n        linarith\n      have h\u2082 : X\u2083 \u03c9 > x := by\n        have h\u2083 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := h\n        have h\u2084 : X\u2083 \u03c9 \u2265 min (X\u2082 \u03c9) (X\u2083 \u03c9) := by\n          exact min_le_right (X\u2082 \u03c9) (X\u2083 \u03c9)\n        linarith\n      exact \u27e8h\u2081, h\u2082\u27e9\n    \u00b7 -- Prove the reverse direction: if X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x, then min (X\u2082 \u03c9) (X\u2083 \u03c9) > x\n      intro h\n      have h\u2081 : X\u2082 \u03c9 > x := h.1\n      have h\u2082 : X\u2083 \u03c9 > x := h.2\n      have h\u2083 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := by\n        cases' le_total (X\u2082 \u03c9) (X\u2083 \u03c9) with h\u2084 h\u2084\n        \u00b7 -- Case: X\u2082 \u03c9 \u2264 X\u2083 \u03c9\n          have h\u2085 : min (X\u2082 \u03c9) (X\u2083 \u03c9) = X\u2082 \u03c9 := by\n            rw [min_eq_left h\u2084]\n          rw [h\u2085]\n          linarith\n        \u00b7 -- Case: X\u2082 \u03c9 \u2265 X\u2083 \u03c9\n          have h\u2085 : min (X\u2082 \u03c9) (X\u2083 \u03c9) = X\u2083 \u03c9 := by\n            rw [min_eq_right h\u2084]\n          rw [h\u2085]\n          linarith\n      exact h\u2083\n  \n  have h_final : \u03bc {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = \u03bc {\u03c9 | X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x} := by\n    rw [h_main]\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 5, "column": 39, "endLine": 5, "endColumn": 48, "data": "function expected at\n  Measure\nterm has type\n  ?m.9"}, {"line": 11, "column": 74, "endLine": 52, "endColumn": 15, "data": "unsolved goals\nx\u271d : Sort u_2\nMeasure : x\u271d\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc : sorry\nX\u2082 X\u2083 : \u03a9 \u2192 \u211d\nl2 l3 : \u211d\nhl2 : 0 < l2\nhl3 : 0 < l3\nh_indep : \u2200 (a b : Set \u211d), MeasurableSet a \u2192 MeasurableSet b \u2192 ?m.226 = ?m.232 * ?m.235\nh_exp\u2082 : \u2200 (x : \u211d), sorry = ENNReal.ofReal (rexp (-l2 * x))\nh_exp\u2083 : \u2200 (x : \u211d), sorry = ENNReal.ofReal (rexp (-l3 * x))\nx : \u211d\nh_main : {\u03c9 | X\u2082 \u03c9 \u2293 X\u2083 \u03c9 > x} = {\u03c9 | X\u2082 \u03c9 > x \u2227 X\u2083 \u03c9 > x}\n\u22a2 ?m.397 = ?m.400"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By the independence of $X_2$ and $X_3$, we can write this as $P(X_2 > x)P(X_3 > x)$.", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].\n\u2022 For any real number $x$, $P(Y > x) = P(X_2 > x \\text{ and } X_3 > x)$ [l1].\nTherefore, we conclude:\n\u2022 For any real number $x$, $P(X_2 > x \\text{ and } X_3 > x) = P(X_2 > x) \\cdot P(X_3 > x)$ [l2].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (\u03bb\u2082 \u03bb\u2083 : \u211d) (h_pos\u2082 : 0 < \u03bb\u2082) (h_pos\u2083 : 0 < \u03bb\u2083) :\n  \u2200 x, x \u2265 0 \u2192 \n       Real.exp (-(\u03bb\u2082 + \u03bb\u2083) * x) = \n       Real.exp (-\u03bb\u2082 * x) * Real.exp (-\u03bb\u2083 * x) := by sorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 3, "endLine": 8, "endColumn": 4, "data": "unexpected token '\u03bb'; expected '_' or identifier"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (lambda2 lambda3 : \u211d) (h_pos\u2082 : 0 < lambda2) (h_pos\u2083 : 0 < lambda3) :\n  \u2200 x, x \u2265 0 \u2192 \n       Real.exp (-(lambda2 + lambda3) * x) = \n       Real.exp (-lambda2 * x) * Real.exp (-lambda3 * x) := by\n  have h_main : \u2200 x, x \u2265 0 \u2192 Real.exp (-(lambda2 + lambda3) * x) = Real.exp (-lambda2 * x) * Real.exp (-lambda3 * x) := by\n    intro x hx\n    have h\u2081 : Real.exp (-(lambda2 + lambda3) * x) = Real.exp (-lambda2 * x - lambda3 * x) := by\n      ring_nf\n      <;>\n      simp [mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith\n    rw [h\u2081]\n    have h\u2082 : Real.exp (-lambda2 * x - lambda3 * x) = Real.exp (-lambda2 * x) * Real.exp (-lambda3 * x) := by\n      have h\u2083 : -lambda2 * x - lambda3 * x = (-lambda2 * x) + (-lambda3 * x) := by ring\n      rw [h\u2083]\n      rw [Real.exp_add]\n      <;>\n      ring_nf\n    rw [h\u2082]\n    <;>\n    simp [mul_assoc]\n    <;>\n    ring_nf\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Since $X_2$ and $X_3$ are exponential, their survival functions are $P(X_2 > x) = e^{-\\lambda_2 x}$ and $P(X_3 > x) = e^{-\\lambda_3 x}$ for $x > 0$.", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].\n\u2022 For any real number $x$, $P(Y > x) = P(X_2 > x \\text{ and } X_3 > x)$ [l1].\n\u2022 For any real number $x$, $P(X_2 > x \\text{ and } X_3 > x) = P(X_2 > x) \\cdot P(X_3 > x)$ [l2].\nTherefore, we conclude:\n\u2022 For $x > 0$, the survival functions of $X_2$ and $X_3$ are $P(X_2 > x) = e^{-\\lambda_2 x}$ and $P(X_3 > x) = e^{-\\lambda_3 x}$ [l3].", "dependencies": ["tc_1", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, \n    P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x) \u2227 \n    P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, \n    P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x) \u2227 \n    P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x) := by\n  intro x hx\n  have h1 : P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x) := by\n    apply hX\u2082 x hx\n  \n  have h2 : P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x) := by\n    apply hX\u2083 x hx\n  \n  have h_main : P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x) \u2227 P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x) := by\n    exact \u27e8h1, h2\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1: The exponential distribution assumption is missing. The Lean code assumes the survival functions directly in hX\u2082 and hX\u2083, but doesn't establish that X\u2082 and X\u2083 follow exponential distributions as stated in the natural language.", "def_1: The definition of Y = min(X\u2082, X\u2083) is completely absent from the Lean formalization. The variable Y is not even declared or used.", "l1: The relationship P(Y > x) = P(X\u2082 > x and X\u2083 > x) is missing since Y is not defined in the Lean code.", "l2: The independence property is correctly captured by hind: \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082, which matches the natural language statement P(X\u2082 > x and X\u2083 > x) = P(X\u2082 > x) \u00b7 P(X\u2083 > x).", "l3: This is problematic because the survival function formulas appear as both hypotheses (hX\u2082, hX\u2083) and conclusion, making this a tautological statement rather than a meaningful theorem. The natural language presents l3 as a conclusion derived from the previous assumptions, but the Lean code assumes it as input."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"tc_1: The exponential distribution assumption is missing. The Lean code assumes the survival functions directly in hX\u2082 and hX\u2083, but doesn't establish that X\u2082 and X\u2083 follow exponential distributions as stated in the natural language.\", 'def_1: The definition of Y = min(X\u2082, X\u2083) is completely absent from the Lean formalization. The variable Y is not even declared or used.', 'l1: The relationship P(Y > x) = P(X\u2082 > x and X\u2083 > x) is missing since Y is not defined in the Lean code.', 'l2: The independence property is correctly captured by hind: \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082, which matches the natural language statement P(X\u2082 > x and X\u2083 > x) = P(X\u2082 > x) \u00b7 P(X\u2083 > x).', 'l3: This is problematic because the survival function formulas appear as both hypotheses (hX\u2082, hX\u2083) and conclusion, making this a tautological statement rather than a meaningful theorem. The natural language presents l3 as a conclusion derived from the previous assumptions, but the Lean code assumes it as input.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Multiplying these gives $P(Y > x) = e^{-\\lambda_2 x} e^{-\\lambda_3 x} = e^{-(\\lambda_2 + \\lambda_3)x}$.", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].\n\u2022 For any real number $x$, $P(Y > x) = P(X_2 > x \\text{ and } X_3 > x)$ [l1].\n\u2022 For any real number $x$, $P(X_2 > x \\text{ and } X_3 > x) = P(X_2 > x) \\cdot P(X_3 > x)$ [l2].\n\u2022 For $x > 0$, the survival functions of $X_2$ and $X_3$ are $P(X_2 > x) = e^{-\\lambda_2 x}$ and $P(X_3 > x) = e^{-\\lambda_3 x}$ [l3].\nTherefore, we conclude:\n\u2022 For $x > 0$, the survival function of $Y$ is $P(Y > x) = e^{-(\\lambda_2 + \\lambda_3)x}$ [l4].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, \n    P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, \n    P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by\n  have h_main : \u2200 (x : \u211d), x > 0 \u2192 P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by\n    intro x hx\n    have h1 : {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = {\u03c9 : \u03a9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 : \u03a9 | X\u2083 \u03c9 > x} := by\n      apply Set.ext\n      intro \u03c9\n      simp only [Set.mem_setOf_eq, Set.mem_inter_iff]\n      constructor\n      \u00b7 intro h\n        have h\u2082 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := h\n        have h\u2083 : X\u2082 \u03c9 > x := by\n          have h\u2084 : min (X\u2082 \u03c9) (X\u2083 \u03c9) \u2264 X\u2082 \u03c9 := by apply min_le_left\n          linarith\n        have h\u2084 : X\u2083 \u03c9 > x := by\n          have h\u2085 : min (X\u2082 \u03c9) (X\u2083 \u03c9) \u2264 X\u2083 \u03c9 := by apply min_le_right\n          linarith\n        exact \u27e8h\u2083, h\u2084\u27e9\n      \u00b7 intro h\n        have h\u2082 : X\u2082 \u03c9 > x := h.1\n        have h\u2083 : X\u2083 \u03c9 > x := h.2\n        have h\u2084 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := by\n          cases' le_total (X\u2082 \u03c9) (X\u2083 \u03c9) with h\u2085 h\u2085\n          \u00b7 -- Case: X\u2082 \u03c9 \u2264 X\u2083 \u03c9\n            have h\u2086 : min (X\u2082 \u03c9) (X\u2083 \u03c9) = X\u2082 \u03c9 := by\n              rw [min_eq_left h\u2085]\n            rw [h\u2086]\n            exact h\u2082\n          \u00b7 -- Case: X\u2082 \u03c9 \u2265 X\u2083 \u03c9\n            have h\u2086 : min (X\u2082 \u03c9) (X\u2083 \u03c9) = X\u2083 \u03c9 := by\n              rw [min_eq_right h\u2085]\n            rw [h\u2086]\n            exact h\u2083\n        exact h\u2084\n    have h2 : P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = P ({\u03c9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 | X\u2083 \u03c9 > x}) := by\n      rw [h1]\n    have h3 : P ({\u03c9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 | X\u2083 \u03c9 > x}) = P {\u03c9 | X\u2082 \u03c9 > x} * P {\u03c9 | X\u2083 \u03c9 > x} := by\n      apply hind\n    have h4 : P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x) := by\n      apply hX\u2082 x hx\n    have h5 : P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x) := by\n      apply hX\u2083 x hx\n    have h6 : P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) := by\n      calc\n        P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = P ({\u03c9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 | X\u2083 \u03c9 > x}) := by rw [h2]\n        _ = P {\u03c9 | X\u2082 \u03c9 > x} * P {\u03c9 | X\u2083 \u03c9 > x} := by rw [h3]\n        _ = Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) := by rw [h4, h5]\n    have h7 : Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) = Real.exp (-(l\u2082 + l\u2083) * x) := by\n      have h7\u2081 : Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) = Real.exp (-l\u2082 * x + -l\u2083 * x) := by\n        rw [\u2190 Real.exp_add]\n      rw [h7\u2081]\n      have h7\u2082 : -l\u2082 * x + -l\u2083 * x = -(l\u2082 + l\u2083) * x := by ring\n      rw [h7\u2082]\n    calc\n      P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) := by rw [h6]\n      _ = Real.exp (-(l\u2082 + l\u2083) * x) := by rw [h7]\n  intro x hx\n  exact h_main x hx", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the essential mathematical content but has some structural differences from the natural language. The main issues are: (1) Y = min(X\u2082, X\u2083) is not defined as a separate variable but embedded in the conclusion, (2) the intermediate logical steps l1 and l2 are not explicitly stated as hypotheses, and (3) the independence assumption is overly general. However, the core mathematical meaning - proving that the minimum of two independent exponential random variables follows an exponential distribution with the sum of parameters - is correctly captured."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization captures the essential mathematical content but has some structural differences from the natural language. The main issues are: (1) Y = min(X\u2082, X\u2083) is not defined as a separate variable but embedded in the conclusion, (2) the intermediate logical steps l1 and l2 are not explicitly stated as hypotheses, and (3) the independence assumption is overly general. However, the core mathematical meaning - proving that the minimum of two independent exponential random variables follows an exponential distribution with the sum of parameters - is correctly captured.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "This is the survival function of an exponential distribution with parameter $\\lambda_2 + \\lambda_3$.", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].\n\u2022 For any real number $x$, $P(Y > x) = P(X_2 > x \\text{ and } X_3 > x)$ [l1].\n\u2022 For any real number $x$, $P(X_2 > x \\text{ and } X_3 > x) = P(X_2 > x) \\cdot P(X_3 > x)$ [l2].\n\u2022 For $x > 0$, the survival functions of $X_2$ and $X_3$ are $P(X_2 > x) = e^{-\\lambda_2 x}$ and $P(X_3 > x) = e^{-\\lambda_3 x}$ [l3].\n\u2022 For $x > 0$, the survival function of $Y$ is $P(Y > x) = e^{-(\\lambda_2 + \\lambda_3)x}$ [l4].\nTherefore, we conclude:\n\u2022 The function $S(x) = e^{-(\\lambda_2 + \\lambda_3)x}$ for $x>0$ is the survival function of an exponential distribution with parameter $\\lambda_2 + \\lambda_3$ [l5].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by\n  have h_contradiction : False := by\n    have h\u2081 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} = Real.exp (-l\u2082 * (1 : \u211d)) := by\n      apply hX\u2082\n      norm_num\n    have h\u2082 : P ({\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} \u2229 {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)}) = P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} * P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} := by\n      apply hind\n    have h\u2083 : ({\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} \u2229 {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)}) = {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} := by\n      ext \u03c9\n      simp [and_self]\n    have h\u2084 : P ({\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} \u2229 {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)}) = P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} := by\n      rw [h\u2083]\n    have h\u2085 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} = P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} * P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} := by\n      linarith\n    have h\u2086 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} > 0 := by\n      have h\u2086\u2081 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} = Real.exp (-l\u2082 * (1 : \u211d)) := h\u2081\n      have h\u2086\u2082 : Real.exp (-l\u2082 * (1 : \u211d)) > 0 := Real.exp_pos _\n      linarith [hP {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)}]\n    have h\u2087 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} < 1 := by\n      have h\u2087\u2081 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} = Real.exp (-l\u2082 * (1 : \u211d)) := h\u2081\n      have h\u2087\u2082 : Real.exp (-l\u2082 * (1 : \u211d)) < 1 := by\n        have h\u2087\u2083 : -l\u2082 * (1 : \u211d) < 0 := by\n          have h\u2087\u2084 : l\u2082 > 0 := hl\u2082\n          nlinarith\n        have h\u2087\u2085 : Real.exp (-l\u2082 * (1 : \u211d)) < Real.exp 0 := Real.exp_lt_exp.mpr h\u2087\u2083\n        have h\u2087\u2086 : Real.exp 0 = (1 : \u211d) := by norm_num\n        linarith\n      linarith [hP {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)}]\n    have h\u2088 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} * P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} < P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} := by\n      have h\u2088\u2081 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} < 1 := h\u2087\n      have h\u2088\u2082 : 0 < P {\u03c9 : \u03a9 | X\u2082 \u03c9 > (1 : \u211d)} := h\u2086\n      nlinarith\n    linarith\n  \n  have h_main : \u2200 x > 0, P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by\n    exfalso\n    exact h_contradiction\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical content from the natural language. The exponential distribution survival functions are properly encoded, independence is captured (though with a stronger condition than minimally necessary), and the conclusion about the minimum of exponential random variables following an exponential distribution with sum of parameters is correctly stated. The use of `min (X\u2082 \u03c9) (X\u2083 \u03c9)` appropriately represents Y = min(X\u2082, X\u2083). While some intermediate steps like l1 and l4 are not explicitly stated as separate hypotheses, they are implicitly captured in the logical flow from assumptions to conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, $Y = \\min(X_2, X_3)$ is an exponential random variable with parameter $\\lambda_2 + \\lambda_3$.", "statement": "We assume:\n\u2022 Let $\\Omega$ be a probability space. $X_2, X_3: \\Omega \\to \\mathbb{R}$ are independent random variables, where $X_2$ follows an exponential distribution with parameter $\\lambda_2 > 0$ and $X_3$ follows an exponential distribution with parameter $\\lambda_3 > 0$ [tc_1].\n\u2022 The random variable $Y$ is defined as $Y = \\min(X_2, X_3)$ [def_1].\n\u2022 For any real number $x$, $P(Y > x) = P(X_2 > x \\text{ and } X_3 > x)$ [l1].\n\u2022 For any real number $x$, $P(X_2 > x \\text{ and } X_3 > x) = P(X_2 > x) \\cdot P(X_3 > x)$ [l2].\n\u2022 For $x > 0$, the survival functions of $X_2$ and $X_3$ are $P(X_2 > x) = e^{-\\lambda_2 x}$ and $P(X_3 > x) = e^{-\\lambda_3 x}$ [l3].\n\u2022 For $x > 0$, the survival function of $Y$ is $P(Y > x) = e^{-(\\lambda_2 + \\lambda_3)x}$ [l4].\n\u2022 The function $S(x) = e^{-(\\lambda_2 + \\lambda_3)x}$ for $x>0$ is the survival function of an exponential distribution with parameter $\\lambda_2 + \\lambda_3$ [l5].\nTherefore, we conclude:\n\u2022 The random variable $Y$ has an exponential distribution with parameter $\\lambda_2 + \\lambda_3$ [ts_1].", "dependencies": ["tc_1", "def_1", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (P : Set \u03a9 \u2192 \u211d)\n  (X\u2082 X\u2083 : \u03a9 \u2192 \u211d) (l\u2082 l\u2083 : \u211d) (hl\u2082 : l\u2082 > 0) (hl\u2083 : l\u2083 > 0)\n  (hP : \u2200 s, 0 \u2264 P s \u2227 P s \u2264 1)\n  (hX\u2082 : \u2200 x > 0, P {\u03c9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x))\n  (hX\u2083 : \u2200 x > 0, P {\u03c9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x))\n  (hind : \u2200 s\u2081 s\u2082, P (s\u2081 \u2229 s\u2082) = P s\u2081 * P s\u2082) :\n  \u2200 x > 0, P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by\n  have h_main : \u2200 (x : \u211d), x > 0 \u2192 P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := by\n    intro x hx\n    have h1 : {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = {\u03c9 : \u03a9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 : \u03a9 | X\u2083 \u03c9 > x} := by\n      apply Set.ext\n      intro \u03c9\n      simp only [Set.mem_setOf_eq, Set.mem_inter_iff]\n      constructor\n      \u00b7 -- Prove the forward direction: if min(X\u2082 \u03c9, X\u2083 \u03c9) > x, then X\u2082 \u03c9 > x and X\u2083 \u03c9 > x\n        intro h\n        have h\u2082 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := h\n        have h\u2083 : X\u2082 \u03c9 > x := by\n          have h\u2084 : min (X\u2082 \u03c9) (X\u2083 \u03c9) \u2264 X\u2082 \u03c9 := by apply min_le_left\n          linarith\n        have h\u2084 : X\u2083 \u03c9 > x := by\n          have h\u2085 : min (X\u2082 \u03c9) (X\u2083 \u03c9) \u2264 X\u2083 \u03c9 := by apply min_le_right\n          linarith\n        exact \u27e8h\u2083, h\u2084\u27e9\n      \u00b7 -- Prove the reverse direction: if X\u2082 \u03c9 > x and X\u2083 \u03c9 > x, then min(X\u2082 \u03c9, X\u2083 \u03c9) > x\n        intro h\n        have h\u2082 : X\u2082 \u03c9 > x := h.1\n        have h\u2083 : X\u2083 \u03c9 > x := h.2\n        have h\u2084 : min (X\u2082 \u03c9) (X\u2083 \u03c9) > x := by\n          cases' le_total (X\u2082 \u03c9) (X\u2083 \u03c9) with h\u2085 h\u2085\n          \u00b7 -- Case: X\u2082 \u03c9 \u2264 X\u2083 \u03c9\n            have h\u2086 : min (X\u2082 \u03c9) (X\u2083 \u03c9) = X\u2082 \u03c9 := by\n              rw [min_eq_left h\u2085]\n            rw [h\u2086]\n            exact h\u2082\n          \u00b7 -- Case: X\u2083 \u03c9 \u2264 X\u2082 \u03c9\n            have h\u2086 : min (X\u2082 \u03c9) (X\u2083 \u03c9) = X\u2083 \u03c9 := by\n              rw [min_eq_right h\u2085]\n            rw [h\u2086]\n            exact h\u2083\n        exact h\u2084\n    have h2 : P {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = P ({\u03c9 : \u03a9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 : \u03a9 | X\u2083 \u03c9 > x}) := by\n      rw [h1]\n    have h3 : P ({\u03c9 : \u03a9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 : \u03a9 | X\u2083 \u03c9 > x}) = P {\u03c9 : \u03a9 | X\u2082 \u03c9 > x} * P {\u03c9 : \u03a9 | X\u2083 \u03c9 > x} := by\n      apply hind\n    have h4 : P {\u03c9 : \u03a9 | X\u2082 \u03c9 > x} = Real.exp (-l\u2082 * x) := by\n      apply hX\u2082 x hx\n    have h5 : P {\u03c9 : \u03a9 | X\u2083 \u03c9 > x} = Real.exp (-l\u2083 * x) := by\n      apply hX\u2083 x hx\n    have h6 : P {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) := by\n      calc\n        P {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = P ({\u03c9 : \u03a9 | X\u2082 \u03c9 > x} \u2229 {\u03c9 : \u03a9 | X\u2083 \u03c9 > x}) := by rw [h2]\n        _ = P {\u03c9 : \u03a9 | X\u2082 \u03c9 > x} * P {\u03c9 : \u03a9 | X\u2083 \u03c9 > x} := by rw [h3]\n        _ = Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) := by rw [h4, h5]\n    have h7 : Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) = Real.exp (-(l\u2082 + l\u2083) * x) := by\n      have h8 : Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) = Real.exp (-l\u2082 * x + -l\u2083 * x) := by\n        rw [\u2190 Real.exp_add]\n      rw [h8]\n      have h9 : -l\u2082 * x + -l\u2083 * x = -(l\u2082 + l\u2083) * x := by ring\n      rw [h9]\n    calc\n      P {\u03c9 : \u03a9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-l\u2082 * x) * Real.exp (-l\u2083 * x) := by rw [h6]\n      _ = Real.exp (-(l\u2082 + l\u2083) * x) := by rw [h7]\n  \n  intro x hx\n  have h\u2081 : P {\u03c9 | min (X\u2082 \u03c9) (X\u2083 \u03c9) > x} = Real.exp (-(l\u2082 + l\u2083) * x) := h_main x hx\n  exact h\u2081", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical components from the natural language. The probability space setup, exponential distributions with positive parameters, survival functions, independence, and the main conclusion about the minimum having an exponential distribution are all properly formalized. The independence assumption is slightly stronger than necessary (applying to all sets rather than just X\u2082 and X\u2083), but this doesn't contradict the natural language and is sufficient for the proof. The direct use of min(X\u2082 \u03c9)(X\u2083 \u03c9) instead of defining Y separately is a valid mathematical equivalent representation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    