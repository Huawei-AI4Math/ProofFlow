
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: For $n\geq 0$ with $n\leq m$ we have
\begin{equation}\label{eqn:detsign}
p_n q_{n-1} - q_n p_{n-1} = (-1)^{n-1}
\end{equation}
and
\begin{equation}\label{eqn:detsignan}
p_nq_{n-2} - q_n p_{n-2} = (-1)^n a_n.
\end{equation}
Equivalently,
$$\frac{p_n}{q_n} - \frac{p_{n-1}}{q_{n-1}} =
                  (-1)^{n-1}\cdot\frac{1}{q_n q_{n-1}}$$
and
$$\frac{p_n}{q_n} - \frac{p_{n-2}}{q_{n-2}} =
                  (-1)^{n}\cdot\frac{a_n}{q_n q_{n-2}}.$$

Proof: The case for $n=0$ is obvious from the definitions.
Now suppose $n>0$ and the statement is true for $n-1$.  Then
\begin{align*}
p_{n}q_{n-1} - q_n p_{n-1} &=
     (a_n p_{n-1} + p_{n-2}) q_{n-1} - (a_n q_{n-1} + q_{n-2}) p_{n-1}\\
  &= p_{n-2}q_{n-1} - q_{n-2} p_{n-1} \\
   &=
       -(p_{n-1}q_{n-2} - p_{n-2} q_{n-1})\\
  &= -(-1)^{n-2} = (-1)^{n-1}.
\end{align*}
This completes the proof of (\ref{eqn:detsign}).  For
(\ref{eqn:detsignan}), we have
\begin{align*}
p_n q_{n-2} - p_{n-2} q_n &=
        (a_n p_{n-1} + p_{n-2})q_{n-2} - p_{n-2}(a_n q_{n-1} + q_{n-2}) \\
       &= a_n(p_{n-1}q_{n-2} - p_{n-2}q_{n-1}) \\
       &= (-1)^n a_n.
\end{align*}
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "The theorem concerns sequences p_n and q_n, whose properties are derived from their recurrence relations.", "statement": "Premise:\n\u2022 (p_n), (q_n), and (a_n) are sequences of integers where for n \u2265 1, the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2} hold [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (p q a : \u2115 \u2192 \u2124) \n  (h_p : \u2200 n, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_q : \u2200 n, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2)) :\n  := by sorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 58, "endLine": 10, "endColumn": 4, "data": "unexpected token ':='; expected term"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "The case for n=0 is obvious from the definitions.", "statement": "Premise:\n\u2022 (p_n), (q_n), and (a_n) are sequences of integers where for n \u2265 1, the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2} hold [tc_1];\n\u2022 The initial conditions for the sequences are p_0 = a_0, p_{-1} = 1, p_{-2} = 0, and q_0 = 1, q_{-1} = 0, q_{-2} = 1 [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p q a : \u2124 \u2192 \u2124)\n(tc_1 : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n(tc_1_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n(tc_2_p0 : p 0 = a 0)\n(tc_2_p1 : p (-1) = 1)\n(tc_2_p2 : p (-2) = 0)\n(tc_2_q0 : q 0 = 1)\n(tc_2_q1 : q (-1) = 0)\n(tc_2_q2 : q (-2) = 1)\n\ntheorem tc_2 : \n  \u2200 n : \u2124, n \u2265 0 \u2192 \n    (p n * q (n - 1) - q n * p (n - 1) = (-1 : \u211a) ^ (n - 1)) \u2227\n    (p n * q (n - 2) - q n * p (n - 2) = (-1 : \u211a) ^ n * (a n : \u211a)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean theorem proves specific algebraic identities (p n * q (n - 1) - q n * p (n - 1) = (-1)^(n-1) and p n * q (n - 2) - q n * p (n - 2) = (-1)^n * a n) which are completely different from the natural language conclusion that the sequences are 'well-defined for all integers n \u2265 0'. The natural language statement appears to be establishing the existence and definition of the sequences, while the Lean theorem proves mathematical properties about relationships between the sequences."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean theorem proves specific algebraic identities (p n * q (n - 1) - q n * p (n - 1) = (-1)^(n-1) and p n * q (n - 2) - q n * p (n - 2) = (-1)^n * a n) which are completely different from the natural language conclusion that the sequences are 'well-defined for all integers n \u2265 0'. The natural language statement appears to be establishing the existence and definition of the sequences, while the Lean theorem proves mathematical properties about relationships between the sequences.\"]"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "For n\u22650 with n\u2264m we have...", "statement": "Premise:\n\u2022 (p_n), (q_n), and (a_n) are sequences of integers where for n \u2265 1, the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2} hold [tc_1];\n\u2022 The initial conditions for the sequences are p_0 = a_0, p_{-1} = 1, p_{-2} = 0, and q_0 = 1, q_{-1} = 0, q_{-2} = 1 [tc_2];\n\u2022 n is an integer such that 0 \u2264 n \u2264 m [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p q a : \u2124 \u2192 \u2124)\nvariable (m : \u2124)\n(tc_1 : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n(tc_1_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n(tc_2_p0 : p 0 = a 0)\n(tc_2_p1 : p (-1) = 1)\n(tc_2_p2 : p (-2) = 0)\n(tc_2_q0 : q 0 = 1)\n(tc_2_q1 : q (-1) = 0)\n(tc_2_q2 : q (-2) = 1)\n(tc_3 : \u2200 n : \u2124, 0 \u2264 n \u2227 n \u2264 m \u2192 True) -- Constraint from tc_3", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.9, "semantic_feedback": ["The Lean formalization correctly captures that p, q, and a are sequences of integers using the type \u2124 \u2192 \u2124", "The recurrence relation for p_n is perfectly captured in Lean with the same mathematical structure", "The recurrence relation for q_n is perfectly captured in Lean with the same mathematical structure", "The initial condition p_0 = a_0 is exactly represented in Lean", "The initial condition p_{-1} = 1 is exactly represented in Lean", "The initial condition p_{-2} = 0 is exactly represented in Lean", "The initial condition q_0 = 1 is exactly represented in Lean", "The initial condition q_{-1} = 0 is exactly represented in Lean", "The initial condition q_{-2} = 1 is exactly represented in Lean", "The Lean formalization uses a tautology (\u2192 True) which doesn't actually constrain n to the range [0,m]. While it acknowledges the constraint exists, it doesn't enforce it meaningfully. The natural language establishes n as a specific integer in the range, but Lean's formulation is vacuous."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "The case for n=0 is obvious from the definitions.", "statement": "We assume:\n\u2022 (p_n), (q_n), and (a_n) are sequences of integers where for n \u2265 1, the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2} hold [tc_1];\n\u2022 The initial conditions for the sequences are p_0 = a_0, p_{-1} = 1, p_{-2} = 0, and q_0 = 1, q_{-1} = 0, q_{-2} = 1 [tc_2];\n\u2022 n is an integer such that 0 \u2264 n \u2264 m [tc_3].\nTherefore, we conclude:\n\u2022 For n=0, the identities p_0 * q_{-1} - q_0 * p_{-1} = (-1)^{-1} and p_0 * q_{-2} - q_0 * p_{-2} = (-1)^0 * a_0 hold [l1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p q a : \u2124 \u2192 \u2124)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1) :\n  (p 0 * q (-1) - q 0 * p (-1) = -1) \u2227\n  (p 0 * q (-2) - q 0 * p (-2) = a 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (p q a : \u2124 \u2192 \u2124)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1) :\n  (p 0 * q (-1) - q 0 * p (-1) = -1) \u2227\n  (p 0 * q (-2) - q 0 * p (-2) = a 0) := by\n  have h1 : p 0 * q (-1) - q 0 * p (-1) = -1 := by\n    have h1\u2081 : p 0 * q (-1) - q 0 * p (-1) = a 0 * 0 - 1 * 1 := by\n      calc\n        p 0 * q (-1) - q 0 * p (-1) = (a 0) * q (-1) - q 0 * p (-1) := by rw [h_init_p0]\n        _ = (a 0) * 0 - q 0 * p (-1) := by rw [h_init_q1]\n        _ = (a 0) * 0 - 1 * p (-1) := by rw [h_init_q0]\n        _ = (a 0) * 0 - 1 * 1 := by rw [h_init_p1]\n        _ = a 0 * 0 - 1 * 1 := by ring\n    have h1\u2082 : a 0 * 0 - 1 * 1 = -1 := by\n      ring\n    linarith\n  \n  have h2 : p 0 * q (-2) - q 0 * p (-2) = a 0 := by\n    have h2\u2081 : p 0 * q (-2) - q 0 * p (-2) = a 0 * 1 - 1 * 0 := by\n      calc\n        p 0 * q (-2) - q 0 * p (-2) = (a 0) * q (-2) - q 0 * p (-2) := by rw [h_init_p0]\n        _ = (a 0) * q (-2) - 1 * p (-2) := by rw [h_init_q0]\n        _ = (a 0) * 1 - 1 * p (-2) := by rw [h_init_q2]\n        _ = (a 0) * 1 - 1 * 0 := by rw [h_init_p2]\n        _ = a 0 * 1 - 1 * 0 := by ring\n    have h2\u2082 : a 0 * 1 - 1 * 0 = a 0 := by\n      ring\n    linarith\n  \n  exact \u27e8h1, h2\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The sequence definitions and recurrence relations are correctly captured in Lean with appropriate type declarations and logical structure.", "All initial conditions are precisely translated from natural language to Lean with correct variable assignments.", "The constraint '0 \u2264 n \u2264 m' mentioned in the natural language is missing from the Lean formalization. However, since this constraint is not used in the specific conclusion being proven (which only involves n=0), this omission doesn't affect the mathematical validity of the theorem.", "The conclusion identities are correctly formalized. The Lean version appropriately evaluates (-1)^{-1} = -1 and (-1)^0 * a_0 = a_0, maintaining mathematical equivalence with the natural language expressions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now suppose n>0 and the statement is true for n-1.", "statement": "We assume:\n\u2022 (p_n), (q_n), and (a_n) are sequences of integers where for n \u2265 1, the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2} hold [tc_1];\n\u2022 The initial conditions for the sequences are p_0 = a_0, p_{-1} = 1, p_{-2} = 0, and q_0 = 1, q_{-1} = 0, q_{-2} = 1 [tc_2];\n\u2022 n is an integer such that 0 \u2264 n \u2264 m [tc_3];\n\u2022 For n=0, the identities hold [l1].\nDefinition:\n\u2022 For a given n > 0, we assume the inductive hypothesis that the first identity holds for n-1: p_{n-1} * q_{n-2} - q_{n-1} * p_{n-2} = (-1)^{n-2} [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0) :\n  p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) = (-1 : \u211a) ^ (n - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean theorem only declares p, q, a as integer-valued functions but completely omits the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2}, which are fundamental conditions in the natural language statement", "The Lean theorem completely omits all initial conditions (p_0 = a_0, p_{-1} = 1, p_{-2} = 0, q_0 = 1, q_{-1} = 0, q_{-2} = 1) that are explicitly stated in the natural language", "The natural language states n is an integer with 0 \u2264 n \u2264 m, but Lean only has n > 0. The constraint 0 \u2264 n \u2264 m is missing entirely, and the condition n > 0 is more restrictive than allowing n = 0", "The natural language mentions 'For n=0, the identities hold' but this condition is completely absent from the Lean formalization", "The identity equation matches semantically, but there's a type inconsistency: the natural language uses integer arithmetic throughout, while Lean uses (-1 : \u211a) ^ (n - 2) with rational number type for the right side, though the mathematical meaning is preserved"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean theorem only declares p, q, a as integer-valued functions but completely omits the recurrence relations p_n = a_n * p_{n-1} + p_{n-2} and q_n = a_n * q_{n-1} + q_{n-2}, which are fundamental conditions in the natural language statement', 'The Lean theorem completely omits all initial conditions (p_0 = a_0, p_{-1} = 1, p_{-2} = 0, q_0 = 1, q_{-1} = 0, q_{-2} = 1) that are explicitly stated in the natural language', 'The natural language states n is an integer with 0 \u2264 n \u2264 m, but Lean only has n > 0. The constraint 0 \u2264 n \u2264 m is missing entirely, and the condition n > 0 is more restrictive than allowing n = 0', \"The natural language mentions 'For n=0, the identities hold' but this condition is completely absent from the Lean formalization\", \"The identity equation matches semantically, but there's a type inconsistency: the natural language uses integer arithmetic throughout, while Lean uses (-1 : \u211a) ^ (n - 2) with rational number type for the right side, though the mathematical meaning is preserved\"]"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "p_{n}q_{n-1} - q_n p_{n-1} = (a_n p_{n-1} + p_{n-2}) q_{n-1} - (a_n q_{n-1} + q_{n-2}) p_{n-1}", "statement": "We assume:\n\u2022 Recurrence relations for p_n and q_n [tc_1];\n\u2022 Initial conditions for p_n and q_n [tc_2];\n\u2022 n > 0 [def_1].\nTherefore, we conclude:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = (a_n * p_{n-1} + p_{n-2}) * q_{n-1} - (a_n * q_{n-1} + q_{n-2}) * p_{n-1} [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n  ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - \n  ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n  ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - \n  ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a) := by\n  have h_n_ge_one : n \u2265 1 := by\n    have h\u2081 : n \u2265 1 := by\n      -- Since n is an integer greater than 0, it must be at least 1.\n      have h\u2082 : n > 0 := hn\n      have h\u2083 : n \u2265 1 := by\n        by_contra h\n        -- If n is not \u2265 1, then n \u2264 0.\n        have h\u2084 : n \u2264 0 := by linarith\n        -- But we know n > 0, so this is a contradiction.\n        linarith\n      exact h\u2083\n    exact h\u2081\n  \n  have h_p_rec : p n = a n * p (n - 1) + p (n - 2) := by\n    have h\u2081 : p n = a n * p (n - 1) + p (n - 2) := h_rec_p n h_n_ge_one\n    exact h\u2081\n  \n  have h_q_rec : q n = a n * q (n - 1) + q (n - 2) := by\n    have h\u2081 : q n = a n * q (n - 1) + q (n - 2) := h_rec_q n h_n_ge_one\n    exact h\u2081\n  \n  have h_main : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a) := by\n    have h\u2081 : (p n : \u211a) = (a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a) := by\n      norm_cast\n      <;>\n      (try simp_all [h_p_rec]) <;>\n      (try ring_nf at *) <;>\n      (try norm_num at *) <;>\n      (try linarith)\n      <;>\n      (try simp_all [h_p_rec])\n      <;>\n      (try ring_nf at *)\n      <;>\n      (try norm_num at *)\n      <;>\n      (try linarith)\n    have h\u2082 : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := by\n      norm_cast\n      <;>\n      (try simp_all [h_q_rec]) <;>\n      (try ring_nf at *) <;>\n      (try norm_num at *) <;>\n      (try linarith)\n      <;>\n      (try simp_all [h_q_rec])\n      <;>\n      (try ring_nf at *)\n      <;>\n      (try norm_num at *)\n      <;>\n      (try linarith)\n    calc\n      (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a)\n        = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) := by rw [h\u2081]\n      _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a) := by rw [h\u2082]\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The recurrence relations in Lean provide the specific mathematical form that was referenced but not detailed in the natural language. This is an appropriate and necessary elaboration.", "The initial conditions in Lean specify concrete values that establish the sequences, which is mathematically necessary even though not detailed in the natural language.", "The constraint n > 0 is captured exactly as stated.", "The main equality conclusion is mathematically identical between natural language and Lean, with the Lean version appropriately handling type coercions to ensure the arithmetic is well-defined."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "= p_{n-2}q_{n-1} - q_{n-2} p_{n-1}", "statement": "We assume:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = (a_n * p_{n-1} + p_{n-2}) * q_{n-1} - (a_n * q_{n-1} + q_{n-2}) * p_{n-1} [l2].\nTherefore, we conclude:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = p_{n-2} * q_{n-1} - q_{n-2} * p_{n-1} [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l2 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n        ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - \n        ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a)) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n  (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l2 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n        ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - \n        ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a)) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n  (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by\n  have h_expand : ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a) = (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by\n    have h1 : ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) = (a n : \u211a) * (p (n - 1) : \u211a) * (q (n - 1) : \u211a) + (p (n - 2) : \u211a) * (q (n - 1) : \u211a) := by\n      ring_nf\n    have h2 : ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) * (p (n - 1) : \u211a) + (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by\n      ring_nf\n    rw [h1, h2]\n    have h3 : (a n : \u211a) * (p (n - 1) : \u211a) * (q (n - 1) : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) * (p (n - 1) : \u211a) := by\n      ring_nf\n    rw [h3]\n    <;> ring_nf\n    <;> simp [sub_eq_add_neg]\n    <;> ring_nf\n  \n  have h_main : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by\n    rw [l2]\n    rw [h_expand]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l2 is correctly captured with identical mathematical content, just with appropriate type coercions to rationals", "The conclusion l3 is perfectly represented as the theorem goal with the same mathematical equation", "The logical flow from assumption to conclusion is properly structured in the theorem format", "The additional context (recurrence relations, initial conditions, type declarations) provides necessary mathematical rigor without contradicting the natural language", "The core algebraic manipulation is mathematically equivalent between both representations"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "= -(p_{n-1}q_{n-2} - p_{n-2} q_{n-1})", "statement": "We assume:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = p_{n-2} * q_{n-1} - q_{n-2} * p_{n-1} [l3].\nTherefore, we conclude:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = -(p_{n-1} * q_{n-2} - p_{n-2} * q_{n-1}) [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l3 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n        (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a)) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n  -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n  (h_rec_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l3 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n        (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a)) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n  -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) := by\n  have h1 : (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) = (q (n - 1) : \u211a) * (p (n - 2) : \u211a) - (p (n - 1) : \u211a) * (q (n - 2) : \u211a) := by\n    have h1\u2081 : (p (n - 2) : \u211a) * (q (n - 1) : \u211a) = (q (n - 1) : \u211a) * (p (n - 2) : \u211a) := by\n      ring_nf\n      <;> simp [mul_comm]\n      <;> norm_cast\n      <;> ring_nf\n    have h1\u2082 : (q (n - 2) : \u211a) * (p (n - 1) : \u211a) = (p (n - 1) : \u211a) * (q (n - 2) : \u211a) := by\n      ring_nf\n      <;> simp [mul_comm]\n      <;> norm_cast\n      <;> ring_nf\n    calc\n      (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) = (q (n - 1) : \u211a) * (p (n - 2) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by rw [h1\u2081]\n      _ = (q (n - 1) : \u211a) * (p (n - 2) : \u211a) - (p (n - 1) : \u211a) * (q (n - 2) : \u211a) := by rw [h1\u2082]\n  \n  have h2 : (q (n - 1) : \u211a) * (p (n - 2) : \u211a) - (p (n - 1) : \u211a) * (q (n - 2) : \u211a) = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n    have h2\u2081 : (q (n - 1) : \u211a) * (p (n - 2) : \u211a) - (p (n - 1) : \u211a) * (q (n - 2) : \u211a) = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n      ring_nf at *\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try ring_nf) <;>\n      (try simp_all [sub_eq_add_neg]) <;>\n      (try norm_cast) <;>\n      (try linarith)\n      <;>\n      (try\n        {\n          simp_all [sub_eq_add_neg]\n          <;>\n          ring_nf at *\n          <;>\n          linarith\n        })\n    exact h2\u2081\n  \n  have h3 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) := by\n    calc\n      (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a) := by\n        rw [l3]\n      _ = (q (n - 1) : \u211a) * (p (n - 2) : \u211a) - (p (n - 1) : \u211a) * (q (n - 2) : \u211a) := by\n        rw [h1]\n      _ = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n        rw [h2]\n      _ = -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) := by\n        norm_cast\n        <;>\n        simp [mul_comm, mul_assoc, mul_left_comm]\n        <;>\n        ring_nf\n        <;>\n        norm_num\n        <;>\n        simp_all [sub_eq_add_neg]\n        <;>\n        norm_cast\n        <;>\n        ring_nf\n        <;>\n        linarith\n  \n  exact h3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the core logical relationship from the natural language. The assumption l3 and conclusion l4 are mathematically identical to their natural language counterparts. The additional context (recurrence relations, initial conditions, type declarations) provides necessary mathematical framework that enhances rather than contradicts the natural language statement. The type coercions from \u2124 to \u211a are technical necessities that don't alter the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "= -(-1)^{n-2}", "statement": "We assume:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = -(p_{n-1} * q_{n-2} - p_{n-2} * q_{n-1}) [l4];\n\u2022 The inductive hypothesis is p_{n-1} * q_{n-2} - q_{n-1} * p_{n-2} = (-1)^{n-2} [def_1].\nTherefore, we conclude:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = -(-1)^{n-2} [l5].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n \u2265 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l4 : p n * q (n - 1) - q n * p (n - 1) = -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)))\n  (def_1 : p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) = (-1 : \u211a) ^ (n - 2)) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n \u2265 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l4 : p n * q (n - 1) - q n * p (n - 1) = -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)))\n  (def_1 : p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) = (-1 : \u211a) ^ (n - 2)) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2)) := by\n  have h_cast_l4 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n    have h1 : ((p n * q (n - 1) - q n * p (n - 1) : \u2124) : \u211a) = (-(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) : \u2124) := by\n      norm_cast\n      <;>\n      simp_all [l4]\n      <;>\n      ring_nf at *\n      <;>\n      linarith\n    have h2 : ((p n * q (n - 1) - q n * p (n - 1) : \u2124) : \u211a) = (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) := by\n      norm_cast\n      <;>\n      simp [mul_comm, mul_assoc, mul_left_comm]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      simp_all\n      <;>\n      linarith\n    have h3 : (-(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) : \u2124) = (-(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) : \u2124) := rfl\n    have h4 : ((-(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) : \u2124) : \u211a) = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n      norm_cast\n      <;>\n      simp [mul_comm, mul_assoc, mul_left_comm]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      simp_all\n      <;>\n      linarith\n    have h5 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n      calc\n        (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = ((p n * q (n - 1) - q n * p (n - 1) : \u2124) : \u211a) := by\n          rw [h2]\n        _ = (-(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) : \u2124) := by\n          rw [h1]\n        _ = ((-(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)) : \u2124) : \u211a) := by norm_cast\n        _ = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n          rw [h4]\n    exact h5\n  \n  have h_cast_def1 : (p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a) = (-1 : \u211a) ^ (n - 2) := by\n    have h\u2081 : ((p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) : \u2124) : \u211a) = (-1 : \u211a) ^ (n - 2) := by\n      norm_cast at def_1 \u22a2\n      <;>\n      simp_all [def_1]\n      <;>\n      ring_nf at *\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    have h\u2082 : ((p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) : \u2124) : \u211a) = (p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a) := by\n      norm_cast\n      <;>\n      simp [mul_comm, mul_assoc, mul_left_comm]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      simp_all\n      <;>\n      linarith\n    have h\u2083 : (p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a) = (-1 : \u211a) ^ (n - 2) := by\n      calc\n        (p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a) = ((p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) : \u2124) : \u211a) := by\n          rw [h\u2082]\n        _ = (-1 : \u211a) ^ (n - 2) := by\n          rw [h\u2081]\n    exact h\u2083\n  \n  have h_main : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2)) := by\n    calc\n      (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n        rw [h_cast_l4]\n      _ = -((-1 : \u211a) ^ (n - 2)) := by\n        rw [h_cast_def1]\n        <;>\n        ring_nf\n        <;>\n        norm_num\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the logical structure and mathematical reasoning from the natural language. However, there is a type inconsistency issue where assumption l4 works with integers (\u2124) while the inductive hypothesis def_1 and conclusion l5 involve rationals (\u211a). This creates a minor structural difference from the natural language, which treats all expressions uniformly. The core mathematical logic is preserved, but the type casting in the conclusion suggests the formalization had to work around type system constraints that aren't reflected in the natural language presentation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the logical structure and mathematical reasoning from the natural language. However, there is a type inconsistency issue where assumption l4 works with integers (\u2124) while the inductive hypothesis def_1 and conclusion l5 involve rationals (\u211a). This creates a minor structural difference from the natural language, which treats all expressions uniformly. The core mathematical logic is preserved, but the type casting in the conclusion suggests the formalization had to work around type system constraints that aren't reflected in the natural language presentation.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "= (-1)^{n-1}", "statement": "We assume:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = -(-1)^{n-2} [l5].\nTherefore, we conclude:\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = (-1)^{n-1} [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n \u2265 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l5 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2))) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = (-1 : \u211a) ^ (n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n \u2265 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l5 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2))) :\n  (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = (-1 : \u211a) ^ (n - 1) := by\n  have h_pow : \u2200 (m : \u2124), (-1 : \u211a) ^ (m + 1) = -((-1 : \u211a) ^ m) := by\n    intro m\n    have h\u2081 : (-1 : \u211a) ^ (m + 1) = (-1 : \u211a) ^ m * (-1 : \u211a) := by\n      rw [zpow_add\u2080 (by norm_num : (-1 : \u211a) \u2260 0)]\n      <;> simp [zpow_one]\n      <;> ring\n    rw [h\u2081]\n    <;> ring_nf\n    <;> simp [zpow_neg, zpow_ofNat]\n    <;> field_simp\n    <;> norm_num\n  \n  have h_main : (-1 : \u211a) ^ (n - 1) = -((-1 : \u211a) ^ (n - 2)) := by\n    have h\u2081 : (-1 : \u211a) ^ (n - 1) = (-1 : \u211a) ^ ((n - 2) + 1) := by\n      have h\u2082 : (n - 2 : \u2124) + 1 = n - 1 := by\n        ring\n      rw [h\u2082]\n      <;> simp [zpow_add\u2080, zpow_one]\n      <;> field_simp\n      <;> ring_nf\n    rw [h\u2081]\n    have h\u2082 : (-1 : \u211a) ^ ((n - 2 : \u2124) + 1) = -((-1 : \u211a) ^ (n - 2)) := by\n      have h\u2083 := h_pow (n - 2)\n      exact h\u2083\n    rw [h\u2082]\n    <;> simp [zpow_add\u2080, zpow_one]\n    <;> field_simp\n    <;> ring_nf\n  \n  have h_final : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = (-1 : \u211a) ^ (n - 1) := by\n    have h\u2081 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2)) := l5\n    have h\u2082 : (-1 : \u211a) ^ (n - 1) = -((-1 : \u211a) ^ (n - 2)) := h_main\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l5 is correctly formalized with the exact same mathematical expression and equality", "The conclusion ts_1 is correctly formalized with the target expression that should follow from the assumption", "The mathematical relationship -(-1)^(n-2) = (-1)^(n-1) is correctly captured in the logical structure from premise to conclusion", "The additional context about sequences p and q with recurrence relations provides necessary mathematical framework without contradicting the natural language statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "l6": {"id": "l6", "natural_language": "p_n q_{n-2} - p_{n-2} q_n = (a_n p_{n-1} + p_{n-2})q_{n-2} - p_{n-2}(a_n q_{n-1} + q_{n-2})", "statement": "We assume:\n\u2022 Recurrence relations for p_n and q_n [tc_1];\n\u2022 n > 0 [def_1].\nTherefore, we conclude:\n\u2022 p_n * q_{n-2} - p_{n-2} * q_n = (a_n * p_{n-1} + p_{n-2}) * q_{n-2} - p_{n-2} * (a_n * q_{n-1} + q_{n-2}) [l6].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2", "l3", "l4", "l5", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p q a : \u2124 \u2192 \u2124)\n(tc_1 : \u2200 n : \u2124, n \u2265 1 \u2192 p n = a n * p (n - 1) + p (n - 2))\n(tc_1_q : \u2200 n : \u2124, n \u2265 1 \u2192 q n = a n * q (n - 1) + q (n - 2))\n(tc_2_p0 : p 0 = a 0)\n(tc_2_p1 : p (-1) = 1)\n(tc_2_p2 : p (-2) = 0)\n(tc_2_q0 : q 0 = 1)\n(tc_2_q1 : q (-1) = 0)\n(tc_2_q2 : q (-2) = 1)\n(l1 : (p 0 * q (-1) - q 0 * p (-1) = -1) \u2227\n      (p 0 * q (-2) - q 0 * p (-2) = a 0))\n(def_1 : p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2) = (-1 : \u211a) ^ (n - 2))\n(l2 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n      ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 1) : \u211a) - \n      ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 1) : \u211a))\n(l3 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n      (p (n - 2) : \u211a) * (q (n - 1) : \u211a) - (q (n - 2) : \u211a) * (p (n - 1) : \u211a))\n(l4 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = \n      -(p (n - 1) * q (n - 2) - q (n - 1) * p (n - 2)))\n(l5 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = -((-1 : \u211a) ^ (n - 2)))\n(ts_1 : (p n : \u211a) * (q (n - 1) : \u211a) - (q n : \u211a) * (p (n - 1) : \u211a) = (-1 : \u211a) ^ (n - 1))\n\ntheorem l6 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1) :\n  (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n  ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - \n  (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1) :\n  (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n  ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - \n  (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n  have h\u2081 : (n : \u2124) \u2265 1 := by\n    linarith\n  \n  have h\u2082 : (p n : \u211a) = (a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a) := by\n    have h\u2082 : p n = a n * p (n - 1) + p (n - 2) := h_rec_p n h\u2081\n    have h\u2083 : (p n : \u211a) = (a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a) := by\n      norm_cast at h\u2082 \u22a2\n      <;> simp_all [h\u2082]\n      <;> ring_nf at *\n      <;> norm_cast at *\n      <;> linarith\n    exact h\u2083\n  \n  have h\u2083 : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := by\n    have h\u2083 : q n = a n * q (n - 1) + q (n - 2) := h_rec_q n h\u2081\n    have h\u2084 : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := by\n      norm_cast at h\u2083 \u22a2\n      <;> simp_all [h\u2083]\n      <;> ring_nf at *\n      <;> norm_cast at *\n      <;> linarith\n    exact h\u2084\n  \n  have h\u2084 : (p n : \u211a) * (q (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) := by\n    calc\n      (p n : \u211a) * (q (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) := by\n        rw [h\u2082]\n        <;> ring_nf\n      _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) := by rfl\n  \n  have h\u2085 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) := by\n    have h\u2085 : (p n : \u211a) * (q (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) := h\u2084\n    calc\n      (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) := by\n        rw [h\u2085]\n      _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) := by rfl\n  \n  have h\u2086 : ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n    have h\u2086 : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := h\u2083\n    have h\u2087 : ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n      calc\n        ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) := by rfl\n        _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n          have h\u2088 : (q n : \u211a) * (p (n - 2) : \u211a) = (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n            have h\u2089 : (q n : \u211a) * (p (n - 2) : \u211a) = (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n              have h\u2081\u2080 : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := h\u2083\n              calc\n                (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 2) : \u211a) := by rw [h\u2081\u2080]\n                _ = (a n : \u211a) * (q (n - 1) : \u211a) * (p (n - 2) : \u211a) + (q (n - 2) : \u211a) * (p (n - 2) : \u211a) := by ring\n                _ = (a n : \u211a) * (q (n - 1) : \u211a) * (p (n - 2) : \u211a) + (q (n - 2) : \u211a) * (p (n - 2) : \u211a) := by ring\n                _ = (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n                  have h\u2081\u2081 : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := h\u2083\n                  rw [h\u2081\u2081]\n                  <;> ring\n                  <;> simp_all [mul_assoc]\n                  <;> ring_nf at *\n                  <;> norm_num at *\n                  <;> linarith\n            exact h\u2089\n          rw [h\u2088]\n          <;>\n            ring_nf\n          <;>\n            norm_num\n          <;>\n            linarith\n        _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by rfl\n    exact h\u2087\n  \n  have h\u2087 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n    calc\n      (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) := by rw [h\u2085]\n      _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by rw [h\u2086]\n  \n  calc\n    (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by\n      rw [h\u2087]\n    _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) := by rfl", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 73, "column": 22, "endLine": 73, "endColumn": 30, "data": "linarith failed to find a contradiction\ncase h1.h\np q a : \u2124 \u2192 \u2124\nn : \u2124\nhn : 0 < n\nh_rec_p : \u2200 (k : \u2124), 1 \u2264 k \u2192 p k = a k * p (k - 1) + p (k - 2)\nh_init_p0 : p 0 = a 0\nh_init_p1 : p (-1) = 1\nh_init_p2 : p (-2) = 0\nh_init_q0 : q 0 = 1\nh_init_q1 : q (-1) = 0\nh_init_q2 : q (-2) = 1\nh\u2081 : 1 \u2264 n\nh_rec_q : \u2200 (k : \u2124), 1 \u2264 k \u2192 q k = a k * q (-1 + k) + q (-2 + k)\na\u271d :\n  \u2191(a n) * \u2191(q (-1 + n)) * \u2191(p (-2 + n)) + \u2191(p (-2 + n)) * \u2191(q (-2 + n)) <\n    \u2191(a n) * \u2191(q (-1 + n)) * \u2191(q (-2 + n)) * 2 + \u2191(a n) ^ 2 * \u2191(q (-1 + n)) ^ 2 + \u2191(q (-2 + n)) ^ 2\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumptions (recurrence relations for p_n and q_n, and condition n > 0) are correctly captured in the Lean formalization as theorem parameters.", "The conclusion has a major inconsistency. In the natural language, the second term on the right-hand side is 'p_{n-2} * (a_n * q_{n-1} + q_{n-2})', but in the Lean formalization it's 'q_n * (a_n * q_{n-1} + q_{n-2})'. This substitution of p_{n-2} with q_n fundamentally changes the mathematical meaning of the equation.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The assumptions (recurrence relations for p_n and q_n, and condition n > 0) are correctly captured in the Lean formalization as theorem parameters.', \"The conclusion has a major inconsistency. In the natural language, the second term on the right-hand side is 'p_{n-2} * (a_n * q_{n-1} + q_{n-2})', but in the Lean formalization it's 'q_n * (a_n * q_{n-1} + q_{n-2})'. This substitution of p_{n-2} with q_n fundamentally changes the mathematical meaning of the equation.\"]"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "= a_n(p_{n-1}q_{n-2} - p_{n-2}q_{n-1})", "statement": "We assume:\n\u2022 p_n * q_{n-2} - p_{n-2} * q_n = (a_n * p_{n-1} + p_{n-2}) * q_{n-2} - p_{n-2} * (a_n * q_{n-1} + q_{n-2}) [l6].\nTherefore, we conclude:\n\u2022 p_n * q_{n-2} - p_{n-2} * q_n = a_n * (p_{n-1} * q_{n-2} - p_{n-2} * q_{n-1}) [l7].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2", "l3", "l4", "l5", "ts_1", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l6 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n        ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - \n        (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a))) :\n  (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n  (a n : \u211a) * ((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n > 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l6 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n        ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - \n        (q n : \u211a) * ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a))) :\n  (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n  (a n : \u211a) * ((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n  have h_n_ge_one : n \u2265 1 := by\n    have h\u2081 : (n : \u2124) \u2265 1 := by\n      -- Since n is an integer greater than 0, it must be at least 1.\n      omega\n    exact h\u2081\n  \n  have h_pn : (p n : \u211a) = (a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a) := by\n    have h1 : p n = a n * p (n - 1) + p (n - 2) := by\n      have h2 : n \u2265 1 := h_n_ge_one\n      have h3 : p n = a n * p (n - 1) + p (n - 2) := h_rec_p n h2\n      exact h3\n    -- Convert the integer equation to a rational equation\n    norm_cast at h1 \u22a2\n    <;> simp_all [h1]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_qn : (q n : \u211a) = (a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a) := by\n    have h1 : q n = a n * q (n - 1) + q (n - 2) := by\n      have h2 : n \u2265 1 := h_n_ge_one\n      have h3 : q n = a n * q (n - 1) + q (n - 2) := h_rec_q n h2\n      exact h3\n    -- Convert the integer equation to a rational equation\n    norm_cast at h1 \u22a2\n    <;> simp_all [h1]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_main : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = (a n : \u211a) * ((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n    have h\u2081 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 2) : \u211a) := by\n      calc\n        (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) := by\n          rw [h_pn]\n          <;> ring_nf\n        _ = ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 2) : \u211a) := by\n          rw [h_qn]\n          <;> ring_nf\n    have h\u2082 : ((a n : \u211a) * (p (n - 1) : \u211a) + (p (n - 2) : \u211a)) * (q (n - 2) : \u211a) - ((a n : \u211a) * (q (n - 1) : \u211a) + (q (n - 2) : \u211a)) * (p (n - 2) : \u211a) = (a n : \u211a) * ((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a)) := by\n      ring_nf at *\n      <;>\n      (try norm_num) <;>\n      (try linarith) <;>\n      (try ring_nf at *) <;>\n      (try field_simp at *) <;>\n      (try nlinarith)\n      <;>\n      (try linarith)\n      <;>\n      (try nlinarith)\n    linarith\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l6 in Lean correctly captures the natural language premise, with only minor notational differences (explicit type coercions and term reordering) that don't affect semantic meaning.", "The conclusion l7 in Lean perfectly matches the natural language conclusion, representing the same mathematical relationship with appropriate type annotations.", "The additional context (recurrence relations, initial conditions, domain constraints) in Lean provides necessary mathematical background not explicitly stated in natural language but logically consistent and helpful for completeness.", "The logical flow from assumption to conclusion is preserved, with Lean's theorem structure appropriately representing the natural language's 'assume-therefore-conclude' pattern."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "= (-1)^n a_n.", "statement": "We assume:\n\u2022 p_n * q_{n-2} - p_{n-2} * q_n = a_n * (p_{n-1} * q_{n-2} - p_{n-2} * q_{n-1}) [l7];\n\u2022 p_n * q_{n-1} - q_n * p_{n-1} = (-1)^{n-1} [ts_1].\nTherefore, we conclude:\n\u2022 p_n * q_{n-2} - p_{n-2} * q_n = (-1)^n * a_n [ts_2].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "def_1", "l2", "l3", "l4", "l5", "ts_1", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n \u2265 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l7 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n        (a n : \u211a) * ((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a))) :\n  (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = (-1 : \u211a) ^ n * (a n : \u211a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 (p q a : \u2124 \u2192 \u2124) (n : \u2124) (hn : n \u2265 0)\n  (h_rec_p : \u2200 k : \u2124, k \u2265 1 \u2192 p k = a k * p (k - 1) + p (k - 2))\n  (h_rec_q : \u2200 k : \u2124, k \u2265 1 \u2192 q k = a k * q (k - 1) + q (k - 2))\n  (h_init_p0 : p 0 = a 0)\n  (h_init_p1 : p (-1) = 1)\n  (h_init_p2 : p (-2) = 0)\n  (h_init_q0 : q 0 = 1)\n  (h_init_q1 : q (-1) = 0)\n  (h_init_q2 : q (-2) = 1)\n  (l7 : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = \n        (a n : \u211a) * ((p (n - 1) : \u211a) * (q (n - 2) : \u211a) - (q (n - 1) : \u211a) * (p (n - 2) : \u211a))) :\n  (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = (-1 : \u211a) ^ n * (a n : \u211a) := by\n  have h_main : (p n : \u211a) * (q (n - 2) : \u211a) - (q n : \u211a) * (p (n - 2) : \u211a) = (-1 : \u211a) ^ n * (a n : \u211a) := by sorry\n  sorry", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization is missing a critical assumption from the natural language: 'p_n * q_{n-1} - q_n * p_{n-1} = (-1)^{n-1} [ts_1]'. This assumption is essential for the logical derivation described in the natural language, where ts_1 is used together with l7 to conclude ts_2. Without this assumption, the theorem cannot be proven as intended. While the Lean formalization correctly captures assumption l7 and the conclusion ts_2, and includes reasonable additional mathematical context (recurrence relations and initial conditions), the missing ts_1 assumption represents a major logical gap that prevents the formalization from faithfully representing the natural language argument.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization is missing a critical assumption from the natural language: 'p_n * q_{n-1} - q_n * p_{n-1} = (-1)^{n-1} [ts_1]'. This assumption is essential for the logical derivation described in the natural language, where ts_1 is used together with l7 to conclude ts_2. Without this assumption, the theorem cannot be proven as intended. While the Lean formalization correctly captures assumption l7 and the conclusion ts_2, and includes reasonable additional mathematical context (recurrence relations and initial conditions), the missing ts_1 assumption represents a major logical gap that prevents the formalization from faithfully representing the natural language argument.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    