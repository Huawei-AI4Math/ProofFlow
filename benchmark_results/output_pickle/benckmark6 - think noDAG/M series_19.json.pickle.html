
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=4$, and the recurrence relation $a_n = 4a_{n-1} - 3a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = \frac{3^n-1}{2}$.

Proof: This proof uses **strong mathematical induction** because the recurrence relation for $a_n$ depends on two previous terms. First, we verify the formula for the initial terms, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1 = \frac{3^1-1}{2} = \frac{2}{2} = 1$. This matches the given value of $a_1=1$. For $n=2$, the formula gives $a_2 = \frac{3^2-1}{2} = \frac{8}{2} = 4$. This matches the given value of $a_2=4$. Now for the inductive step, assume the formula holds for all integers $j$ where $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = \frac{3^j-1}{2}$ is true. We must now prove that the formula holds for $n=k+1$, i.e., $a_{k+1} = \frac{3^{k+1}-1}{2}$. Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = 4a_k - 3a_{k-1}$. By our assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = 4\left(\frac{3^k-1}{2}\right) - 3\left(\frac{3^{k-1}-1}{2}\right)$. Now we expand and simplify the expression: $a_{k+1} = \frac{4(3^k-1) - 3(3^{k-1}-1)}{2} = \frac{4 \cdot 3^k - 4 - 3 \cdot 3^{k-1} + 3}{2} = \frac{4 \cdot 3^k - 3^k - 1}{2} = \frac{3 \cdot 3^k - 1}{2} = \frac{3^{k+1}-1}{2}$. This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = \frac{3^n-1}{2}$ is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=4$, and the recurrence relation $a_n = 4a_{n-1} - 3a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = (3^n - 1) / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean condition h1 : a 1 = 1 exactly matches the natural language condition a\u2081 = 1", "The Lean condition h2 : a 2 = 4 exactly matches the natural language condition a\u2082 = 4", "The Lean condition h_rec exactly captures the recurrence relation a\u2099 = 4\u00b7a\u2099\u208b\u2081 - 3\u00b7a\u2099\u208b\u2082 for n \u2265 3", "The natural language conclusion states that the sequence is 'completely defined', which means the recurrence relation and initial conditions uniquely determine all terms. However, the Lean proposition provides an explicit closed-form formula a n = (3^n - 1) / 2, which is a much stronger and different mathematical statement than just asserting the sequence is well-defined"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean condition h1 : a 1 = 1 exactly matches the natural language condition a\u2081 = 1', 'The Lean condition h2 : a 2 = 4 exactly matches the natural language condition a\u2082 = 4', 'The Lean condition h_rec exactly captures the recurrence relation a\u2099 = 4\u00b7a\u2099\u208b\u2081 - 3\u00b7a\u2099\u208b\u2082 for n \u2265 3', \"The natural language conclusion states that the sequence is 'completely defined', which means the recurrence relation and initial conditions uniquely determine all terms. However, the Lean proposition provides an explicit closed-form formula a n = (3^n - 1) / 2, which is a much stronger and different mathematical statement than just asserting the sequence is well-defined\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1 = \\frac{3^1-1}{2} = \\frac{2}{2} = 1$. This matches the given value of $a_1=1$.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\nTherefore, we conclude:\n\u2022 The formula a_n = (3^n-1)/2 holds for n=1, as (3\u00b9-1)/2 = 1, which matches the given a\u2081=1 [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) :\n  a 1 = (3^1 - 1) / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) :\n  a 1 = (3^1 - 1) / 2 := by\n  have h_main : a 1 = (3^1 - 1 : \u211d) / 2 := by\n    have h3 : (3 : \u211d) ^ 1 - 1 = 2 := by norm_num\n    have h4 : (3 : \u211d) ^ 1 - 1 = 2 := by norm_num\n    have h5 : (3 : \u211d) ^ 1 - 1 = 2 := by norm_num\n    -- Simplify the expression (3^1 - 1)/2 to 1\n    have h6 : ((3 : \u211d) ^ 1 - 1 : \u211d) / 2 = 1 := by norm_num\n    -- Use the given hypothesis a 1 = 1 to conclude the proof\n    rw [h6]\n    <;> simp_all [h1]\n    <;> norm_num\n  \n  -- The final step is to use the established fact to conclude the proof\n  simpa using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is accurately captured in the Lean hypotheses h1, h2, and h_rec.", "The conclusion that the formula a_n = (3^n-1)/2 holds for n=1 is precisely stated as the theorem goal a 1 = (3^1 - 1) / 2.", "The mathematical verification showing (3\u00b9-1)/2 = 1 = a\u2081 is implicitly contained in the Lean statement, as both sides evaluate to 1 given the hypotheses."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, the formula gives $a_2 = \\frac{3^2-1}{2} = \\frac{8}{2} = 4$. This matches the given value of $a_2=4$.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=1 [l1].\nTherefore, we conclude:\n\u2022 The formula a_n = (3^n-1)/2 holds for n=2, as (3\u00b2-1)/2 = 4, which matches the given a\u2082=4 [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) \n  (l1 : a 1 = (3^1 - 1) / 2) :\n  a 2 = (3^2 - 1) / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) \n  (l1 : a 1 = (3^1 - 1) / 2) :\n  a 2 = (3^2 - 1) / 2 := by\n  have h_main : a 2 = (3^2 - 1 : \u2115) / 2 := by\n    norm_num [h2]\n    <;>\n    simp_all [Nat.div_eq_of_lt]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  -- Since the goal is in \u211d, we need to ensure the coercion is correct.\n  -- (3^2 - 1 : \u2115) / 2 is 4 in \u2115, which coerces to 4 in \u211d.\n  norm_num at h_main \u22a2\n  <;>\n  simp_all [Nat.cast_inj]\n  <;>\n  norm_num\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all mathematical content from the natural language. The sequence definition, recurrence relation, base cases, and the theorem statement are all properly represented. The computational justification mentioned in natural language ((3\u00b2-1)/2 = 4) is appropriately handled as part of the proof rather than as an explicit hypothesis, which is mathematically sound."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the formula holds for all integers $j$ where $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = \frac{3^j-1}{2}$ is true.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=1 [l1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=2 [l2].\nDefinition:\n\u2022 For some integer k \u2265 2, we assume that for all integers j such that 1 \u2264 j \u2264 k, the formula a_j = (3^j-1)/2 is true. This is the inductive hypothesis (IH) [def_1].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\nvariable (k : \u2115) (hk : k \u2265 2)\nvariable (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization completely omits the recurrence relation definition a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3, and the initial conditions a\u2081=1, a\u2082=4. Only the sequence variable is declared without any defining properties.", "The Lean formalization does not include the specific condition that a_1 = (3^1-1)/2 holds for n=1. This base case is missing from the Lean code.", "The Lean formalization does not include the specific condition that a_2 = (3^2-1)/2 holds for n=2. This base case is missing from the Lean code.", "The Lean formalization correctly captures the inductive hypothesis with k \u2265 2 and the condition that for all j with 1 \u2264 j \u2264 k, the formula a_j = (3^j-1)/2 holds."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely omits the recurrence relation definition a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3, and the initial conditions a\u2081=1, a\u2082=4. Only the sequence variable is declared without any defining properties.', 'The Lean formalization does not include the specific condition that a_1 = (3^1-1)/2 holds for n=1. This base case is missing from the Lean code.', 'The Lean formalization does not include the specific condition that a_2 = (3^2-1)/2 holds for n=2. This base case is missing from the Lean code.', 'The Lean formalization correctly captures the inductive hypothesis with k \u2265 2 and the condition that for all j with 1 \u2264 j \u2264 k, the formula a_j = (3^j-1)/2 holds.']"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = 4a_k - 3a_{k-1}$.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=1 [l1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=2 [l2].\n\u2022 For some integer k \u2265 2, we assume that for all integers j such that 1 \u2264 j \u2264 k, the formula a_j = (3^j-1)/2 is true (IH) [def_1].\nTherefore, we conclude:\n\u2022 a_{k+1} = 4*a_k - 3*a_{k-1} [l3].", "dependencies": ["tc_1", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2))\n  (l1 : a 1 = (3^1 - 1) / 2)\n  (l2 : a 2 = (3^2 - 1) / 2)\n  (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2) :\n  a (k + 1) = 4 * a k - 3 * a (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2))\n  (l1 : a 1 = (3^1 - 1) / 2)\n  (l2 : a 2 = (3^2 - 1) / 2)\n  (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2) :\n  a (k + 1) = 4 * a k - 3 * a (k - 1) := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h : k + 1 \u2265 3 := by\n      have h\u2081 : k \u2265 2 := hk\n      have h\u2082 : k + 1 \u2265 3 := by\n        omega\n      exact h\u2082\n    exact h\n  \n  have h_main : a (k + 1) = 4 * a k - 3 * a (k - 1) := by\n    have h3 : a (k + 1) = 4 * a (k + 1 - 1) - 3 * a (k + 1 - 2) := by\n      have h4 : k + 1 \u2265 3 := h_k_plus_1_ge_3\n      have h5 : a (k + 1) = 4 * a (k + 1 - 1) - 3 * a (k + 1 - 2) := h_rec (k + 1) h4\n      exact h5\n    have h6 : (k + 1 - 1 : \u2115) = k := by\n      have h7 : k \u2265 2 := hk\n      have h8 : (k + 1 - 1 : \u2115) = k := by\n        omega\n      exact h8\n    have h9 : (k + 1 - 2 : \u2115) = k - 1 := by\n      have h10 : k \u2265 2 := hk\n      have h11 : (k + 1 - 2 : \u2115) = k - 1 := by\n        have h12 : k \u2265 2 := hk\n        have h13 : k + 1 \u2265 3 := by omega\n        have h14 : k + 1 - 2 = k - 1 := by\n          cases k with\n          | zero => contradiction -- k cannot be zero since hk : k \u2265 2\n          | succ k' =>\n            cases k' with\n            | zero => contradiction -- k cannot be one since hk : k \u2265 2\n            | succ k'' =>\n              simp [Nat.succ_eq_add_one, Nat.add_assoc] at h12 \u22a2\n              <;> ring_nf at *\n              <;> omega\n        exact h14\n      exact h11\n    have h10 : a (k + 1) = 4 * a k - 3 * a (k - 1) := by\n      rw [h3]\n      have h11 : (k + 1 - 1 : \u2115) = k := h6\n      have h12 : (k + 1 - 2 : \u2115) = k - 1 := h9\n      rw [h11, h12]\n      <;> simp [Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_mul, Nat.cast_sub]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> simp_all\n      <;> linarith\n    exact h10\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition with initial conditions a\u2081=1, a\u2082=4 and recurrence relation is correctly formalized in Lean with appropriate type declarations.", "The base cases l1 and l2 establishing the formula for n=1 and n=2 are accurately captured.", "The inductive hypothesis with constraint k \u2265 2 and the universal quantification over j in range [1,k] is properly formalized.", "The conclusion a_{k+1} = 4*a_k - 3*a_{k-1} is exactly represented in Lean notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By our assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = 4\\left(\\frac{3^k-1}{2}\\right) - 3\\left(\\frac{3^{k-1}-1}{2}\\right)$.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=1 [l1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=2 [l2].\n\u2022 For some integer k \u2265 2, we assume that for all integers j such that 1 \u2264 j \u2264 k, the formula a_j = (3^j-1)/2 is true (IH) [def_1].\n\u2022 a_{k+1} = 4*a_k - 3*a_{k-1} [l3].\nTherefore, we conclude:\n\u2022 a_{k+1} = 4*((3^k-1)/2) - 3*((3^{k-1}-1)/2) [l4].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2))\n  (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2) :\n  a (k + 1) = 4 * ((3^k - 1) / 2) - 3 * ((3^(k-1) - 1) / 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2))\n  (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2) :\n  a (k + 1) = 4 * ((3^k - 1) / 2) - 3 * ((3^(k-1) - 1) / 2) := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : k + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h_rec_k_plus_1 : a (k + 1) = 4 * a k - 3 * a (k - 1) := by\n    have h\u2081 : a (k + 1) = 4 * a (k + 1 - 1) - 3 * a (k + 1 - 2) := by\n      have h\u2082 : k + 1 \u2265 3 := h_k_plus_1_ge_3\n      have h\u2083 : a (k + 1) = 4 * a (k + 1 - 1) - 3 * a (k + 1 - 2) := h_rec (k + 1) h\u2082\n      exact h\u2083\n    have h\u2082 : a (k + 1) = 4 * a k - 3 * a (k - 1) := by\n      have h\u2083 : k + 1 - 1 = k := by\n        have h\u2084 : k \u2265 2 := hk\n        omega\n      have h\u2084 : k + 1 - 2 = k - 1 := by\n        have h\u2085 : k \u2265 2 := hk\n        omega\n      rw [h\u2081]\n      rw [h\u2083]\n      rw [h\u2084]\n      <;>\n      (try omega) <;>\n      (try ring_nf at * <;> simp_all) <;>\n      (try norm_num) <;>\n      (try linarith)\n    exact h\u2082\n  \n  have h_a_k : a k = (3^k - 1 : \u211d) / 2 := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2082 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n      have h\u2083 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n        have h\u2084 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n          have h\u2085 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n            -- Use the given property def_1 to get the expression for a k\n            have h\u2086 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n              have h\u2087 : (1 : \u2115) \u2264 k \u2227 k \u2264 k := by\n                constructor <;> omega\n              have h\u2088 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n                have h\u2089 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n                  -- Use the given property def_1 to get the expression for a k\n                  have h\u2081\u2080 : a k = (3 ^ k - 1 : \u211d) / 2 := by\n                    simpa [h\u2081] using def_1 k \u27e8by omega, by omega\u27e9\n                  exact h\u2081\u2080\n                exact h\u2089\n              exact h\u2088\n            exact h\u2086\n          exact h\u2085\n        exact h\u2084\n      exact h\u2083\n    exact h\u2082\n  \n  have h_a_k_minus_1 : a (k - 1) = (3^(k - 1) - 1 : \u211d) / 2 := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : (k - 1 : \u2115) \u2265 1 := by\n        have h\u2084 : k \u2265 2 := hk\n        omega\n      have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8by omega, by omega\u27e9\n    have h\u2082 : a (k - 1) = (3 ^ (k - 1) - 1 : \u211d) / 2 := by\n      have h\u2083 : a (k - 1) = (3 ^ (k - 1) - 1 : \u211d) / 2 := by\n        have h\u2084 : a (k - 1) = (3 ^ (k - 1) - 1 : \u211d) / 2 := by\n          -- Use the given property def_1 to get the expression for a (k - 1)\n          have h\u2085 : a (k - 1) = (3 ^ (k - 1) - 1 : \u211d) / 2 := by\n            have h\u2086 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := h\u2081\n            have h\u2087 : a (k - 1) = (3 ^ (k - 1) - 1 : \u211d) / 2 := by\n              simpa [h\u2086] using def_1 (k - 1) \u27e8by omega, by omega\u27e9\n            exact h\u2087\n          exact h\u2085\n        exact h\u2084\n      exact h\u2083\n    exact h\u2082\n  \n  have h_main : a (k + 1) = 4 * ((3^k - 1 : \u211d) / 2) - 3 * ((3^(k - 1) - 1 : \u211d) / 2) := by\n    rw [h_rec_k_plus_1]\n    rw [h_a_k]\n    rw [h_a_k_minus_1]\n    <;>\n    (try ring_nf) <;>\n    (try norm_num) <;>\n    (try field_simp) <;>\n    (try ring_nf) <;>\n    (try norm_cast) <;>\n    (try simp_all [pow_succ]) <;>\n    (try linarith)\n  \n  have h_final : a (k + 1) = 4 * ((3^k - 1) / 2) - 3 * ((3^(k-1) - 1) / 2) := by\n    simpa using h_main\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization.", "The base cases l1 and l2 are not explicitly stated as separate hypotheses in Lean, but they are logically derivable from the inductive hypothesis def_1, so this is a minor structural difference.", "The inductive hypothesis is perfectly formalized, correctly capturing both the constraint k \u2265 2 and the formula holding for all j in the range 1 \u2264 j \u2264 k.", "The recurrence application l3 is not explicitly stated as a separate hypothesis, but follows from h_rec applied to k+1. This is a minor structural difference in how the logical steps are organized.", "The conclusion is perfectly matched - the theorem statement exactly captures what needs to be proven.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization.', 'The base cases l1 and l2 are not explicitly stated as separate hypotheses in Lean, but they are logically derivable from the inductive hypothesis def_1, so this is a minor structural difference.', 'The inductive hypothesis is perfectly formalized, correctly capturing both the constraint k \u2265 2 and the formula holding for all j in the range 1 \u2264 j \u2264 k.', 'The recurrence application l3 is not explicitly stated as a separate hypothesis, but follows from h_rec applied to k+1. This is a minor structural difference in how the logical steps are organized.', 'The conclusion is perfectly matched - the theorem statement exactly captures what needs to be proven.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Now we expand and simplify the expression: $a_{k+1} = \\frac{4(3^k-1) - 3(3^{k-1}-1)}{2} = \\frac{4 \\cdot 3^k - 4 - 3 \\cdot 3^{k-1} + 3}{2} = \\frac{4 \\cdot 3^k - 3^k - 1}{2} = \\frac{3 \\cdot 3^k - 1}{2} = \\frac{3^{k+1}-1}{2}$.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=1 [l1].\n\u2022 The formula a_n = (3^n-1)/2 holds for n=2 [l2].\n\u2022 For some integer k \u2265 2, we assume that for all integers j such that 1 \u2264 j \u2264 k, the formula a_j = (3^j-1)/2 is true (IH) [def_1].\n\u2022 a_{k+1} = 4*a_k - 3*a_{k-1} [l3].\n\u2022 a_{k+1} = 4*((3^k-1)/2) - 3*((3^{k-1}-1)/2) [l4].\nTherefore, we conclude:\n\u2022 a_{k+1} = (3^{k+1}-1)/2 [l5].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2))\n  (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2)\n  (l3 : a (k + 1) = 4 * a k - 3 * a (k - 1))\n  (l4 : a (k + 1) = 4 * ((3^k - 1) / 2) - 3 * ((3^(k-1) - 1) / 2)) :\n  a (k + 1) = (3^(k+1) - 1) / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2))\n  (k : \u2115) (hk : k \u2265 2)\n  (def_1 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (3^j - 1) / 2)\n  (l3 : a (k + 1) = 4 * a k - 3 * a (k - 1))\n  (l4 : a (k + 1) = 4 * ((3^k - 1) / 2) - 3 * ((3^(k-1) - 1) / 2)) :\n  a (k + 1) = (3^(k+1) - 1) / 2 := by\n  have h_k_ge_one : (k : \u2115) \u2265 1 := by\n    omega\n  \n  have h3 : (3 : \u211d) ^ (k : \u2115) = 3 * (3 : \u211d) ^ (k - 1 : \u2115) := by\n    have h\u2083 : (k : \u2115) \u2265 1 := h_k_ge_one\n    have h\u2084 : (k : \u2115) = (k - 1 : \u2115) + 1 := by\n      have h\u2085 : (k : \u2115) \u2265 1 := h_k_ge_one\n      have h\u2086 : (k : \u2115) - 1 + 1 = (k : \u2115) := by\n        have h\u2087 : (k : \u2115) \u2265 1 := h_k_ge_one\n        omega\n      omega\n    calc\n      (3 : \u211d) ^ (k : \u2115) = (3 : \u211d) ^ ((k - 1 : \u2115) + 1 : \u2115) := by\n        rw [h\u2084]\n        <;> norm_cast\n      _ = (3 : \u211d) ^ (k - 1 : \u2115) * (3 : \u211d) ^ 1 := by\n        rw [pow_add]\n        <;> norm_cast\n      _ = (3 : \u211d) ^ (k - 1 : \u2115) * 3 := by\n        norm_num\n      _ = 3 * (3 : \u211d) ^ (k - 1 : \u2115) := by\n        ring\n  \n  have h4 : (4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 3 * (3 : \u211d) ^ (k - 1 : \u2115) = 3 * (3 : \u211d) ^ (k : \u2115) := by\n    have h\u2084 : (3 : \u211d) ^ (k : \u2115) = 3 * (3 : \u211d) ^ (k - 1 : \u2115) := h3\n    have h\u2085 : (4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 3 * (3 : \u211d) ^ (k - 1 : \u2115) = 3 * (3 : \u211d) ^ (k : \u2115) := by\n      calc\n        (4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 3 * (3 : \u211d) ^ (k - 1 : \u2115) = (4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - (3 : \u211d) ^ (k : \u2115) := by\n          -- Substitute 3 * (3 : \u211d)^(k - 1) with (3 : \u211d)^k using h\u2084\n          have h\u2086 : (3 : \u211d) ^ (k : \u2115) = 3 * (3 : \u211d) ^ (k - 1 : \u2115) := h\u2084\n          have h\u2087 : (3 : \u211d) ^ (k - 1 : \u2115) = (3 : \u211d) ^ (k - 1 : \u2115) := rfl\n          -- Use linear arithmetic to simplify the expression\n          linarith\n        _ = 3 * (3 : \u211d) ^ (k : \u2115) := by\n          -- Simplify 4 * (3 : \u211d)^k - (3 : \u211d)^k to 3 * (3 : \u211d)^k\n          ring\n          <;>\n          simp_all [pow_add, pow_one, mul_assoc]\n          <;>\n          ring_nf at *\n          <;>\n          linarith\n    exact h\u2085\n  \n  have h5 : (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 = (3 * (3 : \u211d) ^ (k : \u2115) - 1) / 2 := by\n    have h\u2085 : (4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 3 * (3 : \u211d) ^ (k - 1 : \u2115) = 3 * (3 : \u211d) ^ (k : \u2115) := h4\n    calc\n      (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 = ((4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 4 - (3 * (3 : \u211d) ^ (k - 1 : \u2115) - 3)) / 2 := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n        <;> linarith\n      _ = ((4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 3 * (3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 := by\n        ring_nf\n        <;> field_simp\n        <;> ring_nf\n        <;> linarith\n      _ = (3 * (3 : \u211d) ^ (k : \u2115) - 1) / 2 := by\n        have h\u2086 : (4 : \u211d) * (3 : \u211d) ^ (k : \u2115) - 3 * (3 : \u211d) ^ (k - 1 : \u2115) = 3 * (3 : \u211d) ^ (k : \u2115) := h4\n        rw [h\u2086]\n        <;> ring_nf\n        <;> field_simp\n        <;> linarith\n  \n  have h6 : (3 : \u211d) ^ (k + 1 : \u2115) = 3 * (3 : \u211d) ^ (k : \u2115) := by\n    have h\u2086 : (3 : \u211d) ^ (k + 1 : \u2115) = (3 : \u211d) ^ (k : \u2115) * 3 := by\n      calc\n        (3 : \u211d) ^ (k + 1 : \u2115) = (3 : \u211d) ^ (k : \u2115) * (3 : \u211d) ^ 1 := by\n          rw [pow_add]\n          <;> norm_num\n        _ = (3 : \u211d) ^ (k : \u2115) * 3 := by norm_num\n    calc\n      (3 : \u211d) ^ (k + 1 : \u2115) = (3 : \u211d) ^ (k : \u2115) * 3 := h\u2086\n      _ = 3 * (3 : \u211d) ^ (k : \u2115) := by ring\n  \n  have h7 : (3 * (3 : \u211d) ^ (k : \u2115) - 1 : \u211d) / 2 = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n    have h\u2087 : (3 : \u211d) ^ (k + 1 : \u2115) = 3 * (3 : \u211d) ^ (k : \u2115) := h6\n    have h\u2088 : (3 * (3 : \u211d) ^ (k : \u2115) - 1 : \u211d) / 2 = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n      rw [h\u2087]\n      <;> ring_nf\n      <;> field_simp\n      <;> linarith\n    exact h\u2088\n  \n  have h8 : (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n    calc\n      (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 = (3 * (3 : \u211d) ^ (k : \u2115) - 1) / 2 := by\n        -- Use h5 to simplify the left-hand side to (3 * (3 : \u211d) ^ (k : \u2115) - 1) / 2\n        rw [h5]\n      _ = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n        -- Use h7 to show that (3 * (3 : \u211d) ^ (k : \u2115) - 1) / 2 equals ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2\n        rw [h7]\n  \n  have h9 : (4 : \u211d) * ((3 ^ k - 1 : \u211d) / 2) - 3 * ((3 ^ (k - 1) - 1 : \u211d) / 2) = (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 := by\n    have h\u2089 : (3 : \u211d) ^ (k : \u2115) = (3 : \u211d) ^ (k : \u2115) := rfl\n    have h\u2081\u2080 : (3 : \u211d) ^ (k - 1 : \u2115) = (3 : \u211d) ^ (k - 1 : \u2115) := rfl\n    have h\u2081\u2081 : (3 : \u211d) ^ (k : \u2115) = (3 : \u211d) ^ (k : \u2115) := rfl\n    have h\u2081\u2082 : (3 : \u211d) ^ (k - 1 : \u2115) = (3 : \u211d) ^ (k - 1 : \u2115) := rfl\n    -- Convert the natural number powers to real numbers and simplify the expression\n    have h\u2081\u2083 : (3 : \u211d) ^ (k : \u2115) = (3 : \u211d) ^ (k : \u2115) := rfl\n    have h\u2081\u2084 : (3 : \u211d) ^ (k - 1 : \u2115) = (3 : \u211d) ^ (k - 1 : \u2115) := rfl\n    -- Use the fact that the real power of 3 is the same as the natural power of 3 when cast to real numbers\n    have h\u2081\u2085 : ((3 : \u2115) ^ k : \u211d) = (3 : \u211d) ^ (k : \u2115) := by\n      norm_cast\n      <;> simp [pow_mul]\n      <;> ring_nf\n      <;> norm_cast\n    have h\u2081\u2086 : ((3 : \u2115) ^ (k - 1) : \u211d) = (3 : \u211d) ^ (k - 1 : \u2115) := by\n      norm_cast\n      <;> simp [pow_mul]\n      <;> ring_nf\n      <;> norm_cast\n    -- Substitute the real powers into the original expression\n    calc\n      (4 : \u211d) * ((3 ^ k - 1 : \u211d) / 2) - 3 * ((3 ^ (k - 1) - 1 : \u211d) / 2) = (4 : \u211d) * ((((3 : \u2115) ^ k : \u211d) - 1) / 2) - 3 * ((((3 : \u2115) ^ (k - 1) : \u211d) - 1) / 2) := by\n        norm_num [pow_succ]\n        <;>\n        simp_all [pow_succ]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      _ = (4 : \u211d) * (((3 : \u211d) ^ (k : \u2115) - 1) / 2) - 3 * (((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2) := by\n        rw [h\u2081\u2085, h\u2081\u2086]\n        <;>\n        norm_num [pow_succ]\n        <;>\n        simp_all [pow_succ]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      _ = (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 := by\n        ring_nf\n        <;>\n        simp_all [pow_succ]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n  \n  have h10 : a (k + 1) = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n    have h\u2081\u2080 : a (k + 1) = 4 * ((3 ^ k - 1 : \u211d) / 2) - 3 * ((3 ^ (k - 1) - 1 : \u211d) / 2) := by\n      exact l4\n    have h\u2081\u2081 : (4 : \u211d) * ((3 ^ k - 1 : \u211d) / 2) - 3 * ((3 ^ (k - 1) - 1 : \u211d) / 2) = (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 := by\n      exact h9\n    have h\u2081\u2082 : (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n      exact h8\n    calc\n      a (k + 1) = 4 * ((3 ^ k - 1 : \u211d) / 2) - 3 * ((3 ^ (k - 1) - 1 : \u211d) / 2) := by rw [h\u2081\u2080]\n      _ = (4 : \u211d) * ((3 : \u211d) ^ (k : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k - 1 : \u2115) - 1) / 2 := by\n        rw [h\u2081\u2081]\n        <;>\n        norm_num at *\n        <;>\n        ring_nf at *\n        <;>\n        simp_all [pow_succ]\n        <;>\n        linarith\n      _ = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n        rw [h\u2081\u2082]\n        <;>\n        norm_num at *\n        <;>\n        ring_nf at *\n        <;>\n        simp_all [pow_succ]\n        <;>\n        linarith\n  \n  have h11 : a (k + 1) = (3^(k+1) - 1) / 2 := by\n    have h\u2081\u2081 : a (k + 1) = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := h10\n    have h\u2081\u2082 : ((3 : \u211d) ^ (k + 1 : \u2115) - 1 : \u211d) / 2 = ((3 : \u2115) ^ (k + 1) - 1 : \u211d) / 2 := by\n      norm_cast\n      <;>\n      simp [pow_add, pow_one, mul_comm]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      simp_all [pow_succ]\n      <;>\n      linarith\n    have h\u2081\u2083 : a (k + 1) = ((3 : \u2115) ^ (k + 1) - 1 : \u211d) / 2 := by\n      calc\n        a (k + 1) = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := h\u2081\u2081\n        _ = ((3 : \u2115) ^ (k + 1) - 1 : \u211d) / 2 := by\n          rw [h\u2081\u2082]\n          <;>\n          simp_all [pow_add, pow_one, mul_comm]\n          <;>\n          ring_nf\n          <;>\n          norm_num\n          <;>\n          linarith\n    have h\u2081\u2084 : ((3 : \u2115) ^ (k + 1) - 1 : \u211d) / 2 = (3^(k+1) - 1 : \u211d) / 2 := by\n      norm_num [pow_add, pow_one, mul_comm]\n      <;>\n      simp_all [pow_add, pow_one, mul_comm]\n      <;>\n      ring_nf at *\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    calc\n      a (k + 1) = ((3 : \u2115) ^ (k + 1) - 1 : \u211d) / 2 := by rw [h\u2081\u2083]\n      _ = (3^(k+1) - 1 : \u211d) / 2 := by rw [h\u2081\u2084]\n      _ = (3^(k+1) - 1) / 2 := by norm_num\n  \n  rw [h11]\n  <;>\n  norm_num\n  <;>\n  simp_all [pow_add, pow_one, mul_comm]\n  <;>\n  ring_nf at *\n  <;>\n  norm_num at *\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The sequence definition with initial conditions and recurrence relation is properly stated. The inductive hypothesis (def_1) correctly formalizes the assumption that the formula holds for all j from 1 to k. The intermediate steps l3 and l4 are accurately represented, and the goal l5 matches the conclusion. While l1 and l2 are not explicit separate hypotheses, they are logically contained within the inductive hypothesis def_1, making the formalization complete and mathematically sound."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = \frac{3^n-1}{2}$ is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The sequence (a_n) for n \u2265 1 is defined by a\u2081=1, a\u2082=4, and the recurrence relation a_n = 4*a_{n-1} - 3*a_{n-2} for n \u2265 3 [tc_1].\n\u2022 The formula a_n = (3^n-1)/2 holds for the base cases n=1 and n=2 [l1, l2].\n\u2022 For an integer k \u2265 2, assuming a_j = (3^j-1)/2 for all 1 \u2264 j \u2264 k [def_1] implies that a_{k+1} = (3^{k+1}-1)/2 [l5].\nTherefore, we conclude:\n\u2022 The formula a_n = (3^n-1)/2 is true for all integers n \u2265 1 [ts_1].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = (3^n - 1) / 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 4) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 4 * a (n - 1) - 3 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = (3^n - 1) / 2 := by\n  have h_main : \u2200 n : \u2115, n \u2265 1 \u2192 a n = (3^n - 1 : \u211d) / 2 := by\n    intro n hn\n    have h : \u2200 n : \u2115, n \u2265 1 \u2192 a n = (3^n - 1 : \u211d) / 2 := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        contradiction\n      | 1 =>\n        norm_num [h1] at hn \u22a2\n        <;>\n        simp_all [h1]\n        <;>\n        norm_num\n      | 2 =>\n        norm_num [h2] at hn \u22a2\n        <;>\n        simp_all [h2]\n        <;>\n        norm_num\n      | k + 3 =>\n        have h\u2083 : a (k + 3) = 4 * a (k + 2) - 3 * a (k + 1) := by\n          have h\u2084 : (k + 3 : \u2115) \u2265 3 := by\n            omega\n          have h\u2085 : a (k + 3) = 4 * a (k + 3 - 1) - 3 * a (k + 3 - 2) := h_rec (k + 3) h\u2084\n          have h\u2086 : (k + 3 : \u2115) - 1 = k + 2 := by\n            omega\n          have h\u2087 : (k + 3 : \u2115) - 2 = k + 1 := by\n            omega\n          rw [h\u2085, h\u2086, h\u2087]\n          <;>\n          simp [add_assoc]\n        have h\u2084 : a (k + 3) = (3 ^ (k + 3 : \u2115) - 1 : \u211d) / 2 := by\n          have h\u2085 : a (k + 2) = ((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2 := by\n            have h\u2085\u2081 : (k + 2 : \u2115) \u2265 1 := by\n              omega\n            have h\u2085\u2082 : a (k + 2) = (3 ^ (k + 2 : \u2115) - 1 : \u211d) / 2 := by\n              apply ih (k + 2)\n              <;>\n              omega\n            -- Ensure the power is in \u211d\n            have h\u2085\u2083 : (3 : \u211d) ^ (k + 2 : \u2115) = (3 : \u211d) ^ (k + 2 : \u2115) := rfl\n            have h\u2085\u2084 : (3 : \u2115) ^ (k + 2 : \u2115) = (3 : \u2115) ^ (k + 2 : \u2115) := rfl\n            -- Use the fact that the coercion from \u2115 to \u211d commutes with powers\n            have h\u2085\u2085 : ((3 : \u2115) ^ (k + 2 : \u2115) : \u211d) = (3 : \u211d) ^ (k + 2 : \u2115) := by\n              norm_cast\n            -- Rewrite the expression to use (3 : \u211d)\n            calc\n              a (k + 2) = (3 ^ (k + 2 : \u2115) - 1 : \u211d) / 2 := h\u2085\u2082\n              _ = (((3 : \u2115) ^ (k + 2 : \u2115) : \u211d) - 1 : \u211d) / 2 := by\n                norm_cast\n              _ = ((3 : \u211d) ^ (k + 2 : \u2115) - 1 : \u211d) / 2 := by\n                rw [h\u2085\u2085]\n                <;>\n                simp [zpow_ofNat]\n          have h\u2086 : a (k + 1) = ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n            have h\u2086\u2081 : (k + 1 : \u2115) \u2265 1 := by\n              omega\n            have h\u2086\u2082 : a (k + 1) = (3 ^ (k + 1 : \u2115) - 1 : \u211d) / 2 := by\n              apply ih (k + 1)\n              <;>\n              omega\n            -- Ensure the power is in \u211d\n            have h\u2086\u2083 : (3 : \u211d) ^ (k + 1 : \u2115) = (3 : \u211d) ^ (k + 1 : \u2115) := rfl\n            have h\u2086\u2084 : (3 : \u2115) ^ (k + 1 : \u2115) = (3 : \u2115) ^ (k + 1 : \u2115) := rfl\n            -- Use the fact that the coercion from \u2115 to \u211d commutes with powers\n            have h\u2086\u2085 : ((3 : \u2115) ^ (k + 1 : \u2115) : \u211d) = (3 : \u211d) ^ (k + 1 : \u2115) := by\n              norm_cast\n            -- Rewrite the expression to use (3 : \u211d)\n            calc\n              a (k + 1) = (3 ^ (k + 1 : \u2115) - 1 : \u211d) / 2 := h\u2086\u2082\n              _ = (((3 : \u2115) ^ (k + 1 : \u2115) : \u211d) - 1 : \u211d) / 2 := by\n                norm_cast\n              _ = ((3 : \u211d) ^ (k + 1 : \u2115) - 1 : \u211d) / 2 := by\n                rw [h\u2086\u2085]\n                <;>\n                simp [zpow_ofNat]\n          rw [h\u2083, h\u2085, h\u2086]\n          -- Simplify the expression to match the target form\n          have h\u2087 : (4 : \u211d) * (((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2) - 3 * (((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2) = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := by\n            have h\u2088 : (3 : \u211d) ^ (k + 3 : \u2115) = (3 : \u211d) ^ (k + 2 : \u2115) * 3 := by\n              rw [show (k + 3 : \u2115) = (k + 2 : \u2115) + 1 by ring]\n              simp [pow_add, pow_one, mul_assoc]\n              <;>\n              ring_nf\n            have h\u2089 : (3 : \u211d) ^ (k + 2 : \u2115) = (3 : \u211d) ^ (k + 1 : \u2115) * 3 := by\n              rw [show (k + 2 : \u2115) = (k + 1 : \u2115) + 1 by ring]\n              simp [pow_add, pow_one, mul_assoc]\n              <;>\n              ring_nf\n            have h\u2081\u2080 : (3 : \u211d) ^ (k + 3 : \u2115) = (3 : \u211d) ^ (k + 1 : \u2115) * 9 := by\n              calc\n                (3 : \u211d) ^ (k + 3 : \u2115) = (3 : \u211d) ^ (k + 2 : \u2115) * 3 := by rw [h\u2088]\n                _ = ((3 : \u211d) ^ (k + 1 : \u2115) * 3) * 3 := by rw [h\u2089]\n                _ = (3 : \u211d) ^ (k + 1 : \u2115) * 9 := by ring\n            -- Simplify the LHS using algebraic manipulation\n            have h\u2081\u2081 : (4 : \u211d) * (((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2) - 3 * (((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2) = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := by\n              calc\n                (4 : \u211d) * (((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2) - 3 * (((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2)\n                  = (4 : \u211d) * ((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2 - 3 * ((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by ring\n                _ = (4 * (3 : \u211d) ^ (k + 2 : \u2115) - 4) / 2 - (3 * (3 : \u211d) ^ (k + 1 : \u2115) - 3) / 2 := by ring\n                _ = (4 * (3 : \u211d) ^ (k + 2 : \u2115) - 4 - (3 * (3 : \u211d) ^ (k + 1 : \u2115) - 3)) / 2 := by\n                  ring_nf\n                  <;>\n                  field_simp\n                  <;>\n                  ring_nf\n                _ = (4 * (3 : \u211d) ^ (k + 2 : \u2115) - 3 * (3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by ring\n                _ = (4 * ((3 : \u211d) ^ (k + 1 : \u2115) * 3) - 3 * (3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by\n                  rw [h\u2089]\n                  <;>\n                  ring_nf\n                _ = (12 * (3 : \u211d) ^ (k + 1 : \u2115) - 3 * (3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by ring\n                _ = (9 * (3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2 := by ring\n                _ = ((3 : \u211d) ^ (k + 1 : \u2115) * 9 - 1) / 2 := by ring\n                _ = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := by\n                  rw [h\u2081\u2080]\n                  <;>\n                  ring_nf\n            exact h\u2081\u2081\n          -- Use the simplified expression to conclude the proof\n          have h\u2088 : (4 : \u211d) * (((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2) - 3 * (((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2) = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := h\u2087\n          have h\u2089 : (3 : \u211d) ^ (k + 3 : \u2115) = (3 : \u211d) ^ (k + 3 : \u2115) := rfl\n          have h\u2081\u2080 : ((3 : \u2115) ^ (k + 3 : \u2115) : \u211d) = (3 : \u211d) ^ (k + 3 : \u2115) := by\n            norm_cast\n          -- Convert the goal to use (3 : \u211d)\n          calc\n            (4 : \u211d) * (((3 : \u211d) ^ (k + 2 : \u2115) - 1) / 2) - 3 * (((3 : \u211d) ^ (k + 1 : \u2115) - 1) / 2) = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := by rw [h\u2088]\n            _ = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := by rfl\n            _ = ((3 : \u211d) ^ (k + 3 : \u2115) - 1) / 2 := by rfl\n            _ = ((3 : \u2115) ^ (k + 3 : \u2115) - 1 : \u211d) / 2 := by\n              norm_cast\n              <;>\n              simp [zpow_ofNat]\n              <;>\n              ring_nf\n              <;>\n              field_simp\n              <;>\n              linarith\n        exact h\u2084\n    exact h n hn\n  intro n hn\n  have h\u2081 : a n = (3^n - 1 : \u211d) / 2 := h_main n hn\n  norm_num at h\u2081 \u22a2\n  <;>\n  simp_all [h\u2081]\n  <;>\n  ring_nf at *\n  <;>\n  norm_num at *\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization with the correct mathematical relationships.", "The base cases are implicitly handled rather than explicitly stated as separate hypotheses, but this is a minor structural difference that doesn't affect the logical meaning.", "The inductive step is implicitly part of what needs to be proven rather than stated as a separate lemma, which is a minor structural difference in how the proof is organized.", "The final conclusion perfectly matches - both state that the formula a_n = (3^n-1)/2 holds for all n \u2265 1, with the Lean version appropriately using natural numbers instead of integers."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization with the correct mathematical relationships.', \"The base cases are implicitly handled rather than explicitly stated as separate hypotheses, but this is a minor structural difference that doesn't affect the logical meaning.\", 'The inductive step is implicitly part of what needs to be proven rather than stated as a separate lemma, which is a minor structural difference in how the proof is organized.', 'The final conclusion perfectly matches - both state that the formula a_n = (3^n-1)/2 holds for all n \u2265 1, with the Lean version appropriately using natural numbers instead of integers.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    