
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a discrete random variable with a probability mass function (PMF) given by $P(X=k) = (1-p)p^k$ for $k \in \{0, 1, 2, ...\}$. The parameter $p$ satisfies $0 < p < 1$. Then, the expected value of $X$ is $E[X] = \frac{p}{1-p}$, the variance of $X$ is $Var(X) = \frac{p}{(1-p)^2}$, and the characteristic function of $X$ is $\phi_X(t) = \frac{1-p}{1-pe^{it}}$.

Proof: To find the moments and characteristic function of $X$, we rely on the properties of geometric series. Since $0 < p < 1$, the geometric series $\sum_{k=0}^\infty a^k$ converges for $a=p$, with the sum being $\sum_{k=0}^\infty a^k = \frac{1}{1-a}$ for $|a|<1$. By differentiating this series with respect to $a$, we find that $\sum_{k=0}^\infty k a^k = \frac{a}{(1-a)^2}$. Using this result, the expected value of $X$ is calculated as $E[X] = \sum_{k=0}^\infty k \cdot P(X=k) = (1-p) \sum_{k=0}^\infty k p^k = (1-p) \frac{p}{(1-p)^2} = \frac{p}{1-p}$. To find the variance, we first need $E[X^2]$. Differentiating the series for $\sum k a^k$ again yields $\sum_{k=0}^\infty k^2 a^k = \frac{a(1+a)}{(1-a)^3}$. This allows us to compute the second moment: $E[X^2] = \sum_{k=0}^\infty k^2 \cdot P(X=k) = (1-p) \sum_{k=0}^\infty k^2 p^k = (1-p) \frac{p(1+p)}{(1-p)^3} = \frac{p(1+p)}{(1-p)^2}$. Now, we can find the variance using the formula $Var(X) = E[X^2] - (E[X])^2 = \frac{p(1+p)}{(1-p)^2} - \left(\frac{p}{1-p}\right)^2 = \frac{p+p^2-p^2}{(1-p)^2} = \frac{p}{(1-p)^2}$. For the characteristic function, we must evaluate the series $E[e^{itX}]$. The term of the corresponding geometric series is $pe^{it}$. Since $0 < p < 1$ and $|e^{it}|=1$, the magnitude $|pe^{it}| = p < 1$, which guarantees convergence. The characteristic function is $\phi_X(t) = E[e^{itX}] = \sum_{k=0}^\infty e^{itk} P(X=k) = (1-p) \sum_{k=0}^\infty (pe^{it})^k = (1-p) \frac{1}{1-pe^{it}} = \frac{1-p}{1-pe^{it}}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a discrete random variable with a probability mass function (PMF) given by $P(X=k) = (1-p)p^k$ for $k \\in \\{0, 1, 2, ...\\}$. The parameter $p$ satisfies $0 < p < 1$.", "statement": "Premise:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\nvariable (P : \u2115 \u2192 \u211d) \n(tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n(tc_1_sum : \u2211' k, P k = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The Lean formalization uses P : \u2115 \u2192 \u211d to represent the PMF, but doesn't explicitly model X as a random variable. Instead, it directly works with the probability mass function P. This captures the mathematical essence but is not a literal translation of 'X is a discrete random variable'", "The PMF formula P k = (1 - p) * p^k perfectly matches P(X=k) = (1-p)p^k, and the domain \u2115 corresponds to {0, 1, 2, ...}", "The constraints hp_pos : 0 < p and hp_lt_one : p < 1 exactly match the condition 0 < p < 1", "The condition tc_1_sum : \u2211' k, P k = 1 is an additional mathematical requirement that P is a valid probability mass function. This is logically consistent and a natural formalization detail not explicitly stated in the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "the geometric series $\\sum_{k=0}^\\infty a^k$ converges for $a=p$, with the sum being $\\sum_{k=0}^\\infty a^k = \\frac{1}{1-a}$ for $|a|<1$.", "statement": "We assume:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1].\nTherefore, we conclude:\n\u2022 For any real number $a$ such that $|a|<1$, the geometric series sum is $\\sum_{k=0}^\\infty a^k = \\frac{1}{1-a}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u211d) (ha : abs a < 1) : \u2211' k : \u2115, a^k = 1 / (1 - a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u211d) (ha : abs a < 1) : \u2211' k : \u2115, a^k = 1 / (1 - a) := by\n  have h\u2081 : a \u2260 1 := by\n    intro h\n    rw [h] at ha\n    norm_num [abs_of_pos] at ha\n    <;> linarith\n  \n  have h\u2082 : 1 - a \u2260 0 := by\n    intro h\n    have h\u2083 : a = 1 := by linarith\n    contradiction\n  \n  have h\u2083 : Summable (fun k : \u2115 => a ^ k) := by\n    have h\u2084 : abs a < 1 := ha\n    -- Use the fact that the series is summable if the absolute value of a is less than 1\n    have h\u2085 : Summable (fun n : \u2115 => a ^ n) := by\n      -- Apply the lemma that states the geometric series is summable when |a| < 1\n      apply summable_geometric_of_abs_lt_one\n      <;> assumption\n    -- The series is summable, so we can use the result directly\n    exact h\u2085\n  \n  have h\u2084 : (1 - a) * \u2211' k : \u2115, a ^ k = 1 := by\n    have h\u2085 : \u2200 n : \u2115, (1 - a) * \u2211 k in Finset.range n, a ^ k = 1 - a ^ n := by\n      intro n\n      have h\u2086 : (1 - a) * \u2211 k in Finset.range n, a ^ k = 1 - a ^ n := by\n        have h\u2087 : (a - 1) * \u2211 k in Finset.range n, a ^ k = a ^ n - 1 := by\n          have h\u2088 : \u2200 (n : \u2115) (x : \u211d), (x - 1) * \u2211 k in Finset.range n, x ^ k = x ^ n - 1 := by\n            intro n x\n            induction n with\n            | zero =>\n              norm_num\n            | succ n ih =>\n              rw [Finset.sum_range_succ, mul_add]\n              simp_all [pow_succ]\n              <;> ring_nf at *\n              <;> nlinarith\n          have h\u2089 := h\u2088 n a\n          exact h\u2089\n        have h\u2081\u2080 : (a - 1) * \u2211 k in Finset.range n, a ^ k = a ^ n - 1 := h\u2087\n        have h\u2081\u2081 : (1 - a) * \u2211 k in Finset.range n, a ^ k = 1 - a ^ n := by\n          have h\u2081\u2082 : (1 - a) * \u2211 k in Finset.range n, a ^ k = -((a - 1) * \u2211 k in Finset.range n, a ^ k) := by\n            ring\n          rw [h\u2081\u2082]\n          have h\u2081\u2083 : -((a - 1) * \u2211 k in Finset.range n, a ^ k) = -(a ^ n - 1) := by\n            rw [h\u2081\u2080]\n          rw [h\u2081\u2083]\n          <;> ring_nf\n          <;> linarith\n        exact h\u2081\u2081\n      exact h\u2086\n    have h\u2086 : HasSum (fun k : \u2115 => a ^ k) (\u2211' k : \u2115, a ^ k) := by\n      apply h\u2083.hasSum\n    have h\u2087 : Tendsto (fun n : \u2115 => \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd (\u2211' k : \u2115, a ^ k)) := by\n      have h\u2088 : HasSum (fun k : \u2115 => a ^ k) (\u2211' k : \u2115, a ^ k) := h\u2086\n      exact h\u2088.tendsto_sum_nat\n    have h\u2088 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd ((1 - a : \u211d) * \u2211' k : \u2115, a ^ k)) := by\n      have h\u2089 : Tendsto (fun n : \u2115 => \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd (\u2211' k : \u2115, a ^ k)) := h\u2087\n      have h\u2081\u2080 : Continuous (fun x : \u211d => (1 - a : \u211d) * x) := by continuity\n      have h\u2081\u2081 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd ((1 - a : \u211d) * \u2211' k : \u2115, a ^ k)) := by\n        have h\u2081\u2082 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd ((1 - a : \u211d) * \u2211' k : \u2115, a ^ k)) :=\n          h\u2081\u2080.continuousAt.tendsto.comp h\u2089\n        exact h\u2081\u2082\n      exact h\u2081\u2081\n    have h\u2089 : Tendsto (fun n : \u2115 => (1 : \u211d) - a ^ n) atTop (\ud835\udcdd (1 : \u211d)) := by\n      have h\u2081\u2080 : Tendsto (fun n : \u2115 => a ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0) := by\n        -- Use the fact that the series is summable to show that a^n tends to 0\n        have h\u2081\u2081 : Summable (fun k : \u2115 => a ^ k) := h\u2083\n        have h\u2081\u2082 : Tendsto (fun n : \u2115 => a ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0) := by\n          -- Use the fact that if a series is summable, then its terms tend to 0\n          have h\u2081\u2083 : Tendsto (fun n : \u2115 => a ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0) :=\n            h\u2081\u2081.tendsto_atTop_zero\n          exact h\u2081\u2083\n        exact h\u2081\u2082\n      have h\u2081\u2081 : Tendsto (fun n : \u2115 => (1 : \u211d) - a ^ n) atTop (\ud835\udcdd (1 - 0)) := by\n        have h\u2081\u2082 : Tendsto (fun n : \u2115 => (a ^ n : \u211d)) atTop (\ud835\udcdd 0) := h\u2081\u2080\n        have h\u2081\u2083 : Tendsto (fun n : \u2115 => (1 : \u211d) - a ^ n) atTop (\ud835\udcdd (1 - 0)) :=\n          Tendsto.const_sub (1 : \u211d) h\u2081\u2082\n        exact h\u2081\u2083\n      have h\u2081\u2082 : (1 : \u211d) - 0 = (1 : \u211d) := by norm_num\n      have h\u2081\u2083 : Tendsto (fun n : \u2115 => (1 : \u211d) - a ^ n) atTop (\ud835\udcdd (1 : \u211d)) :=\n        h\u2081\u2081.congr' (by simp [h\u2081\u2082])\n      exact h\u2081\u2083\n    have h\u2081\u2080 : (1 - a : \u211d) * \u2211' k : \u2115, a ^ k = 1 := by\n      have h\u2081\u2081 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd ((1 - a : \u211d) * \u2211' k : \u2115, a ^ k)) := h\u2088\n      have h\u2081\u2082 : Tendsto (fun n : \u2115 => (1 : \u211d) - a ^ n) atTop (\ud835\udcdd (1 : \u211d)) := h\u2089\n      have h\u2081\u2083 : \u2200 n : \u2115, (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k = (1 : \u211d) - a ^ n := by\n        intro n\n        have h\u2081\u2084 := h\u2085 n\n        linarith\n      have h\u2081\u2084 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd (1 : \u211d)) := by\n        have h\u2081\u2085 : (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) = (fun n : \u2115 => (1 : \u211d) - a ^ n) := by\n          funext n\n          rw [h\u2081\u2083 n]\n        rw [h\u2081\u2085]\n        exact h\u2089\n      have h\u2081\u2085 : (1 - a : \u211d) * \u2211' k : \u2115, a ^ k = 1 := by\n        have h\u2081\u2086 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd ((1 - a : \u211d) * \u2211' k : \u2115, a ^ k)) := h\u2088\n        have h\u2081\u2087 : Tendsto (fun n : \u2115 => (1 - a : \u211d) * \u2211 k in Finset.range n, a ^ k) atTop (\ud835\udcdd (1 : \u211d)) := h\u2081\u2084\n        have h\u2081\u2088 : (1 - a : \u211d) * \u2211' k : \u2115, a ^ k = 1 := by\n          apply tendsto_nhds_unique h\u2081\u2086 h\u2081\u2087\n        exact h\u2081\u2088\n      exact h\u2081\u2085\n    exact h\u2081\u2080\n  \n  have h\u2085 : \u2211' k : \u2115, a ^ k = 1 / (1 - a) := by\n    have h\u2086 : (1 - a) * \u2211' k : \u2115, a ^ k = 1 := h\u2084\n    have h\u2087 : \u2211' k : \u2115, a ^ k = 1 / (1 - a) := by\n      have h\u2088 : 1 - a \u2260 0 := h\u2082\n      -- Solve for the sum by dividing both sides by (1 - a)\n      have h\u2089 : \u2211' k : \u2115, a ^ k = 1 / (1 - a) := by\n        calc\n          \u2211' k : \u2115, a ^ k = (1 : \u211d) / (1 - a) := by\n            -- Divide both sides of the equation by (1 - a)\n            have h\u2081\u2080 : (1 - a) * \u2211' k : \u2115, a ^ k = 1 := h\u2086\n            field_simp [h\u2088] at h\u2081\u2080 \u22a2\n            <;> nlinarith\n          _ = 1 / (1 - a) := by ring\n      exact h\u2089\n    exact h\u2087\n  \n  apply h\u2085", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 85, "column": 23, "endLine": 85, "endColumn": 33, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization completely omits the premise about the discrete random variable X with its PMF P(X=k) = (1-p)p^k where 0 < p < 1. This is a significant missing component from the natural language.", "The geometric series theorem is perfectly captured in Lean. The condition |a|<1, the infinite sum notation, and the formula 1/(1-a) are all correctly formalized.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely omits the premise about the discrete random variable X with its PMF P(X=k) = (1-p)p^k where 0 < p < 1. This is a significant missing component from the natural language.', 'The geometric series theorem is perfectly captured in Lean. The condition |a|<1, the infinite sum notation, and the formula 1/(1-a) are all correctly formalized.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By differentiating this series with respect to $a$, we find that $\\sum_{k=0}^\\infty k a^k = \\frac{a}{(1-a)^2}$.", "statement": "We assume:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1];\n\u2022 For any real number $a$ such that $|a|<1$, the geometric series sum is $\\sum_{k=0}^\\infty a^k = \\frac{1}{1-a}$ [l1].\nTherefore, we conclude:\n\u2022 For any real number $a$ such that $|a|<1$, the sum is $\\sum_{k=0}^\\infty k a^k = \\frac{a}{(1-a)^2}$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u211d) (ha : abs a < 1) (l1 : \u2211' k : \u2115, a^k = 1 / (1 - a)) :\n  \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u211d) (ha : abs a < 1) (l1 : \u2211' k : \u2115, a^k = 1 / (1 - a)) :\n  \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2 := by\n  have h_main : \u2211' k : \u2115, (k : \u211d) * a ^ k = a / (1 - a) ^ 2 := by\n    have h\u2081 : HasSum (fun n : \u2115 => (n : \u211d) * a ^ n) (a / (1 - a) ^ 2) := by\n      -- Convert the absolute value condition to a norm condition\n      have h\u2082 : \u2016a\u2016 < 1 := by\n        simpa [Real.norm_eq_abs] using ha\n      -- Use the lemma to get the hasSum result\n      have h\u2083 : HasSum (fun n : \u2115 => (n : \u211d) * a ^ n) (a / (1 - a) ^ 2) := by\n        -- Use the lemma for the sum of the series\n        have h\u2084 : HasSum (fun n : \u2115 => (n : \u211d) * a ^ n) (a / (1 - a) ^ 2) := by\n          convert hasSum_coe_mul_geometric_of_norm_lt_one h\u2082 using 1\n          <;> field_simp [sub_ne_zero.mpr (show (1 : \u211d) \u2260 a by\n            intro h\n            have h\u2085 : a = 1 := by linarith\n            rw [h\u2085] at ha\n            norm_num [abs_of_pos] at ha)]\n          <;> ring_nf\n          <;> field_simp [sub_ne_zero.mpr (show (1 : \u211d) \u2260 a by\n            intro h\n            have h\u2085 : a = 1 := by linarith\n            rw [h\u2085] at ha\n            norm_num [abs_of_pos] at ha)]\n          <;> ring_nf\n        exact h\u2084\n      exact h\u2083\n    -- Use the hasSum result to get the tsum result\n    have h\u2082 : \u2211' (n : \u2115), (n : \u211d) * a ^ n = a / (1 - a) ^ 2 := by\n      -- Use the uniqueness of the sum\n      have h\u2083 : HasSum (fun n : \u2115 => (n : \u211d) * a ^ n) (a / (1 - a) ^ 2) := h\u2081\n      -- Convert the hasSum to tsum\n      exact h\u2083.tsum_eq\n    -- Use the tsum result to conclude the proof\n    simpa using h\u2082\n  \n  -- Use the main result to conclude the proof\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The geometric series formula l1 is correctly captured as a hypothesis in the Lean theorem, with the same mathematical content: infinite sum of powers of a equals 1/(1-a)", "The main theorem statement l2 is perfectly formalized, with the infinite sum \u2211k\u00b7a^k = a/(1-a)\u00b2 correctly represented using Lean's infinite sum notation and explicit type casting of k to reals", "The constraint |a|<1 is correctly represented as 'abs a < 1' in Lean, capturing the same mathematical condition", "The variable type 'real number a' is properly declared as '(a : \u211d)' in Lean", "The logical structure correctly captures the natural language flow: l1 is given as an assumption/hypothesis, and l2 is the conclusion to be proved, which matches the 'Therefore, we conclude' structure in the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "the expected value of $X$ is calculated as $E[X] = \\sum_{k=0}^\\infty k \\cdot P(X=k)$", "statement": "Definition:\n\u2022 The expected value of $X$ is defined as $E[X] = \\sum_{k=0}^\\infty k \\cdot P(X=k)$ [def_1].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (hP : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l1 : \u2200 a : \u211d, abs a < 1 \u2192 \u2211' k : \u2115, a^k = 1 / (1 - a))\n  (l2 : \u2200 a : \u211d, abs a < 1 \u2192 \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2) :\n  \u2211' k : \u2115, (k : \u211d) * P k = p / (1 - p) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states 'X is a random variable' but the Lean theorem has no random variable X - instead it works with a real parameter p", "The natural language states 'P(X=k) represents the probability that X equals k' (general probability function), but Lean specifically defines P k = (1 - p) * p^k, which is a geometric distribution, not a general probability function", "The natural language states 'The sum exists' as a general condition, but Lean provides specific lemmas l1 and l2 about geometric series convergence, which are much more specific than the general existence condition", "The natural language concludes with the general definition E[X] = \u2211_{k=0}^\u221e k \u00b7 P(X=k), but Lean concludes with a specific result \u2211' k : \u2115, (k : \u211d) * P k = p / (1 - p), which is the expected value of a geometric distribution, not the general definition of expected value"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states 'X is a random variable' but the Lean theorem has no random variable X - instead it works with a real parameter p\", \"The natural language states 'P(X=k) represents the probability that X equals k' (general probability function), but Lean specifically defines P k = (1 - p) * p^k, which is a geometric distribution, not a general probability function\", \"The natural language states 'The sum exists' as a general condition, but Lean provides specific lemmas l1 and l2 about geometric series convergence, which are much more specific than the general existence condition\", \"The natural language concludes with the general definition E[X] = \u2211_{k=0}^\u221e k \u00b7 P(X=k), but Lean concludes with a specific result \u2211' k : \u2115, (k : \u211d) * P k = p / (1 - p), which is the expected value of a geometric distribution, not the general definition of expected value\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "$E[X] = \\sum_{k=0}^\\infty k \\cdot P(X=k) = (1-p) \\sum_{k=0}^\\infty k p^k$", "statement": "We assume:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1];\n\u2022 The expected value of $X$ is defined as $E[X] = \\sum_{k=0}^\\infty k \\cdot P(X=k)$ [def_1].\nTherefore, we conclude:\n\u2022 $E[X] = (1-p) \\sum_{k=0}^\\infty k p^k$ [l3].", "dependencies": ["tc_1", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k) :\n  \u2211' k, k * P k = (1 - p) * \u2211' k, k * p^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k) :\n  \u2211' k, (k : \u211d) * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p^k := by\n  have h_sum_rewrite : \u2211' k : \u2115, (k : \u211d) * P k = \u2211' k : \u2115, (1 - p) * ((k : \u211d) * p ^ k) := by\n    have h1 : \u2200 k : \u2115, (k : \u211d) * P k = (1 - p) * ((k : \u211d) * p ^ k) := by\n      intro k\n      have h2 : P k = (1 - p) * p ^ k := tc_1 k\n      rw [h2]\n      <;> ring_nf\n      <;> simp [pow_mul, mul_assoc]\n      <;> ring_nf\n      <;> field_simp\n      <;> ring_nf\n    calc\n      \u2211' k : \u2115, (k : \u211d) * P k = \u2211' k : \u2115, ((1 - p) * ((k : \u211d) * p ^ k)) := by\n        exact tsum_congr h1\n      _ = \u2211' k : \u2115, (1 - p) * ((k : \u211d) * p ^ k) := by rfl\n  \n  have h_factor_out : \u2211' k : \u2115, (1 - p) * ((k : \u211d) * p ^ k) = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by\n    -- Use the property of tsum to factor out the constant (1 - p)\n    rw [tsum_mul_left]\n    <;>\n    simp_all [mul_assoc]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h_final : \u2211' k : \u2115, (k : \u211d) * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by\n    calc\n      \u2211' k : \u2115, (k : \u211d) * P k = \u2211' k : \u2115, (1 - p) * ((k : \u211d) * p ^ k) := by rw [h_sum_rewrite]\n      _ = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by rw [h_factor_out]\n  \n  have h_main : \u2211' k, (k : \u211d) * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by\n    have h\u2081 : \u2211' k : \u2115, (k : \u211d) * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := h_final\n    have h\u2082 : \u2211' k, (k : \u211d) * P k = \u2211' k : \u2115, (k : \u211d) * P k := by\n      simp [tsum_eq_zero_of_not_summable]\n      <;>\n      (try norm_num) <;>\n      (try simp_all [Nat.cast_eq_zero]) <;>\n      (try linarith)\n    calc\n      \u2211' k, (k : \u211d) * P k = \u2211' k : \u2115, (k : \u211d) * P k := by rw [h\u2082]\n      _ = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by rw [h\u2081]\n      _ = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by rfl\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 20, "endLine": 8, "endColumn": 21, "data": "application type mismatch\n  P k\nargument\n  k\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}, {"line": 39, "column": 34, "endLine": 39, "endColumn": 35, "data": "application type mismatch\n  P k\nargument\n  k\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}, {"line": 41, "column": 32, "endLine": 41, "endColumn": 33, "data": "application type mismatch\n  P k\nargument\n  k\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}, {"line": 42, "column": 6, "endLine": 42, "endColumn": 41, "data": "simp made no progress"}, {"line": 48, "column": 24, "endLine": 48, "endColumn": 25, "data": "application type mismatch\n  P k\nargument\n  k\nhas type\n  \u211d : Type\nbut is expected to have type\n  \u2115 : Type"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The PMF definition, domain, and constraints on p are correctly formalized. Using P : \u2115 \u2192 \u211d appropriately represents the probability mass function on natural numbers.", "The infinite sum notation \u2211' k, k * P k correctly represents the expected value definition from the natural language.", "The conclusion equation is precisely captured, showing the equality between the expected value and its factored form.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3_negation_implies_false \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k) :\n  (\u00ac (\u2211' k : \u2115, (k : \u211d) * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k)) \u2192 False := by\n  intro h_neg\n  have h\u2081 : \u2016(p : \u211d)\u2016 < 1 := by\n    rw [Real.norm_eq_abs]\n    rw [abs_of_nonneg (le_of_lt hp_pos)]\n    <;> linarith\n  \n  have h\u2082 : Summable fun k : \u2115 => (k : \u211d) * p ^ k := by\n    have h\u2083 : Summable fun k : \u2115 => (k : \u211d) ^ 1 * p ^ k := by\n      -- Use the theorem summable_pow_mul_geometric_of_norm_lt_one to show that the series is summable.\n      apply summable_pow_mul_geometric_of_norm_lt_one 1 h\u2081\n    -- Convert the sum from (k : \u211d)^1 * p^k to (k : \u211d) * p^k.\n    convert h\u2083 using 1\n    <;> simp [pow_one]\n    <;> congr 1 <;> ext k <;> ring_nf\n  \n  have h_pos : \u2211' k : \u2115, (k : \u211d) * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by\n    calc\n      \u2211' k : \u2115, (k : \u211d) * P k = \u2211' k : \u2115, (k : \u211d) * ((1 - p) * p ^ k) := by\n        -- Substitute the expression for P k using the given condition tc_1\n        congr with k\n        rw [tc_1]\n        <;> ring_nf\n      _ = \u2211' k : \u2115, (1 - p) * ((k : \u211d) * p ^ k) := by\n        -- Factor out (1 - p) from each term in the sum\n        congr with k\n        <;> ring_nf\n        <;> simp [mul_assoc, mul_comm, mul_left_comm]\n        <;> ring_nf\n      _ = (1 - p) * \u2211' k : \u2115, (k : \u211d) * p ^ k := by\n        -- Factor out (1 - p) from the entire sum\n        rw [tsum_mul_left]\n        <;> simp_all [mul_assoc]\n        <;>\n        (try norm_num) <;>\n        (try linarith)\n  \n  -- Use the fact that h_pos contradicts h_neg to derive False\n  have h\u2083 : False := by\n    apply h_neg\n    exact h_pos\n  \n  exact h\u2083"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "= (1-p) \\frac{p}{(1-p)^2} = \\frac{p}{1-p}$.", "statement": "We assume:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1];\n\u2022 For any real number $a$ such that $|a|<1$, the sum is $\\sum_{k=0}^\\infty k a^k = \\frac{a}{(1-a)^2}$ [l2];\n\u2022 $E[X] = (1-p) \\sum_{k=0}^\\infty k p^k$ [l3].\nTherefore, we conclude:\n\u2022 $E[X] = \\frac{p}{1-p}$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l2 : \u2200 a : \u211d, abs a < 1 \u2192 \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2)\n  (l3 : \u2211' k, k * P k = (1 - p) * \u2211' k, k * p^k) :\n  \u2211' k, k * P k = p / (1 - p) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l2 : \u2200 a : \u211d, abs a < 1 \u2192 \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2)\n  (l3 : \u2211' k, k * P k = (1 - p) * \u2211' k, k * p^k) :\n  \u2211' k, k * P k = p / (1 - p) := by\n  have h_sum_p : \u2211' (k : \u2115), (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n    have h\u2081 : abs p < 1 := by\n      rw [abs_of_pos hp_pos]\n      linarith\n    have h\u2082 : \u2211' (k : \u2115), (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n      have h\u2083 : \u2211' (k : \u2115), (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n        have h\u2084 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n          -- Apply the given lemma l2 to p\n          have h\u2085 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n            -- Use the lemma l2 to get the sum\n            have h\u2086 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n              calc\n                \u2211' k : \u2115, (k : \u211d) * p ^ k = \u2211' k : \u2115, (k : \u211d) * p ^ k := rfl\n                _ = p / (1 - p) ^ 2 := by\n                  -- Use the lemma l2 to get the sum\n                  have h\u2087 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n                    -- Apply the lemma l2\n                    have h\u2088 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n                      -- Use the lemma l2 to get the sum\n                      have h\u2089 : \u2211' k : \u2115, (k : \u211d) * p ^ k = \u2211' k : \u2115, (k : \u211d) * p ^ k := rfl\n                      rw [h\u2089]\n                      have h\u2081\u2080 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n                        -- Apply the lemma l2\n                        have h\u2081\u2081 : abs p < 1 := h\u2081\n                        have h\u2081\u2082 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n                          calc\n                            \u2211' k : \u2115, (k : \u211d) * p ^ k = \u2211' k : \u2115, (k : \u211d) * p ^ k := rfl\n                            _ = p / (1 - p) ^ 2 := by\n                              -- Use the lemma l2 to get the sum\n                              have h\u2081\u2083 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n                                -- Apply the lemma l2\n                                have h\u2081\u2084 : \u2211' k : \u2115, (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := by\n                                  calc\n                                    \u2211' k : \u2115, (k : \u211d) * p ^ k = \u2211' k : \u2115, (k : \u211d) * p ^ k := rfl\n                                    _ = p / (1 - p) ^ 2 := by\n                                      -- Use the lemma l2 to get the sum\n                                      simpa using l2 p h\u2081\n                                exact h\u2081\u2084\n                              exact h\u2081\u2083\n                        exact h\u2081\u2082\n                      exact h\u2081\u2080\n                    exact h\u2088\n                  exact h\u2087\n                _ = p / (1 - p) ^ 2 := by rfl\n            exact h\u2086\n          exact h\u2085\n        exact h\u2084\n      exact h\u2083\n    exact h\u2082\n  \n  have h_sum_P : \u2211' (k : \u2115), (k : \u211d) * P k = (1 - p) * \u2211' (k : \u2115), (k : \u211d) * p ^ k := by\n    have h\u2081 : \u2211' (k : \u2115), (k : \u211d) * P k = \u2211' (k : \u2115), (k : \u211d) * ((1 - p) * p ^ k) := by\n      -- Use the fact that P k = (1 - p) * p ^ k to rewrite the sum\n      have h\u2082 : \u2200 (k : \u2115), (k : \u211d) * P k = (k : \u211d) * ((1 - p) * p ^ k) := by\n        intro k\n        have h\u2083 : P k = (1 - p) * p ^ k := by\n          rw [tc_1]\n        rw [h\u2083]\n        <;> ring_nf\n      -- Use the fact that the terms are equal to show the sums are equal\n      calc\n        \u2211' (k : \u2115), (k : \u211d) * P k = \u2211' (k : \u2115), ( (k : \u211d) * P k : \u211d) := by simp\n        _ = \u2211' (k : \u2115), ( (k : \u211d) * ((1 - p) * p ^ k) : \u211d) := by\n          -- Apply the term-wise equality\n          exact tsum_congr h\u2082\n        _ = \u2211' (k : \u2115), (k : \u211d) * ((1 - p) * p ^ k) := by simp\n    -- Now factor out (1 - p) from the sum\n    calc\n      \u2211' (k : \u2115), (k : \u211d) * P k = \u2211' (k : \u2115), (k : \u211d) * ((1 - p) * p ^ k) := h\u2081\n      _ = \u2211' (k : \u2115), (1 - p) * ((k : \u211d) * p ^ k) := by\n        -- Use the fact that (k : \u211d) * ((1 - p) * p ^ k) = (1 - p) * ((k : \u211d) * p ^ k)\n        have h\u2083 : \u2200 (k : \u2115), (k : \u211d) * ((1 - p) * p ^ k) = (1 - p) * ((k : \u211d) * p ^ k) := by\n          intro k\n          ring_nf\n        calc\n          \u2211' (k : \u2115), (k : \u211d) * ((1 - p) * p ^ k) = \u2211' (k : \u2115), ( (k : \u211d) * ((1 - p) * p ^ k) : \u211d) := by simp\n          _ = \u2211' (k : \u2115), ( (1 - p) * ((k : \u211d) * p ^ k) : \u211d) := by\n            -- Apply the term-wise equality\n            exact tsum_congr h\u2083\n          _ = \u2211' (k : \u2115), (1 - p) * ((k : \u211d) * p ^ k) := by simp\n      _ = (1 - p) * \u2211' (k : \u2115), (k : \u211d) * p ^ k := by\n        -- Factor out the constant (1 - p)\n        rw [tsum_mul_left]\n        <;>\n        simp_all [mul_assoc]\n        <;>\n        ring_nf\n        <;>\n        norm_num\n        <;>\n        linarith\n  \n  have h_main : \u2211' (k : \u2115), (k : \u211d) * P k = p / (1 - p) := by\n    have h\u2081 : \u2211' (k : \u2115), (k : \u211d) * P k = (1 - p) * \u2211' (k : \u2115), (k : \u211d) * p ^ k := h_sum_P\n    rw [h\u2081]\n    have h\u2082 : \u2211' (k : \u2115), (k : \u211d) * p ^ k = p / (1 - p) ^ 2 := h_sum_p\n    rw [h\u2082]\n    have h\u2083 : (1 - p : \u211d) \u2260 0 := by\n      have h\u2084 : p < 1 := hp_lt_one\n      linarith\n    have h\u2084 : (1 - p : \u211d) ^ 2 \u2260 0 := by\n      have h\u2085 : (1 - p : \u211d) \u2260 0 := h\u2083\n      positivity\n    field_simp [h\u2083, h\u2084]\n    <;> ring_nf\n    <;> field_simp [h\u2083, h\u2084]\n    <;> ring_nf\n    <;> linarith\n  \n  have h_final' : \u2211' k, k * P k = p / (1 - p) := by\n    have h\u2081 : \u2211' (k : \u2115), (k : \u211d) * P k = p / (1 - p) := by simpa using h_main\n    have h\u2082 : \u2211' (k : \u2115), (k : \u2115) * P k = \u2211' (k : \u2115), (k : \u211d) * P k := by\n      -- Prove that the sum of (k : \u2115) * P k is equal to the sum of (k : \u211d) * P k\n      have h\u2083 : \u2200 (k : \u2115), ((k : \u2115) : \u211d) * P k = (k : \u211d) * P k := by\n        intro k\n        norm_cast\n      calc\n        \u2211' (k : \u2115), (k : \u2115) * P k = \u2211' (k : \u2115), ((k : \u2115) : \u211d) * P k := by\n          -- Since (k : \u2115) * P k is automatically cast to \u211d, we can write it as ((k : \u2115) : \u211d) * P k\n          simp [Nat.cast_id]\n        _ = \u2211' (k : \u2115), (k : \u211d) * P k := by\n          -- Use the fact that ((k : \u2115) : \u211d) * P k = (k : \u211d) * P k\n          exact tsum_congr h\u2083\n    -- Now, since \u2211' k, k * P k is definitionally equal to \u2211' (k : \u2115), (k : \u2115) * P k, we can use h\u2082 to relate it to h\u2081\n    have h\u2083 : \u2211' k, k * P k = \u2211' (k : \u2115), (k : \u2115) * P k := by\n      rfl\n    have h\u2084 : \u2211' (k : \u2115), (k : \u2115) * P k = p / (1 - p) := by\n      calc\n        \u2211' (k : \u2115), (k : \u2115) * P k = \u2211' (k : \u2115), (k : \u211d) * P k := by rw [h\u2082]\n        _ = p / (1 - p) := by rw [h\u2081]\n    calc\n      \u2211' k, k * P k = \u2211' (k : \u2115), (k : \u2115) * P k := by rw [h\u2083]\n      _ = p / (1 - p) := by rw [h\u2084]\n  \n  exact h_final'", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The PMF definition is correctly formalized with proper domain (\u2115 for non-negative integers), the exact formula (1-p)*p^k, and the constraint 0 < p < 1.", "The sum formula assumption is perfectly captured with correct absolute value condition and the precise mathematical relationship.", "The expected value formula correctly represents E[X] as the infinite sum and properly captures the factorization with (1-p).", "The conclusion correctly states the final result with consistent representation of E[X] as the infinite sum."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "l4": {"id": "l4", "natural_language": "Differentiating the series for $\\sum k a^k$ again yields $\\sum_{k=0}^\\infty k^2 a^k = \\frac{a(1+a)}{(1-a)^3}$.", "statement": "We assume:\n\u2022 For any real number $a$ such that $|a|<1$, the sum is $\\sum_{k=0}^\\infty k a^k = \\frac{a}{(1-a)^2}$ [l2].\nTherefore, we conclude:\n\u2022 For any real number $a$ such that $|a|<1$, the sum is $\\sum_{k=0}^\\infty k^2 a^k = \\frac{a(1+a)}{(1-a)^3}$ [l4].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u211d) (ha : abs a < 1) \n  (l2 : \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2) :\n  \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u211d) (ha : abs a < 1) \n  (l2 : \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2) :\n  \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3 := by\n  have h_sum_a_pow : \u2211' k : \u2115, a ^ k = (1 : \u211d) / (1 - a) := by sorry\n  have h_sum_a_pow_pos : \u2211' k : \u2115, a ^ (k + 1) = a / (1 - a) := by sorry\n  have h_sum_k_a_pow : \u2211' k : \u2115, (k : \u211d) * a ^ (k + 1) = a ^ 2 / (1 - a) ^ 2 := by sorry\n  have h_sum_2k1 : (1 - a) * \u2211' k : \u2115, (k : \u211d)^2 * a^k = (a + a ^ 2) / (1 - a)^2 := by sorry\n  have h_main : \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3 := by sorry\n  sorry", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The constraint |a| < 1 for real number a is correctly captured as (a : \u211d) (ha : abs a < 1)", "The assumption l2 about the infinite sum \u2211k*a^k = a/(1-a)^2 is correctly represented as a hypothesis", "The conclusion l4 about \u2211k\u00b2*a^k = a(1+a)/(1-a)\u00b3 is correctly captured in the theorem goal", "The logical structure (assumption \u2192 conclusion) is properly represented as a theorem with hypothesis l2 and goal l4", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u211d) (ha : abs a < 1) \n  (l2 : \u2211' k : \u2115, (k : \u211d) * a^k = a / (1 - a)^2) :\n  \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3 := by\n  have h\u2081 : \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3 := by\n    have h\u2082 : a \u2260 1 := by\n      intro h\n      rw [h] at ha\n      norm_num [abs_of_pos] at ha\n    have h\u2083 : 1 - a \u2260 0 := by\n      intro h\n      have h\u2084 : a = 1 := by linarith\n      contradiction\n    -- Use the known power series result for \u2211' k : \u2115, (k : \u211d)^2 * a^k\n    -- This step would require a detailed proof using calculus, which we cannot yet formalize\n    -- For now, we will assume the result based on known power series identities.\n    have h\u2084 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n      -- Use the fact that the sum is unique and can be derived using calculus\n      -- This step would require a detailed proof using calculus, which we cannot yet formalize\n      -- For now, we will assume the result based on known power series identities.\n      have h\u2085 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n        -- This is a placeholder for the actual proof, which would involve detailed calculus\n        -- For the purpose of this example, we assume the result\n        have h\u2086 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n          -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n          -- This step would require a detailed proof using calculus, which we cannot yet formalize\n          -- For now, we will assume the result based on known power series identities.\n          have h\u2087 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n            -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n            -- This step would require a detailed proof using calculus, which we cannot yet formalize\n            -- For now, we will assume the result based on known power series identities.\n            have h\u2088 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n              -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n              -- This step would require a detailed proof using calculus, which we cannot yet formalize\n              -- For now, we will assume the result based on known power series identities.\n              have h\u2089 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n                -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n                -- This step would require a detailed proof using calculus, which we cannot yet formalize\n                -- For now, we will assume the result based on known power series identities.\n                have h\u2081\u2080 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n                  -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n                  -- This step would require a detailed proof using calculus, which we cannot yet formalize\n                  -- For now, we will assume the result based on known power series identities.\n                  have h\u2081\u2081 : abs a < 1 := ha\n                  -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n                  -- This step would require a detailed proof using calculus, which we cannot yet formalize\n                  -- For now, we will assume the result based on known power series identities.\n                  have h\u2081\u2082 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n                    -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n                    -- This step would require a detailed proof using calculus, which we cannot yet formalize\n                    -- For now, we will assume the result based on known power series identities.\n                    calc\n                      \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = \u2211' k : \u2115, (k : \u211d)^2 * a ^ k := rfl\n                      _ = a * (1 + a) / (1 - a)^3 := by\n                        -- This step would require a detailed proof using calculus\n                        -- For now, we will assume the result based on known power series identities.\n                        have h\u2081\u2083 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n                          -- Use the fact that the sum is unique and can be derived using calculus\n                          -- This step would require a detailed proof using calculus, which we cannot yet formalize\n                          -- For now, we will assume the result based on known power series identities.\n                          have h\u2081\u2084 : \u2211' k : \u2115, (k : \u211d)^2 * a ^ k = a * (1 + a) / (1 - a)^3 := by\n                            -- Use the known power series sum for \u2211' k : \u2115, (k : \u211d)^2 * a ^ k\n                            -- This step would require a detailed proof using calculus, which we cannot yet formalize\n                            -- For now, we will assume the result based on known power series identities.\n                            sorry\n                          exact h\u2081\u2084\n                        exact h\u2081\u2083\n                  exact h\u2081\u2082\n                exact h\u2081\u2080\n              exact h\u2089\n            exact h\u2088\n          exact h\u2087\n        exact h\u2086\n      exact h\u2085\n    exact h\u2084\n  exact h\u2081"}, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "$E[X^2] = \\sum_{k=0}^\\infty k^2 \\cdot P(X=k)$", "statement": "Definition:\n\u2022 The second moment of $X$ is defined as $E[X^2] = \\sum_{k=0}^\\infty k^2 \\cdot P(X=k)$ [def_2].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (hP : \u2200 k : \u2115, P k = (1 - p) * p^k) :\n  \u2211' k : \u2115, (k : \u211d)^2 * P k = p / (1 - p) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean uses P as a function \u2115 \u2192 \u211d which can represent probabilities, but doesn't explicitly state that X is a random variable. This is a minor structural difference but captures the same mathematical concept.", "The Lean theorem constrains P to follow a specific geometric distribution formula (1-p)*p^k, while the natural language presents a general definition that should work for any probability distribution. This is a major restriction not present in the original definition.", "Both the natural language and Lean formulation use summation over all natural numbers from 0 to infinity, which matches perfectly.", "The natural language defines the second moment as the sum, while the Lean theorem proves that this sum equals a specific value p/(1-p). The Lean is proving a result about the second moment rather than defining what the second moment is."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean uses P as a function \u2115 \u2192 \u211d which can represent probabilities, but doesn't explicitly state that X is a random variable. This is a minor structural difference but captures the same mathematical concept.\", 'The Lean theorem constrains P to follow a specific geometric distribution formula (1-p)*p^k, while the natural language presents a general definition that should work for any probability distribution. This is a major restriction not present in the original definition.', 'Both the natural language and Lean formulation use summation over all natural numbers from 0 to infinity, which matches perfectly.', 'The natural language defines the second moment as the sum, while the Lean theorem proves that this sum equals a specific value p/(1-p). The Lean is proving a result about the second moment rather than defining what the second moment is.']"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "$E[X^2] = \\sum_{k=0}^\\infty k^2 \\cdot P(X=k) = (1-p) \\sum_{k=0}^\\infty k^2 p^k = (1-p) \\frac{p(1+p)}{(1-p)^3} = \\frac{p(1+p)}{(1-p)^2}$.", "statement": "We assume:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1];\n\u2022 For any real number $a$ such that $|a|<1$, the sum is $\\sum_{k=0}^\\infty k^2 a^k = \\frac{a(1+a)}{(1-a)^3}$ [l4];\n\u2022 The second moment of $X$ is defined as $E[X^2] = \\sum_{k=0}^\\infty k^2 \\cdot P(X=k)$ [def_2].\nTherefore, we conclude:\n\u2022 $E[X^2] = \\frac{p(1+p)}{(1-p)^2}$ [l5].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l4 : \u2200 a : \u211d, abs a < 1 \u2192 \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3)\n  (def_2 : \u2211' k : \u2115, (k : \u211d)^2 * P k = p / (1 - p)) :\n  \u2211' k : \u2115, (k : \u211d)^2 * P k = p * (1 + p) / (1 - p)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l4 : \u2200 a : \u211d, abs a < 1 \u2192 \u2211' k : \u2115, (k : \u211d)^2 * a^k = a * (1 + a) / (1 - a)^3)\n  (def_2 : \u2211' k : \u2115, (k : \u211d)^2 * P k = p / (1 - p)) :\n  \u2211' k : \u2115, (k : \u211d)^2 * P k = p * (1 + p) / (1 - p)^2 := by\n  have h_sum : \u2211' k : \u2115, (k : \u211d)^2 * P k = p * (1 + p) / (1 - p)^2 := by\n    have h\u2081 : \u2211' k : \u2115, (k : \u211d)^2 * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d)^2 * p ^ k := by\n      calc\n        \u2211' k : \u2115, (k : \u211d)^2 * P k = \u2211' k : \u2115, (k : \u211d)^2 * ((1 - p) * p ^ k) := by\n          congr with k\n          rw [tc_1]\n        _ = \u2211' k : \u2115, (1 - p) * ((k : \u211d)^2 * p ^ k) := by\n          congr with k\n          ring\n        _ = (1 - p) * \u2211' k : \u2115, (k : \u211d)^2 * p ^ k := by\n          rw [tsum_mul_left]\n    have h\u2082 : abs p < 1 := by\n      rw [abs_of_pos hp_pos]\n      linarith\n    have h\u2083 : \u2211' k : \u2115, (k : \u211d)^2 * p ^ k = p * (1 + p) / (1 - p) ^ 3 := by\n      have h\u2084 : \u2211' k : \u2115, (k : \u211d)^2 * p ^ k = p * (1 + p) / (1 - p) ^ 3 := by\n        have h\u2085 : \u2211' k : \u2115, (k : \u211d)^2 * p ^ k = p * (1 + p) / (1 - p) ^ 3 := by\n          have h\u2086 := l4 p h\u2082\n          -- Simplify the expression using the given lemma\n          norm_num at h\u2086 \u22a2\n          <;>\n          (try ring_nf at h\u2086 \u22a2) <;>\n          (try field_simp at h\u2086 \u22a2) <;>\n          (try norm_num at h\u2086 \u22a2) <;>\n          (try linarith) <;>\n          (try simp_all [pow_succ]) <;>\n          (try ring_nf at h\u2086 \u22a2) <;>\n          (try field_simp at h\u2086 \u22a2) <;>\n          (try norm_num at h\u2086 \u22a2) <;>\n          (try linarith) <;>\n          (try simp_all [pow_succ]) <;>\n          (try ring_nf at h\u2086 \u22a2) <;>\n          (try field_simp at h\u2086 \u22a2) <;>\n          (try norm_num at h\u2086 \u22a2) <;>\n          (try linarith)\n          <;>\n          simp_all [pow_succ]\n          <;>\n          ring_nf at *\n          <;>\n          linarith\n        exact h\u2085\n      exact h\u2084\n    have h\u2084 : (1 - p : \u211d) \u2260 0 := by\n      have h\u2085 : p < 1 := hp_lt_one\n      linarith\n    calc\n      \u2211' k : \u2115, (k : \u211d)^2 * P k = (1 - p) * \u2211' k : \u2115, (k : \u211d)^2 * p ^ k := by rw [h\u2081]\n      _ = (1 - p) * (p * (1 + p) / (1 - p) ^ 3) := by rw [h\u2083]\n      _ = p * (1 + p) / (1 - p) ^ 2 := by\n        have h\u2085 : (1 - p : \u211d) \u2260 0 := by\n          have h\u2086 : p < 1 := hp_lt_one\n          linarith\n        field_simp [h\u2085, pow_ne_zero]\n        <;> ring_nf\n        <;> field_simp [h\u2085, pow_ne_zero]\n        <;> ring_nf\n        <;> linarith\n  \n  have h_false : False := by\n    have h\u2081 : p * (1 + p) / (1 - p) ^ 2 = p / (1 - p) := by\n      linarith\n    have h\u2082 : (1 - p : \u211d) \u2260 0 := by\n      have h\u2083 : p < 1 := hp_lt_one\n      linarith\n    have h\u2083 : p * (1 + p) = p * (1 - p) := by\n      have h\u2084 : p * (1 + p) / (1 - p) ^ 2 = p / (1 - p) := h\u2081\n      have h\u2085 : (1 - p : \u211d) \u2260 0 := h\u2082\n      field_simp [h\u2085, pow_ne_zero] at h\u2084\n      <;>\n      (try ring_nf at h\u2084 \u22a2) <;>\n      (try nlinarith) <;>\n      (try linarith) <;>\n      (try nlinarith [hp_pos, hp_lt_one])\n      <;>\n      nlinarith [hp_pos, hp_lt_one]\n    have h\u2084 : p > 0 := hp_pos\n    have h\u2085 : p * (1 + p) = p * (1 - p) := h\u2083\n    have h\u2086 : 1 + p = 1 - p := by\n      apply mul_left_cancel\u2080 (show (p : \u211d) \u2260 0 by linarith)\n      linarith\n    have h\u2087 : p = 0 := by linarith\n    linarith\n  \n  have h_main : \u2211' k : \u2115, (k : \u211d)^2 * P k = p * (1 + p) / (1 - p)^2 := by\n    exfalso\n    exact h_false\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The random variable definition is correctly captured with the PMF formula and parameter constraints.", "The sum formula assumption is accurately represented with the correct mathematical relationship.", "The second moment definition has a major error. The natural language defines E[X\u00b2] as the sum itself, but the Lean formalization assigns it the value p/(1-p), which contradicts the conclusion that it should equal p(1+p)/(1-p)\u00b2. This creates a logical inconsistency.", "The conclusion formula is correctly stated, matching the target expression from the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The random variable definition is correctly captured with the PMF formula and parameter constraints.', 'The sum formula assumption is accurately represented with the correct mathematical relationship.', 'The second moment definition has a major error. The natural language defines E[X\u00b2] as the sum itself, but the Lean formalization assigns it the value p/(1-p), which contradicts the conclusion that it should equal p(1+p)/(1-p)\u00b2. This creates a logical inconsistency.', 'The conclusion formula is correctly stated, matching the target expression from the natural language.']"}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "Now, we can find the variance using the formula $Var(X) = E[X^2] - (E[X])^2$", "statement": "Definition:\n\u2022 The variance of $X$ is defined as $Var(X) = E[X^2] - (E[X])^2$ [def_3].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (hP : \u2200 k : \u2115, P k = (1 - p) * p^k) :\n  (\u2211' k : \u2115, (k : \u211d)^2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)^2 = p / (1 - p)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language presents a general definition of variance for any random variable X, but the Lean theorem is specifically about a geometric distribution with parameter p. The Lean version introduces many specific constraints and parameters not mentioned in the natural language definition.", "The natural language gives the abstract formula Var(X) = E[X\u00b2] - (E[X])\u00b2, but the Lean theorem provides a specific calculation for a geometric distribution resulting in p/(1-p)\u00b2. While the Lean expression (\u2211' k : \u2115, (k : \u211d)\u00b2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)\u00b2 does represent E[X\u00b2] - (E[X])\u00b2 for the specific distribution, the conclusion is a concrete value rather than the general definitional formula."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language presents a general definition of variance for any random variable X, but the Lean theorem is specifically about a geometric distribution with parameter p. The Lean version introduces many specific constraints and parameters not mentioned in the natural language definition.', \"The natural language gives the abstract formula Var(X) = E[X\u00b2] - (E[X])\u00b2, but the Lean theorem provides a specific calculation for a geometric distribution resulting in p/(1-p)\u00b2. While the Lean expression (\u2211' k : \u2115, (k : \u211d)\u00b2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)\u00b2 does represent E[X\u00b2] - (E[X])\u00b2 for the specific distribution, the conclusion is a concrete value rather than the general definitional formula.\"]"}, "type": "definition"}, "l6": {"id": "l6", "natural_language": "$Var(X) = E[X^2] - (E[X])^2 = \\frac{p(1+p)}{(1-p)^2} - \\left(\\frac{p}{1-p}\\right)^2$", "statement": "We assume:\n\u2022 $E[X] = \\frac{p}{1-p}$ [ts_1];\n\u2022 $E[X^2] = \\frac{p(1+p)}{(1-p)^2}$ [l5];\n\u2022 The variance of $X$ is defined as $Var(X) = E[X^2] - (E[X])^2$ [def_3].\nTherefore, we conclude:\n\u2022 $Var(X) = \\frac{p(1+p)}{(1-p)^2} - \\left(\\frac{p}{1-p}\\right)^2$ [l6].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (ts_1 : \u2211' k : \u2115, (k : \u211d) * ((1 - p) * p^k) = p / (1 - p))\n  (l5 : \u2211' k : \u2115, (k : \u211d)^2 * ((1 - p) * p^k) = p * (1 + p) / (1 - p)^2)\n  (def_3 : \u2200 (X : \u2115 \u2192 \u211d), \u2211' k, (X k)^2 - (\u2211' k, X k)^2 = \u2211' k, (X k)^2 - (\u2211' k, X k)^2) :\n  \u2211' k, (k : \u211d)^2 * ((1 - p) * p^k) - (\u2211' k, (k : \u211d) * ((1 - p) * p^k))^2 = \n  p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (ts_1 : \u2211' k : \u2115, (k : \u211d) * ((1 - p) * p^k) = p / (1 - p))\n  (l5 : \u2211' k : \u2115, (k : \u211d)^2 * ((1 - p) * p^k) = p * (1 + p) / (1 - p)^2)\n  (def_3 : \u2200 (X : \u2115 \u2192 \u211d), \u2211' k, (X k)^2 - (\u2211' k, X k)^2 = \u2211' k, (X k)^2 - (\u2211' k, X k)^2) :\n  \u2211' k, (k : \u211d)^2 * ((1 - p) * p^k) - (\u2211' k, (k : \u211d) * ((1 - p) * p^k))^2 = \n  p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2 := by\n  have h_main : \u2211' k : \u2115, (k : \u211d)^2 * ((1 - p) * p^k) - (\u2211' k : \u2115, (k : \u211d) * ((1 - p) * p^k))^2 = p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2 := by\n    have h1 : \u2211' k : \u2115, (k : \u211d)^2 * ((1 - p) * p^k) = p * (1 + p) / (1 - p)^2 := l5\n    have h2 : (\u2211' k : \u2115, (k : \u211d) * ((1 - p) * p^k)) = p / (1 - p) := ts_1\n    calc\n      \u2211' k : \u2115, (k : \u211d)^2 * ((1 - p) * p^k) - (\u2211' k : \u2115, (k : \u211d) * ((1 - p) * p^k))^2 = (p * (1 + p) / (1 - p)^2) - (\u2211' k : \u2115, (k : \u211d) * ((1 - p) * p^k))^2 := by rw [h1]\n      _ = (p * (1 + p) / (1 - p)^2) - (p / (1 - p))^2 := by\n        rw [h2]\n        <;>\n        simp [pow_two]\n        <;>\n        ring_nf\n        <;>\n        field_simp [sub_ne_zero.mpr (show (1 : \u211d) - p \u2260 0 by linarith)]\n        <;>\n        ring_nf\n  \n  have h_final : \u2211' k, (k : \u211d)^2 * ((1 - p) * p^k) - (\u2211' k, (k : \u211d) * ((1 - p) * p^k))^2 = p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2 := by\n    simpa using h_main\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 28, "column": 4, "endLine": 28, "endColumn": 22, "data": "type mismatch, term\n  h_main\nafter simplification has type\n  (tsum fun (k : \u2115) => \u2191k ^ 2 * ((1 - p) * p ^ k)) - (\u2211' (k : \u2115), \u2191k * ((1 - p) * p ^ k)) ^ 2 =\n    p * (1 + p) / (1 - p) ^ 2 - (p / (1 - p)) ^ 2 : Prop\nbut is expected to have type\n  (tsum fun (k : \u211d) => k ^ 2 * ((1 - p) * p ^ k)) - (\u2211' (k : \u211d), k * ((1 - p) * p ^ k)) ^ 2 =\n    p * (1 + p) / (1 - p) ^ 2 - (p / (1 - p)) ^ 2 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The expected value assumption E[X] = p/(1-p) is correctly formalized as an infinite sum over the geometric distribution.", "The second moment assumption E[X\u00b2] = p(1+p)/(1-p)\u00b2 is correctly formalized as an infinite sum.", "The variance definition is incorrectly formalized as a tautology A = A rather than actually defining variance as the difference between second moment and squared first moment.", "The conclusion about the variance calculation is correctly expressed in the goal statement.", "The additional probability constraints 0 < p < 1 are mathematically appropriate additions not mentioned in natural language but logically consistent.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The expected value assumption E[X] = p/(1-p) is correctly formalized as an infinite sum over the geometric distribution.', 'The second moment assumption E[X\u00b2] = p(1+p)/(1-p)\u00b2 is correctly formalized as an infinite sum.', 'The variance definition is incorrectly formalized as a tautology A = A rather than actually defining variance as the difference between second moment and squared first moment.', 'The conclusion about the variance calculation is correctly expressed in the goal statement.', 'The additional probability constraints 0 < p < 1 are mathematically appropriate additions not mentioned in natural language but logically consistent.']"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "= \\frac{p+p^2-p^2}{(1-p)^2} = \\frac{p}{(1-p)^2}$.", "statement": "We assume:\n\u2022 $Var(X) = \\frac{p(1+p)}{(1-p)^2} - \\left(\\frac{p}{1-p}\\right)^2$ [l6].\nTherefore, we conclude:\n\u2022 $Var(X) = \\frac{p}{(1-p)^2}$ [ts_2].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5", "def_3", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l6 : (\u2211' k : \u2115, (k : \u211d)^2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)^2 = \n        p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2) :\n  (\u2211' k : \u2115, (k : \u211d)^2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)^2 = \n  p / (1 - p)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (l6 : (\u2211' k : \u2115, (k : \u211d)^2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)^2 = \n        p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2) :\n  (\u2211' k : \u2115, (k : \u211d)^2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)^2 = \n  p / (1 - p)^2 := by\n  have h\u2081 : (1 - p : \u211d) \u2260 0 := by\n    have h\u2081\u2080 : (1 : \u211d) - p > 0 := by linarith\n    linarith\n  \n  have h\u2082 : (p / (1 - p))^2 = p^2 / (1 - p)^2 := by\n    have h\u2082\u2081 : (p / (1 - p)) ^ 2 = p ^ 2 / (1 - p) ^ 2 := by\n      calc\n        (p / (1 - p)) ^ 2 = (p / (1 - p)) * (p / (1 - p)) := by ring\n        _ = (p * p) / ((1 - p) * (1 - p)) := by\n          field_simp [h\u2081]\n          <;> ring\n        _ = p ^ 2 / (1 - p) ^ 2 := by\n          ring_nf\n          <;> field_simp [h\u2081]\n          <;> ring\n    rw [h\u2082\u2081]\n  \n  have h\u2083 : p * (1 + p) / (1 - p)^2 - (p / (1 - p))^2 = p / (1 - p)^2 := by\n    have h\u2083\u2081 : p * (1 + p) / (1 - p) ^ 2 - (p / (1 - p)) ^ 2 = p * (1 + p) / (1 - p) ^ 2 - p ^ 2 / (1 - p) ^ 2 := by\n      rw [h\u2082]\n    rw [h\u2083\u2081]\n    have h\u2083\u2082 : p * (1 + p) / (1 - p) ^ 2 - p ^ 2 / (1 - p) ^ 2 = (p * (1 + p) - p ^ 2) / (1 - p) ^ 2 := by\n      have h\u2083\u2082\u2081 : (1 - p : \u211d) \u2260 0 := h\u2081\n      have h\u2083\u2082\u2082 : (1 - p : \u211d) ^ 2 \u2260 0 := by positivity\n      field_simp [h\u2083\u2082\u2082]\n      <;> ring_nf\n      <;> field_simp [h\u2083\u2082\u2082]\n      <;> ring_nf\n    rw [h\u2083\u2082]\n    have h\u2083\u2083 : p * (1 + p) - p ^ 2 = p := by\n      ring_nf\n      <;> nlinarith\n    rw [h\u2083\u2083]\n    <;> field_simp [h\u2081]\n    <;> ring_nf\n    <;> field_simp [h\u2081]\n    <;> ring_nf\n  \n  have h\u2084 : (\u2211' k : \u2115, (k : \u211d)^2 * P k) - (\u2211' k : \u2115, (k : \u211d) * P k)^2 = p / (1 - p)^2 := by\n    rw [l6]\n    rw [h\u2083]\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption l6 correctly captures the variance formula as stated in natural language, with proper mathematical notation for expectation values", "The conclusion ts_2 accurately represents the simplified variance expression", "Additional constraints (probability bounds, geometric distribution) are mathematically consistent and provide necessary context", "The logical structure properly represents the 'assume-therefore-conclude' reasoning as a theorem with hypothesis and conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "def_4": {"id": "def_4", "natural_language": "The characteristic function is $\\phi_X(t) = E[e^{itX}] = \\sum_{k=0}^\\infty e^{itk} P(X=k)$", "statement": "Definition:\n\u2022 The characteristic function of $X$ is defined as $\\phi_X(t) = E[e^{itX}] = \\sum_{k=0}^\\infty e^{itk} P(X=k)$ [def_4].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5", "def_3", "l6", "ts_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_4 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (hP : \u2200 k : \u2115, P k = (1 - p) * p^k) :\n  \u2203 (phi : \u211d \u2192 \u2102), \u2200 t : \u211d, \n    phi t = \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization doesn't explicitly declare a random variable X, instead working directly with probability functions", "The Lean code defines existence of phi but doesn't explicitly connect it to a random variable X as stated in natural language", "The Lean constrains P to a specific geometric distribution (1-p)*p^k, while the natural language describes P(X=k) as a general probability function for any discrete random variable", "The expected value formulation E[e^{itX}] is completely missing from the Lean code", "The expected value equality \u03c6_X(t) = E[e^{itX}] is not present in the Lean formalization", "The sum formulation matches mathematically but uses different notation: Complex.exp and Complex.I instead of e and i, plus type coercions. The mathematical meaning is preserved"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization doesn't explicitly declare a random variable X, instead working directly with probability functions\", \"The Lean code defines existence of phi but doesn't explicitly connect it to a random variable X as stated in natural language\", 'The Lean constrains P to a specific geometric distribution (1-p)*p^k, while the natural language describes P(X=k) as a general probability function for any discrete random variable', 'The expected value formulation E[e^{itX}] is completely missing from the Lean code', 'The expected value equality \u03c6_X(t) = E[e^{itX}] is not present in the Lean formalization', 'The sum formulation matches mathematically but uses different notation: Complex.exp and Complex.I instead of e and i, plus type coercions. The mathematical meaning is preserved']"}, "type": "definition"}, "l7": {"id": "l7", "natural_language": "Since $0 < p < 1$ and $|e^{it}|=1$, the magnitude $|pe^{it}| = p < 1$, which guarantees convergence.", "statement": "We assume:\n\u2022 $0 < p < 1$ [tc_1].\nTherefore, we conclude:\n\u2022 For any real number $t$, $|pe^{it}| < 1$ [l7].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5", "def_3", "l6", "ts_2", "def_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (p : \u211d) (hp : 0 < p \u2227 p < 1) (t : \u211d) : \n  Complex.abs (p * Complex.exp (Complex.I * t)) < 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (p : \u211d) (hp : 0 < p \u2227 p < 1) (t : \u211d) : \n  Complex.abs (p * Complex.exp (Complex.I * t)) < 1 := by\n  have h\u2081 : Complex.abs (p : \u2102) = p := by\n    simp [Complex.abs, Complex.normSq, Real.sqrt_eq_iff_sq_eq, sq, hp.1.le, hp.1.le]\n    <;>\n    ring_nf <;>\n    norm_num <;>\n    linarith\n  \n  have h\u2082 : Complex.abs (Complex.exp (Complex.I * t)) = 1 := by\n    rw [Complex.abs_exp]\n    <;> simp [Complex.normSq, Complex.ext_iff, pow_two]\n    <;> ring_nf\n    <;> simp [Real.exp_zero]\n    <;> field_simp [Real.exp_ne_zero]\n    <;> ring_nf\n    <;> simp [Real.cos_sq_add_sin_sq]\n    <;> norm_num\n  \n  have h\u2083 : Complex.abs (p * Complex.exp (Complex.I * t)) = p := by\n    calc\n      Complex.abs (p * Complex.exp (Complex.I * t)) = Complex.abs (p : \u2102) * Complex.abs (Complex.exp (Complex.I * t)) := by\n        -- Use the multiplicative property of the absolute value for complex numbers\n        simp [Complex.abs.map_mul]\n      _ = p * Complex.abs (Complex.exp (Complex.I * t)) := by\n        -- Substitute the value of Complex.abs (p : \u2102) from h\u2081\n        rw [h\u2081]\n      _ = p * 1 := by\n        -- Substitute the value of Complex.abs (Complex.exp (Complex.I * t)) from h\u2082\n        rw [h\u2082]\n      _ = p := by\n        -- Simplify the expression\n        ring\n  \n  have h\u2084 : Complex.abs (p * Complex.exp (Complex.I * t)) < 1 := by\n    rw [h\u2083]\n    -- Since p < 1 by hypothesis, we have p < 1.\n    linarith [hp.2]\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption '0 < p < 1' is correctly formalized as '0 < p \u2227 p < 1' in the hypothesis.", "The conclusion '|pe^{it}| < 1' is accurately represented as 'Complex.abs (p * Complex.exp (Complex.I * t)) < 1'.", "The quantification 'for any real number t' is properly captured by the parameter '(t : \u211d)'.", "The overall logical structure from assumption to conclusion is correctly preserved in the theorem format."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "$\\phi_X(t) = E[e^{itX}] = \\sum_{k=0}^\\infty e^{itk} P(X=k) = (1-p) \\sum_{k=0}^\\infty (pe^{it})^k$", "statement": "We assume:\n\u2022 $X$ is a discrete random variable on $\\{0, 1, 2, ...\\}$ with PMF $P(X=k) = (1-p)p^k$ where $0 < p < 1$ [tc_1];\n\u2022 The characteristic function of $X$ is defined as $\\phi_X(t) = \\sum_{k=0}^\\infty e^{itk} P(X=k)$ [def_4].\nTherefore, we conclude:\n\u2022 $\\phi_X(t) = (1-p) \\sum_{k=0}^\\infty (pe^{it})^k$ [l8].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5", "def_3", "l6", "ts_2", "def_4", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (def_4 : \u2200 t : \u211d, \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) = \n        \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k)) :\n  \u2200 t : \u211d, \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) = \n           (1 - p) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t))^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (P : \u2115 \u2192 \u211d) \n  (tc_1 : \u2200 k : \u2115, P k = (1 - p) * p^k)\n  (def_4 : \u2200 t : \u211d, \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) = \n        \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k)) :\n  \u2200 t : \u211d, \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) = \n           (1 - p) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t))^k := by\n  intro t\n  have h_main : \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) = (1 - p) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t))^k := by\n    calc\n      \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191(P k) = \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p ^ k) := by\n        -- Substitute the expression for P(k) using tc_1\n        congr with k\n        rw [tc_1]\n        <;> simp [Complex.ext_iff, pow_mul]\n      _ = \u2211' k : \u2115, (1 - p : \u2102) * (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) := by\n        -- Factor out (1 - p) and adjust the product inside the sum\n        have h\u2081 : \u2200 k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p ^ k) = (1 - p : \u2102) * (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) := by\n          intro k\n          calc\n            Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p ^ k) = Complex.exp (Complex.I * t * \u2191k) * ((1 - p : \u211d) * (p : \u211d) ^ k : \u2102) := by\n              simp [Complex.ext_iff, pow_mul]\n              <;> norm_cast\n            _ = (1 - p : \u2102) * (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) := by\n              -- Distribute the multiplication and adjust the types\n              have h\u2082 : (Complex.exp (Complex.I * t * \u2191k) : \u2102) = Complex.exp (Complex.I * t * \u2191k) := rfl\n              have h\u2083 : ((1 - p : \u211d) : \u2102) = (1 - p : \u2102) := by simp [Complex.ext_iff]\n              have h\u2084 : ((p : \u211d) ^ k : \u2102) = (p : \u2102) ^ k := by\n                norm_cast\n                <;> simp [Complex.ext_iff, pow_mul]\n              simp_all [Complex.ext_iff, pow_mul, Complex.ext_iff, Complex.mul_re, Complex.mul_im]\n              <;> ring_nf\n              <;> simp_all [Complex.ext_iff, pow_mul]\n              <;> norm_num\n              <;> field_simp [Complex.ext_iff, pow_mul]\n              <;> ring_nf\n              <;> simp_all [Complex.ext_iff, pow_mul]\n              <;> norm_num\n              <;> linarith\n        -- Apply the transformation to the sum\n        calc\n          \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p ^ k) = \u2211' k : \u2115, (1 - p : \u2102) * (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) := by\n            exact tsum_congr h\u2081\n          _ = \u2211' k : \u2115, (1 - p : \u2102) * (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) := by rfl\n      _ = (1 - p : \u2102) * \u2211' k : \u2115, (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) := by\n        -- Factor out the constant (1 - p)\n        rw [tsum_mul_left]\n      _ = (1 - p : \u2102) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k := by\n        -- Show that exp(i t * k) * p^k = (p * exp(i t))^k\n        have h\u2082 : \u2200 k : \u2115, (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k : \u2102) = (p * Complex.exp (Complex.I * t)) ^ k := by\n          intro k\n          calc\n            (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k : \u2102) = (Complex.exp (Complex.I * t) ^ k * (p : \u2102) ^ k : \u2102) := by\n              -- Use the property exp(n * z) = (exp(z))^n\n              have h\u2083 : Complex.exp (Complex.I * t * \u2191k) = Complex.exp (Complex.I * t) ^ k := by\n                rw [\u2190 Complex.exp_nat_mul]\n                <;> ring_nf\n                <;> simp [Complex.ext_iff, pow_mul]\n              rw [h\u2083]\n              <;> ring_nf\n            _ = (p * Complex.exp (Complex.I * t)) ^ k := by\n              -- Use the property (a * b)^n = a^n * b^n\n              have h\u2084 : (Complex.exp (Complex.I * t) ^ k * (p : \u2102) ^ k : \u2102) = (p * Complex.exp (Complex.I * t)) ^ k := by\n                calc\n                  (Complex.exp (Complex.I * t) ^ k * (p : \u2102) ^ k : \u2102) = ((p : \u2102) * Complex.exp (Complex.I * t)) ^ k := by\n                    rw [mul_pow]\n                    <;> ring_nf\n                  _ = (p * Complex.exp (Complex.I * t)) ^ k := by simp [Complex.ext_iff]\n              rw [h\u2084]\n              <;> ring_nf\n        -- Apply the transformation to the sum\n        calc\n          (1 - p : \u2102) * \u2211' k : \u2115, (Complex.exp (Complex.I * t * \u2191k) * (p : \u2102) ^ k) = (1 - p : \u2102) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k := by\n            rw [tsum_congr h\u2082]\n          _ = (1 - p : \u2102) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k := by rfl\n      _ = (1 - p) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k := by\n        -- Adjust the type of (1 - p)\n        simp [Complex.ext_iff, pow_mul]\n        <;> norm_cast\n        <;> simp_all [Complex.ext_iff, pow_mul]\n        <;> ring_nf\n        <;> simp_all [Complex.ext_iff, pow_mul]\n        <;> norm_num\n        <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The variable declarations correctly capture the discrete random variable on natural numbers and the constraint 0 < p < 1. The use of \u2115 \u2192 \u211d for the PMF is appropriate.", "The PMF definition tc_1 correctly translates P(X=k) = (1-p)p^k using standard mathematical notation in Lean.", "The characteristic function definition def_4 has a major flaw: it's defined as a tautology (A = A) rather than actually defining \u03c6_X(t). It should define \u03c6_X(t) as the sum, not state that the sum equals itself.", "The main conclusion l8 correctly captures the mathematical relationship \u03c6_X(t) = (1-p)\u2211(pe^{it})^k, properly factoring out (1-p) and representing the geometric series structure."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable declarations correctly capture the discrete random variable on natural numbers and the constraint 0 < p < 1. The use of \u2115 \u2192 \u211d for the PMF is appropriate.', 'The PMF definition tc_1 correctly translates P(X=k) = (1-p)p^k using standard mathematical notation in Lean.', \"The characteristic function definition def_4 has a major flaw: it's defined as a tautology (A = A) rather than actually defining \u03c6_X(t). It should define \u03c6_X(t) as the sum, not state that the sum equals itself.\", 'The main conclusion l8 correctly captures the mathematical relationship \u03c6_X(t) = (1-p)\u2211(pe^{it})^k, properly factoring out (1-p) and representing the geometric series structure.']"}, "solved_negation": null, "type": "lemma"}, "ts_3": {"id": "ts_3", "natural_language": "= (1-p) \\frac{1}{1-pe^{it}} = \\frac{1-p}{1-pe^{it}}$.", "statement": "We assume:\n\u2022 For any real number $a$ such that $|a|<1$, the geometric series sum is $\\sum_{k=0}^\\infty a^k = \\frac{1}{1-a}$ [l1];\n\u2022 For any real number $t$, $|pe^{it}| < 1$ [l7];\n\u2022 $\\phi_X(t) = (1-p) \\sum_{k=0}^\\infty (pe^{it})^k$ [l8].\nTherefore, we conclude:\n\u2022 $\\phi_X(t) = \\frac{1-p}{1-pe^{it}}$ [ts_3].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "ts_1", "l4", "def_2", "l5", "def_3", "l6", "ts_2", "def_4", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (t : \u211d)\n  (l7 : Complex.abs (p * Complex.exp (Complex.I * t)) < 1)\n  (l8 : \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p^k) = \n        (1 - p) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t))^k) :\n  \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p^k) = \n  (1 - p) / (1 - p * Complex.exp (Complex.I * t)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3 \n  (p : \u211d) (hp_pos : 0 < p) (hp_lt_one : p < 1)\n  (t : \u211d)\n  (l7 : Complex.abs (p * Complex.exp (Complex.I * t)) < 1)\n  (l8 : \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p^k) = \n        (1 - p) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t))^k) :\n  \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p^k) = \n  (1 - p) / (1 - p * Complex.exp (Complex.I * t)) := by\n  have h1 : p * Complex.exp (Complex.I * t) \u2260 1 := by\n    intro h\n    have h\u2081 : Complex.abs (p * Complex.exp (Complex.I * t)) = 1 := by\n      rw [h]\n      simp [Complex.abs, Complex.normSq]\n      <;> ring_nf\n      <;> norm_num\n      <;> simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> norm_num\n    linarith\n  \n  have h2 : \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k = (1 - (p * Complex.exp (Complex.I * t)))\u207b\u00b9 := by\n    have h\u2082 : \u2016(p * Complex.exp (Complex.I * t) : \u2102)\u2016 < 1 := by\n      simpa [Complex.norm_eq_abs] using l7\n    -- Use the tsum_geometric_of_norm_lt_one lemma to find the sum of the geometric series.\n    have h\u2083 : \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k = (1 - (p * Complex.exp (Complex.I * t)))\u207b\u00b9 := by\n      rw [tsum_geometric_of_norm_lt_one h\u2082]\n      <;> field_simp [sub_ne_zero.mpr h1]\n      <;> ring_nf\n      <;> simp_all [Complex.ext_iff, pow_one, pow_two, pow_three]\n      <;> norm_num\n      <;> linarith\n    -- The result follows directly from the lemma.\n    exact h\u2083\n  \n  have h3 : ((1 - p : \u211d) : \u2102) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k = ((1 - p : \u211d) : \u2102) / (1 - p * Complex.exp (Complex.I * t)) := by\n    calc\n      ((1 - p : \u211d) : \u2102) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k = ((1 - p : \u211d) : \u2102) * (1 - (p * Complex.exp (Complex.I * t)))\u207b\u00b9 := by rw [h2]\n      _ = ((1 - p : \u211d) : \u2102) / (1 - p * Complex.exp (Complex.I * t)) := by\n        have h\u2083 : (1 - (p * Complex.exp (Complex.I * t)) : \u2102) \u2260 0 := by\n          intro h\u2083\n          apply h1\n          have h\u2084 : (1 : \u2102) - p * Complex.exp (Complex.I * t) = 0 := by simpa using h\u2083\n          have h\u2085 : p * Complex.exp (Complex.I * t) = 1 := by\n            rw [sub_eq_zero] at h\u2084\n            linear_combination -h\u2084\n          simpa using h\u2085\n        field_simp [h\u2083]\n        <;> ring_nf\n        <;> simp_all [Complex.ext_iff, pow_one, pow_two]\n        <;> norm_num\n        <;> linarith\n  \n  have h4 : \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p^k) = ((1 - p : \u211d) : \u2102) / (1 - p * Complex.exp (Complex.I * t)) := by\n    calc\n      \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p ^ k) = (1 - p : \u211d) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k := by\n        simpa using l8\n      _ = ((1 - p : \u211d) : \u2102) * \u2211' k : \u2115, (p * Complex.exp (Complex.I * t)) ^ k := by\n        norm_cast\n        <;>\n        simp_all [Complex.ext_iff, pow_one, mul_comm]\n        <;>\n        ring_nf at *\n        <;>\n        simp_all [Complex.ext_iff, pow_one, mul_comm]\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      _ = ((1 - p : \u211d) : \u2102) / (1 - p * Complex.exp (Complex.I * t)) := by\n        rw [h3]\n  \n  have h5 : \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p^k) = (1 - p) / (1 - p * Complex.exp (Complex.I * t)) := by\n    calc\n      \u2211' k : \u2115, Complex.exp (Complex.I * t * \u2191k) * \u2191((1 - p) * p ^ k) = ((1 - p : \u211d) : \u2102) / (1 - p * Complex.exp (Complex.I * t)) := by rw [h4]\n      _ = (1 - p : \u211d) / (1 - p * Complex.exp (Complex.I * t)) := by\n        norm_num [Complex.ext_iff, div_eq_mul_inv]\n        <;>\n        simp_all [Complex.ext_iff, pow_one, mul_comm]\n        <;>\n        ring_nf at *\n        <;>\n        simp_all [Complex.ext_iff, pow_one, mul_comm]\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      _ = (1 - p) / (1 - p * Complex.exp (Complex.I * t)) := by\n        norm_num [Complex.ext_iff, div_eq_mul_inv]\n        <;>\n        simp_all [Complex.ext_iff, pow_one, mul_comm]\n        <;>\n        ring_nf at *\n        <;>\n        simp_all [Complex.ext_iff, pow_one, mul_comm]\n        <;>\n        norm_num at *\n        <;>\n        linarith\n  \n  rw [h5]\n  <;>\n  norm_num\n  <;>\n  simp_all [Complex.ext_iff, pow_one, mul_comm]\n  <;>\n  ring_nf at *\n  <;>\n  simp_all [Complex.ext_iff, pow_one, mul_comm]\n  <;>\n  norm_num at *\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization is missing the fundamental geometric series formula (l1) that is explicitly stated in the natural language and is essential for the mathematical derivation. While the conclusion and other conditions are correctly represented, the absence of this key assumption represents a major logical gap. The natural language clearly states this formula as an assumption, but the Lean code provides no way to access or apply this crucial mathematical fact."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization is missing the fundamental geometric series formula (l1) that is explicitly stated in the natural language and is essential for the mathematical derivation. While the conclusion and other conditions are correctly represented, the absence of this key assumption represents a major logical gap. The natural language clearly states this formula as an assumption, but the Lean code provides no way to access or apply this crucial mathematical fact.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_4", "label": "def_4", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_3", "label": "ts_3", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "def_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    