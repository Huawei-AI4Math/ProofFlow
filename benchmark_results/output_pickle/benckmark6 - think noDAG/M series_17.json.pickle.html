
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \frac{1}{2}(a_{n-1}+a_{n-2})$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the inequality $1 \leq a_n \leq 2$ holds.

Proof: For $n=1$, we have $a_1=1$. The inequality is $1 \leq 1 \leq 2$, which is true. For $n=2$, we have $a_2=2$. The inequality is $1 \leq 2 \leq 2$, which is also true. Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $1 \leq a_j \leq 2$ is true. We must prove the inequality holds for $n=k+1$, i.e., $1 \leq a_{k+1} \leq 2$. From the recurrence relation, we have $a_{k+1} = \frac{1}{2}(a_k+a_{k-1})$. By the inductive hypothesis, we know that $1 \leq a_k \leq 2$ and $1 \leq a_{k-1} \leq 2$. Adding these two inequalities, we get: $1+1 \leq a_k+a_{k-1} \leq 2+2$, which simplifies to $2 \leq a_k+a_{k-1} \leq 4$. Now we divide the entire inequality by 2: $\frac{2}{2} \leq \frac{1}{2}(a_k+a_{k-1}) \leq \frac{4}{2}$, which simplifies to $1 \leq a_{k+1} \leq 2$. This matches the inequality for $n=k+1$. By the principle of **strong mathematical induction**, the inequality $1 \leq a_n \leq 2$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) :\n  \u2200 n, n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition a_1 = 1 matches exactly with h1 : a 1 = 1", "The condition a_2 = 2 matches exactly with h2 : a 2 = 2", "The recurrence relation condition matches exactly with h3, both stating the same formula for n \u2265 3", "The sequence being real-valued is captured by the type declaration (a : \u2115 \u2192 \u211d)", "The natural language conclusion states that the sequence is well-defined for all positive integers, but the Lean proposition proves a completely different statement about bounds (1 \u2264 a n \u2264 2). These are entirely different mathematical claims"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition a_1 = 1 matches exactly with h1 : a 1 = 1', 'The condition a_2 = 2 matches exactly with h2 : a 2 = 2', 'The recurrence relation condition matches exactly with h3, both stating the same formula for n \u2265 3', 'The sequence being real-valued is captured by the type declaration (a : \u2115 \u2192 \u211d)', 'The natural language conclusion states that the sequence is well-defined for all positive integers, but the Lean proposition proves a completely different statement about bounds (1 \u2264 a n \u2264 2). These are entirely different mathematical claims']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, we have $a_1=1$. The inequality is $1 \\leq 1 \\leq 2$, which is true.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1].\nTherefore, we conclude:\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) :\n  1 \u2264 a 1 \u2227 a 1 \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) :\n  1 \u2264 a 1 \u2227 a 1 \u2264 2 := by\n  have h_left : 1 \u2264 a 1 := by\n    rw [h1]\n    <;> norm_num\n  \n  have h_right : a 1 \u2264 2 := by\n    rw [h1]\n    <;> norm_num\n  \n  have h_main : 1 \u2264 a 1 \u2227 a 1 \u2264 2 := by\n    exact \u27e8h_left, h_right\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly captured. The natural language defines a sequence of real numbers with initial conditions a\u2081=1 and a\u2082=2, which is precisely represented in Lean as a function from \u2115 to \u211d with hypotheses h1 and h2 establishing these initial values.", "The recurrence relation is accurately formalized. The natural language states the relation holds for all integers n\u22653, and the Lean code uses universal quantification (\u2200 n, n \u2265 3 \u2192) with the exact same mathematical formula, just using Lean's multiplication syntax (* instead of juxtaposition).", "The conclusion is perfectly captured. The natural language states that for n=1, the inequality 1 \u2264 a\u2081 \u2264 2 holds, which is represented in Lean as the conjunction 1 \u2264 a 1 \u2227 a 1 \u2264 2. This is mathematically equivalent to the compound inequality in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we have $a_2=2$. The inequality is $1 \\leq 2 \\leq 2$, which is also true.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1];\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1].\nTherefore, we conclude:\n\u2022 For $n=2$, the inequality $1 \\leq a_2 \\leq 2$ holds true [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) \n  (tc_1 : \u2200 n, n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2)\n  (l1 : 1 \u2264 a 1 \u2227 a 1 \u2264 2) :\n  1 \u2264 a 2 \u2227 a 2 \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) \n  (tc_1 : \u2200 n, n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2)\n  (l1 : 1 \u2264 a 1 \u2227 a 1 \u2264 2) :\n  1 \u2264 a 2 \u2227 a 2 \u2264 2 := by\n  have h_main : 1 \u2264 a 2 \u2227 a 2 \u2264 2 := by\n    have h4 : (2 : \u2115) \u2265 1 := by norm_num\n    have h5 : 1 \u2264 a 2 \u2227 a 2 \u2264 2 := tc_1 2 h4\n    exact h5\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition with initial conditions a\u2081=1, a\u2082=2 and recurrence relation for n\u22653 is correctly formalized in Lean.", "The given condition l1 stating 1 \u2264 a\u2081 \u2264 2 is accurately represented as a hypothesis.", "The conclusion l2 stating 1 \u2264 a\u2082 \u2264 2 is properly formalized as the goal to prove.", "The Lean formalization includes an additional assumption tc_1 (\u2200 n, n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2) that is not mentioned in the natural language. While this doesn't contradict the natural language, it provides extra information that makes the proof structure different from what's implied in the natural language reasoning.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $1 \\leq a_j \\leq 2$ is true.", "statement": "Definition:\n\u2022 We assume for some integer $k \\geq 2$ that for all integers $j$ with $1 \\leq j \\leq k$, the inequality $1 \\leq a_j \\leq 2$ holds. This is the strong inductive hypothesis [def_1].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (hk : k \u2265 2) \n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies k as an integer, but Lean uses \u2115 (natural numbers). While \u2115 \u2286 \u2124 and the constraint k \u2265 2 ensures k is a positive integer, this is a type difference that represents the same mathematical concept but with a more restrictive type in Lean.", "The Lean formalization perfectly captures the mathematical statement about the bounds on a_j for all j in the specified range.", "The Lean theorem conclusion correctly establishes the strong inductive hypothesis by stating the same property as given in the hypothesis, which is exactly what the natural language describes as 'establishing the strong inductive hypothesis [def_1]'."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relation, we have $a_{k+1} = \\frac{1}{2}(a_k+a_{k-1})$.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1];\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1];\n\u2022 For $n=2$, the inequality $1 \\leq a_2 \\leq 2$ holds true [l2];\n\u2022 We assume for some integer $k \\geq 2$ that for all integers $j$ with $1 \\leq j \\leq k$, the inequality $1 \\leq a_j \\leq 2$ holds. This is the strong inductive hypothesis [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = \\frac{1}{2}(a_k+a_{k-1})$ [l3].", "dependencies": ["tc_1", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : (k : \u2115) + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h_recurrence : a (k + 1) = (1 / 2 : \u211d) * (a k + a (k - 1)) := by\n    have h\u2084 : a (k + 1) = (1 / 2 : \u211d) * (a ( (k + 1) - 1 ) + a ( (k + 1) - 2 )) := by\n      have h\u2085 : (k + 1 : \u2115) \u2265 3 := h_k_plus_1_ge_3\n      have h\u2086 : a (k + 1) = (1 / 2 : \u211d) * (a ((k + 1) - 1) + a ((k + 1) - 2)) := by\n        apply h3\n        <;> norm_num at h\u2085 \u22a2 <;> omega\n      exact h\u2086\n    have h\u2085 : ( (k + 1 : \u2115) - 1 : \u2115) = k := by\n      have h\u2086 : k \u2265 2 := hk\n      have h\u2087 : (k + 1 : \u2115) - 1 = k := by\n        omega\n      exact h\u2087\n    have h\u2086 : ( (k + 1 : \u2115) - 2 : \u2115) = k - 1 := by\n      have h\u2087 : k \u2265 2 := hk\n      have h\u2088 : (k + 1 : \u2115) - 2 = k - 1 := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc] at h\u2087 \u22a2\n            <;> ring_nf at *\n            <;> omega\n      exact h\u2088\n    rw [h\u2084]\n    have h\u2087 : ( (k + 1 : \u2115) - 1 : \u2115) = k := h\u2085\n    have h\u2088 : ( (k + 1 : \u2115) - 2 : \u2115) = k - 1 := h\u2086\n    simp [h\u2087, h\u2088]\n    <;> ring_nf at *\n    <;> field_simp at *\n    <;> ring_nf at *\n    <;> norm_cast at *\n    <;> simp_all [Nat.cast_add, Nat.cast_one, Nat.cast_zero, Nat.cast_mul, Nat.cast_sub]\n    <;> linarith\n  \n  have h_ak_bounds : 1 \u2264 a k \u2227 a k \u2264 2 := by\n    have h\u2081 : 1 \u2264 (k : \u2115) \u2227 (k : \u2115) \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2082 : 1 \u2264 a k \u2227 a k \u2264 2 := hbound k \u27e8by\n      -- Prove that 1 \u2264 k\n      have h\u2083 : 1 \u2264 (k : \u2115) := by\n        omega\n      exact_mod_cast h\u2083, by\n      -- Prove that k \u2264 k\n      have h\u2083 : (k : \u2115) \u2264 k := by\n        omega\n      exact_mod_cast h\u2083\u27e9\n    exact h\u2082\n  \n  have h_ak1_bounds : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2084 : k \u2265 2 := hk\n        have h\u2085 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2084\n        have h\u2086 : (k - 1 : \u2115) \u2265 1 := by\n          omega\n        exact h\u2086\n      have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n        have h\u2085 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n        have h\u2086 : (k - 1 : \u2115) \u2264 k := by\n          omega\n        exact h\u2086\n      exact \u27e8h\u2083, h\u2084\u27e9\n    have h\u2082 : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := by\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := h\u2081\n      have h\u2084 : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := hbound (k - 1) \u27e8by\n        -- Prove that 1 \u2264 (k - 1 : \u2115)\n        have h\u2085 : 1 \u2264 (k - 1 : \u2115) := h\u2081.1\n        exact_mod_cast h\u2085, by\n        -- Prove that (k - 1 : \u2115) \u2264 k\n        have h\u2085 : (k - 1 : \u2115) \u2264 k := h\u2081.2\n        exact_mod_cast h\u2085\u27e9\n      exact h\u2084\n    exact h\u2082\n  \n  have h_sum_bounds : 2 \u2264 (a k + a (k - 1)) \u2227 (a k + a (k - 1)) \u2264 4 := by\n    have h\u2081 : 1 \u2264 a k := h_ak_bounds.1\n    have h\u2082 : a k \u2264 2 := h_ak_bounds.2\n    have h\u2083 : 1 \u2264 a (k - 1) := h_ak1_bounds.1\n    have h\u2084 : a (k - 1) \u2264 2 := h_ak1_bounds.2\n    constructor\n    \u00b7 -- Prove 2 \u2264 a k + a (k - 1)\n      linarith\n    \u00b7 -- Prove a k + a (k - 1) \u2264 4\n      linarith\n  \n  have h_final : 1 \u2264 a (k + 1) \u2227 a (k + 1) \u2264 2 := by\n    have h\u2081 : a (k + 1) = (1 / 2 : \u211d) * (a k + a (k - 1)) := h_recurrence\n    have h\u2082 : 2 \u2264 (a k + a (k - 1)) := h_sum_bounds.1\n    have h\u2083 : (a k + a (k - 1)) \u2264 4 := h_sum_bounds.2\n    constructor\n    \u00b7 -- Prove 1 \u2264 a (k + 1)\n      have h\u2084 : 1 \u2264 a (k + 1) := by\n        rw [h\u2081]\n        -- Use the fact that (a k + a (k - 1)) \u2265 2 to show (1 / 2 : \u211d) * (a k + a (k - 1)) \u2265 1\n        have h\u2085 : (2 : \u211d) \u2264 (a k + a (k - 1)) := by exact_mod_cast h\u2082\n        have h\u2086 : (1 / 2 : \u211d) * (a k + a (k - 1)) \u2265 1 := by\n          linarith\n        linarith\n      exact h\u2084\n    \u00b7 -- Prove a (k + 1) \u2264 2\n      have h\u2084 : a (k + 1) \u2264 2 := by\n        rw [h\u2081]\n        -- Use the fact that (a k + a (k - 1)) \u2264 4 to show (1 / 2 : \u211d) * (a k + a (k - 1)) \u2264 2\n        have h\u2085 : (a k + a (k - 1)) \u2264 (4 : \u211d) := by exact_mod_cast h\u2083\n        have h\u2086 : (1 / 2 : \u211d) * (a k + a (k - 1)) \u2264 2 := by\n          linarith\n        linarith\n      exact h\u2084\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition with initial values and recurrence relation is correctly captured in the Lean hypotheses h1, h2, and h3.", "The base case bounds are implicitly included in the general bound condition hbound, which is logically equivalent.", "The inductive hypothesis about k\u22652 and the bounds for all j\u2264k is perfectly captured by hk and hbound.", "The conclusion is fundamentally different: the natural language concludes with the recurrence relation formula a_{k+1} = (1/2)(a_k + a_{k-1}), while Lean concludes with the bound inequality 1 \u2264 a_{k+1} \u2264 2. These represent different logical statements."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial values and recurrence relation is correctly captured in the Lean hypotheses h1, h2, and h3.', 'The base case bounds are implicitly included in the general bound condition hbound, which is logically equivalent.', 'The inductive hypothesis about k\u22652 and the bounds for all j\u2264k is perfectly captured by hk and hbound.', 'The conclusion is fundamentally different: the natural language concludes with the recurrence relation formula a_{k+1} = (1/2)(a_k + a_{k-1}), while Lean concludes with the bound inequality 1 \u2264 a_{k+1} \u2264 2. These represent different logical statements.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we know that $1 \\leq a_k \\leq 2$ and $1 \\leq a_{k-1} \\leq 2$.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1];\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1];\n\u2022 For $n=2$, the inequality $1 \\leq a_2 \\leq 2$ holds true [l2];\n\u2022 We assume for some integer $k \\geq 2$ that for all integers $j$ with $1 \\leq j \\leq k$, the inequality $1 \\leq a_j \\leq 2$ holds. This is the strong inductive hypothesis [def_1];\n\u2022 $a_{k+1} = \\frac{1}{2}(a_k+a_{k-1})$ [l3].\nTherefore, we conclude:\n\u2022 $1 \\leq a_k \\leq 2$ and $1 \\leq a_{k-1} \\leq 2$ [l4].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by\n  have h_k_plus_1_ge_3 : (k + 1 : \u2115) \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : (k : \u2115) + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h_recurrence : a (k+1) = (1/2 : \u211d) * (a k + a (k-1)) := by\n    have h4 : a (k + 1) = (1 / 2 : \u211d) * (a (k + 1 - 1) + a (k + 1 - 2)) := by\n      have h5 : (k + 1 : \u2115) \u2265 3 := h_k_plus_1_ge_3\n      have h6 : a (k + 1) = (1 / 2) * (a (k + 1 - 1) + a (k + 1 - 2)) := h3 (k + 1) (by exact_mod_cast h5)\n      exact h6\n    have h7 : (k + 1 : \u2115) - 1 = k := by\n      simp [Nat.add_sub_cancel]\n    have h8 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h9 : k \u2265 2 := hk\n      have h10 : (k : \u2115) + 1 \u2265 3 := by omega\n      have h11 : (k + 1 : \u2115) - 2 = k - 1 := by\n        cases k with\n        | zero => omega\n        | succ k' =>\n          cases k' with\n          | zero => omega\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc]\n            <;> ring_nf at *\n            <;> omega\n      exact h11\n    have h9 : a (k + 1) = (1 / 2 : \u211d) * (a k + a (k - 1)) := by\n      rw [h4]\n      have h10 : (a (k + 1 - 1) : \u211d) = a k := by\n        rw [h7]\n        <;> simp [Nat.cast_add, Nat.cast_one]\n      have h11 : (a (k + 1 - 2) : \u211d) = a (k - 1) := by\n        rw [h8]\n        <;> simp [Nat.cast_add, Nat.cast_one]\n      rw [h10, h11]\n      <;> ring_nf\n      <;> field_simp\n      <;> ring_nf\n    exact h9\n  \n  have h_a_k_bounds : 1 \u2264 a k \u2227 a k \u2264 2 := by\n    have h4 : 1 \u2264 (k : \u2115) \u2227 (k : \u2115) \u2264 k := by\n      have h5 : 1 \u2264 (k : \u2115) := by\n        omega\n      have h6 : (k : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h5, h6\u27e9\n    have h7 : 1 \u2264 a k \u2227 a k \u2264 2 := hbound k \u27e8by\n      -- Prove 1 \u2264 k\n      have h8 : 1 \u2264 (k : \u2115) := by omega\n      exact_mod_cast h8, by\n      -- Prove k \u2264 k\n      have h8 : (k : \u2115) \u2264 k := by omega\n      exact_mod_cast h8\u27e9\n    exact h7\n  \n  have h_a_k_minus_1_bounds : 1 \u2264 a (k-1) \u2227 a (k-1) \u2264 2 := by\n    have h4 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h5 : k \u2265 2 := hk\n      have h6 : 1 \u2264 (k - 1 : \u2115) := by\n        have h7 : k \u2265 2 := hk\n        have h8 : (k : \u2115) - 1 \u2265 1 := by\n          omega\n        exact by\n          omega\n      have h7 : (k - 1 : \u2115) \u2264 k := by\n        have h8 : (k : \u2115) - 1 \u2264 k := by\n          omega\n        exact h8\n      exact \u27e8h6, h7\u27e9\n    have h8 : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := hbound (k - 1) \u27e8by\n      -- Prove 1 \u2264 k - 1\n      have h9 : 1 \u2264 (k - 1 : \u2115) := h4.1\n      exact_mod_cast h9, by\n      -- Prove k - 1 \u2264 k\n      have h9 : (k - 1 : \u2115) \u2264 k := h4.2\n      exact_mod_cast h9\u27e9\n    exact h8\n  \n  have h_main : 1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by\n    have h\u2081 : a (k + 1) = (1 / 2 : \u211d) * (a k + a (k - 1)) := h_recurrence\n    rw [h\u2081]\n    have h\u2082 : 1 \u2264 a k := h_a_k_bounds.1\n    have h\u2083 : a k \u2264 2 := h_a_k_bounds.2\n    have h\u2084 : 1 \u2264 a (k - 1) := h_a_k_minus_1_bounds.1\n    have h\u2085 : a (k - 1) \u2264 2 := h_a_k_minus_1_bounds.2\n    constructor\n    \u00b7 -- Prove 1 \u2264 (1 / 2 : \u211d) * (a k + a (k - 1))\n      have h\u2086 : (1 : \u211d) \u2264 (1 / 2 : \u211d) * (a k + a (k - 1)) := by\n        -- Use the fact that a k \u2265 1 and a (k - 1) \u2265 1 to show the sum is at least 2\n        have h\u2087 : (a k + a (k - 1) : \u211d) \u2265 2 := by\n          linarith\n        -- Multiply both sides by 1/2 to get the desired inequality\n        linarith\n      exact h\u2086\n    \u00b7 -- Prove (1 / 2 : \u211d) * (a k + a (k - 1)) \u2264 2\n      have h\u2086 : (1 / 2 : \u211d) * (a k + a (k - 1)) \u2264 (2 : \u211d) := by\n        -- Use the fact that a k \u2264 2 and a (k - 1) \u2264 2 to show the sum is at most 4\n        have h\u2087 : (a k + a (k - 1) : \u211d) \u2264 4 := by\n          linarith\n        -- Multiply both sides by 1/2 to get the desired inequality\n        linarith\n      exact h\u2086\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is correctly formalized", "The base case conditions are properly captured in the hypotheses", "The inductive hypothesis is accurately represented", "The constraint k \u2265 2 is correctly included", "All premises and assumptions are faithfully translated", "The conclusion is fundamentally different: natural language concludes bounds for a_k and a_{k-1} (which follow from the inductive hypothesis), while Lean concludes bounds for a_{k+1} (which would be the inductive step). This changes the logical meaning of what is being proven."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions and recurrence relation is correctly formalized', 'The base case conditions are properly captured in the hypotheses', 'The inductive hypothesis is accurately represented', 'The constraint k \u2265 2 is correctly included', 'All premises and assumptions are faithfully translated', 'The conclusion is fundamentally different: natural language concludes bounds for a_k and a_{k-1} (which follow from the inductive hypothesis), while Lean concludes bounds for a_{k+1} (which would be the inductive step). This changes the logical meaning of what is being proven.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Adding these two inequalities, we get: $1+1 \\leq a_k+a_{k-1} \\leq 2+2$, which simplifies to $2 \\leq a_k+a_{k-1} \\leq 4$.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1];\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1];\n\u2022 For $n=2$, the inequality $1 \\leq a_2 \\leq 2$ holds true [l2];\n\u2022 We assume for some integer $k \\geq 2$ that for all integers $j$ with $1 \\leq j \\leq k$, the inequality $1 \\leq a_j \\leq 2$ holds. This is the strong inductive hypothesis [def_1];\n\u2022 $a_{k+1} = \\frac{1}{2}(a_k+a_{k-1})$ [l3];\n\u2022 $1 \\leq a_k \\leq 2$ and $1 \\leq a_{k-1} \\leq 2$ [l4].\nTherefore, we conclude:\n\u2022 $2 \\leq a_k+a_{k-1} \\leq 4$ [l5].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  2 \u2264 a k + a (k-1) \u2227 a k + a (k-1) \u2264 4 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2) :\n  2 \u2264 a k + a (k-1) \u2227 a k + a (k-1) \u2264 4 := by\n  have h_k_sub_one_bounds : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : k - 1 \u2265 1 := by\n        have h\u2084 : k \u2265 2 := hk\n        omega\n      exact h\u2083\n    have h\u2082 : (k - 1 : \u2115) \u2264 k := by\n      have h\u2083 : k - 1 \u2264 k := by\n        omega\n      exact h\u2083\n    exact \u27e8h\u2081, h\u2082\u27e9\n  \n  have h_a_k_sub_one : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := h_k_sub_one_bounds\n    have h\u2082 : 1 \u2264 (k - 1 : \u2115) := h\u2081.1\n    have h\u2083 : (k - 1 : \u2115) \u2264 k := h\u2081.2\n    have h\u2084 : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := by\n      have h\u2085 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := h\u2081\n      have h\u2086 : 1 \u2264 (k - 1 : \u2115) := h\u2085.1\n      have h\u2087 : (k - 1 : \u2115) \u2264 k := h\u2085.2\n      -- Use the given bound to get the bounds for a (k - 1)\n      have h\u2088 : 1 \u2264 a (k - 1) \u2227 a (k - 1) \u2264 2 := hbound (k - 1) \u27e8by\n        -- Prove 1 \u2264 k - 1\n        omega, by\n        -- Prove k - 1 \u2264 k\n        omega\u27e9\n      exact h\u2088\n    exact h\u2084\n  \n  have h_a_k : 1 \u2264 a k \u2227 a k \u2264 2 := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor\n      \u00b7 -- Prove 1 \u2264 k\n        omega\n      \u00b7 -- Prove k \u2264 k\n        omega\n    have h\u2082 : 1 \u2264 a k \u2227 a k \u2264 2 := hbound k \u27e8by omega, by omega\u27e9\n    exact h\u2082\n  \n  have h_sum_lower : 2 \u2264 a k + a (k - 1) := by\n    have h\u2081 : 1 \u2264 a (k - 1) := h_a_k_sub_one.1\n    have h\u2082 : 1 \u2264 a k := h_a_k.1\n    have h\u2083 : 2 \u2264 a k + a (k - 1) := by\n      linarith\n    exact h\u2083\n  \n  have h_sum_upper : a k + a (k - 1) \u2264 4 := by\n    have h\u2081 : a (k - 1) \u2264 2 := h_a_k_sub_one.2\n    have h\u2082 : a k \u2264 2 := h_a_k.2\n    have h\u2083 : a k + a (k - 1) \u2264 4 := by\n      linarith\n    exact h\u2083\n  \n  have h_final : 2 \u2264 a k + a (k-1) \u2227 a k + a (k-1) \u2264 4 := by\n    constructor\n    \u00b7 -- Prove 2 \u2264 a k + a (k - 1)\n      exact h_sum_lower\n    \u00b7 -- Prove a k + a (k - 1) \u2264 4\n      exact h_sum_upper\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical components from the natural language. The sequence definition (initial values and recurrence relation), the constraint k\u22652, the inductive hypothesis about bounds on all terms up to k, and the target conclusion about the sum a_k + a_(k-1) are all properly formalized. While the natural language includes some intermediate proof steps as separate assumptions, the Lean version appropriately treats these as logical consequences of the main hypotheses, which is mathematically sound and complete."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Now we divide the entire inequality by 2: $\\frac{2}{2} \\leq \\frac{1}{2}(a_k+a_{k-1}) \\leq \\frac{4}{2}$, which simplifies to $1 \\leq a_{k+1} \\leq 2$.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1];\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1];\n\u2022 For $n=2$, the inequality $1 \\leq a_2 \\leq 2$ holds true [l2];\n\u2022 We assume for some integer $k \\geq 2$ that for all integers $j$ with $1 \\leq j \\leq k$, the inequality $1 \\leq a_j \\leq 2$ holds. This is the strong inductive hypothesis [def_1];\n\u2022 $a_{k+1} = \\frac{1}{2}(a_k+a_{k-1})$ [l3];\n\u2022 $1 \\leq a_k \\leq 2$ and $1 \\leq a_{k-1} \\leq 2$ [l4];\n\u2022 $2 \\leq a_k+a_{k-1} \\leq 4$ [l5].\nTherefore, we conclude:\n\u2022 $1 \\leq a_{k+1} \\leq 2$ [l6].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2)\n  (l5 : 2 \u2264 a k + a (k-1) \u2227 a k + a (k-1) \u2264 4) :\n  1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 (a : \u2115 \u2192 \u211d) (k : \u2115) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2)))\n  (hk : k \u2265 2)\n  (hbound : \u2200 j, 1 \u2264 j \u2227 j \u2264 k \u2192 1 \u2264 a j \u2227 a j \u2264 2)\n  (l5 : 2 \u2264 a k + a (k-1) \u2227 a k + a (k-1) \u2264 4) :\n  1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by\n  have h_k_plus_1_ge_3 : (k + 1 : \u2115) \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : (k : \u2115) + 1 \u2265 3 := by\n      omega\n    exact h\u2082\n  \n  have h_recurrence : a (k + 1) = (1/2 : \u211d) * (a k + a (k - 1)) := by\n    have h\u2084 : a (k + 1) = (1 / 2 : \u211d) * (a (k + 1 - 1) + a (k + 1 - 2)) := by\n      have h\u2085 : (k + 1 : \u2115) \u2265 3 := h_k_plus_1_ge_3\n      have h\u2086 : a (k + 1) = (1 / 2 : \u211d) * (a (k + 1 - 1) + a (k + 1 - 2)) := by\n        apply h3\n        <;> norm_num at h\u2085 \u22a2 <;>\n          (try omega) <;>\n          (try linarith) <;>\n          (try simp_all [Nat.succ_eq_add_one, Nat.add_assoc]) <;>\n          (try ring_nf at * <;> omega)\n        <;>\n          (try omega)\n      exact h\u2086\n    have h\u2085 : (k + 1 : \u2115) - 1 = k := by\n      have h\u2086 : k \u2265 2 := hk\n      have h\u2087 : (k : \u2115) + 1 \u2265 3 := by omega\n      have h\u2088 : (k + 1 : \u2115) - 1 = k := by\n        omega\n      exact h\u2088\n    have h\u2086 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2087 : k \u2265 2 := hk\n      have h\u2088 : (k : \u2115) + 1 \u2265 3 := by omega\n      have h\u2089 : (k + 1 : \u2115) - 2 = k - 1 := by\n        omega\n      exact h\u2089\n    rw [h\u2084]\n    <;> simp [h\u2085, h\u2086]\n    <;> ring_nf\n    <;> norm_num\n    <;>\n    (try\n      {\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp_all [Nat.succ_eq_add_one, Nat.add_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> linarith\n      })\n    <;>\n    (try omega)\n  \n  have h_left : (1 : \u211d) \u2264 a (k + 1) := by\n    have h\u2086 : (2 : \u211d) \u2264 a k + a (k - 1) := l5.1\n    have h\u2087 : a (k + 1) = (1 / 2 : \u211d) * (a k + a (k - 1)) := h_recurrence\n    have h\u2088 : (1 : \u211d) \u2264 a (k + 1) := by\n      rw [h\u2087]\n      -- Use the fact that 2 \u2264 a_k + a_{k-1} to show that (1/2)(a_k + a_{k-1}) \u2265 1\n      linarith\n    exact h\u2088\n  \n  have h_right : a (k + 1) \u2264 (2 : \u211d) := by\n    have h\u2086 : a k + a (k - 1) \u2264 (4 : \u211d) := l5.2\n    have h\u2087 : a (k + 1) = (1 / 2 : \u211d) * (a k + a (k - 1)) := h_recurrence\n    have h\u2088 : a (k + 1) \u2264 (2 : \u211d) := by\n      rw [h\u2087]\n      -- Use the fact that a_k + a_{k-1} \u2264 4 to show that (1/2)(a_k + a_{k-1}) \u2264 2\n      linarith\n    exact h\u2088\n  \n  have h_main : 1 \u2264 a (k+1) \u2227 a (k+1) \u2264 2 := by\n    refine' \u27e8h_left, h_right\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical components from the natural language. While some intermediate steps (l1-l4) mentioned in the natural language are not explicitly stated as separate hypotheses in Lean, they are all logically derivable from the given hypotheses. The sequence definition, inductive hypothesis, key constraint (l5), and conclusion are all properly formalized. The logical structure and mathematical meaning are preserved completely."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of strong mathematical induction, the inequality $1 \\leq a_n \\leq 2$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The sequence of real numbers $(a_n)$ is defined by $a_1=1$, $a_2=2$ and the recurrence relation $a_n = \\frac{1}{2}(a_{n-1}+a_{n-2})$ for all integers $n \\geq 3$ [tc_1];\n\u2022 For $n=1$, the inequality $1 \\leq a_1 \\leq 2$ holds true [l1];\n\u2022 For $n=2$, the inequality $1 \\leq a_2 \\leq 2$ holds true [l2];\n\u2022 For an integer $k \\geq 2$, assuming $1 \\leq a_j \\leq 2$ for all integers $j$ such that $1 \\leq j \\leq k$, it follows that $1 \\leq a_{k+1} \\leq 2$ [l6].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $1 \\leq a_n \\leq 2$ holds [ts_1].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) :\n  \u2200 n, n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 2) \n  (h3 : \u2200 n, n \u2265 3 \u2192 a n = (1/2) * (a (n-1) + a (n-2))) :\n  \u2200 n, n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2 := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2 := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 1 \u2264 a n \u2227 a n \u2264 2 := by\n      intro n\n      induction' n using Nat.strong_induction_on with n ih\n      intro hn\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false, but Lean requires us to handle it.\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        constructor\n        \u00b7 -- Prove 1 \u2264 a 1\n          norm_num [h1]\n        \u00b7 -- Prove a 1 \u2264 2\n          norm_num [h1]\n      | 2 =>\n        -- Base case: n = 2\n        constructor\n        \u00b7 -- Prove 1 \u2264 a 2\n          norm_num [h2]\n        \u00b7 -- Prove a 2 \u2264 2\n          norm_num [h2]\n      | k + 3 =>\n        -- Inductive step: n = k + 3, where k \u2265 0\n        have h4 : (k + 3 : \u2115) \u2265 3 := by\n          omega\n        have h5 : a (k + 3) = (1 / 2 : \u211d) * (a (k + 3 - 1) + a (k + 3 - 2)) := h3 (k + 3) (by omega)\n        have h6 : a (k + 3) = (1 / 2 : \u211d) * (a (k + 2) + a (k + 1)) := by\n          rw [h5]\n          <;> simp [Nat.add_assoc]\n          <;> ring_nf at *\n          <;> norm_num\n          <;> simp_all [Nat.add_assoc]\n          <;> linarith\n        have h7 : 1 \u2264 a (k + 2) \u2227 a (k + 2) \u2264 2 := by\n          have h8 : (k + 2 : \u2115) \u2265 1 := by\n            omega\n          have h9 : 1 \u2264 a (k + 2) \u2227 a (k + 2) \u2264 2 := ih (k + 2) (by\n            omega) (by omega)\n          exact h9\n        have h8 : 1 \u2264 a (k + 1) \u2227 a (k + 1) \u2264 2 := by\n          have h9 : (k + 1 : \u2115) \u2265 1 := by\n            omega\n          have h10 : 1 \u2264 a (k + 1) \u2227 a (k + 1) \u2264 2 := ih (k + 1) (by\n            omega) (by omega)\n          exact h10\n        have h9 : 1 \u2264 a (k + 3) \u2227 a (k + 3) \u2264 2 := by\n          constructor\n          \u00b7 -- Prove 1 \u2264 a (k + 3)\n            have h10 : a (k + 3) = (1 / 2 : \u211d) * (a (k + 2) + a (k + 1)) := h6\n            rw [h10]\n            have h11 : (1 : \u211d) \u2264 a (k + 2) := h7.1\n            have h12 : (1 : \u211d) \u2264 a (k + 1) := h8.1\n            have h13 : (a (k + 2) : \u211d) + a (k + 1) \u2265 2 := by linarith\n            have h14 : (1 / 2 : \u211d) * (a (k + 2) + a (k + 1)) \u2265 1 := by\n              linarith\n            linarith\n          \u00b7 -- Prove a (k + 3) \u2264 2\n            have h10 : a (k + 3) = (1 / 2 : \u211d) * (a (k + 2) + a (k + 1)) := h6\n            rw [h10]\n            have h11 : (a (k + 2) : \u211d) \u2264 2 := h7.2\n            have h12 : (a (k + 1) : \u211d) \u2264 2 := h8.2\n            have h13 : (a (k + 2) : \u211d) + a (k + 1) \u2264 4 := by linarith\n            have h14 : (1 / 2 : \u211d) * (a (k + 2) + a (k + 1)) \u2264 2 := by\n              linarith\n            linarith\n        exact h9\n    exact h n hn\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization.", "The base cases l1 and l2 are not explicitly stated as hypotheses in Lean, but they are logically derivable from h1 and h2. Since a_1 = 1 and a_2 = 2, the inequalities 1 \u2264 a_1 \u2264 2 and 1 \u2264 a_2 \u2264 2 automatically hold.", "The inductive step l6 is described in natural language as an assumption, but in the Lean formalization it's not provided as a hypothesis. Instead, it would need to be proven as part of the theorem proof. This represents a structural difference in how the logical argument is presented.", "The conclusion perfectly matches between natural language and Lean, both stating that for all n \u2265 1, the sequence values lie between 1 and 2 inclusive."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization.', 'The base cases l1 and l2 are not explicitly stated as hypotheses in Lean, but they are logically derivable from h1 and h2. Since a_1 = 1 and a_2 = 2, the inequalities 1 \u2264 a_1 \u2264 2 and 1 \u2264 a_2 \u2264 2 automatically hold.', \"The inductive step l6 is described in natural language as an assumption, but in the Lean formalization it's not provided as a hypothesis. Instead, it would need to be proven as part of the theorem proof. This represents a structural difference in how the logical argument is presented.\", 'The conclusion perfectly matches between natural language and Lean, both stating that for all n \u2265 1, the sequence values lie between 1 and 2 inclusive.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    