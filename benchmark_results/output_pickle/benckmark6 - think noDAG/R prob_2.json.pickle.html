
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a random variable with mean $E[X] = \mu$. Let $\mathcal{G}$ be a sub-$\sigma$-algebra of the underlying $\sigma$-algebra $\mathcal{F}$. Suppose the conditional expectation of $X$ given $\mathcal{G}$ is $E[X|\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$. The moments of $Y$ are given by $E[Y] = m$ and $E[Y^2] = k$, with $m 
eq 0$. Then, the variance of the conditional expectation is $Var(E[X|\mathcal{G}]) = \mu^2 \left(\frac{k}{m^2} - 1\right)$.

Proof: First, we determine the constant $c$. Using the law of total expectation, $E[E[X|\mathcal{G}]] = E[X]$, and substituting the given expressions, we have $E[cY] = \mu$. This implies $c E[Y] = \mu$, which leads to $cm = \mu$, so we find $c = \frac{\mu}{m}$.
Next, we determine the mean of $E[X|\mathcal{G}]$. By the law of total expectation, $E[E[X|\mathcal{G}]] = E[X]$, which is given as $\mu$.
We then calculate the second moment of $E[X|\mathcal{G}]$. This is $E[(E[X|\mathcal{G}])^2] = E[(cY)^2] = c^2 E[Y^2]$. Substituting the value of $c$ we found and the given value for $E[Y^2]$, we get $(\frac{\mu}{m})^2 k = \frac{\mu^2 k}{m^2}$.
Finally, we compute the variance using the formula $Var(Z) = E[Z^2] - (E[Z])^2$. This gives $Var(E[X|\mathcal{G}]) = \frac{\mu^2 k}{m^2} - \mu^2$, which simplifies to $\mu^2 \left(\frac{k}{m^2} - 1\right)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a random variable with mean $E[X] = \\mu$. Let $\\mathcal{G}$ be a sub-$\\sigma$-algebra of the underlying $\\sigma$-algebra $\\mathcal{F}$.", "statement": "Premise:\n\u2022 $X$ is a random variable, $\\mathcal{G}$ is a sub-$\\sigma$-algebra of the underlying $\\sigma$-algebra $\\mathcal{F}$, and the mean of $X$ is $E[X] = \\mu$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes X as a random variable, but the Lean code defines 'a' as a function from natural numbers to real numbers, which is completely different from a random variable", "The natural language mentions \u03c3-algebras G and F, but the Lean code contains no mention of \u03c3-algebras or any probability-theoretic structures", "The natural language states E[X] = \u03bc (expected value equals mu), but the Lean code only states that all values of the sequence 'a' are positive, with no mention of expected values or the parameter \u03bc"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language describes X as a random variable, but the Lean code defines 'a' as a function from natural numbers to real numbers, which is completely different from a random variable\", 'The natural language mentions \u03c3-algebras G and F, but the Lean code contains no mention of \u03c3-algebras or any probability-theoretic structures', \"The natural language states E[X] = \u03bc (expected value equals mu), but the Lean code only states that all values of the sequence 'a' are positive, with no mention of expected values or the parameter \u03bc\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Suppose the conditional expectation of $X$ given $\\mathcal{G}$ is $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$.", "statement": "Premise:\n\u2022 The conditional expectation of $X$ given $\\mathcal{G}$ is $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (X Y : \u03a9 \u2192 \u211d) (G : Sub\u03c3Algebra \u211d \u03a9) \n  (\u03bc m k c : \u211d)\n  (h1 : \u222b \u03c9, X \u03c9 \u2202volume = \u03bc)\n  (h2 : \u222b \u03c9, Y \u03c9 \u2202volume = m)\n  (h3 : \u222b \u03c9, (Y \u03c9)^2 \u2202volume = k)\n  (h4 : m \u2260 0)\n  (h5 : \u2200 \u03c9, \u222b x, X x \u2202volume (\u00b7 | G) \u03c9 = c * Y \u03c9) :\n  \u222b \u03c9, (\u222b x, X x \u2202volume (\u00b7 | G) \u03c9)^2 \u2202volume - (\u222b \u03c9, \u222b x, X x \u2202volume (\u00b7 | G) \u03c9 \u2202volume)^2 = \n  \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": false, "error_msg": [{"line": 15, "column": 32, "endLine": 15, "endColumn": 34, "data": "unexpected token '|'; expected ')', ',' or ':'"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "The moments of $Y$ are given by $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$.", "statement": "Premise:\n\u2022 The moments of the random variable $Y$ are given by $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\n-- The theorem condition (what we're given as premise)\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (\u03bc c m k : \u211d) (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2)\n\n-- The main theorem statement (what we want to prove)\ntheorem tc_3 :\n  \u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states E[Y] = m, but the Lean formalization has c * m = \u03bc. This introduces additional variables c and \u03bc that are not mentioned in the natural language premise, fundamentally changing the mathematical relationship.", "The natural language states E[Y^2] = k, but the Lean formalization has c^2 * k = \u03bc^2. Again, this introduces variables c and \u03bc not present in the original statement and changes the fundamental relationship between the expected values.", "Both the natural language and Lean formalization correctly state that m \u2260 0, which matches perfectly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language states E[Y] = m, but the Lean formalization has c * m = \u03bc. This introduces additional variables c and \u03bc that are not mentioned in the natural language premise, fundamentally changing the mathematical relationship.', 'The natural language states E[Y^2] = k, but the Lean formalization has c^2 * k = \u03bc^2. Again, this introduces variables c and \u03bc not present in the original statement and changes the fundamental relationship between the expected values.', 'Both the natural language and Lean formalization correctly state that m \u2260 0, which matches perfectly.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Using the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$", "statement": "We assume:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ and $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_1].\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\nTherefore, we conclude:\n\u2022 By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : Measure \u03a9) (hP : P.IsProbabilityMeasure)\n  (X Y : \u03a9 \u2192 \u211d) \n  (G : SubsigmaAlgebra \u03a9 (MeasurableSpace \u03a9))\n  (\u03bc c m k : \u211d) (hm_ne_zero : m \u2260 0)\n  (hX_measurable : Measurable X)\n  (hY_measurable : Measurable Y)\n  (hX_integrable : \u222b \u03c9, |X \u03c9| \u2202P \u03c9 < \u221e)\n  (hY_integrable : \u222b \u03c9, |Y \u03c9| \u2202P \u03c9 < \u221e)\n  (hG_measurable : \u2200 s \u2208 G, MeasurableSet s)\n  (hX_mean : \u222b \u03c9, X \u03c9 \u2202P \u03c9 = \u03bc)\n  (hX_cond_exp : \u2200 s \u2208 G, \u222b \u03c9 in s, X \u03c9 \u2202P \u03c9 = c * \u222b \u03c9 in s, Y \u03c9 \u2202P \u03c9)\n  (hY_mean : \u222b \u03c9, Y \u03c9 \u2202P \u03c9 = m)\n  (hY_sq_mean : \u222b \u03c9, (Y \u03c9)^2 \u2202P \u03c9 = k) :\n  \u222b \u03c9, (\u222b x in G, X x \u2202P x) \u2202P \u03c9 = \u03bc := by sorry", "lean_pass": false, "error_msg": [], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] \n  (P : Measure \u03a9) (hP : P.IsProbabilityMeasure)\n  (X Y : \u03a9 \u2192 \u211d) \n  (G : SubsigmaAlgebra \u03a9 (MeasurableSpace \u03a9))\n  (\u03bc c m k : \u211d) (hm_ne_zero : m \u2260 0)\n  (hX_measurable : Measurable X)\n  (hY_measurable : Measurable Y)\n  (hX_integrable : \u222b \u03c9, |X \u03c9| \u2202P \u03c9 < \u221e)\n  (hY_integrable : \u222b \u03c9, |Y \u03c9| \u2202P \u03c9 < \u221e)\n  (hG_measurable : \u2200 s \u2208 G, MeasurableSet s)\n  (hX_mean : \u222b \u03c9, X \u03c9 \u2202P \u03c9 = \u03bc)\n  (hX_cond_exp : \u2200 s \u2208 G, \u222b \u03c9 in s, X \u03c9 \u2202P \u03c9 = c * \u222b \u03c9 in s, Y \u03c9 \u2202P \u03c9)\n  (hY_mean : \u222b \u03c9, Y \u03c9 \u2202P \u03c9 = m)\n  (hY_sq_mean : \u222b \u03c9, (Y \u03c9)^2 \u2202P \u03c9 = k) :\n  \u222b \u03c9, (\u222b x in (Set.univ : Set \u03a9), X x \u2202P x) \u2202P \u03c9 = \u03bc := by\n  have h_inner : (\u222b x in (Set.univ : Set \u03a9), X x \u2202P x) = \u03bc := by\n    have h1 : (\u222b x in (Set.univ : Set \u03a9), X x \u2202P x) = \u222b x, X x \u2202P x := by\n      simp [MeasureTheory.integral_univ]\n    rw [h1]\n    -- Use the given mean of X to conclude the proof\n    have h2 : \u222b x, X x \u2202P x = \u03bc := by\n      simpa using hX_mean\n    rw [h2]\n    <;>\n    norm_num\n  \n  have h_main : \u222b \u03c9, (\u222b x in (Set.univ : Set \u03a9), X x \u2202P x) \u2202P \u03c9 = \u03bc := by\n    calc\n      \u222b \u03c9, (\u222b x in (Set.univ : Set \u03a9), X x \u2202P x) \u2202P \u03c9 = \u222b \u03c9, \u03bc \u2202P \u03c9 := by\n        -- Substitute the value of the inner integral from h_inner\n        congr\n        ext \u03c9\n        rw [h_inner]\n      _ = \u03bc := by\n        -- Since P is a probability measure, the integral of \u03bc over the entire space is \u03bc\n        have h\u2081 : \u222b \u03c9, \u03bc \u2202P \u03c9 = \u03bc := by\n          -- Use the fact that P is a probability measure to simplify the integral\n          have h\u2082 : \u222b \u03c9, \u03bc \u2202P \u03c9 = \u03bc * \u222b \u03c9, (1 : \u211d) \u2202P \u03c9 := by\n            simp [integral_const_mul]\n          rw [h\u2082]\n          have h\u2083 : \u222b \u03c9, (1 : \u211d) \u2202P \u03c9 = 1 := by\n            -- The integral of 1 over the entire space is the measure of the space, which is 1 for a probability measure\n            have h\u2084 : \u222b \u03c9, (1 : \u211d) \u2202P \u03c9 = P (Set.univ : Set \u03a9) := by\n              simp [MeasureTheory.integral_const]\n            rw [h\u2084]\n            have h\u2085 : P (Set.univ : Set \u03a9) = 1 := by\n              -- The measure of the entire space is 1 for a probability measure\n              have h\u2086 : P (Set.univ : Set \u03a9) = 1 := by\n                exact hP.1\n              exact h\u2086\n            rw [h\u2085]\n          rw [h\u2083]\n          <;> ring\n          <;> simp_all\n        rw [h\u2081]\n  \n  apply h_main", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "and substituting the given expressions, we have $E[cY] = \\mu$.", "statement": "We assume:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ and $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_1].\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\n\u2022 By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\nTherefore, we conclude:\n\u2022 $E[cY] = \\mu$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c * m = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c * m = \u03bc := by\n  have h_main : c * m = \u03bc := by\n    -- The hypothesis hcond_exp directly gives us the required equality.\n    exact hcond_exp\n  \n  -- The main statement is already proven, so we can directly use it.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the key mathematical relationship c * m = \u03bc that emerges from the natural language description, but it does so by assuming this relationship as a hypothesis rather than deriving it from the probabilistic setup described in the natural language. The natural language describes a derivation using conditional expectation, law of total expectation, and linearity of expectation, while the Lean code directly assumes the final result. The mathematical content is correct but the logical structure differs - the natural language shows a derivation while the Lean code shows a tautology."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization captures the key mathematical relationship c * m = \u03bc that emerges from the natural language description, but it does so by assuming this relationship as a hypothesis rather than deriving it from the probabilistic setup described in the natural language. The natural language describes a derivation using conditional expectation, law of total expectation, and linearity of expectation, while the Lean code directly assumes the final result. The mathematical content is correct but the logical structure differs - the natural language shows a derivation while the Lean code shows a tautology.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "This implies $c E[Y] = \\mu$", "statement": "We assume:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ and $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_1].\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\n\u2022 By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\n\u2022 $E[cY] = \\mu$ [l2].\nTherefore, we conclude:\n\u2022 $c E[Y] = \\mu$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c * m = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c * m = \u03bc := by\n  have h_main : c * m = \u03bc := by\n    exact hcond_exp\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization misses all key logical components from the natural language. It omits the random variables X and Y, the sub-\u03c3-algebra G, conditional expectations, the law of total expectation, and the entire probabilistic derivation. Instead, it reduces the problem to a trivial tautology where the conclusion c * m = \u03bc is given as a hypothesis. The formalization captures none of the mathematical reasoning described in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization misses all key logical components from the natural language. It omits the random variables X and Y, the sub-\u03c3-algebra G, conditional expectations, the law of total expectation, and the entire probabilistic derivation. Instead, it reduces the problem to a trivial tautology where the conclusion c * m = \u03bc is given as a hypothesis. The formalization captures none of the mathematical reasoning described in the natural language.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "which leads to $cm = \\mu$", "statement": "We assume:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ and $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_1].\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\n\u2022 By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\n\u2022 $E[cY] = \\mu$ [l2].\n\u2022 $c E[Y] = \\mu$ [l3].\nTherefore, we conclude:\n\u2022 $cm = \\mu$ [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c * m = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c * m = \u03bc := by\n  have h_main : c * m = \u03bc := by\n    exact hcond_exp\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has major inconsistencies with the natural language. It completely omits the probabilistic framework (random variables, \u03c3-algebras, conditional expectations) that forms the core of the mathematical setup. Most critically, it presents a circular tautology where c*m = \u03bc is both assumed and proven, rather than capturing the meaningful derivation shown in the natural language that uses the law of total expectation and linearity of expectation to establish this relationship. The formalization fails to represent the logical flow and mathematical reasoning that constitutes the essence of the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization has major inconsistencies with the natural language. It completely omits the probabilistic framework (random variables, \u03c3-algebras, conditional expectations) that forms the core of the mathematical setup. Most critically, it presents a circular tautology where c*m = \u03bc is both assumed and proven, rather than capturing the meaningful derivation shown in the natural language that uses the law of total expectation and linearity of expectation to establish this relationship. The formalization fails to represent the logical flow and mathematical reasoning that constitutes the essence of the original statement.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "so we find $c = \\frac{\\mu}{m}$.", "statement": "We assume:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ and $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_1].\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\n\u2022 By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\n\u2022 $E[cY] = \\mu$ [l2].\n\u2022 $c E[Y] = \\mu$ [l3].\n\u2022 $cm = \\mu$ [l4].\nTherefore, we conclude:\n\u2022 $c = \\frac{\\mu}{m}$ [l5].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c = \u03bc / m := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c = \u03bc / m := by\n  have h_div : c = \u03bc / m := by\n    have h\u2081 : c * m = \u03bc := hcond_exp\n    have h\u2082 : c = \u03bc / m := by\n      -- Divide both sides by m to solve for c\n      have h\u2083 : c = \u03bc / m := by\n        -- Use field_simp to simplify the division\n        field_simp [hm_ne_zero] at h\u2081 \u22a2\n        -- Use linear arithmetic to confirm the equality\n        <;> nlinarith\n      exact h\u2083\n    exact h\u2082\n  \n  exact h_div", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the final mathematical relationship c = \u03bc/m and the essential constraint m \u2260 0, but it completely abstracts away the probabilistic context that motivates this relationship. The natural language describes a rich setup involving random variables, conditional expectations, and the law of total expectation, while the Lean code treats this as a simple algebraic identity. The mathematical core is preserved, but the probabilistic foundation and derivation steps are missing, making this a structural simplification rather than a complete formalization."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the final mathematical relationship c = \u03bc/m and the essential constraint m \u2260 0, but it completely abstracts away the probabilistic context that motivates this relationship. The natural language describes a rich setup involving random variables, conditional expectations, and the law of total expectation, while the Lean code treats this as a simple algebraic identity. The mathematical core is preserved, but the probabilistic foundation and derivation steps are missing, making this a structural simplification rather than a complete formalization.']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$, which is given as $\\mu$.", "statement": "We assume:\n\u2022 $X$ is a random variable with mean $E[X] = \\mu$ and $\\mathcal{G}$ is a sub-$\\sigma$-algebra [tc_1].\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\n\u2022 By the law of total expectation, $E[E[X|\\mathcal{G}]] = E[X]$ [l1].\n\u2022 $c = \\mu/m$ [l5].\nTherefore, we conclude:\n\u2022 The mean of the conditional expectation is $E[E[X|\\mathcal{G}]] = \\mu$ [l6].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  c * m = \u03bc := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  c * m = \u03bc := by\n  have h_main : c * m = \u03bc := by\n    -- Directly use the given hypothesis hcond_exp to prove the goal.\n    exact hcond_exp\n  \n  -- The final result follows directly from the established fact h_main.\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization completely removes the probabilistic structure (random variables, \u03c3-algebras, conditional expectations) and reduces everything to real number arithmetic, fundamentally changing the mathematical context", "The law of total expectation E[E[X|G]] = E[X], which is central to the natural language argument, is completely absent from the Lean formalization", "The relationship c = \u03bc/m is captured equivalently as c * m = \u03bc, but the derivation context from total expectation is lost", "The conclusion about the mean of conditional expectation E[E[X|G]] = \u03bc is reduced to a trivial arithmetic identity c * m = \u03bc, losing all probabilistic meaning", "The Lean code introduces an additional assumption about c\u00b2 * k = \u03bc\u00b2 that is not mentioned in the natural language description"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely removes the probabilistic structure (random variables, \u03c3-algebras, conditional expectations) and reduces everything to real number arithmetic, fundamentally changing the mathematical context', 'The law of total expectation E[E[X|G]] = E[X], which is central to the natural language argument, is completely absent from the Lean formalization', 'The relationship c = \u03bc/m is captured equivalently as c * m = \u03bc, but the derivation context from total expectation is lost', 'The conclusion about the mean of conditional expectation E[E[X|G]] = \u03bc is reduced to a trivial arithmetic identity c * m = \u03bc, losing all probabilistic meaning', 'The Lean code introduces an additional assumption about c\u00b2 * k = \u03bc\u00b2 that is not mentioned in the natural language description']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "This is $E[(E[X|\\mathcal{G}])^2] = E[(cY)^2] = c^2 E[Y^2]$.", "statement": "We assume:\n\u2022 $E[X|\\mathcal{G}] = cY$ for a constant $c$ and a random variable $Y$ [tc_2].\n\u2022 ... (all previous steps)\nTherefore, we conclude:\n\u2022 The second moment of the conditional expectation is $E[(E[X|\\mathcal{G}])^2] = c^2 E[Y^2]$ [l7].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c^2 * k = \u03bc^2 * (k / m^2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc) :\n  c^2 * k = \u03bc^2 * (k / m^2) := by\n  have h1 : \u03bc^2 * (k / m^2) = (c * m)^2 * (k / m^2) := by\n    have h1\u2081 : \u03bc = c * m := by\n      linarith\n    rw [h1\u2081]\n    <;> ring_nf\n  \n  have h2 : (c * m)^2 * (k / m^2) = c^2 * m^2 * (k / m^2) := by\n    ring_nf at *\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try ring_nf) <;>\n    (try field_simp [hm_ne_zero]) <;>\n    (try nlinarith)\n    <;>\n    linarith\n  \n  have h3 : c^2 * m^2 * (k / m^2) = c^2 * k := by\n    have h3\u2081 : m \u2260 0 := hm_ne_zero\n    have h3\u2082 : m ^ 2 \u2260 0 := by\n      exact pow_ne_zero 2 h3\u2081\n    have h3\u2083 : c ^ 2 * m ^ 2 * (k / m ^ 2) = c ^ 2 * k := by\n      calc\n        c ^ 2 * m ^ 2 * (k / m ^ 2) = c ^ 2 * (m ^ 2 * (k / m ^ 2)) := by ring\n        _ = c ^ 2 * k := by\n          have h3\u2084 : m ^ 2 * (k / m ^ 2) = k := by\n            field_simp [h3\u2082]\n            <;> ring\n          rw [h3\u2084]\n          <;> ring\n    exact h3\u2083\n  \n  have h4 : \u03bc^2 * (k / m^2) = c^2 * k := by\n    calc\n      \u03bc ^ 2 * (k / m ^ 2) = (c * m) ^ 2 * (k / m ^ 2) := by rw [h1]\n      _ = c ^ 2 * m ^ 2 * (k / m ^ 2) := by rw [h2]\n      _ = c ^ 2 * k := by rw [h3]\n  \n  have h5 : c^2 * k = \u03bc^2 * (k / m^2) := by\n    linarith\n  \n  exact h5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization completely abandons the probabilistic framework that is essential to the natural language statement. The natural language discusses conditional expectations, random variables, and second moments in probability theory, while the Lean code presents a purely algebraic equation with real numbers. Key mathematical objects like random variables X and Y, the sigma-algebra G, conditional expectation E[X|G], and the second moment E[(E[X|G])^2] are entirely missing from the formalization. The algebraic equation c^2 * k = \u03bc^2 * (k / m^2) does not recognizably correspond to the probabilistic statement E[(E[X|G])^2] = c^2 E[Y^2]."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely abandons the probabilistic framework that is essential to the natural language statement. The natural language discusses conditional expectations, random variables, and second moments in probability theory, while the Lean code presents a purely algebraic equation with real numbers. Key mathematical objects like random variables X and Y, the sigma-algebra G, conditional expectation E[X|G], and the second moment E[(E[X|G])^2] are entirely missing from the formalization. The algebraic equation c^2 * k = \u03bc^2 * (k / m^2) does not recognizably correspond to the probabilistic statement E[(E[X|G])^2] = c^2 E[Y^2].']"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Substituting the value of $c$ we found and the given value for $E[Y^2]$, we get $(\\frac{\\mu}{m})^2 k = \\frac{\\mu^2 k}{m^2}$.", "statement": "We assume:\n\u2022 The moments of $Y$ are $E[Y] = m$ and $E[Y^2] = k$, with $m \\neq 0$ [tc_3].\n\u2022 $c = \\frac{\\mu}{m}$ [l5].\n\u2022 $E[(E[X|\\mathcal{G}])^2] = c^2 E[Y^2]$ [l7].\n\u2022 ... (all previous steps)\nTherefore, we conclude:\n\u2022 $E[(E[X|\\mathcal{G}])^2] = \\frac{\\mu^2 k}{m^2}$ [l8].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  \u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  \u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2 - 1) := by\n  have h_main : \u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2 - 1) := by\n    rfl\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has major logical inconsistencies with the natural language. The condition 'c^2 * k = \u03bc^2' incorrectly treats what should be the conclusion as a premise. The theorem statement is a meaningless tautology '\u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2 - 1)' rather than proving the intended conclusion E[(E[X|\ud835\udca2])\u00b2] = \u03bc\u00b2k/m\u00b2. The formalization also fails to properly represent the conditional expectations and moments from the natural language description."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has major logical inconsistencies with the natural language. The condition 'c^2 * k = \u03bc^2' incorrectly treats what should be the conclusion as a premise. The theorem statement is a meaningless tautology '\u03bc^2 * (k / m^2 - 1) = \u03bc^2 * (k / m^2 - 1)' rather than proving the intended conclusion E[(E[X|\ud835\udca2])\u00b2] = \u03bc\u00b2k/m\u00b2. The formalization also fails to properly represent the conditional expectations and moments from the natural language description.\"]"}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "Finally, we compute the variance using the formula $Var(Z) = E[Z^2] - (E[Z])^2$. This gives $Var(E[X|\\mathcal{G}]) = \\frac{\\mu^2 k}{m^2} - \\mu^2$", "statement": "We assume:\n\u2022 The mean of the conditional expectation is $E[E[X|\\mathcal{G}]] = \\mu$ [l6].\n\u2022 The second moment of the conditional expectation is $E[(E[X|\\mathcal{G}])^2] = \\frac{\\mu^2 k}{m^2}$ [l8].\n\u2022 ... (all previous steps)\nTherefore, we conclude:\n\u2022 $Var(E[X|\\mathcal{G}]) = \\frac{\\mu^2 k}{m^2} - \\mu^2$ [l9].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  c^2 * k - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  c^2 * k - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n  have h_c : c = \u03bc / m := by\n    have h1 : c * m = \u03bc := hcond_exp\n    have h2 : c = \u03bc / m := by\n      have h3 : m \u2260 0 := hm_ne_zero\n      field_simp [h3] at h1 \u22a2\n      <;> nlinarith\n    exact h2\n  \n  have h_mu_sq_k : \u03bc^2 * k = \u03bc^2 * m^2 := by\n    have h\u2081 : c = \u03bc / m := h_c\n    have h\u2082 : c ^ 2 * k = \u03bc ^ 2 := hcond_exp_sq\n    have h\u2083 : m \u2260 0 := hm_ne_zero\n    have h\u2084 : (\u03bc / m : \u211d) ^ 2 * k = \u03bc ^ 2 := by\n      calc\n        (\u03bc / m : \u211d) ^ 2 * k = (c : \u211d) ^ 2 * k := by\n          rw [h\u2081]\n          <;> field_simp [h\u2083]\n          <;> ring_nf\n        _ = \u03bc ^ 2 := by rw [h\u2082]\n    have h\u2085 : (\u03bc / m : \u211d) ^ 2 * k = (\u03bc ^ 2 / m ^ 2 : \u211d) * k := by\n      ring_nf\n      <;> field_simp [h\u2083]\n      <;> ring_nf\n    have h\u2086 : (\u03bc ^ 2 / m ^ 2 : \u211d) * k = \u03bc ^ 2 := by\n      linarith\n    have h\u2087 : \u03bc ^ 2 * k = \u03bc ^ 2 * m ^ 2 := by\n      have h\u2088 : (\u03bc ^ 2 / m ^ 2 : \u211d) * k = \u03bc ^ 2 := h\u2086\n      have h\u2089 : (\u03bc ^ 2 / m ^ 2 : \u211d) * k * m ^ 2 = \u03bc ^ 2 * m ^ 2 := by\n        calc\n          (\u03bc ^ 2 / m ^ 2 : \u211d) * k * m ^ 2 = ((\u03bc ^ 2 / m ^ 2 : \u211d) * k) * m ^ 2 := by ring\n          _ = (\u03bc ^ 2 : \u211d) * m ^ 2 := by\n            rw [h\u2088]\n            <;> ring\n      have h\u2081\u2080 : (\u03bc ^ 2 / m ^ 2 : \u211d) * k * m ^ 2 = \u03bc ^ 2 * k := by\n        calc\n          (\u03bc ^ 2 / m ^ 2 : \u211d) * k * m ^ 2 = (\u03bc ^ 2 / m ^ 2 : \u211d) * (k * m ^ 2) := by ring\n          _ = (\u03bc ^ 2 / m ^ 2 : \u211d) * (m ^ 2 * k) := by ring\n          _ = (\u03bc ^ 2 / m ^ 2 : \u211d) * m ^ 2 * k := by ring\n          _ = \u03bc ^ 2 * k := by\n            field_simp [h\u2083]\n            <;> ring_nf\n      linarith\n    exact h\u2087\n  \n  have h_main : \u03bc^2 * (k / m^2 - 1) = 0 := by\n    have h\u2081 : \u03bc ^ 2 * k = \u03bc ^ 2 * m ^ 2 := h_mu_sq_k\n    have h\u2082 : m \u2260 0 := hm_ne_zero\n    have h\u2083 : \u03bc ^ 2 * (k / m ^ 2 - 1) = (\u03bc ^ 2 * k) / m ^ 2 - \u03bc ^ 2 := by\n      calc\n        \u03bc ^ 2 * (k / m ^ 2 - 1) = \u03bc ^ 2 * (k / m ^ 2) - \u03bc ^ 2 * 1 := by ring\n        _ = (\u03bc ^ 2 * k) / m ^ 2 - \u03bc ^ 2 := by\n          field_simp [h\u2082]\n          <;> ring_nf\n          <;> field_simp [h\u2082]\n          <;> ring_nf\n        _ = (\u03bc ^ 2 * k) / m ^ 2 - \u03bc ^ 2 := by ring\n    rw [h\u2083]\n    have h\u2084 : (\u03bc ^ 2 * k) / m ^ 2 = (\u03bc ^ 2 * m ^ 2) / m ^ 2 := by\n      rw [h\u2081]\n    rw [h\u2084]\n    have h\u2085 : (\u03bc ^ 2 * m ^ 2 : \u211d) / m ^ 2 = \u03bc ^ 2 := by\n      have h\u2085\u2081 : m \u2260 0 := hm_ne_zero\n      field_simp [h\u2085\u2081]\n      <;> ring_nf\n      <;> field_simp [h\u2085\u2081]\n      <;> ring_nf\n    rw [h\u2085]\n    <;> ring_nf\n    <;> linarith\n  \n  have h_final : c^2 * k - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n    have h\u2081 : c ^ 2 * k - \u03bc ^ 2 = 0 := by\n      have h\u2082 : c ^ 2 * k = \u03bc ^ 2 := hcond_exp_sq\n      linarith\n    have h\u2082 : \u03bc ^ 2 * (k / m ^ 2 - 1) = 0 := h_main\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the mathematical relationships and variance calculation, but abstracts the conditional expectation E[X|\ud835\udca2] to a variable 'c' that is not explicitly mentioned in the natural language. The mathematical structure and conclusion are preserved and equivalent, but the notation differs from the natural language presentation. The relationships c*m = \u03bc and c\u00b2*k = \u03bc\u00b2 effectively encode the given conditions about conditional expectations, and the final equation is mathematically equivalent to the stated variance formula."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the mathematical relationships and variance calculation, but abstracts the conditional expectation E[X|\ud835\udca2] to a variable 'c' that is not explicitly mentioned in the natural language. The mathematical structure and conclusion are preserved and equivalent, but the notation differs from the natural language presentation. The relationships c*m = \u03bc and c\u00b2*k = \u03bc\u00b2 effectively encode the given conditions about conditional expectations, and the final equation is mathematically equivalent to the stated variance formula.\"]"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "which simplifies to $\\mu^2 \\left(\\frac{k}{m^2} - 1\\right)$.", "statement": "We assume:\n\u2022 $Var(E[X|\\mathcal{G}]) = \\frac{\\mu^2 k}{m^2} - \\mu^2$ [l9].\n\u2022 ... (all previous steps)\nTherefore, we conclude:\n\u2022 $Var(E[X|\\mathcal{G}]) = \\mu^2 \\left(\\frac{k}{m^2} - 1\\right)$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  c^2 * k - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (\u03bc c m k : \u211d) \n  (hm_ne_zero : m \u2260 0)\n  (hcond_exp : c * m = \u03bc)\n  (hcond_exp_sq : c^2 * k = \u03bc^2) :\n  c^2 * k - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n  have h_c_sq_m_sq : c^2 * m^2 = \u03bc^2 := by\n    have h1 : c * m = \u03bc := hcond_exp\n    calc\n      c ^ 2 * m ^ 2 = (c * m) ^ 2 := by ring\n      _ = \u03bc ^ 2 := by rw [h1]\n  \n  have h_mu_sq_k : \u03bc^2 * k = \u03bc^2 * m^2 := by\n    have h1 : c^2 * k = \u03bc^2 := hcond_exp_sq\n    have h2 : c^2 * m^2 = \u03bc^2 := h_c_sq_m_sq\n    calc\n      \u03bc^2 * k = (c^2 * m^2) * k := by rw [h2]\n      _ = c^2 * (m^2 * k) := by ring\n      _ = c^2 * (k * m^2) := by ring\n      _ = (c^2 * k) * m^2 := by ring\n      _ = \u03bc^2 * m^2 := by rw [h1]\n  \n  have h_main : \u03bc^2 * (k - m^2) = 0 := by\n    have h1 : \u03bc^2 * k = \u03bc^2 * m^2 := h_mu_sq_k\n    have h2 : \u03bc^2 * (k - m^2) = 0 := by\n      calc\n        \u03bc^2 * (k - m^2) = \u03bc^2 * k - \u03bc^2 * m^2 := by ring\n        _ = \u03bc^2 * m^2 - \u03bc^2 * m^2 := by rw [h1]\n        _ = 0 := by ring\n    exact h2\n  \n  have h_final : c^2 * k - \u03bc^2 = \u03bc^2 * (k / m^2 - 1) := by\n    have h\u2081 : c^2 * k - \u03bc^2 = 0 := by\n      have h\u2082 : c^2 * k = \u03bc^2 := hcond_exp_sq\n      linarith\n    have h\u2082 : \u03bc^2 * (k / m^2 - 1) = 0 := by\n      by_cases h\u03bc : \u03bc = 0\n      \u00b7 -- Case: \u03bc = 0\n        have h\u2083 : \u03bc^2 = 0 := by\n          rw [h\u03bc]\n          <;> ring\n        have h\u2084 : \u03bc^2 * (k / m^2 - 1) = 0 := by\n          rw [h\u2083]\n          <;> ring\n        exact h\u2084\n      \u00b7 -- Case: \u03bc \u2260 0\n        have h\u2083 : k = m^2 := by\n          have h\u2084 : \u03bc^2 * (k - m^2) = 0 := h_main\n          have h\u2085 : \u03bc^2 \u2260 0 := by\n            exact pow_ne_zero 2 h\u03bc\n          have h\u2086 : k - m^2 = 0 := by\n            apply mul_left_cancel\u2080 h\u2085\n            linarith\n          linarith\n        have h\u2084 : \u03bc^2 * (k / m^2 - 1) = 0 := by\n          rw [h\u2083]\n          field_simp [hm_ne_zero, pow_ne_zero]\n          <;> ring_nf\n          <;> nlinarith [sq_pos_of_ne_zero hm_ne_zero]\n        exact h\u2084\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has a major logical inconsistency. The natural language shows that Var(E[X|G]) equals both expressions, but the Lean code uses constraints that make c^2 * k = \u03bc^2, which would make the left side of the equation c^2 * k - \u03bc^2 = 0. This doesn't capture the intended mathematical relationship where we start with Var(E[X|G]) = \u03bc^2 k/m^2 - \u03bc^2 and factor it to \u03bc^2(k/m^2 - 1). The constraint c^2 * k = \u03bc^2 contradicts the assumption that the variance equals \u03bc^2 k/m^2 - \u03bc^2, since this would imply the variance is zero."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has a major logical inconsistency. The natural language shows that Var(E[X|G]) equals both expressions, but the Lean code uses constraints that make c^2 * k = \u03bc^2, which would make the left side of the equation c^2 * k - \u03bc^2 = 0. This doesn't capture the intended mathematical relationship where we start with Var(E[X|G]) = \u03bc^2 k/m^2 - \u03bc^2 and factor it to \u03bc^2(k/m^2 - 1). The constraint c^2 * k = \u03bc^2 contradicts the assumption that the variance equals \u03bc^2 k/m^2 - \u03bc^2, since this would imply the variance is zero.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    