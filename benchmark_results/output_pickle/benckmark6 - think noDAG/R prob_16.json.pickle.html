
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ and $Y$ be two independent random variables. Suppose $X$ follows a Uniform distribution on the interval $(0, 1)$, and $Y$ is a discrete random variable with probability mass function $P(Y=1) = p$ and $P(Y=-1) = 1-p$ for some $p \in (0,1)$. Let the random variable $Z$ be defined as $Z = X+Y$. Then we have the following conclusions:
1. The expectation of $Z$ is $E[Z] = 2p - \frac{1}{2}$.
2. The conditional expectation of $Z$ given $Y$ is $E[Z|Y] = Y + \frac{1}{2}$.
3. The variance of the conditional expectation is $Var(E[Z|Y]) = Var(Y)$.

Proof: First, we compute the individual expectations of $X$ and $Y$. The expectation of a Uniform(0,1) random variable is $E[X] = \frac{1}{2}$. The expectation of the discrete random variable $Y$ is $E[Y] = (1)(p) + (-1)(1-p) = 2p-1$. From the definition $Z = X+Y$ and the linearity of expectation, it follows that $E[Z] = E[X] + E[Y]$. Substituting the computed expectations gives $E[Z] = \frac{1}{2} + 2p - 1 = 2p - \frac{1}{2}$, which proves the first conclusion.

Next, we determine the conditional expectation. From $Z = X+Y$ and the linearity of conditional expectation, we have $E[Z|Y] = E[X|Y] + E[Y|Y]$. Due to the independence of $X$ and $Y$, we know that $E[X|Y] = E[X]$, and it is a fundamental property that $E[Y|Y] = Y$. Substituting these properties into our expression for the conditional expectation, we get $E[Z|Y] = E[X] + Y$. Using our previously calculated value for $E[X]$, we arrive at the second conclusion: $E[Z|Y] = Y + \frac{1}{2}$.

Finally, we compute the variance of this conditional expectation. From our result for the second conclusion, it follows that $Var(E[Z|Y]) = Var(Y + \frac{1}{2})$. A key property of variance is that adding a constant to a random variable does not change its variance, which means $Var(Y + \frac{1}{2}) = Var(Y)$. By combining these last two steps, we establish the third conclusion: $Var(E[Z|Y]) = Var(Y)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ and $Y$ be two independent random variables.", "statement": "Premise:\n\u2022 X and Y are independent random variables [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y : \u03a9 \u2192 \u211d)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the independence of random variables X and Y. While the natural language simply states they are 'independent random variables', the Lean code provides the precise measure-theoretic definition of independence through the condition h_indep. The additional technical details (measure space, measurability, etc.) are necessary mathematical infrastructure that don't contradict the natural language statement but rather formalize it properly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Suppose $X$ follows a Uniform distribution on the interval $(0, 1)$", "statement": "Premise:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y : \u03a9 \u2192 \u211d)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))\n  (h_uniform : \u2200 a b : \u211d, 0 \u2264 a \u2192 a < b \u2192 b \u2264 1 \u2192 \n    \u03bc (X \u207b\u00b9' Set.Ioo a b) = (b - a : ENNReal)) :=\nby sorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 29, "endLine": 11, "endColumn": 34, "data": "type mismatch\n  b - a\nhas type\n  \u211d : outParam Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 11, "column": 47, "endLine": 11, "endColumn": 49, "data": "unexpected token ':='; expected command"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Y is a discrete random variable with probability mass function $P(Y=1) = p$ and $P(Y=-1) = 1-p$ for some $p \\in (0,1)$.", "statement": "Premise:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem condition\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y : \u03a9 \u2192 \u211d)\n  (p : \u211d)\n  (h_p : 0 < p \u2227 p < 1)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))\n  (h_X_uniform : \u2200 s : Set \u211d, \u03bc (X \u207b\u00b9' s) = MeasureTheory.volume (s \u2229 Set.Ioo 0 1))\n  (h_Y_discrete : \u03bc (Y \u207b\u00b9' {1}) = p \u2227 \u03bc (Y \u207b\u00b9' {-1}) = 1 - p) :\n  let Z := fun \u03c9 => X \u03c9 + Y \u03c9\n  -- Setup for the problem with independent random variables X and Y\n  True := by sorry", "lean_pass": false, "error_msg": [{"line": 14, "column": 34, "endLine": 14, "endColumn": 35, "data": "type mismatch\n  p\nhas type\n  \u211d : Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 14, "column": 55, "endLine": 14, "endColumn": 60, "data": "failed to synthesize\n  HSub \u2115 \u211d ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "Let the random variable $Z$ be defined as $Z = X+Y$.", "statement": "Premise:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_4\n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y : \u03a9 \u2192 \u211d)\n  (p : \u211d)\n  (h_p : 0 < p \u2227 p < 1)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))\n  (h_uniform : \u2200 a b : \u211d, 0 \u2264 a \u2227 a \u2264 b \u2227 b \u2264 1 \u2192 \n    \u03bc (X \u207b\u00b9' (Set.Icc a b)) = (b - a : ENNReal))\n  (h_discrete : \u03bc (Y \u207b\u00b9' {1}) = (p : ENNReal) \u2227 \u03bc (Y \u207b\u00b9' {-1}) = ((1 - p) : ENNReal)) :\n  let Z := fun \u03c9 => X \u03c9 + Y \u03c9\n  -- E[Z] = 2p - 1/2\n  (\u222b \u03c9, Z \u03c9 \u2202\u03bc = 2 * p - 1/2) \u2227\n  -- E[Z|Y] = Y + 1/2  \n  (\u2200 y : \u211d, (y = 1 \u2228 y = -1) \u2192 \n    \u222b \u03c9, (Z \u03c9 - (y + 1/2)) * (if Y \u03c9 = y then 1 else 0) \u2202\u03bc = 0) \u2227\n  -- Var(Y) = p(1-p)\n  (\u222b \u03c9, (Y \u03c9 - \u222b \u03c9', Y \u03c9' \u2202\u03bc)^2 \u2202\u03bc = p * (1 - p))\n  := by sorry", "lean_pass": false, "error_msg": [{"line": 14, "column": 31, "endLine": 14, "endColumn": 36, "data": "type mismatch\n  b - a\nhas type\n  \u211d : outParam Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 15, "column": 32, "endLine": 15, "endColumn": 45, "data": "type mismatch\n  p\nhas type\n  \u211d : Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 15, "column": 67, "endLine": 15, "endColumn": 72, "data": "failed to synthesize\n  HSub \u2115 \u211d ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "The expectation of a Uniform(0,1) random variable is $E[X] = \\frac{1}{2}$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\nTherefore, we conclude:\n\u2022 The expectation of X is E[X] = 1/2 [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y Z : \u03a9 \u2192 \u211d)\n  (p : \u211d)\n  (h_p : p \u2208 Set.Ioo 0 1)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))\n  (h_uniform : \u2200 a b : \u211d, a \u2208 Set.Ioo 0 1 \u2192 b \u2208 Set.Ioo 0 1 \u2192 \n    \u03bc (X \u207b\u00b9' (Set.Icc a b)) = b - a)\n  (h_discrete : \u03bc (Y \u207b\u00b9' {1}) = p \u2227 \u03bc (Y \u207b\u00b9' {-1}) = 1 - p)\n  (h_Z : Z = X + Y) :\n  MeasureTheory.integral \u03bc X = 1/2 := by sorry", "lean_pass": false, "error_msg": [{"line": 14, "column": 30, "endLine": 14, "endColumn": 35, "data": "type mismatch\n  b - a\nhas type\n  \u211d : outParam Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 15, "column": 32, "endLine": 15, "endColumn": 33, "data": "type mismatch\n  p\nhas type\n  \u211d : Type\nbut is expected to have type\n  ENNReal : Type"}, {"line": 15, "column": 53, "endLine": 15, "endColumn": 58, "data": "failed to synthesize\n  HSub \u2115 \u211d ENNReal\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nhave h\u2081 : False := by\n  have h\u2082 := h_discrete.1\n  -- Now h\u2082 : \u03bc (Y \u207b\u00b9' {1}) = p\n  -- But \u03bc (Y \u207b\u00b9' {1}) : ENNReal and p : \u211d\n  -- Lean cannot equate them unless it can coerce p to ENNReal.\n  <;>\n  (try contradiction)\n  <;>\n  (try norm_num at h\u2082)\n  <;>\n  (try linarith [h_p.1, h_p.2])", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 4, "column": 0, "endLine": 4, "endColumn": 4, "data": "unexpected token 'have'; expected command"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "The expectation of the discrete random variable $Y$ is $E[Y] = (1)(p) + (-1)(1-p) = 2p-1$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\nTherefore, we conclude:\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1) :\n  \u222b y in ({1, -1} : Set \u211d), (if y = 1 then p else 1 - p) * y = 2*p - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1) :\n  \u222b y in ({1, -1} : Set \u211d), (if y = 1 then p else 1 - p) * y = 2*p - 1 := by\n  have h_main : \u222b y in ({1, -1} : Set \u211d), (if y = 1 then p else 1 - p) * y = 2*p - 1 := by\n    have h\u2081 : \u222b y in ({1, -1} : Set \u211d), (if y = 1 then p else 1 - p) * y = (p : \u211d) + (1 - p : \u211d) * (-1 : \u211d) := by\n      -- Use the fact that the set {1, -1} is finite to compute the integral as the sum of the function over the set.\n      -- This is a specific case of the general result that the integral over a finite set is the sum of the function over the set.\n      -- Here, we compute the integral directly by evaluating the function at each point in the set.\n      norm_num [Set.mem_insert, Set.mem_singleton_iff]\n      <;>\n      (try simp_all [MeasureTheory.integral_undef, Real.volume_singleton]) <;>\n      (try norm_num) <;>\n      (try ring_nf) <;>\n      (try linarith) <;>\n      (try field_simp) <;>\n      (try norm_num) <;>\n      (try ring_nf) <;>\n      (try linarith)\n      <;>\n      (try\n        {\n          simp_all [MeasureTheory.integral_undef, Real.volume_singleton]\n          <;> norm_num <;> linarith\n        })\n      <;>\n      (try\n        {\n          simp_all [MeasureTheory.integral_undef, Real.volume_singleton]\n          <;> norm_num <;> linarith\n        })\n    rw [h\u2081]\n    -- Simplify the expression to get the final result.\n    <;> ring_nf\n    <;> linarith\n  \n  -- The main result follows directly from the computation.\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 7, "column": 111, "endLine": 32, "endColumn": 10, "data": "unsolved goals\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\n\u22a2 (\u222b (y : \u211d) in {1, -1}, if y = 1 then p else -(p * y) + y) = -1 + p * 2"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization completely omits all the foundational assumptions about random variables X, Y, Z, their independence, and their distributions that are central to the natural language problem setup.", "The given fact E[X] = 1/2 is entirely missing from the Lean formalization, even though it's stated as a premise in the natural language.", "While the Lean theorem computes the correct expression 2*p - 1, it does so as a direct integral calculation rather than as the expectation of the random variable Y described in the natural language.", "The Lean formalization lacks the proper probabilistic framework and context, reducing a probability theory problem to a basic integral calculation without random variables or probability spaces.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely omits all the foundational assumptions about random variables X, Y, Z, their independence, and their distributions that are central to the natural language problem setup.', \"The given fact E[X] = 1/2 is entirely missing from the Lean formalization, even though it's stated as a premise in the natural language.\", 'While the Lean theorem computes the correct expression 2*p - 1, it does so as a direct integral calculation rather than as the expectation of the random variable Y described in the natural language.', 'The Lean formalization lacks the proper probabilistic framework and context, reducing a probability theory problem to a basic integral calculation without random variables or probability spaces.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "From the definition $Z = X+Y$ and the linearity of expectation, it follows that $E[Z] = E[X] + E[Y]$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\nTherefore, we conclude:\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1)\n  (\u03bc_X : \u211d) (\u03bc_Y : \u211d) (\u03bc_Z : \u211d)\n  (h_l1 : \u03bc_X = 1/2)  -- E[X] = 1/2\n  (h_l2 : \u03bc_Y = 2*p - 1)  -- E[Y] = 2p - 1\n  (h_sum : \u03bc_Z = \u03bc_X + \u03bc_Y)  -- E[Z] = E[X] + E[Y] where Z = X + Y\n  : \u03bc_Z = 2*p - 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1)\n  (\u03bc_X : \u211d) (\u03bc_Y : \u211d) (\u03bc_Z : \u211d)\n  (h_l1 : \u03bc_X = 1/2)\n  (h_l2 : \u03bc_Y = 2*p - 1)\n  (h_sum : \u03bc_Z = \u03bc_X + \u03bc_Y)\n  : \u03bc_Z = 2*p - 1/2 := by\n  have h_main : \u03bc_Z = 2*p - 1/2 := by\n    have h1 : \u03bc_Z = \u03bc_X + \u03bc_Y := h_sum\n    rw [h1]\n    rw [h_l1, h_l2]\n    ring_nf\n    <;>\n    (try norm_num) <;>\n    (try linarith)\n    <;>\n    (try ring_nf at *) <;>\n    (try linarith)\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.45, "semantic_feedback": ["The Lean formalization abstracts away the actual random variables and their distributions, working directly with expectation values as real numbers rather than defining the probabilistic structure described in the natural language.", "The mathematical relationships E[X] = 1/2 and E[Y] = 2p - 1 are perfectly captured in the Lean hypotheses h_l1 and h_l2.", "The conclusion about E[Z] = E[X] + E[Y] is captured, but the Lean code takes this linearity as an assumption (h_sum) and proves the numerical result, rather than deriving the linearity from independence as suggested in the natural language.", "While the mathematical content is preserved, the Lean formalization takes a more abstract approach by working with expectation values directly rather than establishing the full probabilistic framework described in the natural language assumptions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.45, below threshold 0.6.\nScorer feedback: ['The Lean formalization abstracts away the actual random variables and their distributions, working directly with expectation values as real numbers rather than defining the probabilistic structure described in the natural language.', 'The mathematical relationships E[X] = 1/2 and E[Y] = 2p - 1 are perfectly captured in the Lean hypotheses h_l1 and h_l2.', 'The conclusion about E[Z] = E[X] + E[Y] is captured, but the Lean code takes this linearity as an assumption (h_sum) and proves the numerical result, rather than deriving the linearity from independence as suggested in the natural language.', 'While the mathematical content is preserved, the Lean formalization takes a more abstract approach by working with expectation values directly rather than establishing the full probabilistic framework described in the natural language assumptions.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting the computed expectations gives $E[Z] = \\frac{1}{2} + 2p - 1 = 2p - \\frac{1}{2}$, which proves the first conclusion.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\nTherefore, we conclude:\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  -- Given: E[X] = 1/2 where X ~ Uniform(0,1)\n  (h_E_X : (1/2 : \u211d) = 1/2)\n  -- Given: E[Y] = 2p - 1 where Y discrete with P(Y=1) = p, P(Y=-1) = 1-p  \n  (h_E_Y : (2*p - 1 : \u211d) = 2*p - 1)\n  -- Given: E[Z] = E[X] + E[Y] by linearity of expectation, where Z = X + Y\n  (h_additivity : (1/2) + (2*p - 1) = 2*p - 1/2)\n  : -- Conclusion: E[Z] = 2p - 1/2\n  (1/2) + (2*p - 1) = 2*p - 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  (h_E_X : (1/2 : \u211d) = 1/2)\n  (h_E_Y : (2*p - 1 : \u211d) = 2*p - 1)\n  (h_additivity : (1/2) + (2*p - 1) = 2*p - 1/2)\n  : (1/2) + (2*p - 1) = 2*p - 1/2 := by\n  have h_main : (1/2) + (2*p - 1) = 2*p - 1/2 := by\n    exact h_additivity\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has major inconsistencies with the natural language. While it captures the final arithmetic relationship E[Z] = 2p - 1/2, it completely omits the foundational probability theory components that justify this relationship. Missing elements include: (1) the actual random variables X, Y, Z and their definitions, (2) the distributional assumptions (Uniform and discrete distributions), (3) the independence assumption, (4) the relationship Z = X + Y, and (5) the linearity of expectation principle. The formalization reduces a meaningful probability theory result to a trivial arithmetic tautology by making the conclusion a direct hypothesis. This fails to capture the mathematical reasoning and probabilistic foundations that make the natural language statement meaningful."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization has major inconsistencies with the natural language. While it captures the final arithmetic relationship E[Z] = 2p - 1/2, it completely omits the foundational probability theory components that justify this relationship. Missing elements include: (1) the actual random variables X, Y, Z and their definitions, (2) the distributional assumptions (Uniform and discrete distributions), (3) the independence assumption, (4) the relationship Z = X + Y, and (5) the linearity of expectation principle. The formalization reduces a meaningful probability theory result to a trivial arithmetic tautology by making the conclusion a direct hypothesis. This fails to capture the mathematical reasoning and probabilistic foundations that make the natural language statement meaningful.']"}, "solved_negation": null, "type": "solution"}, "l4": {"id": "l4", "natural_language": "From $Z = X+Y$ and the linearity of conditional expectation, we have $E[Z|Y] = E[X|Y] + E[Y|Y]$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\nTherefore, we conclude:\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y : \u03a9 \u2192 \u211d)\n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))\n  : -- For independent random variables X and Y, \n    -- and Z = X + Y, we have E[Z|Y] = E[X|Y] + E[Y|Y]\n  \u2200 y : \u211d, \u03bc (Y \u207b\u00b9' {y}) > 0 \u2192\n    (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) \n      (fun x => x)) + y = \n    y + (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) \n      (fun x => x)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  {\u03a9 : Type*} [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (X Y : \u03a9 \u2192 \u211d)\n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  (h_indep : \u2200 s t : Set \u211d, \u03bc (X \u207b\u00b9' s \u2229 Y \u207b\u00b9' t) = \u03bc (X \u207b\u00b9' s) * \u03bc (Y \u207b\u00b9' t))\n  : \u2200 y : \u211d, \u03bc (Y \u207b\u00b9' {y}) > 0 \u2192\n    (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) \n      (fun x => x)) + y = \n    y + (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) \n      (fun x => x)) := by\n  intro y hy\n  have h_main : (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) (fun x => x)) + y = y + (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) (fun x => x)) := by\n    have h\u2081 : (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) (fun x : \u211d => x)) + y = y + (MeasureTheory.integral (MeasureTheory.volume.restrict (Set.univ : Set \u211d)) (fun x : \u211d => x)) := by\n      -- Use the commutativity of addition to swap the order of terms\n      ring_nf\n      <;>\n      simp_all [add_comm]\n      <;>\n      linarith\n    exact h\u2081\n  simpa using h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization completely fails to capture the mathematical meaning of the natural language statement. The natural language describes a relationship about conditional expectations E[Z|Y] = E[X|Y] + E[Y|Y] for random variables, but the Lean code only proves the trivial algebraic fact that addition is commutative (integral + y = y + integral). The formalization doesn't involve conditional expectations, doesn't reference the random variables X, Y, Z in the conclusion, doesn't use the independence assumption, and uses the wrong measure space. This is a fundamental misrepresentation of the intended mathematical content."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization completely fails to capture the mathematical meaning of the natural language statement. The natural language describes a relationship about conditional expectations E[Z|Y] = E[X|Y] + E[Y|Y] for random variables, but the Lean code only proves the trivial algebraic fact that addition is commutative (integral + y = y + integral). The formalization doesn't involve conditional expectations, doesn't reference the random variables X, Y, Z in the conclusion, doesn't use the independence assumption, and uses the wrong measure space. This is a fundamental misrepresentation of the intended mathematical content.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Due to the independence of $X$ and $Y$, we know that $E[X|Y] = E[X]$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\nTherefore, we conclude:\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  : -- Given X ~ Uniform(0,1) and Y discrete with P(Y=1) = p, P(Y=-1) = 1-p\n    -- and X, Y independent, we have E[X|Y] = E[X] = 1/2\n  -- For Y = 1: E[X|Y=1] = E[X] = 1/2\n  (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1/2) \u2227\n  -- For Y = -1: E[X|Y=-1] = E[X] = 1/2  \n  (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1/2) := by sorry", "lean_pass": false, "error_msg": [{"line": 14, "column": 3, "endLine": 14, "endColumn": 44, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 14, "column": 3, "endLine": 14, "endColumn": 44, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 16, "column": 3, "endLine": 16, "endColumn": 44, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 16, "column": 3, "endLine": 16, "endColumn": 44, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  : (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1/2) \u2227\n    (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1/2) := by\n  have h\u2081 : (\u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) * (1 / 2 : \u211d) / (1 / 2 : \u211d)) = \u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) := by\n    have h\u2082 : (fun x : \u211d => x * (1 / 2 : \u211d) / (1 / 2 : \u211d)) = (fun x : \u211d => x : \u211d \u2192 \u211d) := by\n      funext x\n      ring_nf\n      <;> field_simp\n      <;> ring_nf\n    rw [h\u2082]\n    <;>\n    simp [Set.Icc]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h\u2082 : \u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) = 1 / 2 := by\n    have h\u2083 : \u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) = \u222b x in (0 : \u211d)..(1 : \u211d), (x : \u211d) := by\n      -- Prove that the integral over [0,1] is equal to the integral from 0 to 1\n      have h\u2084 : \u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) = \u222b x in (0 : \u211d)..(1 : \u211d), (x : \u211d) := by\n        -- Use the fundamental theorem of calculus to equate the two integrals\n        simp [MeasureTheory.integral_Icc_eq_integral_Ioc, Real.volume_Ioc, intervalIntegral.integral_of_le (by norm_num : (0 : \u211d) \u2264 1)]\n        <;>\n        simp_all [MeasureTheory.integral_Ioc_eq_integral_Icc]\n        <;>\n        norm_num\n        <;>\n        linarith\n      rw [h\u2084]\n    rw [h\u2083]\n    -- Compute the integral from 0 to 1 of x\n    norm_num [integral_id]\n    <;>\n    simp_all\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h\u2083 : (\u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) * (1 / 2 : \u211d) / (1 / 2 : \u211d)) = 1 / 2 := by\n    calc\n      (\u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) * (1 / 2 : \u211d) / (1 / 2 : \u211d)) = \u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) := by rw [h\u2081]\n      _ = 1 / 2 := by rw [h\u2082]\n  \n  have h\u2084 : (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1/2) \u2227 (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1/2) := by\n    have h\u2085 : (\u222b x in Set.Icc (0 : \u211d) 1, (x : \u211d) * (1 / 2 : \u211d) / (1 / 2 : \u211d)) = 1 / 2 := h\u2083\n    have h\u2086 : (\u222b x in Set.Icc 0 1, x * (1 / 2) / (1 / 2) : \u211d) = 1 / 2 := by\n      -- Use the fact that the integral over [0,1] in \u211d is the same as the integral in \u2115\n      norm_cast at h\u2085 \u22a2\n      <;>\n      simp_all [Set.Icc]\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    constructor <;>\n    (try norm_num at h\u2086 \u22a2) <;>\n    (try simp_all [Set.Icc]) <;>\n    (try norm_cast at h\u2086 \u22a2) <;>\n    (try simp_all [Set.Icc]) <;>\n    (try norm_num at h\u2086 \u22a2) <;>\n    (try linarith)\n    <;>\n    (try\n      {\n        simp_all [Set.Icc]\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [Set.Icc]\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [Set.Icc]\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n  \n  exact h\u2084", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 5, "endLine": 8, "endColumn": 46, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 8, "column": 5, "endLine": 8, "endColumn": 46, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 5, "endLine": 9, "endColumn": 46, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 5, "endLine": 9, "endColumn": 46, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 52, "column": 13, "endLine": 52, "endColumn": 54, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 52, "column": 13, "endLine": 52, "endColumn": 54, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 52, "column": 65, "endLine": 52, "endColumn": 106, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 52, "column": 65, "endLine": 52, "endColumn": 106, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 52, "column": 117, "endLine": 96, "endColumn": 8, "data": "unsolved goals\ncase left\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082\u271d : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\nh\u2082 : \u222b (x : \u211d) in {x | 0 \u2264 x \u2227 x \u2264 1}, x = 2\u207b\u00b9\n\u22a2 \u222b (x : \u2115) in {x | x \u2264 1}, 0 = 0\n\ncase right\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082\u271d : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\nh\u2082 : \u222b (x : \u211d) in {x | 0 \u2264 x \u2227 x \u2264 1}, x = 2\u207b\u00b9\n\u22a2 \u222b (x : \u2115) in {x | x \u2264 1}, 0 = 0"}, {"line": 98, "column": 8, "endLine": 98, "endColumn": 10, "data": "unknown identifier 'h\u2084'"}, {"line": 9, "column": 57, "endLine": 98, "endColumn": 10, "data": "unsolved goals\ncase refine_2\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082 : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\n\u22a2 NormedSpace \u211d \u2115\n\ncase refine_3\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082 : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\n\u22a2 MeasureTheory.MeasureSpace \u2115\n\ncase refine_4\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082 : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\n\u22a2 NormedAddCommGroup \u2115\n\ncase refine_5\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082 : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\n\u22a2 NormedSpace \u211d \u2115\n\ncase refine_6\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082 : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\n\u22a2 MeasureTheory.MeasureSpace \u2115\n\ncase refine_7\np : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nh\u2081 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = \u222b (x : \u211d) in Set.Icc 0 1, x\nh\u2082 : \u222b (x : \u211d) in Set.Icc 0 1, x = 1 / 2\nh\u2083 : \u222b (x : \u211d) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\nh\u2084 : \u222b (x : \u2115) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2 \u2227 \u222b (x : \u2115) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2\n\u22a2 \u222b (x : \u2115) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2 \u2227 \u222b (x : \u2115) in Set.Icc 0 1, x * (1 / 2) / (1 / 2) = 1 / 2"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "it is a fundamental property that $E[Y|Y] = Y$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5];\nTherefore, we conclude:\n\u2022 The conditional expectation of Y given Y is E[Y|Y] = Y [l6].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (Y : \u211d) (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  : -- For discrete random variable Y with P(Y=1) = p, P(Y=-1) = 1-p,\n    -- the conditional expectation E[Y|Y] equals Y itself\n  (if Y = 1 then p else (1 - p)) * Y = Y := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (Y : \u211d) (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  : (if Y = 1 then p else (1 - p)) * Y = Y := by\n  have h_main : Y = 0 := by\n    by_cases hY : Y = 1\n    \u00b7 -- Case Y = 1\n      have h\u2081 : (if Y = 1 then p else (1 - p)) * Y = p := by\n        simp [hY]\n        <;> ring\n      have h\u2082 : (p : \u211d) < 1 := h_p_lt_one\n      have h\u2083 : (Y : \u211d) = 1 := by simp [hY]\n      have h\u2084 : (if Y = 1 then p else (1 - p)) * Y < Y := by\n        rw [h\u2081]\n        linarith\n      -- Since (if Y = 1 then p else (1 - p)) * Y < Y, we cannot have (if Y = 1 then p else (1 - p)) * Y = Y\n      -- But we are trying to prove (if Y = 1 then p else (1 - p)) * Y = Y, so if Y = 1, this leads to a contradiction\n      -- Therefore, Y cannot be 1\n      have h\u2085 : False := by\n        -- Assume the original statement (if Y = 1 then p else (1 - p)) * Y = Y\n        -- but we have (if Y = 1 then p else (1 - p)) * Y < Y when Y = 1\n        -- which is a contradiction because p < 1\n        have h\u2086 : (if Y = 1 then p else (1 - p)) * Y < Y := h\u2084\n        -- But we need to prove (if Y = 1 then p else (1 - p)) * Y = Y, which is impossible when Y = 1\n        -- because p < 1\n        have h\u2087 : (if Y = 1 then p else (1 - p)) * Y = Y := by\n          -- This is the statement we are trying to prove, but under Y = 1, it's false\n          -- So perhaps we can use the fact that it's false to derive a contradiction\n          exfalso\n          -- Since (if Y = 1 then p else (1 - p)) * Y < Y, we cannot have (if Y = 1 then p else (1 - p)) * Y = Y\n          linarith\n        linarith\n      exfalso\n      exact h\u2085\n    \u00b7 -- Case Y \u2260 1\n      have h\u2081 : (if Y = 1 then p else (1 - p)) * Y = (1 - p) * Y := by\n        simp [hY]\n        <;> ring\n      -- Now we need to show that if Y \u2260 0, then (1 - p) * Y \u2260 Y\n      by_contra h\u2082\n      -- Assume Y \u2260 0 and derive a contradiction\n      have h\u2083 : Y \u2260 0 := h\u2082\n      -- If Y \u2260 0, then (1 - p) * Y = Y implies Y = 0, which is a contradiction\n      have h\u2084 : (1 - p) * Y \u2260 Y := by\n        intro h\u2084\n        have h\u2085 : (1 - p - 1 : \u211d) * Y = 0 := by linarith\n        have h\u2086 : (-p : \u211d) * Y = 0 := by ring_nf at h\u2085 \u22a2 <;> linarith\n        have h\u2087 : (-p : \u211d) \u2260 0 := by\n          have h\u2088 : (p : \u211d) > 0 := h_p_pos\n          linarith\n        have h\u2088 : Y = 0 := by\n          apply mul_left_cancel\u2080 h\u2087\n          linarith\n        contradiction\n      -- But we need to prove (if Y = 1 then p else (1 - p)) * Y = Y, which is (1 - p) * Y = Y when Y \u2260 1\n      -- So we have a contradiction because (1 - p) * Y \u2260 Y when Y \u2260 0 and Y \u2260 1\n      have h\u2085 : False := by\n        have h\u2086 : (if Y = 1 then p else (1 - p)) * Y = (1 - p) * Y := h\u2081\n        have h\u2087 : (1 - p) * Y \u2260 Y := h\u2084\n        have h\u2088 : (if Y = 1 then p else (1 - p)) * Y = Y := by\n          -- This is the statement we are trying to prove, but under Y \u2260 0 and Y \u2260 1, we have (1 - p) * Y \u2260 Y\n          exfalso\n          -- We have (1 - p) * Y \u2260 Y, but we need (1 - p) * Y = Y\n          -- So perhaps we can use the fact that (1 - p) * Y \u2260 Y to derive a contradiction\n          have h\u2089 : (if Y = 1 then p else (1 - p)) * Y = (1 - p) * Y := h\u2081\n          have h\u2081\u2080 : (1 - p) * Y \u2260 Y := h\u2084\n          -- But we need to prove (if Y = 1 then p else (1 - p)) * Y = Y, which is (1 - p) * Y = Y\n          -- So perhaps we can use the fact that (1 - p) * Y \u2260 Y to derive a contradiction\n          simp_all [h\u2081]\n          <;>\n          (try contradiction) <;>\n          (try linarith)\n        simp_all [h\u2081]\n        <;>\n        (try contradiction) <;>\n        (try linarith)\n      exfalso\n      exact h\u2085\n  \n  have h_final : (if Y = 1 then p else (1 - p)) * Y = Y := by\n    rw [h_main]\n    <;> simp\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 35, "column": 10, "endLine": 35, "endColumn": 18, "data": "linarith failed to find a contradiction\nY p : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nhY : Y = 1\nh\u2081 : (if Y = 1 then p else 1 - p) * Y = p\nh\u2082 : p < 1\nh\u2083 : Y = 1\nh\u2084 h\u2086 : (if Y = 1 then p else 1 - p) * Y < Y\n\u22a2 False failed"}, {"line": 64, "column": 60, "endLine": 76, "endColumn": 24, "data": "unsolved goals\nY p : \u211d\nh_p_pos : 0 < p\nh_p_lt_one : p < 1\nhY : \u00acY = 1\nh\u2083 : \u00acY = 0\nh\u2081\u2080 : \u00acp = 0\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization fundamentally misrepresents the mathematical concept of conditional expectation E[Y|Y] = Y. The expression '(if Y = 1 then p else (1 - p)) * Y = Y' incorrectly multiplies Y by its probability weights, which does not represent conditional expectation. The conditional expectation E[Y|Y] should simply equal Y itself as a direct identity, not involve probability weights. The formalized equation is mathematically incorrect for the given discrete random variable, as it would only hold for specific values of p that contradict the given constraints.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization fundamentally misrepresents the mathematical concept of conditional expectation E[Y|Y] = Y. The expression '(if Y = 1 then p else (1 - p)) * Y = Y' incorrectly multiplies Y by its probability weights, which does not represent conditional expectation. The conditional expectation E[Y|Y] should simply equal Y itself as a direct identity, not involve probability weights. The formalized equation is mathematically incorrect for the given discrete random variable, as it would only hold for specific values of p that contradict the given constraints.\"]"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Substituting these properties into our expression for the conditional expectation, we get $E[Z|Y] = E[X] + Y$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5];\n\u2022 The conditional expectation of Y given Y is E[Y|Y] = Y [l6];\nTherefore, we conclude:\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X] + Y [l7].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  -- Given: X ~ Uniform(0,1), so E[X] = 1/2\n  (h_E_X : \u222b x in Set.Ioo 0 1, x = 1/2)\n  -- Given: Y discrete with P(Y=1) = p, P(Y=-1) = 1-p, so E[Y] = 2p-1  \n  (h_E_Y : p * 1 + (1 - p) * (-1) = 2*p - 1)\n  -- Given: E[Z|Y] = E[X|Y] + E[Y|Y] (linearity of conditional expectation)\n  (h_l4 : \u2200 y \u2208 ({1, -1} : Set \u211d), \n    \u222b x in Set.Ioo 0 1, (x + y) = y + 1/2)\n  -- Given: E[X|Y] = E[X] (independence)\n  (h_l5 : \u2200 y \u2208 ({1, -1} : Set \u211d), \n    \u222b x in Set.Ioo 0 1, x = 1/2)\n  -- Given: E[Y|Y] = Y\n  (h_l6 : \u2200 y \u2208 ({1, -1} : Set \u211d), y = y)\n  : \u2200 y \u2208 ({1, -1} : Set \u211d), \n    \u222b x in Set.Ioo 0 1, (x + y) = 1/2 + y := by sorry", "lean_pass": false, "error_msg": [{"line": 12, "column": 11, "endLine": 12, "endColumn": 32, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 12, "column": 11, "endLine": 12, "endColumn": 32, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 20, "column": 4, "endLine": 20, "endColumn": 25, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 20, "column": 4, "endLine": 20, "endColumn": 25, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  (h_E_X : \u222b x in Set.Ioo 0 1, x = 1/2)\n  (h_E_Y : p * 1 + (1 - p) * (-1) = 2*p - 1)\n  (h_l4 : \u2200 y \u2208 ({1, -1} : Set \u211d), \u222b x in Set.Ioo 0 1, (x + y) = y + 1/2)\n  (h_l5 : \u2200 y \u2208 ({1, -1} : Set \u211d), \u222b x in Set.Ioo 0 1, x = 1/2)\n  (h_l6 : \u2200 y \u2208 ({1, -1} : Set \u211d), y = y)\n  : \u2200 y \u2208 ({1, -1} : Set \u211d), \u222b x in Set.Ioo 0 1, (x + y) = 1/2 + y := by\n  have h_main : \u2200 (y : \u211d), y \u2208 ({1, -1} : Set \u211d) \u2192 \u222b x in Set.Ioo 0 1, (x + y) = 1/2 + y := by\n    intro y hy\n    have h\u2081 : \u222b x in Set.Ioo 0 1, (x + y) = y + 1 / 2 := h_l4 y hy\n    have h\u2082 : y + 1 / 2 = 1 / 2 + y := by ring\n    linarith\n  \n  intro y hy\n  have h\u2081 : \u222b x in Set.Ioo 0 1, (x + y) = 1/2 + y := h_main y hy\n  exact h\u2081", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 11, "endLine": 8, "endColumn": 32, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 8, "column": 11, "endLine": 8, "endColumn": 32, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 35, "endLine": 11, "endColumn": 56, "data": "failed to synthesize\n  MeasureTheory.MeasureSpace \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 11, "column": 35, "endLine": 11, "endColumn": 56, "data": "failed to synthesize\n  NormedAddCommGroup \u2115\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "Using our previously calculated value for $E[X]$, we arrive at the second conclusion: $E[Z|Y] = Y + \\frac{1}{2}$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5];\n\u2022 The conditional expectation of Y given Y is E[Y|Y] = Y [l6];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X] + Y [l7];\nTherefore, we conclude:\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = Y + 1/2 [ts_2].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  -- Given: E[X] = 1/2 where X ~ Uniform(0,1)\n  (h_E_X : (1/2 : \u211d) = 1/2)\n  -- Given: E[Y] = 2p - 1 where Y discrete with P(Y=1) = p, P(Y=-1) = 1-p  \n  (h_E_Y : (2*p - 1 : \u211d) = 2*p - 1)\n  -- Given: E[Z] = E[X] + E[Y] by linearity, where Z = X + Y\n  (h_additivity : (1/2) + (2*p - 1) = 2*p - 1/2)\n  -- Given: E[Z|Y] = E[X|Y] + E[Y|Y] (conditional expectation additivity)\n  (h_cond_exp_additive : \u2200 y : \u211d, \n    \u222b z, z * (if y = 1 then p else (1 - p)) = \n    \u222b x, x * (if y = 1 then p else (1 - p)) + y)\n  -- Given: E[X|Y] = E[X] (independence implies E[X|Y] = E[X])\n  (h_cond_exp_X : \u2200 y : \u211d, \n    \u222b x, x * (if y = 1 then p else (1 - p)) = 1/2)\n  -- Given: E[Y|Y] = Y (law of conditional expectation)\n  (h_cond_exp_Y : \u2200 y : \u211d, y \u2208 ({1, -1} : Set \u211d) \u2192 \n    \u222b y', y' * (if y' = y then 1 else 0) = y)\n  : -- Conclusion: E[Z|Y] = Y + 1/2\n  \u2200 y : \u211d, y \u2208 ({1, -1} : Set \u211d) \u2192 \n    \u222b z, z * (if y = 1 then p else (1 - p)) = y + 1/2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (p : \u211d)\n  (h_p_pos : 0 < p)\n  (h_p_lt_one : p < 1)\n  (h_E_X : (1/2 : \u211d) = 1/2)\n  (h_E_Y : (2*p - 1 : \u211d) = 2*p - 1)\n  (h_additivity : (1/2) + (2*p - 1) = 2*p - 1/2)\n  (h_cond_exp_additive : \u2200 y : \u211d, \n    \u222b z, z * (if y = 1 then p else (1 - p)) = \n    \u222b x, x * (if y = 1 then p else (1 - p)) + y)\n  (h_cond_exp_X : \u2200 y : \u211d, \n    \u222b x, x * (if y = 1 then p else (1 - p)) = 1/2)\n  (h_cond_exp_Y : \u2200 y : \u211d, y \u2208 ({1, -1} : Set \u211d) \u2192 \n    \u222b y', y' * (if y' = y then 1 else 0) = y)\n  : \u2200 y : \u211d, y \u2208 ({1, -1} : Set \u211d) \u2192 \n    \u222b z, z * (if y = 1 then p else (1 - p)) = y + 1/2 := by\n  have h\u2082 : False := by\n    have h\u2083 : (\u222b z : \u211d, (z : \u211d) * p) = (\u222b x : \u211d, (x : \u211d) * p) := by\n      congr\n      <;> ext\n      <;> ring_nf\n      <;> simp_all [mul_comm]\n      <;> linarith\n    have h\u2084 := h_cond_exp_additive 1\n    have h\u2085 := h_cond_exp_X 1\n    have h\u2086 : (\u222b z : \u211d, (z : \u211d) * p) = (\u222b x : \u211d, (x : \u211d) * p) + 1 := by\n      have h\u2086\u2081 : (\u222b z : \u211d, (z : \u211d) * (if (1 : \u211d) = 1 then p else (1 - p))) = (\u222b x : \u211d, (x : \u211d) * (if (1 : \u211d) = 1 then p else (1 - p))) + 1 := by\n        simpa using h\u2084\n      have h\u2086\u2082 : (\u222b z : \u211d, (z : \u211d) * (if (1 : \u211d) = 1 then p else (1 - p))) = (\u222b z : \u211d, (z : \u211d) * p) := by\n        simp [ite_true] at h\u2086\u2081 \u22a2\n        <;>\n        simp_all [mul_comm]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      have h\u2086\u2083 : (\u222b x : \u211d, (x : \u211d) * (if (1 : \u211d) = 1 then p else (1 - p))) = (\u222b x : \u211d, (x : \u211d) * p) := by\n        simp [ite_true] at h\u2086\u2081 \u22a2\n        <;>\n        simp_all [mul_comm]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      linarith\n    have h\u2087 : (\u222b x : \u211d, (x : \u211d) * p) + 1 = (\u222b x : \u211d, (x : \u211d) * p) := by linarith\n    linarith\n  \n  have h_main : \u2200 y : \u211d, y \u2208 ({1, -1} : Set \u211d) \u2192 \u222b z, z * (if y = 1 then p else (1 - p)) = y + 1/2 := by\n    exfalso\n    exact h\u2082\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 31, "column": 8, "endLine": 31, "endColumn": 22, "data": "type mismatch, term\n  h\u2084\nafter simplification has type\n  \u222b (z : \u211d), z * p = \u222b (x : \u211d), x * p + 1 : Prop\nbut is expected to have type\n  False : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization contains major mathematical errors in representing conditional expectations. The use of marginal probabilities p and (1-p) as weights in conditional expectation expressions is incorrect - conditional expectations should be computed using conditional probability distributions, not marginal ones. The integral notation mixed with discrete probability weighting creates a mathematically inconsistent framework. While the final conclusion E[Z|Y] = Y + 1/2 matches the natural language, the formal mathematical foundation used to derive it is fundamentally flawed.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization contains major mathematical errors in representing conditional expectations. The use of marginal probabilities p and (1-p) as weights in conditional expectation expressions is incorrect - conditional expectations should be computed using conditional probability distributions, not marginal ones. The integral notation mixed with discrete probability weighting creates a mathematically inconsistent framework. While the final conclusion E[Z|Y] = Y + 1/2 matches the natural language, the formal mathematical foundation used to derive it is fundamentally flawed.']"}, "solved_negation": null, "type": "solution"}, "l8": {"id": "l8", "natural_language": "From our result for the second conclusion, it follows that $Var(E[Z|Y]) = Var(Y + \\frac{1}{2})$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5];\n\u2022 The conditional expectation of Y given Y is E[Y|Y] = Y [l6];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X] + Y [l7];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = Y + 1/2 [ts_2];\nTherefore, we conclude:\n\u2022 The variance of the conditional expectation is Var(E[Z|Y]) = Var(Y + 1/2) [l8].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4", "l5", "l6", "l7", "ts_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1)\n  : -- Given the setup where X ~ Uniform(0,1), Y discrete with P(Y=1)=p, P(Y=-1)=1-p,\n    -- and Z = X + Y, we have shown that E[Z|Y] = Y + 1/2\n  -- The variance of E[Z|Y] equals the variance of Y\n  let Var_Y := (1 : \u211d)^2 * p + (-1)^2 * (1 - p) - (2*p - 1)^2\n  let Var_EZ_given_Y := (1 + 1/2)^2 * p + (-1 + 1/2)^2 * (1 - p) - (2*p - 1/2)^2\n  Var_EZ_given_Y = Var_Y := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1)\n  : let Var_Y := (1 : \u211d)^2 * p + (-1)^2 * (1 - p) - (2*p - 1)^2\n    let Var_EZ_given_Y := (1 + 1/2)^2 * p + (-1 + 1/2)^2 * (1 - p) - (2*p - 1/2)^2\n    Var_EZ_given_Y = Var_Y := by\n  dsimp only\n  have h_main : ((1 + 1 / 2 : \u211d) ^ 2 * p + (-1 + 1 / 2 : \u211d) ^ 2 * (1 - p) - (2 * p - 1 / 2 : \u211d) ^ 2) = ((1 : \u211d) ^ 2 * p + (-1 : \u211d) ^ 2 * (1 - p) - (2 * p - 1 : \u211d) ^ 2) := by\n    ring_nf\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try nlinarith) <;>\n    (try ring_nf at *) <;>\n    (try field_simp at *) <;>\n    (try nlinarith)\n    <;>\n    linarith\n  \n  rw [h_main]\n  <;>\n  (try ring_nf) <;>\n  (try norm_num) <;>\n  (try linarith) <;>\n  (try nlinarith)\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical conclusion from the natural language. The theorem statement properly expresses that Var(E[Z|Y]) = Var(Y + 1/2) = Var(Y), with accurate variance calculations for both the discrete random variable Y and the conditional expectation E[Z|Y] = Y + 1/2. The essential parameter constraints are preserved, and the mathematical relationship is correctly formalized even though the intermediate setup steps are condensed into comments.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "A key property of variance is that adding a constant to a random variable does not change its variance, which means $Var(Y + \\frac{1}{2}) = Var(Y)$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5];\n\u2022 The conditional expectation of Y given Y is E[Y|Y] = Y [l6];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X] + Y [l7];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = Y + 1/2 [ts_2];\n\u2022 The variance of the conditional expectation is Var(E[Z|Y]) = Var(Y + 1/2) [l8];\nTherefore, we conclude:\n\u2022 The variance is invariant to adding a constant: Var(Y + 1/2) = Var(Y) [l9].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4", "l5", "l6", "l7", "ts_2", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1) :\n  -- For discrete random variable Y with P(Y=1) = p, P(Y=-1) = 1-p,\n  -- the variance is invariant to adding a constant\n  let P := fun y : \u211d => if y = 1 then p else if y = -1 then 1 - p else 0\n  let E_Y := \u222b y in ({1, -1} : Set \u211d), y * P y\n  let E_Y_plus_half := \u222b y in ({1, -1} : Set \u211d), (y + 1/2) * P y\n  let E_Y_squared := \u222b y in ({1, -1} : Set \u211d), y^2 * P y\n  let E_Y_plus_half_squared := \u222b y in ({1, -1} : Set \u211d), (y + 1/2)^2 * P y\n  let Var_Y := E_Y_squared - E_Y^2\n  let Var_Y_plus_half := E_Y_plus_half_squared - E_Y_plus_half^2\n  Var_Y_plus_half = Var_Y := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1) :\n  let P := fun y : \u211d => if y = 1 then p else if y = -1 then 1 - p else 0\n  let E_Y := (\u2211 y in ({1, -1} : Finset \u211d), y * P y)\n  let E_Y_plus_half := (\u2211 y in ({1, -1} : Finset \u211d), (y + 1/2) * P y)\n  let E_Y_squared := (\u2211 y in ({1, -1} : Finset \u211d), y^2 * P y)\n  let E_Y_plus_half_squared := (\u2211 y in ({1, -1} : Finset \u211d), (y + 1/2)^2 * P y)\n  let Var_Y := E_Y_squared - E_Y^2\n  let Var_Y_plus_half := E_Y_plus_half_squared - E_Y_plus_half^2\n  Var_Y_plus_half = Var_Y := by\n  intro P E_Y E_Y_plus_half E_Y_squared E_Y_plus_half_squared Var_Y Var_Y_plus_half\n  have h1 : E_Y = (2 : \u211d) * p - 1 := by\n    simp only [E_Y, P]\n    norm_num [Finset.sum_pair (show (1 : \u211d) \u2260 -1 by norm_num)]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h2 : E_Y_plus_half = (2 : \u211d) * p - 1 / 2 := by\n    simp only [E_Y_plus_half, P]\n    norm_num [Finset.sum_pair (show (1 : \u211d) \u2260 -1 by norm_num)]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h3 : E_Y_squared = 1 := by\n    simp only [E_Y_squared, P]\n    norm_num [Finset.sum_pair (show (1 : \u211d) \u2260 -1 by norm_num)]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h4 : E_Y_plus_half_squared = (8 : \u211d) * p / 4 + 1 / 4 := by\n    simp only [E_Y_plus_half_squared, P]\n    norm_num [Finset.sum_pair (show (1 : \u211d) \u2260 -1 by norm_num)]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h5 : Var_Y_plus_half = (4 : \u211d) * p - 4 * p ^ 2 := by\n    have h\u2085 : Var_Y_plus_half = E_Y_plus_half_squared - E_Y_plus_half ^ 2 := rfl\n    rw [h\u2085]\n    have h\u2086 : E_Y_plus_half_squared = (8 : \u211d) * p / 4 + 1 / 4 := h4\n    have h\u2087 : E_Y_plus_half = (2 : \u211d) * p - 1 / 2 := h2\n    rw [h\u2086, h\u2087]\n    <;> ring_nf at *\n    <;> nlinarith [h_p_pos, h_p_lt_one]\n  \n  have h6 : Var_Y = (4 : \u211d) * p - 4 * p ^ 2 := by\n    have h\u2086 : Var_Y = E_Y_squared - E_Y ^ 2 := rfl\n    rw [h\u2086]\n    have h\u2087 : E_Y_squared = 1 := h3\n    have h\u2088 : E_Y = (2 : \u211d) * p - 1 := h1\n    rw [h\u2087, h\u2088]\n    <;> ring_nf\n    <;> nlinarith [h_p_pos, h_p_lt_one]\n  \n  have h7 : Var_Y_plus_half = Var_Y := by\n    rw [h5, h6]\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try ring_nf) <;>\n    (try nlinarith)\n  \n  exact h7", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the variance invariance property for the discrete random variable Y. The probability mass function is properly defined, expectations are calculated using appropriate integrals over the support set, and variances use the standard E[X\u00b2] - (E[X])\u00b2 formula. The theorem statement directly expresses the claimed invariance Var(Y + 1/2) = Var(Y). The additional constraints ensuring p \u2208 (0,1) are mathematically appropriate and consistent with the natural language context.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_3": {"id": "ts_3", "natural_language": "By combining these last two steps, we establish the third conclusion: $Var(E[Z|Y]) = Var(Y)$.", "statement": "We assume:\n\u2022 X and Y are independent random variables [tc_1];\n\u2022 X follows a Uniform distribution on the interval (0, 1) [tc_2];\n\u2022 Y is a discrete random variable with probability mass function P(Y=1) = p and P(Y=-1) = 1-p for some p in (0,1) [tc_3];\n\u2022 The random variable Z is defined as Z = X+Y [tc_4];\n\u2022 The expectation of X is E[X] = 1/2 [l1];\n\u2022 The expectation of Y is E[Y] = 2p - 1 [l2];\n\u2022 The expectation of Z is E[Z] = E[X] + E[Y] [l3];\n\u2022 The expectation of Z is E[Z] = 2p - 1/2 [ts_1];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X|Y] + E[Y|Y] [l4];\n\u2022 The conditional expectation of X given Y is E[X|Y] = E[X] [l5];\n\u2022 The conditional expectation of Y given Y is E[Y|Y] = Y [l6];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = E[X] + Y [l7];\n\u2022 The conditional expectation of Z given Y is E[Z|Y] = Y + 1/2 [ts_2];\n\u2022 The variance of the conditional expectation is Var(E[Z|Y]) = Var(Y + 1/2) [l8];\n\u2022 The variance is invariant to adding a constant: Var(Y + 1/2) = Var(Y) [l9];\nTherefore, we conclude:\n\u2022 The variance of the conditional expectation is Var(E[Z|Y]) = Var(Y) [ts_3].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "ts_1", "l4", "l5", "l6", "l7", "ts_2", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3\n  (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1)\n  -- Given: X ~ Uniform(0,1), Y discrete with P(Y=1) = p, P(Y=-1) = 1-p\n  -- Z = X + Y, and we have established that E[Z|Y] = Y + 1/2\n  : -- The variance of the conditional expectation equals the variance of Y\n  let Var_Y := p * (1 - p)  -- Variance of discrete Y with P(Y=1) = p, P(Y=-1) = 1-p\n  let Var_EZ_given_Y := p * (1 - p)  -- Variance of E[Z|Y] = Y + 1/2\n  Var_EZ_given_Y = Var_Y := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_3\n  (p : \u211d) (h_p_pos : 0 < p) (h_p_lt_one : p < 1)\n  : \n  let Var_Y := p * (1 - p)\n  let Var_EZ_given_Y := p * (1 - p)\n  Var_EZ_given_Y = Var_Y := by\n  intro Var_Y Var_EZ_given_Y\n  have h_main : Var_EZ_given_Y = Var_Y := by\n    dsimp only [Var_Y, Var_EZ_given_Y]\n    <;> ring_nf\n    <;> linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization fails to capture the essential mathematical content of the natural language. It's missing the foundational probability theory setup (random variables X, Y, Z and their distributions), the independence assumption, all intermediate derivation steps involving expectations and conditional expectations, and the actual variance calculations. Instead, it only provides a trivial equality between two identical expressions, which doesn't demonstrate the mathematical reasoning described in the natural language.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization fails to capture the essential mathematical content of the natural language. It's missing the foundational probability theory setup (random variables X, Y, Z and their distributions), the independence assumption, all intermediate derivation steps involving expectations and conditional expectations, and the actual variance calculations. Instead, it only provides a trivial equality between two identical expressions, which doesn't demonstrate the mathematical reasoning described in the natural language.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_3", "label": "ts_3", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_2", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    