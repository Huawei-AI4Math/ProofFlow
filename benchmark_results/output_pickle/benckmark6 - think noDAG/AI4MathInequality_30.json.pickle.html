
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $a, b, c, x, y, z$ such that $a x + b y + c z = x y z$, the following inequality holds: $\\sqrt{a+b} + \\sqrt{b+c} + \\sqrt{c+a} < x + y + z$.

Proof: Let $u=	frac{a}{yz}, v=	frac{b}{xz}, w=	frac{c}{xy}$. From $ax+by+cz=xyz$, dividing through by $xyz$ yields $	frac{a}{yz}+	frac{b}{xz}+	frac{c}{xy}=1$, so $u+v+w=1$. Substituting $a=uyz$, $b=vxz$, and $c=wxy$ into the target inequality $\sqrt{a+b}+\sqrt{b+c}+\sqrt{c+a}<x+y+z$ gives $\sqrt{z(uy+vx)}+\sqrt{x(vz+wy)}+\sqrt{y(wx+uz)}<x+y+z$. Denote these radicals by $A=\sqrt{z(uy+vx)}, B=\sqrt{x(vz+wy)}, C=\sqrt{y(wx+uz)}$. Then we must prove $(A+B+C)^2<(x+y+z)^2$. By the Cauchyâ€“Schwarz inequality with vectors $(\sqrt{z},\sqrt{x},\sqrt{y})$ and $(\sqrt{uy+vx},\sqrt{vz+wy},\sqrt{wx+uz})$, we obtain $(A+B+C)^2\le (x+y+z)ig((uy+vx)+(vz+wy)+(wx+uz)ig)$. Setting $S=(uy+vx)+(vz+wy)+(wx+uz)$, observe that $S=u(y+z)+v(x+z)+w(x+y)$. Since $u+v+w=1$, we rewrite this as $S=(u+v+w)(x+y+z)-(ux+vy+wz)=(x+y+z)-(ux+vy+wz)$. As $u,v,w,x,y,z>0$, we have $ux+vy+wz>0$, hence $S<x+y+z$. Therefore $(A+B+C)^2\le(x+y+z)S<(x+y+z)(x+y+z)=(x+y+z)^2$. Taking square roots, we conclude $\sqrt{z(uy+vx)}+\sqrt{x(vz+wy)}+\sqrt{y(wx+uz)}<x+y+z$, which establishes the desired inequality.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "for all positive real numbers $a, b, c, x, y, z$", "statement": "Premise:\n\u2022 a, b, c, x, y, z are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem (a b c x y z : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by sorry", "lean_pass": false, "error_msg": [{"line": 7, "column": 7, "endLine": 7, "endColumn": 9, "data": "unexpected token '('; expected identifier"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "$a x + b y + c z = x y z$", "statement": "Premise:\n\u2022 a, b, c, x, y, z are positive real numbers [tc_1].\n\u2022 $a x + b y + c z = x y z$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (a b c x y z : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c, x, y, z are positive real numbers through the type declaration (a b c x y z : \u211d) and the positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)", "The constraint a * x + b * y + c * z = x * y * z in Lean perfectly matches the mathematical equation ax + by + cz = xyz from the natural language", "The natural language states there are no new derived facts and only presents the given premises. However, the Lean formalization introduces a completely new conclusion: Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z, which is not mentioned anywhere in the natural language statement. This is a major logical inconsistency as it adds a substantive mathematical claim not present in the original statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c, x, y, z are positive real numbers through the type declaration (a b c x y z : \u211d) and the positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)', 'The constraint a * x + b * y + c * z = x * y * z in Lean perfectly matches the mathematical equation ax + by + cz = xyz from the natural language', 'The natural language states there are no new derived facts and only presents the given premises. However, the Lean formalization introduces a completely new conclusion: Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z, which is not mentioned anywhere in the natural language statement. This is a major logical inconsistency as it adds a substantive mathematical claim not present in the original statement']"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $u=\tfrac{a}{yz}, v=\tfrac{b}{xz}, w=\tfrac{c}{xy}$.", "statement": "Definition:\n\u2022 Let a, b, c, x, y, z be positive real numbers [tc_1].\n\u2022 Let $u = a/(y*z)$, $v = b/(x*z)$, and $w = c/(x*y)$ [def_1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (a b c x y z : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c, x, y, z are positive real numbers through explicit positivity conditions (ha : 0 < a), etc., which perfectly matches the natural language condition.", "The Lean conclusion 'Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z' is completely different from the natural language conclusions which define u, v, w with specific division formulas. Additionally, the Lean code introduces an extra constraint 'a * x + b * y + c * z = x * y * z' that is not mentioned in the natural language at all. This represents a major inconsistency as the core mathematical content is entirely different."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c, x, y, z are positive real numbers through explicit positivity conditions (ha : 0 < a), etc., which perfectly matches the natural language condition.', \"The Lean conclusion 'Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z' is completely different from the natural language conclusions which define u, v, w with specific division formulas. Additionally, the Lean code introduces an extra constraint 'a * x + b * y + c * z = x * y * z' that is not mentioned in the natural language at all. This represents a major inconsistency as the core mathematical content is entirely different.\"]"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From $ax+by+cz=xyz$, dividing through by $xyz$ yields $\tfrac{a}{yz}+\tfrac{b}{xz}+\tfrac{c}{xy}=1$", "statement": "We assume:\n\u2022 a, b, c, x, y, z are positive real numbers [tc_1].\n\u2022 $a x + b y + c z = x y z$ [tc_2].\n\u2022 u, v, w are defined as $u = a/(y*z)$, $v = b/(x*z)$, and $w = c/(x*y)$ [def_1].\nTherefore, we conclude:\n\u2022 $a/(y*z) + b/(x*z) + c/(x*y) = 1$ [l1].", "dependencies": ["tc_1", "tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  a / (y * z) + b / (x * z) + c / (x * y) = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  a / (y * z) + b / (x * z) + c / (x * y) = 1 := by\n  have h_pos : 0 < x * y * z := by\n    have h\u2081 : 0 < x * y := mul_pos hx hy\n    have h\u2082 : 0 < x * y * z := mul_pos h\u2081 hz\n    exact h\u2082\n  \n  have h_div : (a * x + b * y + c * z) / (x * y * z) = 1 := by\n    have h\u2081 : (a * x + b * y + c * z) = x * y * z := by\n      linarith\n    rw [h\u2081]\n    field_simp [h_pos.ne']\n    <;>\n    ring_nf\n    <;>\n    field_simp [h_pos.ne']\n    <;>\n    nlinarith\n  \n  have h_split : a * x / (x * y * z) + b * y / (x * y * z) + c * z / (x * y * z) = 1 := by\n    have h\u2081 : a * x / (x * y * z) + b * y / (x * y * z) + c * z / (x * y * z) = (a * x + b * y + c * z) / (x * y * z) := by\n      have h\u2082 : a * x / (x * y * z) + b * y / (x * y * z) + c * z / (x * y * z) = (a * x + b * y + c * z) / (x * y * z) := by\n        ring_nf\n        <;> field_simp [h_pos.ne']\n        <;> ring_nf\n      rw [h\u2082]\n    rw [h\u2081]\n    rw [h_div]\n    <;>\n    ring_nf\n    <;>\n    field_simp [h_pos.ne']\n    <;>\n    nlinarith\n  \n  have h_simplify1 : a * x / (x * y * z) = a / (y * z) := by\n    have h\u2081 : a * x / (x * y * z) = a / (y * z) := by\n      have h\u2082 : x \u2260 0 := by linarith\n      have h\u2083 : y \u2260 0 := by linarith\n      have h\u2084 : z \u2260 0 := by linarith\n      have h\u2085 : y * z \u2260 0 := by positivity\n      have h\u2086 : x * y * z \u2260 0 := by positivity\n      -- Simplify the fraction by canceling x in the numerator and denominator\n      calc\n        a * x / (x * y * z) = (a * x) / (x * (y * z)) := by ring_nf\n        _ = a / (y * z) := by\n          have h\u2087 : (a * x) / (x * (y * z)) = a / (y * z) := by\n            -- Cancel x in the numerator and denominator\n            field_simp [h\u2082, h\u2083, h\u2084, h\u2085, h\u2086]\n            <;> ring_nf\n            <;> field_simp [h\u2082, h\u2083, h\u2084, h\u2085, h\u2086]\n            <;> ring_nf\n            <;> linarith\n          rw [h\u2087]\n    rw [h\u2081]\n  \n  have h_simplify2 : b * y / (x * y * z) = b / (x * z) := by\n    have h\u2081 : b * y / (x * y * z) = b / (x * z) := by\n      have h\u2082 : x \u2260 0 := by linarith\n      have h\u2083 : y \u2260 0 := by linarith\n      have h\u2084 : z \u2260 0 := by linarith\n      have h\u2085 : x * z \u2260 0 := by positivity\n      have h\u2086 : x * y * z \u2260 0 := by positivity\n      -- Simplify the fraction by canceling y in the numerator and denominator\n      calc\n        b * y / (x * y * z) = (b * y) / (y * (x * z)) := by ring_nf\n        _ = b / (x * z) := by\n          have h\u2087 : (b * y) / (y * (x * z)) = b / (x * z) := by\n            -- Cancel y in the numerator and denominator\n            field_simp [h\u2082, h\u2083, h\u2084, h\u2085, h\u2086]\n            <;> ring_nf\n            <;> field_simp [h\u2082, h\u2083, h\u2084, h\u2085, h\u2086]\n            <;> ring_nf\n            <;> linarith\n          rw [h\u2087]\n    rw [h\u2081]\n  \n  have h_simplify3 : c * z / (x * y * z) = c / (x * y) := by\n    have h\u2081 : c * z / (x * y * z) = c / (x * y) := by\n      have h\u2082 : x \u2260 0 := by linarith\n      have h\u2083 : y \u2260 0 := by linarith\n      have h\u2084 : z \u2260 0 := by linarith\n      have h\u2085 : x * y \u2260 0 := by positivity\n      have h\u2086 : x * y * z \u2260 0 := by positivity\n      -- Simplify the fraction by canceling z in the numerator and denominator\n      calc\n        c * z / (x * y * z) = (c * z) / (z * (x * y)) := by ring_nf\n        _ = c / (x * y) := by\n          have h\u2087 : (c * z) / (z * (x * y)) = c / (x * y) := by\n            -- Cancel z in the numerator and denominator\n            field_simp [h\u2082, h\u2083, h\u2084, h\u2085, h\u2086]\n            <;> ring_nf\n            <;> field_simp [h\u2082, h\u2083, h\u2084, h\u2085, h\u2086]\n            <;> ring_nf\n            <;> linarith\n          rw [h\u2087]\n    rw [h\u2081]\n  \n  have h_final : a / (y * z) + b / (x * z) + c / (x * y) = 1 := by\n    calc\n      a / (y * z) + b / (x * z) + c / (x * y) = (a / (y * z)) + (b / (x * z)) + (c / (x * y)) := by rfl\n      _ = (a * x / (x * y * z) + b * y / (x * y * z) + c * z / (x * y * z)) := by\n        rw [h_simplify1, h_simplify2, h_simplify3]\n        <;> ring_nf\n      _ = 1 := by\n        rw [h_split]\n      _ = 1 := by rfl\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate Lean syntax", "The constraint equation is perfectly translated with correct mathematical operators and precedence", "The intermediate variable definitions u, v, w are not explicitly declared in Lean, but this doesn't affect the mathematical meaning since they're not used in the final statement", "The conclusion statement matches exactly between natural language and Lean formalization"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "so $u+v+w=1$.", "statement": "We assume:\n\u2022 a, b, c, x, y, z are positive real numbers [tc_1].\n\u2022 $a x + b y + c z = x y z$ [tc_2].\n\u2022 u, v, w are defined as $u = a/(y*z)$, $v = b/(x*z)$, and $w = c/(x*y)$ [def_1].\n\u2022 $a/(y*z) + b/(x*z) + c/(x*y) = 1$ [l1].\nTherefore, we conclude:\n\u2022 $u + v + w = 1$ [l2].", "dependencies": ["tc_1", "tc_2", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  let u := a / (y * z)\n  let v := b / (x * z)  \n  let w := c / (x * y)\n  u + v + w = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z) :\n  let u := a / (y * z)\n  let v := b / (x * z)  \n  let w := c / (x * y)\n  u + v + w = 1 := by\n  have h_denom_pos : 0 < x * y * z := by\n    have h\u2081 : 0 < x * y := mul_pos hx hy\n    have h\u2082 : 0 < x * y * z := mul_pos h\u2081 hz\n    exact h\u2082\n  \n  have h_sum_div : (a * x + b * y + c * z) / (x * y * z) = 1 := by\n    have h\u2081 : (a * x + b * y + c * z) = x * y * z := by linarith\n    rw [h\u2081]\n    field_simp [h_denom_pos.ne']\n    <;> ring_nf\n    <;> field_simp [h_denom_pos.ne']\n    <;> linarith\n  \n  have h_expand : (a * x) / (x * y * z) + (b * y) / (x * y * z) + (c * z) / (x * y * z) = 1 := by\n    have h\u2081 : (a * x) / (x * y * z) + (b * y) / (x * y * z) + (c * z) / (x * y * z) = (a * x + b * y + c * z) / (x * y * z) := by\n      have h\u2082 : (a * x) / (x * y * z) + (b * y) / (x * y * z) + (c * z) / (x * y * z) = (a * x + b * y + c * z) / (x * y * z) := by\n        -- Use the property of fractions to combine the terms\n        field_simp [h_denom_pos.ne']\n        <;> ring_nf\n        <;> field_simp [h_denom_pos.ne']\n        <;> linarith\n      rw [h\u2082]\n    rw [h\u2081]\n    rw [h_sum_div]\n    <;> simp [h_denom_pos.ne']\n    <;> ring_nf\n    <;> field_simp [h_denom_pos.ne']\n    <;> linarith\n  \n  have h_simplify_u : (a * x) / (x * y * z) = a / (y * z) := by\n    have h\u2081 : (a * x) / (x * y * z) = a / (y * z) := by\n      have h\u2082 : x \u2260 0 := by linarith\n      have h\u2083 : y \u2260 0 := by linarith\n      have h\u2084 : z \u2260 0 := by linarith\n      have h\u2085 : x * y \u2260 0 := by positivity\n      have h\u2086 : x * y * z \u2260 0 := by positivity\n      -- Simplify the fraction by canceling x in the numerator and denominator\n      calc\n        (a * x) / (x * y * z) = (a * x) / (x * (y * z)) := by ring\n        _ = a / (y * z) := by\n          have h\u2087 : x \u2260 0 := by linarith\n          have h\u2088 : y * z \u2260 0 := by positivity\n          field_simp [h\u2087, h\u2088]\n          <;> ring_nf\n          <;> field_simp [h\u2087, h\u2088]\n          <;> linarith\n    rw [h\u2081]\n  \n  have h_simplify_v : (b * y) / (x * y * z) = b / (x * z) := by\n    have h\u2081 : (b * y) / (x * y * z) = b / (x * z) := by\n      have h\u2082 : x \u2260 0 := by linarith\n      have h\u2083 : y \u2260 0 := by linarith\n      have h\u2084 : z \u2260 0 := by linarith\n      have h\u2085 : x * z \u2260 0 := by positivity\n      have h\u2086 : x * y * z \u2260 0 := by positivity\n      -- Simplify the fraction by canceling y in the numerator and denominator\n      calc\n        (b * y) / (x * y * z) = (b * y) / (y * (x * z)) := by ring\n        _ = b / (x * z) := by\n          have h\u2087 : y \u2260 0 := by linarith\n          have h\u2088 : x * z \u2260 0 := by positivity\n          field_simp [h\u2087, h\u2088]\n          <;> ring_nf\n          <;> field_simp [h\u2087, h\u2088]\n          <;> linarith\n    rw [h\u2081]\n  \n  have h_simplify_w : (c * z) / (x * y * z) = c / (x * y) := by\n    have h\u2081 : (c * z) / (x * y * z) = c / (x * y) := by\n      have h\u2082 : x \u2260 0 := by linarith\n      have h\u2083 : y \u2260 0 := by linarith\n      have h\u2084 : z \u2260 0 := by linarith\n      have h\u2085 : x * y \u2260 0 := by positivity\n      have h\u2086 : x * y * z \u2260 0 := by positivity\n      -- Simplify the fraction by canceling z in the numerator and denominator\n      calc\n        (c * z) / (x * y * z) = (c * z) / (z * (x * y)) := by ring\n        _ = c / (x * y) := by\n          have h\u2087 : z \u2260 0 := by linarith\n          have h\u2088 : x * y \u2260 0 := by positivity\n          field_simp [h\u2087, h\u2088]\n          <;> ring_nf\n          <;> field_simp [h\u2087, h\u2088]\n          <;> linarith\n    rw [h\u2081]\n  \n  have h_main : a / (y * z) + b / (x * z) + c / (x * y) = 1 := by\n    have h\u2081 : (a * x) / (x * y * z) + (b * y) / (x * y * z) + (c * z) / (x * y * z) = 1 := h_expand\n    have h\u2082 : (a * x) / (x * y * z) = a / (y * z) := h_simplify_u\n    have h\u2083 : (b * y) / (x * y * z) = b / (x * z) := h_simplify_v\n    have h\u2084 : (c * z) / (x * y * z) = c / (x * y) := h_simplify_w\n    calc\n      a / (y * z) + b / (x * z) + c / (x * y) = (a * x) / (x * y * z) + (b * y) / (x * y * z) + (c * z) / (x * y * z) := by\n        rw [h\u2082, h\u2083, h\u2084]\n        <;> ring\n      _ = 1 := by rw [h\u2081]\n  \n  intro u v w\n  have h_final : u + v + w = 1 := by\n    dsimp only [u, v, w] at *\n    -- Now we need to prove that a / (y * z) + b / (x * z) + c / (x * y) = 1\n    -- But we already have this as h_main\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured with appropriate Lean syntax for real numbers and strict inequalities.", "The main constraint equation is accurately translated with proper multiplication notation.", "Variable definitions using let bindings correctly capture the mathematical definitions of u, v, and w.", "The intermediate result [l1] is implicitly handled - while not stated as a separate assumption, it's mathematically equivalent to what needs to be proven given the definitions.", "The final conclusion is correctly stated as the goal to be proven, with the exact same mathematical expression as in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Substituting $a=uyz$, $b=vxz$, and $c=wxy$ into the target inequality $\\sqrt{a+b}+\\sqrt{b+c}+\\sqrt{c+a}<x+y+z$ gives $\\sqrt{z(uy+vx)}+\\sqrt{x(vz+wy)}+\\sqrt{y(wx+uz)}<x+y+z$.", "statement": "We assume:\n\u2022 a, b, c, x, y, z are positive real numbers [tc_1].\n\u2022 $a x + b y + c z = x y z$ [tc_2].\n\u2022 u, v, w are defined as $u = a/(y*z)$, $v = b/(x*z)$, and $w = c/(x*y)$ [def_1].\n\u2022 $u + v + w = 1$ [l2].\nTherefore, we conclude:\n\u2022 The inequality $\\sqrt{a+b}+\\sqrt{b+c}+\\sqrt{c+a}<x+y+z$ is equivalent to $\\sqrt{z(u*y+v*x)}+\\sqrt{x(v*z+w*y)}+\\sqrt{y(w*x+u*z)}<x+y+z$ [l3].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (u v w : \u211d)\n  (hu : u = a / (y * z))\n  (hv : v = b / (x * z))  \n  (hw : w = c / (x * y))\n  (h_sum : u + v + w = 1) :\n  (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z) \u2194\n  (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (u v w : \u211d)\n  (hu : u = a / (y * z))\n  (hv : v = b / (x * z))  \n  (hw : w = c / (x * y))\n  (h_sum : u + v + w = 1) :\n  (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z) \u2194\n  (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z) := by\n  have h1 : z * (u * y + v * x) = a + b := by\n    have h1\u2081 : z * (u * y + v * x) = z * u * y + z * v * x := by ring\n    rw [h1\u2081]\n    have h1\u2082 : z * u * y = a := by\n      have h1\u2083 : u = a / (y * z) := hu\n      rw [h1\u2083]\n      have h1\u2084 : 0 < y * z := mul_pos hy hz\n      field_simp [h1\u2084.ne']\n      <;> ring_nf\n      <;> field_simp [hx.ne', hy.ne', hz.ne']\n      <;> nlinarith [ha, hb, hc, hx, hy, hz]\n    have h1\u2083 : z * v * x = b := by\n      have h1\u2084 : v = b / (x * z) := hv\n      rw [h1\u2084]\n      have h1\u2085 : 0 < x * z := mul_pos hx hz\n      field_simp [h1\u2085.ne']\n      <;> ring_nf\n      <;> field_simp [hx.ne', hy.ne', hz.ne']\n      <;> nlinarith [ha, hb, hc, hx, hy, hz]\n    linarith\n  \n  have h2 : x * (v * z + w * y) = b + c := by\n    have h2\u2081 : x * (v * z + w * y) = x * v * z + x * w * y := by ring\n    rw [h2\u2081]\n    have h2\u2082 : x * v * z = b := by\n      have h2\u2083 : v = b / (x * z) := hv\n      rw [h2\u2083]\n      have h2\u2084 : 0 < x * z := mul_pos hx hz\n      field_simp [h2\u2084.ne']\n      <;> ring_nf\n      <;> field_simp [hx.ne', hy.ne', hz.ne']\n      <;> nlinarith [ha, hb, hc, hx, hy, hz]\n    have h2\u2083 : x * w * y = c := by\n      have h2\u2084 : w = c / (x * y) := hw\n      rw [h2\u2084]\n      have h2\u2085 : 0 < x * y := mul_pos hx hy\n      field_simp [h2\u2085.ne']\n      <;> ring_nf\n      <;> field_simp [hx.ne', hy.ne', hz.ne']\n      <;> nlinarith [ha, hb, hc, hx, hy, hz]\n    linarith\n  \n  have h3 : y * (w * x + u * z) = c + a := by\n    have h3\u2081 : y * (w * x + u * z) = y * w * x + y * u * z := by ring\n    rw [h3\u2081]\n    have h3\u2082 : y * w * x = c := by\n      have h3\u2083 : w = c / (x * y) := hw\n      rw [h3\u2083]\n      have h3\u2084 : 0 < x * y := mul_pos hx hy\n      field_simp [h3\u2084.ne']\n      <;> ring_nf\n      <;> field_simp [hx.ne', hy.ne', hz.ne']\n      <;> nlinarith [ha, hb, hc, hx, hy, hz]\n    have h3\u2083 : y * u * z = a := by\n      have h3\u2084 : u = a / (y * z) := hu\n      rw [h3\u2084]\n      have h3\u2085 : 0 < y * z := mul_pos hy hz\n      field_simp [h3\u2085.ne']\n      <;> ring_nf\n      <;> field_simp [hx.ne', hy.ne', hz.ne']\n      <;> nlinarith [ha, hb, hc, hx, hy, hz]\n    linarith\n  \n  have h4 : Real.sqrt (z * (u * y + v * x)) = Real.sqrt (a + b) := by\n    rw [h1]\n    <;>\n    simp [Real.sqrt_eq_iff_sq_eq]\n    <;>\n    nlinarith [ha, hb, hc, hx, hy, hz]\n  \n  have h5 : Real.sqrt (x * (v * z + w * y)) = Real.sqrt (b + c) := by\n    rw [h2]\n    <;>\n    simp [Real.sqrt_eq_iff_sq_eq]\n    <;>\n    nlinarith [ha, hb, hc, hx, hy, hz]\n  \n  have h6 : Real.sqrt (y * (w * x + u * z)) = Real.sqrt (c + a) := by\n    rw [h3]\n    <;>\n    simp [Real.sqrt_eq_iff_sq_eq]\n    <;>\n    nlinarith [ha, hb, hc, hx, hy, hz]\n  \n  have h_main : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z) \u2194 (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z) := by\n    constructor\n    \u00b7 -- Prove the forward direction: if LHS < x + y + z, then RHS < x + y + z\n      intro h\n      have h\u2087 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) = Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) := by\n        rw [h4, h5, h6]\n        <;> ring\n      linarith\n    \u00b7 -- Prove the reverse direction: if RHS < x + y + z, then LHS < x + y + z\n      intro h\n      have h\u2087 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) = Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) := by\n        rw [h4, h5, h6]\n        <;> ring\n      linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured with appropriate Lean syntax for real numbers and strict inequalities.", "The constraint equation a*x + b*y + c*z = x*y*z is perfectly translated with proper multiplication notation.", "All three variable definitions (u, v, w) are correctly formalized with proper division syntax and parentheses for denominators.", "The sum constraint u + v + w = 1 is exactly represented.", "The main equivalence statement perfectly captures both sides of the biconditional, with all square root expressions, products, sums, and the inequality correctly formalized using Real.sqrt and proper operator precedence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "Denote these radicals by $A=\\sqrt{z(uy+vx)}, B=\\sqrt{x(vz+wy)}, C=\\sqrt{y(wx+uz)}$.", "statement": "Definition:\n\u2022 Let $A = \\sqrt{z(u*y+v*x)}$, $B = \\sqrt{x(v*z+w*y)}$, and $C = \\sqrt{y(w*x+u*z)}$ [def_2].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c x y z u v w : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n\ntheorem def_2 :\n  let A := Real.sqrt (z * (u * y + v * x))\n  let B := Real.sqrt (x * (v * z + w * y))\n  let C := Real.sqrt (y * (w * x + u * z))\n  A + B + C < x + y + z := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The definition A := Real.sqrt (z * (u * y + v * x)) perfectly matches the natural language condition A = \u221a(z(u*y+v*x))", "The definition B := Real.sqrt (x * (v * z + w * y)) perfectly matches the natural language condition B = \u221a(x(v*z+w*y))", "The definition C := Real.sqrt (y * (w * x + u * z)) perfectly matches the natural language condition C = \u221a(y(w*x+u*z))", "The Lean formalization concludes with 'A + B + C < x + y + z' which is a completely different mathematical statement than the natural language conclusion that simply states the variables are defined according to the given expressions. This introduces a new inequality that was not present in the original statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The definition A := Real.sqrt (z * (u * y + v * x)) perfectly matches the natural language condition A = \u221a(z(u*y+v*x))', 'The definition B := Real.sqrt (x * (v * z + w * y)) perfectly matches the natural language condition B = \u221a(x(v*z+w*y))', 'The definition C := Real.sqrt (y * (w * x + u * z)) perfectly matches the natural language condition C = \u221a(y(w*x+u*z))', \"The Lean formalization concludes with 'A + B + C < x + y + z' which is a completely different mathematical statement than the natural language conclusion that simply states the variables are defined according to the given expressions. This introduces a new inequality that was not present in the original statement.\"]"}, "type": "definition"}, "l4": {"id": "l4", "natural_language": "By the Cauchy\u2013Schwarz inequality with vectors $(\\sqrt{z},\\sqrt{x},\\sqrt{y})$ and $(\\sqrt{uy+vx},\\sqrt{vz+wy},\\sqrt{wx+uz})$, we obtain $(A+B+C)^2\\le (x+y+z)((uy+vx)+(vz+wy)+(wx+uz))$.", "statement": "We assume:\n\u2022 $A = \\sqrt{z(u*y+v*x)}$, $B = \\sqrt{x(v*z+w*y)}$, and $C = \\sqrt{y(w*x+u*z)}$ [def_2].\nTherefore, we conclude:\n\u2022 $(A+B+C)^2 \\le (x+y+z) * ((u*y+v*x) + (v*z+w*y) + (w*x+u*z))$ [l4].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a b c x y z u v w : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (A B C : \u211d)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))\n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (l1 : a / (y * z) + b / (x * z) + c / (x * y) = 1)\n  (l2 : u + v + w = 1)\n  (l3 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z) :\n  (A + B + C)^2 \u2264 (x + y + z) * ((u * y + v * x) + (v * z + w * y) + (w * x + u * z)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a b c x y z u v w : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (A B C : \u211d)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))\n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (l1 : a / (y * z) + b / (x * z) + c / (x * y) = 1)\n  (l2 : u + v + w = 1)\n  (l3 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z) :\n  (A + B + C)^2 \u2264 (x + y + z) * ((u * y + v * x) + (v * z + w * y) + (w * x + u * z)) := by\n  have h_main : (A + B + C)^2 \u2264 (x + y + z) * ((u * y + v * x) + (v * z + w * y) + (w * x + u * z)) := by\n    have hA' : A = Real.sqrt (z * (u * y + v * x)) := hA\n    have hB' : B = Real.sqrt (x * (v * z + w * y)) := hB\n    have hC' : C = Real.sqrt (y * (w * x + u * z)) := hC\n    rw [hA', hB', hC']\n    have h\u2081 : 0 \u2264 Real.sqrt (z * (u * y + v * x)) := Real.sqrt_nonneg _\n    have h\u2082 : 0 \u2264 Real.sqrt (x * (v * z + w * y)) := Real.sqrt_nonneg _\n    have h\u2083 : 0 \u2264 Real.sqrt (y * (w * x + u * z)) := Real.sqrt_nonneg _\n    have h\u2084 : 0 \u2264 z := by linarith\n    have h\u2085 : 0 \u2264 x := by linarith\n    have h\u2086 : 0 \u2264 y := by linarith\n    have h\u2087 : 0 \u2264 u * y + v * x := by\n      have h\u2087\u2081 : 0 \u2264 u := by linarith\n      have h\u2087\u2082 : 0 \u2264 v := by linarith\n      have h\u2087\u2083 : 0 \u2264 x := by linarith\n      have h\u2087\u2084 : 0 \u2264 y := by linarith\n      nlinarith\n    have h\u2088 : 0 \u2264 v * z + w * y := by\n      have h\u2088\u2081 : 0 \u2264 v := by linarith\n      have h\u2088\u2082 : 0 \u2264 w := by linarith\n      have h\u2088\u2083 : 0 \u2264 z := by linarith\n      have h\u2088\u2084 : 0 \u2264 y := by linarith\n      nlinarith\n    have h\u2089 : 0 \u2264 w * x + u * z := by\n      have h\u2089\u2081 : 0 \u2264 w := by linarith\n      have h\u2089\u2082 : 0 \u2264 u := by linarith\n      have h\u2089\u2083 : 0 \u2264 x := by linarith\n      have h\u2089\u2084 : 0 \u2264 z := by linarith\n      nlinarith\n    have h\u2081\u2080 : 0 \u2264 z * (u * y + v * x) := by positivity\n    have h\u2081\u2081 : 0 \u2264 x * (v * z + w * y) := by positivity\n    have h\u2081\u2082 : 0 \u2264 y * (w * x + u * z) := by positivity\n    have h\u2081\u2083 : (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 \u2264 ( (z * (u * y + v * x) / z + x * (v * z + w * y) / x + y * (w * x + u * z) / y ) * (z + x + y) ) := by\n      have h\u2081\u2084 : 0 < z := by linarith\n      have h\u2081\u2085 : 0 < x := by linarith\n      have h\u2081\u2086 : 0 < y := by linarith\n      have h\u2081\u2087 : 0 \u2264 z * (u * y + v * x) / z := by positivity\n      have h\u2081\u2088 : 0 \u2264 x * (v * z + w * y) / x := by positivity\n      have h\u2081\u2089 : 0 \u2264 y * (w * x + u * z) / y := by positivity\n      have h\u2082\u2080 : (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 = (Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt z + Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt x + Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt y) ^ 2 := by\n        have h\u2082\u2081 : Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt z = Real.sqrt (z * (u * y + v * x)) := by\n          have h\u2082\u2082 : 0 \u2264 z * (u * y + v * x) / z := by positivity\n          have h\u2082\u2083 : 0 \u2264 z := by linarith\n          have h\u2082\u2084 : Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt z = Real.sqrt ((z * (u * y + v * x) / z) * z) := by\n            rw [\u2190 Real.sqrt_mul] <;> positivity\n          have h\u2082\u2085 : (z * (u * y + v * x) / z) * z = z * (u * y + v * x) := by\n            field_simp [h\u2081\u2084.ne']\n            <;> ring\n          rw [h\u2082\u2084, h\u2082\u2085]\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;>\n            nlinarith [Real.sqrt_nonneg (z * (u * y + v * x)), Real.sq_sqrt (show 0 \u2264 z * (u * y + v * x) by positivity)]\n        have h\u2082\u2086 : Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt x = Real.sqrt (x * (v * z + w * y)) := by\n          have h\u2082\u2087 : 0 \u2264 x * (v * z + w * y) / x := by positivity\n          have h\u2082\u2088 : 0 \u2264 x := by linarith\n          have h\u2082\u2089 : Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt x = Real.sqrt ((x * (v * z + w * y) / x) * x) := by\n            rw [\u2190 Real.sqrt_mul] <;> positivity\n          have h\u2083\u2080 : (x * (v * z + w * y) / x) * x = x * (v * z + w * y) := by\n            field_simp [h\u2081\u2085.ne']\n            <;> ring\n          rw [h\u2082\u2089, h\u2083\u2080]\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;>\n            nlinarith [Real.sqrt_nonneg (x * (v * z + w * y)), Real.sq_sqrt (show 0 \u2264 x * (v * z + w * y) by positivity)]\n        have h\u2083\u2081 : Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt y = Real.sqrt (y * (w * x + u * z)) := by\n          have h\u2083\u2082 : 0 \u2264 y * (w * x + u * z) / y := by positivity\n          have h\u2083\u2083 : 0 \u2264 y := by linarith\n          have h\u2083\u2084 : Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt y = Real.sqrt ((y * (w * x + u * z) / y) * y) := by\n            rw [\u2190 Real.sqrt_mul] <;> positivity\n          have h\u2083\u2085 : (y * (w * x + u * z) / y) * y = y * (w * x + u * z) := by\n            field_simp [h\u2081\u2086.ne']\n            <;> ring\n          rw [h\u2083\u2084, h\u2083\u2085]\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;>\n            nlinarith [Real.sqrt_nonneg (y * (w * x + u * z)), Real.sq_sqrt (show 0 \u2264 y * (w * x + u * z) by positivity)]\n        calc\n          (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 = (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 := by rfl\n          _ = (Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt z + Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt x + Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt y) ^ 2 := by\n            rw [h\u2082\u2081, h\u2082\u2086, h\u2083\u2081]\n            <;> ring_nf\n      rw [h\u2082\u2080]\n      have h\u2083\u2086 : (Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt z + Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt x + Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt y) ^ 2 \u2264 ( (z * (u * y + v * x) / z + x * (v * z + w * y) / x + y * (w * x + u * z) / y ) * (z + x + y) ) := by\n        have h\u2083\u2087 : 0 \u2264 Real.sqrt (z * (u * y + v * x) / z) := Real.sqrt_nonneg _\n        have h\u2083\u2088 : 0 \u2264 Real.sqrt (x * (v * z + w * y) / x) := Real.sqrt_nonneg _\n        have h\u2083\u2089 : 0 \u2264 Real.sqrt (y * (w * x + u * z) / y) := Real.sqrt_nonneg _\n        have h\u2084\u2080 : 0 \u2264 Real.sqrt z := Real.sqrt_nonneg _\n        have h\u2084\u2081 : 0 \u2264 Real.sqrt x := Real.sqrt_nonneg _\n        have h\u2084\u2082 : 0 \u2264 Real.sqrt y := Real.sqrt_nonneg _\n        have h\u2084\u2083 : (Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt z + Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt x + Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt y) ^ 2 \u2264 ((Real.sqrt (z * (u * y + v * x) / z)) ^ 2 + (Real.sqrt (x * (v * z + w * y) / x)) ^ 2 + (Real.sqrt (y * (w * x + u * z) / y)) ^ 2) * ((Real.sqrt z) ^ 2 + (Real.sqrt x) ^ 2 + (Real.sqrt y) ^ 2) := by\n          nlinarith [sq_nonneg (Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt x - Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt z),\n            sq_nonneg (Real.sqrt (z * (u * y + v * x) / z) * Real.sqrt y - Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt z),\n            sq_nonneg (Real.sqrt (x * (v * z + w * y) / x) * Real.sqrt y - Real.sqrt (y * (w * x + u * z) / y) * Real.sqrt x)]\n        have h\u2084\u2084 : (Real.sqrt (z * (u * y + v * x) / z)) ^ 2 = z * (u * y + v * x) / z := by\n          rw [Real.sq_sqrt] <;> positivity\n        have h\u2084\u2085 : (Real.sqrt (x * (v * z + w * y) / x)) ^ 2 = x * (v * z + w * y) / x := by\n          rw [Real.sq_sqrt] <;> positivity\n        have h\u2084\u2086 : (Real.sqrt (y * (w * x + u * z) / y)) ^ 2 = y * (w * x + u * z) / y := by\n          rw [Real.sq_sqrt] <;> positivity\n        have h\u2084\u2087 : (Real.sqrt z) ^ 2 = z := by\n          rw [Real.sq_sqrt] <;> linarith\n        have h\u2084\u2088 : (Real.sqrt x) ^ 2 = x := by\n          rw [Real.sq_sqrt] <;> linarith\n        have h\u2084\u2089 : (Real.sqrt y) ^ 2 = y := by\n          rw [Real.sq_sqrt] <;> linarith\n        have h\u2085\u2080 : ((Real.sqrt (z * (u * y + v * x) / z)) ^ 2 + (Real.sqrt (x * (v * z + w * y) / x)) ^ 2 + (Real.sqrt (y * (w * x + u * z) / y)) ^ 2) * ((Real.sqrt z) ^ 2 + (Real.sqrt x) ^ 2 + (Real.sqrt y) ^ 2) = (z * (u * y + v * x) / z + x * (v * z + w * y) / x + y * (w * x + u * z) / y) * (z + x + y) := by\n          rw [h\u2084\u2084, h\u2084\u2085, h\u2084\u2086, h\u2084\u2087, h\u2084\u2088, h\u2084\u2089]\n          <;> ring_nf\n        nlinarith\n      linarith\n    have h\u2085\u2081 : (z * (u * y + v * x) / z + x * (v * z + w * y) / x + y * (w * x + u * z) / y) * (z + x + y) = ( (u * y + v * x) + (v * z + w * y) + (w * x + u * z) ) * (z + x + y) := by\n      have h\u2085\u2082 : z * (u * y + v * x) / z = u * y + v * x := by\n        have h\u2085\u2083 : z \u2260 0 := by linarith\n        field_simp [h\u2085\u2083]\n        <;> ring\n      have h\u2085\u2084 : x * (v * z + w * y) / x = v * z + w * y := by\n        have h\u2085\u2085 : x \u2260 0 := by linarith\n        field_simp [h\u2085\u2085]\n        <;> ring\n      have h\u2085\u2086 : y * (w * x + u * z) / y = w * x + u * z := by\n        have h\u2085\u2087 : y \u2260 0 := by linarith\n        field_simp [h\u2085\u2087]\n        <;> ring\n      rw [h\u2085\u2082, h\u2085\u2084, h\u2085\u2086]\n      <;> ring_nf\n      <;> nlinarith\n    have h\u2085\u2088 : (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 \u2264 ( (u * y + v * x) + (v * z + w * y) + (w * x + u * z) ) * (z + x + y) := by\n      linarith\n    have h\u2085\u2089 : (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 = (Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z))) ^ 2 := by rfl\n    have h\u2086\u2080 : ( (u * y + v * x) + (v * z + w * y) + (w * x + u * z) ) * (z + x + y) = (x + y + z) * ((u * y + v * x) + (v * z + w * y) + (w * x + u * z)) := by ring\n    nlinarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The definitions of A, B, and C are perfectly translated from natural language to Lean, with identical mathematical expressions using appropriate Lean syntax for square roots and arithmetic operations.", "The main inequality conclusion is perfectly captured in Lean with the same mathematical structure. The Lean formalization includes many additional assumptions and constraints not mentioned in the natural language, but these are extra conditions that don't contradict the stated premise and conclusion - they appear to provide necessary context for proving the theorem. The core logical relationship between the assumptions and conclusion is preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "Setting $S=(uy+vx)+(vz+wy)+(wx+uz)$", "statement": "Definition:\n\u2022 Let $S = (u*y+v*x) + (v*z+w*y) + (w*x+u*z)$ [def_3].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (u v w x y z : \u211d)\nvariable (hu : 0 < u) (hv : 0 < v) (hw : 0 < w) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n\ndef S : \u211d := (u * y + v * x) + (v * z + w * y) + (w * x + u * z)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The natural language states no conditions, while Lean adds positivity constraints (0 < u, 0 < v, etc.) for all variables. However, these are extra conditions that don't contradict the natural language definition and are logically consistent additions.", "The Lean definition perfectly captures the mathematical expression S = (u*y+v*x) + (v*z+w*y) + (w*x+u*z). The structure, grouping, and order of terms are identical."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "observe that $S=u(y+z)+v(x+z)+w(x+y)$. Since $u+v+w=1$, we rewrite this as $S=(u+v+w)(x+y+z)-(ux+vy+wz)$.", "statement": "We assume:\n\u2022 $S = (u*y+v*x) + (v*z+w*y) + (w*x+u*z)$ [def_3].\nTherefore, we conclude:\n\u2022 $S = (u+v+w)*(x+y+z) - (u*x+v*y+w*z)$ [l5].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (d : \u211d) (h : 2 * d = 6) : d = 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 (d : \u211d) (h : 2 * d = 6) : d = 3 := by\n  have h_main : d = 3 := by\n    -- Divide both sides of the equation 2 * d = 6 by 2 to solve for d\n    have h\u2081 : d = 3 := by\n      -- Use the fact that 2 is non-zero to divide both sides by 2\n      apply mul_left_cancel\u2080 (show (2 : \u211d) \u2260 0 by norm_num)\n      -- Simplify the equation 2 * d = 6 to d = 3\n      linarith\n    -- The result is d = 3\n    exact h\u2081\n  \n  -- The final result follows directly from h_main\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization is completely unrelated to the natural language statement. The natural language describes an algebraic identity involving 6 variables (u, v, w, x, y, z) and polynomial expressions, while the Lean theorem is about solving a simple linear equation '2*d = 6' to conclude 'd = 3'. The mathematical content, variables, and logical structure are entirely different."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization is completely unrelated to the natural language statement. The natural language describes an algebraic identity involving 6 variables (u, v, w, x, y, z) and polynomial expressions, while the Lean theorem is about solving a simple linear equation '2*d = 6' to conclude 'd = 3'. The mathematical content, variables, and logical structure are entirely different.\"]"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "S=(u+v+w)(x+y+z)-(ux+vy+wz)=(x+y+z)-(ux+vy+wz).", "statement": "We assume:\n\u2022 $u + v + w = 1$ [l2].\n\u2022 $S = (u+v+w)*(x+y+z) - (u*x+v*y+w*z)$ [l5].\nTherefore, we conclude:\n\u2022 $S = (x+y+z) - (u*x+v*y+w*z)$ [l6].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (u v w x y z : \u211d)\n  (l2 : u + v + w = 1)\n  (l5 : (u + v + w) * (x + y + z) - (u * x + v * y + w * z) = (x + y + z) - (u * x + v * y + w * z)) :\n  (u + v + w) * (x + y + z) - (u * x + v * y + w * z) = (x + y + z) - (u * x + v * y + w * z) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (u v w x y z : \u211d)\n  (l2 : u + v + w = 1)\n  (l5 : (u + v + w) * (x + y + z) - (u * x + v * y + w * z) = (x + y + z) - (u * x + v * y + w * z)) :\n  (u + v + w) * (x + y + z) - (u * x + v * y + w * z) = (x + y + z) - (u * x + v * y + w * z) := by\n  have h_main : (u + v + w) * (x + y + z) - (u * x + v * y + w * z) = (x + y + z) - (u * x + v * y + w * z) := by\n    exact l5\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization has major structural problems: (1) It completely omits the variable S that is central to the natural language argument, (2) It treats the conclusion as an assumption rather than deriving it from the given premises, and (3) The logical flow is circular - assuming what should be proven. The natural language presents a derivation where l2 is substituted into l5 to obtain l6, but the Lean version makes this derivation trivial by assuming the result."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization has major structural problems: (1) It completely omits the variable S that is central to the natural language argument, (2) It treats the conclusion as an assumption rather than deriving it from the given premises, and (3) The logical flow is circular - assuming what should be proven. The natural language presents a derivation where l2 is substituted into l5 to obtain l6, but the Lean version makes this derivation trivial by assuming the result.']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "As $u,v,w,x,y,z>0$", "statement": "We assume:\n\u2022 a, b, c, x, y, z are positive real numbers [tc_1].\n\u2022 u, v, w are defined as $u = a/(y*z)$, $v = b/(x*z)$, and $w = c/(x*y)$ [def_1].\nTherefore, we conclude:\n\u2022 $u > 0, v > 0, w > 0$ [l7].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (u v w : \u211d)\n  (hu : u = a / (y * z))\n  (hv : v = b / (x * z))  \n  (hw : w = c / (x * y))\n  (h_sum : u + v + w = 1) :\n  0 < u \u2227 0 < v \u2227 0 < w := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a b c x y z : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (u v w : \u211d)\n  (hu : u = a / (y * z))\n  (hv : v = b / (x * z))  \n  (hw : w = c / (x * y))\n  (h_sum : u + v + w = 1) :\n  0 < u \u2227 0 < v \u2227 0 < w := by\n  have h_u_pos : 0 < u := by\n    rw [hu]\n    have h\u2081 : 0 < y * z := mul_pos hy hz\n    have h\u2082 : 0 < a := ha\n    exact div_pos h\u2082 h\u2081\n  \n  have h_v_pos : 0 < v := by\n    rw [hv]\n    have h\u2081 : 0 < x * z := mul_pos hx hz\n    have h\u2082 : 0 < b := hb\n    exact div_pos h\u2082 h\u2081\n  \n  have h_w_pos : 0 < w := by\n    rw [hw]\n    have h\u2081 : 0 < x * y := mul_pos hx hy\n    have h\u2082 : 0 < c := hc\n    exact div_pos h\u2082 h\u2081\n  \n  have h_main : 0 < u \u2227 0 < v \u2227 0 < w := by\n    refine' \u27e8h_u_pos, h_v_pos, h_w_pos\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the logical and mathematical meaning from the natural language. The variable declarations, definitions, and conclusion are accurately represented. While the Lean code includes two additional constraints (h_constraint and h_sum) not mentioned in the natural language, these are extra conditions that don't contradict the stated premises and are consistent with the mathematical context. All core statements from the natural language are properly formalized."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "we have $ux+vy+wz>0$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1].\n\u2022 $u > 0, v > 0, w > 0$ [l7].\nTherefore, we conclude:\n\u2022 $u*x + v*y + w*z > 0$ [l8].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (x y z u v w : \u211d)\n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w) :\n  u * x + v * y + w * z > 0 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (x y z u v w : \u211d)\n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w) :\n  u * x + v * y + w * z > 0 := by\n  have h\u2081 : u * x > 0 := by\n    -- Since u and x are positive, their product is positive.\n    have h : 0 < u * x := mul_pos hu hx\n    linarith\n  \n  have h\u2082 : v * y > 0 := by\n    -- Since v and y are positive, their product is positive.\n    have h : 0 < v * y := mul_pos hv hy\n    linarith\n  \n  have h\u2083 : w * z > 0 := by\n    -- Since w and z are positive, their product is positive.\n    have h : 0 < w * z := mul_pos hw hz\n    linarith\n  \n  have h\u2084 : u * x + v * y + w * z > 0 := by\n    -- Since each term is positive, their sum is also positive.\n    have h\u2085 : u * x + v * y + w * z > 0 := by\n      -- Use the fact that the sum of positive numbers is positive.\n      linarith\n    exact h\u2085\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints for x, y, z are correctly captured in Lean with appropriate real number types and positivity hypotheses", "Additional positivity constraints for u, v, w are correctly represented with equivalent mathematical notation (0 < u is same as u > 0)", "The conclusion expression u*x + v*y + w*z > 0 is identically represented in both natural language and Lean", "The logical structure from assumptions to conclusion is properly maintained in the theorem format, with all premises as hypotheses leading to the stated conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "hence $S<x+y+z$", "statement": "We assume:\n\u2022 $S = (x+y+z) - (u*x+v*y+w*z)$ [l6].\n\u2022 $u*x + v*y + w*z > 0$ [l8].\nTherefore, we conclude:\n\u2022 $S < x+y+z$ [l9].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 \n  (u v w x y z : \u211d)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_pos : u * x + v * y + w * z > 0) :\n  (x + y + z) - (u * x + v * y + w * z) < x + y + z := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 \n  (u v w x y z : \u211d)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (h_pos : u * x + v * y + w * z > 0) :\n  (x + y + z) - (u * x + v * y + w * z) < x + y + z := by\n  have h_main : (x + y + z) - (u * x + v * y + w * z) < x + y + z := by\n    -- Use the lemma `sub_lt_self` which states that if `b > 0`, then `a - b < a`.\n    have h : (x + y + z) - (u * x + v * y + w * z) < x + y + z := by\n      -- Apply the lemma `sub_lt_self` with `a = x + y + z` and `b = u * x + v * y + w * z`.\n      apply sub_lt_self\n      -- Confirm that `u * x + v * y + w * z > 0`.\n      <;> linarith\n    -- The result follows directly from the lemma.\n    exact h\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture all mentioned variables as real numbers", "The definition of S is correctly represented in the conclusion through substitution", "The assumption about u*x + v*y + w*z > 0 is exactly captured", "The conclusion S < x+y+z is correctly formalized using the definition of S", "Extra positivity constraints on individual variables are additional logical conditions that strengthen the theorem without contradicting the natural language premise"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l10": {"id": "l10", "natural_language": "Therefore $(A+B+C)^2\\le(x+y+z)S<(x+y+z)(x+y+z)=(x+y+z)^2$.", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1].\n\u2022 $(A+B+C)^2 \\le (x+y+z) * S$ [l4, def_3].\n\u2022 $S < x+y+z$ [l9].\nTherefore, we conclude:\n\u2022 $(A+B+C)^2 < (x+y+z)^2$ [l10].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5", "l6", "l7", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (a b c x y z u v w A B C S : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))  \n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (hS : S = (u * y + v * x) + (v * z + w * y) + (w * x + u * z))\n  (l4 : (A + B + C)^2 \u2264 (x + y + z) * S)\n  (l9 : S < x + y + z) :\n  (A + B + C)^2 < (x + y + z)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (a b c x y z u v w A B C S : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))  \n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (hS : S = (u * y + v * x) + (v * z + w * y) + (w * x + u * z))\n  (l4 : (A + B + C)^2 \u2264 (x + y + z) * S)\n  (l9 : S < x + y + z) :\n  (A + B + C)^2 < (x + y + z)^2 := by\n  have h_sum_pos : 0 < x + y + z := by\n    have h\u2081 : 0 < x := hx\n    have h\u2082 : 0 < y := hy\n    have h\u2083 : 0 < z := hz\n    -- Since x, y, z are positive, their sum is also positive.\n    linarith\n  \n  have h_mul_ineq : (x + y + z) * S < (x + y + z) * (x + y + z) := by\n    have h\u2081 : S < x + y + z := l9\n    have h\u2082 : 0 < x + y + z := h_sum_pos\n    -- Multiply both sides of the inequality S < x + y + z by the positive number (x + y + z)\n    have h\u2083 : (x + y + z) * S < (x + y + z) * (x + y + z) := by\n      nlinarith\n    exact h\u2083\n  \n  have h_final : (A + B + C)^2 < (x + y + z)^2 := by\n    have h\u2081 : (A + B + C)^2 \u2264 (x + y + z) * S := l4\n    have h\u2082 : (x + y + z) * S < (x + y + z) * (x + y + z) := h_mul_ineq\n    have h\u2083 : (x + y + z) * (x + y + z) = (x + y + z)^2 := by ring\n    have h\u2084 : (x + y + z) * S < (x + y + z)^2 := by\n      linarith\n    -- Using the transitivity of inequalities to combine the above results\n    have h\u2085 : (A + B + C)^2 < (x + y + z)^2 := by\n      linarith\n    exact h\u2085\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential logical components from the natural language: the positivity of x, y, z, the two key assumptions (A+B+C)\u00b2 \u2264 (x+y+z)*S and S < x+y+z, and the conclusion (A+B+C)\u00b2 < (x+y+z)\u00b2. While the Lean code includes many additional variables, constraints, and specific definitions for A, B, C, and S that are not mentioned in the natural language, these are consistent additional details that provide a concrete mathematical context. All statements from the natural language are faithfully represented in the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l11": {"id": "l11", "natural_language": "Taking square roots, we conclude $\\sqrt{z(uy+vx)}+\\sqrt{x(vz+wy)}+\\sqrt{y(wx+uz)}<x+y+z$", "statement": "We assume:\n\u2022 a, b, c, x, y, z are positive real numbers and u, v, w are derived from them [tc_1, def_1, l7].\n\u2022 $A = \\sqrt{z(u*y+v*x)}$, $B = \\sqrt{x(v*z+w*y)}$, and $C = \\sqrt{y(w*x+u*z)}$ [def_2].\n\u2022 $(A+B+C)^2 < (x+y+z)^2$ [l10].\nTherefore, we conclude:\n\u2022 $A+B+C < x+y+z$ [l11].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5", "l6", "l7", "l8", "l9", "l10"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l11 \n  (a b c x y z u v w A B C S : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))\n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (hS : S = (u * y + v * x) + (v * z + w * y) + (w * x + u * z))\n  (l1 : a / (y * z) + b / (x * z) + c / (x * y) = 1)\n  (l2 : u + v + w = 1)\n  (l3 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z)\n  (l4 : (A + B + C)^2 \u2264 (x + y + z) * S)\n  (l5 : S < x + y + z) :\n  A + B + C < x + y + z := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l11 \n  (a b c x y z u v w A B C S : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))\n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (hS : S = (u * y + v * x) + (v * z + w * y) + (w * x + u * z))\n  (l1 : a / (y * z) + b / (x * z) + c / (x * y) = 1)\n  (l2 : u + v + w = 1)\n  (l3 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z)\n  (l4 : (A + B + C)^2 \u2264 (x + y + z) * S)\n  (l5 : S < x + y + z) :\n  A + B + C < x + y + z := by\n  have hA_nonneg : A \u2265 0 := by\n    rw [hA]\n    apply Real.sqrt_nonneg\n  \n  have hB_nonneg : B \u2265 0 := by\n    rw [hB]\n    apply Real.sqrt_nonneg\n  \n  have hC_nonneg : C \u2265 0 := by\n    rw [hC]\n    apply Real.sqrt_nonneg\n  \n  have h_sum_nonneg : A + B + C \u2265 0 := by\n    linarith [hA_nonneg, hB_nonneg, hC_nonneg]\n  \n  have h_sum_pos : 0 < x + y + z := by\n    linarith [hx, hy, hz]\n  \n  have h_mul_S_lt : (x + y + z) * S < (x + y + z) ^ 2 := by\n    have h\u2081 : S < x + y + z := l5\n    have h\u2082 : 0 < x + y + z := by linarith [hx, hy, hz]\n    have h\u2083 : (x + y + z) * S < (x + y + z) * (x + y + z) := by\n      nlinarith\n    nlinarith\n  \n  have h_sq_abc_lt : (A + B + C) ^ 2 < (x + y + z) ^ 2 := by\n    have h\u2081 : (A + B + C) ^ 2 \u2264 (x + y + z) * S := l4\n    have h\u2082 : (x + y + z) * S < (x + y + z) ^ 2 := h_mul_S_lt\n    have h\u2083 : (A + B + C) ^ 2 < (x + y + z) ^ 2 := by\n      linarith\n    exact h\u2083\n  \n  have h_main : A + B + C < x + y + z := by\n    by_contra h\n    have h\u2081 : A + B + C \u2265 x + y + z := by linarith\n    have h\u2082 : (A + B + C) ^ 2 \u2265 (x + y + z) ^ 2 := by\n      have h\u2083 : 0 \u2264 A + B + C := by linarith\n      have h\u2084 : 0 \u2264 x + y + z := by linarith\n      nlinarith [sq_nonneg (A + B + C - (x + y + z))]\n    linarith [h_sq_abc_lt]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.8, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured in Lean with appropriate type annotations.", "The definitions of A, B, and C are exactly translated with proper mathematical notation using Real.sqrt.", "The constraint (A+B+C)\u00b2 < (x+y+z)\u00b2 in natural language is directly stated as A+B+C < x+y+z in Lean. While mathematically equivalent for positive values, this is not a direct structural translation.", "The conclusion A+B+C < x+y+z is perfectly matched between natural language and Lean.", "The Lean formalization includes additional constraints and auxiliary variables (like S, constraint equations) that are not mentioned in the natural language but appear to be supporting conditions for the proof."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Taking square roots, we conclude $\\sqrt{z(uy+vx)}+\\sqrt{x(vz+wy)}+\\sqrt{y(wx+uz)}<x+y+z$, which establishes the desired inequality.", "statement": "We assume:\n\u2022 The inequality $\\sqrt{a+b}+\\sqrt{b+c}+\\sqrt{c+a}<x+y+z$ is equivalent to $\\sqrt{z(u*y+v*x)}+\\sqrt{x(v*z+w*y)}+\\sqrt{y(w*x+u*z)}<x+y+z$ [l3].\n\u2022 $A = \\sqrt{z(u*y+v*x)}$, $B = \\sqrt{x(v*z+w*y)}$, and $C = \\sqrt{y(w*x+u*z)}$ [def_2].\n\u2022 $A+B+C < x+y+z$ [l11].\nTherefore, we conclude:\n\u2022 $\\sqrt{a+b} + \\sqrt{b+c} + \\sqrt{c+a} < x + y + z$ [ts_1].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "l2", "l3", "def_2", "l4", "def_3", "l5", "l6", "l7", "l8", "l9", "l10", "l11"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b c x y z u v w A B C S : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))\n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (hS : S = (u * y + v * x) + (v * z + w * y) + (w * x + u * z))\n  (l1 : a / (y * z) + b / (x * z) + c / (x * y) = 1)\n  (l2 : u + v + w = 1)\n  (l3 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z)\n  (l4 : (A + B + C)^2 \u2264 (x + y + z) * S)\n  (l5 : S < x + y + z) :\n  Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b c x y z u v w A B C S : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) \n  (hx : 0 < x) (hy : 0 < y) (hz : 0 < z)\n  (hu : 0 < u) (hv : 0 < v) (hw : 0 < w)\n  (h_constraint : a * x + b * y + c * z = x * y * z)\n  (h_sum : u + v + w = 1)\n  (hA : A = Real.sqrt (z * (u * y + v * x)))\n  (hB : B = Real.sqrt (x * (v * z + w * y)))\n  (hC : C = Real.sqrt (y * (w * x + u * z)))\n  (hS : S = (u * y + v * x) + (v * z + w * y) + (w * x + u * z))\n  (l1 : a / (y * z) + b / (x * z) + c / (x * y) = 1)\n  (l2 : u + v + w = 1)\n  (l3 : Real.sqrt (z * (u * y + v * x)) + Real.sqrt (x * (v * z + w * y)) + Real.sqrt (y * (w * x + u * z)) < x + y + z)\n  (l4 : (A + B + C)^2 \u2264 (x + y + z) * S)\n  (l5 : S < x + y + z) :\n  Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by\n  have h_a_le : a \u2264 y * z := by\n    have h\u2081 : 0 < x := hx\n    have h\u2082 : 0 < y := hy\n    have h\u2083 : 0 < z := hz\n    have h\u2084 : 0 < a := ha\n    have h\u2085 : 0 < b := hb\n    have h\u2086 : 0 < c := hc\n    have h\u2087 : a * x + b * y + c * z = x * y * z := h_constraint\n    have h\u2088 : a * x \u2264 x * y * z := by\n      nlinarith [mul_pos h\u2085 h\u2082, mul_pos h\u2086 h\u2083]\n    have h\u2089 : a \u2264 y * z := by\n      have h\u2081\u2080 : 0 < x := hx\n      have h\u2081\u2081 : 0 < y * z := by positivity\n      have h\u2081\u2082 : a * x \u2264 x * (y * z) := by\n        calc\n          a * x \u2264 x * y * z := h\u2088\n          _ = x * (y * z) := by ring\n      have h\u2081\u2083 : a \u2264 y * z := by\n        nlinarith [h\u2081\u2080]\n      exact h\u2081\u2083\n    exact h\u2089\n  \n  have h_b_le : b \u2264 x * z := by\n    have h\u2081 : 0 < x := hx\n    have h\u2082 : 0 < y := hy\n    have h\u2083 : 0 < z := hz\n    have h\u2084 : 0 < a := ha\n    have h\u2085 : 0 < b := hb\n    have h\u2086 : 0 < c := hc\n    have h\u2087 : a * x + b * y + c * z = x * y * z := h_constraint\n    have h\u2088 : b * y \u2264 x * y * z := by\n      nlinarith [mul_pos h\u2084 h\u2081, mul_pos h\u2086 h\u2083]\n    have h\u2089 : b \u2264 x * z := by\n      have h\u2081\u2080 : 0 < y := hy\n      have h\u2081\u2081 : 0 < x * z := by positivity\n      have h\u2081\u2082 : b * y \u2264 y * (x * z) := by\n        calc\n          b * y \u2264 x * y * z := h\u2088\n          _ = y * (x * z) := by ring\n      have h\u2081\u2083 : b \u2264 x * z := by\n        nlinarith [h\u2081\u2080]\n      exact h\u2081\u2083\n    exact h\u2089\n  \n  have h_c_le : c \u2264 x * y := by\n    have h\u2081 : 0 < x := hx\n    have h\u2082 : 0 < y := hy\n    have h\u2083 : 0 < z := hz\n    have h\u2084 : 0 < a := ha\n    have h\u2085 : 0 < b := hb\n    have h\u2086 : 0 < c := hc\n    have h\u2087 : a * x + b * y + c * z = x * y * z := h_constraint\n    have h\u2088 : c * z \u2264 x * y * z := by\n      nlinarith [mul_pos h\u2084 h\u2081, mul_pos h\u2085 h\u2082]\n    have h\u2089 : c \u2264 x * y := by\n      have h\u2081\u2080 : 0 < z := hz\n      have h\u2081\u2081 : 0 < x * y := by positivity\n      have h\u2081\u2082 : c * z \u2264 z * (x * y) := by\n        calc\n          c * z \u2264 x * y * z := h\u2088\n          _ = z * (x * y) := by ring\n      have h\u2081\u2083 : c \u2264 x * y := by\n        nlinarith [h\u2081\u2080]\n      exact h\u2081\u2083\n    exact h\u2089\n  \n  have h_sum_abc : a + b + c \u2264 x * y + y * z + z * x := by\n    have h\u2081 : a + b + c \u2264 y * z + x * z + x * y := by\n      linarith [h_a_le, h_b_le, h_c_le]\n    linarith\n  \n  have h_main_ineq : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a))^2 \u2264 6 * (a + b + c) := by\n    have h\u2081 : 0 \u2264 Real.sqrt (a + b) := Real.sqrt_nonneg (a + b)\n    have h\u2082 : 0 \u2264 Real.sqrt (b + c) := Real.sqrt_nonneg (b + c)\n    have h\u2083 : 0 \u2264 Real.sqrt (c + a) := Real.sqrt_nonneg (c + a)\n    have h\u2084 : 0 \u2264 Real.sqrt (a + b) * Real.sqrt (b + c) := by positivity\n    have h\u2085 : 0 \u2264 Real.sqrt (b + c) * Real.sqrt (c + a) := by positivity\n    have h\u2086 : 0 \u2264 Real.sqrt (c + a) * Real.sqrt (a + b) := by positivity\n    have h\u2087 : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a)) ^ 2 \u2264 3 * ((Real.sqrt (a + b)) ^ 2 + (Real.sqrt (b + c)) ^ 2 + (Real.sqrt (c + a)) ^ 2) := by\n      nlinarith [sq_nonneg (Real.sqrt (a + b) - Real.sqrt (b + c)), sq_nonneg (Real.sqrt (b + c) - Real.sqrt (c + a)), sq_nonneg (Real.sqrt (c + a) - Real.sqrt (a + b))]\n    have h\u2088 : (Real.sqrt (a + b)) ^ 2 = a + b := by\n      rw [Real.sq_sqrt] <;> linarith\n    have h\u2089 : (Real.sqrt (b + c)) ^ 2 = b + c := by\n      rw [Real.sq_sqrt] <;> linarith\n    have h\u2081\u2080 : (Real.sqrt (c + a)) ^ 2 = c + a := by\n      rw [Real.sq_sqrt] <;> linarith\n    have h\u2081\u2081 : 3 * ((Real.sqrt (a + b)) ^ 2 + (Real.sqrt (b + c)) ^ 2 + (Real.sqrt (c + a)) ^ 2) = 3 * (a + b + (b + c) + (c + a)) := by\n      rw [h\u2088, h\u2089, h\u2081\u2080]\n      <;> ring_nf\n    have h\u2081\u2082 : 3 * (a + b + (b + c) + (c + a)) = 6 * (a + b + c) := by ring\n    have h\u2081\u2083 : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a)) ^ 2 \u2264 6 * (a + b + c) := by\n      linarith\n    exact h\u2081\u2083\n  \n  have h_final : Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by\n    have h\u2081 : 0 < x + y + z := by linarith\n    have h\u2082 : 0 \u2264 Real.sqrt (a + b) := Real.sqrt_nonneg _\n    have h\u2083 : 0 \u2264 Real.sqrt (b + c) := Real.sqrt_nonneg _\n    have h\u2084 : 0 \u2264 Real.sqrt (c + a) := Real.sqrt_nonneg _\n    have h\u2085 : 0 \u2264 Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) := by positivity\n    have h\u2086 : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a)) ^ 2 \u2264 6 * (a + b + c) := h_main_ineq\n    have h\u2087 : a + b + c \u2264 x * y + y * z + z * x := h_sum_abc\n    have h\u2088 : 6 * (a + b + c) \u2264 6 * (x * y + y * z + z * x) := by linarith\n    have h\u2089 : (x + y + z) ^ 2 = x ^ 2 + y ^ 2 + z ^ 2 + 2 * (x * y + y * z + z * x) := by ring\n    have h\u2081\u2080 : 6 * (x * y + y * z + z * x) < (x + y + z) ^ 2 := by\n      nlinarith [sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x),\n        mul_pos hx hy, mul_pos hy hz, mul_pos hz hx]\n    have h\u2081\u2081 : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a)) ^ 2 < (x + y + z) ^ 2 := by\n      calc\n        (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a)) ^ 2 \u2264 6 * (a + b + c) := h_main_ineq\n        _ \u2264 6 * (x * y + y * z + z * x) := by linarith\n        _ < (x + y + z) ^ 2 := by linarith\n    have h\u2081\u2082 : Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) < x + y + z := by\n      by_contra h\n      have h\u2081\u2083 : Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a) \u2265 x + y + z := by linarith\n      have h\u2081\u2084 : (Real.sqrt (a + b) + Real.sqrt (b + c) + Real.sqrt (c + a)) ^ 2 \u2265 (x + y + z) ^ 2 := by\n        exact pow_le_pow_of_le_left (by positivity) h\u2081\u2083 2\n      linarith\n    exact h\u2081\u2082\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization is missing the crucial equivalence statement from the natural language. The natural language states that two inequalities are equivalent, but Lean only includes one side as hypothesis l3, making the logical derivation incomplete.", "The definitions of A, B, and C are correctly captured in the Lean formalization through hA, hB, and hC.", "The inequality A+B+C < x+y+z is present but appears as l3 with expanded definitions rather than using the defined variables A, B, C, and has different labeling (l3 vs l11).", "The conclusion statement is correctly formalized as the theorem goal in Lean.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization is missing the crucial equivalence statement from the natural language. The natural language states that two inequalities are equivalent, but Lean only includes one side as hypothesis l3, making the logical derivation incomplete.', 'The definitions of A, B, and C are correctly captured in the Lean formalization through hA, hB, and hC.', 'The inequality A+B+C < x+y+z is present but appears as l3 with expanded definitions rather than using the defined variables A, B, C, and has different labeling (l3 vs l11).', 'The conclusion statement is correctly formalized as the theorem goal in Lean.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l10", "label": "l10", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l11", "label": "l11", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l11", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    