
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $a, b, c$ such that $a b c \geq 1$, the following inequality holds: $a+b+c \geq \frac{1+a}{1+b}+\frac{1+b}{1+c}+\frac{1+c}{1+a}$.

Proof: Let $a,b,c>0$ with $abc\ge 1$. We want to show that $a+b+c \ge rac{1+a}{1+b} + rac{1+b}{1+c} + rac{1+c}{1+a}$. Observe that $rac{1+a}{1+b} + rac{1+b}{1+c} + rac{1+c}{1+a} = 3 + rac{a-b}{1+b} + rac{b-c}{1+c} + rac{c-a}{1+a} = rac{(1+a)b}{1+b} + rac{(1+b)c}{1+c} + rac{(1+c)a}{1+a}$. By the AMâ€“GM inequality, $rac{(1+a)b}{1+b} + rac{(1+b)c}{1+c} + rac{(1+c)a}{1+a} \ge 3 \sqrt[3]{rac{(1+a)b}{1+b} \cdot rac{(1+b)c}{1+c} \cdot rac{(1+c)a}{1+a}} = 3\sqrt[3]{abc} \ge 3$. Therefore, $a+b+c - \left(rac{1+a}{1+b} + rac{1+b}{1+c} + rac{1+c}{1+a}ight) \ge 0$, which gives $a+b+c \ge rac{1+a}{1+b} + rac{1+b}{1+c} + rac{1+c}{1+a}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $a,b,c>0$", "statement": "Premise:\n\u2022 a, b, and c are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c : \u211d)\n(tc_1 : 0 < a \u2227 0 < b \u2227 0 < c \u2227 1 \u2264 a * b * c)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (a b c : \u211d)' correctly captures that a, b, and c are real numbers", "The Lean condition '0 < a' in the conjunction perfectly matches 'a > 0'", "The Lean condition '0 < b' in the conjunction perfectly matches 'b > 0'", "The Lean condition '0 < c' in the conjunction perfectly matches 'c > 0'", "The Lean formalization includes an additional constraint '1 \u2264 a * b * c' that is not mentioned in the natural language. However, this is acceptable as extra conditions are allowed and do not contradict the stated conditions"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "with $abc\\ge 1$", "statement": "Premise:\n\u2022 a, b, and c are positive real numbers [tc_1];\n\u2022 $abc \\ge 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (h_constraint : 1 \u2264 a * b * c) :\n  a + b + c \u2265 (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, c are positive real numbers through type declaration and positivity constraints", "The constraint abc \u2265 1 is correctly formalized as 1 \u2264 a * b * c, which is mathematically equivalent", "The natural language states there are no conclusions derived, but the Lean theorem introduces a completely new inequality conclusion that was not mentioned in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that a, b, c are positive real numbers through type declaration and positivity constraints', 'The constraint abc \u2265 1 is correctly formalized as 1 \u2264 a * b * c, which is mathematically equivalent', 'The natural language states there are no conclusions derived, but the Lean theorem introduces a completely new inequality conclusion that was not mentioned in the natural language statement']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Observe that $\frac{1+a}{1+b} + \frac{1+b}{1+c} + \frac{1+c}{1+a} = ... = \frac{(1+a)b}{1+b} + \frac{(1+b)c}{1+c} + \frac{(1+c)a}{1+a}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1];\n\u2022 $abc \\ge 1$ [tc_2].\nTherefore, we conclude:\n\u2022 $\\frac{1+a}{1+b} + \\frac{1+b}{1+c} + \\frac{1+c}{1+a} = \\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a}$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) \n  (tc_1 : 0 < a \u2227 0 < b \u2227 0 < c) \n  (tc_2 : 1 \u2264 a * b * c) :\n  (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n  (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b c : \u211d) \n  (tc_1 : 0 < a \u2227 0 < b \u2227 0 < c) \n  (tc_2 : 1 \u2264 a * b * c) :\n  (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n  (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) := by\n  have h\u2081 : 0 < a := by linarith\n  have h\u2082 : 0 < b := by linarith\n  have h\u2083 : 0 < c := by linarith\n  have h\u2084 : 0 < 1 + a := by linarith\n  have h\u2085 : 0 < 1 + b := by linarith\n  have h\u2086 : 0 < 1 + c := by linarith\n  have h\u2087 : 0 < (1 + a) * (1 + b) * (1 + c) := by positivity\n  field_simp [h\u2084.ne', h\u2085.ne', h\u2086.ne']\n  ring_nf\n  <;>\n  (try norm_num) <;>\n  (try linarith [mul_nonneg h\u2081.le h\u2082.le, mul_nonneg h\u2081.le h\u2083.le, mul_nonneg h\u2082.le h\u2083.le]) <;>\n  (try nlinarith [sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (c - 1),\n    mul_nonneg h\u2081.le h\u2082.le, mul_nonneg h\u2081.le h\u2083.le, mul_nonneg h\u2082.le h\u2083.le,\n    mul_nonneg (sq_nonneg (a - 1)) h\u2082.le, mul_nonneg (sq_nonneg (b - 1)) h\u2083.le,\n    mul_nonneg (sq_nonneg (c - 1)) h\u2081.le])\n  <;>\n  (try\n    {\n      nlinarith [sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (c - 1),\n        mul_nonneg h\u2081.le h\u2082.le, mul_nonneg h\u2081.le h\u2083.le, mul_nonneg h\u2082.le h\u2083.le,\n        mul_nonneg (sq_nonneg (a - 1)) h\u2082.le, mul_nonneg (sq_nonneg (b - 1)) h\u2083.le,\n        mul_nonneg (sq_nonneg (c - 1)) h\u2081.le, mul_nonneg (sq_nonneg (a - 1)) (mul_nonneg h\u2081.le h\u2082.le),\n        mul_nonneg (sq_nonneg (b - 1)) (mul_nonneg h\u2081.le h\u2082.le), mul_nonneg (sq_nonneg (c - 1)) (mul_nonneg h\u2081.le h\u2082.le)]\n    })\n  <;>\n  (try\n    {\n      nlinarith [sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (c - 1),\n        mul_nonneg h\u2081.le h\u2082.le, mul_nonneg h\u2081.le h\u2083.le, mul_nonneg h\u2082.le h\u2083.le,\n        mul_nonneg (sq_nonneg (a - 1)) h\u2082.le, mul_nonneg (sq_nonneg (b - 1)) h\u2083.le,\n        mul_nonneg (sq_nonneg (c - 1)) h\u2081.le, mul_nonneg (sq_nonneg (a - 1)) (mul_nonneg h\u2081.le h\u2082.le),\n        mul_nonneg (sq_nonneg (b - 1)) (mul_nonneg h\u2081.le h\u2082.le), mul_nonneg (sq_nonneg (c - 1)) (mul_nonneg h\u2081.le h\u2082.le)]\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture 'positive real numbers' as real numbers with explicit positivity conditions", "Positivity conditions are correctly formalized as strict inequalities with zero", "The constraint 'abc \u2265 1' is correctly represented as '1 \u2264 a * b * c' - mathematically equivalent", "The main equation is perfectly translated from mathematical notation to Lean syntax, preserving all algebraic relationships"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By the AM\u2013GM inequality, $\frac{(1+a)b}{1+b} + \frac{(1+b)c}{1+c} + \frac{(1+c)a}{1+a} \\ge 3 \\sqrt[3]{\frac{(1+a)b}{1+b} \\cdot \frac{(1+b)c}{1+c} \\cdot \frac{(1+c)a}{1+a}} = 3\\sqrt[3]{abc}$", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1];\n\u2022 $abc \\ge 1$ [tc_2];\n\u2022 $\\frac{1+a}{1+b} + \\frac{1+b}{1+c} + \\frac{1+c}{1+a} = \\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a}$ [l1].\nTherefore, we conclude:\n\u2022 $\\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a} \\ge 3 \\sqrt[3]{abc}$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (h_eq : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n          (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a)) :\n  (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n  3 * (a * b * c) ^ (1/3 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (h_eq : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n          (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a)) :\n  (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n  3 * (a * b * c) ^ (1/3 : \u211d) := by\n  have h\u2081 : 0 < (1 + a) * b / (1 + b) := by sorry\n  have h\u2082 : 0 < (1 + b) * c / (1 + c) := by sorry\n  have h\u2083 : 0 < (1 + c) * a / (1 + a) := by sorry\n  have h\u2084 : ((1 + a) * b / (1 + b)) * ((1 + b) * c / (1 + c)) * ((1 + c) * a / (1 + a)) = a * b * c := by sorry\n  have h\u2085 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 3 * (a * b * c) ^ (1/3 : \u211d) := by sorry\n  sorry", "lean_pass": true, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate real number types and strict inequality constraints.", "The product constraint abc \u2265 1 is accurately represented as 1 \u2264 a * b * c, which is mathematically equivalent.", "The equality condition is precisely translated, with correct operator precedence handling for the fractions involving products.", "The conclusion inequality is correctly formalized, with the cube root properly expressed using exponentiation and appropriate type annotation.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (h_eq : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n          (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a)) :\n  (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n  3 * (a * b * c) ^ (1/3 : \u211d) := by\n  have h_sum : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (3 + a + b + c) / 2 := by\n    have h\u2081 : (1 + a) * b / (1 + b) = (1 + a) - (1 + a) / (1 + b) := by\n      have h\u2081\u2081 : 0 < 1 + b := by linarith\n      have h\u2081\u2082 : (1 + a) * b / (1 + b) = (1 + a) * b / (1 + b) := rfl\n      calc\n        (1 + a) * b / (1 + b) = (1 + a) * (b / (1 + b)) := by ring\n        _ = (1 + a) * (1 - 1 / (1 + b)) := by\n          have h\u2081\u2083 : b / (1 + b) = 1 - 1 / (1 + b) := by\n            have h\u2081\u2084 : 0 < 1 + b := by linarith\n            field_simp [h\u2081\u2084.ne']\n            <;> ring\n            <;> field_simp [h\u2081\u2084.ne']\n            <;> ring\n          rw [h\u2081\u2083]\n          <;> ring\n        _ = (1 + a) - (1 + a) / (1 + b) := by\n          have h\u2081\u2083 : 0 < 1 + b := by linarith\n          field_simp [h\u2081\u2083.ne']\n          <;> ring\n          <;> field_simp [h\u2081\u2083.ne']\n          <;> ring\n    have h\u2082 : (1 + b) * c / (1 + c) = (1 + b) - (1 + b) / (1 + c) := by\n      have h\u2082\u2081 : 0 < 1 + c := by linarith\n      have h\u2082\u2082 : (1 + b) * c / (1 + c) = (1 + b) * c / (1 + c) := rfl\n      calc\n        (1 + b) * c / (1 + c) = (1 + b) * (c / (1 + c)) := by ring\n        _ = (1 + b) * (1 - 1 / (1 + c)) := by\n          have h\u2082\u2083 : c / (1 + c) = 1 - 1 / (1 + c) := by\n            have h\u2082\u2084 : 0 < 1 + c := by linarith\n            field_simp [h\u2082\u2084.ne']\n            <;> ring\n            <;> field_simp [h\u2082\u2084.ne']\n            <;> ring\n          rw [h\u2082\u2083]\n          <;> ring\n        _ = (1 + b) - (1 + b) / (1 + c) := by\n          have h\u2082\u2083 : 0 < 1 + c := by linarith\n          field_simp [h\u2082\u2083.ne']\n          <;> ring\n          <;> field_simp [h\u2082\u2083.ne']\n          <;> ring\n    have h\u2083 : (1 + c) * a / (1 + a) = (1 + c) - (1 + c) / (1 + a) := by\n      have h\u2083\u2081 : 0 < 1 + a := by linarith\n      have h\u2083\u2082 : (1 + c) * a / (1 + a) = (1 + c) * a / (1 + a) := rfl\n      calc\n        (1 + c) * a / (1 + a) = (1 + c) * (a / (1 + a)) := by ring\n        _ = (1 + c) * (1 - 1 / (1 + a)) := by\n          have h\u2083\u2083 : a / (1 + a) = 1 - 1 / (1 + a) := by\n            have h\u2083\u2084 : 0 < 1 + a := by linarith\n            field_simp [h\u2083\u2084.ne']\n            <;> ring\n            <;> field_simp [h\u2083\u2084.ne']\n            <;> ring\n          rw [h\u2083\u2083]\n          <;> ring\n        _ = (1 + c) - (1 + c) / (1 + a) := by\n          have h\u2083\u2083 : 0 < 1 + a := by linarith\n          field_simp [h\u2083\u2083.ne']\n          <;> ring\n          <;> field_simp [h\u2083\u2083.ne']\n          <;> ring\n    have h\u2084 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) = (1 + a) + (1 + b) + (1 + c) - ((1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a)) := by\n      calc\n        (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) = ((1 + a) - (1 + a) / (1 + b)) + ((1 + b) - (1 + b) / (1 + c)) + ((1 + c) - (1 + c) / (1 + a)) := by\n          rw [h\u2081, h\u2082, h\u2083]\n          <;> ring\n        _ = (1 + a) + (1 + b) + (1 + c) - ((1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a)) := by\n          ring\n    have h\u2085 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (3 + a + b + c) / 2 := by\n      have h\u2085\u2081 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) := by\n        linarith\n      have h\u2085\u2082 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) = (1 + a) + (1 + b) + (1 + c) - ((1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a)) := by\n        linarith\n      have h\u2085\u2083 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (1 + a) + (1 + b) + (1 + c) - ((1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a)) := by\n        linarith\n      have h\u2085\u2084 : 2 * ((1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a)) = (1 + a) + (1 + b) + (1 + c) := by linarith\n      have h\u2085\u2085 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (3 + a + b + c) / 2 := by\n        linarith\n      exact h\u2085\u2085\n    exact h\u2085\n  \n  have h_sum' : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) = (3 + a + b + c) / 2 := by\n    have h\u2081 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) := by linarith\n    linarith\n  \n  have h_main : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 3 * (a * b * c) ^ (1/3 : \u211d) := by\n    have h\u2081 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) = (3 + a + b + c) / 2 := by linarith\n    rw [h\u2081]\n    have h\u2082 : (3 + a + b + c : \u211d) / 2 \u2265 3 := by\n      have h\u2083 : a + b + c \u2265 3 := by\n        -- Use AM-GM inequality to show that a + b + c \u2265 3\n        have h\u2083\u2081 : 0 < a * b := by positivity\n        have h\u2083\u2082 : 0 < a * c := by positivity\n        have h\u2083\u2083 : 0 < b * c := by positivity\n        nlinarith [sq_nonneg (a - b), sq_nonneg (a - c), sq_nonneg (b - c),\n          sq_nonneg (a * b - 1), sq_nonneg (a * c - 1), sq_nonneg (b * c - 1)]\n      linarith\n    have h\u2083 : (3 : \u211d) * (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2264 (3 + a + b + c : \u211d) / 2 := by\n      have h\u2084 : (a * b * c : \u211d) \u2265 1 := by\n        norm_cast at h_constraint \u22a2\n        <;> linarith\n      have h\u2085 : (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2264 1 := by\n        -- Use the fact that a * b * c \u2265 1 to show that (a * b * c)^(1/3) \u2264 1\n        have h\u2085\u2081 : (a * b * c : \u211d) \u2265 1 := by exact_mod_cast h_constraint\n        have h\u2085\u2082 : Real.log ((a * b * c : \u211d)) \u2265 0 := by\n          -- Since a * b * c \u2265 1, log(a * b * c) \u2265 log(1) = 0\n          apply Real.log_nonneg\n          linarith\n        -- Use the fact that the logarithm is concave and increasing\n        have h\u2085\u2083 : Real.log ((a * b * c : \u211d) ^ (1 / 3 : \u211d)) = (1 / 3 : \u211d) * Real.log ((a * b * c : \u211d)) := by\n          rw [Real.log_rpow (by positivity)]\n        have h\u2085\u2084 : Real.log ((a * b * c : \u211d) ^ (1 / 3 : \u211d)) \u2265 0 := by\n          rw [h\u2085\u2083]\n          have h\u2085\u2085 : (1 / 3 : \u211d) * Real.log ((a * b * c : \u211d)) \u2265 0 := by\n            nlinarith [h\u2085\u2082]\n          linarith\n        -- Since the logarithm is concave and increasing, (a * b * c)^(1/3) \u2264 1\n        have h\u2085\u2086 : (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2264 1 := by\n          by_contra h\n          have h\u2085\u2087 : (a * b * c : \u211d) ^ (1 / 3 : \u211d) > 1 := by linarith\n          have h\u2085\u2088 : Real.log ((a * b * c : \u211d) ^ (1 / 3 : \u211d)) > Real.log 1 := by\n            apply Real.log_lt_log (by positivity)\n            linarith\n          have h\u2085\u2089 : Real.log 1 = 0 := by norm_num\n          linarith\n        exact h\u2085\u2086\n      -- Combine the inequalities to get the desired result\n      have h\u2085\u2081\u2080 : (3 : \u211d) * (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2264 3 := by\n        nlinarith [h\u2085]\n      have h\u2085\u2081\u2081 : (3 : \u211d) \u2264 (3 + a + b + c : \u211d) / 2 := by\n        linarith [h\u2082]\n      linarith\n    linarith\n  \n  exact h_main"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "$\\ge 3\\sqrt[3]{abc} \\ge 3$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1];\n\u2022 $abc \\ge 1$ [tc_2];\n\u2022 $\\frac{1+a}{1+b} + \\frac{1+b}{1+c} + \\frac{1+c}{1+a} = \\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a}$ [l1];\n\u2022 $\\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a} \\ge 3 \\sqrt[3]{abc}$ [l2].\nTherefore, we conclude:\n\u2022 $3 \\sqrt[3]{abc} \\ge 3$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (l1 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n        (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a))\n  (l2 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n        3 * (a * b * c) ^ (1/3 : \u211d)) :\n  3 * (a * b * c) ^ (1/3 : \u211d) \u2265 3 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (l1 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n        (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a))\n  (l2 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n        3 * (a * b * c) ^ (1/3 : \u211d)) :\n  3 * (a * b * c) ^ (1/3 : \u211d) \u2265 3 := by\n  have h_cbrt_ge_one : (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2265 1 := by\n    have h\u2081 : (1 : \u211d) \u2264 (a * b * c : \u211d) := by\n      exact_mod_cast h_constraint\n    have h\u2082 : (0 : \u211d) \u2264 (1 / 3 : \u211d) := by norm_num\n    -- Use the property of real powers to show that if x \u2265 1 and y \u2265 0, then x^y \u2265 1\n    have h\u2083 : (1 : \u211d) \u2264 (a * b * c : \u211d) ^ (1 / 3 : \u211d) := by\n      apply Real.one_le_rpow\n      \u00b7 linarith\n      \u00b7 norm_num\n    linarith\n  \n  have h_main : 3 * (a * b * c) ^ (1/3 : \u211d) \u2265 3 := by\n    have h\u2081 : (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2265 1 := h_cbrt_ge_one\n    have h\u2082 : (3 : \u211d) * (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2265 (3 : \u211d) * 1 := by\n      -- Multiply both sides of the inequality by 3 (which is positive)\n      have h\u2083 : (0 : \u211d) \u2264 (3 : \u211d) := by norm_num\n      nlinarith\n    -- Simplify the right side to get the final result\n    have h\u2083 : (3 : \u211d) * (a * b * c : \u211d) ^ (1 / 3 : \u211d) \u2265 3 := by\n      norm_num at h\u2082 \u22a2\n      <;> linarith\n    -- Since (a * b * c : \u211d) ^ (1 / 3 : \u211d) is the same as (a * b * c) ^ (1/3 : \u211d), we can directly use the result\n    have h\u2084 : (3 : \u211d) * (a * b * c) ^ (1 / 3 : \u211d) \u2265 3 := by\n      simpa [div_eq_mul_inv] using h\u2083\n    -- Convert the result back to the original form\n    norm_num at h\u2084 \u22a2\n    <;>\n    (try norm_num) <;>\n    (try linarith) <;>\n    (try assumption) <;>\n    (try simp_all [div_eq_mul_inv]) <;>\n    (try nlinarith)\n    <;>\n    (try\n      {\n        ring_nf at *\n        <;>\n        nlinarith\n      })\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate type annotations and strict inequality constraints.", "The constraint abc \u2265 1 is correctly represented as 1 \u2264 a * b * c, which is mathematically equivalent.", "The equation l1 is accurately translated with proper fraction notation and algebraic expressions.", "The inequality l2 correctly represents the cube root as exponentiation with 1/3 and maintains the proper inequality structure.", "The conclusion l3 correctly captures the final inequality statement that needs to be proven."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, $a+b+c - \\left(\frac{1+a}{1+b} + \frac{1+b}{1+c} + \frac{1+c}{1+a}ight) \\ge 0$, which gives $a+b+c \\ge \frac{1+a}{1+b} + \frac{1+b}{1+c} + \frac{1+c}{1+a}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1];\n\u2022 $abc \\ge 1$ [tc_2];\n\u2022 $\\frac{1+a}{1+b} + \\frac{1+b}{1+c} + \\frac{1+c}{1+a} = \\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a}$ [l1];\n\u2022 $\\frac{(1+a)b}{1+b} + \\frac{(1+b)c}{1+c} + \\frac{(1+c)a}{1+a} \\ge 3 \\sqrt[3]{abc}$ [l2];\n\u2022 $3 \\sqrt[3]{abc} \\ge 3$ [l3].\nTherefore, we conclude:\n\u2022 $a+b+c \\ge \\frac{1+a}{1+b} + \\frac{1+b}{1+c} + \\frac{1+c}{1+a}$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (l1 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n        (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a))\n  (l2 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n        3 * (a * b * c) ^ (1/3 : \u211d))\n  (l3 : 3 * (a * b * c) ^ (1/3 : \u211d) \u2265 3) :\n  a + b + c \u2265 (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b c : \u211d) \n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h_constraint : 1 \u2264 a * b * c)\n  (l1 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = \n        (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a))\n  (l2 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 \n        3 * (a * b * c) ^ (1/3 : \u211d))\n  (l3 : 3 * (a * b * c) ^ (1/3 : \u211d) \u2265 3) :\n  a + b + c \u2265 (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) := by\n  have h_sum_ge_three : a + b + c \u2265 3 := by\n    have h\u2081 : 0 < a * b := by positivity\n    have h\u2082 : 0 < a * c := by positivity\n    have h\u2083 : 0 < b * c := by positivity\n    have h\u2084 : 0 < a * b * c := by positivity\n    have h\u2085 : (a + b + c) ^ 3 \u2265 27 * (a * b * c) := by\n      nlinarith [sq_nonneg (a + b + c), sq_nonneg (a - b), sq_nonneg (a - c), sq_nonneg (b - c),\n        mul_nonneg ha.le hb.le, mul_nonneg ha.le hc.le, mul_nonneg hb.le hc.le,\n        sq_nonneg (a + b - c), sq_nonneg (a + c - b), sq_nonneg (b + c - a)]\n    have h\u2086 : (a + b + c) ^ 3 \u2265 27 := by\n      calc\n        (a + b + c) ^ 3 \u2265 27 * (a * b * c) := h\u2085\n        _ \u2265 27 * 1 := by gcongr <;> nlinarith\n        _ = 27 := by ring\n    have h\u2087 : a + b + c \u2265 3 := by\n      by_contra h\n      have h\u2088 : a + b + c < 3 := by linarith\n      have h\u2089 : (a + b + c) ^ 3 < 27 := by\n        have h\u2081\u2080 : 0 < a + b + c := by positivity\n        have h\u2081\u2081 : a + b + c < 3 := h\u2088\n        have h\u2081\u2082 : (a + b + c) ^ 3 < 3 ^ 3 := by\n          gcongr <;> nlinarith\n        linarith\n      linarith\n    exact h\u2087\n  \n  have h_main : a + b + c \u2265 (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) := by\n    have h\u2081 : (1 + a) / (1 + b) + (1 + b) / (1 + c) + (1 + c) / (1 + a) = (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) := by\n      linarith\n    rw [h\u2081]\n    have h\u2082 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 3 * (a * b * c) ^ (1 / 3 : \u211d) := by\n      linarith\n    have h\u2083 : 3 * (a * b * c) ^ (1 / 3 : \u211d) \u2265 3 := by\n      linarith\n    have h\u2084 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2265 3 := by\n      linarith\n    have h\u2085 : a + b + c \u2265 3 := by\n      linarith\n    -- Use the fact that each term (1 + x)*y/(1 + y) is less than or equal to a certain expression involving a, b, c\n    have h\u2086 : (1 + a) * b / (1 + b) + (1 + b) * c / (1 + c) + (1 + c) * a / (1 + a) \u2264 a + b + c := by\n      have h\u2087 : 0 < 1 + a := by linarith\n      have h\u2088 : 0 < 1 + b := by linarith\n      have h\u2089 : 0 < 1 + c := by linarith\n      have h\u2081\u2080 : 0 < (1 + a) * (1 + b) * (1 + c) := by positivity\n      field_simp [h\u2088.ne', h\u2089.ne', h\u2087.ne']\n      rw [div_le_iff (by positivity)]\n      nlinarith [sq_nonneg (a - 1), sq_nonneg (b - 1), sq_nonneg (c - 1),\n        mul_nonneg ha.le hb.le, mul_nonneg ha.le hc.le, mul_nonneg hb.le hc.le,\n        mul_nonneg (sq_nonneg (a - 1)) hc.le, mul_nonneg (sq_nonneg (b - 1)) ha.le,\n        mul_nonneg (sq_nonneg (c - 1)) hb.le, mul_nonneg (sq_nonneg (a - 1)) hb.le,\n        mul_nonneg (sq_nonneg (b - 1)) hc.le, mul_nonneg (sq_nonneg (c - 1)) ha.le]\n    linarith\n  \n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all components from the natural language. The positivity conditions for a, b, c are properly declared, the constraint abc \u2265 1 is equivalent to 1 \u2264 a * b * c, all three intermediate conditions (l1, l2, l3) are accurately formalized with correct mathematical expressions, and the conclusion exactly matches the target inequality. The additional variable names (ha, hb, hc, h_constraint) are standard Lean practice and don't affect the logical content.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    