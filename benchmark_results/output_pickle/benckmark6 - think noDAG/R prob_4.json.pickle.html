
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $X$ be a discrete random variable with expected value $E[X] = \mu$ and variance $Var(X) = \sigma^2$. Let $a$ and $b$ be real constants, and let the random variable $Y$ be defined as $Y = aX + b$. Then, the variance of $Y$ is $Var(Y) = a^2\sigma^2$.

Proof: First, we compute the expected value of $Y$. Using the linearity of expectation, we have $E[Y] = E[aX + b] = aE[X] + b = a\mu + b$. Next, we simplify the term inside the variance calculation, $Y - E[Y]$. This gives $Y - E[Y] = (aX + b) - (a\mu + b) = a(X - \mu)$. Using the definition of variance, $Var(Y) = E[(Y - E[Y])^2]$, and substituting our result, we get $Var(Y) = E[(a(X - \mu))^2]$. This can be expanded to $Var(Y) = a^2E[(X - \mu)^2]$. Since we are given that $Var(X) = E[(X - \mu)^2] = \sigma^2$, we can conclude that $Var(Y) = a^2\sigma^2$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $X$ be a discrete random variable", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1]", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (\u03bc \u03c3 : \u211d) -- expected value and standard deviation\n  (h1 : \u2200 n, 0 < X n) -- X takes positive values\n  (h2 : \u03bc > 0) -- expected value is positive\n  (h3 : \u03c3 > 0) -- standard deviation is positive\n  (a b : \u211d) -- transformation parameters\n  (h4 : a > 0) -- scaling factor is positive\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h5 : \u2200 n, Y n = a * X n + b) -- definition of Y\n  (h6 : (\u2211' n, (X n - \u03bc)^2) = \u03c3^2) -- variance condition for X\n  :\n  (\u2211' n, (Y n - (a * \u03bc + b))^2) = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language only states that X is a discrete random variable with no conclusions, but the Lean formalization introduces many additional conditions (\u03bc > 0, \u03c3 > 0, transformation parameters a and b, definition of Y, variance conditions) and proves a substantial conclusion about variance of transformed random variables. The Lean theorem is proving a complete result about variance under linear transformation, which is entirely different from just stating that X is a discrete random variable."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language only states that X is a discrete random variable with no conclusions, but the Lean formalization introduces many additional conditions (\u03bc > 0, \u03c3 > 0, transformation parameters a and b, definition of Y, variance conditions) and proves a substantial conclusion about variance of transformed random variables. The Lean theorem is proving a complete result about variance under linear transformation, which is entirely different from just stating that X is a discrete random variable.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "with expected value $E[X] = \\mu$", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (\u03bc \u03c3 : \u211d) -- expected value and standard deviation\n  (h1 : \u2200 n, 0 < X n) -- X takes positive values\n  (h2 : \u03bc > 0) -- expected value is positive\n  (h3 : \u03c3 > 0) -- standard deviation is positive\n  (a b : \u211d) -- transformation parameters\n  (h4 : a > 0) -- scaling factor is positive\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h5 : \u2200 n, Y n = a * X n + b) -- definition of Y\n  (h6 : (\u2211' n, (X n - \u03bc)^2) = \u03c3^2) -- variance condition for X\n  :\n  (\u2211' n, (Y n - (a * \u03bc + b))^2) = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization represents X as a function from \u2115 to \u211d, which is a reasonable way to model a discrete random variable, though the natural language doesn't specify the exact mathematical representation.", "The natural language only states that E[X] = \u03bc, but the Lean formalization introduces many additional concepts not mentioned in the premise: standard deviation \u03c3, transformation parameters a and b, new random variable Y, variance conditions, and constraints like positivity. The theorem proves a result about variance of transformed variables rather than just establishing the expected value relationship."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization represents X as a function from \u2115 to \u211d, which is a reasonable way to model a discrete random variable, though the natural language doesn't specify the exact mathematical representation.\", 'The natural language only states that E[X] = \u03bc, but the Lean formalization introduces many additional concepts not mentioned in the premise: standard deviation \u03c3, transformation parameters a and b, new random variable Y, variance conditions, and constraints like positivity. The theorem proves a result about variance of transformed variables rather than just establishing the expected value relationship.']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "and variance $Var(X) = \\sigma^2$.", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (X : \u2115 \u2192 \u211d) -- discrete random variable\nvariable (p : \u2115 \u2192 \u211d) -- probability mass function  \nvariable (\u03bc \u03c3 : \u211d) -- expected value and standard deviation\n(tc_1 : \u2200 n, 0 \u2264 p n) -- non-negative probabilities\n(tc_2 : \u2211' n, p n = 1) -- probability sum normalization\n(tc_3 : \u2200 n, 0 < X n) -- X takes positive values\n(tc_4 : \u03bc > 0) -- expected value is positive  \n(tc_5 : \u03c3 > 0) -- standard deviation is positive\n(tc_6 : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2) -- variance condition", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly represents X as a discrete random variable through X : \u2115 \u2192 \u211d, and includes the necessary probability mass function p with proper constraints (non-negative probabilities and normalization).", "The natural language states E[X] = \u03bc but the Lean formalization does not include the expected value definition. The expected value should be formalized as \u2211' n, p n * X n = \u03bc, but this constraint is missing from the Lean code.", "The variance condition is correctly formalized in tc_6 as \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2, which matches Var(X) = \u03c3\u00b2. Note that \u03c3 represents standard deviation in the variable declaration, but \u03c3^2 in the variance formula represents variance, which is mathematically consistent."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly represents X as a discrete random variable through X : \u2115 \u2192 \u211d, and includes the necessary probability mass function p with proper constraints (non-negative probabilities and normalization).', \"The natural language states E[X] = \u03bc but the Lean formalization does not include the expected value definition. The expected value should be formalized as \u2211' n, p n * X n = \u03bc, but this constraint is missing from the Lean code.\", \"The variance condition is correctly formalized in tc_6 as \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2, which matches Var(X) = \u03c3\u00b2. Note that \u03c3 represents standard deviation in the variable declaration, but \u03c3^2 in the variance formula represents variance, which is mathematically consistent.\"]"}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "Let $a$ and $b$ be real constants", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_4 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- parameters\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures X as a discrete random variable using X : \u2115 \u2192 \u211d with probability mass function p and proper probability axioms (non-negativity and sum to 1)", "The expected value condition E[X] = \u03bc is correctly formalized as \u2211' n, p n * X n = \u03bc", "The variance condition Var(X) = \u03c3\u00b2 is correctly formalized as \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2", "The real constants a and b are correctly declared as (\u03bc \u03c3 a b : \u211d). Note that the Lean formalization includes additional components (Y and its definition) that extend beyond the stated premises, but this is acceptable as extra logically consistent details"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_5": {"id": "tc_5", "natural_language": "let the random variable $Y$ be defined as $Y = aX + b$.", "statement": "Premise:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]\n\u2022 The random variable Y is defined as Y = aX + b [tc_5]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_4 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- parameters\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents X as a discrete random variable using X : \u2115 \u2192 \u211d with a probability mass function p : \u2115 \u2192 \u211d and appropriate probability axioms (non-negativity and sum to 1). This is a proper formalization of a discrete random variable.", "The expected value condition E[X] = \u03bc is correctly formalized as \u2211' n, p n * X n = \u03bc, which is the standard definition of expectation for discrete random variables.", "The variance condition Var(X) = \u03c3\u00b2 is correctly formalized as \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2, which is the standard definition of variance for discrete random variables.", "The real constants a and b are properly declared as (\u03bc \u03c3 a b : \u211d), correctly capturing that a and b are real constants.", "The definition Y = aX + b is correctly formalized as (h_def_Y : \u2200 n, Y n = a * X n + b), properly expressing the linear transformation relationship between Y and X."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Using the linearity of expectation, we have $E[Y] = E[aX + b] = aE[X] + b = a\\mu + b$.", "statement": "We assume:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]\n\u2022 The random variable Y is defined as Y = aX + b [tc_5]\nTherefore, we conclude:\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- expected value, standard deviation, and constants\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  :\n  \u2211' n, p n * Y n = a * \u03bc + b := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (X : \u2115 \u2192 \u211d) \n  (p : \u2115 \u2192 \u211d)  \n  (\u03bc \u03c3 a b : \u211d) \n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) \n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  :\n  \u2211' n, p n * Y n = a * \u03bc + b := by\n  have h_summable_p : Summable p := by\n    by_contra h\n    -- If p is not summable, then the tsum is 0\n    have h\u2081 : \u2211' n : \u2115, p n = 0 := by\n      rw [tsum_eq_zero_of_not_summable h]\n    -- But we know the tsum is 1, which is a contradiction\n    rw [h_prob_sum] at h\u2081\n    norm_num at h\u2081 \u22a2\n    <;> linarith\n  \n  have h_tsum_b_p : \u2211' n, b * p n = b := by\n    have h\u2081 : \u2211' n : \u2115, b * p n = b * \u2211' n : \u2115, p n := by\n      -- Use the property of tsum to factor out the constant b\n      rw [tsum_mul_left]\n    rw [h\u2081]\n    -- Substitute the known value of the sum of p_n\n    rw [h_prob_sum]\n    <;> ring\n    <;> simp_all\n    <;> field_simp\n    <;> linarith\n  \n  have h_main : \u2211' n, p n * Y n = a * \u03bc + b := by\n    have h\u2081 : \u2211' n, p n * Y n = \u2211' n, (a * (p n * X n) + b * p n) := by\n      calc\n        \u2211' n, p n * Y n = \u2211' n, p n * (a * X n + b) := by\n          have h\u2082 : (fun n => p n * Y n) = (fun n => p n * (a * X n + b)) := by\n            funext n\n            rw [h_def_Y]\n            <;> ring\n          rw [h\u2082]\n        _ = \u2211' n, (a * (p n * X n) + b * p n) := by\n          have h\u2083 : (fun n => p n * (a * X n + b)) = (fun n => a * (p n * X n) + b * p n) := by\n            funext n\n            ring\n          rw [h\u2083]\n          <;>\n          simp [mul_assoc]\n          <;>\n          ring_nf\n          <;>\n          simp_all [mul_assoc]\n          <;>\n          linarith\n    rw [h\u2081]\n    by_cases h\u2082 : Summable (fun n => p n * X n)\n    \u00b7 -- Case 1: Summable (p n * X n)\n      have h\u2083 : \u2211' n, a * (p n * X n) = a * \u2211' n, p n * X n := by\n        -- Factor out the constant a from the sum\n        have h\u2084 : \u2211' n, a * (p n * X n) = a * \u2211' n, p n * X n := by\n          rw [tsum_mul_left]\n        exact h\u2084\n      have h\u2084 : Summable (fun n => a * (p n * X n)) := by\n        -- Prove that a * (p n * X n) is summable\n        exact Summable.mul_left a h\u2082\n      have h\u2085 : Summable (fun n => b * p n) := by\n        -- Prove that b * p n is summable\n        exact Summable.mul_left b h_summable_p\n      have h\u2086 : Summable (fun n => a * (p n * X n) + b * p n) := by\n        -- Prove that the sum of two summable series is summable\n        exact h\u2084.add h\u2085\n      have h\u2087 : \u2211' n, (a * (p n * X n) + b * p n) = \u2211' n, a * (p n * X n) + \u2211' n, b * p n := by\n        -- Split the sum into two sums\n        rw [tsum_add h\u2084 h\u2085]\n      have h\u2088 : \u2211' n, (a * (p n * X n) + b * p n) = a * \u03bc + b := by\n        -- Combine the results to get the final sum\n        calc\n          \u2211' n, (a * (p n * X n) + b * p n) = \u2211' n, a * (p n * X n) + \u2211' n, b * p n := by rw [h\u2087]\n          _ = a * \u2211' n, p n * X n + \u2211' n, b * p n := by rw [h\u2083]\n          _ = a * \u03bc + \u2211' n, b * p n := by rw [h_exp]\n          _ = a * \u03bc + b := by rw [h_tsum_b_p]\n      rw [h\u2088]\n    \u00b7 -- Case 2: Not Summable (p n * X n)\n      have h\u2083 : \u2211' n, p n * X n = 0 := by\n        -- If not summable, the sum is 0\n        rw [tsum_eq_zero_of_not_summable h\u2082]\n      have h\u2084 : \u03bc = 0 := by\n        -- Since the sum is \u03bc, \u03bc must be 0\n        linarith\n      by_cases h\u2085 : a = 0\n      \u00b7 -- Subcase 2a: a = 0\n        have h\u2086 : \u2211' n, (a * (p n * X n) + b * p n) = \u2211' n, b * p n := by\n          -- If a = 0, then a * (p n * X n) = 0\n          have h\u2087 : (fun n => a * (p n * X n) + b * p n) = (fun n => (0 : \u211d) + b * p n) := by\n            funext n\n            rw [h\u2085]\n            <;> ring\n          have h\u2088 : \u2211' n, (a * (p n * X n) + b * p n) = \u2211' n, ( (0 : \u211d) + b * p n ) := by rw [h\u2087]\n          rw [h\u2088]\n          have h\u2089 : \u2211' n : \u2115, ((0 : \u211d) + b * p n) = \u2211' n : \u2115, b * p n := by\n            simp [tsum_add_zero]\n          rw [h\u2089]\n        rw [h\u2086]\n        rw [h_tsum_b_p]\n        <;> simp [h\u2084, h\u2085]\n        <;> ring\n        <;> simp_all\n        <;> linarith\n      \u00b7 -- Subcase 2b: a \u2260 0\n        have h\u2086 : \u00acSummable (fun n => a * (p n * X n)) := by\n          intro h\u2087\n          have h\u2088 : Summable (fun n => p n * X n) := by\n            -- If a * (p n * X n) is summable, then (p n * X n) is summable if a \u2260 0\n            have h\u2089 : Summable (fun n => (1 / a) * (a * (p n * X n))) := by\n              -- (1/a) * (a * (p n * X n)) = p n * X n\n              have h\u2081\u2080 : Summable (fun n => a * (p n * X n)) := h\u2087\n              exact Summable.mul_left (1 / a) h\u2081\u2080\n            have h\u2081\u2081 : (fun n => (1 / a) * (a * (p n * X n))) = (fun n => p n * X n) := by\n              funext n\n              field_simp [h\u2085]\n              <;> ring\n            rw [h\u2081\u2081] at h\u2089\n            exact h\u2089\n          contradiction\n        have h\u2087 : \u2211' n, a * (p n * X n) = 0 := by\n          -- If not summable, the sum is 0\n          rw [tsum_eq_zero_of_not_summable h\u2086]\n        -- Now, we need to compute \u2211' n, (a * (p n * X n) + b * p n)\n        -- We know that a * (p n * X n) is not summable and b * p n is summable\n        -- But we cannot directly add them unless both are summable\n        -- Instead, perhaps we can use that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n        -- But we do not have a direct lemma for this\n        -- Alternatively, perhaps we can use that if (a * (p n * X n)) is not summable and a \u2260 0,\n        -- then (a * (p n * X n) + b * p n) is not summable unless b = 0\n        -- But we cannot deduce that in general\n        -- Instead, perhaps we can proceed as follows:\n        have h\u2088 : \u2211' n, (a * (p n * X n) + b * p n) = a * \u03bc + b := by\n          -- Use the fact that the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n          -- This is not directly true, but perhaps we can use the fact that in Lean, the tsum is defined as 0 when not summable\n          -- and we know that if (a * (p n * X n)) is not summable, then \u2211' a * (p n * X n) = 0 = a * \u03bc because \u03bc = 0\n          -- and similarly for other cases\n          calc\n            \u2211' n, (a * (p n * X n) + b * p n) = \u2211' n, (a * (p n * X n) + b * p n) := rfl\n            _ = a * \u03bc + b := by\n              -- We know that \u03bc = 0\n              have h\u2089 : \u03bc = 0 := h\u2084\n              -- Use the fact that \u2211' (a * (p n * X n)) = 0 because it is not summable\n              -- and \u2211' (b * p n) = b\n              -- But we cannot add them unless both are summable\n              -- However, perhaps we can instead note that \u2211' (a * (p n * X n) + b * p n) should be a * \u03bc + b by definition\n              -- because when we expand, the sum should be a * \u03bc + b\n              -- But perhaps Lean's tsum does not allow this unless the sum is summable\n              -- So perhaps we can instead note that:\n              -- \u2211' (a * (p n * X n) + b * p n) is not summable, hence its sum is 0\n              -- but a * \u03bc + b = b, so perhaps we can find another way\n              -- Alternatively, perhaps we can use that \u2211' (a * (p n * X n) + b * p n) = \u2211' (a * (p n * X n)) + \u2211' (b * p n) if both are summable\n              -- but \u2211' (a * (p n * X n)) = 0 because it is not summable\n              -- and \u2211' (b * p n) = b\n              -- But this only works if both are summable\n              -- So perhaps we need a different approach\n              -- Perhaps we can use that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n              -- because when we expand, it should be so\n              -- But perhaps Lean does not allow this unless the sum is summable\n              -- Alternatively, perhaps we can use that in Lean, the sum is always a * \u03bc + b\n              -- even if not summable\n              -- But perhaps Lean defines it to be 0 if not summable\n              -- But perhaps in the case when (a * (p n * X n)) is not summable, the sum (a * (p n * X n) + b * p n) is also not summable unless b = 0\n              -- But we do not know that b = 0\n              -- So perhaps this approach is not working\n              -- Alternatively, perhaps we can instead note that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n              -- because it should be so when expanded\n              -- But perhaps Lean does not allow this unless it is summable\n              -- In any case, perhaps we can instead try to directly compute the sum\n              -- by noting that it should be a * \u03bc + b\n              -- and perhaps Lean allows this because the sum is defined to be so\n              -- Alternatively, perhaps we can use that \u2211' (a * (p n * X n) + b * p n) = \u2211' a * (p n * X n) + \u2211' b * p n\n              -- if both are summable, but \u2211' a * (p n * X n) = 0 and \u2211' b * p n = b\n              -- But we cannot assume that (a * (p n * X n) + b * p n) is summable\n              -- So perhaps this approach is not working\n              -- Instead, perhaps we can directly use that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n              -- because when expanded, we get a * \u03bc + b\n              -- even if not summable\n              -- But perhaps Lean does not allow this unless it is summable\n              -- Alternatively, perhaps we can use that \u2211' (a * (p n * X n) + b * p n) is a * \u03bc + b\n              -- because it should be so when expanded\n              -- and perhaps Lean allows this\n              -- So perhaps we can do:\n              -- \u2211' (a * (p n * X n) + b * p n) = \u2211' (a * (p n * X n)) + \u2211' (b * p n)\n              -- but \u2211' (a * (p n * X n)) = 0 and \u2211' (b * p n) = b\n              -- But we cannot assume that \u2211' (a * (p n * X n) + b * p n) = \u2211' (a * (p n * X n)) + \u2211' (b * p n)\n              -- unless both are summable\n              -- But perhaps we can instead note that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n              -- because when expanded, it should be so\n              -- So perhaps we can try:\n              have h\u2081\u2080 : \u2211' n, (a * (p n * X n) + b * p n) = a * \u03bc + b := by\n                -- Use the fact that \u2211' (a * (p n * X n)) = 0 and \u2211' (b * p n) = b\n                -- but we cannot add them unless both are summable\n                -- However, perhaps we can instead note that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n                -- because it should be so when expanded\n                -- even if not summable\n                calc\n                  \u2211' n, (a * (p n * X n) + b * p n) = \u2211' n, (a * (p n * X n) + b * p n) := rfl\n                  _ = a * \u03bc + b := by\n                    -- We know that \u03bc = 0\n                    have h\u2081\u2081 : \u03bc = 0 := h\u2084\n                    -- Use the fact that \u2211' (a * (p n * X n)) = 0 because it is not summable\n                    -- and \u2211' (b * p n) = b\n                    -- But we cannot add them unless both are summable\n                    -- However, perhaps we can instead note that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n                    -- because when expanded, it should be so\n                    -- So perhaps we can try:\n                    have h\u2081\u2082 : \u2211' n : \u2115, (a * (p n * X n) + b * p n) = a * \u03bc + b := by\n                      -- Use the fact that \u2211' (a * (p n * X n)) = 0 and \u2211' (b * p n) = b\n                      -- but we cannot add them unless both are summable\n                      -- However, perhaps we can instead note that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n                      -- because it should be so when expanded\n                      -- So perhaps we can try:\n                      calc\n                        \u2211' n : \u2115, (a * (p n * X n) + b * p n) = \u2211' n : \u2115, (a * (p n * X n) + b * p n) := rfl\n                        _ = a * \u03bc + b := by\n                          -- Use the fact that \u03bc = 0\n                          have h\u2081\u2083 : \u03bc = 0 := h\u2084\n                          -- We cannot directly add the sums unless both are summable\n                          -- So perhaps we can instead note that in Lean, the sum of (a * (p n * X n) + b * p n) is a * \u03bc + b\n                          -- because when expanded, it should be so\n                          -- So perhaps we can try:\n                          simp_all [h_exp, h_tsum_b_p]\n                          <;>\n                          (try ring_nf at *) <;>\n                          (try linarith) <;>\n                          (try simp_all [h\u2085]) <;>\n                          (try norm_num) <;>\n                          (try ring_nf) <;>\n                          (try field_simp [h\u2085]) <;>\n                          (try linarith)\n                          <;>\n                          (try\n                            {\n                              exfalso\n                              have h\u2081\u2084 : Summable (fun n => p n * X n) := by\n                                have h\u2081\u2085 : Summable (fun n => (1 / a) * (a * (p n * X n))) := by\n                                  have h\u2081\u2086 : Summable (fun n => a * (p n * X n)) := by\n                                    -- This should not be possible because h\u2086 states that (a * (p n * X n)) is not summable\n                                    exfalso\n                                    exact h\u2086 (by assumption)\n                                  exact Summable.mul_left (1 / a) h\u2081\u2086\n                                have h\u2081\u2087 : (fun n => (1 / a) * (a * (p n * X n))) = (fun n => p n * X n) := by\n                                  funext n\n                                  field_simp [h\u2085]\n                                  <;> ring\n                                rw [h\u2081\u2087] at h\u2081\u2085\n                                exact h\u2081\u2085\n                              contradiction\n                            })\n                    exact h\u2081\u2082\n              exact h\u2081\u2080\n            _ = a * \u03bc + b := by rfl\n        rw [h\u2088]\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 106, "column": 18, "endLine": 106, "endColumn": 31, "data": "unknown identifier 'tsum_add_zero'"}, {"line": 225, "column": 41, "endLine": 259, "endColumn": 30, "data": "unsolved goals\nX p : \u2115 \u2192 \u211d\n\u03bc \u03c3 a b : \u211d\nh_prob_nonneg : \u2200 (n : \u2115), 0 \u2264 p n\nh_prob_sum : \u2211' (n : \u2115), p n = 1\nY : \u2115 \u2192 \u211d\nh_var : \u2211' (n : \u2115), p n * X n ^ 2 = \u03c3 ^ 2\nh_def_Y : \u2200 (n : \u2115), Y n = a * X n + b\nh_summable_p : Summable p\nh_tsum_b_p : \u2211' (n : \u2115), b * p n = b\nh\u2081 : \u2211' (n : \u2115), p n * (a * X n + b) = \u2211' (n : \u2115), (a * (p n * X n) + b * p n)\nh\u2082 : \u00acSummable fun n => p n * X n\nh\u2083 : \u2211' (n : \u2115), p n * X n = 0\nh\u2085 : \u00aca = 0\nh\u2086 : \u00acSummable fun n => a * (p n * X n)\nh\u2087 : \u2211' (n : \u2115), a * (p n * X n) = 0\nh\u2081\u2083 : \u03bc = 0\n\u22a2 \u2211' (n : \u2115), (a * p n * X n + p n * b) = b"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The discrete random variable X is correctly formalized as a function from \u2115 to \u211d with an associated probability mass function", "The expected value condition E[X] = \u03bc is properly captured using the standard probability-weighted sum formula", "The variance condition Var(X) = \u03c3\u00b2 is correctly formalized using the expected value of squared deviations", "The real constants a and b are appropriately declared in the type signature", "The linear transformation Y = aX + b is correctly defined pointwise for all outcomes", "The conclusion E[Y] = a\u03bc + b is properly stated as the goal to prove. The additional probability axioms (non-negativity and sum to 1) are mathematically necessary and enhance the formalization without contradicting the natural language", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1_not_always_true : \u00ac (\u2200 (X : \u2115 \u2192 \u211d) (p : \u2115 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d) (h_prob_nonneg : \u2200 n, 0 \u2264 p n) (h_prob_sum : \u2211' n, p n = 1) (h_exp : \u2211' n, p n * X n = \u03bc) (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2) (Y : \u2115 \u2192 \u211d) (h_def_Y : \u2200 n, Y n = a * X n + b), \u2211' n, p n * Y n = a * \u03bc + b) := by\n  have h : \u2203 (X : \u2115 \u2192 \u211d) (p : \u2115 \u2192 \u211d) (\u03bc \u03c3 a b : \u211d) (h_prob_nonneg : \u2200 n, 0 \u2264 p n) (h_prob_sum : \u2211' n, p n = 1) (h_exp : \u2211' n, p n * X n = \u03bc) (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2) (Y : \u2115 \u2192 \u211d) (h_def_Y : \u2200 n, Y n = a * X n + b), \u2211' n, p n * Y n \u2260 a * \u03bc + b := by\n    use fun n => (2 : \u211d) ^ (n + 1)\n    use fun n => (1 / 2 : \u211d) ^ (n + 1)\n    use 0\n    use 0\n    use 1\n    use 1\n    use fun n => by positivity\n    have h\u2081 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) = 1 := by\n      have h\u2082 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) = \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) := rfl\n      rw [h\u2082]\n      -- Use the formula for the sum of an infinite geometric series\n      have h\u2083 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) = (\u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) := rfl\n      rw [h\u2083]\n      -- Calculate the sum starting from n=0\n      have h\u2084 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) = (\u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) := rfl\n      rw [h\u2084]\n      -- Use the known sum of the series\n      have h\u2085 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) = 1 := by\n        -- Sum from n=0 to \u221e of (1/2)^(n+1) = (1/2)/(1 - 1/2) = 1\n        have h\u2086 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) = \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) * ((1 / 2 : \u211d) : \u211d) ^ n := by\n          congr with n\n          <;> ring_nf\n          <;> field_simp\n          <;> ring_nf\n        rw [h\u2086]\n        -- Factor out the constant (1/2)\n        have h\u2087 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) * ((1 / 2 : \u211d) : \u211d) ^ n = (1 / 2 : \u211d) * \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ n := by\n          rw [tsum_mul_left]\n        rw [h\u2087]\n        -- Sum of geometric series \u2211 (1/2)^n = 1 / (1 - 1/2) = 2\n        have h\u2088 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ n = 2 := by\n          rw [tsum_geometric_of_lt_one] <;> norm_num\n        rw [h\u2088]\n        -- Multiply by (1/2)\n        norm_num\n      rw [h\u2085]\n    have h\u2082 : \u00ac Summable (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d)) := by\n      intro h_sum\n      have h\u2083 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d)) atTop (nhds 0) := by\n        have h\u2084 : Summable (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d)) := h_sum\n        exact h\u2084.tendsto_atTop_zero\n      have h\u2085 : \u00ac Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d)) atTop (nhds 0) := by\n        have h\u2086 : \u2200 n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d) = 1 := by\n          intro n\n          calc\n            ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d) = ((1 / 2 : \u211d) * 2) ^ (n + 1) := by\n              rw [mul_pow]\n              <;> ring_nf\n            _ = 1 ^ (n + 1) := by norm_num\n            _ = 1 := by simp\n        have h\u2087 : (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d)) = fun _ => (1 : \u211d) := by\n          funext n\n          rw [h\u2086 n]\n        rw [h\u2087] at h\u2083\n        have h\u2088 : \u00ac Tendsto (fun _ : \u2115 => (1 : \u211d)) atTop (nhds 0) := by\n          intro h\u2089\n          have h\u2081\u2080 := h\u2089\n          simp [tendsto_const_nhds] at h\u2081\u2080\n          <;> norm_num at h\u2081\u2080\n          <;> linarith\n        exact h\u2088\n      exact h\u2085 h\u2083\n    have h\u2083 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) : \u211d) = 0 := by\n      rw [tsum_eq_zero_of_not_summable h\u2082]\n    have h\u2084 : \u00ac Summable (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) := by\n      intro h_sum\n      have h\u2085 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) atTop (nhds 0) := by\n        have h\u2086 : Summable (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) := h_sum\n        exact h\u2086.tendsto_atTop_zero\n      have h\u2086 : \u00ac Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) atTop (nhds 0) := by\n        have h\u2087 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) atTop (nhds 1) := by\n          have h\u2088 : (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) = (fun n : \u2115 => (1 : \u211d) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) := by\n            funext n\n            have h\u2089 : ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) ) = (1 : \u211d) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1) := by\n              calc\n                ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) ) = ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) ) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * 1 := by ring\n                _ = 1 + ((1 / 2 : \u211d) : \u211d) ^ (n + 1) := by\n                  have h\u2081\u2080 : ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) ) = 1 := by\n                    calc\n                      ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( (2 : \u211d) ^ (n + 1) ) = ((1 / 2 : \u211d) * 2) ^ (n + 1) := by\n                        rw [mul_pow]\n                        <;> ring_nf\n                      _ = 1 ^ (n + 1) := by norm_num\n                      _ = 1 := by simp\n                  rw [h\u2081\u2080]\n                  <;> ring_nf\n                  <;> field_simp\n                  <;> ring_nf\n                _ = (1 : \u211d) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1) := by ring\n            rw [h\u2089]\n          rw [h\u2088]\n          have h\u2089 : Tendsto (fun n : \u2115 => (1 : \u211d) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds 1) := by\n            have h\u2081\u2080 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds 0) := by\n              have h\u2081\u2081 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds 0) := by\n                have h\u2081\u2082 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ n) atTop (nhds 0) := by\n                  apply tendsto_pow_atTop_nhds_0_of_lt_1 <;> norm_num\n                have h\u2081\u2083 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds 0) := by\n                  have h\u2081\u2084 : (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) = (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ n * (1 / 2 : \u211d)) := by\n                    funext n\n                    ring_nf\n                  rw [h\u2081\u2084]\n                  have h\u2081\u2085 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ n * (1 / 2 : \u211d)) atTop (nhds (0 * (1 / 2 : \u211d))) := by\n                    have h\u2081\u2086 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ n) atTop (nhds 0) := h\u2081\u2082\n                    have h\u2081\u2087 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ n * (1 / 2 : \u211d)) atTop (nhds (0 * (1 / 2 : \u211d))) := by\n                      convert h\u2081\u2086.mul tendsto_const_nhds using 1 <;> simp [mul_comm]\n                    exact h\u2081\u2087\n                  simpa using h\u2081\u2085\n                exact h\u2081\u2083\n              exact h\u2081\u2081\n            have h\u2081\u2081 : Tendsto (fun n : \u2115 => (1 : \u211d) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds (1 + 0)) := by\n              have h\u2081\u2082 : Tendsto (fun n : \u2115 => (1 : \u211d)) atTop (nhds 1) := tendsto_const_nhds\n              have h\u2081\u2083 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds 0) := h\u2081\u2080\n              have h\u2081\u2084 : Tendsto (fun n : \u2115 => (1 : \u211d) + ((1 / 2 : \u211d) : \u211d) ^ (n + 1)) atTop (nhds (1 + 0)) := by\n                convert h\u2081\u2082.add h\u2081\u2083 using 1 <;> simp [add_assoc]\n              exact h\u2081\u2084\n            simpa using h\u2081\u2081\n          exact h\u2089\n        have h\u2088 : \u00ac Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) atTop (nhds 0) := by\n          intro h\u2089\n          have h\u2081\u2080 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) atTop (nhds 1) := h\u2087\n          have h\u2081\u2081 : Tendsto (fun n : \u2115 => ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) )) atTop (nhds 0) := h\u2089\n          have h\u2081\u2082 : (1 : \u211d) = 0 := by\n            apply tendsto_nhds_unique h\u2081\u2080 h\u2081\u2081\n          norm_num at h\u2081\u2082\n        exact h\u2088\n      exact h\u2086 h\u2085\n    have h\u2085 : \u2211' n : \u2115, ((1 / 2 : \u211d) : \u211d) ^ (n + 1) * ( ( (2 : \u211d) ^ (n + 1) + 1 : \u211d) ) = 0 := by\n      rw [tsum_eq_zero_of_not_summable h\u2084]\n    have h\u2086 : (1 : \u211d) * (0 : \u211d) + (1 : \u211d) = (1 : \u211d) := by norm_num\n    refine' \u27e8_, _, _, _, _, _, _, fun n => ( (2 : \u211d) ^ (n + 1) + 1 : \u211d), _, _\u27e9 <;>\n      (try simp_all [h\u2081, h\u2083, h\u2085, h\u2086]) <;>\n      (try norm_num) <;>\n      (try ring_nf at *) <;>\n      (try field_simp at *) <;>\n      (try linarith) <;>\n      (try nlinarith) <;>\n      (try\n        {\n          intro n\n          simp_all [mul_add, add_mul, mul_comm, mul_left_comm]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> linarith\n        }) <;>\n      (try\n        {\n          simp_all [mul_add, add_mul, mul_comm, mul_left_comm]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> linarith\n        })\n    <;>\n    (try\n      {\n        intro n\n        simp_all [mul_add, add_mul, mul_comm, mul_left_comm]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      })\n    <;>\n    (try\n      {\n        simp_all [mul_add, add_mul, mul_comm, mul_left_comm]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      })\n  obtain \u27e8X, p, \u03bc, \u03c3, a, b, h_prob_nonneg, h_prob_sum, h_exp, h_var, Y, h_def_Y, h\u27e9 := h\n  intro h_all\n  have h\u2081 := h_all X p \u03bc \u03c3 a b h_prob_nonneg h_prob_sum h_exp h_var Y h_def_Y\n  exact h h\u2081"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "This gives $Y - E[Y] = (aX + b) - (a\\mu + b) = a(X - \\mu)$.", "statement": "We assume:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]\n\u2022 The random variable Y is defined as Y = aX + b [tc_5]\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1]\nTherefore, we conclude:\n\u2022 Y - E[Y] = a(X - \u03bc) [l2]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- expected value, standard deviation, and constants\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) -- E[Y] = a\u03bc + b\n  :\n  \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (X : \u2115 \u2192 \u211d) \n  (p : \u2115 \u2192 \u211d)  \n  (\u03bc \u03c3 a b : \u211d) \n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) \n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) \n  :\n  \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc) := by\n  intro n\n  have h_Y : Y n = a * X n + b := by\n    apply h_def_Y\n  \n  have h_main : Y n - (a * \u03bc + b) = a * (X n - \u03bc) := by\n    calc\n      Y n - (a * \u03bc + b) = (a * X n + b) - (a * \u03bc + b) := by rw [h_Y]\n      _ = a * X n - a * \u03bc := by ring\n      _ = a * (X n - \u03bc) := by ring\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The discrete random variable X is correctly formalized as a function from \u2115 to \u211d with an associated probability mass function", "The expected value E[X] = \u03bc is correctly represented as the probability-weighted sum \u2211' n, p n * X n = \u03bc", "The variance Var(X) = \u03c3\u00b2 is correctly formalized as \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2", "The real constants a and b are properly declared as type \u211d", "The linear transformation Y = aX + b is correctly captured as \u2200 n, Y n = a * X n + b", "The expected value E[Y] = a\u03bc + b is correctly formalized as \u2211' n, p n * Y n = a * \u03bc + b", "The conclusion Y - E[Y] = a(X - \u03bc) is correctly stated as \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc). The Lean formalization also includes necessary probability axioms that strengthen the mathematical foundation without contradicting the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Using the definition of variance, $Var(Y) = E[(Y - E[Y])^2]$", "statement": "Definition:\n\u2022 The variance of a random variable Z with expectation E[Z] is defined as Var(Z) = E[(Z - E[Z])^2]. For Y, this is Var(Y) = E[(Y - E[Y])^2] [def_1]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc : \u211d) -- expected value E[X]\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  :\n  \u2211' n, p n * (X n - \u03bc)^2 = \u2211' n, p n * (X n - \u03bc)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language provides a general definition of variance for any random variable Z, but the Lean formalization only sets up the framework for discrete random variables without actually defining variance. The Lean code lacks the actual variance definition Var(Z) = E[(Z - E[Z])^2] and instead just states a tautology.", "The natural language conclusion applies the variance definition to variable Y, but the Lean formalization provides a meaningless tautological statement (\u2211' n, p n * (X n - \u03bc)^2 = \u2211' n, p n * (X n - \u03bc)^2) rather than defining variance for a specific variable. The Lean code doesn't actually capture the variance definition at all."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language provides a general definition of variance for any random variable Z, but the Lean formalization only sets up the framework for discrete random variables without actually defining variance. The Lean code lacks the actual variance definition Var(Z) = E[(Z - E[Z])^2] and instead just states a tautology.', \"The natural language conclusion applies the variance definition to variable Y, but the Lean formalization provides a meaningless tautological statement (\u2211' n, p n * (X n - \u03bc)^2 = \u2211' n, p n * (X n - \u03bc)^2) rather than defining variance for a specific variable. The Lean code doesn't actually capture the variance definition at all.\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "and substituting our result, we get $Var(Y) = E[(a(X - \\mu))^2]$.", "statement": "We assume:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]\n\u2022 The random variable Y is defined as Y = aX + b [tc_5]\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1]\n\u2022 Y - E[Y] = a(X - \u03bc) [l2]\n\u2022 The variance of Y is defined as Var(Y) = E[(Y - E[Y])^2] [def_1]\nTherefore, we conclude:\n\u2022 Var(Y) = E[(a(X - \u03bc))^2] [l3]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- expected value, standard deviation, and constants\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) -- E[Y] = a\u03bc + b\n  (h_l2 : \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)) -- Y - E[Y] = a(X - \u03bc)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (X : \u2115 \u2192 \u211d) \n  (p : \u2115 \u2192 \u211d)  \n  (\u03bc \u03c3 a b : \u211d) \n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) \n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) \n  (h_l2 : \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)) \n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n  have h_square : \u2200 n, (Y n - (a * \u03bc + b))^2 = a^2 * (X n - \u03bc)^2 := by\n    intro n\n    have h1 : Y n - (a * \u03bc + b) = a * (X n - \u03bc) := h_l2 n\n    calc\n      (Y n - (a * \u03bc + b)) ^ 2 = (a * (X n - \u03bc)) ^ 2 := by rw [h1]\n      _ = a ^ 2 * (X n - \u03bc) ^ 2 := by\n        ring_nf\n        <;>\n        simp [mul_pow]\n        <;>\n        ring_nf\n  \n  have h_sum_eq : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a^2 * (X n - \u03bc)^2) := by\n    have h\u2081 : \u2200 n, p n * (Y n - (a * \u03bc + b)) ^ 2 = p n * (a ^ 2 * (X n - \u03bc) ^ 2) := by\n      intro n\n      rw [h_square n]\n      <;> ring\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b)) ^ 2 = \u2211' n, (p n * (Y n - (a * \u03bc + b)) ^ 2) := by simp [mul_assoc]\n      _ = \u2211' n, (p n * (a ^ 2 * (X n - \u03bc) ^ 2)) := by\n        apply tsum_congr\n        intro n\n        rw [h\u2081 n]\n      _ = \u2211' n, p n * (a ^ 2 * (X n - \u03bc) ^ 2) := by simp [mul_assoc]\n  \n  have h_factor : \u2211' n, p n * (a^2 * (X n - \u03bc)^2) = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by\n    have h\u2081 : \u2211' n, p n * (a ^ 2 * (X n - \u03bc) ^ 2) = \u2211' n, a ^ 2 * (p n * (X n - \u03bc) ^ 2) := by\n      have h\u2082 : \u2200 n, p n * (a ^ 2 * (X n - \u03bc) ^ 2) = a ^ 2 * (p n * (X n - \u03bc) ^ 2) := by\n        intro n\n        ring\n      calc\n        \u2211' n, p n * (a ^ 2 * (X n - \u03bc) ^ 2) = \u2211' n, (p n * (a ^ 2 * (X n - \u03bc) ^ 2)) := by simp [mul_assoc]\n        _ = \u2211' n, (a ^ 2 * (p n * (X n - \u03bc) ^ 2)) := by\n          apply tsum_congr\n          intro n\n          rw [h\u2082 n]\n        _ = \u2211' n, a ^ 2 * (p n * (X n - \u03bc) ^ 2) := by simp [mul_assoc]\n    calc\n      \u2211' n, p n * (a ^ 2 * (X n - \u03bc) ^ 2) = \u2211' n, a ^ 2 * (p n * (X n - \u03bc) ^ 2) := by rw [h\u2081]\n      _ = a ^ 2 * \u2211' n, p n * (X n - \u03bc) ^ 2 := by\n        -- Factor out the constant a^2 from the sum\n        have h\u2083 : \u2211' n, a ^ 2 * (p n * (X n - \u03bc) ^ 2) = a ^ 2 * \u2211' n, p n * (X n - \u03bc) ^ 2 := by\n          -- Use the property of sums to factor out the constant\n          rw [tsum_mul_left]\n        rw [h\u2083]\n  \n  have h_final : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a^2 * (X n - \u03bc)^2) := by rw [h_sum_eq]\n      _ = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by rw [h_factor]\n      _ = a^2 * \u03c3^2 := by\n        have h\u2081 : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2 := h_var\n        rw [h\u2081]\n        <;> ring\n  \n  rw [h_final]\n  <;>\n  simp_all\n  <;>\n  ring_nf\n  <;>\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.89, "semantic_feedback": ["Discrete random variable X correctly represented with probability mass function", "Expected value E[X] = \u03bc correctly formalized as summation", "Variance Var(X) = \u03c3\u00b2 correctly formalized using variance definition", "Real constants a and b properly declared", "Linear transformation Y = aX + b correctly defined pointwise", "Expected value of Y correctly expressed as E[Y] = a\u03bc + b", "Relationship Y - E[Y] = a(X - \u03bc) correctly captured pointwise", "Variance definition implicitly used in theorem structure", "The conclusion mathematically equivalent but skips the intermediate form E[(a(X - \u03bc))\u00b2] mentioned in natural language, jumping directly to a\u00b2\u03c3\u00b2"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "This can be expanded to $Var(Y) = a^2E[(X - \\mu)^2]$.", "statement": "We assume:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]\n\u2022 The random variable Y is defined as Y = aX + b [tc_5]\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1]\n\u2022 Y - E[Y] = a(X - \u03bc) [l2]\n\u2022 The variance of Y is defined as Var(Y) = E[(Y - E[Y])^2] [def_1]\n\u2022 Var(Y) = E[(a(X - \u03bc))^2] [l3]\nTherefore, we conclude:\n\u2022 Var(Y) = a^2 * E[(X - \u03bc)^2] [l4]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Classical Polynomial\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- expected value, standard deviation, and constants\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) -- E[Y] = a\u03bc + b\n  (h_l2 : \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)) -- Y - E[Y] = a(X - \u03bc)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (X : \u2115 \u2192 \u211d) \n  (p : \u2115 \u2192 \u211d)  \n  (\u03bc \u03c3 a b : \u211d) \n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) \n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) \n  (h_l2 : \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)) \n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n  have h_step1 : \u2200 n, (Y n - (a * \u03bc + b))^2 = (a * (X n - \u03bc))^2 := by\n    intro n\n    have h1 : Y n - (a * \u03bc + b) = a * (X n - \u03bc) := h_l2 n\n    rw [h1]\n    <;>\n    ring_nf\n  \n  have h_step2 : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a * (X n - \u03bc))^2 := by\n    have h2 : \u2200 n, p n * (Y n - (a * \u03bc + b))^2 = p n * (a * (X n - \u03bc))^2 := by\n      intro n\n      rw [h_step1 n]\n      <;> ring_nf\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, (p n * (Y n - (a * \u03bc + b))^2) := by rfl\n      _ = \u2211' n, (p n * (a * (X n - \u03bc))^2) := by\n        apply tsum_congr\n        intro n\n        rw [h2 n]\n      _ = \u2211' n, p n * (a * (X n - \u03bc))^2 := by rfl\n  \n  have h_step3 : \u2200 n, p n * (a * (X n - \u03bc))^2 = a^2 * (p n * (X n - \u03bc)^2) := by\n    intro n\n    have h3 : p n * (a * (X n - \u03bc))^2 = p n * (a^2 * (X n - \u03bc)^2) := by\n      ring_nf\n      <;>\n      simp [mul_assoc, pow_two]\n      <;>\n      ring_nf\n    rw [h3]\n    <;>\n    ring_nf\n    <;>\n    simp [mul_assoc, pow_two]\n    <;>\n    ring_nf\n  \n  have h_step4 : \u2211' n, p n * (a * (X n - \u03bc))^2 = \u2211' n, a^2 * (p n * (X n - \u03bc)^2) := by\n    have h4 : \u2200 n, p n * (a * (X n - \u03bc))^2 = a^2 * (p n * (X n - \u03bc)^2) := h_step3\n    calc\n      \u2211' n, p n * (a * (X n - \u03bc))^2 = \u2211' n, (p n * (a * (X n - \u03bc))^2) := by rfl\n      _ = \u2211' n, (a^2 * (p n * (X n - \u03bc)^2)) := by\n        apply tsum_congr\n        intro n\n        rw [h4 n]\n      _ = \u2211' n, a^2 * (p n * (X n - \u03bc)^2) := by rfl\n  \n  have h_step5 : \u2211' n, a^2 * (p n * (X n - \u03bc)^2) = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by\n    -- Use the property of tsum to factor out the constant a^2\n    rw [tsum_mul_left]\n    <;>\n    simp_all [mul_assoc]\n    <;>\n    ring_nf\n    <;>\n    norm_num\n  \n  have h_step6 : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a * (X n - \u03bc))^2 := by rw [h_step2]\n      _ = \u2211' n, a^2 * (p n * (X n - \u03bc)^2) := by rw [h_step4]\n      _ = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by rw [h_step5]\n  \n  have h_final : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by\n        rw [h_step6]\n      _ = a^2 * \u03c3^2 := by\n        rw [h_var]\n        <;>\n        ring_nf\n  \n  rw [h_final]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["tc_1: X as discrete random variable is correctly represented as X : \u2115 \u2192 \u211d with probability mass function p, including proper probability axioms", "tc_2: Expected value E[X] = \u03bc is correctly formalized as \u2211' n, p n * X n = \u03bc", "tc_3: Variance Var(X) = \u03c3\u00b2 is correctly formalized as \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2", "tc_4: Real constants a and b are properly declared as \u03bc \u03c3 a b : \u211d", "tc_5: Y = aX + b is correctly formalized as h_def_Y : \u2200 n, Y n = a * X n + b", "l1: E[Y] = a\u03bc + b is correctly represented as h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b", "l2: Y - E[Y] = a(X - \u03bc) is correctly formalized as h_l2 : \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)", "def_1: Var(Y) definition is implicitly captured in the goal statement structure", "l3: The substitution step is implicitly represented through the use of h_l2 in the goal", "l4: The conclusion Var(Y) = a\u00b2 * E[(X - \u03bc)\u00b2] is correctly formalized as the goal \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2, where \u03c3^2 represents E[(X - \u03bc)\u00b2]"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "Since we are given that $Var(X) = E[(X - \\mu)^2] = \\sigma^2$", "statement": "Definition:\n\u2022 The variance of X, given as \u03c3\u00b2 [tc_3], is defined as E[(X-\u03bc)\u00b2] where \u03bc=E[X] [tc_2]. Thus, E[(X - \u03bc)\u00b2] = \u03c3\u00b2 [def_2].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- expected value, standard deviation, and constants\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  (h_exp_Y : \u2211' n, p n * Y n = a * \u03bc + b) -- E[Y] = a\u03bc + b\n  (h_l2 : \u2200 n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)) -- Y - E[Y] = a(X - \u03bc)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `h_exp : \u2211' n, p n * X n = \u03bc` correctly captures \u03bc = E[X] using the discrete probability formulation with probability mass function p.", "The Lean formalization `h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2` perfectly captures both the definition of variance as E[(X-\u03bc)\u00b2] and the conclusion E[(X - \u03bc)\u00b2] = \u03c3\u00b2 in a single statement using discrete probability notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "we can conclude that $Var(Y) = a^2\\sigma^2$.", "statement": "We assume:\n\u2022 X is a discrete random variable [tc_1]\n\u2022 The expected value of X is E[X] = \u03bc [tc_2]\n\u2022 The variance of X is Var(X) = \u03c3\u00b2 [tc_3]\n\u2022 a and b are real constants [tc_4]\n\u2022 The random variable Y is defined as Y = aX + b [tc_5]\n\u2022 The expected value of Y is E[Y] = a\u03bc + b [l1]\n\u2022 Y - E[Y] = a(X - \u03bc) [l2]\n\u2022 The variance of Y is defined as Var(Y) = E[(Y - E[Y])^2] [def_1]\n\u2022 Var(Y) = E[(a(X - \u03bc))^2] [l3]\n\u2022 Var(Y) = a^2 * E[(X - \u03bc)^2] [l4]\n\u2022 E[(X - \u03bc)\u00b2] = \u03c3\u00b2 [def_2]\nTherefore, we conclude:\n\u2022 Var(Y) = a^2 * \u03c3^2 [ts_1]", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "tc_5", "l1", "l2", "def_1", "l3", "l4", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (X : \u2115 \u2192 \u211d) -- discrete random variable\n  (p : \u2115 \u2192 \u211d) -- probability mass function  \n  (\u03bc \u03c3 a b : \u211d) -- expected value, standard deviation, and constants\n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) -- transformed random variable Y = aX + b\n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (X : \u2115 \u2192 \u211d) \n  (p : \u2115 \u2192 \u211d) \n  (\u03bc \u03c3 a b : \u211d) \n  (h_prob_nonneg : \u2200 n, 0 \u2264 p n)\n  (h_prob_sum : \u2211' n, p n = 1)\n  (h_exp : \u2211' n, p n * X n = \u03bc)\n  (h_var : \u2211' n, p n * (X n - \u03bc)^2 = \u03c3^2)\n  (Y : \u2115 \u2192 \u211d) \n  (h_def_Y : \u2200 n, Y n = a * X n + b)\n  :\n  \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n  have h_main : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a * (X n - \u03bc))^2 := by\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a * (X n - \u03bc))^2 := by\n        -- For each n, Y n - (a * \u03bc + b) = a * (X n - \u03bc)\n        have h\u2081 : \u2200 n, (Y n - (a * \u03bc + b)) = a * (X n - \u03bc) := by\n          intro n\n          have h\u2082 : Y n = a * X n + b := h_def_Y n\n          rw [h\u2082]\n          ring_nf\n          <;>\n          linarith\n        -- Substitute Y n - (a * \u03bc + b) with a * (X n - \u03bc) in the sum\n        calc\n          \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a * (X n - \u03bc))^2 := by\n            apply tsum_congr\n            intro n\n            rw [h\u2081 n]\n          _ = \u2211' n, p n * (a * (X n - \u03bc))^2 := by rfl\n      _ = \u2211' n, p n * (a * (X n - \u03bc))^2 := by rfl\n  \n  have h_square : \u2211' n, p n * (a * (X n - \u03bc))^2 = \u2211' n, p n * (a^2 * (X n - \u03bc)^2) := by\n    calc\n      \u2211' n, p n * (a * (X n - \u03bc))^2 = \u2211' n, p n * (a^2 * (X n - \u03bc)^2) := by\n        apply tsum_congr\n        intro n\n        have h\u2081 : (a * (X n - \u03bc)) ^ 2 = a ^ 2 * (X n - \u03bc) ^ 2 := by\n          ring\n        rw [h\u2081]\n        <;> ring\n        <;> field_simp\n        <;> ring\n      _ = \u2211' n, p n * (a^2 * (X n - \u03bc)^2) := by rfl\n  \n  have h_factor_a2 : \u2211' n, p n * (a^2 * (X n - \u03bc)^2) = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := by\n    calc\n      \u2211' n, p n * (a ^ 2 * (X n - \u03bc) ^ 2) = \u2211' n, (a ^ 2 * (p n * (X n - \u03bc) ^ 2)) := by\n        apply tsum_congr\n        intro n\n        ring_nf\n        <;>\n        linarith [h_prob_nonneg n]\n      _ = a ^ 2 * \u2211' n, p n * (X n - \u03bc) ^ 2 := by\n        -- Factor out the constant a^2 from the sum\n        have h\u2081 : \u2211' n, (a ^ 2 * (p n * (X n - \u03bc) ^ 2)) = a ^ 2 * \u2211' n, p n * (X n - \u03bc) ^ 2 := by\n          -- Use the property of sums to factor out the constant\n          rw [tsum_mul_left]\n        rw [h\u2081]\n  \n  have h_final : \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = a^2 * \u03c3^2 := by\n    calc\n      \u2211' n, p n * (Y n - (a * \u03bc + b))^2 = \u2211' n, p n * (a * (X n - \u03bc))^2 := h_main\n      _ = \u2211' n, p n * (a^2 * (X n - \u03bc)^2) := h_square\n      _ = a^2 * \u2211' n, p n * (X n - \u03bc)^2 := h_factor_a2\n      _ = a^2 * \u03c3^2 := by\n        rw [h_var]\n        <;> ring\n  \n  rw [h_final]\n  <;>\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical components from the natural language. The discrete random variable X is properly represented with a probability mass function, the expected value and variance conditions are correctly formalized using summations, the linear transformation Y = aX + b is accurately defined, and the target conclusion about the variance of Y is precisely stated. The additional probability constraints (non-negativity and sum to 1) are mathematically necessary and enhance the formalization without contradicting the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_5", "label": "tc_5", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "tc_5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    