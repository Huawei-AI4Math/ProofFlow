
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = 2^n - 1$.

Proof: This proof uses **strong mathematical induction** because the recurrence relation for $a_n$ depends on two previous terms. First, we verify the formula for the initial terms, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1 = 2^1 - 1 = 1$. This matches the given value of $a_1=1$. For $n=2$, the formula gives $a_2 = 2^2 - 1 = 3$. This matches the given value of $a_2=3$. Now for the inductive step, assume the formula holds for all integers $j$ where $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^j - 1$ is true. We must now prove that the formula holds for $n=k+1$, i.e., $a_{k+1} = 2^{k+1} - 1$. Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = 3a_k - 2a_{k-1}$. By our assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$. Now we expand and simplify the expression: $a_{k+1} = 3 \cdot 2^k - 3 - 2 \cdot 2^{k-1} + 2 = 3 \cdot 2^k - 2^k - 1 = 2 \cdot 2^k - 1 = 2^{k+1} - 1$. This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^n - 1$ is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2203 a : \u2115 \u2192 \u211d, \n    a 1 = 1 \u2227 \n    a 2 = 3 \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The natural language mentions 'integers n \u2265 1' but Lean uses '\u2115 \u2192 \u211d' (naturals to reals). While \u2115 includes all positive integers, the natural language seems to suggest the domain could be all integers \u2265 1. However, this is a minor difference as \u2115 starting from 1 captures the intended domain, and the codomain being \u211d is a reasonable mathematical choice.", "Direct match: a 1 = 1 corresponds exactly to a\u2081 = 1", "Direct match: a 2 = 3 corresponds exactly to a\u2082 = 3", "Perfect match: the universal quantification and recurrence relation are identical in meaning", "The existential quantifier \u2203 in Lean captures the conclusion that such a sequence is completely determined/exists with the given properties"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1 = 2^1 - 1 = 1$. This matches the given value of $a_1=1$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=1$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2203 a : \u2115 \u2192 \u211d, \n    a 1 = 1 \u2227 \n    a 2 = 3 \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by sorry\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 3) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) :\n  a 1 = 2^1 - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2203 a : \u2115 \u2192 \u211d, \n    a 1 = 1 \u2227 \n    a 2 = 3 \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by\n  have h_main : \u2203 (a : \u2115 \u2192 \u211d), a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by\n    use fun n => (2 : \u211d) ^ n - 1\n    constructor\n    \u00b7 -- Prove a 1 = 1\n      norm_num\n    constructor\n    \u00b7 -- Prove a 2 = 3\n      norm_num\n    \u00b7 -- Prove the recurrence relation for n \u2265 3\n      intro n hn\n      have h\u2081 : (2 : \u211d) ^ n - 1 = 3 * ((2 : \u211d) ^ (n - 1) - 1) - 2 * ((2 : \u211d) ^ (n - 2) - 1) := by\n        have h\u2082 : n \u2265 3 := hn\n        have h\u2083 : (n : \u2115) \u2265 3 := by exact_mod_cast h\u2082\n        have h\u2084 : (n : \u2115) - 1 + 1 = n := by\n          have h\u2085 : (n : \u2115) \u2265 1 := by omega\n          omega\n        have h\u2085 : (n : \u2115) - 2 + 2 = n := by\n          have h\u2086 : (n : \u2115) \u2265 2 := by omega\n          omega\n        have h\u2086 : (2 : \u211d) ^ n = (2 : \u211d) ^ ((n - 1) + 1) := by\n          have h\u2087 : (n : \u2115) - 1 + 1 = n := by omega\n          rw [h\u2087]\n          <;> simp [pow_add]\n          <;> ring_nf\n        have h\u2087 : (2 : \u211d) ^ n = (2 : \u211d) ^ ((n - 2) + 2) := by\n          have h\u2088 : (n : \u2115) - 2 + 2 = n := by omega\n          rw [h\u2088]\n          <;> simp [pow_add]\n          <;> ring_nf\n        calc\n          (2 : \u211d) ^ n - 1 = (2 : \u211d) ^ ((n - 1) + 1) - 1 := by rw [h\u2086]\n          _ = (2 : \u211d) ^ (n - 1) * 2 - 1 := by\n            rw [pow_add]\n            <;> ring_nf\n            <;> field_simp\n            <;> ring_nf\n          _ = 3 * ((2 : \u211d) ^ (n - 1) - 1) - 2 * ((2 : \u211d) ^ (n - 2) - 1) := by\n            have h\u2088 : (2 : \u211d) ^ (n - 1) = (2 : \u211d) ^ ((n - 2) + 1) := by\n              have h\u2089 : (n : \u2115) - 1 = (n - 2 : \u2115) + 1 := by\n                have h\u2081\u2080 : (n : \u2115) \u2265 3 := by exact_mod_cast h\u2082\n                omega\n              rw [h\u2089]\n              <;> simp [pow_add]\n              <;> ring_nf\n            rw [h\u2088]\n            have h\u2089 : (2 : \u211d) ^ ((n - 2 : \u2115) + 1) = (2 : \u211d) ^ (n - 2) * 2 := by\n              rw [pow_add]\n              <;> ring_nf\n              <;> field_simp\n              <;> ring_nf\n            rw [h\u2089]\n            ring_nf\n            <;> field_simp\n            <;> ring_nf\n            <;> linarith\n          _ = 3 * ((2 : \u211d) ^ (n - 1) - 1) - 2 * ((2 : \u211d) ^ (n - 2) - 1) := by rfl\n      -- Use the established equality to prove the recurrence relation\n      simp_all [h\u2081]\n      <;> ring_nf at *\n      <;> linarith\n  \n  exact h_main\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 3) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) :\n  a 1 = 2^1 - 1 := by\n  have h_main : a 1 = (2 : \u211d)^1 - 1 := by\n    norm_num [h1] at h1 \u22a2\n    <;> linarith\n  \n  norm_num at h_main \u22a2\n  <;>\n  (try simp_all) <;>\n  (try norm_num) <;>\n  (try linarith)\n  <;>\n  (try ring_nf at *) <;>\n  (try simp_all) <;>\n  (try norm_num) <;>\n  (try linarith)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the sequence definition with initial conditions a\u2081=1, a\u2082=3, and the recurrence relation for n\u22653. The use of existential quantification and \u2115\u2192\u211d type is appropriate for defining the sequence over integers n\u22651.", "The Lean theorem correctly states that for a sequence satisfying the given properties, the formula a\u2081 = 2\u00b9 - 1 holds. The hypotheses properly reference all the sequence properties from the assumption, and the conclusion matches exactly what is stated in natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, the formula gives $a_2 = 2^2 - 1 = 3$. This matches the given value of $a_2=3$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=1$ [l1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=2$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2203 a : \u2115 \u2192 \u211d, \n    a 1 = 1 \u2227 \n    a 2 = 3 \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by sorry\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 3) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) :\n  a 1 = 2^1 - 1 := by sorry\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 3) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1) :\n  a 2 = 2^2 - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 : \n  \u2203 a : \u2115 \u2192 \u211d, \n    a 1 = 1 \u2227 \n    a 2 = 3 \u2227 \n    (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by\n  have h_main : \u2203 (a : \u2115 \u2192 \u211d), a 1 = 1 \u2227 a 2 = 3 \u2227 (\u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) := by\n    use fun n => (2 : \u211d) ^ n - 1\n    constructor\n    \u00b7 -- Prove a 1 = 1\n      norm_num\n    constructor\n    \u00b7 -- Prove a 2 = 3\n      norm_num\n    \u00b7 -- Prove the recurrence relation for n \u2265 3\n      intro n hn\n      cases n with\n      | zero => contradiction -- n cannot be zero since hn : n \u2265 3\n      | succ n =>\n        cases n with\n        | zero => contradiction -- n cannot be one since hn : n \u2265 3\n        | succ n =>\n          cases n with\n          | zero => contradiction -- n cannot be two since hn : n \u2265 3\n          | succ n =>\n            simp [pow_succ, mul_add, mul_comm, mul_left_comm, mul_assoc, Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_zero]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;>\n            (try\n              {\n                simp_all [pow_succ, mul_add, mul_comm, mul_left_comm, mul_assoc, Nat.cast_add, Nat.cast_one, Nat.cast_mul, Nat.cast_zero]\n                <;> ring_nf at *\n                <;> norm_num at *\n                <;> linarith\n              })\n            <;>\n            (try\n              {\n                field_simp at *\n                <;> ring_nf at *\n                <;> norm_num at *\n                <;> linarith\n              })\n            <;>\n            (try\n              {\n                norm_num at *\n                <;> linarith\n              })\n  exact h_main\n\ntheorem l1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 3) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) :\n  a 1 = 2^1 - 1 := by\n  have h_main : a 1 = (2 : \u2115)^1 - 1 := by\n    norm_num [h1] at h1 \u22a2\n    <;>\n    (try simp_all) <;>\n    (try norm_num) <;>\n    (try linarith)\n  -- Convert the natural number expression to real number if necessary\n  norm_num at h_main \u22a2\n  <;>\n  (try simp_all) <;>\n  (try norm_num) <;>\n  (try linarith)\n  <;>\n  (try ring_nf at *) <;>\n  (try norm_num at *) <;>\n  (try linarith)\n\ntheorem l2 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1) \n  (h2 : a 2 = 3) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1) :\n  a 2 = 2^2 - 1 := by\n  have h_main : a 2 = (2 : \u2115)^2 - 1 := by\n    norm_num [h2] at h2 \u22a2\n    <;>\n    (try simp_all) <;>\n    (try norm_num) <;>\n    (try linarith)\n  -- Convert the natural number expression to real number if necessary\n  norm_num at h_main \u22a2\n  <;>\n  (try simp_all) <;>\n  (try norm_num) <;>\n  (try linarith)\n  <;>\n  (try ring_nf at *) <;>\n  (try norm_num at *) <;>\n  (try linarith)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition correctly captures all three conditions: initial values and recurrence relation. The existential quantification appropriately establishes the sequence's existence.", "The base case theorem properly takes the sequence properties as hypotheses and proves the formula holds for n=1, matching the natural language statement.", "The conclusion theorem correctly incorporates all previous conditions including l1 as a hypothesis and proves the formula for n=2, properly reflecting the logical dependency described in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the formula holds for all integers $j$ where $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^j - 1$ is true.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=2$ [l2].\nDefinition:\n\u2022 For the inductive step, fix an integer $k \\geq 2$ and assume that $a_j = 2^j - 1$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : a 1 = 1 \u2227 a 2 = 3 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n(l1 : a 1 = 2^1 - 1)\n(l2 : a 2 = 2^2 - 1)\n\ntheorem def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is completely missing from the Lean theorem", "The base case verification for n=1 is not present in the Lean theorem", "The base case verification for n=2 is not present in the Lean theorem", "The inductive hypothesis matches perfectly - both state that for k\u22652, we assume a_j = 2^j - 1 for all j with 1\u2264j\u2264k", "The natural language states no explicit conclusions, but the Lean theorem concludes a(k+1) = 2^(k+1) - 1, which is the inductive step conclusion not mentioned in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions and recurrence relation is completely missing from the Lean theorem', 'The base case verification for n=1 is not present in the Lean theorem', 'The base case verification for n=2 is not present in the Lean theorem', 'The inductive hypothesis matches perfectly - both state that for k\u22652, we assume a_j = 2^j - 1 for all j with 1\u2264j\u2264k', 'The natural language states no explicit conclusions, but the Lean theorem concludes a(k+1) = 2^(k+1) - 1, which is the inductive step conclusion not mentioned in the natural language']"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "Using the given recurrence relation for $n=k+1$, we have $a_{k+1} = 3a_k - 2a_{k-1}$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=2$ [l2];\n\u2022 For the inductive step, fix an integer $k \\geq 2$ and assume that $a_j = 2^j - 1$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 3a_k - 2a_{k-1}$ [l3].", "dependencies": ["tc_1", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1)\n  (l2 : a 2 = 2^2 - 1)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * a k - 2 * a (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1)\n  (l2 : a 2 = 2^2 - 1)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n  intro k hk h_aj\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h : k \u2265 2 := hk\n    omega\n  \n  have h_main : a (k + 1) = 3 * a ((k + 1) - 1) - 2 * a ((k + 1) - 2) := by\n    have h4 : (k + 1 : \u2115) \u2265 3 := by exact_mod_cast h_k_plus_1_ge_3\n    have h5 : a (k + 1) = 3 * a ((k + 1) - 1) - 2 * a ((k + 1) - 2) := by\n      have h6 : a (k + 1) = 3 * a ((k + 1) - 1) - 2 * a ((k + 1) - 2) := by\n        have h7 := h3 (k + 1) h4\n        simpa using h7\n      exact h6\n    exact h5\n  \n  have h_sub_1 : (k + 1) - 1 = k := by\n    have h\u2081 : (k + 1) - 1 = k := by\n      omega\n    exact h\u2081\n  \n  have h_sub_2 : (k + 1) - 2 = k - 1 := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : (k + 1) - 2 = k - 1 := by\n      have h\u2083 : k \u2265 1 := by omega\n      have h\u2084 : (k + 1) - 2 = k - 1 := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc]\n            <;> ring_nf at *\n            <;> omega\n      exact h\u2084\n    exact h\u2082\n  \n  have h_final : a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n    have h\u2081 : a (k + 1) = 3 * a ((k + 1) - 1) - 2 * a ((k + 1) - 2) := h_main\n    have h\u2082 : (k + 1) - 1 = k := h_sub_1\n    have h\u2083 : (k + 1) - 2 = k - 1 := h_sub_2\n    rw [h\u2081, h\u2082, h\u2083]\n    <;>\n    (try ring_nf) <;>\n    (try norm_num) <;>\n    (try simp_all [Nat.succ_eq_add_one, Nat.add_assoc]) <;>\n    (try linarith)\n    <;>\n    (try omega)\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try norm_num at *)\n    <;>\n    (try simp_all [Nat.succ_eq_add_one, Nat.add_assoc])\n    <;>\n    (try linarith)\n    <;>\n    (try omega)\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures all the assumptions and conditions from the natural language, but there's a structural issue with the conclusion. The natural language presents 'a_{k+1} = 3a_k - 2a_{k-1}' as a direct consequence of the recurrence relation, but the Lean formalization treats it as something that needs to be proven under the inductive hypothesis. The conclusion should simply follow from hypothesis h3 (the recurrence relation) when k \u2265 2, regardless of the inductive assumption about the formula a_j = 2^j - 1. This creates a logical dependency that doesn't exist in the natural language reasoning."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures all the assumptions and conditions from the natural language, but there's a structural issue with the conclusion. The natural language presents 'a_{k+1} = 3a_k - 2a_{k-1}' as a direct consequence of the recurrence relation, but the Lean formalization treats it as something that needs to be proven under the inductive hypothesis. The conclusion should simply follow from hypothesis h3 (the recurrence relation) when k \u2265 2, regardless of the inductive assumption about the formula a_j = 2^j - 1. This creates a logical dependency that doesn't exist in the natural language reasoning.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By our assumption, we substitute the formulas for $a_k$ and $a_{k-1}$: $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=2$ [l2];\n\u2022 For the inductive step, fix an integer $k \\geq 2$ and assume that $a_j = 2^j - 1$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1];\n\u2022 $a_{k+1} = 3a_k - 2a_{k-1}$ [l3].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$ [l4].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1)\n  (l2 : a 2 = 2^2 - 1)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * a k - 2 * a (k - 1)) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * (2^k - 1) - 2 * (2^(k-1) - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1)\n  (l2 : a 2 = 2^2 - 1)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * a k - 2 * a (k - 1)) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * (2^k - 1) - 2 * (2^(k-1) - 1) := by\n  intro k hk h\n  have h_l3 : a (k + 1) = 3 * a k - 2 * a (k - 1) := by\n    have h\u2084 : a (k + 1) = 3 * a k - 2 * a (k - 1) := l3 k hk h\n    exact h\u2084\n  \n  have h_ak : a k = (2 : \u211d)^k - 1 := by\n    have h\u2085 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try norm_num) <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2086 : a k = (2 : \u211d)^k - 1 := by\n      have h\u2087 : a k = (2 : \u211d)^k - 1 := by\n        have h\u2088 := h k h\u2085\n        norm_num at h\u2088 \u22a2\n        <;>\n        (try simp_all [pow_succ]) <;>\n        (try ring_nf at * <;> linarith) <;>\n        (try norm_cast at * <;> simp_all [pow_succ]) <;>\n        (try linarith)\n        <;>\n        (try ring_nf at * <;> linarith)\n        <;>\n        (try norm_num at * <;> linarith)\n        <;>\n        (try simp_all [pow_succ])\n        <;>\n        (try ring_nf at * <;> linarith)\n        <;>\n        (try norm_cast at * <;> simp_all [pow_succ])\n        <;>\n        (try linarith)\n        <;>\n        (try ring_nf at * <;> linarith)\n        <;>\n        (try norm_num at * <;> linarith)\n      exact h\u2087\n    exact h\u2086\n  \n  have h_ak1 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := by\n    have h\u2085 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2085\u2081 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2085\u2082 : k \u2265 2 := hk\n        have h\u2085\u2083 : (k : \u2115) - 1 \u2265 1 := by\n          omega\n        omega\n      have h\u2085\u2082 : (k - 1 : \u2115) \u2264 k := by\n        have h\u2085\u2083 : (k : \u2115) - 1 \u2264 k := by\n          omega\n        omega\n      exact \u27e8h\u2085\u2081, h\u2085\u2082\u27e9\n    have h\u2086 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := by\n      have h\u2087 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := by\n        have h\u2088 := h (k - 1) h\u2085\n        norm_num at h\u2088 \u22a2\n        <;>\n        (try simp_all [pow_succ]) <;>\n        (try ring_nf at * <;> linarith) <;>\n        (try norm_cast at * <;> simp_all [pow_succ]) <;>\n        (try linarith)\n        <;>\n        (try ring_nf at * <;> linarith)\n        <;>\n        (try norm_num at * <;> linarith)\n        <;>\n        (try simp_all [pow_succ])\n        <;>\n        (try ring_nf at * <;> linarith)\n        <;>\n        (try norm_cast at * <;> simp_all [pow_succ])\n        <;>\n        (try linarith)\n        <;>\n        (try ring_nf at * <;> linarith)\n        <;>\n        (try norm_num at * <;> linarith)\n      exact h\u2087\n    exact h\u2086\n  \n  have h_main : a (k + 1) = 3 * ((2 : \u211d)^k - 1) - 2 * ((2 : \u211d)^(k - 1) - 1) := by\n    have h\u2085 : a (k + 1) = 3 * a k - 2 * a (k - 1) := h_l3\n    have h\u2086 : a k = (2 : \u211d)^k - 1 := h_ak\n    have h\u2087 : a (k - 1) = (2 : \u211d)^(k - 1) - 1 := h_ak1\n    rw [h\u2085, h\u2086, h\u2087]\n    <;> ring_nf\n    <;> simp_all [pow_succ]\n    <;> norm_num\n    <;> linarith\n  \n  have h_final : a (k + 1) = 3 * (2^k - 1) - 2 * (2^(k-1) - 1) := by\n    have h\u2085 : a (k + 1) = 3 * ((2 : \u211d)^k - 1) - 2 * ((2 : \u211d)^(k - 1) - 1) := h_main\n    have h\u2086 : (3 : \u211d) * ((2 : \u211d)^k - 1) - 2 * ((2 : \u211d)^(k - 1) - 1) = 3 * (2^k - 1) - 2 * (2^(k-1) - 1) := by\n      norm_num [pow_succ] at *\n      <;>\n      (try ring_nf at *) <;>\n      (try norm_cast at *) <;>\n      (try simp_all [pow_succ]) <;>\n      (try ring_nf at *) <;>\n      (try norm_num at *) <;>\n      (try linarith)\n      <;>\n      (try simp_all [pow_succ])\n      <;>\n      (try ring_nf at *)\n      <;>\n      (try norm_num at *)\n      <;>\n      (try linarith)\n    rw [h\u2085]\n    <;>\n    (try simp_all [pow_succ])\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try norm_num at *)\n    <;>\n    (try linarith)\n    <;>\n    (try simp_all [pow_succ])\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try norm_num at *)\n    <;>\n    (try linarith)\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The sequence definition, base cases, inductive hypothesis, recurrence relation application, and final conclusion all correspond accurately. The Lean version includes some additional structural elements (like def_1 and conditional statements in l3) that provide more explicit logical context for the proof, but these are consistent with and enhance the natural language description rather than contradicting it. The mathematical meaning is preserved completely."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Now we expand and simplify the expression: $a_{k+1} = 3 \\cdot 2^k - 3 - 2 \\cdot 2^{k-1} + 2 = 3 \\cdot 2^k - 2^k - 1 = 2 \\cdot 2^k - 1 = 2^{k+1} - 1$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined over integers $n \\geq 1$ by $a_1=1$, $a_2=3$, and the recurrence relation $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^n - 1$ holds for $n=2$ [l2];\n\u2022 For the inductive step, fix an integer $k \\geq 2$ and assume that $a_j = 2^j - 1$ for all integers $j$ such that $1 \\leq j \\leq k$ [def_1];\n\u2022 $a_{k+1} = 3a_k - 2a_{k-1}$ [l3];\n\u2022 $a_{k+1} = 3(2^k-1) - 2(2^{k-1}-1)$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^{k+1} - 1$ [l5].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1)\n  (l2 : a 2 = 2^2 - 1)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * a k - 2 * a (k - 1))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * (2^k - 1) - 2 * (2^(k-1) - 1)) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a : \u2115 \u2192 \u211d)\n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2))\n  (l1 : a 1 = 2^1 - 1)\n  (l2 : a 2 = 2^2 - 1)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * a k - 2 * a (k - 1))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 3 * (2^k - 1) - 2 * (2^(k-1) - 1)) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1 := by\n  have h_main : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^j - 1) \u2192 a (k + 1) = 2^(k + 1) - 1 := by\n    intro k hk h\n    have h\u2081 : a (k + 1) = 2^(k + 1) - 1 := def_1 k hk h\n    exact h\u2081\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition (h1, h2, h3) correctly captures the initial conditions and recurrence relation from tc_1.", "The base cases l1 and l2 perfectly match the natural language statements about the formula holding for n=1 and n=2.", "The hypothesis def_1 is problematic - it directly states the conclusion as a given fact rather than representing the inductive hypothesis structure. In proper inductive reasoning, this should be an assumption for the inductive step, not a direct statement of what we're trying to prove.", "The hypothesis l3 correctly captures the application of the recurrence relation in the inductive step.", "The hypothesis l4 correctly captures the substitution step using the inductive hypothesis.", "The theorem conclusion perfectly matches the natural language conclusion l5.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition (h1, h2, h3) correctly captures the initial conditions and recurrence relation from tc_1.', 'The base cases l1 and l2 perfectly match the natural language statements about the formula holding for n=1 and n=2.', \"The hypothesis def_1 is problematic - it directly states the conclusion as a given fact rather than representing the inductive hypothesis structure. In proper inductive reasoning, this should be an assumption for the inductive step, not a direct statement of what we're trying to prove.\", 'The hypothesis l3 correctly captures the application of the recurrence relation in the inductive step.', 'The hypothesis l4 correctly captures the substitution step using the inductive hypothesis.', 'The theorem conclusion perfectly matches the natural language conclusion l5.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "This result matches the formula for $n=k+1$. Therefore, by the principle of **strong mathematical induction**, the formula $a_n = 2^n - 1$ is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The sequence $(a_n)$ is defined by $a_1=1$, $a_2=3$, and $a_n = 3a_{n-1} - 2a_{n-2}$ for $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^n - 1$ holds for the base cases $n=1$ [l1] and $n=2$ [l2];\n\u2022 For any integer $k \\geq 2$, assuming $a_j = 2^j - 1$ for all $1 \\leq j \\leq k$ (the inductive hypothesis [def_1]) allows us to prove that $a_{k+1} = 2^{k+1} - 1$ [l5].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^n - 1$ is true for all integers $n \\geq 1$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^n - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u211d) \n  (h1 : a 1 = 1)\n  (h2 : a 2 = 3)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 3 * a (n - 1) - 2 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^n - 1 := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n    intro n hn\n    have h : \u2200 n : \u2115, n \u2265 1 \u2192 a n = (2 : \u211d)^n - 1 := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h1] at hn \u22a2\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h2] at hn \u22a2\n      | k + 3 =>\n        -- Inductive step for n = k + 3 \u2265 3\n        have h4 := h3 (k + 3) (by linarith)\n        have h5 : a (k + 3) = 3 * a (k + 2) - 2 * a (k + 1) := by\n          simpa [Nat.add_assoc] using h4\n        have h6 : a (k + 2) = (2 : \u211d)^(k + 2) - 1 := by\n          have h7 : (k + 2 : \u2115) \u2265 1 := by linarith\n          have h8 : a (k + 2) = (2 : \u211d)^(k + 2) - 1 := by\n            apply ih (k + 2)\n            <;> simp_all [Nat.lt_succ_iff]\n            <;> omega\n          exact h8\n        have h7 : a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n          have h8 : (k + 1 : \u2115) \u2265 1 := by linarith\n          have h9 : a (k + 1) = (2 : \u211d)^(k + 1) - 1 := by\n            apply ih (k + 1)\n            <;> simp_all [Nat.lt_succ_iff]\n            <;> omega\n          exact h9\n        rw [h5, h6, h7]\n        -- Simplify the expression to show it equals 2^(k+3) - 1\n        have h8 : (3 : \u211d) * ((2 : \u211d)^(k + 2) - 1) - 2 * ((2 : \u211d)^(k + 1) - 1) = (2 : \u211d)^(k + 3) - 1 := by\n          have h9 : (2 : \u211d)^(k + 2) = 2 * (2 : \u211d)^(k + 1) := by\n            ring_nf\n            <;> simp [pow_succ, mul_assoc]\n            <;> ring_nf\n          calc\n            (3 : \u211d) * ((2 : \u211d)^(k + 2) - 1) - 2 * ((2 : \u211d)^(k + 1) - 1) = (3 : \u211d) * ((2 : \u211d)^(k + 2)) - 3 - (2 * (2 : \u211d)^(k + 1) - 2) := by\n              ring\n            _ = (3 : \u211d) * ((2 : \u211d)^(k + 2)) - 3 - 2 * (2 : \u211d)^(k + 1) + 2 := by ring\n            _ = (3 : \u211d) * (2 * (2 : \u211d)^(k + 1)) - 3 - 2 * (2 : \u211d)^(k + 1) + 2 := by rw [h9]\n            _ = (6 : \u211d) * (2 : \u211d)^(k + 1) - 3 - 2 * (2 : \u211d)^(k + 1) + 2 := by ring\n            _ = (4 : \u211d) * (2 : \u211d)^(k + 1) - 1 := by ring\n            _ = (2 : \u211d)^(k + 3) - 1 := by\n              have h10 : (2 : \u211d)^(k + 3) = (2 : \u211d)^2 * (2 : \u211d)^(k + 1) := by\n                calc\n                  (2 : \u211d)^(k + 3) = (2 : \u211d)^((k + 1) + 2) := by ring_nf\n                  _ = (2 : \u211d)^(k + 1) * (2 : \u211d)^2 := by\n                    rw [pow_add]\n                    <;> ring_nf\n                  _ = (2 : \u211d)^2 * (2 : \u211d)^(k + 1) := by ring\n              have h11 : (4 : \u211d) * (2 : \u211d)^(k + 1) = (2 : \u211d)^2 * (2 : \u211d)^(k + 1) := by norm_num\n              have h12 : (4 : \u211d) * (2 : \u211d)^(k + 1) = (2 : \u211d)^(k + 3) := by\n                linarith\n              linarith\n        linarith\n    exact h n hn\n  intro n hn\n  have h\u2081 : a n = (2 : \u211d)^n - 1 := h_main n hn\n  have h\u2082 : (2 : \u211d)^n - 1 = (2 : \u211d)^n - 1 := rfl\n  norm_num at h\u2081 \u22a2\n  <;>\n  (try simp_all [pow_succ]) <;>\n  (try ring_nf at * <;> norm_num at * <;> linarith) <;>\n  (try simp_all [pow_succ]) <;>\n  (try norm_cast at * <;> simp_all [pow_succ]) <;>\n  (try linarith)\n  <;>\n  (try\n    {\n      simp_all [pow_succ]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean hypotheses h1, h2, and h3.", "The base cases are implicitly present - they can be derived from the initial conditions and the target formula, though not stated as explicit separate hypotheses.", "The inductive step structure described in the natural language is completely missing from the Lean formalization. The natural language explicitly mentions the inductive hypothesis and the proof strategy, but the Lean code only provides the recurrence relation without the inductive framework.", "The final conclusion is perfectly matched - both state that the formula a_n = 2^n - 1 holds for all n \u2265 1."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean hypotheses h1, h2, and h3.', 'The base cases are implicitly present - they can be derived from the initial conditions and the target formula, though not stated as explicit separate hypotheses.', 'The inductive step structure described in the natural language is completely missing from the Lean formalization. The natural language explicitly mentions the inductive hypothesis and the proof strategy, but the Lean code only provides the recurrence relation without the inductive framework.', 'The final conclusion is perfectly matched - both state that the formula a_n = 2^n - 1 holds for all n \u2265 1.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    