
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=5$ and the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, $a_n = 2^{n-1}+3^{n-1}$.

Proof: We will prove this by strong mathematical induction on $n$. First, for the base cases, we need to verify the formula holds for $n=1$ and $n=2$. For $n=1$, we are given $a_1=2$. The formula gives $a_1=2^{1-1}+3^{1-1}=2^0+3^0=1+1=2$. This holds. For $n=2$, we are given $a_2=5$. The formula gives $a_2=2^{2-1}+3^{2-1}=2^1+3^1=2+3=5$. This also holds. Now, for the inductive step, we assume the statement is true for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{j-1}+3^{j-1}$ for $1 \leq j \leq k$. We want to show the statement is true for $k+1$, i.e., $a_{k+1}=2^{k}+3^{k}$. From the recurrence relation, we have $a_{k+1}=5a_k-6a_{k-1}$. By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$. So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$. We expand this: $5 \cdot 2^{k-1} + 5 \cdot 3^{k-1} - 6 \cdot 2^{k-2} - 6 \cdot 3^{k-2}$. We can rewrite the coefficients. $5 \cdot 2^{k-1} = (2+3) \cdot 2^{k-1} = 2 \cdot 2^{k-1} + 3 \cdot 2^{k-1} = 2^k + 3 \cdot 2^{k-1}$. No, that's not right. $5 \cdot 2^{k-1} = 5 \cdot 2^{k-2} \cdot 2 = 10 \cdot 2^{k-2}$. We have $a_{k+1}=10 \cdot 2^{k-2} + 15 \cdot 3^{k-2} - 6 \cdot 2^{k-2} - 6 \cdot 3^{k-2}$. Combining like terms gives $(10-6) \cdot 2^{k-2} + (15-6) \cdot 3^{k-2} = 4 \cdot 2^{k-2} + 9 \cdot 3^{k-2}$. We can simplify this further: $4 \cdot 2^{k-2} = 2^2 \cdot 2^{k-2} = 2^k$. And $9 \cdot 3^{k-2} = 3^2 \cdot 3^{k-2} = 3^k$. Thus, $a_{k+1}=2^k+3^k$. This matches the formula for $n=k+1$. By the principle of strong mathematical induction, the statement is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=5$ and the recurrence relation $a_{n} = 5a_{n-1} - 6a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n - 1) + 3^(n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean type signature (a : \u2115 \u2192 \u2124) correctly captures that a_n is a sequence of integers", "Both state a_1 = 2 identically", "Both state a_2 = 5 identically", "The recurrence relation is mathematically identical, but the natural language mentions 'integers n \u2265 3' while Lean uses 'n : \u2115, n \u2265 3'. Since the context is about sequence indices, natural numbers are appropriate, making this a minor notational difference", "The natural language conclusion states the sequence is 'completely defined' by the given conditions, which is a general statement about existence and uniqueness. However, the Lean proposition provides a specific explicit formula a_n = 2^(n-1) + 3^(n-1), which is much stronger and more specific than what the natural language concludes"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean type signature (a : \u2115 \u2192 \u2124) correctly captures that a_n is a sequence of integers', 'Both state a_1 = 2 identically', 'Both state a_2 = 5 identically', \"The recurrence relation is mathematically identical, but the natural language mentions 'integers n \u2265 3' while Lean uses 'n : \u2115, n \u2265 3'. Since the context is about sequence indices, natural numbers are appropriate, making this a minor notational difference\", \"The natural language conclusion states the sequence is 'completely defined' by the given conditions, which is a general statement about existence and uniqueness. However, the Lean proposition provides a specific explicit formula a_n = 2^(n-1) + 3^(n-1), which is much stronger and more specific than what the natural language concludes\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "First, for the base cases, we need to verify the formula holds for $n=1$ and $n=2$. For $n=1$, we are given $a_1=2$. The formula gives $a_1=2^{1-1}+3^{1-1}=2^0+3^0=1+1=2$. This holds.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 1 = 2^(1 - 1) + 3^(1 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 1 = 2^(1 - 1) + 3^(1 - 1) := by\n  have h4 : (2 : \u2124) ^ (1 - 1 : \u2115) + (3 : \u2124) ^ (1 - 1 : \u2115) = 2 := by\n    norm_num\n    <;>\n    simp [pow_zero]\n    <;>\n    norm_num\n    <;>\n    rfl\n  \n  have h5 : a 1 = (2 : \u2124) ^ (1 - 1 : \u2115) + (3 : \u2124) ^ (1 - 1 : \u2115) := by\n    have h6 : a 1 = 2 := h1\n    have h7 : (2 : \u2124) ^ (1 - 1 : \u2115) + (3 : \u2124) ^ (1 - 1 : \u2115) = 2 := h4\n    linarith\n  \n  simpa using h5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition, type signature (\u2115 \u2192 \u2124), and initial conditions (a\u2081=2, a\u2082=5) are correctly captured in the Lean formalization.", "The recurrence relation a_n = 5a_{n-1} - 6a_{n-2} for n \u2265 3 is precisely translated with correct coefficients and domain restriction.", "The conclusion that the formula a_n = 2^{n-1} + 3^{n-1} holds for n=1 is correctly expressed by direct substitution, and the mathematical verification confirms a\u2081 = 2^0 + 3^0 = 2, which matches the given initial condition."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we are given $a_2=5$. The formula gives $a_2=2^{2-1}+3^{2-1}=2^1+3^1=2+3=5$. This also holds.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 2 = 2^(2 - 1) + 3^(2 - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  a 2 = 2^(2 - 1) + 3^(2 - 1) := by\n  have h_main : a 2 = 2^(2 - 1) + 3^(2 - 1) := by\n    norm_num [h2]\n    <;>\n    (try decide)\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try norm_num at *)\n    <;>\n    (try linarith)\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization is missing a crucial premise from the natural language: that the formula a_n = 2^(n-1) + 3^(n-1) holds for n=1. This premise (labeled [l1] in the natural language) is essential for the logical structure of the argument, as it provides the foundation for concluding that the formula also holds for n=2. Without this premise, the Lean theorem cannot properly capture the intended mathematical reasoning."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization is missing a crucial premise from the natural language: that the formula a_n = 2^(n-1) + 3^(n-1) holds for n=1. This premise (labeled [l1] in the natural language) is essential for the logical structure of the argument, as it provides the foundation for concluding that the formula also holds for n=2. Without this premise, the Lean theorem cannot properly capture the intended mathematical reasoning.']"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now, for the inductive step, we assume the statement is true for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{j-1}+3^{j-1}$ for $1 \\leq j \\leq k$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2].\nDefinition:\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition matches well, but there's a type inconsistency: natural language specifies 'integers n \u2265 3' while Lean uses '\u2115' (natural numbers). The mathematical content is equivalent since we're dealing with n \u2265 3.", "The natural language explicitly states that the formula holds for n=1 as a separate condition, but this is completely missing as a hypothesis in the Lean formalization.", "The natural language explicitly states that the formula holds for n=2 as a separate condition, but this is completely missing as a hypothesis in the Lean formalization.", "The inductive hypothesis structure is captured, but there's a type difference: natural language uses 'integer k \u2265 2' and 'integers j' while Lean uses natural numbers. Also, the natural language presents this as an assumption for 'some' k, while Lean presents it as a universal statement over all k \u2265 2."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The sequence definition matches well, but there's a type inconsistency: natural language specifies 'integers n \u2265 3' while Lean uses '\u2115' (natural numbers). The mathematical content is equivalent since we're dealing with n \u2265 3.\", 'The natural language explicitly states that the formula holds for n=1 as a separate condition, but this is completely missing as a hypothesis in the Lean formalization.', 'The natural language explicitly states that the formula holds for n=2 as a separate condition, but this is completely missing as a hypothesis in the Lean formalization.', \"The inductive hypothesis structure is captured, but there's a type difference: natural language uses 'integer k \u2265 2' and 'integers j' while Lean uses natural numbers. Also, the natural language presents this as an assumption for 'some' k, while Lean presents it as a universal statement over all k \u2265 2.\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relation, we have $a_{k+1}=5a_k-6a_{k-1}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2];\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 5a_k - 6a_{k-1}$ [l3].", "dependencies": ["tc_1", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) :\n  a (k + 1) = 2^k + 3^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) :\n  a (k + 1) = 2^k + 3^k := by\n  have hk1 : k + 1 \u2265 3 := by\n    omega\n  \n  have h_rec : a (k + 1) = 5 * a k - 6 * a (k - 1) := by\n    have h5 : a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := by\n      have h6 : (k + 1 : \u2115) \u2265 3 := by omega\n      have h7 : a (k + 1) = 5 * a ((k + 1) - 1) - 6 * a ((k + 1) - 2) := by\n        apply h3\n        <;> omega\n      exact h7\n    have h8 : (k + 1 : \u2115) - 1 = k := by\n      omega\n    have h9 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h10 : k \u2265 2 := hk\n      omega\n    rw [h5]\n    rw [h8]\n    rw [h9]\n    <;> simp [Nat.add_assoc]\n    <;> ring_nf\n    <;> norm_num\n    <;> omega\n  \n  have h_ak : a k = (2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1) := by\n    have h5 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h6 : a k = 2^(k - 1) + 3^(k - 1) := h4 k h5\n    have h7 : (a k : \u2124) = (2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1) := by\n      norm_cast at h6 \u22a2\n      <;>\n      (try simp_all [pow_succ]) <;>\n      (try ring_nf at * <;> simp_all) <;>\n      (try norm_num at * <;> linarith)\n      <;>\n      (try omega)\n      <;>\n      (try ring_nf at * <;> simp_all)\n      <;>\n      (try norm_num at * <;> linarith)\n      <;>\n      (try omega)\n    exact_mod_cast h7\n  \n  have h_ak1 : a (k - 1) = (2 : \u2124)^(k - 2) + (3 : \u2124)^(k - 2) := by\n    have h5 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h6 : k \u2265 2 := hk\n      have h7 : 1 \u2264 (k - 1 : \u2115) := by\n        have h8 : k \u2265 2 := hk\n        omega\n      have h9 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h7, h9\u27e9\n    have h10 : a (k - 1) = 2 ^ ((k - 1 : \u2115) - 1) + 3 ^ ((k - 1 : \u2115) - 1) := h4 (k - 1) h5\n    have h11 : (a (k - 1) : \u2124) = (2 : \u2124) ^ ((k - 1 : \u2115) - 1) + (3 : \u2124) ^ ((k - 1 : \u2115) - 1) := by\n      norm_cast at h10 \u22a2 <;>\n      (try simp_all [pow_succ]) <;>\n      (try ring_nf at * <;> simp_all) <;>\n      (try norm_num at * <;> linarith)\n      <;>\n      (try omega)\n      <;>\n      (try ring_nf at * <;> simp_all)\n      <;>\n      (try norm_num at * <;> linarith)\n      <;>\n      (try omega)\n    have h12 : ((k - 1 : \u2115) - 1 : \u2115) = k - 2 := by\n      have h13 : k \u2265 2 := hk\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    rw [h11]\n    <;> simp [h12]\n    <;> norm_cast\n    <;> simp_all [pow_succ]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_main : (5 : \u2124) * ((2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2) + (3 : \u2124)^(k - 2)) = (2 : \u2124)^k + (3 : \u2124)^k := by\n    have h\u2081 : (5 : \u2124) * (2 : \u2124) ^ (k - 1) - 6 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : (2 : \u2124) ^ (k - 1) = 2 * (2 : \u2124) ^ (k - 2) := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [pow_succ, mul_assoc]\n            <;> ring_nf\n            <;> norm_num\n            <;> simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> linarith\n      have h\u2084 : (5 : \u2124) * (2 : \u2124) ^ (k - 1) - 6 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ k := by\n        calc\n          (5 : \u2124) * (2 : \u2124) ^ (k - 1) - 6 * (2 : \u2124) ^ (k - 2) = (5 : \u2124) * (2 * (2 : \u2124) ^ (k - 2)) - 6 * (2 : \u2124) ^ (k - 2) := by rw [h\u2083]\n          _ = (10 : \u2124) * (2 : \u2124) ^ (k - 2) - 6 * (2 : \u2124) ^ (k - 2) := by ring\n          _ = (4 : \u2124) * (2 : \u2124) ^ (k - 2) := by ring\n          _ = (2 : \u2124) ^ 2 * (2 : \u2124) ^ (k - 2) := by norm_num\n          _ = (2 : \u2124) ^ (2 + (k - 2)) := by\n            rw [\u2190 pow_add]\n            <;> ring_nf\n          _ = (2 : \u2124) ^ k := by\n            have h\u2085 : 2 + (k - 2) = k := by\n              have h\u2086 : k \u2265 2 := hk\n              omega\n            rw [h\u2085]\n      exact h\u2084\n    have h\u2082 : (5 : \u2124) * (3 : \u2124) ^ (k - 1) - 6 * (3 : \u2124) ^ (k - 2) = (3 : \u2124) ^ k := by\n      have h\u2083 : k \u2265 2 := hk\n      have h\u2084 : (3 : \u2124) ^ (k - 1) = 3 * (3 : \u2124) ^ (k - 2) := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [pow_succ, mul_assoc]\n            <;> ring_nf\n            <;> norm_num\n            <;> simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> linarith\n      have h\u2085 : (5 : \u2124) * (3 : \u2124) ^ (k - 1) - 6 * (3 : \u2124) ^ (k - 2) = (3 : \u2124) ^ k := by\n        calc\n          (5 : \u2124) * (3 : \u2124) ^ (k - 1) - 6 * (3 : \u2124) ^ (k - 2) = (5 : \u2124) * (3 * (3 : \u2124) ^ (k - 2)) - 6 * (3 : \u2124) ^ (k - 2) := by rw [h\u2084]\n          _ = (15 : \u2124) * (3 : \u2124) ^ (k - 2) - 6 * (3 : \u2124) ^ (k - 2) := by ring\n          _ = (9 : \u2124) * (3 : \u2124) ^ (k - 2) := by ring\n          _ = (3 : \u2124) ^ 2 * (3 : \u2124) ^ (k - 2) := by norm_num\n          _ = (3 : \u2124) ^ (2 + (k - 2)) := by\n            rw [\u2190 pow_add]\n            <;> ring_nf\n          _ = (3 : \u2124) ^ k := by\n            have h\u2086 : 2 + (k - 2) = k := by\n              have h\u2087 : k \u2265 2 := hk\n              omega\n            rw [h\u2086]\n      exact h\u2085\n    calc\n      (5 : \u2124) * ((2 : \u2124) ^ (k - 1) + (3 : \u2124) ^ (k - 1)) - 6 * ((2 : \u2124) ^ (k - 2) + (3 : \u2124) ^ (k - 2))\n        = (5 : \u2124) * (2 : \u2124) ^ (k - 1) + (5 : \u2124) * (3 : \u2124) ^ (k - 1) - (6 * (2 : \u2124) ^ (k - 2) + 6 * (3 : \u2124) ^ (k - 2)) := by\n          ring\n        _ = (5 : \u2124) * (2 : \u2124) ^ (k - 1) - 6 * (2 : \u2124) ^ (k - 2) + ((5 : \u2124) * (3 : \u2124) ^ (k - 1) - 6 * (3 : \u2124) ^ (k - 2)) := by\n          ring\n        _ = (2 : \u2124) ^ k + (3 : \u2124) ^ k := by\n          rw [h\u2081, h\u2082]\n          <;> ring\n          <;> norm_num\n  \n  have h_final : a (k + 1) = (2 : \u2124)^k + (3 : \u2124)^k := by\n    rw [h_rec]\n    rw [h_ak]\n    rw [h_ak1]\n    have h\u2081 : (5 : \u2124) * ((2 : \u2124) ^ (k - 1) + (3 : \u2124) ^ (k - 1)) - 6 * ((2 : \u2124) ^ (k - 2) + (3 : \u2124) ^ (k - 2)) = (2 : \u2124) ^ k + (3 : \u2124) ^ k := by\n      exact h_main\n    linarith\n  \n  norm_cast at h_final \u22a2\n  <;> simp_all [pow_succ]\n  <;> ring_nf at *\n  <;> norm_num at *\n  <;> linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition components (domain, initial conditions, and recurrence relation) are correctly captured in the Lean formalization.", "The base cases for n=1 and n=2 are implicitly covered by the inductive hypothesis when j=1 and j=2.", "The inductive hypothesis is correctly formalized with the proper quantification over j and the constraint k\u22652.", "The conclusion has a major inconsistency. The natural language states the conclusion as 'a_{k+1} = 5a_k - 6a_{k-1}' (which is just the recurrence relation), but the Lean formalization concludes 'a (k + 1) = 2^k + 3^k' (which is the inductive step for the closed form). These represent completely different logical statements."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition components (domain, initial conditions, and recurrence relation) are correctly captured in the Lean formalization.', 'The base cases for n=1 and n=2 are implicitly covered by the inductive hypothesis when j=1 and j=2.', 'The inductive hypothesis is correctly formalized with the proper quantification over j and the constraint k\u22652.', \"The conclusion has a major inconsistency. The natural language states the conclusion as 'a_{k+1} = 5a_k - 6a_{k-1}' (which is just the recurrence relation), but the Lean formalization concludes 'a (k + 1) = 2^k + 3^k' (which is the inductive step for the closed form). These represent completely different logical statements.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+3^{k-1}$ and $a_{k-1}=2^{k-2}+3^{k-2}$. So, $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2];\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1];\n\u2022 $a_{k+1} = 5a_k - 6a_{k-1}$ [l3].\nTherefore, we conclude:\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l4].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) :\n  a (k + 1) = 2^k + 3^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1)) :\n  a (k + 1) = 2^k + 3^k := by\n  have h5 : a (k + 1) = 5 * a k - 6 * a (k - 1) := by\n    have h5\u2081 : (k + 1 : \u2115) \u2265 3 := by\n      have h5\u2082 : k \u2265 2 := hk\n      omega\n    have h5\u2082 : a (k + 1) = 5 * a (k + 1 - 1) - 6 * a (k + 1 - 2) := by\n      apply h3\n      <;> omega\n    have h5\u2083 : (k + 1 : \u2115) - 1 = k := by\n      omega\n    have h5\u2084 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h5\u2085 : k \u2265 2 := hk\n      have h5\u2086 : (k : \u2115) \u2265 2 := by exact_mod_cast h5\u2085\n      omega\n    rw [h5\u2082, h5\u2083, h5\u2084]\n    <;> simp [Nat.add_assoc]\n    <;> ring_nf at *\n    <;> omega\n  \n  have h6 : a k = (2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1) := by\n    have h6\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h6\u2082 : a k = (2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1) := by\n      have h6\u2083 : a k = 2^(k - 1) + 3^(k - 1) := h4 k h6\u2081\n      norm_cast at h6\u2083 \u22a2\n      <;> simp_all [pow_succ]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    exact h6\u2082\n  \n  have h7 : a (k - 1) = (2 : \u2124)^(k - 2) + (3 : \u2124)^(k - 2) := by\n    have h7\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h7\u2082 : k \u2265 2 := hk\n      have h7\u2083 : 1 \u2264 (k - 1 : \u2115) := by\n        have h7\u2084 : k \u2265 2 := hk\n        omega\n      have h7\u2084 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h7\u2083, h7\u2084\u27e9\n    have h7\u2082 : a (k - 1) = (2 : \u2124)^((k - 1 : \u2115) - 1) + (3 : \u2124)^((k - 1 : \u2115) - 1) := by\n      have h7\u2083 : a (k - 1) = 2^((k - 1 : \u2115) - 1) + 3^((k - 1 : \u2115) - 1) := h4 (k - 1) h7\u2081\n      norm_cast at h7\u2083 \u22a2\n      <;> simp_all [pow_succ]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    have h7\u2083 : (k - 1 : \u2115) - 1 = k - 2 := by\n      have h7\u2084 : k \u2265 2 := hk\n      have h7\u2085 : (k : \u2115) \u2265 2 := by exact_mod_cast h7\u2084\n      cases k with\n      | zero => omega\n      | succ k' =>\n        cases k' with\n        | zero => omega\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    rw [h7\u2082, h7\u2083]\n    <;> norm_num\n    <;> ring_nf at *\n    <;> simp_all\n  \n  have h8 : a (k + 1) = 5 * ((2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2) + (3 : \u2124)^(k - 2)) := by\n    rw [h5, h6, h7]\n    <;> ring_nf\n    <;> norm_num\n    <;> simp [pow_succ]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h9 : (5 : \u2124) * ((2 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2)) = (2 : \u2124)^k := by\n    have h9\u2081 : k \u2265 2 := hk\n    have h9\u2082 : (k : \u2115) \u2265 2 := by exact_mod_cast h9\u2081\n    have h9\u2083 : (5 : \u2124) * ((2 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2)) = (2 : \u2124)^k := by\n      have h9\u2084 : \u2200 (n : \u2115), n \u2265 2 \u2192 (5 : \u2124) * ((2 : \u2124)^(n - 1)) - 6 * ((2 : \u2124)^(n - 2)) = (2 : \u2124)^n := by\n        intro n hn\n        have h9\u2085 : n \u2265 2 := hn\n        have h9\u2086 : (n : \u2115) \u2265 2 := by exact_mod_cast h9\u2085\n        have h9\u2087 : (5 : \u2124) * ((2 : \u2124)^(n - 1)) - 6 * ((2 : \u2124)^(n - 2)) = (2 : \u2124)^n := by\n          have h9\u2088 : n \u2265 2 := hn\n          have h9\u2089 : (n : \u2115) \u2265 2 := by exact_mod_cast h9\u2088\n          -- We handle the exponentiation by cases to ensure the arithmetic works out.\n          cases n with\n          | zero => contradiction -- n cannot be zero since hn : n \u2265 2\n          | succ n' =>\n            cases n' with\n            | zero => contradiction -- n cannot be one since hn : n \u2265 2\n            | succ n'' =>\n              clear hn h9\u2085 h9\u2086 h9\u2088 h9\u2089\n              induction' n'' with n''' ih\n              -- Base case: n = 2\n              \u00b7 norm_num\n              -- Inductive step: assume the statement holds for n'', prove for n'' + 1\n              \u00b7 simp [pow_succ, mul_add, mul_comm, mul_left_comm, mul_assoc, Nat.succ_eq_add_one] at ih \u22a2\n                <;> ring_nf at ih \u22a2 <;>\n                (try omega) <;>\n                (try linarith) <;>\n                (try nlinarith) <;>\n                (try ring_nf at ih \u22a2 <;> omega)\n                <;>\n                (try nlinarith)\n        exact h9\u2087\n      have h9\u2088 : (5 : \u2124) * ((2 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2)) = (2 : \u2124)^k := h9\u2084 k h9\u2081\n      exact h9\u2088\n    exact h9\u2083\n  \n  have h10 : (5 : \u2124) * ((3 : \u2124)^(k - 1)) - 6 * ((3 : \u2124)^(k - 2)) = (3 : \u2124)^k := by\n    have h10\u2081 : k \u2265 2 := hk\n    have h10\u2082 : (k : \u2115) \u2265 2 := by exact_mod_cast h10\u2081\n    have h10\u2083 : (5 : \u2124) * ((3 : \u2124)^(k - 1)) - 6 * ((3 : \u2124)^(k - 2)) = (3 : \u2124)^k := by\n      have h10\u2084 : \u2200 (n : \u2115), n \u2265 2 \u2192 (5 : \u2124) * ((3 : \u2124)^(n - 1)) - 6 * ((3 : \u2124)^(n - 2)) = (3 : \u2124)^n := by\n        intro n hn\n        have h10\u2085 : n \u2265 2 := hn\n        have h10\u2086 : (n : \u2115) \u2265 2 := by exact_mod_cast h10\u2085\n        have h10\u2087 : (5 : \u2124) * ((3 : \u2124)^(n - 1)) - 6 * ((3 : \u2124)^(n - 2)) = (3 : \u2124)^n := by\n          have h10\u2088 : n \u2265 2 := hn\n          have h10\u2089 : (n : \u2115) \u2265 2 := by exact_mod_cast h10\u2088\n          -- We handle the exponentiation by cases to ensure the arithmetic works out.\n          cases n with\n          | zero => contradiction -- n cannot be zero since hn : n \u2265 2\n          | succ n' =>\n            cases n' with\n            | zero => contradiction -- n cannot be one since hn : n \u2265 2\n            | succ n'' =>\n              clear hn h10\u2085 h10\u2086 h10\u2088 h10\u2089\n              induction' n'' with n''' ih\n              -- Base case: n = 2\n              \u00b7 norm_num\n              -- Inductive step: assume the statement holds for n'', prove for n'' + 1\n              \u00b7 simp [pow_succ, mul_add, mul_comm, mul_left_comm, mul_assoc, Nat.succ_eq_add_one] at ih \u22a2\n                <;> ring_nf at ih \u22a2 <;>\n                (try omega) <;>\n                (try linarith) <;>\n                (try nlinarith) <;>\n                (try ring_nf at ih \u22a2 <;> omega)\n                <;>\n                (try nlinarith)\n        exact h10\u2087\n      have h10\u2088 : (5 : \u2124) * ((3 : \u2124)^(k - 1)) - 6 * ((3 : \u2124)^(k - 2)) = (3 : \u2124)^k := h10\u2084 k h10\u2081\n      exact h10\u2088\n    exact h10\u2083\n  \n  have h11 : a (k + 1) = (2 : \u2124)^k + (3 : \u2124)^k := by\n    have h11\u2081 : a (k + 1) = 5 * ((2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2) + (3 : \u2124)^(k - 2)) := h8\n    have h11\u2082 : (5 : \u2124) * ((2 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2)) = (2 : \u2124)^k := h9\n    have h11\u2083 : (5 : \u2124) * ((3 : \u2124)^(k - 1)) - 6 * ((3 : \u2124)^(k - 2)) = (3 : \u2124)^k := h10\n    calc\n      a (k + 1) = 5 * ((2 : \u2124)^(k - 1) + (3 : \u2124)^(k - 1)) - 6 * ((2 : \u2124)^(k - 2) + (3 : \u2124)^(k - 2)) := by rw [h11\u2081]\n      _ = (5 * (2 : \u2124)^(k - 1) - 6 * (2 : \u2124)^(k - 2)) + (5 * (3 : \u2124)^(k - 1) - 6 * (3 : \u2124)^(k - 2)) := by\n        ring_nf\n        <;>\n        (try norm_num) <;>\n        (try linarith)\n      _ = (2 : \u2124)^k + (3 : \u2124)^k := by\n        rw [h11\u2082, h11\u2083]\n        <;>\n        (try ring_nf) <;>\n        (try norm_num) <;>\n        (try linarith)\n  \n  have h12 : (a (k + 1) : \u2124) = (2 : \u2124)^k + (3 : \u2124)^k := by\n    exact_mod_cast h11\n  \n  have h13 : a (k + 1) = 2^k + 3^k := by\n    norm_cast at h12 \u22a2\n    <;>\n    (try simp_all [pow_succ]) <;>\n    (try ring_nf at *) <;>\n    (try norm_num at *) <;>\n    (try linarith)\n    <;>\n    (try omega)\n    <;>\n    (try nlinarith)\n  \n  exact h13", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is perfectly captured in the Lean formalization.", "The base cases for the formula are implicitly covered by the inductive hypothesis constraint.", "The inductive hypothesis is correctly formalized with the same logical structure.", "The constraint k \u2265 2 and the application of recurrence relation are properly represented.", "The conclusion differs in form: natural language shows the intermediate step a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2}) while Lean shows the simplified final form a(k+1) = 2^k + 3^k. These are mathematically equivalent but represent different proof stages."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "$5 \\cdot 2^{k-1} = 5 \\cdot 2^{k-2} \\cdot 2 = 10 \\cdot 2^{k-2}$. We have $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2];\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1];\n\u2022 $a_{k+1} = 5a_k - 6a_{k-1}$ [l3];\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l4].\nTherefore, we conclude:\n\u2022 $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$ [l5].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))\n  (h5 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h6 : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2))) :\n  a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))\n  (h5 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h6 : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2))) :\n  a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2) := by\n  have h7 : (5 : \u2124) * (2 : \u2124)^(k - 1) = (10 : \u2124) * (2 : \u2124)^(k - 2) := by\n    have h7\u2081 : (k : \u2115) \u2265 2 := hk\n    have h7\u2082 : (k : \u2115) - 1 = (k - 2 : \u2115) + 1 := by\n      have h7\u2083 : k \u2265 2 := hk\n      have h7\u2084 : k - 1 = (k - 2) + 1 := by\n        have h7\u2085 : k \u2265 2 := hk\n        omega\n      exact h7\u2084\n    have h7\u2083 : (2 : \u2124) ^ (k - 1 : \u2115) = (2 : \u2124) ^ ((k - 2 : \u2115) + 1 : \u2115) := by\n      rw [h7\u2082]\n      <;> simp [pow_add, pow_one]\n      <;> ring_nf\n    have h7\u2084 : (2 : \u2124) ^ ((k - 2 : \u2115) + 1 : \u2115) = (2 : \u2124) ^ (k - 2 : \u2115) * 2 := by\n      rw [pow_add]\n      <;> simp [pow_one]\n      <;> ring_nf\n    have h7\u2085 : (2 : \u2124) ^ (k - 1 : \u2115) = (2 : \u2124) ^ (k - 2 : \u2115) * 2 := by\n      rw [h7\u2083, h7\u2084]\n    calc\n      (5 : \u2124) * (2 : \u2124) ^ (k - 1 : \u2115) = (5 : \u2124) * ((2 : \u2124) ^ (k - 2 : \u2115) * 2) := by rw [h7\u2085]\n      _ = (10 : \u2124) * (2 : \u2124) ^ (k - 2 : \u2115) := by ring\n      _ = (10 : \u2124) * (2 : \u2124) ^ (k - 2) := by simp [zpow_ofNat]\n  \n  have h8 : (5 : \u2124) * (3 : \u2124)^(k - 1) = (15 : \u2124) * (3 : \u2124)^(k - 2) := by\n    have h8\u2081 : (k : \u2115) \u2265 2 := hk\n    have h8\u2082 : (k : \u2115) - 1 = (k - 2 : \u2115) + 1 := by\n      have h8\u2083 : k \u2265 2 := hk\n      have h8\u2084 : k - 1 = (k - 2) + 1 := by\n        have h8\u2085 : k \u2265 2 := hk\n        omega\n      exact h8\u2084\n    have h8\u2083 : (3 : \u2124) ^ (k - 1 : \u2115) = (3 : \u2124) ^ ((k - 2 : \u2115) + 1 : \u2115) := by\n      rw [h8\u2082]\n      <;> simp [pow_add, pow_one]\n      <;> ring_nf\n    have h8\u2084 : (3 : \u2124) ^ ((k - 2 : \u2115) + 1 : \u2115) = (3 : \u2124) ^ (k - 2 : \u2115) * 3 := by\n      rw [pow_add]\n      <;> simp [pow_one]\n      <;> ring_nf\n    have h8\u2085 : (3 : \u2124) ^ (k - 1 : \u2115) = (3 : \u2124) ^ (k - 2 : \u2115) * 3 := by\n      rw [h8\u2083, h8\u2084]\n    calc\n      (5 : \u2124) * (3 : \u2124) ^ (k - 1 : \u2115) = (5 : \u2124) * ((3 : \u2124) ^ (k - 2 : \u2115) * 3) := by rw [h8\u2085]\n      _ = (15 : \u2124) * (3 : \u2124) ^ (k - 2 : \u2115) := by ring\n      _ = (15 : \u2124) * (3 : \u2124) ^ (k - 2) := by simp [zpow_ofNat]\n  \n  have h9 : a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2) := by\n    have h9\u2081 : a (k + 1) = 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) := by\n      exact h6\n    have h9\u2082 : (5 : \u2124) * (2 : \u2124)^(k - 1) = (10 : \u2124) * (2 : \u2124)^(k - 2) := h7\n    have h9\u2083 : (5 : \u2124) * (3 : \u2124)^(k - 1) = (15 : \u2124) * (3 : \u2124)^(k - 2) := h8\n    calc\n      a (k + 1) = 5 * (2 ^ (k - 1) + 3 ^ (k - 1)) - 6 * (2 ^ (k - 2) + 3 ^ (k - 2)) := by rw [h9\u2081]\n      _ = (5 * (2 : \u2124) ^ (k - 1) + 5 * (3 : \u2124) ^ (k - 1)) - (6 * (2 : \u2124) ^ (k - 2) + 6 * (3 : \u2124) ^ (k - 2)) := by\n        ring_nf\n        <;> simp [zpow_ofNat]\n        <;> norm_cast\n        <;> ring_nf\n      _ = (10 * (2 : \u2124) ^ (k - 2) + 15 * (3 : \u2124) ^ (k - 2)) - (6 * (2 : \u2124) ^ (k - 2) + 6 * (3 : \u2124) ^ (k - 2)) := by\n        rw [h9\u2082, h9\u2083]\n        <;> ring_nf\n        <;> simp [zpow_ofNat]\n        <;> norm_cast\n      _ = 10 * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) := by\n        ring_nf\n        <;> simp [zpow_ofNat]\n        <;> norm_cast\n        <;> ring_nf\n        <;> simp_all [Nat.cast_add, Nat.cast_mul, Nat.cast_pow]\n        <;> linarith\n  \n  exact h9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization accurately captures all components of the natural language premise. The sequence definition, initial conditions, recurrence relation, inductive hypothesis, and the algebraic expansion are all properly formalized. The base cases l1 and l2 are implicitly covered by the inductive hypothesis h4, which is mathematically equivalent and more concise. All mathematical relationships and logical dependencies are preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Combining like terms gives $(10-6) \\cdot 2^{k-2} + (15-6) \\cdot 3^{k-2} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2];\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1];\n\u2022 $a_{k+1} = 5a_k - 6a_{k-1}$ [l3];\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l4];\n\u2022 $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$ [l5].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$ [l6].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))\n  (h5 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h6 : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)))\n  (h7 : a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2)) :\n  a (k + 1) = 4 * 2^(k - 2) + 9 * 3^(k - 2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))\n  (h5 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h6 : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)))\n  (h7 : a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2)) :\n  a (k + 1) = 4 * 2^(k - 2) + 9 * 3^(k - 2) := by\n  have h8 : (10 : \u2124) * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) := by\n    have h8\u2081 : (10 : \u2124) * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) = (10 - 6 : \u2124) * 2 ^ (k - 2) + (15 - 6 : \u2124) * 3 ^ (k - 2) := by\n      ring_nf\n      <;>\n      simp [pow_add, pow_one, mul_assoc, mul_comm, mul_left_comm]\n      <;>\n      ring_nf at *\n      <;>\n      norm_num at *\n      <;>\n      linarith\n    rw [h8\u2081]\n    <;> norm_num\n    <;>\n    (try decide)\n    <;>\n    (try ring_nf at *)\n    <;>\n    (try norm_num at *)\n    <;>\n    (try linarith)\n  \n  have h9 : a (k + 1) = 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) := by\n    have h9\u2081 : a (k + 1) = (10 : \u2124) * 2 ^ (k - 2) + 15 * 3 ^ (k - 2) - 6 * 2 ^ (k - 2) - 6 * 3 ^ (k - 2) := by\n      exact h7\n    rw [h9\u2081]\n    linarith\n  \n  exact h9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language proof. The sequence definition, inductive hypothesis, recurrence relation application, algebraic manipulations, and final conclusion are all properly formalized. The additional technical details in Lean (type declarations, explicit hypothesis naming) are standard formalization practices that don't alter the mathematical content."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "We can simplify this further: $4 \\cdot 2^{k-2} = 2^2 \\cdot 2^{k-2} = 2^k$. And $9 \\cdot 3^{k-2} = 3^2 \\cdot 3^{k-2} = 3^k$. Thus, $a_{k+1}=2^k+3^k$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2];\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1];\n\u2022 $a_{k+1} = 5a_k - 6a_{k-1}$ [l3];\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l4];\n\u2022 $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$ [l5];\n\u2022 $a_{k+1} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1}=2^k+3^k$ [l7].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))\n  (h5 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h6 : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)))\n  (h7 : a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2))\n  (h8 : a (k + 1) = 4 * 2^(k - 2) + 9 * 3^(k - 2)) :\n  a (k + 1) = 2^k + 3^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma key_step (k : \u2115) (hk : k \u2265 2) : 4 * 2^(k-2) + 9 * 3^(k-2) = 2^k + 3^k := by\n  have h\u2081 : 2 ^ k = 4 * 2 ^ (k - 2) := by\n    have h\u2082 : k = (k - 2) + 2 := by\n      have h\u2083 : k \u2265 2 := hk\n      omega\n    rw [h\u2082]\n    calc\n      2 ^ ((k - 2) + 2) = 2 ^ (k - 2) * 2 ^ 2 := by rw [pow_add]\n      _ = 2 ^ (k - 2) * 4 := by norm_num\n      _ = 4 * 2 ^ (k - 2) := by ring\n  have h\u2082 : 3 ^ k = 9 * 3 ^ (k - 2) := by\n    have h\u2083 : k = (k - 2) + 2 := by\n      have h\u2084 : k \u2265 2 := hk\n      omega\n    rw [h\u2083]\n    calc\n      3 ^ ((k - 2) + 2) = 3 ^ (k - 2) * 3 ^ 2 := by rw [pow_add]\n      _ = 3 ^ (k - 2) * 9 := by norm_num\n      _ = 9 * 3 ^ (k - 2) := by ring\n  have h\u2083 : 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) = 2 ^ k + 3 ^ k := by\n    linarith\n  exact h\u2083\n\ntheorem l7 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2))\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h4 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j - 1) + 3^(j - 1))\n  (h5 : a (k + 1) = 5 * a k - 6 * a (k - 1))\n  (h6 : a (k + 1) = 5 * (2^(k - 1) + 3^(k - 1)) - 6 * (2^(k - 2) + 3^(k - 2)))\n  (h7 : a (k + 1) = 10 * 2^(k - 2) + 15 * 3^(k - 2) - 6 * 2^(k - 2) - 6 * 3^(k - 2))\n  (h8 : a (k + 1) = 4 * 2^(k - 2) + 9 * 3^(k - 2)) :\n  a (k + 1) = 2^k + 3^k := by\n  have h_key : 4 * 2^(k-2) + 9 * 3^(k-2) = 2^k + 3^k := by\n    have h\u2089 : 4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) = 2 ^ k + 3 ^ k := by\n      apply key_step\n      <;> omega\n    exact h\u2089\n  \n  have h_main : a (k + 1) = 2^k + 3^k := by\n    have h\u2089 : (a (k + 1) : \u2124) = (4 * 2^(k - 2) + 9 * 3^(k - 2) : \u2115) := by\n      norm_cast at h8 \u22a2\n      <;> simp_all [h8]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    have h\u2081\u2080 : (a (k + 1) : \u2124) = (2 ^ k + 3 ^ k : \u2115) := by\n      have h\u2081\u2081 : (4 * 2 ^ (k - 2) + 9 * 3 ^ (k - 2) : \u2115) = (2 ^ k + 3 ^ k : \u2115) := by\n        norm_cast at h_key \u22a2\n        <;> simp_all [h_key]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      rw [h\u2089]\n      <;> norm_cast at h\u2081\u2081 \u22a2 <;> simp_all [h\u2081\u2081]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> linarith\n    norm_cast at h\u2081\u2080 \u22a2\n    <;> simp_all [h\u2081\u2080]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The sequence definition, initial conditions, recurrence relation, inductive hypothesis, and all intermediate algebraic steps are properly represented. The base cases [l1] and [l2] mentioned separately in natural language are logically covered by the inductive hypothesis h4. All constraints and mathematical relationships are preserved with appropriate types."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Thus, $a_{k+1}=2^k+3^k$. This matches the formula for $n=k+1$. By the principle of strong mathematical induction, the statement is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)$ is a sequence of integers where $a_1=2$, $a_2=5$, and $a_n = 5a_{n-1} - 6a_{n-2}$ for all integers $n \\geq 3$ [tc_1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=1$ [l1];\n\u2022 The formula $a_n = 2^{n-1}+3^{n-1}$ holds for $n=2$ [l2];\n\u2022 For some integer $k \\geq 2$, we assume as the inductive hypothesis that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+3^{j-1}$ holds [def_1];\n\u2022 $a_{k+1} = 5a_k - 6a_{k-1}$ [l3];\n\u2022 $a_{k+1}=5(2^{k-1}+3^{k-1})-6(2^{k-2}+3^{k-2})$ [l4];\n\u2022 $a_{k+1}=10 \\cdot 2^{k-2} + 15 \\cdot 3^{k-2} - 6 \\cdot 2^{k-2} - 6 \\cdot 3^{k-2}$ [l5];\n\u2022 $a_{k+1} = 4 \\cdot 2^{k-2} + 9 \\cdot 3^{k-2}$ [l6];\n\u2022 The inductive step is completed by showing $a_{k+1}=2^k+3^k$ [l7].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, $a_n = 2^{n-1}+3^{n-1}$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "def_1", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n - 1) + 3^(n - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2)\n  (h2 : a 2 = 5)\n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 5 * a (n - 1) - 6 * a (n - 2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n - 1) + 3^(n - 1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u2124)^(n - 1) + (3 : \u2124)^(n - 1) := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u2124)^(n - 1) + (3 : \u2124)^(n - 1) := by\n      intro n\n      induction' n using Nat.strong_induction_on with n ih\n      intro hn\n      match n with\n      | 0 =>\n        -- For n = 0, the hypothesis n \u2265 1 is false, so this case is vacuously true.\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h1] at hn \u22a2\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h2] at hn \u22a2\n      | 3 =>\n        -- Base case: n = 3 (could also be part of the inductive step)\n        have h\u2083 := h3 3 (by norm_num)\n        have h\u2082 : a 2 = (2 : \u2124)^(2 - 1) + (3 : \u2124)^(2 - 1) := by\n          norm_num [h2]\n        have h\u2081 : a 1 = (2 : \u2124)^(1 - 1) + (3 : \u2124)^(1 - 1) := by\n          norm_num [h1]\n        norm_num [h\u2083, h\u2082, h\u2081] at *\n        <;>\n        (try omega) <;>\n        (try ring_nf at *) <;>\n        (try norm_num at *) <;>\n        (try linarith)\n      | n + 4 =>\n        -- Inductive step: n \u2265 4\n        have h\u2084 := h3 (n + 4) (by omega)\n        have h\u2083 : a (n + 3) = (2 : \u2124)^((n + 3) - 1) + (3 : \u2124)^((n + 3) - 1) := by\n          have h\u2083\u2081 : (n + 3 : \u2115) \u2265 1 := by omega\n          have h\u2083\u2082 : a (n + 3) = (2 : \u2124)^((n + 3) - 1) + (3 : \u2124)^((n + 3) - 1) := by\n            apply ih (n + 3)\n            <;> omega\n          exact h\u2083\u2082\n        have h\u2082 : a (n + 2) = (2 : \u2124)^((n + 2) - 1) + (3 : \u2124)^((n + 2) - 1) := by\n          have h\u2082\u2081 : (n + 2 : \u2115) \u2265 1 := by omega\n          have h\u2082\u2082 : a (n + 2) = (2 : \u2124)^((n + 2) - 1) + (3 : \u2124)^((n + 2) - 1) := by\n            apply ih (n + 2)\n            <;> omega\n          exact h\u2082\u2082\n        have h\u2081 : a (n + 4) = 5 * a (n + 3) - 6 * a (n + 2) := by\n          simpa [Nat.add_assoc] using h\u2084\n        rw [h\u2081, h\u2083, h\u2082]\n        -- Simplify the expression to show it equals 2^(n+3) + 3^(n+3)\n        have h\u2085 : (n : \u2115) + 4 \u2265 4 := by omega\n        cases n with\n        | zero =>\n          norm_num at h\u2085 \u22a2 <;>\n          (try ring_nf at *) <;>\n          (try norm_num at *) <;>\n          (try linarith)\n        | succ n =>\n          simp [pow_add, pow_one, pow_two, mul_add, mul_comm, mul_left_comm, mul_assoc,\n            Nat.succ_eq_add_one] at *\n          <;>\n          ring_nf at * <;>\n          norm_num at * <;>\n          (try omega) <;>\n          (try\n            {\n              simp_all [pow_add, pow_one, pow_two, mul_add, mul_comm, mul_left_comm, mul_assoc]\n              <;> ring_nf at * <;> norm_num at * <;> linarith\n            })\n          <;>\n          (try\n            {\n              simp_all [pow_add, pow_one, pow_two, mul_add, mul_comm, mul_left_comm, mul_assoc]\n              <;> ring_nf at * <;> norm_num at * <;> linarith\n            })\n          <;>\n          (try\n            {\n              simp_all [pow_add, pow_one, pow_two, mul_add, mul_comm, mul_left_comm, mul_assoc]\n              <;> ring_nf at * <;> norm_num at * <;> linarith\n            })\n    exact h n hn\n  intro n hn\n  have h\u2081 : a n = (2 : \u2124)^(n - 1) + (3 : \u2124)^(n - 1) := h_main n hn\n  norm_cast at h\u2081 \u22a2\n  <;>\n  (try simp_all [pow_add, pow_one, pow_two, mul_add, mul_comm, mul_left_comm, mul_assoc]) <;>\n  (try ring_nf at *) <;>\n  (try norm_num at *) <;>\n  (try linarith)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical components from the natural language. The theorem statement includes: (1) the sequence a with initial conditions a(1)=2 and a(2)=5, (2) the recurrence relation a(n) = 5*a(n-1) - 6*a(n-2) for n\u22653, and (3) the conclusion that a(n) = 2^(n-1) + 3^(n-1) for all n\u22651. While the natural language provides detailed steps of an inductive proof (base cases, inductive hypothesis, algebraic manipulations), the Lean formalization appropriately states the theorem to be proved without including the proof steps in the theorem statement itself - this is standard mathematical practice where the theorem statement captures what needs to be proven, and the proof would be provided separately. The 'sorry' indicates the proof is omitted, which is acceptable for analyzing the theorem statement. All mathematical relationships and constraints from the natural language are faithfully represented in the Lean code."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    