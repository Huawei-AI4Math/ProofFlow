
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}$ and $\mathbf{Y}$ are in $\R^n,$ then
\begin{equation}\label{eq:5.1.6}
|\mathbf{X}+\mathbf{Y}|\le |\mathbf{X}|+|\mathbf{Y}|,
\end{equation}
with equality if and only if one of the vectors is a nonnegative
multiple of the other$.$

We can assume the following statement(s) without a proof. 

If $\mathbf{X}$ and $\mathbf{Y}$ are any two vectors in $\R^n,$ then
\begin{equation} \label{eq:5.1.3}
|\mathbf{X}\cdot\mathbf{Y}|\le |\mathbf{X}|\,|\mathbf{Y}|,
\end{equation}
with equality  if and only if one of the vectors is a scalar
multiple of the other$.$

Proof: By definition,
\begin{equation} \label{eq:5.1.7}
\begin{array}{rcl}
|\mathbf{X}+\mathbf{Y}|^2\ar=\dst\sum^n_{i=1} (x_i+y_i)^2=\sum^n_{i=1} x^2_i+
2\sum^n_{i=1} x_iy_i+\sum^n_{i=1}y^2_i\\[4\jot]
\ar=|\mathbf{X}|^2+2(\mathbf{X}\cdot\mathbf{Y})+|\mathbf{Y}|^2\\[2\jot]
\ar\le  |\mathbf{X}|^2+2|\mathbf{X}|\,|\mathbf{Y}|+|\mathbf{Y}|^2\mbox{\quad (by
Schwarz's inequality)}\\[2\jot]
\ar=(|\mathbf{X}|+|\mathbf{Y}|)^2.
\end{array}
\end{equation}
Hence,
$$
|\mathbf{X}+\mathbf{Y}|^2\le (|\mathbf{X}|+|\mathbf{Y}|)^2.
$$
Taking square roots yields \eqref{eq:5.1.6}.
From the third line of \eqref{eq:5.1.7},
equality holds in \eqref{eq:5.1.6} if and
only  if $\mathbf{X}\cdot\mathbf{Y}=|\mathbf{X}||\mathbf{Y}|$, which is true if
and
only if one of the vectors $\mathbf{X}$ and $\mathbf{Y}$ is a nonnegative
scalar multiple of the other (Lemma~\ref{thmtype:5.1.5}).
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X}$ and $\\mathbf{Y}$ are in $\\R^n,$", "statement": "Premise:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115) (X Y : Fin n \u2192 \u211d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents vectors in \u211d\u207f using the type 'Fin n \u2192 \u211d', which is the standard mathematical representation of n-dimensional real vectors in Lean. The natural number n is properly declared as the dimension.", "Both the natural language and Lean formalization are premise statements with no conclusions to prove, which matches perfectly."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $\\mathbf{X}$ and $\\mathbf{Y}$ are any two vectors in $\\R^n,$ then\n|$\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$, with equality if and only if one of the vectors is a scalar multiple of the other.", "statement": "Premise:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 For any two vectors $\\mathbf{X}, \\mathbf{Y} \\in \\R^n$, we have the Cauchy-Schwarz inequality $|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$, with equality if and only if one of the vectors is a scalar multiple of the other [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem cauchySchwarz (n : \u2115) (X Y : Fin n \u2192 \u211d) :\n  |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016 \u2227\n  (|\u2211 i, X i * Y i| = \u2016X\u2016 * \u2016Y\u2016 \u2194 \n   \u2203 c : \u211d, X = c \u2022 Y \u2228 Y = c \u2022 X) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents vectors in \u211d\u207f using the type `Fin n \u2192 \u211d`, which is the standard way to represent n-dimensional vectors in Lean. This perfectly captures the mathematical meaning.", "The Lean formalization correctly captures the Cauchy-Schwarz inequality. The dot product `\u2211 i, X i * Y i` corresponds to $\\mathbf{X}\\cdot\\mathbf{Y}$, the norms `\u2016X\u2016 * \u2016Y\u2016` correspond to $|\\mathbf{X}|\\,|\\mathbf{Y}|$, and the equality condition with scalar multiples `\u2203 c : \u211d, X = c \u2022 Y \u2228 Y = c \u2022 X` perfectly matches the natural language statement about one vector being a scalar multiple of the other."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "By definition,\n\\begin{equation} \\label{eq:5.1.7}\n\\begin{array}{rcl}\n|\\mathbf{X}+\\mathbf{Y}|^2\\ar=\\dst\\sum^n_{i=1} (x_i+y_i)^2=\\sum^n_{i=1} x^2_i+\n2\\sum^n_{i=1} x_iy_i+\\sum^n_{i=1}y^2_i\\[4\\jot]\n\\ar=|\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2\n\\end{array}\n\\end{equation}", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 For any two vectors $\\mathbf{X}, \\mathbf{Y} \\in \\R^n$, we have the Cauchy-Schwarz inequality $|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$ [tc_2].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016) :\n  \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016) :\n  \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2 := by\n  have h1 : \u2016X + Y\u2016^2 = \u2211 i : Fin n, (X i + Y i)^2 := by\n    have h\u2081 : \u2016X + Y\u2016 = Real.sqrt (\u2211 i : Fin n, (X i + Y i) ^ 2) := by\n      simp [Pi.norm_def, Real.norm_eq_abs, Finset.sum_range_succ, add_assoc]\n      <;>\n      congr 1 <;>\n      ext i <;>\n      simp [Pi.add_apply, add_assoc, add_comm, add_left_comm]\n      <;>\n      ring_nf\n      <;>\n      simp [abs_mul_abs_self]\n    have h\u2082 : \u2016X + Y\u2016 ^ 2 = \u2211 i : Fin n, (X i + Y i) ^ 2 := by\n      rw [h\u2081]\n      have h\u2083 : 0 \u2264 \u2211 i : Fin n, (X i + Y i) ^ 2 := by\n        apply Finset.sum_nonneg\n        intro i _\n        nlinarith [sq_nonneg (X i + Y i)]\n      rw [Real.sq_sqrt] <;>\n      linarith\n    exact h\u2082\n  \n  have h2 : \u2211 i : Fin n, (X i + Y i)^2 = \u2211 i : Fin n, (X i^2 + 2 * X i * Y i + Y i^2) := by\n    apply Finset.sum_congr rfl\n    intro i _\n    have h2\u2081 : (X i + Y i) ^ 2 = X i ^ 2 + 2 * X i * Y i + Y i ^ 2 := by\n      ring\n    rw [h2\u2081]\n    <;>\n    simp [add_assoc]\n    <;>\n    ring_nf\n  \n  have h3 : \u2211 i : Fin n, (X i^2 + 2 * X i * Y i + Y i^2) = (\u2211 i : Fin n, X i^2) + (\u2211 i : Fin n, 2 * X i * Y i) + (\u2211 i : Fin n, Y i^2) := by\n    calc\n      \u2211 i : Fin n, (X i ^ 2 + 2 * X i * Y i + Y i ^ 2) = \u2211 i : Fin n, (X i ^ 2 + (2 * X i * Y i) + Y i ^ 2) := by simp [add_assoc]\n      _ = (\u2211 i : Fin n, X i ^ 2) + (\u2211 i : Fin n, 2 * X i * Y i) + (\u2211 i : Fin n, Y i ^ 2) := by\n        calc\n          \u2211 i : Fin n, (X i ^ 2 + (2 * X i * Y i) + Y i ^ 2) = \u2211 i : Fin n, (X i ^ 2 + (2 * X i * Y i) + Y i ^ 2) := rfl\n          _ = (\u2211 i : Fin n, (X i ^ 2 + (2 * X i * Y i))) + \u2211 i : Fin n, Y i ^ 2 := by\n            rw [Finset.sum_add_distrib]\n          _ = (\u2211 i : Fin n, X i ^ 2 + \u2211 i : Fin n, (2 * X i * Y i)) + \u2211 i : Fin n, Y i ^ 2 := by\n            rw [Finset.sum_add_distrib]\n          _ = (\u2211 i : Fin n, X i ^ 2) + (\u2211 i : Fin n, 2 * X i * Y i) + \u2211 i : Fin n, Y i ^ 2 := by\n            ring\n          _ = (\u2211 i : Fin n, X i ^ 2) + (\u2211 i : Fin n, 2 * X i * Y i) + (\u2211 i : Fin n, Y i ^ 2) := by rfl\n  \n  have h4 : (\u2211 i : Fin n, 2 * X i * Y i) = 2 * (\u2211 i : Fin n, X i * Y i) := by\n    calc\n      (\u2211 i : Fin n, 2 * X i * Y i) = \u2211 i : Fin n, 2 * (X i * Y i) := by\n        apply Finset.sum_congr rfl\n        intro i _\n        ring\n      _ = 2 * \u2211 i : Fin n, (X i * Y i) := by\n        rw [Finset.mul_sum]\n        <;>\n        simp [mul_assoc]\n      _ = 2 * (\u2211 i : Fin n, X i * Y i) := by rfl\n  \n  have h5 : \u2016X + Y\u2016^2 = (\u2211 i : Fin n, X i^2) + 2 * (\u2211 i : Fin n, X i * Y i) + (\u2211 i : Fin n, Y i^2) := by\n    calc\n      \u2016X + Y\u2016 ^ 2 = \u2211 i : Fin n, (X i + Y i) ^ 2 := h1\n      _ = \u2211 i : Fin n, (X i ^ 2 + 2 * X i * Y i + Y i ^ 2) := h2\n      _ = (\u2211 i : Fin n, X i ^ 2) + (\u2211 i : Fin n, 2 * X i * Y i) + (\u2211 i : Fin n, Y i ^ 2) := h3\n      _ = (\u2211 i : Fin n, X i ^ 2) + 2 * (\u2211 i : Fin n, X i * Y i) + (\u2211 i : Fin n, Y i ^ 2) := by\n        rw [h4]\n        <;> ring\n        <;>\n        simp_all [Finset.sum_add_distrib]\n        <;>\n        ring_nf\n        <;>\n        linarith\n  \n  have h6 : \u2016X\u2016^2 = \u2211 i : Fin n, X i^2 := by\n    have h\u2081 : \u2016X\u2016 = Real.sqrt (\u2211 i : Fin n, (X i) ^ 2) := by\n      simp [Pi.norm_def, Real.norm_eq_abs, Finset.sum_range_succ, add_assoc]\n      <;>\n      congr 1 <;>\n      ext i <;>\n      simp [add_assoc, add_comm, add_left_comm]\n      <;>\n      ring_nf\n      <;>\n      simp [abs_mul_abs_self]\n    have h\u2082 : \u2016X\u2016 ^ 2 = \u2211 i : Fin n, (X i) ^ 2 := by\n      rw [h\u2081]\n      have h\u2083 : 0 \u2264 \u2211 i : Fin n, (X i) ^ 2 := by\n        apply Finset.sum_nonneg\n        intro i _\n        nlinarith [sq_nonneg (X i)]\n      rw [Real.sq_sqrt] <;>\n      linarith\n    calc\n      \u2016X\u2016 ^ 2 = \u2211 i : Fin n, (X i) ^ 2 := h\u2082\n      _ = \u2211 i : Fin n, X i ^ 2 := by simp [pow_two]\n  \n  have h7 : \u2016Y\u2016^2 = \u2211 i : Fin n, Y i^2 := by\n    have h\u2081 : \u2016Y\u2016 = Real.sqrt (\u2211 i : Fin n, (Y i) ^ 2) := by\n      simp [Pi.norm_def, Real.norm_eq_abs, Finset.sum_range_succ, add_assoc]\n      <;>\n      congr 1 <;>\n      ext i <;>\n      simp [add_assoc, add_comm, add_left_comm]\n      <;>\n      ring_nf\n      <;>\n      simp [abs_mul_abs_self]\n    have h\u2082 : \u2016Y\u2016 ^ 2 = \u2211 i : Fin n, (Y i) ^ 2 := by\n      rw [h\u2081]\n      have h\u2083 : 0 \u2264 \u2211 i : Fin n, (Y i) ^ 2 := by\n        apply Finset.sum_nonneg\n        intro i _\n        nlinarith [sq_nonneg (Y i)]\n      rw [Real.sq_sqrt] <;>\n      linarith\n    calc\n      \u2016Y\u2016 ^ 2 = \u2211 i : Fin n, (Y i) ^ 2 := h\u2082\n      _ = \u2211 i : Fin n, Y i ^ 2 := by simp [pow_two]\n  \n  have h8 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2 := by\n    calc\n      \u2016X + Y\u2016 ^ 2 = (\u2211 i : Fin n, X i ^ 2) + 2 * (\u2211 i : Fin n, X i * Y i) + (\u2211 i : Fin n, Y i ^ 2) := h5\n      _ = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 := by\n        rw [h6, h7]\n        <;>\n        simp_all [Finset.sum_add_distrib]\n        <;>\n        ring_nf\n        <;>\n        linarith\n      _ = \u2016X\u2016 ^ 2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016 ^ 2 := by\n        simp [Finset.sum_range_succ, add_assoc]\n        <;>\n        ring_nf\n        <;>\n        simp_all [Finset.sum_add_distrib]\n        <;>\n        linarith\n  \n  exact h8", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 6, "endLine": 19, "endColumn": 29, "data": "simp made no progress"}, {"line": 92, "column": 6, "endLine": 92, "endColumn": 29, "data": "simp made no progress"}, {"line": 115, "column": 6, "endLine": 115, "endColumn": 29, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The representation of vectors as functions Fin n \u2192 \u211d correctly captures vectors in \u211d\u207f", "The Cauchy-Schwarz inequality is accurately formalized with proper dot product and norm notation", "The vector addition identity is correctly expressed with consistent notation for norms and dot products", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016) :\n  \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2 := by\n  have h\u2081 : \u2016X + Y\u2016 ^ 2 = \u2211 i : Fin n, (X i + Y i) ^ 2 := by\n    calc\n      \u2016X + Y\u2016 ^ 2 = (\u2016X + Y\u2016 : \u211d) ^ 2 := by norm_cast\n      _ = \u2211 i : Fin n, (X i + Y i) ^ 2 := by\n        -- Use the property that the square of the norm is the sum of the squares of the components\n        have h : \u2016X + Y\u2016 = Real.sqrt (\u2211 i : Fin n, (X i + Y i) ^ 2) := by\n          simp [Norm.norm, Real.norm_eq_abs, Pi.add_apply]\n          <;>\n          simp_all [Real.sqrt_sq_eq_abs, sq_abs]\n          <;>\n          rfl\n        rw [h]\n        -- Square the square root to get the sum of squares\n        have h\u2082 : 0 \u2264 \u2211 i : Fin n, (X i + Y i) ^ 2 := by\n          apply Finset.sum_nonneg\n          intro i _\n          nlinarith [sq_nonneg (X i + Y i)]\n        rw [Real.sq_sqrt h\u2082]\n      _ = \u2211 i : Fin n, (X i + Y i) ^ 2 := by rfl\n  \n  have h\u2082 : \u2211 i : Fin n, (X i + Y i) ^ 2 = \u2211 i : Fin n, (X i ^ 2 + 2 * X i * Y i + Y i ^ 2) := by\n    apply Finset.sum_congr rfl\n    intro i _\n    have h\u2082\u2081 : (X i + Y i) ^ 2 = X i ^ 2 + 2 * X i * Y i + Y i ^ 2 := by\n      ring\n    rw [h\u2082\u2081]\n  \n  have h\u2083 : \u2211 i : Fin n, (X i ^ 2 + 2 * X i * Y i + Y i ^ 2) = (\u2211 i : Fin n, (X i ^ 2)) + 2 * (\u2211 i : Fin n, X i * Y i) + (\u2211 i : Fin n, (Y i ^ 2)) := by\n    calc\n      _ = \u2211 i : Fin n, (X i ^ 2 + 2 * X i * Y i + Y i ^ 2) := rfl\n      _ = \u2211 i : Fin n, (X i ^ 2) + \u2211 i : Fin n, (2 * X i * Y i) + \u2211 i : Fin n, (Y i ^ 2) := by\n        simp [Finset.sum_add_distrib]\n      _ = (\u2211 i : Fin n, (X i ^ 2)) + 2 * (\u2211 i : Fin n, X i * Y i) + (\u2211 i : Fin n, (Y i ^ 2)) := by\n        have h\u2083\u2081 : \u2211 i : Fin n, (2 * X i * Y i) = 2 * \u2211 i : Fin n, (X i * Y i) := by\n          calc\n            \u2211 i : Fin n, (2 * X i * Y i) = \u2211 i : Fin n, (2 * (X i * Y i)) := by\n              apply Finset.sum_congr rfl\n              intro i _\n              ring\n            _ = 2 * \u2211 i : Fin n, (X i * Y i) := by\n              simp [Finset.mul_sum]\n        rw [h\u2083\u2081]\n        <;> ring\n        <;> simp [Finset.mul_sum]\n        <;> ring\n        <;> simp [Finset.sum_add_distrib]\n        <;> ring\n  \n  have h\u2084 : (\u2211 i : Fin n, (X i ^ 2)) = \u2016X\u2016 ^ 2 := by\n    have h\u2084\u2081 : \u2016X\u2016 = Real.sqrt (\u2211 i : Fin n, (X i : \u211d) ^ 2) := by\n      simp [Norm.norm, Real.norm_eq_abs]\n      <;>\n      simp_all [Real.sqrt_sq_eq_abs, sq_abs]\n      <;>\n      rfl\n    have h\u2084\u2082 : 0 \u2264 \u2211 i : Fin n, (X i : \u211d) ^ 2 := by\n      apply Finset.sum_nonneg\n      intro i _\n      positivity\n    calc\n      (\u2211 i : Fin n, (X i ^ 2)) = \u2211 i : Fin n, (X i : \u211d) ^ 2 := by simp\n      _ = (Real.sqrt (\u2211 i : Fin n, (X i : \u211d) ^ 2)) ^ 2 := by\n        rw [Real.sq_sqrt] <;> positivity\n      _ = \u2016X\u2016 ^ 2 := by\n        rw [h\u2084\u2081]\n        <;>\n        simp [sq]\n  \n  have h\u2085 : (\u2211 i : Fin n, (Y i ^ 2)) = \u2016Y\u2016 ^ 2 := by\n    have h\u2085\u2081 : \u2016Y\u2016 = Real.sqrt (\u2211 i : Fin n, (Y i : \u211d) ^ 2) := by\n      simp [Norm.norm, Real.norm_eq_abs]\n      <;>\n      simp_all [Real.sqrt_sq_eq_abs, sq_abs]\n      <;>\n      rfl\n    have h\u2085\u2082 : 0 \u2264 \u2211 i : Fin n, (Y i : \u211d) ^ 2 := by\n      apply Finset.sum_nonneg\n      intro i _\n      positivity\n    calc\n      (\u2211 i : Fin n, (Y i ^ 2)) = \u2211 i : Fin n, (Y i : \u211d) ^ 2 := by simp\n      _ = (Real.sqrt (\u2211 i : Fin n, (Y i : \u211d) ^ 2)) ^ 2 := by\n        rw [Real.sq_sqrt] <;> positivity\n      _ = \u2016Y\u2016 ^ 2 := by\n        rw [h\u2085\u2081]\n        <;>\n        simp [sq]\n  \n  calc\n    \u2016X + Y\u2016 ^ 2 = \u2211 i : Fin n, (X i + Y i) ^ 2 := by rw [h\u2081]\n    _ = \u2211 i : Fin n, (X i ^ 2 + 2 * X i * Y i + Y i ^ 2) := by rw [h\u2082]\n    _ = (\u2211 i : Fin n, (X i ^ 2)) + 2 * (\u2211 i : Fin n, X i * Y i) + (\u2211 i : Fin n, (Y i ^ 2)) := by rw [h\u2083]\n    _ = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 := by\n      rw [h\u2084, h\u2085]\n      <;>\n      simp_all [add_assoc]\n      <;>\n      ring_nf\n      <;>\n      norm_num\n      <;>\n      linarith"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "\\ar\\le  |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2\\mbox{\\quad (by\nSchwarz's inequality)}", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 For any two vectors $\\mathbf{X}, \\mathbf{Y} \\in \\R^n$, we have the Cauchy-Schwarz inequality $|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$ [tc_2].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2$ [l1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2) :\n  \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2) :\n  \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 := by\n  have h_sum_le : (\u2211 i : Fin n, X i * Y i) \u2264 \u2016X\u2016 * \u2016Y\u2016 := by\n    have h\u2081 : (\u2211 i : Fin n, X i * Y i) \u2264 |\u2211 i : Fin n, X i * Y i| := by\n      exact le_abs_self _\n    have h\u2082 : |\u2211 i : Fin n, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016 := h_cschwarz\n    linarith\n  \n  have h_two_sum_le : 2 * (\u2211 i : Fin n, X i * Y i) \u2264 2 * (\u2016X\u2016 * \u2016Y\u2016) := by\n    have h\u2081 : (\u2211 i : Fin n, X i * Y i) \u2264 \u2016X\u2016 * \u2016Y\u2016 := h_sum_le\n    have h\u2082 : 2 * (\u2211 i : Fin n, X i * Y i) \u2264 2 * (\u2016X\u2016 * \u2016Y\u2016) := by\n      linarith\n    exact h\u2082\n  \n  have h_main : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 := by\n    calc\n      \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin n, X i * Y i) + \u2016Y\u2016 ^ 2 := by\n        rw [h_l1]\n      _ \u2264 \u2016X\u2016 ^ 2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016 ^ 2 := by\n        -- Use the fact that 2 * (\u2211 i, X i * Y i) \u2264 2 * (\u2016X\u2016 * \u2016Y\u2016) to bound the middle term\n        have h\u2083 : 2 * (\u2211 i : Fin n, X i * Y i) \u2264 2 * (\u2016X\u2016 * \u2016Y\u2016) := h_two_sum_le\n        -- Add the inequalities to get the final bound\n        nlinarith [norm_nonneg X, norm_nonneg Y]\n      _ = \u2016X\u2016 ^ 2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016 ^ 2 := by ring\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Vector declarations are correctly represented using Fin n \u2192 \u211d notation", "Cauchy-Schwarz inequality is accurately formalized with proper dot product and norm representations", "The norm expansion formula l1 is perfectly captured with consistent notation", "The conclusion l2 maintains exact correspondence with the natural language statement", "The overall logical structure and mathematical reasoning flow are preserved correctly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "\\ar=(|\\mathbf{X}|+|\\mathbf{Y}|)^2.", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 For any two vectors $\\mathbf{X}, \\mathbf{Y} \\in \\R^n$, we have the Cauchy-Schwarz inequality $|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$ [tc_2].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2$ [l1].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2$ [l2].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2 = (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (h_l2 : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2) :\n  \u2016X + Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (h_l2 : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2) :\n  \u2016X + Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n  have h_main : \u2016X + Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n    cases n with\n    | zero =>\n      -- For n = 0, Fin 0 is empty and all functions are equal to the zero function.\n      have hX : X = 0 := by\n        ext i\n        exact Fin.elim0 i\n      have hY : Y = 0 := by\n        ext i\n        exact Fin.elim0 i\n      simp [hX, hY, norm_zero] at h_cschwarz h_l1 h_l2 \u22a2\n      <;> norm_num\n    | succ n =>\n      -- For n > 0, we cannot prove the statement in general.\n      -- However, perhaps we can try to prove it under the assumption that \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016.\n      -- But since this is not given, we cannot proceed.\n      have h\u2083 : \u2016X + Y\u2016 ^ 2 = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n        have h\u2084 : \u2016X + Y\u2016 ^ 2 \u2264 (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n          calc\n            \u2016X + Y\u2016 ^ 2 \u2264 \u2016X\u2016 ^ 2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016 ^ 2 := by\n              simpa [add_sq] using h_l2\n            _ = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n              ring\n        have h\u2085 : (\u2016X\u2016 + \u2016Y\u2016) ^ 2 \u2264 \u2016X + Y\u2016 ^ 2 := by\n          -- We need to show that (\u2016X\u2016 + \u2016Y\u2016)^2 \u2264 \u2016X + Y\u2016^2\n          -- This is not always true, so we need to find a contradiction or another approach\n          have h\u2086 : \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin (n + 1), X i * Y i) + \u2016Y\u2016 ^ 2 := by\n            simpa using h_l1\n          have h\u2087 : (\u2211 i : Fin (n + 1), X i * Y i) \u2265 \u2016X\u2016 * \u2016Y\u2016 := by\n            -- This is not always true, but we can try to use the given inequalities\n            -- to find that (\u2211 i, X i * Y i) \u2265 \u2016X\u2016 * \u2016Y\u2016\n            by_contra h\n            have h\u2088 : (\u2211 i : Fin (n + 1), X i * Y i) < \u2016X\u2016 * \u2016Y\u2016 := by linarith\n            have h\u2089 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n              calc\n                \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin (n + 1), X i * Y i) + \u2016Y\u2016 ^ 2 := by simpa using h_l1\n                _ < \u2016X\u2016 ^ 2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016 ^ 2 := by\n                  nlinarith [norm_nonneg X, norm_nonneg Y]\n                _ = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by ring\n            have h\u2081\u2080 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016 := by\n              nlinarith [norm_nonneg (X + Y), norm_nonneg X, norm_nonneg Y]\n            have h\u2081\u2081 : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := norm_add_le X Y\n            linarith\n          calc\n            (\u2016X\u2016 + \u2016Y\u2016) ^ 2 = \u2016X\u2016 ^ 2 + 2 * (\u2016X\u2016 * \u2016Y\u2016) + \u2016Y\u2016 ^ 2 := by ring\n            _ \u2264 \u2016X\u2016 ^ 2 + 2 * (\u2211 i : Fin (n + 1), X i * Y i) + \u2016Y\u2016 ^ 2 := by\n              -- Use the fact that (\u2211 i, X i * Y i) \u2265 \u2016X\u2016 * \u2016Y\u2016\n              nlinarith [h\u2087]\n            _ = \u2016X + Y\u2016 ^ 2 := by\n              -- Use the given identity for \u2016X + Y\u2016 ^ 2\n              rw [h\u2086]\n              <;> ring\n        -- Combine the two inequalities to get the desired equality\n        linarith\n      exact h\u2083\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 53, "column": 12, "endLine": 53, "endColumn": 20, "data": "linarith failed to find a contradiction\nn : \u2115\nX Y : Fin (n + 1) \u2192 \u211d\nh_cschwarz : |\u2211 i : Fin (n + 1), X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016\nh_l1 : \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * \u2211 i : Fin (n + 1), X i * Y i + \u2016Y\u2016 ^ 2\nh_l2 : \u2016X + Y\u2016 ^ 2 \u2264 \u2016X\u2016 ^ 2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016 ^ 2\nh\u2084 : \u2016X + Y\u2016 ^ 2 \u2264 (\u2016X\u2016 + \u2016Y\u2016) ^ 2\nh\u2086 : \u2016X + Y\u2016 ^ 2 = \u2016X\u2016 ^ 2 + 2 * \u2211 i : Fin (n + 1), X i * Y i + \u2016Y\u2016 ^ 2\nh : \u00ac\u2211 i : Fin (n + 1), X i * Y i \u2265 \u2016X\u2016 * \u2016Y\u2016\nh\u2088 : \u2211 i : Fin (n + 1), X i * Y i < \u2016X\u2016 * \u2016Y\u2016\nh\u2089 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2\nh\u2081\u2080 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016\nh\u2081\u2081 : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Vector type representation correctly captures vectors in \u211d\u207f using Lean's standard Fin n \u2192 \u211d notation.", "Cauchy-Schwarz inequality is correctly formalized with proper dot product and norm representations.", "The expansion formula l1 correctly translates the norm squared expansion with appropriate dot product notation.", "The inequality l2 is correctly formalized matching the natural language statement.", "Major inconsistency: The natural language l3 states an algebraic identity |X|\u00b2 + 2|X||Y| + |Y|\u00b2 = (|X| + |Y|)\u00b2, but the Lean formalization states \u2016X + Y\u2016\u00b2 = (\u2016X\u2016 + \u2016Y\u2016)\u00b2, which is the triangle inequality as equality. These are fundamentally different mathematical statements.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"Vector type representation correctly captures vectors in \u211d\u207f using Lean's standard Fin n \u2192 \u211d notation.\", 'Cauchy-Schwarz inequality is correctly formalized with proper dot product and norm representations.', 'The expansion formula l1 correctly translates the norm squared expansion with appropriate dot product notation.', 'The inequality l2 is correctly formalized matching the natural language statement.', 'Major inconsistency: The natural language l3 states an algebraic identity |X|\u00b2 + 2|X||Y| + |Y|\u00b2 = (|X| + |Y|)\u00b2, but the Lean formalization states \u2016X + Y\u2016\u00b2 = (\u2016X\u2016 + \u2016Y\u2016)\u00b2, which is the triangle inequality as equality. These are fundamentally different mathematical statements.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Hence,\n$$\n|\\mathbf{X}+\\mathbf{Y}|^2\\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2.\n$$", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 For any two vectors $\\mathbf{X}, \\mathbf{Y} \\in \\R^n$, we have the Cauchy-Schwarz inequality $|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$ [tc_2].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2$ [l1].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2$ [l2].\n\u2022 $|\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2 = (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l3].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (h_l2 : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2)\n  (h_l3 : \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (h_l2 : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2)\n  (h_l3 : \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n  have h_main : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n    calc\n      \u2016X + Y\u2016 ^ 2 \u2264 \u2016X\u2016 ^ 2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016 ^ 2 := h_l2\n      _ = (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n        rw [h_l3]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Vector declarations correctly use Lean's function type notation (Fin n \u2192 \u211d) to represent vectors in \u211d\u207f", "Cauchy-Schwarz inequality correctly represents dot product as sum and uses proper norm notation", "Expansion formula correctly captures the algebraic identity with proper Lean syntax", "Inequality step correctly translates the mathematical inequality", "Algebraic identity correctly represents the perfect square expansion", "Final conclusion correctly captures the triangle inequality in squared form"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Taking square roots yields \\eqref{eq:5.1.6}.", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 For any two vectors $\\mathbf{X}, \\mathbf{Y} \\in \\R^n$, we have the Cauchy-Schwarz inequality $|\\mathbf{X}\\cdot\\mathbf{Y}|\\le |\\mathbf{X}|\\,|\\mathbf{Y}|$ [tc_2].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}|^2 \\le (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l4].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (h_l2 : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2)\n  (h_l3 : \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2)\n  (h_l4 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l1 : \u2016X + Y\u2016^2 = \u2016X\u2016^2 + 2 * (\u2211 i, X i * Y i) + \u2016Y\u2016^2)\n  (h_l2 : \u2016X + Y\u2016^2 \u2264 \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2)\n  (h_l3 : \u2016X\u2016^2 + 2 * \u2016X\u2016 * \u2016Y\u2016 + \u2016Y\u2016^2 = (\u2016X\u2016 + \u2016Y\u2016)^2)\n  (h_l4 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2) :\n  \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n  have h_nonneg_a : 0 \u2264 \u2016X + Y\u2016 := by\n    exact norm_nonneg _\n  \n  have h_nonneg_b : 0 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n    have h\u2081 : 0 \u2264 \u2016X\u2016 := norm_nonneg X\n    have h\u2082 : 0 \u2264 \u2016Y\u2016 := norm_nonneg Y\n    linarith\n  \n  have h_product_nonpos : (\u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016)) * (\u2016X + Y\u2016 + (\u2016X\u2016 + \u2016Y\u2016)) \u2264 0 := by\n    have h\u2081 : (\u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016)) * (\u2016X + Y\u2016 + (\u2016X\u2016 + \u2016Y\u2016)) = \u2016X + Y\u2016^2 - (\u2016X\u2016 + \u2016Y\u2016)^2 := by\n      ring_nf\n      <;>\n      (try\n        {\n          simp [sq, mul_assoc]\n          <;>\n          ring_nf\n          <;>\n          linarith\n        })\n      <;>\n      (try\n        {\n          nlinarith\n        })\n    rw [h\u2081]\n    have h\u2082 : \u2016X + Y\u2016^2 \u2264 (\u2016X\u2016 + \u2016Y\u2016)^2 := h_l4\n    linarith\n  \n  have h_sum_nonneg : 0 \u2264 \u2016X + Y\u2016 + (\u2016X\u2016 + \u2016Y\u2016) := by\n    have h\u2081 : 0 \u2264 \u2016X + Y\u2016 := h_nonneg_a\n    have h\u2082 : 0 \u2264 \u2016X\u2016 + \u2016Y\u2016 := h_nonneg_b\n    linarith\n  \n  have h_diff_nonpos : \u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016) \u2264 0 := by\n    by_contra h\n    have h\u2081 : \u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016) > 0 := by linarith\n    have h\u2082 : (\u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016)) * (\u2016X + Y\u2016 + (\u2016X\u2016 + \u2016Y\u2016)) > 0 := by\n      have h\u2083 : 0 < \u2016X + Y\u2016 - (\u2016X\u2016 + \u2016Y\u2016) := by linarith\n      have h\u2084 : 0 \u2264 \u2016X + Y\u2016 + (\u2016X\u2016 + \u2016Y\u2016) := h_sum_nonneg\n      nlinarith\n    linarith\n  \n  have h_final : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The vectors are properly represented as functions from Fin n to \u211d, the Cauchy-Schwarz inequality is correctly stated with proper dot product and norm notation, and the triangle inequality (both squared and final forms) are accurately formalized. The additional hypotheses h_l1, h_l2, and h_l3 represent valid intermediate steps in the mathematical derivation and do not contradict the natural language - they provide the logical bridge from the squared inequality to the final conclusion. The use of \u2016\u00b7\u2016 for vector norms versus |\u00b7| for absolute values is mathematically more precise than the natural language notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "l5": {"id": "l5", "natural_language": "From the third line of \\eqref{eq:5.1.7}, equality holds in \\eqref{eq:5.1.6} if and only if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$,", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1].\n\u2022 The derivation of [ts_1] involved the series of (in)equalities: $|\\mathbf{X}+\\mathbf{Y}|^2 = |\\mathbf{X}|^2+2(\\mathbf{X}\\cdot\\mathbf{Y})+|\\mathbf{Y}|^2 \\le |\\mathbf{X}|^2+2|\\mathbf{X}|\\,|\\mathbf{Y}|+|\\mathbf{Y}|^2 = (|\\mathbf{X}|+|\\mathbf{Y}|)^2$ [l1, l2, l3].\nTherefore, we conclude:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1] if and only if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}|\\,|\\mathbf{Y}|$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016) :\n  (\u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016) :\n  (\u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) := by\n  have h_imp : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2192 \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n    intro h\n    have h\u2081 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n      by_contra h\u2081\n      -- Use the fact that if the sum is not equal to the product of norms, then we derive a contradiction\n      have h\u2082 : \u2211 i : Fin n, X i * Y i < \u2016X\u2016 * \u2016Y\u2016 \u2228 \u2211 i : Fin n, X i * Y i > \u2016X\u2016 * \u2016Y\u2016 := by\n        cases' lt_or_gt_of_ne h\u2081 with h\u2082 h\u2082\n        \u00b7 exact Or.inl h\u2082\n        \u00b7 exact Or.inr h\u2082\n      cases' h\u2082 with h\u2082 h\u2082\n      \u00b7 -- Case: sum < product of norms\n        have h\u2083 : \u2211 i : Fin n, X i * Y i < \u2016X\u2016 * \u2016Y\u2016 := h\u2082\n        have h\u2084 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016 := by\n          -- Use the fact that the square of the norm is less than the square of the sum of norms\n          have h\u2085 : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := norm_add_le X Y\n          have h\u2086 : \u2016X + Y\u2016 \u2260 \u2016X\u2016 + \u2016Y\u2016 := by\n            intro h\u2087\n            have h\u2088 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := h\u2087\n            have h\u2089 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n              -- This is a contradiction because we assumed the sum is not equal to the product of norms\n              exfalso\n              linarith\n            contradiction\n          -- Use the fact that the square of the norm is less than the square of the sum of norms\n          have h\u2087 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016 := by\n            contrapose! h\u2086\n            linarith\n          exact h\u2087\n        linarith\n      \u00b7 -- Case: sum > product of norms\n        have h\u2083 : \u2211 i : Fin n, X i * Y i > \u2016X\u2016 * \u2016Y\u2016 := h\u2082\n        have h\u2084 : |\u2211 i : Fin n, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016 := h_cschwarz\n        have h\u2085 : \u2211 i : Fin n, X i * Y i \u2264 \u2016X\u2016 * \u2016Y\u2016 := by\n          -- Use the fact that the absolute value of the sum is less than or equal to the product of norms\n          have h\u2086 : \u2211 i : Fin n, X i * Y i \u2264 |\u2211 i : Fin n, X i * Y i| := by\n            exact le_abs_self _\n          linarith\n        linarith\n    exact h\u2081\n  \n  have h_converse : (\u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) \u2192 \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n    intro h_sum_eq\n    have h\u2081 : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by\n      -- Apply the triangle inequality to get the upper bound\n      exact norm_add_le X Y\n    have h\u2082 : \u2016X + Y\u2016 \u2265 \u2016X\u2016 + \u2016Y\u2016 := by\n      -- Use the given condition to show the lower bound\n      by_contra h\u2083\n      -- Assume for contradiction that \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016\n      have h\u2084 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016 := by linarith\n      -- Use the fact that the square of the norm is less than the square of the sum of norms\n      have h\u2085 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := by\n        have h\u2085\u2081 : 0 \u2264 \u2016X + Y\u2016 := norm_nonneg (X + Y)\n        have h\u2085\u2082 : 0 \u2264 \u2016X\u2016 + \u2016Y\u2016 := by positivity\n        nlinarith [h\u2084]\n      -- Use the given condition to derive a contradiction\n      have h\u2086 : |\u2211 i : Fin n, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016 := h_cschwarz\n      have h\u2087 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_sum_eq\n      have h\u2088 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n      -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n      have h\u2089 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n      have h\u2081\u2080 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n      -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n      have h\u2081\u2081 : False := by\n        -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n        have h\u2081\u2082 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n        have h\u2081\u2083 : 0 \u2264 \u2016X\u2016 := norm_nonneg X\n        have h\u2081\u2084 : 0 \u2264 \u2016Y\u2016 := norm_nonneg Y\n        have h\u2081\u2085 : 0 \u2264 \u2016X\u2016 * \u2016Y\u2016 := by positivity\n        -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n        have h\u2081\u2086 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n        -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n        have h\u2081\u2087 : False := by\n          -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n          exfalso\n          -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n          have h\u2081\u2088 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n          have h\u2081\u2089 : 0 \u2264 \u2016X\u2016 := norm_nonneg X\n          have h\u2082\u2080 : 0 \u2264 \u2016Y\u2016 := norm_nonneg Y\n          have h\u2082\u2081 : 0 \u2264 \u2016X\u2016 * \u2016Y\u2016 := by positivity\n          -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n          have h\u2082\u2082 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2 := h\u2085\n          have h\u2082\u2083 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_sum_eq\n          have h\u2082\u2084 : |\u2211 i : Fin n, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016 := h_cschwarz\n          -- Use the fact that the square of the norm is less than the square of the sum of norms to derive a contradiction\n          cases' le_total 0 (\u2211 i : Fin n, X i * Y i) with h\u2082\u2085 h\u2082\u2085 <;>\n            simp_all [abs_of_nonneg, abs_of_nonpos, le_of_lt] <;>\n            nlinarith [sq_nonneg (\u2016X\u2016 - \u2016Y\u2016)]\n        exact h\u2081\u2087\n      exact h\u2081\u2081\n    -- Combine the upper and lower bounds to get the equality\n    linarith\n  \n  have h_main : (\u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) := by\n    constructor\n    \u00b7 -- Prove the forward direction: if \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016, then \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016\n      intro h\n      exact h_imp h\n    \u00b7 -- Prove the reverse direction: if \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016, then \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016\n      intro h\n      exact h_converse h\n  \n  simpa using h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 30, "column": 14, "endLine": 30, "endColumn": 22, "data": "linarith failed to find a contradiction\nn : \u2115\nX Y : Fin n \u2192 \u211d\nh_cschwarz : |\u2211 i : Fin n, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016\nh : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016\nh\u2081 : \u00ac\u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016\nh\u2082 h\u2083 : \u2211 i : Fin n, X i * Y i < \u2016X\u2016 * \u2016Y\u2016\nh\u2085 : \u2016X + Y\u2016 \u2264 \u2016X\u2016 + \u2016Y\u2016\nh\u2087 h\u2088 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016\n\u22a2 False failed"}, {"line": 96, "column": 12, "endLine": 96, "endColumn": 45, "data": "linarith failed to find a contradiction\ncase inl\nn : \u2115\nX Y : Fin n \u2192 \u211d\nh\u2084 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016\nh\u2082\u2081 : 0 \u2264 \u2016X\u2016 * \u2016Y\u2016\nh\u2082\u2082 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2\nh\u2082\u2083 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016\n\u22a2 False failed"}, {"line": 96, "column": 12, "endLine": 96, "endColumn": 45, "data": "linarith failed to find a contradiction\ncase inr\nn : \u2115\nX Y : Fin n \u2192 \u211d\nh\u2084 : \u2016X + Y\u2016 < \u2016X\u2016 + \u2016Y\u2016\nh\u2082\u2081 : 0 \u2264 \u2016X\u2016 * \u2016Y\u2016\nh\u2082\u2082 : \u2016X + Y\u2016 ^ 2 < (\u2016X\u2016 + \u2016Y\u2016) ^ 2\nh\u2082\u2083 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016\nh\u2082\u2085 : \u2016X\u2016 * \u2016Y\u2016 \u2264 0\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Vector representation in \u211d\u207f is correctly captured using Fin n \u2192 \u211d", "The triangle inequality is implicitly available in Mathlib, though not explicitly stated as assumption", "The derivation steps are not explicitly shown in the Lean code, but this is acceptable since they would be part of the proof", "Cauchy-Schwarz inequality is correctly stated as a hypothesis", "The main conclusion captures the right logical structure, but there's a subtle issue with the condition - the natural language suggests X\u00b7Y = |X||Y| (without absolute value on dot product), while the Lean version uses the same but the relationship with the Cauchy-Schwarz hypothesis could be clearer", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['Vector representation in \u211d\u207f is correctly captured using Fin n \u2192 \u211d', 'The triangle inequality is implicitly available in Mathlib, though not explicitly stated as assumption', 'The derivation steps are not explicitly shown in the Lean code, but this is acceptable since they would be part of the proof', 'Cauchy-Schwarz inequality is correctly stated as a hypothesis', \"The main conclusion captures the right logical structure, but there's a subtle issue with the condition - the natural language suggests X\u00b7Y = |X||Y| (without absolute value on dot product), while the Lean version uses the same but the relationship with the Cauchy-Schwarz hypothesis could be clearer\"]"}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "equality holds in \\eqref{eq:5.1.6} if and\nonly  if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$, which is true if\nand\nonly if one of the vectors $\\mathbf{X}$ and $\\mathbf{Y}$ is a nonnegative\nscalar multiple of the other (Lemma~\\ref{thmtype:5.1.5}).", "statement": "We assume:\n\u2022 $\\mathbf{X}$ and $\\mathbf{Y}$ are vectors in $\\R^n$ [tc_1].\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1] if and only if $\\mathbf{X}\\cdot\\mathbf{Y}=|\\mathbf{X}||\\mathbf{Y}|$ [l5].\nTherefore, we conclude:\n\u2022 Equality holds in $|\\mathbf{X}+\\mathbf{Y}| \\le |\\mathbf{X}|+|\\mathbf{Y}|$ [ts_1] if and only if one of $\\mathbf{X}$ or $\\mathbf{Y}$ is a non-negative multiple of the other [ts_2].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "ts_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l5 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) :\n  \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n  (\u2203 c : \u211d, c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l5 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) :\n  \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n  (\u2203 c : \u211d, c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X)) := by\n  have h_main : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 (\u2203 c : \u211d, c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X)) := by\n    constructor\n    \u00b7 -- Forward direction: \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2192 \u2203 c \u2265 0, (X = c \u2022 Y \u2228 Y = c \u2022 X)\n      intro h\n      have h\u2081 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n        have h\u2082 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := h\n        have h\u2083 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_l5\n        have h\u2084 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n          have h\u2085 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := h\u2082\n          have h\u2086 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_l5\n          simp_all [Finset.sum_range_succ, Finset.sum_range_zero]\n          <;>\n          (try norm_num) <;>\n          (try linarith) <;>\n          (try simp_all [Real.norm_eq_abs, abs_mul, abs_of_nonneg, abs_of_nonpos, mul_comm]) <;>\n          (try nlinarith)\n        exact h\u2084\n      -- Case when X = 0\n      by_cases hX : X = 0\n      \u00b7 -- If X = 0, then X = 0 \u2022 Y\n        refine' \u27e80, by norm_num, _\u27e9\n        exact Or.inl (by simp [hX])\n      \u00b7 -- Case when X \u2260 0\n        by_cases hY : Y = 0\n        \u00b7 -- If Y = 0, then Y = 0 \u2022 X\n          refine' \u27e80, by norm_num, _\u27e9\n          exact Or.inr (by simp [hY])\n        \u00b7 -- Neither X nor Y is zero\n          have hX' : \u2016X\u2016 > 0 := by\n            have hX'' : X \u2260 0 := hX\n            have hX''' : \u2016X\u2016 > 0 := by\n              apply norm_pos_iff.mpr\n              exact hX''\n            exact hX'''\n          have hY' : \u2016Y\u2016 > 0 := by\n            have hY'' : Y \u2260 0 := hY\n            have hY''' : \u2016Y\u2016 > 0 := by\n              apply norm_pos_iff.mpr\n              exact hY''\n            exact hY'''\n          -- Use the identity to show that Y is a scalar multiple of X\n          have h\u2082 : \u2200 i : Fin n, \u2016Y\u2016 * X i = \u2016X\u2016 * Y i := by\n            intro i\n            have h\u2083 : \u2211 i : Fin n, (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 = 0 := by\n              have h\u2084 : \u2211 i : Fin n, (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 = 2 * \u2016X\u2016 ^ 2 * \u2016Y\u2016 ^ 2 - 2 * \u2016X\u2016 * \u2016Y\u2016 * (\u2211 i : Fin n, X i * Y i) := by\n                calc\n                  \u2211 i : Fin n, (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 = \u2211 i : Fin n, (\u2016Y\u2016 ^ 2 * X i ^ 2 + \u2016X\u2016 ^ 2 * Y i ^ 2 - 2 * \u2016Y\u2016 * \u2016X\u2016 * (X i * Y i)) := by\n                    apply Finset.sum_congr rfl\n                    intro i _\n                    ring_nf\n                    <;>\n                    simp [sq, mul_assoc, mul_comm, mul_left_comm]\n                    <;>\n                    ring_nf\n                  _ = \u2211 i : Fin n, (\u2016Y\u2016 ^ 2 * X i ^ 2 + \u2016X\u2016 ^ 2 * Y i ^ 2) - \u2211 i : Fin n, (2 * \u2016Y\u2016 * \u2016X\u2016 * (X i * Y i)) := by\n                    simp [Finset.sum_sub_distrib]\n                  _ = (\u2211 i : Fin n, (\u2016Y\u2016 ^ 2 * X i ^ 2) + \u2211 i : Fin n, (\u2016X\u2016 ^ 2 * Y i ^ 2)) - \u2211 i : Fin n, (2 * \u2016Y\u2016 * \u2016X\u2016 * (X i * Y i)) := by\n                    simp [Finset.sum_add_distrib]\n                  _ = (\u2016Y\u2016 ^ 2 * \u2211 i : Fin n, X i ^ 2 + \u2016X\u2016 ^ 2 * \u2211 i : Fin n, Y i ^ 2) - 2 * \u2016Y\u2016 * \u2016X\u2016 * \u2211 i : Fin n, (X i * Y i) := by\n                    simp [Finset.mul_sum, Finset.sum_mul, mul_assoc, mul_comm, mul_left_comm]\n                    <;>\n                    ring_nf\n                  _ = (\u2016Y\u2016 ^ 2 * \u2016X\u2016 ^ 2 + \u2016X\u2016 ^ 2 * \u2016Y\u2016 ^ 2) - 2 * \u2016Y\u2016 * \u2016X\u2016 * \u2211 i : Fin n, (X i * Y i) := by\n                    have h\u2085 : \u2016X\u2016 ^ 2 = \u2211 i : Fin n, X i ^ 2 := by\n                      simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg,\n                        Finset.sum_nonneg]\n                      <;>\n                      ring_nf\n                      <;>\n                      field_simp [Real.sqrt_eq_iff_sq_eq]\n                      <;>\n                      nlinarith\n                    have h\u2086 : \u2016Y\u2016 ^ 2 = \u2211 i : Fin n, Y i ^ 2 := by\n                      simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg,\n                        Finset.sum_nonneg]\n                      <;>\n                      ring_nf\n                      <;>\n                      field_simp [Real.sqrt_eq_iff_sq_eq]\n                      <;>\n                      nlinarith\n                    rw [h\u2085, h\u2086]\n                    <;>\n                    ring_nf\n                    <;>\n                    nlinarith\n                  _ = 2 * \u2016X\u2016 ^ 2 * \u2016Y\u2016 ^ 2 - 2 * \u2016X\u2016 * \u2016Y\u2016 * (\u2211 i : Fin n, X i * Y i) := by\n                    ring_nf\n                    <;>\n                    nlinarith\n              have h\u2085 : 2 * \u2016X\u2016 ^ 2 * \u2016Y\u2016 ^ 2 - 2 * \u2016X\u2016 * \u2016Y\u2016 * (\u2211 i : Fin n, X i * Y i) = 0 := by\n                rw [h\u2081]\n                <;>\n                ring_nf\n                <;>\n                nlinarith [sq_nonneg (\u2016X\u2016 - \u2016Y\u2016)]\n              linarith\n            have h\u2084 : (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 = 0 := by\n              have h\u2085 : \u2211 i : Fin n, (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 = 0 := h\u2083\n              have h\u2086 : (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 \u2265 0 := by positivity\n              have h\u2087 : (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 \u2264 0 := by\n                have h\u2088 : \u2211 i : Fin n, (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 = 0 := h\u2083\n                have h\u2089 : (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 \u2264 \u2211 i : Fin n, (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i) ^ 2 := by\n                  exact Finset.single_le_sum (fun i _ => sq_nonneg (\u2016Y\u2016 * X i - \u2016X\u2016 * Y i)) (Finset.mem_univ i)\n                linarith\n              linarith\n            have h\u2085 : \u2016Y\u2016 * X i - \u2016X\u2016 * Y i = 0 := by\n              nlinarith\n            linarith\n          -- Deduce that Y is a scalar multiple of X\n          have h\u2083 : Y = (\u2016Y\u2016 / \u2016X\u2016) \u2022 X := by\n            ext i\n            have h\u2084 := h\u2082 i\n            have h\u2085 : \u2016Y\u2016 * X i = \u2016X\u2016 * Y i := h\u2084\n            have h\u2086 : Y i = (\u2016Y\u2016 / \u2016X\u2016) * X i := by\n              have h\u2087 : \u2016X\u2016 \u2260 0 := by linarith\n              field_simp [h\u2087] at h\u2085 \u22a2\n              <;>\n              nlinarith\n            simp [h\u2086, smul_eq_mul]\n            <;>\n            ring_nf\n            <;>\n            field_simp [hX']\n            <;>\n            nlinarith\n          -- Show that the scalar is non-negative\n          have h\u2084 : \u2016Y\u2016 / \u2016X\u2016 \u2265 0 := by\n            have h\u2085 : \u2016Y\u2016 \u2265 0 := norm_nonneg Y\n            have h\u2086 : \u2016X\u2016 > 0 := hX'\n            positivity\n          -- Conclude the existence of c\n          refine' \u27e8\u2016Y\u2016 / \u2016X\u2016, h\u2084, _\u27e9\n          exact Or.inr (by simpa [h\u2083] using h\u2083)\n    \u00b7 -- Backward direction: \u2203 c \u2265 0, (X = c \u2022 Y \u2228 Y = c \u2022 X) \u2192 \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016\n      intro h\n      rcases h with \u27e8c, hc, hXY\u27e9\n      have h\u2081 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n        cases hXY with\n        | inl hXY =>\n          -- Case X = c \u2022 Y\n          have h\u2082 : X = c \u2022 Y := hXY\n          calc\n            \u2211 i : Fin n, X i * Y i = \u2211 i : Fin n, (c \u2022 Y) i * Y i := by rw [h\u2082]\n            _ = \u2211 i : Fin n, (c * Y i) * Y i := by\n              simp [Pi.smul_apply]\n            _ = \u2211 i : Fin n, c * (Y i * Y i) := by\n              apply Finset.sum_congr rfl\n              intro i _\n              ring\n            _ = c * \u2211 i : Fin n, (Y i * Y i) := by\n              simp [Finset.mul_sum]\n            _ = c * \u2211 i : Fin n, Y i ^ 2 := by\n              apply congr_arg (fun x => c * x)\n              apply Finset.sum_congr rfl\n              intro i _\n              ring\n            _ = c * \u2016Y\u2016 ^ 2 := by\n              have h\u2083 : \u2016Y\u2016 ^ 2 = \u2211 i : Fin n, Y i ^ 2 := by\n                simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg,\n                  Finset.sum_nonneg]\n                <;>\n                ring_nf\n                <;>\n                field_simp [Real.sqrt_eq_iff_sq_eq]\n                <;>\n                nlinarith\n              rw [h\u2083]\n              <;>\n              ring\n            _ = \u2016X\u2016 * \u2016Y\u2016 := by\n              have h\u2083 : \u2016X\u2016 = |c| * \u2016Y\u2016 := by\n                calc\n                  \u2016X\u2016 = \u2016c \u2022 Y\u2016 := by rw [h\u2082]\n                  _ = |c| * \u2016Y\u2016 := by simp [norm_smul, Real.norm_eq_abs]\n              have h\u2084 : c \u2265 0 := hc\n              have h\u2085 : |c| = c := by\n                rw [abs_of_nonneg h\u2084]\n              rw [h\u2083, h\u2085]\n              <;>\n              ring_nf\n              <;>\n              cases' le_or_lt 0 c with h\u2086 h\u2086 <;>\n              simp_all [abs_of_nonneg, abs_of_neg, le_of_lt]\n              <;>\n              nlinarith\n        | inr hXY =>\n          -- Case Y = c \u2022 X\n          have h\u2082 : Y = c \u2022 X := hXY\n          calc\n            \u2211 i : Fin n, X i * Y i = \u2211 i : Fin n, X i * (c \u2022 X) i := by rw [h\u2082]\n            _ = \u2211 i : Fin n, X i * (c * X i) := by\n              simp [Pi.smul_apply]\n            _ = \u2211 i : Fin n, c * (X i * X i) := by\n              apply Finset.sum_congr rfl\n              intro i _\n              ring\n            _ = c * \u2211 i : Fin n, (X i * X i) := by\n              simp [Finset.mul_sum]\n            _ = c * \u2211 i : Fin n, X i ^ 2 := by\n              apply congr_arg (fun x => c * x)\n              apply Finset.sum_congr rfl\n              intro i _\n              ring\n            _ = c * \u2016X\u2016 ^ 2 := by\n              have h\u2083 : \u2016X\u2016 ^ 2 = \u2211 i : Fin n, X i ^ 2 := by\n                simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg,\n                  Finset.sum_nonneg]\n                <;>\n                ring_nf\n                <;>\n                field_simp [Real.sqrt_eq_iff_sq_eq]\n                <;>\n                nlinarith\n              rw [h\u2083]\n              <;>\n              ring\n            _ = \u2016X\u2016 * \u2016Y\u2016 := by\n              have h\u2083 : \u2016Y\u2016 = |c| * \u2016X\u2016 := by\n                calc\n                  \u2016Y\u2016 = \u2016c \u2022 X\u2016 := by rw [h\u2082]\n                  _ = |c| * \u2016X\u2016 := by simp [norm_smul, Real.norm_eq_abs]\n              have h\u2084 : c \u2265 0 := hc\n              have h\u2085 : |c| = c := by\n                rw [abs_of_nonneg h\u2084]\n              rw [h\u2083, h\u2085]\n              <;>\n              ring_nf\n              <;>\n              cases' le_or_lt 0 c with h\u2086 h\u2086 <;>\n              simp_all [abs_of_nonneg, abs_of_neg, le_of_lt]\n              <;>\n              nlinarith\n      -- Use h_l5 to conclude \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016\n      have h\u2082 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n        have h\u2083 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_l5\n        have h\u2084 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h\u2081\n        have h\u2085 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n          have h\u2086 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h\u2084\n          have h\u2087 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_l5\n          have h\u2088 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n            simp_all [Finset.sum_range_succ, Finset.sum_range_zero]\n            <;>\n            (try norm_num) <;>\n            (try linarith) <;>\n            (try simp_all [Real.norm_eq_abs, abs_mul, abs_of_nonneg, abs_of_nonpos, mul_comm]) <;>\n            (try nlinarith)\n          exact h\u2088\n        exact h\u2085\n      exact h\u2082\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 75, "column": 22, "endLine": 76, "endColumn": 42, "data": "simp made no progress"}, {"line": 84, "column": 22, "endLine": 85, "endColumn": 42, "data": "simp made no progress"}, {"line": 144, "column": 27, "endLine": 144, "endColumn": 46, "data": "tactic 'simp' failed, nested error:\nmaximum recursion depth has been reached\nuse `set_option maxRecDepth <num>` to increase limit\nuse `set_option diagnostics true` to get diagnostic information"}, {"line": 170, "column": 16, "endLine": 171, "endColumn": 36, "data": "simp made no progress"}, {"line": 217, "column": 16, "endLine": 218, "endColumn": 36, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Vector representation using Fin n \u2192 \u211d correctly captures vectors in \u211d\u207f", "The triangle inequality equality condition is correctly formalized with proper dot product and norm representations", "The main biconditional conclusion about non-negative multiples is accurately captured", "The additional Cauchy-Schwarz inequality assumption is mathematically consistent and likely necessary for the proof, representing acceptable extra detail", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_2 \n  (n : \u2115) \n  (X Y : Fin n \u2192 \u211d)\n  (h_cschwarz : |\u2211 i, X i * Y i| \u2264 \u2016X\u2016 * \u2016Y\u2016)\n  (h_l5 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i, X i * Y i = \u2016X\u2016 * \u2016Y\u2016) :\n  \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \n  (\u2203 c : \u211d, c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X)) := by\n  have h_forward : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2192 (\u2203 c : \u211d, c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X)) := by\n    intro h\n    have h1 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n      have h2 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := h\n      have h3 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 \u2194 \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h_l5\n      have h4 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := by\n        rw [h3] at h2\n        exact h2\n      exact h4\n    -- Case when X = 0\n    by_cases hX : X = 0\n    \u00b7 -- If X = 0, take c = 0\n      refine' \u27e80, by norm_num, _\u27e9\n      -- We need to show that X = 0 \u2022 Y or Y = 0 \u2022 X\n      -- Since X = 0, we have X = 0 \u2022 Y\n      exact Or.inl (by simp [hX])\n    \u00b7 -- Case when X \u2260 0\n      by_cases hY : Y = 0\n      \u00b7 -- If Y = 0, take c = 0\n        refine' \u27e80, by norm_num, _\u27e9\n        -- We need to show that X = 0 \u2022 Y or Y = 0 \u2022 X\n        -- Since Y = 0, we have Y = 0 \u2022 X\n        exact Or.inr (by simp [hY])\n      \u00b7 -- Case when X \u2260 0 and Y \u2260 0\n        -- Use the fact that the sum of products equals the product of norms to find a scalar c\n        have h2 : \u2203 (c : \u211d), c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X) := by\n          -- Use the fact that the vectors are linearly dependent\n          have h3 : 0 < \u2016X\u2016 := by\n            have h4 : X \u2260 0 := hX\n            exact norm_pos_iff.mpr h4\n          have h4 : 0 < \u2016Y\u2016 := by\n            have h5 : Y \u2260 0 := hY\n            exact norm_pos_iff.mpr h5\n          -- Use the fact that the vectors are linearly dependent\n          have h5 : Y = (\u2016Y\u2016 / \u2016X\u2016) \u2022 X := by\n            -- Use the fact that the vectors are linearly dependent\n            have h6 : \u2211 i : Fin n, X i * Y i = \u2016X\u2016 * \u2016Y\u2016 := h1\n            have h7 : \u2016X\u2016 > 0 := h3\n            have h8 : \u2016Y\u2016 > 0 := h4\n            -- Use the fact that the vectors are linearly dependent\n            have h9 : \u2200 i : Fin n, Y i = (\u2016Y\u2016 / \u2016X\u2016) * X i := by\n              intro i\n              have h10 : (\u2211 i : Fin n, X i * Y i) ^ 2 = (\u2211 i : Fin n, X i ^ 2) * \u2211 i : Fin n, Y i ^ 2 := by\n                calc\n                  (\u2211 i : Fin n, X i * Y i) ^ 2 = (\u2016X\u2016 * \u2016Y\u2016) ^ 2 := by rw [h6]\n                  _ = (\u2016X\u2016 ^ 2) * (\u2016Y\u2016 ^ 2) := by ring\n                  _ = (\u2211 i : Fin n, X i ^ 2) * \u2211 i : Fin n, Y i ^ 2 := by\n                    simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                    <;>\n                    simp_all [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                    <;>\n                    ring_nf at *\n                    <;>\n                    simp_all [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                    <;>\n                    nlinarith\n              -- Use the fact that the vectors are linearly dependent\n              have h11 : (Y i - (\u2016Y\u2016 / \u2016X\u2016) * X i) = 0 := by\n                -- Use the fact that the vectors are linearly dependent\n                have h12 : (\u2211 j : Fin n, (X j - (\u2016Y\u2016 / \u2016X\u2016) * Y j) ^ 2) = 0 := by\n                  calc\n                    (\u2211 j : Fin n, (X j - (\u2016Y\u2016 / \u2016X\u2016) * Y j) ^ 2) = \u2211 j : Fin n, (X j ^ 2 - 2 * (\u2016Y\u2016 / \u2016X\u2016) * (X j * Y j) + (\u2016Y\u2016 / \u2016X\u2016) ^ 2 * Y j ^ 2) := by\n                      apply Finset.sum_congr rfl\n                      intro j _\n                      ring_nf\n                      <;>\n                      field_simp [h7.ne']\n                      <;>\n                      ring_nf\n                    _ = \u2211 j : Fin n, (X j ^ 2 - 2 * (\u2016Y\u2016 / \u2016X\u2016) * (X j * Y j) + (\u2016Y\u2016 / \u2016X\u2016) ^ 2 * Y j ^ 2) := by rfl\n                    _ = (\u2211 j : Fin n, X j ^ 2) - 2 * (\u2016Y\u2016 / \u2016X\u2016) * (\u2211 j : Fin n, X j * Y j) + (\u2016Y\u2016 / \u2016X\u2016) ^ 2 * (\u2211 j : Fin n, Y j ^ 2) := by\n                      simp [Finset.sum_add_distrib, Finset.mul_sum, Finset.sum_sub_distrib]\n                      <;>\n                      ring_nf\n                    _ = (\u2211 j : Fin n, X j ^ 2) - 2 * (\u2016Y\u2016 / \u2016X\u2016) * (\u2016X\u2016 * \u2016Y\u2016) + (\u2016Y\u2016 / \u2016X\u2016) ^ 2 * (\u2211 j : Fin n, Y j ^ 2) := by\n                      rw [h6]\n                    _ = (\u2211 j : Fin n, X j ^ 2) - 2 * (\u2016Y\u2016 / \u2016X\u2016) * (\u2016X\u2016 * \u2016Y\u2016) + (\u2016Y\u2016 / \u2016X\u2016) ^ 2 * (\u2211 j : Fin n, Y j ^ 2) := by rfl\n                    _ = (\u2211 j : Fin n, X j ^ 2) - 2 * (\u2016Y\u2016 ^ 2) + (\u2016Y\u2016 / \u2016X\u2016) ^ 2 * (\u2211 j : Fin n, Y j ^ 2) := by\n                      field_simp [h7.ne']\n                      <;>\n                      ring_nf\n                      <;>\n                      field_simp [h7.ne']\n                      <;>\n                      ring_nf\n                    _ = (\u2211 j : Fin n, X j ^ 2) - 2 * (\u2016Y\u2016 ^ 2) + (\u2016Y\u2016 ^ 2 / \u2016X\u2016 ^ 2) * (\u2211 j : Fin n, Y j ^ 2) := by\n                      field_simp [h7.ne']\n                      <;>\n                      ring_nf\n                    _ = 0 := by\n                      have h13 : (\u2211 j : Fin n, X j ^ 2) = \u2016X\u2016 ^ 2 := by\n                        simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                        <;>\n                        simp_all [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                        <;>\n                        ring_nf at *\n                        <;>\n                        simp_all [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                        <;>\n                        nlinarith\n                      have h14 : (\u2211 j : Fin n, Y j ^ 2) = \u2016Y\u2016 ^ 2 := by\n                        simp [norm_eq_sqrt_real_inner, Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                        <;>\n                        simp_all [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                        <;>\n                        ring_nf at *\n                        <;>\n                        simp_all [Real.sqrt_eq_iff_sq_eq, sq_nonneg, add_nonneg, mul_self_nonneg]\n                        <;>\n                        nlinarith\n                      rw [h13, h14]\n                      field_simp [h7.ne']\n                      <;>\n                      ring_nf\n                      <;>\n                      field_simp [h7.ne']\n                      <;>\n                      nlinarith [sq_nonneg (\u2016X\u2016 - \u2016Y\u2016)]\n                -- Use the fact that the sum of squares is zero\n                have h13 : (X i - (\u2016Y\u2016 / \u2016X\u2016) * Y i) ^ 2 = 0 := by\n                  have h14 : (\u2211 j : Fin n, (X j - (\u2016Y\u2016 / \u2016X\u2016) * Y j) ^ 2) = 0 := h12\n                  have h15 : (X i - (\u2016Y\u2016 / \u2016X\u2016) * Y i) ^ 2 \u2265 0 := by positivity\n                  have h16 : (X i - (\u2016Y\u2016 / \u2016X\u2016) * Y i) ^ 2 \u2264 \u2211 j : Fin n, (X j - (\u2016Y\u2016 / \u2016X\u2016) * Y j) ^ 2 := by\n                    exact Finset.single_le_sum (fun j _ => sq_nonneg (X j - (\u2016Y\u2016 / \u2016X\u2016) * Y j)) (Finset.mem_univ i)\n                  linarith\n                -- Use the fact that the square is zero\n                have h17 : X i - (\u2016Y\u2016 / \u2016X\u2016) * Y i = 0 := by\n                  nlinarith\n                -- Rearrange to get Y i = (\u2016Y\u2016 / \u2016X\u2016) * X i\n                have h18 : Y i = (\u2016Y\u2016 / \u2016X\u2016) * X i := by linarith\n                linarith\n              -- Use the fact that the difference is zero\n              have h12 : Y i = (\u2016Y\u2016 / \u2016X\u2016) * X i := by linarith\n              exact h12\n            -- Use the fact that the vectors are linearly dependent\n            funext i\n            have h13 : Y i = (\u2016Y\u2016 / \u2016X\u2016) * X i := h9 i\n            simp [h13, Pi.smul_apply]\n            <;>\n            ring_nf\n            <;>\n            field_simp [h3.ne']\n            <;>\n            ring_nf\n          -- Use the fact that the vectors are linearly dependent\n          refine' \u27e8\u2016Y\u2016 / \u2016X\u2016, by positivity, _\u27e9\n          exact Or.inr h5\n        -- Use the fact that the vectors are linearly dependent\n        exact h2\n  have h_backward : (\u2203 c : \u211d, c \u2265 0 \u2227 (X = c \u2022 Y \u2228 Y = c \u2022 X)) \u2192 \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n    intro h\n    obtain \u27e8c, hc, hXY\u27e9 := h\n    have h\u2081 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n      cases hXY with\n      | inl hXY =>\n        -- Case: X = c \u2022 Y\n        have h\u2082 : X = c \u2022 Y := hXY\n        have h\u2083 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n          calc\n            \u2016X + Y\u2016 = \u2016c \u2022 Y + Y\u2016 := by rw [h\u2082]\n            _ = \u2016(c + 1) \u2022 Y\u2016 := by\n              simp [add_smul]\n              <;>\n              simp_all [smul_smul]\n              <;>\n              ring_nf\n            _ = |c + 1| * \u2016Y\u2016 := by\n              simp [norm_smul, Real.norm_eq_abs]\n            _ = (c + 1) * \u2016Y\u2016 := by\n              have h\u2084 : c + 1 \u2265 0 := by linarith\n              rw [abs_of_nonneg h\u2084]\n            _ = c * \u2016Y\u2016 + \u2016Y\u2016 := by ring\n            _ = \u2016c \u2022 Y\u2016 + \u2016Y\u2016 := by\n              simp [norm_smul, Real.norm_eq_abs, abs_of_nonneg hc]\n              <;>\n              ring_nf\n              <;>\n              simp_all [abs_of_nonneg]\n            _ = \u2016X\u2016 + \u2016Y\u2016 := by\n              rw [h\u2082]\n              <;>\n              simp [norm_smul, Real.norm_eq_abs, abs_of_nonneg hc]\n              <;>\n              ring_nf\n              <;>\n              simp_all [abs_of_nonneg]\n        exact h\u2083\n      | inr hXY =>\n        -- Case: Y = c \u2022 X\n        have h\u2082 : Y = c \u2022 X := hXY\n        have h\u2083 : \u2016X + Y\u2016 = \u2016X\u2016 + \u2016Y\u2016 := by\n          calc\n            \u2016X + Y\u2016 = \u2016X + c \u2022 X\u2016 := by rw [h\u2082]\n            _ = \u2016(1 + c) \u2022 X\u2016 := by\n              simp [add_smul]\n              <;>\n              simp_all [smul_smul]\n              <;>\n              ring_nf\n            _ = |1 + c| * \u2016X\u2016 := by\n              simp [norm_smul, Real.norm_eq_abs]\n            _ = (1 + c) * \u2016X\u2016 := by\n              have h\u2084 : 1 + c \u2265 0 := by linarith\n              rw [abs_of_nonneg h\u2084]\n            _ = \u2016X\u2016 + c * \u2016X\u2016 := by ring\n            _ = \u2016X\u2016 + \u2016c \u2022 X\u2016 := by\n              simp [norm_smul, Real.norm_eq_abs, abs_of_nonneg hc]\n              <;>\n              ring_nf\n              <;>\n              simp_all [abs_of_nonneg]\n            _ = \u2016X\u2016 + \u2016Y\u2016 := by\n              rw [h\u2082]\n              <;>\n              simp [norm_smul, Real.norm_eq_abs, abs_of_nonneg hc]\n              <;>\n              ring_nf\n              <;>\n              simp_all [abs_of_nonneg]\n        exact h\u2083\n    exact h\u2081\n  \n  exact \u27e8h_forward, h_backward\u27e9"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    