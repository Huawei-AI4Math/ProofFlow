
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: no point of $S^c$ is a limit point of~$S.$

Proof: Suppose that $S$ is closed and $x_0\in S^c$. Since $S^c$ is open,
there is a neighborhood of $x_0$ that is contained in $S^c$ and
therefore contains no points of $S$. Hence, $x_0$ cannot be a limit
point of $S$. For the converse, if no point of $S^c$ is a limit point
of $S$ then every point in $S^c$ must have a neighborhood contained
in $S^c$. Therefore, $S^c$ is open and $S$ is closed.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"def_1": {"id": "def_1", "natural_language": "Suppose that S is closed", "statement": "Assumption:\n\u2022 Assume S is a closed set in a topological space [def_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that S is a closed set in a topological space through the type declarations and the IsClosed hypothesis", "The natural language explicitly states there are no conclusions derived in this assumption step, but the Lean formalization includes a significant conclusion about the existence of open neighborhoods disjoint from closed sets. This is a major logical inconsistency as it introduces content not present in the natural language statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that S is a closed set in a topological space through the type declarations and the IsClosed hypothesis', 'The natural language explicitly states there are no conclusions derived in this assumption step, but the Lean formalization includes a significant conclusion about the existence of open neighborhoods disjoint from closed sets. This is a major logical inconsistency as it introduces content not present in the natural language statement']"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "and x_0\u2208 S^c", "statement": "We assume:\n\u2022 S is a closed set [def_1].\nDefinition:\n\u2022 Let x\u2080 be an arbitrary point in S^c, the complement of S [def_2].", "dependencies": ["def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_2\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 S\u1d9c) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition that S is a closed set is perfectly captured by the Lean header (hS : IsClosed S)", "The natural language only states that x\u2080 is an arbitrary point in S^c, which is captured by the Lean headers. However, the Lean proposition introduces a completely new conclusion about the existence of an open set U with specific properties (IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) that is not mentioned anywhere in the natural language statement. This is a major addition that changes the logical meaning of the statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition that S is a closed set is perfectly captured by the Lean header (hS : IsClosed S)', 'The natural language only states that x\u2080 is an arbitrary point in S^c, which is captured by the Lean headers. However, the Lean proposition introduces a completely new conclusion about the existence of an open set U with specific properties (IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) that is not mentioned anywhere in the natural language statement. This is a major addition that changes the logical meaning of the statement.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Since S^c is open,", "statement": "We assume:\n\u2022 S is a closed set [def_1];\n\u2022 Let x\u2080 be an arbitrary point in S^c [def_2].\nTherefore, we conclude:\n\u2022 The complement of S, S^c, is an open set [l1].", "dependencies": ["def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  IsOpen (S\u1d9c) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  IsOpen (S\u1d9c) := by\n  have h_main : IsOpen (S\u1d9c) := by\n    apply hS.isOpen_compl\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.75, "semantic_feedback": ["The theorem statement correctly captures the logical relationship: closed set implies its complement is open. The extra type parameters and topological space constraint are appropriate mathematical context.", "The assumption that S is closed is correctly formalized as 'hS : IsClosed S', which directly corresponds to the natural language premise.", "The natural language mentions 'Let x\u2080 be an arbitrary point in S^c' but this variable does not appear in the Lean formalization. However, this doesn't affect the core logical meaning since the theorem statement (closed implies complement is open) doesn't require explicitly mentioning points in the complement.", "The conclusion that S^c is open is correctly formalized as 'IsOpen (S\u1d9c)', which directly matches the natural language conclusion."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "there is a neighborhood of x_0 that is contained in S^c", "statement": "We assume:\n\u2022 S is a closed set [def_1];\n\u2022 Let x\u2080 be an arbitrary point in S^c [def_2];\n\u2022 S^c is an open set [l1].\nTherefore, we conclude:\n\u2022 There exists a neighborhood N of x\u2080 such that N \u2286 S^c [l2].", "dependencies": ["def_1", "def_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 S\u1d9c)\n  (l1 : IsOpen (S\u1d9c)) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 S\u1d9c)\n  (l1 : IsOpen (S\u1d9c)) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c := by\n  have h_main : \u2203 (U : Set \u03b1), IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c := by\n    refine' \u27e8S\u1d9c, l1, hx\u2080, _\u27e9\n    -- We need to show that S\u1d9c \u2286 S\u1d9c, which is trivially true.\n    <;> simp [Set.Subset.refl]\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumptions and setup are correctly translated from natural language to Lean, with all key hypotheses properly formalized.", "The conclusion structure perfectly captures the existence statement about the neighborhood, with appropriate Lean syntax.", "The mathematical content is identical between both versions, expressing the same topological theorem about closed sets and neighborhoods.", "The technical details in Lean (type declarations, explicit open set conditions) are necessary formalizations that don't contradict the natural language.", "Both versions include the same logical redundancy (closed set + open complement), which is consistent across both representations."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "and therefore contains no points of S.", "statement": "We assume:\n\u2022 S is a closed set [def_1];\n\u2022 Let x\u2080 be an arbitrary point in S^c [def_2];\n\u2022 S^c is an open set [l1];\n\u2022 There exists a neighborhood N of x\u2080 such that N \u2286 S^c [l2].\nTherefore, we conclude:\n\u2022 The neighborhood N from l2 is disjoint from S (i.e., N \u2229 S = \u2205) [l3].", "dependencies": ["def_1", "def_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 S\u1d9c)\n  (l1 : IsOpen (S\u1d9c))\n  (l2 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 Set.compl S)\n  (l1 : IsOpen (Set.compl S))\n  (l2 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 Set.compl S) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 Set.compl S \u2227 U \u2229 S = \u2205 := by\n  obtain \u27e8U, hU_open, hx\u2080_in_U, hU_subset_S_compl\u27e9 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 Set.compl S := l2\n  have hU_inter_S_empty : U \u2229 S = \u2205 := by\n    apply Set.eq_empty_of_forall_not_mem\n    intro x hx\n    have hx_in_U : x \u2208 U := hx.1\n    have hx_in_S : x \u2208 S := hx.2\n    have hx_in_S_compl : x \u2208 Set.compl S := hU_subset_S_compl hx_in_U\n    have hx_not_in_S : x \u2209 S := by\n      simp only [Set.mem_compl_iff] at hx_in_S_compl\n      exact hx_in_S_compl\n    exact hx_not_in_S hx_in_S\n  refine' \u27e8U, hU_open, hx\u2080_in_U, hU_subset_S_compl, _\u27e9\n  exact hU_inter_S_empty", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.8, "semantic_feedback": ["All assumptions from natural language are correctly captured in the Lean formalization with appropriate mathematical notation.", "The conclusion structure correctly translates the disjointness property from natural language to formal logic.", "The logical relationship between assumptions and conclusion is mathematically equivalent in both versions.", "Variable naming differs (N vs U) and the approach differs slightly (referring to specific neighborhood vs proving existence), but these are structural rather than semantic differences.", "The mathematical content is complete and the Lean version actually provides a stronger result by proving existence of the desired neighborhood."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Hence, x_0 cannot be a limit point of S.", "statement": "We assume:\n\u2022 S is a closed set [def_1];\n\u2022 Let x\u2080 be an arbitrary point in S^c [def_2];\n\u2022 S^c is an open set [l1];\n\u2022 There exists a neighborhood N of x\u2080 such that N \u2286 S^c [l2];\n\u2022 The neighborhood N is disjoint from S [l3].\nTherefore, we conclude:\n\u2022 x\u2080 is not a limit point of S [l4].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 S\u1d9c)\n  (l1 : IsOpen (S\u1d9c))\n  (l2 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c)\n  (l3 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c \u2227 U \u2229 S = \u2205) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S)\n  (x\u2080 : \u03b1) (hx\u2080 : x\u2080 \u2208 S\u1d9c)\n  (l1 : IsOpen (S\u1d9c))\n  (l2 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c)\n  (l3 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2286 S\u1d9c \u2227 U \u2229 S = \u2205) :\n  \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n  have h_main : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n    obtain \u27e8U, hU_open, hx\u2080_in_U, hU_subset_Sc, hU_inter_S\u27e9 := l3\n    refine' \u27e8U, hU_open, hx\u2080_in_U, _\u27e9\n    -- We already have U \u2229 S = \u2205 from l3, so we can directly use it.\n    exact hU_inter_S\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization captures the mathematical essence but has a structural mismatch with the natural language conclusion. The natural language explicitly concludes 'x\u2080 is not a limit point of S', while Lean concludes with the existence of a disjoint neighborhood. Although these are mathematically equivalent (a point is not a limit point iff there exists a neighborhood disjoint from the set), the formalization should directly state the limit point conclusion to match the natural language. Additionally, there are redundant premises (l1, l2, l3 contain overlapping information), though this doesn't affect correctness."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization captures the mathematical essence but has a structural mismatch with the natural language conclusion. The natural language explicitly concludes 'x\u2080 is not a limit point of S', while Lean concludes with the existence of a disjoint neighborhood. Although these are mathematically equivalent (a point is not a limit point iff there exists a neighborhood disjoint from the set), the formalization should directly state the limit point conclusion to match the natural language. Additionally, there are redundant premises (l1, l2, l3 contain overlapping information), though this doesn't affect correctness.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Suppose that S is closed and x_0\u2208 S^c. ... Hence, x_0 cannot be a limit point of S.", "statement": "We assume:\n\u2022 Assuming S is a closed set [def_1] allows proving that any point x\u2080 in S^c [def_2] is not a limit point of S [l1, l2, l3, l4].\nTherefore, we conclude:\n\u2022 If S is closed, then no point of S^c is a limit point of S [l5].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  \u2200 x\u2080 : \u03b1, x\u2080 \u2209 S \u2192 \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  \u2200 x\u2080 : \u03b1, x\u2080 \u2209 S \u2192 \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n  intro x\u2080 hx\u2080\n  have h\u2081 : IsOpen (S\u1d9c) := by\n    apply isOpen_compl_iff.mpr\n    exact hS\n  \n  have h\u2082 : x\u2080 \u2208 S\u1d9c := by\n    simp only [Set.mem_compl_iff]\n    exact hx\u2080\n  \n  have h\u2083 : S\u1d9c \u2229 S = \u2205 := by\n    apply Set.eq_empty_iff_forall_not_mem.mpr\n    intro x hx\n    simp only [Set.mem_inter_iff, Set.mem_compl_iff] at hx\n    tauto\n  \n  have h\u2084 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n    refine' \u27e8S\u1d9c, h\u2081, h\u2082, _\u27e9\n    -- We have already shown that S\u1d9c \u2229 S = \u2205 in h\u2083, so we can directly use it here.\n    exact h\u2083\n  \n  exact h\u2084", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning of the natural language statement. While the natural language uses the term 'limit point' and the Lean code expresses this through open neighborhoods, these are mathematically equivalent formulations. The statement 'x\u2080 is not a limit point of S' is precisely equivalent to '\u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205'. The theorem correctly assumes S is closed and proves the stated property for all points in S^c (represented as x\u2080 \u2209 S). The logical structure and mathematical content are perfectly preserved."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_3": {"id": "def_3", "natural_language": "if no point of S^c is a limit point of S", "statement": "We assume:\n\u2022 All previous steps [def_1, def_2, l1, l2, l3, l4, l5].\nAssumption:\n\u2022 Assume no point of S^c is a limit point of S [def_3].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S) :\n  \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language references 'all previous steps' but the Lean theorem doesn't explicitly reference them. However, the Lean includes necessary mathematical context (topological space, closed set) which may encompass the previous definitions.", "The Lean formalization perfectly captures the mathematical meaning of 'no point of S^c is a limit point of S' through the equivalent topological statement that every point in the complement has an open neighborhood disjoint from S.", "The natural language presents this as an assumption step with no new conclusions, but the Lean formulates it as a theorem statement. This is a structural difference in presentation rather than mathematical content."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language references 'all previous steps' but the Lean theorem doesn't explicitly reference them. However, the Lean includes necessary mathematical context (topological space, closed set) which may encompass the previous definitions.\", \"The Lean formalization perfectly captures the mathematical meaning of 'no point of S^c is a limit point of S' through the equivalent topological statement that every point in the complement has an open neighborhood disjoint from S.\", 'The natural language presents this as an assumption step with no new conclusions, but the Lean formulates it as a theorem statement. This is a structural difference in presentation rather than mathematical content.']"}, "type": "definition"}, "l6": {"id": "l6", "natural_language": "then every point in S^c must have a neighborhood contained in S^c.", "statement": "We assume:\n\u2022 All previous steps [def_1, def_2, l1, l2, l3, l4, l5];\n\u2022 Assume no point of S^c is a limit point of S [def_3].\nTherefore, we conclude:\n\u2022 For every point x in S^c, there exists a neighborhood N of x such that N \u2286 S^c [l6].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "def_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S) :\n  \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S) :\n  \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n  intro x\u2080 hx\u2080\n  have h1 : IsOpen S\u1d9c := by\n    apply IsClosed.isOpen_compl\n    exact hS\n  \n  have h2 : \u2203 (U : Set \u03b1), IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n    refine' \u27e8S\u1d9c, h1, hx\u2080, _\u27e9\n    have h3 : S\u1d9c \u2229 S = \u2205 := by\n      apply Set.eq_empty_of_forall_not_mem\n      intro x hx\n      have h4 : x \u2208 S\u1d9c := hx.1\n      have h5 : x \u2208 S := hx.2\n      exact h4 h5\n    exact h3\n  \n  exact h2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 4, "endLine": 11, "endColumn": 12, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the logical meaning of the natural language statement. The assumption 'IsClosed S' is mathematically equivalent to 'no point of S^c is a limit point of S', and the conclusion 'U \u2229 S = \u2205' is equivalent to 'U \u2286 S^c'. The use of 'IsOpen U' properly formalizes the concept of neighborhood. The overall logical structure and mathematical content are preserved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_3\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) (hS : IsClosed S) :\n  \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n  intro x\u2080 hx\u2080\n  have h\u2081 : IsOpen (S\u1d9c : Set \u03b1) := by\n    exact isOpen_compl_iff.mpr hS\n  \n  have h\u2082 : \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n    refine' \u27e8S\u1d9c, h\u2081, hx\u2080, _\u27e9\n    -- We need to show that S\u1d9c \u2229 S = \u2205\n    have h\u2083 : S\u1d9c \u2229 S = \u2205 := by\n      apply Set.eq_empty_of_forall_not_mem\n      intro x hx\n      -- If x is in S\u1d9c \u2229 S, then x is in S\u1d9c and x is in S, which is a contradiction\n      have h\u2084 : x \u2208 S\u1d9c := hx.1\n      have h\u2085 : x \u2208 S := hx.2\n      exact h\u2084 h\u2085\n    exact h\u2083\n  \n  exact h\u2082"}, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Therefore, S^c is open", "statement": "We assume:\n\u2022 All previous steps [def_1, def_2, l1, l2, l3, l4, l5, def_3];\n\u2022 For every point x in S^c, there exists a neighborhood N of x such that N \u2286 S^c [l6].\nTherefore, we conclude:\n\u2022 S^c is an open set [l7].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "def_3", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  IsOpen (S\u1d9c) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (hS : IsClosed S) :\n  IsOpen (S\u1d9c) := by\n  have h_main : IsOpen (S\u1d9c) := by\n    -- Use `simpa` to unfold the definition of `IsClosed` and directly obtain `IsOpen (S\u1d9c)`\n    simpa [IsClosed] using hS\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization uses a fundamentally different logical approach than described in the natural language. The natural language describes proving openness via the neighborhood definition (every point has a neighborhood contained in the set), while the Lean code assumes S is closed and uses the closed-open duality. Although both approaches are mathematically valid for proving S^c is open, the Lean formalization does not capture the specific logical structure and proof method outlined in the natural language, which explicitly mentions using the neighborhood characterization from step l6."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization uses a fundamentally different logical approach than described in the natural language. The natural language describes proving openness via the neighborhood definition (every point has a neighborhood contained in the set), while the Lean code assumes S is closed and uses the closed-open duality. Although both approaches are mathematically valid for proving S^c is open, the Lean formalization does not capture the specific logical structure and proof method outlined in the natural language, which explicitly mentions using the neighborhood characterization from step l6.']"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "and S is closed.", "statement": "We assume:\n\u2022 All previous steps [def_1, def_2, l1, l2, l3, l4, l5, def_3, l6];\n\u2022 S^c is an open set [l7].\nTherefore, we conclude:\n\u2022 S is a closed set [l8].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "def_3", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (h : IsOpen (S\u1d9c)) :\n  IsClosed S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (h : IsOpen (S\u1d9c)) :\n  IsClosed S := by\n  have h_main : IsClosed S := by\n    have h\u2081 : IsClosed S \u2194 IsOpen (S\u1d9c) := by\n      apply Iff.intro\n      \u00b7 -- Prove the forward direction: if S is closed, then S\u1d9c is open\n        intro hS\n        have h\u2082 : IsOpen (S\u1d9c) := by\n          -- Use the fact that the complement of a closed set is open\n          have h\u2083 : IsOpen (S\u1d9c) := isOpen_compl_iff.mpr hS\n          exact h\u2083\n        exact h\u2082\n      \u00b7 -- Prove the reverse direction: if S\u1d9c is open, then S is closed\n        intro hS_compl\n        have h\u2082 : IsClosed S := by\n          -- Use the fact that the complement of an open set is closed\n          have h\u2083 : IsClosed S := isClosed_compl_iff.mpr hS_compl\n          exact h\u2083\n        exact h\u2082\n    -- Use the equivalence to deduce that S is closed\n    have h\u2082 : IsClosed S := by\n      rw [h\u2081] at *\n      exact h\n    exact h\u2082\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 23, "column": 34, "endLine": 23, "endColumn": 65, "data": "type mismatch\n  isClosed_compl_iff.mpr hS_compl\nhas type\n  IsClosed S\u1d9c\u1d9c : Prop\nbut is expected to have type\n  IsClosed S : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The topological space setup and set declaration correctly captures the mathematical context", "The hypothesis 'IsOpen (S\u1d9c)' perfectly translates 'S^c is an open set' using appropriate Lean notation", "The conclusion 'IsClosed S' exactly matches 'S is a closed set'", "The theorem structure with hypothesis and conclusion correctly represents the logical flow from premise to conclusion", "The formalization captures the essential topological relationship between open complements and closed sets", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1)\n  (h : IsOpen (S\u1d9c)) :\n  IsClosed S := by\n  have h\u2081 : IsClosed S := by\n    -- Since IsClosed S is defined as IsOpen S\u1d9c, we can directly use h.\n    exact h\n  -- The conclusion follows directly from h\u2081.\n  exact h\u2081"}, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "if no point of S^c is a limit point of S then every point in S^c must have a neighborhood contained in S^c. Therefore, S^c is open and S is closed.", "statement": "We assume:\n\u2022 Assuming no point of S^c is a limit point of S [def_3] allows proving that S is closed [l6, l7, l8].\nTherefore, we conclude:\n\u2022 If no point of S^c is a limit point of S, then S is closed [l9].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "def_3", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) :\n  (\u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) \u2192\n  IsClosed S := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) :\n  (\u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) \u2192\n  IsClosed S := by\n  intro h\n  have h_main : IsOpen (S\u1d9c) := by\n    rw [isOpen_iff_forall_mem_open]\n    intro x hx\n    have h\u2081 : \u2203 U : Set \u03b1, IsOpen U \u2227 x \u2208 U \u2227 U \u2229 S = \u2205 := h x hx\n    obtain \u27e8U, hU_open, hU_x, hU_inter\u27e9 := h\u2081\n    have h\u2082 : U \u2286 S\u1d9c := by\n      intro y hy\n      have h\u2083 : y \u2208 U := hy\n      have h\u2084 : y \u2209 S := by\n        by_contra h\u2085\n        have h\u2086 : y \u2208 S := h\u2085\n        have h\u2087 : y \u2208 U \u2229 S := Set.mem_inter h\u2083 h\u2086\n        rw [hU_inter] at h\u2087\n        exact Set.not_mem_empty y h\u2087\n      exact h\u2084\n    refine' \u27e8U, \u27e8hU_open, hU_x, h\u2082\u27e9\u27e9\n  \n  have h_final : IsClosed S := by\n    have h\u2081 : IsClosed S := by\n      -- Use the fact that the complement of S is open to conclude that S is closed\n      have h\u2082 : IsOpen (S\u1d9c) := h_main\n      have h\u2083 : IsClosed (S\u1d9c\u1d9c) := h\u2082.isClosed_compl\n      have h\u2084 : S\u1d9c\u1d9c = S := by\n        ext x\n        simp\n      rw [h\u2084] at h\u2083\n      exact h\u2083\n    exact h\u2081\n  \n  exact h_final", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 25, "column": 17, "endLine": 25, "endColumn": 24, "data": "application type mismatch\n  And.intro hU_open\nargument\n  hU_open\nhas type\n  IsOpen U : Prop\nbut is expected to have type\n  U \u2286 S\u1d9c : Prop"}, {"line": 25, "column": 26, "endLine": 25, "endColumn": 30, "data": "application type mismatch\n  And.intro hU_x\nargument\n  hU_x\nhas type\n  x \u2208 U : Prop\nbut is expected to have type\n  IsOpen U : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The main theorem structure correctly captures the conditional statement from natural language to Lean.", "The Lean formalization uses the precise topological definition of 'not being a limit point' which correctly captures the natural language phrase 'no point of S^c is a limit point of S'.", "The conclusion 'IsClosed S' perfectly matches 'S is closed' from the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9\n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) :\n  (\u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) \u2192\n  IsClosed S := by\n  intro h\n  have h\u2081 : IsOpen S\u1d9c := by\n    have h\u2082 : S\u1d9c = \u22c3 (x : \u03b1) (hx : x \u2208 S\u1d9c), (Classical.choose (h x hx)) := by\n      apply Set.ext\n      intro y\n      simp only [Set.mem_iUnion, Set.mem_compl_iff]\n      constructor\n      \u00b7 -- Prove that if y \u2208 S\u1d9c, then y is in the union\n        intro hy\n        have h\u2083 : \u2203 U : Set \u03b1, IsOpen U \u2227 y \u2208 U \u2227 U \u2229 S = \u2205 := h y hy\n        have h\u2084 : y \u2208 Classical.choose h\u2083 := (Classical.choose_spec h\u2083).2.1\n        exact \u27e8y, hy, h\u2084\u27e9\n      \u00b7 -- Prove that if y is in the union, then y \u2208 S\u1d9c\n        intro hy\n        rcases hy with \u27e8x, hx, hy\u27e9\n        have h\u2083 : IsOpen (Classical.choose (h x hx)) := (Classical.choose_spec (h x hx)).1\n        have h\u2084 : x \u2208 Classical.choose (h x hx) := (Classical.choose_spec (h x hx)).2.1\n        have h\u2085 : Classical.choose (h x hx) \u2229 S = \u2205 := (Classical.choose_spec (h x hx)).2.2\n        have h\u2086 : y \u2208 Classical.choose (h x hx) := hy\n        have h\u2087 : y \u2209 S := by\n          by_contra h\u2088\n          have h\u2089 : y \u2208 Classical.choose (h x hx) \u2229 S := Set.mem_inter h\u2086 h\u2088\n          rw [h\u2085] at h\u2089\n          exact Set.not_mem_empty y h\u2089\n        exact h\u2087\n    rw [h\u2082]\n    -- The union of open sets is open\n    apply isOpen_iUnion\n    intro x\n    apply isOpen_iUnion\n    intro hx\n    exact (Classical.choose_spec (h x hx)).1\n  \n  have h\u2082 : IsClosed S := by\n    -- Since S\u1d9c is open, S is closed\n    have h\u2083 : IsClosed S := h\u2081.isClosed_compl\n    exact h\u2083\n  \n  exact h\u2082"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Suppose that S is closed ... For the converse, if no point of S^c is a limit point of S then ... S is closed.", "statement": "We assume:\n\u2022 All previous steps [def_1 ... l8];\n\u2022 If S is closed, then no point of S^c is a limit point of S [l5];\n\u2022 If no point of S^c is a limit point of S, then S is closed [l9].\nTherefore, we conclude:\n\u2022 S is closed if and only if no point of S^c is a limit point of S [ts_1].", "dependencies": ["def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "def_3", "l6", "l7", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) :\n  IsClosed S \u2194 \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) :\n  IsClosed S \u2194 \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n  have h_imp : IsClosed S \u2192 \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n    intro hS x\u2080 hx\u2080\n    have h\u2081 : IsOpen (S\u1d9c) := hS.isOpen_compl\n    refine' \u27e8S\u1d9c, h\u2081, hx\u2080, _\u27e9\n    have h\u2082 : S\u1d9c \u2229 S = \u2205 := by\n      apply Set.eq_empty_of_forall_not_mem\n      intro x hx\n      simp_all [Set.mem_inter_iff]\n    exact h\u2082\n  \n  have h_conv : (\u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) \u2192 IsClosed S := by\n    intro h\n    have h\u2081 : IsOpen (S\u1d9c) := by\n      refine' isOpen_iff_forall_mem_open.mpr _\n      intro x hx\n      obtain \u27e8U, hU_open, hU_mem, hU_disj\u27e9 := h x hx\n      have h\u2082 : U \u2286 S\u1d9c := by\n        intro y hy\n        by_contra h\u2083\n        have h\u2084 : y \u2208 S := by simpa using h\u2083\n        have h\u2085 : y \u2208 U \u2229 S := Set.mem_inter hy h\u2084\n        rw [hU_disj] at h\u2085\n        exact Set.not_mem_empty y h\u2085\n      refine' \u27e8U, hU_open, hU_mem, h\u2082\u27e9\n    -- Use the fact that the complement of an open set is closed\n    have h\u2082 : IsClosed S := by\n      -- Use the fact that if S\u1d9c is open, then S is closed\n      have h\u2083 : IsClosed S := by\n        -- Use the definition of closed sets as complements of open sets\n        have h\u2084 : IsOpen (S\u1d9c) := h\u2081\n        -- Use the fact that the complement of an open set is closed\n        have h\u2085 : IsClosed S := by\n          -- Use the fact that S is the complement of an open set\n          have h\u2086 : S = (S\u1d9c)\u1d9c := by\n            ext x\n            simp\n          rw [h\u2086]\n          -- The complement of an open set is closed\n          exact isOpen_compl.mp h\u2084\n        exact h\u2085\n      exact h\u2083\n    exact h\u2082\n  \n  constructor\n  \u00b7 -- Prove the forward direction: IsClosed S \u2192 \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205\n    exact h_imp\n  \u00b7 -- Prove the backward direction: (\u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) \u2192 IsClosed S\n    exact h_conv", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 31, "column": 18, "endLine": 31, "endColumn": 25, "data": "application type mismatch\n  And.intro hU_open\nargument\n  hU_open\nhas type\n  IsOpen U : Prop\nbut is expected to have type\n  U \u2286 S\u1d9c : Prop"}, {"line": 31, "column": 27, "endLine": 31, "endColumn": 33, "data": "application type mismatch\n  And.intro hU_mem\nargument\n  hU_mem\nhas type\n  x \u2208 U : Prop\nbut is expected to have type\n  IsOpen U : Prop"}, {"line": 46, "column": 16, "endLine": 46, "endColumn": 31, "data": "unknown identifier 'isOpen_compl.mp'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The biconditional structure is correctly captured in both the natural language and Lean formalization.", "The left side 'S is closed' is correctly represented as 'IsClosed S' in Lean.", "The right side 'no point of S^c is a limit point of S' is correctly formalized using the topological definition: for every point in the complement, there exists an open neighborhood disjoint from S. This is mathematically equivalent to saying no point in S^c is a limit point of S.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  {\u03b1 : Type*} [TopologicalSpace \u03b1]\n  (S : Set \u03b1) :\n  IsClosed S \u2194 \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n  have h_imp : IsClosed S \u2192 \u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205 := by\n    intro hS x\u2080 hx\u2080\n    have h\u2081 : IsOpen (S\u1d9c) := isOpen_compl_iff.mpr hS\n    refine' \u27e8S\u1d9c, h\u2081, hx\u2080, _\u27e9\n    -- We need to show that S\u1d9c \u2229 S = \u2205\n    have h\u2082 : S\u1d9c \u2229 S = \u2205 := by\n      apply Set.eq_empty_of_forall_not_mem\n      intro x hx\n      -- If x is in S\u1d9c \u2229 S, then x is in S and x is not in S, which is a contradiction\n      have h\u2083 : x \u2208 S\u1d9c := hx.1\n      have h\u2084 : x \u2208 S := hx.2\n      exact h\u2083 h\u2084\n    exact h\u2082\n  \n  have h_conv : (\u2200 x\u2080 \u2208 S\u1d9c, \u2203 U : Set \u03b1, IsOpen U \u2227 x\u2080 \u2208 U \u2227 U \u2229 S = \u2205) \u2192 IsClosed S := by\n    intro h\n    have h\u2081 : IsOpen (S\u1d9c) := by\n      -- Show that S\u1d9c is open using the fact that for each x \u2208 S\u1d9c, there is an open U \u2286 S\u1d9c containing x\n      have h\u2082 : \u2200 x \u2208 S\u1d9c, \u2203 (U : Set \u03b1), IsOpen U \u2227 x \u2208 U \u2227 U \u2286 S\u1d9c := by\n        intro x hx\n        obtain \u27e8U, hU\u2081, hU\u2082, hU\u2083\u27e9 := h x hx\n        refine' \u27e8U, hU\u2081, hU\u2082, _\u27e9\n        -- Prove that U \u2286 S\u1d9c using U \u2229 S = \u2205\n        have h\u2083 : U \u2229 S = \u2205 := hU\u2083\n        have h\u2084 : U \u2286 S\u1d9c := by\n          intro y hy\n          have h\u2085 : y \u2208 U := hy\n          have h\u2086 : y \u2209 S := by\n            intro h\u2087\n            have h\u2088 : y \u2208 U \u2229 S := \u27e8h\u2085, h\u2087\u27e9\n            rw [h\u2083] at h\u2088\n            exact Set.not_mem_empty y h\u2088\n          exact h\u2086\n        exact h\u2084\n      -- Use the lemma isOpen_iff to conclude that S\u1d9c is open\n      have h\u2083 : IsOpen (S\u1d9c) := by\n        rw [isOpen_iff]\n        intro x hx\n        obtain \u27e8U, hU\u2081, hU\u2082, hU\u2083\u27e9 := h\u2082 x hx\n        exact \u27e8U, hU\u2081, hU\u2082, hU\u2083\u27e9\n      exact h\u2083\n    -- Since S\u1d9c is open, S is closed\n    have h\u2082 : IsClosed S := by\n      have h\u2083 : IsClosed (S\u1d9c\u1d9c) := by\n        exact isClosed_compl_iff.mpr h\u2081\n      have h\u2084 : S\u1d9c\u1d9c = S := by\n        simp [compl_compl]\n      rw [h\u2084] at h\u2083\n      exact h\u2083\n    exact h\u2082\n  \n  constructor\n  \u00b7 -- Prove the forward direction: if S is closed, then for all x\u2080 \u2208 S\u1d9c, there exists an open set U containing x\u2080 such that U \u2229 S = \u2205.\n    exact h_imp\n  \u00b7 -- Prove the backward direction: if for all x\u2080 \u2208 S\u1d9c, there exists an open set U containing x\u2080 such that U \u2229 S = \u2205, then S is closed.\n    exact h_conv"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_3", "label": "def_3", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "def_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    