
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$. Let $(b_n)$ be a sequence defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$. Prove that for all integers $n \geq 1$, the inequality $a_n < b_n$ holds.

Proof: First, we find the explicit formulas for the terms of both sequences and then showing the inequality holds. For the sequence $(a_n)$, we have $a_1=1$. For $n=1$, $a_2=3a_1-2=3(1)-2=1$. For $n=2$, $a_3=3a_2-2=3(1)-2=1$. By induction, we can show that $a_n=1$ for all $n \geq 1$. For the sequence $(b_n)$, we have $b_1=3$. We can show that $b_n=2^{n+1}-1$ by induction. For the base case $n=1$, $b_1=2^{1+1}-1=2^2-1=3$ holds. Assume $b_k=2^{k+1}-1$ for some $k \geq 1$. Then $b_{k+1}=2b_k+1=2(2^{k+1}-1)+1=2^{k+2}-2+1=2^{k+2}-1$. So $b_{k+1}=2^{(k+1)+1}-1$ holds. Thus $b_n=2^{n+1}-1$ for all $n \geq 1$. Now we need to prove the inequality $a_n < b_n$. Substituting our explicit formulas, we need to show that $1 < 2^{n+1}-1$. This is equivalent to showing $2 < 2^{n+1}$, which is $1 < 2^n$. This inequality holds for all integers $n \geq 1$. Therefore, the inequality $a_n < b_n$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$.", "statement": "Premise:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for $n \\geq 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2124)\n(tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean type declaration `a : \u2115 \u2192 \u2124` perfectly captures the concept of a sequence of integers indexed by natural numbers", "The initial condition `a 1 = 1` is exactly as stated in the natural language", "The recurrence relation `\u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2` matches the mathematical statement exactly, including the domain restriction", "The Lean formalization establishes the sequence as well-defined through proper type declarations and constraints, which aligns with the conclusion about well-definedness"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $(b_n)$ be a sequence defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$.", "statement": "Premise:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for $n \\geq 1$ [tc_1].\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of integers defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$ for $n \\geq 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2\n  (a b : \u2115 \u2192 \u2124)\n  (ha : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (hb : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean hypothesis `ha : a 1 = 1` perfectly captures the condition that sequence (a_n) has initial value a_1 = 1", "The Lean hypothesis `ha : ... \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2` perfectly captures the recurrence relation a_{n+1} = 3a_n - 2 for n \u2265 1", "The Lean hypothesis `hb : b 1 = 3` perfectly captures the condition that sequence (b_n) has initial value b_1 = 3", "The Lean hypothesis `hb : ... \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1` perfectly captures the recurrence relation b_{n+1} = 2b_n + 1 for n \u2265 1", "The Lean proposition `\u2200 n : \u2115, n \u2265 1 \u2192 a n < b n` claims that a_n < b_n for all n \u2265 1, which is completely different from the natural language conclusion that the sequences are well-defined. The Lean formalization introduces a new mathematical claim about the relationship between the sequences that was not mentioned in the natural language statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean hypothesis `ha : a 1 = 1` perfectly captures the condition that sequence (a_n) has initial value a_1 = 1', 'The Lean hypothesis `ha : ... \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2` perfectly captures the recurrence relation a_{n+1} = 3a_n - 2 for n \u2265 1', 'The Lean hypothesis `hb : b 1 = 3` perfectly captures the condition that sequence (b_n) has initial value b_1 = 3', 'The Lean hypothesis `hb : ... \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1` perfectly captures the recurrence relation b_{n+1} = 2b_n + 1 for n \u2265 1', 'The Lean proposition `\u2200 n : \u2115, n \u2265 1 \u2192 a n < b n` claims that a_n < b_n for all n \u2265 1, which is completely different from the natural language conclusion that the sequences are well-defined. The Lean formalization introduces a new mathematical claim about the relationship between the sequences that was not mentioned in the natural language statement.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For the sequence $(a_n)$, we have $a_1=1$. For $n=1$, $a_2=3a_1-2=3(1)-2=1$. For $n=2$, $a_3=3a_2-2=3(1)-2=1$. By induction, we can show that $a_n=1$ for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for $n \\geq 1$ [tc_1].\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of integers defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$ for $n \\geq 1$ [tc_2].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, $a_n = 1$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a b : \u2115 \u2192 \u2124)\n  (ha : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (hb : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a b : \u2115 \u2192 \u2124)\n  (ha : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (hb : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1 := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 1 := by\n    intro n hn\n    induction' n using Nat.strong_induction_on with n ih\n    match n with\n    | 0 =>\n      -- This case is impossible because hn : 0 \u2265 1 is false.\n      exfalso\n      linarith\n    | 1 =>\n      -- Base case: n = 1\n      have h\u2081 : a 1 = 1 := ha.1\n      exact h\u2081\n    | (k + 2) =>\n      -- Inductive step: n = k + 2\n      have h\u2082 : (k + 2) \u2265 1 := by linarith\n      have h\u2083 : a (k + 2) = 1 := by\n        have h\u2084 : a (k + 2) = 3 * a (k + 1) - 2 := ha.2 (k + 1) (by\n          -- Prove that k + 1 \u2265 1\n          omega)\n        have h\u2085 : a (k + 1) = 1 := by\n          -- Use the induction hypothesis to get a (k + 1) = 1\n          have h\u2086 : (k + 1) \u2265 1 := by omega\n          have h\u2087 : a (k + 1) = 1 := ih (k + 1) (by omega) h\u2086\n          exact h\u2087\n        -- Substitute a (k + 1) = 1 into the expression for a (k + 2)\n        rw [h\u2084, h\u2085]\n        <;> norm_num\n      exact h\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence (a_n) definition is correctly formalized with both the initial condition a_1=1 and the recurrence relation a_{n+1}=3a_n-2 for n\u22651.", "The sequence (b_n) definition is correctly formalized with both the initial condition b_1=3 and the recurrence relation b_{n+1}=2b_n+1 for n\u22651.", "The conclusion is correctly formalized. Using \u2115 instead of 'integers' for the domain is appropriate since we're considering n\u22651, which effectively means positive integers."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For the base case $n=1$, $b_1=2^{1+1}-1=2^2-1=3$ holds.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for $n \\geq 1$ [tc_1].\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of integers defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$ for $n \\geq 1$ [tc_2].\n\u2022 For all integers $n \\geq 1$, $a_n = 1$ [l1].\nTherefore, we conclude:\n\u2022 The formula $b_n=2^{n+1}-1$ holds for the base case $n=1$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1) :\n  b 1 = 2^(1 + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1) :\n  b 1 = 2^(1 + 1) - 1 := by\n  have h_main : b 1 = 2^(1 + 1) - 1 := by\n    have h2 : b 1 = 3 := tc_2.1\n    norm_num [h2]\n    <;>\n    (try decide) <;>\n    (try ring_nf at *) <;>\n    (try norm_cast at *) <;>\n    (try simp_all) <;>\n    (try omega)\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence (a_n) definition is correctly formalized with proper initial condition and recurrence relation", "The sequence (b_n) definition accurately captures the initial value and recurrence relation", "The property that all terms of sequence a_n equal 1 is properly stated as a universal quantification", "The base case conclusion for the formula b_n = 2^(n+1) - 1 when n=1 is correctly formalized"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Assume $b_k=2^{k+1}-1$ for some $k \\geq 1$. Then $b_{k+1}=2b_k+1=2(2^{k+1}-1)+1=2^{k+2}-2+1=2^{k+2}-1$. So $b_{k+1}=2^{(k+1)+1}-1$ holds.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for $n \\geq 1$ [tc_1].\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of integers defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$ for $n \\geq 1$ [tc_2].\n\u2022 For all integers $n \\geq 1$, $a_n = 1$ [l1].\n\u2022 The formula $b_n=2^{n+1}-1$ holds for the base case $n=1$ [l2].\nTherefore, we conclude:\n\u2022 For any integer $k \\geq 1$, if we assume $b_k = 2^{k+1}-1$, then it follows that $b_{k+1} = 2^{(k+1)+1}-1$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : b 1 = 2^(1 + 1) - 1)\n  (k : \u2115)\n  (hk : k \u2265 1)\n  (h : b k = 2^(k + 1) - 1) :\n  b (k + 1) = 2^((k + 1) + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : b 1 = 2^(1 + 1) - 1)\n  (k : \u2115)\n  (hk : k \u2265 1)\n  (h : b k = 2^(k + 1) - 1) :\n  b (k + 1) = 2^((k + 1) + 1) - 1 := by\n  have h_rec : b (k + 1) = 2 * b k + 1 := by\n    have h\u2081 : \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1 := tc_2.2\n    have h\u2082 : k \u2265 1 := hk\n    have h\u2083 : b (k + 1) = 2 * b k + 1 := h\u2081 k h\u2082\n    exact h\u2083\n  \n  have h_expand : b (k + 1) = 2 * (2^(k + 1) - 1 : \u2124) + 1 := by\n    rw [h_rec]\n    rw [h]\n    <;> norm_cast\n    <;> simp [pow_add, pow_one, mul_assoc]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> simp_all [Int.mul_emod]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> linarith\n  \n  have h_power : (2 : \u2124) * (2 : \u2124)^(k + 1 : \u2115) = (2 : \u2124)^((k + 1 : \u2115) + 1 : \u2115) := by\n    have h\u2081 : (2 : \u2124) * (2 : \u2124)^(k + 1 : \u2115) = (2 : \u2124)^((k + 1 : \u2115) + 1 : \u2115) := by\n      calc\n        (2 : \u2124) * (2 : \u2124)^(k + 1 : \u2115) = (2 : \u2124)^1 * (2 : \u2124)^(k + 1 : \u2115) := by norm_num\n        _ = (2 : \u2124)^(1 + (k + 1 : \u2115)) := by\n          rw [\u2190 pow_add]\n          <;> simp [add_assoc]\n        _ = (2 : \u2124)^((k + 1 : \u2115) + 1 : \u2115) := by\n          congr 1 <;> ring_nf\n          <;> simp [add_assoc]\n          <;> omega\n    exact h\u2081\n  \n  have h_main : b (k + 1) = (2 : \u2124)^((k + 1 : \u2115) + 1 : \u2115) - 1 := by\n    calc\n      b (k + 1) = 2 * (2 ^ (k + 1) - 1 : \u2124) + 1 := h_expand\n      _ = 2 * (2 : \u2124)^(k + 1 : \u2115) - 2 + 1 := by\n        ring_nf\n        <;> norm_cast\n        <;> simp [pow_add, pow_one, mul_assoc]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> simp_all [Int.mul_emod]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      _ = (2 : \u2124) * (2 : \u2124)^(k + 1 : \u2115) - 1 := by ring\n      _ = (2 : \u2124)^((k + 1 : \u2115) + 1 : \u2115) - 1 := by\n        rw [h_power]\n        <;> ring_nf\n        <;> norm_cast\n        <;> simp [pow_add, pow_one, mul_assoc]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> simp_all [Int.mul_emod]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n  \n  have h_final : b (k + 1) = 2^((k + 1) + 1) - 1 := by\n    simpa [add_assoc] using h_main\n  \n  apply h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence (a_n) definition with initial condition and recurrence relation is correctly formalized in Lean.", "The sequence (b_n) definition with initial condition and recurrence relation is correctly formalized in Lean.", "The universal property l1 about sequence a is correctly captured.", "The base case l2 for the formula is correctly stated.", "The main inductive step conclusion l3 is correctly formalized with proper quantification and implication structure.", "The type choices (\u2115 \u2192 \u2124 for sequences, \u2115 for indices) are mathematically sound and consistent with standard practice."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Thus $b_n=2^{n+1}-1$ for all $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=1$ and the recurrence relation $a_{n+1}=3a_n-2$ for $n \\geq 1$ [tc_1].\n\u2022 $(b_n)_{n \\geq 1}$ is a sequence of integers defined by $b_1=3$ and the recurrence relation $b_{n+1}=2b_n+1$ for $n \\geq 1$ [tc_2].\n\u2022 For all integers $n \\geq 1$, $a_n = 1$ [l1].\n\u2022 The formula $b_n=2^{n+1}-1$ holds for the base case $n=1$ [l2].\n\u2022 For any integer $k \\geq 1$, if we assume $b_k = 2^{k+1}-1$, then it follows that $b_{k+1} = 2^{(k+1)+1}-1$ [l3].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, $b_n = 2^{n+1}-1$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : b 1 = 2^(1 + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 1 \u2192 b k = 2^(k + 1) - 1 \u2192 b (k + 1) = 2^((k + 1) + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : b 1 = 2^(1 + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 1 \u2192 b k = 2^(k + 1) - 1 \u2192 b (k + 1) = 2^((k + 1) + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1 := by\n  have h_main : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1 := by\n    intro n hn\n    have h : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1 := by\n      intro n hn\n      induction' hn with n hn IH\n      \u00b7 -- Base case: n = 1\n        norm_num [l2] at *\n        <;> simp_all\n        <;> norm_num\n        <;> linarith\n      \u00b7 -- Inductive step: assume the statement holds for n, prove for n + 1\n        have h\u2081 := l3 n hn IH\n        simp [pow_succ, mul_add, mul_one, add_assoc] at h\u2081 \u22a2\n        <;>\n        (try norm_num at h\u2081 \u22a2) <;>\n        (try ring_nf at h\u2081 \u22a2) <;>\n        (try simp_all [pow_succ, mul_add, mul_one, add_assoc]) <;>\n        (try norm_num at h\u2081 \u22a2) <;>\n        (try linarith) <;>\n        (try ring_nf at h\u2081 \u22a2) <;>\n        (try omega)\n        <;>\n        (try\n          {\n            cases n with\n            | zero => contradiction -- n cannot be zero since hn : n \u2265 1\n            | succ n =>\n              simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_add, mul_one, add_assoc]\n              <;> ring_nf at *\n              <;> norm_num at *\n              <;> linarith\n          })\n        <;>\n        (try\n          {\n            simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_add, mul_one, add_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> linarith\n          })\n    exact h n hn\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition for (a_n) is correctly captured with both the initial condition and recurrence relation properly formalized.", "The sequence definition for (b_n) is correctly captured with both the initial condition and recurrence relation properly formalized.", "The statement about a_n = 1 is semantically correct, but uses natural numbers (\u2115) instead of integers (\u2124) as mentioned in natural language. However, this is a minor notational difference that doesn't affect the logical meaning since we're dealing with positive indices.", "The base case for the induction is perfectly captured, showing that b_1 = 2^(1+1) - 1.", "The inductive step is correctly formalized, capturing the implication structure needed for mathematical induction.", "The conclusion is semantically correct but again uses natural numbers instead of integers. This is consistent with the rest of the formalization and doesn't affect the logical meaning.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Now we need to prove the inequality $a_n < b_n$. Substituting our explicit formulas, we need to show that $1 < 2^{n+1}-1$.", "statement": "We assume:\n\u2022 For all integers $n \\geq 1$, $a_n = 1$ [l1].\n\u2022 For all integers $n \\geq 1$, $b_n = 2^{n+1}-1$ [l4].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $a_n < b_n$ is equivalent to showing $1 < 2^{n+1}-1$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) := by\n    intro n hn\n    have h\u2081 : a n = 1 := l1 n hn\n    have h\u2082 : b n = 2^(n + 1) - 1 := l4 n hn\n    constructor\n    \u00b7 -- Prove the forward direction: a n < b n \u2192 1 < 2^(n+1) - 1\n      intro h\n      have h\u2083 : (a n : \u2124) < (b n : \u2124) := by exact_mod_cast h\n      rw [h\u2081] at h\u2083\n      have h\u2084 : (b n : \u2124) = (2^(n + 1) - 1 : \u2115) := by\n        norm_cast\n        <;> simp [h\u2082]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> omega\n      rw [h\u2084] at h\u2083\n      norm_num at h\u2083 \u22a2\n      <;>\n      (try omega) <;>\n      (try\n        {\n          have h\u2085 : n \u2265 1 := hn\n          have h\u2086 : (2 : \u2115)^(n + 1) \u2265 4 := by\n            have h\u2087 : n + 1 \u2265 2 := by linarith\n            have h\u2088 : (2 : \u2115)^(n + 1) \u2265 2 ^ 2 := by\n              exact pow_le_pow_right (by norm_num) (by linarith)\n            norm_num at h\u2088 \u22a2\n            <;> linarith\n          have h\u2087 : (2 : \u2115)^(n + 1) - 1 \u2265 3 := by\n            have h\u2088 : (2 : \u2115)^(n + 1) \u2265 4 := h\u2086\n            omega\n          norm_num at h\u2083 \u22a2\n          <;>\n          (try omega) <;>\n          (try\n            {\n              cases n with\n              | zero => contradiction\n              | succ n =>\n                simp [pow_succ, mul_add, mul_one, mul_assoc, mul_comm, mul_left_comm] at h\u2083 \u22a2\n                <;> ring_nf at h\u2083 \u22a2 <;> norm_cast at h\u2083 \u22a2 <;> omega\n            }) <;>\n          (try\n            {\n              norm_num at h\u2083 \u22a2 <;>\n              ring_nf at h\u2083 \u22a2 <;>\n              norm_cast at h\u2083 \u22a2 <;>\n              omega\n            })\n        })\n    \u00b7 -- Prove the reverse direction: 1 < 2^(n+1) - 1 \u2192 a n < b n\n      intro h\n      have h\u2083 : (a n : \u2124) < (b n : \u2124) := by\n        rw [h\u2081]\n        have h\u2084 : (b n : \u2124) = (2^(n + 1) - 1 : \u2115) := by\n          norm_cast\n          <;> simp [h\u2082]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> omega\n        rw [h\u2084]\n        have h\u2085 : (1 : \u2124) < (2^(n + 1) - 1 : \u2115) := by\n          norm_num at h \u22a2\n          <;>\n          (try omega) <;>\n          (try\n            {\n              have h\u2086 : n \u2265 1 := hn\n              have h\u2087 : (2 : \u2115)^(n + 1) \u2265 4 := by\n                have h\u2088 : n + 1 \u2265 2 := by linarith\n                have h\u2089 : (2 : \u2115)^(n + 1) \u2265 2 ^ 2 := by\n                  exact pow_le_pow_right (by norm_num) (by linarith)\n                norm_num at h\u2089 \u22a2\n                <;> linarith\n              have h\u2088 : (2 : \u2115)^(n + 1) - 1 \u2265 3 := by\n                have h\u2089 : (2 : \u2115)^(n + 1) \u2265 4 := h\u2087\n                omega\n              norm_num at h \u22a2\n              <;>\n              (try omega) <;>\n              (try\n                {\n                  cases n with\n                  | zero => contradiction\n                  | succ n =>\n                    simp [pow_succ, mul_add, mul_one, mul_assoc, mul_comm, mul_left_comm] at h \u22a2\n                    <;> ring_nf at h \u22a2 <;> norm_cast at h \u22a2 <;> omega\n                }) <;>\n              (try\n                {\n                  norm_num at h \u22a2 <;>\n                  ring_nf at h \u22a2 <;>\n                  norm_cast at h \u22a2 <;>\n                  omega\n                })\n            })\n        exact_mod_cast h\u2085\n      exact_mod_cast h\u2083\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The extra conditions tc_1 and tc_2 are additional logically consistent details not mentioned in natural language, which is acceptable", "Assumption l1 is correctly formalized with appropriate type conversion from integers to natural numbers", "Assumption l4 is correctly formalized with proper exponential notation", "The conclusion l5 correctly captures the equivalence statement using the biconditional operator", "The overall logical structure properly represents the natural language reasoning from assumptions to conclusion"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "This is equivalent to showing $2 < 2^{n+1}$,", "statement": "We assume:\n\u2022 For all integers $n \\geq 1$, the inequality $a_n < b_n$ is equivalent to showing $1 < 2^{n+1}-1$ [l5].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $1 < 2^{n+1}-1$ is equivalent to $2 < 2^{n+1}$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) \u2227 (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) \u2227 (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1)) := by\n  intro n hn\n  have h_main\u2081 : (a n < b n \u2194 1 < 2^(n + 1) - 1) := by\n    have h\u2081 : a n = 1 := l1 n hn\n    have h\u2082 : (b n : \u2124) = (2 : \u2124) ^ (n + 1) - 1 := by\n      have h\u2083 : b n = 2 ^ (n + 1) - 1 := l4 n hn\n      norm_cast at h\u2083 \u22a2\n      <;> simp [h\u2083]\n      <;> ring_nf at h\u2083 \u22a2 <;> simp_all\n      <;> omega\n    have h\u2083 : (a n : \u2124) < (b n : \u2124) \u2194 (1 : \u2124) < (2 : \u2124) ^ (n + 1) - 1 := by\n      rw [h\u2081, h\u2082]\n      <;> norm_cast\n      <;> simp [pow_succ]\n      <;> ring_nf at *\n      <;> norm_num at *\n      <;> omega\n    norm_cast at h\u2083 \u22a2\n    <;> simp_all [h\u2081, h\u2082]\n    <;> ring_nf at *\n    <;> norm_num at *\n    <;> omega\n  \n  have h_main\u2082 : (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1)) := by\n    have h\u2082 : 2 ^ (n + 1) \u2265 4 := by\n      have h\u2083 : n + 1 \u2265 2 := by omega\n      have h\u2084 : 2 ^ (n + 1) \u2265 2 ^ 2 := by\n        exact pow_le_pow_right (by norm_num) h\u2083\n      norm_num at h\u2084 \u22a2\n      <;> omega\n    have h\u2083 : 1 < 2 ^ (n + 1) - 1 := by\n      have h\u2084 : 2 ^ (n + 1) \u2265 4 := h\u2082\n      have h\u2085 : 2 ^ (n + 1) - 1 \u2265 3 := by\n        have h\u2086 : 2 ^ (n + 1) \u2265 4 := h\u2082\n        omega\n      omega\n    have h\u2084 : 2 < 2 ^ (n + 1) := by\n      have h\u2085 : 2 ^ (n + 1) \u2265 4 := h\u2082\n      omega\n    constructor\n    \u00b7 intro h\n      -- Prove the forward direction: 1 < 2^(n+1) - 1 \u2192 2 < 2^(n+1)\n      -- Since 2^(n+1) \u2265 4, 2^(n+1) - 1 \u2265 3, so 1 < 2^(n+1) - 1 is true, and 2 < 2^(n+1) is also true.\n      have h\u2085 : 2 ^ (n + 1) \u2265 4 := h\u2082\n      omega\n    \u00b7 intro h\n      -- Prove the reverse direction: 2 < 2^(n+1) \u2192 1 < 2^(n+1) - 1\n      -- Since 2^(n+1) \u2265 4, 2^(n+1) - 1 \u2265 3, so 1 < 2^(n+1) - 1 is true.\n      have h\u2085 : 2 ^ (n + 1) \u2265 4 := h\u2082\n      omega\n  \n  exact \u27e8h_main\u2081, h_main\u2082\u27e9", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 31, "column": 8, "endLine": 31, "endColumn": 13, "data": "omega could not prove the goal:\na possible counterexample may satisfy the constraints\n  e \u2265 2\n  d \u2265 2\n  c \u2265 1\nwhere\n c := \u2191n\n d := Int.subNatNat (2 ^ n * 2) 1\n e := 2 ^ n"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures both mathematical equivalences mentioned in the natural language: (1) a_n < b_n \u2194 1 < 2^(n+1)-1 and (2) 1 < 2^(n+1)-1 \u2194 2 < 2^(n+1). However, there is a structural difference in how these are presented. The natural language treats the first as an assumption and the second as a conclusion, while the Lean code presents both as parts of a single conjunctive conclusion. The mathematical content is preserved, but the logical organization differs slightly. The additional context about sequences a and b provides necessary mathematical foundation not explicitly mentioned in the natural language excerpt.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures both mathematical equivalences mentioned in the natural language: (1) a_n < b_n \u2194 1 < 2^(n+1)-1 and (2) 1 < 2^(n+1)-1 \u2194 2 < 2^(n+1). However, there is a structural difference in how these are presented. The natural language treats the first as an assumption and the second as a conclusion, while the Lean code presents both as parts of a single conjunctive conclusion. The mathematical content is preserved, but the logical organization differs slightly. The additional context about sequences a and b provides necessary mathematical foundation not explicitly mentioned in the natural language excerpt.']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "which is $1 < 2^n$.", "statement": "We assume:\n\u2022 For all integers $n \\geq 1$, the inequality $1 < 2^{n+1}-1$ is equivalent to $2 < 2^{n+1}$ [l6].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, the inequality $2 < 2^{n+1}$ is equivalent to $1 < 2^n$ [l7].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : b 1 = 2^(1 + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 1 \u2192 b k = 2^(k + 1) - 1 \u2192 b (k + 1) = 2^((k + 1) + 1) - 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) \u2227 (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1))) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (2 < 2^(n + 1) \u2194 1 < 2^n) := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l2 : b 1 = 2^(1 + 1) - 1)\n  (l3 : \u2200 k : \u2115, k \u2265 1 \u2192 b k = 2^(k + 1) - 1 \u2192 b (k + 1) = 2^((k + 1) + 1) - 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) \u2227 (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1))) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 (2 < 2^(n + 1) \u2194 1 < 2^n) := by\n  intro n hn\n  have h\u2081 : 2 < 2 ^ (n + 1) := by\n    have h\u2081\u2081 : n + 1 \u2265 2 := by\n      omega\n    have h\u2081\u2082 : 2 ^ (n + 1) \u2265 2 ^ 2 := by\n      exact pow_le_pow_right (by norm_num) h\u2081\u2081\n    have h\u2081\u2083 : 2 ^ 2 = 4 := by norm_num\n    have h\u2081\u2084 : 2 ^ (n + 1) \u2265 4 := by\n      linarith\n    have h\u2081\u2085 : 2 < 2 ^ (n + 1) := by\n      omega\n    exact h\u2081\u2085\n  \n  have h\u2082 : 1 < 2 ^ n := by\n    have h\u2082\u2081 : n \u2265 1 := hn\n    have h\u2082\u2082 : 2 ^ n \u2265 2 ^ 1 := by\n      exact pow_le_pow_right (by norm_num) h\u2082\u2081\n    have h\u2082\u2083 : 2 ^ 1 = 2 := by norm_num\n    have h\u2082\u2084 : 2 ^ n \u2265 2 := by\n      linarith\n    have h\u2082\u2085 : 1 < 2 ^ n := by\n      omega\n    exact h\u2082\u2085\n  \n  have h\u2083 : (2 < 2 ^ (n + 1)) \u2194 (1 < 2 ^ n) := by\n    constructor\n    \u00b7 -- Prove the forward direction: 2 < 2^(n + 1) \u2192 1 < 2^n\n      intro h\n      -- Since we already have 1 < 2^n from h\u2082, we can directly use it\n      exact h\u2082\n    \u00b7 -- Prove the backward direction: 1 < 2^n \u2192 2 < 2^(n + 1)\n      intro h\n      -- Since we already have 2 < 2^(n + 1) from h\u2081, we can directly use it\n      exact h\u2081\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The assumption from natural language is correctly captured in premise l6, though it's embedded within additional context not mentioned in the natural language. The type difference (integers vs natural numbers) is minor since we're dealing with n \u2265 1.", "The conclusion stated in natural language is perfectly captured as the goal of theorem l7, with the exact same mathematical relationship: 2 < 2^(n+1) \u2194 1 < 2^n for n \u2265 1.", "While the core mathematical content is preserved, the Lean formalization includes substantial additional premises (tc_1, tc_2, l1-l5) defining sequences and their properties that are completely absent from the natural language description. This suggests the formalization is part of a larger context not reflected in the given natural language.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The assumption from natural language is correctly captured in premise l6, though it's embedded within additional context not mentioned in the natural language. The type difference (integers vs natural numbers) is minor since we're dealing with n \u2265 1.\", 'The conclusion stated in natural language is perfectly captured as the goal of theorem l7, with the exact same mathematical relationship: 2 < 2^(n+1) \u2194 1 < 2^n for n \u2265 1.', 'While the core mathematical content is preserved, the Lean formalization includes substantial additional premises (tc_1, tc_2, l1-l5) defining sequences and their properties that are completely absent from the natural language description. This suggests the formalization is part of a larger context not reflected in the given natural language.']"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "This inequality holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 For all integers $n \\geq 1$, the inequality $2 < 2^{n+1}$ is equivalent to $1 < 2^n$ [l7].\nTherefore, we conclude:\n\u2022 The inequality $1 < 2^n$ holds for all integers $n \\geq 1$ [l8].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (h : \u2200 n : \u2115, n \u2265 1 \u2192 (2 < 2^(n + 1) \u2194 1 < 2^n)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (h : \u2200 n : \u2115, n \u2265 1 \u2192 (2 < 2^(n + 1) \u2194 1 < 2^n)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n := by\n  intro n hn\n  have h_pow : 2 < 2 ^ (n + 1) := by\n    have h\u2081 : 2 \u2264 n + 1 := by linarith\n    have h\u2082 : 2 ^ 2 \u2264 2 ^ (n + 1) := by\n      apply Nat.pow_le_pow_of_le_right\n      <;> norm_num\n      <;> linarith\n    have h\u2083 : 2 ^ (n + 1) \u2265 4 := by\n      calc\n        2 ^ (n + 1) \u2265 2 ^ 2 := h\u2082\n        _ = 4 := by norm_num\n    have h\u2084 : 2 < 2 ^ (n + 1) := by\n      omega\n    exact h\u2084\n  \n  have h_main : 1 < 2 ^ n := by\n    have h\u2081 : (2 < 2 ^ (n + 1)) \u2194 (1 < 2 ^ n) := h n hn\n    have h\u2082 : 2 < 2 ^ (n + 1) := h_pow\n    have h\u2083 : 1 < 2 ^ n := by\n      -- Since 2 < 2 ^ (n + 1) is true, we can use the equivalence to deduce 1 < 2 ^ n\n      have h\u2084 : (1 < 2 ^ n) := by\n        -- Use the equivalence to get 1 < 2 ^ n\n        have h\u2085 : (2 < 2 ^ (n + 1)) \u2194 (1 < 2 ^ n) := h\u2081\n        -- Since 2 < 2 ^ (n + 1) is true, we can use the equivalence to deduce 1 < 2 ^ n\n        have h\u2086 : 2 < 2 ^ (n + 1) := h\u2082\n        -- Use the equivalence to deduce 1 < 2 ^ n\n        have h\u2087 : 1 < 2 ^ n := by\n          -- Use the fact that 2 < 2 ^ (n + 1) is true and the equivalence to deduce 1 < 2 ^ n\n          have h\u2088 : (1 < 2 ^ n) := by\n            -- Use the equivalence to deduce 1 < 2 ^ n\n            simpa [h\u2085] using h\u2086\n          exact h\u2088\n        exact h\u2087\n      exact h\u2084\n    exact h\u2083\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The assumption is correctly formalized, but there's a minor type difference: natural language mentions 'integers n \u2265 1' while Lean uses natural numbers (\u2115). However, for n \u2265 1, this difference doesn't affect the mathematical meaning since we're only dealing with positive integers.", "The conclusion is perfectly captured - the inequality 1 < 2^n for all n \u2265 1 is exactly represented in the Lean formalization.", "The logical structure is perfectly preserved - the Lean theorem correctly shows that the conclusion follows from the given assumption, matching the 'Therefore, we conclude' reasoning in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, the inequality $a_n < b_n$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 For all integers $n \\geq 1$, the inequality $a_n < b_n$ is equivalent to showing $1 < 2^{n+1}-1$ [l5].\n\u2022 For all integers $n \\geq 1$, the inequality $1 < 2^{n+1}-1$ is equivalent to $2 < 2^{n+1}$ [l6].\n\u2022 For all integers $n \\geq 1$, the inequality $2 < 2^{n+1}$ is equivalent to $1 < 2^n$ [l7].\n\u2022 The inequality $1 < 2^n$ holds for all integers $n \\geq 1$ [l8].\nTherefore, we conclude:\n\u2022 The inequality $a_n < b_n$ holds for all integers $n \\geq 1$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) \u2227 (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1)))\n  (l7 : \u2200 n : \u2115, n \u2265 1 \u2192 (2 < 2^(n + 1) \u2194 1 < 2^n))\n  (l8 : \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\n  sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a b : \u2115 \u2192 \u2124)\n  (tc_1 : a 1 = 1 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 a (n + 1) = 3 * a n - 2)\n  (tc_2 : b 1 = 3 \u2227 \u2200 n : \u2115, n \u2265 1 \u2192 b (n + 1) = 2 * b n + 1)\n  (l1 : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 1)\n  (l4 : \u2200 n : \u2115, n \u2265 1 \u2192 b n = 2^(n + 1) - 1)\n  (l5 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1))\n  (l6 : \u2200 n : \u2115, n \u2265 1 \u2192 (a n < b n \u2194 1 < 2^(n + 1) - 1) \u2227 (1 < 2^(n + 1) - 1 \u2194 2 < 2^(n + 1)))\n  (l7 : \u2200 n : \u2115, n \u2265 1 \u2192 (2 < 2^(n + 1) \u2194 1 < 2^n))\n  (l8 : \u2200 n : \u2115, n \u2265 1 \u2192 1 < 2^n) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\n  intro n hn\n  have h1 : (1 : \u2115) < 2 ^ n := by\n    have h1' : 1 < 2 ^ n := l8 n hn\n    exact_mod_cast h1'\n  \n  have h2 : (2 : \u2115) < 2 ^ (n + 1) := by\n    have h2' : (2 : \u2115) < 2 ^ (n + 1) := by\n      have h7 : (2 < 2 ^ (n + 1) \u2194 1 < 2 ^ n) := l7 n hn\n      have h8 : 1 < 2 ^ n := h1\n      have h9 : 2 < 2 ^ (n + 1) := by\n        have h10 : 1 < 2 ^ n := h8\n        have h11 : 2 < 2 ^ (n + 1) := by\n          have h12 : (2 < 2 ^ (n + 1) \u2194 1 < 2 ^ n) := l7 n hn\n          have h13 : 1 < 2 ^ n := h10\n          have h14 : 2 < 2 ^ (n + 1) := by\n            rw [h12] at *\n            <;> tauto\n          exact h14\n        exact h11\n      exact h9\n    exact h2'\n  \n  have h3 : (1 : \u2115) < 2 ^ (n + 1) - 1 := by\n    have h3' : (1 < 2 ^ (n + 1) - 1 \u2194 2 < 2 ^ (n + 1)) := (l6 n hn).2\n    have h4 : 2 < 2 ^ (n + 1) := h2\n    have h5 : 1 < 2 ^ (n + 1) - 1 := by\n      have h6 : 1 < 2 ^ (n + 1) - 1 := by\n        rw [h3']\n        <;> simp_all\n        <;> omega\n      exact h6\n    exact h5\n  \n  have h4 : a n < b n := by\n    have h4' : (a n < b n \u2194 1 < 2 ^ (n + 1) - 1) := (l5 n hn)\n    have h5 : 1 < 2 ^ (n + 1) - 1 := by\n      -- Use the fact that h3 is (1 : \u2115) < 2^(n+1) - 1 and Lean will automatically handle the coercion\n      exact_mod_cast h3\n    have h6 : a n < b n := by\n      -- Use the equivalence from l5 to get a n < b n from 1 < 2^(n+1) - 1\n      have h7 : a n < b n := by\n        rw [h4']\n        <;> simp_all\n      exact h7\n    exact h6\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.8, "semantic_feedback": ["Assumption l5 is correctly formalized as a biconditional statement matching the natural language exactly.", "Assumption l6 includes redundant information. The natural language only states the equivalence between '1 < 2^(n+1)-1' and '2 < 2^(n+1)', but the Lean formalization unnecessarily repeats the equivalence from l5 as well, creating a conjunction where only one biconditional was specified.", "Assumption l7 correctly captures the equivalence between '2 < 2^(n+1)' and '1 < 2^n' as stated in natural language.", "Assumption l8 correctly states that '1 < 2^n' holds for all n \u2265 1, matching the natural language exactly.", "The conclusion ts_1 correctly formalizes that 'a_n < b_n' holds for all integers n \u2265 1. The additional context assumptions (tc_1, tc_2, l1, l4) provide helpful background information that doesn't contradict the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    