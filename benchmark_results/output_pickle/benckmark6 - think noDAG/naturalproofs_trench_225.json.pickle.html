
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If a sequence $\{u_n\}$ in a metric space $(A,\rho)$ is convergent$,$
then it is a Cauchy sequence.

Proof: Suppose that $\lim_{n	o\infty}u_n=u$. If $\epsilon>0$, there is an integer
$N$ such that
$\rho(u_n,u)<\epsilon/2$ if $n>N$. Therefore, if $m$, $n>N$, then
$$
\rho(u_n,u_m)\le\rho(u_n,u)+\rho(u,u_m)<\epsilon.
$$
\vskip-2em
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If a sequence \\({u_n}\\) in a metric space \\((A,\\rho)\\) is convergent", "statement": "Premise:\n\u2022 \\({u_n}\\) is a convergent sequence in a metric space \\((A,\\rho)\\) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A)\n(tc_1 : \u2203 x : A, Filter.Tendsto u Filter.atTop (nhds x))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the metric space structure. While the natural language uses notation (A,\u03c1), Lean's [MetricSpace A] typeclass provides the same mathematical structure including the metric \u03c1", "The sequence {u_n} is correctly formalized as u : \u2115 \u2192 A, representing a function from natural numbers to the metric space A", "The convergence condition is perfectly captured. The Lean statement \u2203 x : A, Filter.Tendsto u Filter.atTop (nhds x) precisely formalizes that the sequence u converges to some limit point x in the metric space"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Suppose that $\\lim_{n\\to\\infty}u_n=u$. If $\\epsilon>0$, there is an integer\n$N$ such that\n$\\rho(u_n,u)<\\epsilon/2$ if $n>N$.", "statement": "We assume:\n\u2022 \\({u_n}\\) is a convergent sequence in a metric space \\((A,\\rho)\\) [tc_1].\nTherefore, we conclude:\n\u2022 For the convergent sequence \\({u_n}\\), there exists a limit $u \\in A$ such that for any $\\epsilon > 0$, there exists an integer $N$ where for all $n > N$, we have $\\rho(u_n, u) < \\epsilon/2$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A) (u_limit : A)\n  (h_conv : Filter.Tendsto u Filter.atTop (nhds u_limit)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n \u2265 N \u2192 m \u2265 N \u2192 \n    dist (u n) (u m) < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A) (u_limit : A)\n  (h_conv : Filter.Tendsto u Filter.atTop (nhds u_limit)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n \u2265 N \u2192 m \u2265 N \u2192 \n    dist (u n) (u m) < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n \u2265 N \u2192 m \u2265 N \u2192 dist (u n) (u m) < \u03b5 := by\n    intro \u03b5 h\u03b5\n    have h\u2081 : \u2203 N : \u2115, \u2200 n : \u2115, n \u2265 N \u2192 dist (u n) u_limit < \u03b5 / 2 := by\n      -- Use the fact that the sequence converges to u_limit to find N such that for all n \u2265 N, dist (u n) u_limit < \u03b5 / 2\n      have h\u2082 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n : \u2115, n \u2265 N \u2192 dist (u n) u_limit < \u03b5 := by\n        intro \u03b5 h\u03b5\n        -- Use the metric space property to translate the filter statement into an \u03b5-N statement\n        have h\u2083 : Filter.Tendsto u Filter.atTop (nhds u_limit) := h_conv\n        -- Use the definition of tendsto in metric spaces to get the \u03b5-N statement\n        have h\u2084 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n : \u2115, n \u2265 N \u2192 dist (u n) u_limit < \u03b5 := by\n          intro \u03b5 h\u03b5\n          -- Use the fact that the sequence converges to u_limit\n          have h\u2085 : Filter.Tendsto u Filter.atTop (nhds u_limit) := h_conv\n          -- Use the metric space property to get the \u03b5-N statement\n          rw [Metric.tendsto_atTop] at h\u2085\n          -- Get the N from the \u03b5-N statement\n          obtain \u27e8N, hN\u27e9 := h\u2085 \u03b5 h\u03b5\n          refine' \u27e8N, _\u27e9\n          intro n hn\n          -- Use the \u03b5-N statement to get the bound\n          exact hN n hn\n        -- Use the \u03b5-N statement to get the N\n        exact h\u2084 \u03b5 h\u03b5\n      -- Use the \u03b5-N statement to get the N for \u03b5/2\n      have h\u2083 : \u03b5 / 2 > 0 := by linarith\n      have h\u2084 : \u2203 N : \u2115, \u2200 n : \u2115, n \u2265 N \u2192 dist (u n) u_limit < \u03b5 / 2 := h\u2082 (\u03b5 / 2) h\u2083\n      -- Get the N for \u03b5/2\n      exact h\u2084\n    -- Obtain the N from the previous step\n    obtain \u27e8N, hN\u27e9 := h\u2081\n    -- Show that for all n, m \u2265 N, dist (u n) (u m) < \u03b5\n    refine' \u27e8N, _\u27e9\n    intro n m hn hm\n    -- Use the triangle inequality to bound dist (u n) (u m)\n    have h\u2082 : dist (u n) (u m) \u2264 dist (u n) u_limit + dist (u_limit) (u m) := by\n      -- Apply the triangle inequality\n      apply dist_triangle\n    -- Use the fact that dist (u n) u_limit < \u03b5 / 2 and dist (u m) u_limit < \u03b5 / 2\n    have h\u2083 : dist (u n) u_limit < \u03b5 / 2 := hN n hn\n    have h\u2084 : dist (u m) u_limit < \u03b5 / 2 := hN m hm\n    have h\u2085 : dist (u_limit) (u m) = dist (u m) u_limit := by\n      -- Use the symmetry of the distance function\n      rw [dist_comm]\n    -- Combine the inequalities to get dist (u n) (u m) < \u03b5\n    have h\u2086 : dist (u n) (u m) < \u03b5 := by\n      calc\n        dist (u n) (u m) \u2264 dist (u n) u_limit + dist (u_limit) (u m) := h\u2082\n        _ = dist (u n) u_limit + dist (u m) u_limit := by rw [h\u2085]\n        _ < \u03b5 / 2 + \u03b5 / 2 := by\n          -- Use the fact that dist (u n) u_limit < \u03b5 / 2 and dist (u m) u_limit < \u03b5 / 2\n          linarith\n        _ = \u03b5 := by ring\n    -- Conclude the proof\n    exact h\u2086\n  -- Use the main result to conclude the proof\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 51, "column": 10, "endLine": 51, "endColumn": 19, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  Nat.dist ?n ?m\nA : Type u_1\ninst\u271d : MetricSpace A\nu : \u2115 \u2192 A\nu_limit : A\nh_conv : Tendsto u atTop (\ud835\udcdd u_limit)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nN : \u2115\nhN : \u2200 n \u2265 N, Dist.dist (u n) u_limit < \u03b5 / 2\nn m : \u2115\nhn : n \u2265 N\nhm : m \u2265 N\nh\u2082 : Dist.dist (u n) (u m) \u2264 Dist.dist (u n) u_limit + Dist.dist u_limit (u m)\nh\u2083 : Dist.dist (u n) u_limit < \u03b5 / 2\nh\u2084 : Dist.dist (u m) u_limit < \u03b5 / 2\n\u22a2 Dist.dist u_limit (u m) = Dist.dist (u m) u_limit"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The natural language describes the definition of sequence convergence (for any \u03b5 > 0, terms eventually get within \u03b5/2 of the limit), while the Lean formalization proves the Cauchy criterion (for any \u03b5 > 0, terms eventually get within \u03b5 of each other). These are fundamentally different mathematical statements, even though both relate to convergent sequences. The Lean code is missing the key component of relating sequence terms to their limit point.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language describes the definition of sequence convergence (for any \u03b5 > 0, terms eventually get within \u03b5/2 of the limit), while the Lean formalization proves the Cauchy criterion (for any \u03b5 > 0, terms eventually get within \u03b5 of each other). These are fundamentally different mathematical statements, even though both relate to convergent sequences. The Lean code is missing the key component of relating sequence terms to their limit point.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "$\\rho(u_n,u_m)\\le\\rho(u_n,u)+\\rho(u,u_m)$", "statement": "We assume:\n\u2022 \\({u_n}\\) is a convergent sequence in a metric space \\((A,\\rho)\\) [tc_1].\n\u2022 For the convergent sequence \\({u_n}\\), there exists a limit $u \\in A$ such that for any $\\epsilon > 0$, there exists an integer $N$ where for all $n > N$, we have $\\rho(u_n, u) < \\epsilon/2$ [l1].\nTherefore, we conclude:\n\u2022 For any $n, m$ and the limit $u$ from [l1], the triangle inequality holds in the metric space \\((A,\\rho)\\): $\\rho(u_n, u_m) \\le \\rho(u_n, u) + \\rho(u, u_m)$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A) (u_limit : A)\n  (h_conv : Filter.Tendsto u Filter.atTop (nhds u_limit))\n  (h_l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n : \u2115, n > N \u2192 dist (u n) u_limit < \u03b5/2) :\n  \u2200 n m : \u2115, \u2200 \u03b5 > 0, dist (u n) u_limit < \u03b5/2 \u2192 dist (u m) u_limit < \u03b5/2 \u2192 \n    dist (u n) (u m) \u2264 \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A) (u_limit : A)\n  (h_conv : Filter.Tendsto u Filter.atTop (nhds u_limit))\n  (h_l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n : \u2115, n > N \u2192 dist (u n) u_limit < \u03b5/2) :\n  \u2200 n m : \u2115, \u2200 \u03b5 > 0, dist (u n) u_limit < \u03b5/2 \u2192 dist (u m) u_limit < \u03b5/2 \u2192 \n    dist (u n) (u m) \u2264 \u03b5 := by\n  have h_main : \u2200 (n m : \u2115) (\u03b5 : \u211d), \u03b5 > 0 \u2192 dist (u n) u_limit < \u03b5/2 \u2192 dist (u m) u_limit < \u03b5/2 \u2192 dist (u n) (u m) \u2264 \u03b5 := by\n    intro n m \u03b5 h\u03b5 h\u2081 h\u2082\n    have h\u2083 : dist (u n) (u m) \u2264 dist (u n) u_limit + dist (u m) u_limit := by\n      -- Apply the triangle inequality\n      calc\n        dist (u n) (u m) \u2264 dist (u n) u_limit + dist (u_limit) (u m) := by\n          -- Use the triangle inequality for metric spaces\n          have h\u2084 : dist (u n) (u m) \u2264 dist (u n) u_limit + dist (u_limit) (u m) := by\n            apply dist_triangle\n          exact h\u2084\n        _ = dist (u n) u_limit + dist (u m) u_limit := by\n          -- Use the symmetry of distance\n          rw [dist_comm (u_limit) (u m)]\n    have h\u2084 : (dist (u n) u_limit : \u211d) + dist (u m) u_limit < \u03b5 := by\n      -- Sum the two given inequalities\n      have h\u2085 : (dist (u n) u_limit : \u211d) < \u03b5 / 2 := by exact_mod_cast h\u2081\n      have h\u2086 : (dist (u m) u_limit : \u211d) < \u03b5 / 2 := by exact_mod_cast h\u2082\n      linarith\n    have h\u2085 : (dist (u n) (u m) : \u211d) < \u03b5 := by\n      -- Use the transitivity of inequalities\n      have h\u2086 : (dist (u n) (u m) : \u211d) \u2264 (dist (u n) u_limit : \u211d) + (dist (u m) u_limit : \u211d) := by\n        exact_mod_cast h\u2083\n      have h\u2087 : (dist (u n) u_limit : \u211d) + (dist (u m) u_limit : \u211d) < \u03b5 := by exact_mod_cast h\u2084\n      -- Use the fact that if a \u2264 b and b < c, then a < c\n      have h\u2088 : (dist (u n) (u m) : \u211d) < \u03b5 := by\n        linarith\n      exact h\u2088\n    -- Conclude the proof by showing that < \u03b5 implies \u2264 \u03b5\n    have h\u2086 : dist (u n) (u m) \u2264 \u03b5 := by\n      exact le_of_lt (by exact_mod_cast h\u2085)\n    exact h\u2086\n  \n  intro n m \u03b5 h\u03b5 h\u2081 h\u2082\n  have h\u2083 : dist (u n) (u m) \u2264 \u03b5 := by\n    have h\u2084 : dist (u n) u_limit < \u03b5/2 := h\u2081\n    have h\u2085 : dist (u m) u_limit < \u03b5/2 := h\u2082\n    have h\u2086 : \u03b5 > (0 : \u211d) := by exact_mod_cast h\u03b5\n    have h\u2087 : dist (u n) (u m) \u2264 \u03b5 := h_main n m \u03b5 h\u2086 h\u2084 h\u2085\n    exact h\u2087\n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The metric space setup and sequence convergence are correctly formalized with appropriate types and convergence condition using Filter.Tendsto.", "The convergence condition [l1] is perfectly captured with the exact \u03b5/2 bound and proper quantifier structure (\u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N).", "The conclusion [l2] has a major inconsistency. The natural language states the general triangle inequality \u03c1(u_n, u_m) \u2264 \u03c1(u_n, u) + \u03c1(u, u_m), but the Lean formalization proves a different statement: that if both distances to the limit are less than \u03b5/2, then the distance between sequence terms is at most \u03b5. While mathematically related, these are fundamentally different claims."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The metric space setup and sequence convergence are correctly formalized with appropriate types and convergence condition using Filter.Tendsto.', 'The convergence condition [l1] is perfectly captured with the exact \u03b5/2 bound and proper quantifier structure (\u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N).', 'The conclusion [l2] has a major inconsistency. The natural language states the general triangle inequality \u03c1(u_n, u_m) \u2264 \u03c1(u_n, u) + \u03c1(u, u_m), but the Lean formalization proves a different statement: that if both distances to the limit are less than \u03b5/2, then the distance between sequence terms is at most \u03b5. While mathematically related, these are fundamentally different claims.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, if $m$, $n>N$, then\n$$\n\\rho(u_n,u_m)\\le\\rho(u_n,u)+\\rho(u,u_m)<\\epsilon.\n$$", "statement": "We assume:\n\u2022 \\({u_n}\\) is a convergent sequence in a metric space \\((A,\\rho)\\) [tc_1].\n\u2022 For the convergent sequence \\({u_n}\\), there exists a limit $u \\in A$ such that for any $\\epsilon > 0$, there exists an integer $N$ where for all $n > N$, we have $\\rho(u_n, u) < \\epsilon/2$ [l1].\n\u2022 For any $n, m$ and the limit $u$ from [l1], the triangle inequality holds in the metric space \\((A,\\rho)\\): $\\rho(u_n, u_m) \\le \\rho(u_n, u) + \\rho(u, u_m)$ [l2].\nTherefore, we conclude:\n\u2022 For the given $\\epsilon > 0$ and the corresponding integer $N$ from [l1], if $m > N$ and $n > N$, then $\\rho(u_n, u_m) < \\epsilon$ [l3].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A) (u_limit : A)\n  (h_conv : Filter.Tendsto u Filter.atTop (nhds u_limit))\n  (h_l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n : \u2115, n > N \u2192 dist (u n) u_limit < \u03b5/2)\n  (h_l2 : \u2200 n m : \u2115, \u2200 \u03b5 > 0, dist (u n) u_limit < \u03b5/2 \u2192 dist (u m) u_limit < \u03b5/2 \u2192 \n    dist (u n) (u m) \u2264 \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n > N \u2192 m > N \u2192 dist (u n) (u m) < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A) (u_limit : A)\n  (h_conv : Filter.Tendsto u Filter.atTop (nhds u_limit))\n  (h_l1 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n : \u2115, n > N \u2192 dist (u n) u_limit < \u03b5/2)\n  (h_l2 : \u2200 n m : \u2115, \u2200 \u03b5 > 0, dist (u n) u_limit < \u03b5/2 \u2192 dist (u m) u_limit < \u03b5/2 \u2192 \n    dist (u n) (u m) \u2264 \u03b5) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n > N \u2192 m > N \u2192 dist (u n) (u m) < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n > N \u2192 m > N \u2192 dist (u n) (u m) < \u03b5 := by\n    intro \u03b5 h\u03b5\n    have h\u2081 : \u2203 N : \u2115, \u2200 n : \u2115, n > N \u2192 dist (u n) u_limit < \u03b5 / 2 := by\n      -- Use the given condition h_l1 to find N such that for all n > N, dist(u_n, u_limit) < \u03b5/2\n      obtain \u27e8N, hN\u27e9 := h_l1 \u03b5 h\u03b5\n      exact \u27e8N, fun n hn => hN n hn\u27e9\n    obtain \u27e8N, hN\u27e9 := h\u2081\n    use N\n    intro n m hn hm\n    have h\u2082 : dist (u n) u_limit < \u03b5 / 2 := hN n hn\n    have h\u2083 : dist (u m) u_limit < \u03b5 / 2 := hN m hm\n    have h\u2084 : dist (u n) (u m) < \u03b5 := by\n      -- Use the triangle inequality to bound dist(u_n, u_m)\n      have h\u2085 : dist (u n) (u m) \u2264 dist (u n) u_limit + dist u_limit (u m) := by\n        -- Apply the triangle inequality: dist(a, b) \u2264 dist(a, c) + dist(c, b)\n        calc\n          dist (u n) (u m) \u2264 dist (u n) u_limit + dist u_limit (u m) := by\n            -- Use the triangle inequality for metric spaces\n            have h\u2085\u2081 : dist (u n) (u m) \u2264 dist (u n) u_limit + dist u_limit (u m) := by\n              calc\n                dist (u n) (u m) = dist (u n) (u m) := rfl\n                _ \u2264 dist (u n) u_limit + dist u_limit (u m) := by\n                  -- Use the triangle inequality\n                  have h\u2085\u2082 : dist (u n) (u m) \u2264 dist (u n) u_limit + dist u_limit (u m) := by\n                    -- Use the triangle inequality for metric spaces\n                    calc\n                      dist (u n) (u m) \u2264 dist (u n) u_limit + dist u_limit (u m) := by\n                        -- Use the triangle inequality\n                        exact dist_triangle (u n) u_limit (u m)\n                      _ = dist (u n) u_limit + dist u_limit (u m) := by rfl\n                  exact h\u2085\u2082\n            exact h\u2085\u2081\n          _ = dist (u n) u_limit + dist u_limit (u m) := by rfl\n      -- Use the fact that dist(u_n, u_limit) < \u03b5/2 and dist(u_m, u_limit) < \u03b5/2 to bound the sum\n      have h\u2086 : dist u_limit (u m) = dist (u m) u_limit := by\n        -- Use the symmetry of the distance function\n        rw [dist_comm u_limit (u m)]\n      have h\u2087 : dist (u n) u_limit + dist u_limit (u m) < \u03b5 / 2 + \u03b5 / 2 := by\n        -- Substitute the inequalities into the sum\n        calc\n          dist (u n) u_limit + dist u_limit (u m) = dist (u n) u_limit + dist (u m) u_limit := by rw [h\u2086]\n          _ < \u03b5 / 2 + \u03b5 / 2 := by\n            -- Use the given inequalities to bound each term\n            linarith\n      have h\u2088 : \u03b5 / 2 + \u03b5 / 2 = \u03b5 := by\n        -- Simplify the sum\n        ring\n      have h\u2089 : dist (u n) u_limit + dist u_limit (u m) < \u03b5 := by\n        -- Combine the inequalities\n        linarith\n      -- Combine all the inequalities to get the final result\n      calc\n        dist (u n) (u m) \u2264 dist (u n) u_limit + dist u_limit (u m) := h\u2085\n        _ < \u03b5 := h\u2089\n    exact h\u2084\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The convergent sequence assumption is correctly formalized using Lean's filter-based convergence definition, which is mathematically equivalent to the natural language statement.", "The limit definition [l1] is accurately translated, with proper quantifier structure and the \u03b5/2 bound correctly preserved.", "The triangle inequality [l2] is incorrectly formalized. The natural language states the standard triangle inequality \u03c1(u_n, u_m) \u2264 \u03c1(u_n, u) + \u03c1(u, u_m), but the Lean version presents a conditional statement involving \u03b5 bounds that fundamentally changes the mathematical meaning.", "The conclusion [l3] correctly captures the Cauchy criterion statement with proper quantifier structure and the relationship between N and the indices n, m.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The convergent sequence assumption is correctly formalized using Lean's filter-based convergence definition, which is mathematically equivalent to the natural language statement.\", 'The limit definition [l1] is accurately translated, with proper quantifier structure and the \u03b5/2 bound correctly preserved.', 'The triangle inequality [l2] is incorrectly formalized. The natural language states the standard triangle inequality \u03c1(u_n, u_m) \u2264 \u03c1(u_n, u) + \u03c1(u, u_m), but the Lean version presents a conditional statement involving \u03b5 bounds that fundamentally changes the mathematical meaning.', 'The conclusion [l3] correctly captures the Cauchy criterion statement with proper quantifier structure and the relationship between N and the indices n, m.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, if $m$, $n>N$, then\n$$\n\\rho(u_n,u_m)\\le\\rho(u_n,u)+\\rho(u,u_m)<\\epsilon.\n$$", "statement": "We assume:\n\u2022 \\({u_n}\\) is a convergent sequence in a metric space \\((A,\\rho)\\) [tc_1].\n\u2022 For the convergent sequence \\({u_n}\\), there exists a limit $u \\in A$ such that for any $\\epsilon > 0$, there exists an integer $N$ where for all $n > N$, we have $\\rho(u_n, u) < \\epsilon/2$ [l1].\n\u2022 For any $n, m$ and the limit $u$ from [l1], the triangle inequality holds in the metric space \\((A,\\rho)\\): $\\rho(u_n, u_m) \\le \\rho(u_n, u) + \\rho(u, u_m)$ [l2].\n\u2022 For any $\\epsilon > 0$, there exists an integer $N$ such that if $m > N$ and $n > N$, then $\\rho(u_n, u_m) < \\epsilon$ [l3].\nTherefore, we conclude:\n\u2022 The sequence \\({u_n}\\) is a Cauchy sequence [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A)\n  (h_conv : \u2203 x : A, Filter.Tendsto u Filter.atTop (nhds x)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n > N \u2192 m > N \u2192 dist (u n) (u m) < \u03b5 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  {A : Type*} [MetricSpace A] (u : \u2115 \u2192 A)\n  (h_conv : \u2203 x : A, Filter.Tendsto u Filter.atTop (nhds x)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n > N \u2192 m > N \u2192 dist (u n) (u m) < \u03b5 := by\n  have h_main : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n m : \u2115, n > N \u2192 m > N \u2192 dist (u n) (u m) < \u03b5 := by\n    intro \u03b5 h\u03b5\n    obtain \u27e8x, hx\u27e9 := h_conv\n    have h\u03b52 : 0 < \u03b5 / 2 := by linarith\n    -- Use the fact that u_n \u2192 x to find N such that for all n \u2265 N, dist (u n) x < \u03b5 / 2\n    have h\u2081 : \u2200\u1da0 (n : \u2115) in Filter.atTop, dist (u n) x < \u03b5 / 2 := by\n      have h\u2082 : Filter.Tendsto u Filter.atTop (nhds x) := hx\n      have h\u2083 : Metric.ball x (\u03b5 / 2) \u2208 nhds x := by\n        apply Metric.mem_nhds_iff.mpr\n        exact \u27e8\u03b5 / 2, by linarith, by simp [Metric.ball]\u27e9\n      have h\u2084 : \u2200\u1da0 (n : \u2115) in Filter.atTop, u n \u2208 Metric.ball x (\u03b5 / 2) := h\u2082 h\u2083\n      filter_upwards [h\u2084] with n hn\n      rw [Metric.mem_ball] at hn\n      exact hn\n    -- Convert the filter eventuality to an explicit N\n    obtain \u27e8N, hN\u27e9 := (Filter.eventually_atTop.mp h\u2081)\n    -- Use N to bound the distance between u_n and u_m for n, m > N\n    use N\n    intro n m hn hm\n    have h\u2082 : dist (u n) x < \u03b5 / 2 := by\n      have h\u2083 : n \u2265 N := by\n        omega\n      exact hN n h\u2083\n    have h\u2083 : dist (u m) x < \u03b5 / 2 := by\n      have h\u2084 : m \u2265 N := by\n        omega\n      exact hN m h\u2084\n    -- Use the triangle inequality to bound dist (u n) (u m)\n    have h\u2084 : dist (u n) (u m) \u2264 dist (u n) x + dist (u m) x := by\n      calc\n        dist (u n) (u m) \u2264 dist (u n) x + dist (x) (u m) := by\n          -- Apply the triangle inequality\n          calc\n            dist (u n) (u m) = dist (u n) (u m) := rfl\n            _ \u2264 dist (u n) x + dist (x) (u m) := by\n              -- Use the triangle inequality: dist a b \u2264 dist a c + dist c b\n              have h\u2085 : dist (u n) (u m) \u2264 dist (u n) x + dist (x) (u m) := by\n                calc\n                  dist (u n) (u m) \u2264 dist (u n) x + dist (x) (u m) := by\n                    -- Use the triangle inequality: dist a b \u2264 dist a c + dist c b\n                    apply dist_triangle (u n) x (u m)\n                  _ = dist (u n) x + dist (x) (u m) := by rfl\n              exact h\u2085\n        _ = dist (u n) x + dist (u m) x := by\n          -- Since dist is symmetric, dist x (u m) = dist (u m) x\n          rw [dist_comm (x : A) (u m)]\n    -- Combine the inequalities to get the final result\n    have h\u2085 : dist (u n) (u m) < \u03b5 := by\n      calc\n        dist (u n) (u m) \u2264 dist (u n) x + dist (u m) x := h\u2084\n        _ < \u03b5 / 2 + \u03b5 / 2 := by\n          -- Use the bounds on dist (u n) x and dist (u m) x\n          linarith\n        _ = \u03b5 := by ring\n    exact h\u2085\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0, "semantic_feedback": ["The convergent sequence assumption is correctly captured with the MetricSpace typeclass and Tendsto condition.", "The specific \u03b5/2 bound mentioned in l1 is not explicitly present in the Lean formalization, though the convergence condition is equivalent. The Lean uses the more general filter-based definition of convergence.", "The triangle inequality is automatically included in the MetricSpace typeclass, correctly capturing this assumption.", "The Cauchy condition l3 is exactly what the theorem conclusion states, perfectly matching the mathematical content.", "The conclusion that the sequence is Cauchy is precisely formalized as the standard definition of a Cauchy sequence.", "Wrong dependencies in Lean4 tactics!"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    