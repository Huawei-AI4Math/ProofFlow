
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $a, b, c$, the following inequality holds:
$$ \sqrt{\\frac{a+b}{c}}+\\sqrt{\\frac{b+c}{a}}+\\sqrt{\\frac{c+a}{b}} \\geq 3\\sqrt{2} $$

Proof: Let $a,b,c>0$. We want to prove $\sqrt{	frac{a+b}{c}}+\sqrt{	frac{b+c}{a}}+\sqrt{	frac{c+a}{b}} \geq 3\sqrt{2}$. Consider the product $(a+b)(b+c)(c+a)$. Since for any $x,y>0$, $x+y \geq 2\sqrt{xy}$, we obtain $a+b \geq 2\sqrt{ab}$, $b+c \geq 2\sqrt{bc}$, and $c+a \geq 2\sqrt{ca}$. Multiplying these inequalities yields $(a+b)(b+c)(c+a) \geq 8abc$. Dividing by $abc>0$, we get $	frac{(a+b)(b+c)(c+a)}{abc} \geq 8$, which is exactly $	frac{a+b}{c}\cdot 	frac{b+c}{a}\cdot 	frac{c+a}{b} \geq 8$. Now let $X=\sqrt{	frac{a+b}{c}},\,Y=\sqrt{	frac{b+c}{a}},\,Z=\sqrt{	frac{c+a}{b}}$. By AMâ€“GM, $X+Y+Z \geq 3\sqrt[3]{XYZ}$. But $$XYZ=\sqrt{	frac{a+b}{c}\cdot 	frac{b+c}{a}\cdot 	frac{c+a}{b}} = \sqrt{	frac{(a+b)(b+c)(c+a)}{abc}}$$, so $X+Y+Z \geq 3\left(	frac{(a+b)(b+c)(c+a)}{abc}ight)^{1/6}$. Since $	frac{(a+b)(b+c)(c+a)}{abc}\geq 8$, it follows that $X+Y+Z \geq 3\cdot 8^{1/6}=3\sqrt{2}$. Therefore, $$ \sqrt{	frac{a+b}{c}}+\sqrt{	frac{b+c}{a}}+\sqrt{	frac{c+a}{b}} \geq 3\sqrt{2} $$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $a,b,c>0$.", "statement": "Premise:\n\u2022 a, b, and c are positive real numbers [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes a, b, and c as individual positive real numbers, but the Lean formalization declares 'a' as a function from natural numbers to real numbers (\u2115 \u2192 \u211d). This is a fundamental type mismatch - the natural language refers to scalar variables while Lean defines a sequence/function.", "The natural language states conditions about three individual variables a, b, and c being positive, but the Lean formalization only addresses the function 'a' being positive for all inputs, and completely omits any mention of variables 'b' and c'. This misses key components from the natural language statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language describes a, b, and c as individual positive real numbers, but the Lean formalization declares 'a' as a function from natural numbers to real numbers (\u2115 \u2192 \u211d). This is a fundamental type mismatch - the natural language refers to scalar variables while Lean defines a sequence/function.\", \"The natural language states conditions about three individual variables a, b, and c being positive, but the Lean formalization only addresses the function 'a' being positive for all inputs, and completely omits any mention of variables 'b' and c'. This misses key components from the natural language statement.\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since for any $x,y>0$, $x+y \\geq 2\\sqrt{xy}$, we obtain $a+b \\geq 2\\sqrt{ab}$, $b+c \\geq 2\\sqrt{bc}$, and $c+a \\geq 2\\sqrt{ca}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1].\nTherefore, we conclude:\n\u2022 $a+b \\geq 2\\sqrt{ab}$, $b+c \\geq 2\\sqrt{bc}$, and $c+a \\geq 2\\sqrt{ca}$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :\n  a + b \u2265 2 * Real.sqrt (a * b) \u2227\n  b + c \u2265 2 * Real.sqrt (b * c) \u2227\n  c + a \u2265 2 * Real.sqrt (c * a) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :\n  a + b \u2265 2 * Real.sqrt (a * b) \u2227\n  b + c \u2265 2 * Real.sqrt (b * c) \u2227\n  c + a \u2265 2 * Real.sqrt (c * a) := by\n  have h\u2081 : a + b \u2265 2 * Real.sqrt (a * b) := by\n    have h\u2081\u2081 : 0 \u2264 Real.sqrt a := Real.sqrt_nonneg a\n    have h\u2081\u2082 : 0 \u2264 Real.sqrt b := Real.sqrt_nonneg b\n    have h\u2081\u2083 : 0 \u2264 Real.sqrt a * Real.sqrt b := by positivity\n    have h\u2081\u2084 : (Real.sqrt a - Real.sqrt b) ^ 2 \u2265 0 := by nlinarith\n    have h\u2081\u2085 : a + b - 2 * (Real.sqrt a * Real.sqrt b) \u2265 0 := by\n      nlinarith [Real.sq_sqrt (le_of_lt ha), Real.sq_sqrt (le_of_lt hb),\n        sq_nonneg (Real.sqrt a - Real.sqrt b)]\n    have h\u2081\u2086 : Real.sqrt (a * b) = Real.sqrt a * Real.sqrt b := by\n      rw [Real.sqrt_mul] <;> linarith\n    nlinarith [Real.sq_sqrt (by positivity : 0 \u2264 a * b)]\n  \n  have h\u2082 : b + c \u2265 2 * Real.sqrt (b * c) := by\n    have h\u2082\u2081 : 0 \u2264 Real.sqrt b := Real.sqrt_nonneg b\n    have h\u2082\u2082 : 0 \u2264 Real.sqrt c := Real.sqrt_nonneg c\n    have h\u2082\u2083 : 0 \u2264 Real.sqrt b * Real.sqrt c := by positivity\n    have h\u2082\u2084 : (Real.sqrt b - Real.sqrt c) ^ 2 \u2265 0 := by nlinarith\n    have h\u2082\u2085 : b + c - 2 * (Real.sqrt b * Real.sqrt c) \u2265 0 := by\n      nlinarith [Real.sq_sqrt (le_of_lt hb), Real.sq_sqrt (le_of_lt hc),\n        sq_nonneg (Real.sqrt b - Real.sqrt c)]\n    have h\u2082\u2086 : Real.sqrt (b * c) = Real.sqrt b * Real.sqrt c := by\n      rw [Real.sqrt_mul] <;> linarith\n    nlinarith [Real.sq_sqrt (by positivity : 0 \u2264 b * c)]\n  \n  have h\u2083 : c + a \u2265 2 * Real.sqrt (c * a) := by\n    have h\u2083\u2081 : 0 \u2264 Real.sqrt c := Real.sqrt_nonneg c\n    have h\u2083\u2082 : 0 \u2264 Real.sqrt a := Real.sqrt_nonneg a\n    have h\u2083\u2083 : 0 \u2264 Real.sqrt c * Real.sqrt a := by positivity\n    have h\u2083\u2084 : (Real.sqrt c - Real.sqrt a) ^ 2 \u2265 0 := by nlinarith\n    have h\u2083\u2085 : c + a - 2 * (Real.sqrt c * Real.sqrt a) \u2265 0 := by\n      nlinarith [Real.sq_sqrt (le_of_lt hc), Real.sq_sqrt (le_of_lt ha),\n        sq_nonneg (Real.sqrt c - Real.sqrt a)]\n    have h\u2083\u2086 : Real.sqrt (c * a) = Real.sqrt c * Real.sqrt a := by\n      rw [Real.sqrt_mul] <;> linarith\n    nlinarith [Real.sq_sqrt (by positivity : 0 \u2264 c * a)]\n  \n  have h_main : a + b \u2265 2 * Real.sqrt (a * b) \u2227 b + c \u2265 2 * Real.sqrt (b * c) \u2227 c + a \u2265 2 * Real.sqrt (c * a) := by\n    exact \u27e8h\u2081, h\u2082, h\u2083\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and positivity assumptions are correctly formalized. The Lean code properly declares a, b, c as real numbers and captures the positivity constraints using strict inequalities, which is the standard interpretation of 'positive real numbers'.", "The three inequality conclusions are accurately translated. Each mathematical expression (addition, square root, multiplication) is properly represented, and the conjunction of all three statements is correctly formalized using the logical AND operator."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Multiplying these inequalities yields $(a+b)(b+c)(c+a) \\geq 8abc$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1].\n\u2022 $a+b \\geq 2\\sqrt{ab}$, $b+c \\geq 2\\sqrt{bc}$, and $c+a \\geq 2\\sqrt{ca}$ [l1].\nTherefore, we conclude:\n\u2022 $(a+b)(b+c)(c+a) \\geq 8abc$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h1 : a + b \u2265 2 * Real.sqrt (a * b))\n  (h2 : b + c \u2265 2 * Real.sqrt (b * c))\n  (h3 : c + a \u2265 2 * Real.sqrt (c * a)) :\n  (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h1 : a + b \u2265 2 * Real.sqrt (a * b))\n  (h2 : b + c \u2265 2 * Real.sqrt (b * c))\n  (h3 : c + a \u2265 2 * Real.sqrt (c * a)) :\n  (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := by\n  have h4 : (a + b) * (b + c) * (c + a) \u2265 8 * (Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a)) := by\n    have h4\u2081 : 0 \u2264 Real.sqrt (a * b) := Real.sqrt_nonneg (a * b)\n    have h4\u2082 : 0 \u2264 Real.sqrt (b * c) := Real.sqrt_nonneg (b * c)\n    have h4\u2083 : 0 \u2264 Real.sqrt (c * a) := Real.sqrt_nonneg (c * a)\n    have h4\u2084 : 0 \u2264 Real.sqrt (a * b) * Real.sqrt (b * c) := by positivity\n    have h4\u2085 : 0 \u2264 Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a) := by positivity\n    have h4\u2086 : 0 < a + b := by linarith\n    have h4\u2087 : 0 < b + c := by linarith\n    have h4\u2088 : 0 < c + a := by linarith\n    have h4\u2089 : 0 < (a + b) * (b + c) := by positivity\n    have h4\u2081\u2080 : 0 < (a + b) * (b + c) * (c + a) := by positivity\n    have h4\u2081\u2081 : 2 * Real.sqrt (a * b) \u2265 0 := by positivity\n    have h4\u2081\u2082 : 2 * Real.sqrt (b * c) \u2265 0 := by positivity\n    have h4\u2081\u2083 : 2 * Real.sqrt (c * a) \u2265 0 := by positivity\n    calc\n      (a + b) * (b + c) * (c + a) \u2265 (2 * Real.sqrt (a * b)) * (2 * Real.sqrt (b * c)) * (2 * Real.sqrt (c * a)) := by\n        gcongr <;>\n          (try norm_num) <;>\n          (try linarith) <;>\n          (try assumption) <;>\n          (try nlinarith [Real.sqrt_nonneg (a * b), Real.sqrt_nonneg (b * c), Real.sqrt_nonneg (c * a)])\n      _ = 8 * (Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a)) := by\n        ring_nf\n        <;>\n        (try norm_num) <;>\n        (try linarith)\n  \n  have h5 : Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a) = a * b * c := by\n    have h5\u2081 : Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a) = Real.sqrt ((a * b) * (b * c) * (c * a)) := by\n      have h5\u2081\u2081 : 0 \u2264 a * b := by positivity\n      have h5\u2081\u2082 : 0 \u2264 b * c := by positivity\n      have h5\u2081\u2083 : 0 \u2264 c * a := by positivity\n      have h5\u2081\u2084 : 0 \u2264 (a * b) * (b * c) := by positivity\n      have h5\u2081\u2085 : 0 \u2264 (a * b) * (b * c) * (c * a) := by positivity\n      have h5\u2081\u2086 : Real.sqrt (a * b) * Real.sqrt (b * c) = Real.sqrt ((a * b) * (b * c)) := by\n        rw [\u2190 Real.sqrt_mul] <;> positivity\n      calc\n        Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a) = (Real.sqrt (a * b) * Real.sqrt (b * c)) * Real.sqrt (c * a) := by ring\n        _ = Real.sqrt ((a * b) * (b * c)) * Real.sqrt (c * a) := by rw [h5\u2081\u2086]\n        _ = Real.sqrt (((a * b) * (b * c)) * (c * a)) := by\n          rw [\u2190 Real.sqrt_mul] <;> positivity\n        _ = Real.sqrt ((a * b) * (b * c) * (c * a)) := by ring_nf\n    rw [h5\u2081]\n    have h5\u2082 : Real.sqrt ((a * b) * (b * c) * (c * a)) = a * b * c := by\n      have h5\u2082\u2081 : 0 \u2264 a * b := by positivity\n      have h5\u2082\u2082 : 0 \u2264 b * c := by positivity\n      have h5\u2082\u2083 : 0 \u2264 c * a := by positivity\n      have h5\u2082\u2084 : 0 \u2264 (a * b) * (b * c) := by positivity\n      have h5\u2082\u2085 : 0 \u2264 (a * b) * (b * c) * (c * a) := by positivity\n      have h5\u2082\u2086 : (a * b) * (b * c) * (c * a) = (a * b * c) ^ 2 := by\n        ring_nf\n        <;>\n        (try norm_num) <;>\n        (try linarith)\n      rw [h5\u2082\u2086]\n      have h5\u2082\u2087 : Real.sqrt ((a * b * c) ^ 2) = a * b * c := by\n        rw [Real.sqrt_eq_iff_sq_eq] <;>\n        (try nlinarith [mul_pos ha hb, mul_pos hb hc, mul_pos hc ha]) <;>\n        (try positivity) <;>\n        (try ring_nf) <;>\n        (try nlinarith)\n      rw [h5\u2082\u2087]\n    rw [h5\u2082]\n  \n  have h6 : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c := by\n    calc\n      (a + b) * (b + c) * (c + a) \u2265 8 * (Real.sqrt (a * b) * Real.sqrt (b * c) * Real.sqrt (c * a)) := h4\n      _ = 8 * (a * b * c) := by\n        rw [h5]\n        <;> ring_nf\n      _ = 8 * a * b * c := by ring\n  \n  exact h6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate real number types and strict inequality constraints.", "All three inequality assumptions are accurately translated with proper mathematical notation, correctly using Real.sqrt for square root operations.", "The conclusion perfectly captures the mathematical relationship with proper operator precedence and multiplication notation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Dividing by $abc>0$, we get $\tfrac{(a+b)(b+c)(c+a)}{abc} \\geq 8$,", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1].\n\u2022 $(a+b)(b+c)(c+a) \\geq 8abc$ [l2].\nTherefore, we conclude:\n\u2022 $\\frac{(a+b)(b+c)(c+a)}{abc} \\geq 8$ [l3].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c) :\n  (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h : (a + b) * (b + c) * (c + a) \u2265 8 * a * b * c) :\n  (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := by\n  have h_main : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := by\n    have h\u2081 : 0 < a * b * c := mul_pos (mul_pos ha hb) hc\n    -- Divide both sides of the given inequality by (a * b * c)\n    have h\u2082 : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := by\n      -- Use the fact that (a + b)(b + c)(c + a) \u2265 8abc to prove the inequality\n      calc\n        (a + b) * (b + c) * (c + a) / (a * b * c) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by rfl\n        _ \u2265 (8 * a * b * c) / (a * b * c) := by\n          -- Since (a + b)(b + c)(c + a) \u2265 8abc, dividing both sides by (a * b * c) preserves the inequality\n          gcongr\n          <;> nlinarith [ha, hb, hc]\n        _ = 8 := by\n          -- Simplify the right-hand side\n          have h\u2083 : a \u2260 0 := by linarith\n          have h\u2084 : b \u2260 0 := by linarith\n          have h\u2085 : c \u2260 0 := by linarith\n          field_simp [h\u2083, h\u2084, h\u2085]\n          <;> ring\n          <;> field_simp [h\u2083, h\u2084, h\u2085]\n          <;> linarith\n    exact h\u2082\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized with appropriate types and inequality conditions", "The inequality assumption is accurately translated with proper operator precedence and mathematical meaning preserved", "The conclusion correctly represents the quotient inequality using Lean's division operator while maintaining the exact mathematical relationship"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "which is exactly $\tfrac{a+b}{c}\\cdot \tfrac{b+c}{a}\\cdot \tfrac{c+a}{b} \\geq 8$.", "statement": "We assume:\n\u2022 $\\frac{(a+b)(b+c)(c+a)}{abc} \\geq 8$ [l3].\nTherefore, we conclude:\n\u2022 $\\frac{a+b}{c} \\cdot \\frac{b+c}{a} \\cdot \\frac{c+a}{b} \\geq 8$ [l4].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8) :\n  (a + b) / c * (b + c) / a * (c + a) / b \u2265 8 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (h : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8) :\n  (a + b) / c * (b + c) / a * (c + a) / b \u2265 8 := by\n  have h_main : (a + b) / c * (b + c) / a * (c + a) / b = (a + b) * (b + c) * (c + a) / (a * b * c) := by\n    have h\u2081 : 0 < a * b := mul_pos ha hb\n    have h\u2082 : 0 < a * b * c := mul_pos h\u2081 hc\n    have h\u2083 : 0 < a * b * c * a := by positivity\n    have h\u2084 : 0 < a * b * c * b := by positivity\n    have h\u2085 : 0 < a * b * c * c := by positivity\n    field_simp [ha.ne', hb.ne', hc.ne']\n    <;> ring\n    <;> field_simp [ha.ne', hb.ne', hc.ne']\n    <;> ring\n  \n  have h_final : (a + b) / c * (b + c) / a * (c + a) / b \u2265 8 := by\n    have h\u2081 : (a + b) / c * (b + c) / a * (c + a) / b = (a + b) * (b + c) * (c + a) / (a * b * c) := by\n      rw [h_main]\n    rw [h\u2081]\n    have h\u2082 : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8 := h\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content of the natural language. The premise (a+b)(b+c)(c+a)/(abc) \u2265 8 is accurately translated, and the conclusion (a+b)/c \u00b7 (b+c)/a \u00b7 (c+a)/b \u2265 8 is mathematically equivalent to the premise. The additional positivity constraints (a,b,c > 0) in Lean are logically necessary for the validity of the expressions and represent good mathematical practice, even though not explicitly stated in the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now let $X=\\sqrt{\tfrac{a+b}{c}},\\,Y=\\sqrt{\tfrac{b+c}{a}},\\,Z=\\sqrt{\tfrac{c+a}{b}}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1].\nDefinition:\n\u2022 Let $X = \\sqrt{\\frac{a+b}{c}}$, $Y = \\sqrt{\\frac{b+c}{a}}$, and $Z = \\sqrt{\\frac{c+a}{b}}$ [def_1].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b c : \u211d) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n\nnoncomputable def X : \u211d := Real.sqrt ((a + b) / c)\nnoncomputable def Y : \u211d := Real.sqrt ((b + c) / a)  \nnoncomputable def Z : \u211d := Real.sqrt ((c + a) / b)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that a, b, and c are positive real numbers through the variable declarations (a b c : \u211d) and the positivity conditions (ha : 0 < a) (hb : 0 < b) (hc : 0 < c). This matches the natural language condition exactly.", "The Lean definitions of X, Y, and Z perfectly match the mathematical expressions. X := Real.sqrt ((a + b) / c) corresponds to $X = \\sqrt{\\frac{a+b}{c}}$, Y := Real.sqrt ((b + c) / a) corresponds to $Y = \\sqrt{\\frac{b+c}{a}}$, and Z := Real.sqrt ((c + a) / b) corresponds to $Z = \\sqrt{\\frac{c+a}{b}}$. The noncomputable keyword is appropriate for square root operations and doesn't change the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "By AM\u2013GM, $X+Y+Z \\geq 3\\sqrt[3]{XYZ}$.", "statement": "We assume:\n\u2022 a, b, and c are positive real numbers [tc_1].\n\u2022 Let $X = \\sqrt{\\frac{a+b}{c}}$, $Y = \\sqrt{\\frac{b+c}{a}}$, and $Z = \\sqrt{\\frac{c+a}{b}}$ [def_1].\nTherefore, we conclude:\n\u2022 $X+Y+Z \\geq 3\\sqrt[3]{XYZ}$ [l5].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d)\n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a))\n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d)\n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a))\n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d) := by\n  have hX_nonneg : X \u2265 0 := by\n    rw [hX]\n    apply Real.sqrt_nonneg\n  \n  have hY_nonneg : Y \u2265 0 := by\n    rw [hY]\n    apply Real.sqrt_nonneg\n  \n  have hZ_nonneg : Z \u2265 0 := by\n    rw [hZ]\n    apply Real.sqrt_nonneg\n  \n  have hXYZ_nonneg : X * Y * Z \u2265 0 := by\n    have h\u2081 : 0 \u2264 X := hX_nonneg\n    have h\u2082 : 0 \u2264 Y := hY_nonneg\n    have h\u2083 : 0 \u2264 Z := hZ_nonneg\n    have h\u2084 : 0 \u2264 X * Y := by positivity\n    have h\u2085 : 0 \u2264 X * Y * Z := by positivity\n    linarith\n  \n  have h_sum_div_nonneg : (X + Y + Z) / 3 \u2265 0 := by\n    have h\u2081 : 0 \u2264 X := hX_nonneg\n    have h\u2082 : 0 \u2264 Y := hY_nonneg\n    have h\u2083 : 0 \u2264 Z := hZ_nonneg\n    have h\u2084 : 0 \u2264 X + Y + Z := by linarith\n    linarith\n  \n  have h_amgm : X * Y * Z \u2264 ((X + Y + Z) / 3) ^ 3 := by\n    have h\u2081 : 0 \u2264 X := hX_nonneg\n    have h\u2082 : 0 \u2264 Y := hY_nonneg\n    have h\u2083 : 0 \u2264 Z := hZ_nonneg\n    nlinarith [sq_nonneg (X - Y), sq_nonneg (Y - Z), sq_nonneg (Z - X),\n      sq_nonneg (X + Y + Z), sq_nonneg (X + Y + Z - 3 * X),\n      sq_nonneg (X + Y + Z - 3 * Y), sq_nonneg (X + Y + Z - 3 * Z)]\n  \n  have h_main : (X * Y * Z) ^ (1 / 3 : \u211d) \u2264 (X + Y + Z) / 3 := by\n    have h\u2081 : 0 \u2264 X * Y * Z := by positivity\n    have h\u2082 : 0 \u2264 (X + Y + Z) / 3 := by positivity\n    have h\u2083 : (X * Y * Z : \u211d) \u2264 ((X + Y + Z) / 3 : \u211d) ^ 3 := by\n      exact_mod_cast h_amgm\n    have h\u2084 : (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) \u2264 ((X + Y + Z) / 3 : \u211d) := by\n      -- Use the property that the cube root function is increasing\n      have h\u2085 : 0 \u2264 (X * Y * Z : \u211d) := by positivity\n      have h\u2086 : 0 \u2264 ((X + Y + Z) / 3 : \u211d) := by positivity\n      -- Use the fact that if a \u2264 b, then a^(1/3) \u2264 b^(1/3)\n      have h\u2087 : (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) \u2264 (((X + Y + Z) / 3 : \u211d) ^ 3) ^ (1 / 3 : \u211d) := by\n        -- Apply the power function which is increasing for positive bases\n        exact Real.rpow_le_rpow (by positivity) h\u2083 (by norm_num)\n      -- Simplify the right-hand side\n      have h\u2088 : (((X + Y + Z) / 3 : \u211d) ^ 3) ^ (1 / 3 : \u211d) = (X + Y + Z) / 3 := by\n        -- Use the property of exponents (a^b)^c = a^(b*c)\n        have h\u2089 : 0 \u2264 ((X + Y + Z) / 3 : \u211d) := by positivity\n        have h\u2081\u2080 : (((X + Y + Z) / 3 : \u211d) ^ 3) ^ (1 / 3 : \u211d) = ((X + Y + Z) / 3 : \u211d) := by\n          rw [\u2190 Real.rpow_nat_cast]\n          rw [\u2190 Real.rpow_mul] <;>\n          (try norm_num) <;>\n          (try linarith) <;>\n          (try positivity)\n          <;>\n          ring_nf\n          <;>\n          norm_num\n        rw [h\u2081\u2080]\n      -- Combine the results\n      calc\n        (X * Y * Z : \u211d) ^ (1 / 3 : \u211d) \u2264 (((X + Y + Z) / 3 : \u211d) ^ 3) ^ (1 / 3 : \u211d) := h\u2087\n        _ = (X + Y + Z) / 3 := by rw [h\u2088]\n    exact_mod_cast h\u2084\n  \n  have h_final : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d) := by\n    have h\u2081 : (X + Y + Z) / 3 \u2265 (X * Y * Z) ^ (1 / 3 : \u211d) := by\n      linarith\n    have h\u2082 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := by\n      linarith\n    exact h\u2082\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The positivity constraints for a, b, and c are correctly captured in Lean with the appropriate strict inequality operators.", "The definitions of X, Y, and Z are mathematically equivalent between natural language and Lean, with proper use of Real.sqrt and division operations.", "The inequality conclusion is correctly formalized, with the cube root properly expressed as exponentiation to 1/3 and appropriate operator precedence."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "But $$XYZ=\\sqrt{\tfrac{a+b}{c}\\cdot \tfrac{b+c}{a}\\cdot \tfrac{c+a}{b}} = \\sqrt{\tfrac{(a+b)(b+c)(c+a)}{abc}}$$,", "statement": "We assume:\n\u2022 Let $X = \\sqrt{\\frac{a+b}{c}}$, $Y = \\sqrt{\\frac{b+c}{a}}$, and $Z = \\sqrt{\\frac{c+a}{b}}$ [def_1].\nTherefore, we conclude:\n\u2022 $XYZ = \\sqrt{\\frac{(a+b)(b+c)(c+a)}{abc}}$ [l6].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d)\n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a))\n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X * Y * Z = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d)\n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a))\n  (hZ : Z = Real.sqrt ((c + a) / b)) :\n  X * Y * Z = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) := by\n  have h\u2081 : 0 \u2264 (a + b) / c := by\n    apply div_nonneg\n    \u00b7 linarith\n    \u00b7 linarith\n  \n  have h\u2082 : 0 \u2264 (b + c) / a := by\n    apply div_nonneg\n    \u00b7 linarith\n    \u00b7 linarith\n  \n  have h\u2083 : 0 \u2264 (c + a) / b := by\n    apply div_nonneg\n    \u00b7 linarith\n    \u00b7 linarith\n  \n  have h\u2084 : X * Y * Z = Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) := by\n    rw [hX, hY, hZ]\n    <;> ring_nf\n    <;> field_simp\n    <;> ring_nf\n  \n  have h\u2085 : Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) = Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) := by\n    have h\u2085\u2081 : 0 \u2264 (a + b) / c := h\u2081\n    have h\u2085\u2082 : 0 \u2264 (b + c) / a := h\u2082\n    have h\u2085\u2083 : 0 \u2264 (c + a) / b := h\u2083\n    have h\u2085\u2084 : 0 \u2264 ((a + b) / c) * ((b + c) / a) := by positivity\n    have h\u2085\u2085 : 0 \u2264 ((a + b) / c) * ((b + c) / a) * ((c + a) / b) := by positivity\n    -- Use the property of square roots to combine the products\n    have h\u2085\u2086 : Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) = Real.sqrt (((a + b) / c) * ((b + c) / a)) := by\n      rw [\u2190 Real.sqrt_mul] <;> positivity\n    calc\n      Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) = Real.sqrt (((a + b) / c) * ((b + c) / a)) * Real.sqrt ((c + a) / b) := by rw [h\u2085\u2086]\n      _ = Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) := by\n        have h\u2085\u2087 : 0 \u2264 ((a + b) / c) * ((b + c) / a) := by positivity\n        have h\u2085\u2088 : 0 \u2264 (c + a) / b := h\u2083\n        have h\u2085\u2089 : 0 \u2264 ((a + b) / c) * ((b + c) / a) * ((c + a) / b) := by positivity\n        rw [\u2190 Real.sqrt_mul] <;>\n          (try positivity) <;>\n          (try ring_nf) <;>\n          (try field_simp) <;>\n          (try linarith) <;>\n          (try nlinarith)\n        <;>\n          positivity\n  \n  have h\u2086 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = (a + b) * (b + c) * (c + a) / (a * b * c) := by\n    have h\u2086\u2081 : ((a + b) / c) * ((b + c) / a) * ((c + a) / b) = ((a + b) * (b + c) * (c + a)) / (a * b * c) := by\n      field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring\n      <;> field_simp [ha.ne', hb.ne', hc.ne']\n      <;> ring\n    rw [h\u2086\u2081]\n    <;>\n    (try ring_nf) <;>\n    (try field_simp [ha.ne', hb.ne', hc.ne']) <;>\n    (try ring_nf) <;>\n    (try linarith)\n  \n  have h\u2087 : Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) := by\n    rw [h\u2086]\n    <;>\n    (try ring_nf) <;>\n    (try field_simp [ha.ne', hb.ne', hc.ne']) <;>\n    (try ring_nf) <;>\n    (try linarith)\n  \n  have h\u2088 : X * Y * Z = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) := by\n    calc\n      X * Y * Z = Real.sqrt ((a + b) / c) * Real.sqrt ((b + c) / a) * Real.sqrt ((c + a) / b) := by rw [h\u2084]\n      _ = Real.sqrt (((a + b) / c) * ((b + c) / a) * ((c + a) / b)) := by rw [h\u2085]\n      _ = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) := by rw [h\u2087]\n  \n  rw [h\u2088]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable definitions X, Y, Z are perfectly captured with identical mathematical expressions using Real.sqrt and division operations.", "The conclusion statement XYZ = \u221a((a+b)(b+c)(c+a)/(abc)) is exactly represented in the Lean formalization.", "The additional positivity constraints (0 < a, 0 < b, 0 < c) are logically consistent additions that ensure mathematical well-definedness of the square roots and divisions, which is acceptable for a 'Perfectly match' evaluation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "so $X+Y+Z \\geq 3\\left(\tfrac{(a+b)(b+c)(c+a)}{abc}ight)^{1/6}$.", "statement": "We assume:\n\u2022 $X+Y+Z \\geq 3\\sqrt[3]{XYZ}$ [l5].\n\u2022 $XYZ = \\sqrt{\\frac{(a+b)(b+c)(c+a)}{abc}}$ [l6].\nTherefore, we conclude:\n\u2022 $X+Y+Z \\geq 3 \\left(\\frac{(a+b)(b+c)(c+a)}{abc}\\right)^{1/6}$ [l7].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d)\n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a))\n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l5 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d))\n  (l6 : X * Y * Z = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c))) :\n  X + Y + Z \u2265 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (X Y Z : \u211d)\n  (hX : X = Real.sqrt ((a + b) / c))\n  (hY : Y = Real.sqrt ((b + c) / a))\n  (hZ : Z = Real.sqrt ((c + a) / b))\n  (l5 : X + Y + Z \u2265 3 * (X * Y * Z) ^ (1/3 : \u211d))\n  (l6 : X * Y * Z = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c))) :\n  X + Y + Z \u2265 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d) := by\n  have hS_pos : (a + b) * (b + c) * (c + a) / (a * b * c) > 0 := by\n    have h\u2081 : 0 < a * b * c := by positivity\n    have h\u2082 : 0 < (a + b) * (b + c) * (c + a) := by positivity\n    positivity\n  \n  have h_sqrt_S : Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) = ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 2 : \u211d) := by\n    rw [Real.sqrt_eq_rpow]\n    <;>\n    (try norm_num) <;>\n    (try positivity) <;>\n    (try linarith) <;>\n    (try ring_nf at * <;> norm_num at * <;> linarith)\n    <;>\n    simp_all [hS_pos.le]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h_main : (X * Y * Z) ^ (1 / 3 : \u211d) = ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n    have h\u2081 : X * Y * Z = Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) := by rw [l6]\n    rw [h\u2081]\n    have h\u2082 : Real.sqrt ((a + b) * (b + c) * (c + a) / (a * b * c)) = ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 2 : \u211d) := by rw [h_sqrt_S]\n    rw [h\u2082]\n    have h\u2083 : (((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 2 : \u211d)) ^ (1 / 3 : \u211d) = ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n      have h\u2084 : 0 < (a + b) * (b + c) * (c + a) / (a * b * c) := by positivity\n      have h\u2085 : (((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 2 : \u211d)) ^ (1 / 3 : \u211d) = ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ ((1 / 2 : \u211d) * (1 / 3 : \u211d)) := by\n        rw [\u2190 Real.rpow_mul (le_of_lt h\u2084)]\n        <;> ring_nf\n        <;> norm_num\n      rw [h\u2085]\n      <;> norm_num\n      <;>\n      (try ring_nf)\n      <;>\n      (try field_simp)\n      <;>\n      (try norm_num)\n      <;>\n      (try linarith)\n    rw [h\u2083]\n    <;>\n    (try ring_nf)\n    <;>\n    (try field_simp)\n    <;>\n    (try norm_num)\n    <;>\n    (try linarith)\n  \n  have h_final : X + Y + Z \u2265 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n    calc\n      X + Y + Z \u2265 3 * (X * Y * Z) ^ (1 / 3 : \u211d) := by\n        exact l5\n      _ = 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n        rw [h_main]\n        <;>\n        (try ring_nf)\n        <;>\n        (try field_simp)\n        <;>\n        (try norm_num)\n        <;>\n        (try linarith)\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured, with appropriate extra conditions for mathematical rigor", "Assumption l5 is perfectly translated with correct mathematical notation", "Assumption l6 is accurately formalized with proper algebraic structure", "Conclusion l7 is correctly stated as the theorem goal with precise mathematical formulation", "Additional variable definitions are mathematically consistent and provide necessary context for the proof, representing acceptable extra detail"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "Since $\tfrac{(a+b)(b+c)(c+a)}{abc}\\geq 8$, it follows that $X+Y+Z \\geq 3\\cdot 8^{1/6}=3\\sqrt{2}$.", "statement": "We assume:\n\u2022 $\\frac{(a+b)(b+c)(c+a)}{abc} \\geq 8$ [l3].\n\u2022 $X+Y+Z \\geq 3 \\left(\\frac{(a+b)(b+c)(c+a)}{abc}\\right)^{1/6}$ [l7].\nTherefore, we conclude:\n\u2022 $X+Y+Z \\geq 3\\sqrt{2}$ [l8].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (l3 : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8)\n  (l7 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 \n        3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d)) :\n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 \n  3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c)\n  (l3 : (a + b) * (b + c) * (c + a) / (a * b * c) \u2265 8)\n  (l7 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 \n        3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d)) :\n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 \n  3 * Real.sqrt 2 := by\n  have h8 : (8 : \u211d) ^ (1 / 6 : \u211d) = Real.sqrt 2 := by\n    have h : (8 : \u211d) = (2 : \u211d) ^ (3 : \u211d) := by norm_num\n    have h\u2081 : (8 : \u211d) ^ (1 / 6 : \u211d) = (2 : \u211d) ^ ((3 : \u211d) * (1 / 6 : \u211d)) := by\n      rw [h]\n      rw [\u2190 Real.rpow_mul] <;> norm_num\n      <;>\n      linarith\n    rw [h\u2081]\n    have h\u2082 : (3 : \u211d) * (1 / 6 : \u211d) = (1 / 2 : \u211d) := by norm_num\n    rw [h\u2082]\n    have h\u2083 : (2 : \u211d) ^ (1 / 2 : \u211d) = Real.sqrt 2 := by\n      rw [Real.sqrt_eq_rpow]\n      <;> norm_num\n    rw [h\u2083]\n    <;>\n    norm_num\n  \n  have h9 : ((a + b) * (b + c) * (c + a) / (a * b * c)) \u2265 8 := by\n    exact l3\n  \n  have h10 : (8 : \u211d) ^ (1 / 6 : \u211d) \u2264 ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n    have h\u2081 : (0 : \u211d) \u2264 8 := by norm_num\n    have h\u2082 : (0 : \u211d) \u2264 (a + b) * (b + c) * (c + a) / (a * b * c) := by\n      have h\u2083 : 0 < a * b * c := by positivity\n      have h\u2084 : 0 < (a + b) := by positivity\n      have h\u2085 : 0 < (b + c) := by positivity\n      have h\u2086 : 0 < (c + a) := by positivity\n      positivity\n    have h\u2083 : (8 : \u211d) \u2264 (a + b) * (b + c) * (c + a) / (a * b * c) := by linarith\n    have h\u2084 : (0 : \u211d) \u2264 (1 / 6 : \u211d) := by norm_num\n    -- Use the fact that the function is increasing to compare the exponents\n    exact Real.rpow_le_rpow (by norm_num) h\u2083 (by norm_num)\n  \n  have h11 : Real.sqrt 2 \u2264 ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n    have h\u2081 : Real.sqrt 2 = (8 : \u211d) ^ (1 / 6 : \u211d) := by\n      rw [h8]\n    rw [h\u2081]\n    exact h10\n  \n  have h12 : 3 * Real.sqrt 2 \u2264 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d) := by\n    have h\u2081 : Real.sqrt 2 \u2264 ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := h11\n    have h\u2082 : 3 * Real.sqrt 2 \u2264 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n      -- Multiply both sides of the inequality by 3\n      have h\u2083 : 0 \u2264 Real.sqrt 2 := Real.sqrt_nonneg 2\n      have h\u2084 : 0 \u2264 ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1 / 6 : \u211d) := by\n        -- Prove that the term is non-negative\n        have h\u2085 : 0 < a * b * c := by positivity\n        have h\u2086 : 0 < (a + b) := by positivity\n        have h\u2087 : 0 < (b + c) := by positivity\n        have h\u2088 : 0 < (c + a) := by positivity\n        have h\u2089 : 0 < (a + b) * (b + c) * (c + a) := by positivity\n        have h\u2081\u2080 : 0 < (a + b) * (b + c) * (c + a) / (a * b * c) := by positivity\n        -- Use the fact that the real power of a positive number is positive\n        exact by positivity\n      -- Use linear arithmetic to conclude the proof\n      nlinarith\n    -- The result follows from the above steps\n    exact h\u2082\n  \n  have h13 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n    have h\u2081 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d) := l7\n    have h\u2082 : 3 * Real.sqrt 2 \u2264 3 * ((a + b) * (b + c) * (c + a) / (a * b * c)) ^ (1/6 : \u211d) := h12\n    linarith\n  \n  exact h13", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The explicit positivity constraints for a, b, c in Lean are mathematically necessary and consistent with the natural language context, even though not explicitly stated.", "The assumption l3 is correctly formalized with the exact same mathematical expression.", "The assumption l7 is correctly formalized, with Lean making explicit what X, Y, Z represent, which is mathematically consistent with the context.", "The conclusion l8 is correctly formalized with the same mathematical expression and target inequality.", "The implicit definition of X, Y, Z as square root expressions is made explicit in Lean, which is a reasonable and mathematically consistent interpretation of the natural language context."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Therefore, $$ \\sqrt{\tfrac{a+b}{c}}+\\sqrt{\tfrac{b+c}{a}}+\\sqrt{\tfrac{c+a}{b}} \\geq 3\\sqrt{2} $$.", "statement": "We assume:\n\u2022 Let $X = \\sqrt{\\frac{a+b}{c}}$, $Y = \\sqrt{\\frac{b+c}{a}}$, and $Z = \\sqrt{\\frac{c+a}{b}}$ [def_1].\n\u2022 $X+Y+Z \\geq 3\\sqrt{2}$ [l8].\nTherefore, we conclude:\n\u2022 $\\sqrt{\\frac{a+b}{c}} + \\sqrt{\\frac{b+c}{a}} + \\sqrt{\\frac{c+a}{b}} \\geq 3\\sqrt{2}$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :\n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a b c : \u211d)\n  (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :\n  Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n  have h\u2081 : Real.sqrt ((a + b) / c) \u2265 (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) := by\n    have h\u2081\u2080 : 0 < a + b := by linarith\n    have h\u2081\u2081 : 0 < c := by linarith\n    have h\u2081\u2082 : 0 < 2 * c := by positivity\n    have h\u2081\u2083 : 0 < Real.sqrt (2 * c) := Real.sqrt_pos.mpr (by positivity)\n    have h\u2081\u2084 : 0 < Real.sqrt a := Real.sqrt_pos.mpr ha\n    have h\u2081\u2085 : 0 < Real.sqrt b := Real.sqrt_pos.mpr hb\n    have h\u2081\u2086 : 0 < Real.sqrt a * Real.sqrt b := by positivity\n    have h\u2081\u2087 : (a + b) / c \u2265 (Real.sqrt a + Real.sqrt b) ^ 2 / (2 * c) := by\n      have h\u2081\u2087\u2081 : 0 < c := by linarith\n      have h\u2081\u2087\u2082 : 0 < 2 * c := by positivity\n      have h\u2081\u2087\u2083 : 0 \u2264 (Real.sqrt a - Real.sqrt b) ^ 2 := by positivity\n      have h\u2081\u2087\u2084 : (Real.sqrt a - Real.sqrt b) ^ 2 = a + b - 2 * Real.sqrt a * Real.sqrt b := by\n        nlinarith [Real.sq_sqrt (le_of_lt ha), Real.sq_sqrt (le_of_lt hb),\n          Real.sqrt_nonneg a, Real.sqrt_nonneg b]\n      have h\u2081\u2087\u2085 : a + b \u2265 2 * Real.sqrt a * Real.sqrt b := by\n        nlinarith [Real.sq_sqrt (le_of_lt ha), Real.sq_sqrt (le_of_lt hb),\n          Real.sqrt_nonneg a, Real.sqrt_nonneg b]\n      have h\u2081\u2087\u2086 : (a + b) / c \u2265 (2 * Real.sqrt a * Real.sqrt b) / c := by\n        apply (div_le_div_iff (by positivity) (by positivity)).mpr\n        nlinarith\n      have h\u2081\u2087\u2087 : (Real.sqrt a + Real.sqrt b) ^ 2 = a + b + 2 * Real.sqrt a * Real.sqrt b := by\n        nlinarith [Real.sq_sqrt (le_of_lt ha), Real.sq_sqrt (le_of_lt hb),\n          Real.sqrt_nonneg a, Real.sqrt_nonneg b]\n      have h\u2081\u2087\u2088 : (a + b) / c - (Real.sqrt a + Real.sqrt b) ^ 2 / (2 * c) \u2265 0 := by\n        field_simp [h\u2081\u2081.ne', h\u2081\u2082.ne']\n        rw [le_div_iff (by positivity)]\n        nlinarith [Real.sq_sqrt (le_of_lt ha), Real.sq_sqrt (le_of_lt hb),\n          Real.sqrt_nonneg a, Real.sqrt_nonneg b]\n      linarith\n    have h\u2081\u2088 : Real.sqrt ((a + b) / c) \u2265 Real.sqrt ((Real.sqrt a + Real.sqrt b) ^ 2 / (2 * c)) := by\n      apply Real.sqrt_le_sqrt\n      linarith\n    have h\u2081\u2089 : Real.sqrt ((Real.sqrt a + Real.sqrt b) ^ 2 / (2 * c)) = (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) := by\n      have h\u2081\u2089\u2081 : 0 \u2264 (Real.sqrt a + Real.sqrt b) := by positivity\n      have h\u2081\u2089\u2082 : 0 < 2 * c := by positivity\n      have h\u2081\u2089\u2083 : 0 < Real.sqrt (2 * c) := Real.sqrt_pos.mpr (by positivity)\n      have h\u2081\u2089\u2084 : Real.sqrt ((Real.sqrt a + Real.sqrt b) ^ 2 / (2 * c)) = (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) := by\n        rw [Real.sqrt_eq_iff_sq_eq (by positivity) (by positivity)]\n        field_simp [h\u2081\u2089\u2083.ne', h\u2081\u2089\u2082.ne']\n        <;> ring_nf <;> field_simp [h\u2081\u2089\u2083.ne', h\u2081\u2089\u2082.ne'] <;> ring_nf <;>\n          nlinarith [Real.sq_sqrt (show 0 \u2264 2 * c by positivity)]\n      rw [h\u2081\u2089\u2084]\n    rw [h\u2081\u2089] at h\u2081\u2088\n    linarith\n  \n  have h\u2082 : Real.sqrt ((b + c) / a) \u2265 (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) := by\n    have h\u2082\u2080 : 0 < b + c := by linarith\n    have h\u2082\u2081 : 0 < a := by linarith\n    have h\u2082\u2082 : 0 < 2 * a := by positivity\n    have h\u2082\u2083 : 0 < Real.sqrt (2 * a) := Real.sqrt_pos.mpr (by positivity)\n    have h\u2082\u2084 : 0 < Real.sqrt b := Real.sqrt_pos.mpr hb\n    have h\u2082\u2085 : 0 < Real.sqrt c := Real.sqrt_pos.mpr hc\n    have h\u2082\u2086 : 0 < Real.sqrt b * Real.sqrt c := by positivity\n    have h\u2082\u2087 : (b + c) / a \u2265 (Real.sqrt b + Real.sqrt c) ^ 2 / (2 * a) := by\n      have h\u2082\u2087\u2081 : 0 < a := by linarith\n      have h\u2082\u2087\u2082 : 0 < 2 * a := by positivity\n      have h\u2082\u2087\u2083 : 0 \u2264 (Real.sqrt b - Real.sqrt c) ^ 2 := by positivity\n      have h\u2082\u2087\u2084 : (Real.sqrt b - Real.sqrt c) ^ 2 = b + c - 2 * Real.sqrt b * Real.sqrt c := by\n        nlinarith [Real.sq_sqrt (le_of_lt hb), Real.sq_sqrt (le_of_lt hc),\n          Real.sqrt_nonneg b, Real.sqrt_nonneg c]\n      have h\u2082\u2087\u2085 : b + c \u2265 2 * Real.sqrt b * Real.sqrt c := by\n        nlinarith [Real.sq_sqrt (le_of_lt hb), Real.sq_sqrt (le_of_lt hc),\n          Real.sqrt_nonneg b, Real.sqrt_nonneg c]\n      have h\u2082\u2087\u2086 : (b + c) / a \u2265 (2 * Real.sqrt b * Real.sqrt c) / a := by\n        apply (div_le_div_iff (by positivity) (by positivity)).mpr\n        nlinarith\n      have h\u2082\u2087\u2087 : (Real.sqrt b + Real.sqrt c) ^ 2 = b + c + 2 * Real.sqrt b * Real.sqrt c := by\n        nlinarith [Real.sq_sqrt (le_of_lt hb), Real.sq_sqrt (le_of_lt hc),\n          Real.sqrt_nonneg b, Real.sqrt_nonneg c]\n      have h\u2082\u2087\u2088 : (b + c) / a - (Real.sqrt b + Real.sqrt c) ^ 2 / (2 * a) \u2265 0 := by\n        field_simp [h\u2082\u2081.ne', h\u2082\u2082.ne']\n        rw [le_div_iff (by positivity)]\n        nlinarith [Real.sq_sqrt (le_of_lt hb), Real.sq_sqrt (le_of_lt hc),\n          Real.sqrt_nonneg b, Real.sqrt_nonneg c]\n      linarith\n    have h\u2082\u2088 : Real.sqrt ((b + c) / a) \u2265 Real.sqrt ((Real.sqrt b + Real.sqrt c) ^ 2 / (2 * a)) := by\n      apply Real.sqrt_le_sqrt\n      linarith\n    have h\u2082\u2089 : Real.sqrt ((Real.sqrt b + Real.sqrt c) ^ 2 / (2 * a)) = (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) := by\n      have h\u2082\u2089\u2081 : 0 \u2264 (Real.sqrt b + Real.sqrt c) := by positivity\n      have h\u2082\u2089\u2082 : 0 < 2 * a := by positivity\n      have h\u2082\u2089\u2083 : 0 < Real.sqrt (2 * a) := Real.sqrt_pos.mpr (by positivity)\n      have h\u2082\u2089\u2084 : Real.sqrt ((Real.sqrt b + Real.sqrt c) ^ 2 / (2 * a)) = (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) := by\n        rw [Real.sqrt_eq_iff_sq_eq (by positivity) (by positivity)]\n        field_simp [h\u2082\u2089\u2083.ne', h\u2082\u2089\u2082.ne']\n        <;> ring_nf <;> field_simp [h\u2082\u2089\u2083.ne', h\u2082\u2089\u2082.ne'] <;> ring_nf <;>\n          nlinarith [Real.sq_sqrt (show 0 \u2264 2 * a by positivity)]\n      rw [h\u2082\u2089\u2084]\n    rw [h\u2082\u2089] at h\u2082\u2088\n    linarith\n  \n  have h\u2083 : Real.sqrt ((c + a) / b) \u2265 (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) := by\n    have h\u2083\u2080 : 0 < c + a := by linarith\n    have h\u2083\u2081 : 0 < b := by linarith\n    have h\u2083\u2082 : 0 < 2 * b := by positivity\n    have h\u2083\u2083 : 0 < Real.sqrt (2 * b) := Real.sqrt_pos.mpr (by positivity)\n    have h\u2083\u2084 : 0 < Real.sqrt c := Real.sqrt_pos.mpr hc\n    have h\u2083\u2085 : 0 < Real.sqrt a := Real.sqrt_pos.mpr ha\n    have h\u2083\u2086 : 0 < Real.sqrt c * Real.sqrt a := by positivity\n    have h\u2083\u2087 : (c + a) / b \u2265 (Real.sqrt c + Real.sqrt a) ^ 2 / (2 * b) := by\n      have h\u2083\u2087\u2081 : 0 < b := by linarith\n      have h\u2083\u2087\u2082 : 0 < 2 * b := by positivity\n      have h\u2083\u2087\u2083 : 0 \u2264 (Real.sqrt c - Real.sqrt a) ^ 2 := by positivity\n      have h\u2083\u2087\u2084 : (Real.sqrt c - Real.sqrt a) ^ 2 = c + a - 2 * Real.sqrt c * Real.sqrt a := by\n        nlinarith [Real.sq_sqrt (le_of_lt hc), Real.sq_sqrt (le_of_lt ha),\n          Real.sqrt_nonneg c, Real.sqrt_nonneg a]\n      have h\u2083\u2087\u2085 : c + a \u2265 2 * Real.sqrt c * Real.sqrt a := by\n        nlinarith [Real.sq_sqrt (le_of_lt hc), Real.sq_sqrt (le_of_lt ha),\n          Real.sqrt_nonneg c, Real.sqrt_nonneg a]\n      have h\u2083\u2087\u2086 : (c + a) / b \u2265 (2 * Real.sqrt c * Real.sqrt a) / b := by\n        apply (div_le_div_iff (by positivity) (by positivity)).mpr\n        nlinarith\n      have h\u2083\u2087\u2087 : (Real.sqrt c + Real.sqrt a) ^ 2 = c + a + 2 * Real.sqrt c * Real.sqrt a := by\n        nlinarith [Real.sq_sqrt (le_of_lt hc), Real.sq_sqrt (le_of_lt ha),\n          Real.sqrt_nonneg c, Real.sqrt_nonneg a]\n      have h\u2083\u2087\u2088 : (c + a) / b - (Real.sqrt c + Real.sqrt a) ^ 2 / (2 * b) \u2265 0 := by\n        field_simp [h\u2083\u2081.ne', h\u2083\u2082.ne']\n        rw [le_div_iff (by positivity)]\n        nlinarith [Real.sq_sqrt (le_of_lt hc), Real.sq_sqrt (le_of_lt ha),\n          Real.sqrt_nonneg c, Real.sqrt_nonneg a]\n      linarith\n    have h\u2083\u2088 : Real.sqrt ((c + a) / b) \u2265 Real.sqrt ((Real.sqrt c + Real.sqrt a) ^ 2 / (2 * b)) := by\n      apply Real.sqrt_le_sqrt\n      linarith\n    have h\u2083\u2089 : Real.sqrt ((Real.sqrt c + Real.sqrt a) ^ 2 / (2 * b)) = (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) := by\n      have h\u2083\u2089\u2081 : 0 \u2264 (Real.sqrt c + Real.sqrt a) := by positivity\n      have h\u2083\u2089\u2082 : 0 < 2 * b := by positivity\n      have h\u2083\u2089\u2083 : 0 < Real.sqrt (2 * b) := Real.sqrt_pos.mpr (by positivity)\n      have h\u2083\u2089\u2084 : Real.sqrt ((Real.sqrt c + Real.sqrt a) ^ 2 / (2 * b)) = (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) := by\n        rw [Real.sqrt_eq_iff_sq_eq (by positivity) (by positivity)]\n        field_simp [h\u2083\u2089\u2083.ne', h\u2083\u2089\u2082.ne']\n        <;> ring_nf <;> field_simp [h\u2083\u2089\u2083.ne', h\u2083\u2089\u2082.ne'] <;> ring_nf <;>\n          nlinarith [Real.sq_sqrt (show 0 \u2264 2 * b by positivity)]\n      rw [h\u2083\u2089\u2084]\n    rw [h\u2083\u2089] at h\u2083\u2088\n    linarith\n  \n  have h\u2084 : (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) + (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) + (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) = Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) := by\n    have h\u2084\u2081 : 0 < a := ha\n    have h\u2084\u2082 : 0 < b := hb\n    have h\u2084\u2083 : 0 < c := hc\n    have h\u2084\u2084 : 0 < Real.sqrt a := Real.sqrt_pos.mpr h\u2084\u2081\n    have h\u2084\u2085 : 0 < Real.sqrt b := Real.sqrt_pos.mpr h\u2084\u2082\n    have h\u2084\u2086 : 0 < Real.sqrt c := Real.sqrt_pos.mpr h\u2084\u2083\n    have h\u2084\u2087 : 0 < Real.sqrt (2 * a) := Real.sqrt_pos.mpr (by positivity)\n    have h\u2084\u2088 : 0 < Real.sqrt (2 * b) := Real.sqrt_pos.mpr (by positivity)\n    have h\u2084\u2089 : 0 < Real.sqrt (2 * c) := Real.sqrt_pos.mpr (by positivity)\n    have h\u2085\u2080 : (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) = (Real.sqrt 2 / 2) * (Real.sqrt (a / c) + Real.sqrt (b / c)) := by\n      have h\u2085\u2080\u2081 : Real.sqrt (2 * c) = Real.sqrt 2 * Real.sqrt c := by\n        rw [\u2190 Real.sqrt_mul] <;> ring_nf <;> positivity\n      have h\u2085\u2080\u2082 : Real.sqrt (a / c) = Real.sqrt a / Real.sqrt c := by\n        rw [Real.sqrt_div (by positivity)]\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n      have h\u2085\u2080\u2083 : Real.sqrt (b / c) = Real.sqrt b / Real.sqrt c := by\n        rw [Real.sqrt_div (by positivity)]\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n      calc\n        (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) = (Real.sqrt a + Real.sqrt b) / (Real.sqrt 2 * Real.sqrt c) := by rw [h\u2085\u2080\u2081]\n        _ = (Real.sqrt a + Real.sqrt b) / (Real.sqrt 2 * Real.sqrt c) := by rfl\n        _ = (Real.sqrt a / (Real.sqrt 2 * Real.sqrt c) + Real.sqrt b / (Real.sqrt 2 * Real.sqrt c)) := by\n          ring_nf\n          <;> field_simp [h\u2084\u2089.ne']\n          <;> ring_nf\n        _ = (Real.sqrt a / Real.sqrt c / Real.sqrt 2 + Real.sqrt b / Real.sqrt c / Real.sqrt 2) := by\n          field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n          <;> field_simp [h\u2084\u2089.ne'] <;> ring_nf\n        _ = (1 / Real.sqrt 2) * (Real.sqrt a / Real.sqrt c + Real.sqrt b / Real.sqrt c) := by\n          ring_nf\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n          <;> field_simp [h\u2084\u2089.ne'] <;> ring_nf\n        _ = (Real.sqrt 2 / 2) * (Real.sqrt a / Real.sqrt c + Real.sqrt b / Real.sqrt c) := by\n          have h\u2085\u2080\u2084 : 1 / Real.sqrt 2 = Real.sqrt 2 / 2 := by\n            field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> norm_num\n          rw [h\u2085\u2080\u2084]\n          <;> ring_nf\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n        _ = (Real.sqrt 2 / 2) * (Real.sqrt (a / c) + Real.sqrt (b / c)) := by\n          have h\u2085\u2080\u2085 : Real.sqrt (a / c) = Real.sqrt a / Real.sqrt c := by\n            rw [Real.sqrt_div (by positivity)]\n            <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n          have h\u2085\u2080\u2086 : Real.sqrt (b / c) = Real.sqrt b / Real.sqrt c := by\n            rw [Real.sqrt_div (by positivity)]\n            <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n          rw [h\u2085\u2080\u2085, h\u2085\u2080\u2086]\n          <;> ring_nf\n    have h\u2085\u2081 : (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) = (Real.sqrt 2 / 2) * (Real.sqrt (b / a) + Real.sqrt (c / a)) := by\n      have h\u2085\u2081\u2081 : Real.sqrt (2 * a) = Real.sqrt 2 * Real.sqrt a := by\n        rw [\u2190 Real.sqrt_mul] <;> ring_nf <;> positivity\n      have h\u2085\u2081\u2082 : Real.sqrt (b / a) = Real.sqrt b / Real.sqrt a := by\n        rw [Real.sqrt_div (by positivity)]\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n      have h\u2085\u2081\u2083 : Real.sqrt (c / a) = Real.sqrt c / Real.sqrt a := by\n        rw [Real.sqrt_div (by positivity)]\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n      calc\n        (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) = (Real.sqrt b + Real.sqrt c) / (Real.sqrt 2 * Real.sqrt a) := by rw [h\u2085\u2081\u2081]\n        _ = (Real.sqrt b + Real.sqrt c) / (Real.sqrt 2 * Real.sqrt a) := by rfl\n        _ = (Real.sqrt b / (Real.sqrt 2 * Real.sqrt a) + Real.sqrt c / (Real.sqrt 2 * Real.sqrt a)) := by\n          ring_nf\n          <;> field_simp [h\u2084\u2087.ne']\n          <;> ring_nf\n        _ = (Real.sqrt b / Real.sqrt a / Real.sqrt 2 + Real.sqrt c / Real.sqrt a / Real.sqrt 2) := by\n          field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n          <;> field_simp [h\u2084\u2087.ne'] <;> ring_nf\n        _ = (1 / Real.sqrt 2) * (Real.sqrt b / Real.sqrt a + Real.sqrt c / Real.sqrt a) := by\n          ring_nf\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n          <;> field_simp [h\u2084\u2087.ne'] <;> ring_nf\n        _ = (Real.sqrt 2 / 2) * (Real.sqrt b / Real.sqrt a + Real.sqrt c / Real.sqrt a) := by\n          have h\u2085\u2081\u2084 : 1 / Real.sqrt 2 = Real.sqrt 2 / 2 := by\n            field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> norm_num\n          rw [h\u2085\u2081\u2084]\n          <;> ring_nf\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n        _ = (Real.sqrt 2 / 2) * (Real.sqrt (b / a) + Real.sqrt (c / a)) := by\n          have h\u2085\u2081\u2085 : Real.sqrt (b / a) = Real.sqrt b / Real.sqrt a := by\n            rw [Real.sqrt_div (by positivity)]\n            <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n          have h\u2085\u2081\u2086 : Real.sqrt (c / a) = Real.sqrt c / Real.sqrt a := by\n            rw [Real.sqrt_div (by positivity)]\n            <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n          rw [h\u2085\u2081\u2085, h\u2085\u2081\u2086]\n          <;> ring_nf\n    have h\u2085\u2082 : (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) = (Real.sqrt 2 / 2) * (Real.sqrt (c / b) + Real.sqrt (a / b)) := by\n      have h\u2085\u2082\u2081 : Real.sqrt (2 * b) = Real.sqrt 2 * Real.sqrt b := by\n        rw [\u2190 Real.sqrt_mul] <;> ring_nf <;> positivity\n      have h\u2085\u2082\u2082 : Real.sqrt (c / b) = Real.sqrt c / Real.sqrt b := by\n        rw [Real.sqrt_div (by positivity)]\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n      have h\u2085\u2082\u2083 : Real.sqrt (a / b) = Real.sqrt a / Real.sqrt b := by\n        rw [Real.sqrt_div (by positivity)]\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n      calc\n        (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) = (Real.sqrt c + Real.sqrt a) / (Real.sqrt 2 * Real.sqrt b) := by rw [h\u2085\u2082\u2081]\n        _ = (Real.sqrt c + Real.sqrt a) / (Real.sqrt 2 * Real.sqrt b) := by rfl\n        _ = (Real.sqrt c / (Real.sqrt 2 * Real.sqrt b) + Real.sqrt a / (Real.sqrt 2 * Real.sqrt b)) := by\n          ring_nf\n          <;> field_simp [h\u2084\u2088.ne']\n          <;> ring_nf\n        _ = (Real.sqrt c / Real.sqrt b / Real.sqrt 2 + Real.sqrt a / Real.sqrt b / Real.sqrt 2) := by\n          field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n          <;> field_simp [h\u2084\u2088.ne'] <;> ring_nf\n        _ = (1 / Real.sqrt 2) * (Real.sqrt c / Real.sqrt b + Real.sqrt a / Real.sqrt b) := by\n          ring_nf\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n          <;> field_simp [h\u2084\u2088.ne'] <;> ring_nf\n        _ = (Real.sqrt 2 / 2) * (Real.sqrt c / Real.sqrt b + Real.sqrt a / Real.sqrt b) := by\n          have h\u2085\u2082\u2084 : 1 / Real.sqrt 2 = Real.sqrt 2 / 2 := by\n            field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf <;> norm_num\n          rw [h\u2085\u2082\u2084]\n          <;> ring_nf\n          <;> field_simp [Real.sqrt_eq_iff_sq_eq] <;> ring_nf\n        _ = (Real.sqrt 2 / 2) * (Real.sqrt (c / b) + Real.sqrt (a / b)) := by\n          have h\u2085\u2082\u2085 : Real.sqrt (c / b) = Real.sqrt c / Real.sqrt b := by\n            rw [Real.sqrt_div (by positivity)]\n            <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n          have h\u2085\u2082\u2086 : Real.sqrt (a / b) = Real.sqrt a / Real.sqrt b := by\n            rw [Real.sqrt_div (by positivity)]\n            <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n          rw [h\u2085\u2082\u2085, h\u2085\u2082\u2086]\n          <;> ring_nf\n    calc\n      (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) + (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) + (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) =\n          (Real.sqrt 2 / 2) * (Real.sqrt (a / c) + Real.sqrt (b / c)) + (Real.sqrt 2 / 2) * (Real.sqrt (b / a) + Real.sqrt (c / a)) + (Real.sqrt 2 / 2) * (Real.sqrt (c / b) + Real.sqrt (a / b)) := by\n        rw [h\u2085\u2080, h\u2085\u2081, h\u2085\u2082]\n        <;> ring_nf\n      _ = (Real.sqrt 2 / 2) * (Real.sqrt (a / c) + Real.sqrt (b / c) + Real.sqrt (b / a) + Real.sqrt (c / a) + Real.sqrt (c / b) + Real.sqrt (a / b)) := by\n        ring_nf\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n        <;> ring_nf\n      _ = (Real.sqrt 2 / 2) * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) + Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b)) := by\n        ring_nf\n        <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n        <;> ring_nf\n      _ = (Real.sqrt 2 / 2) * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) + Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b)) := by rfl\n      _ = Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) := by\n        have h\u2085\u2083 : Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b) = Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) := by\n          have h\u2085\u2083\u2081 : Real.sqrt (a / c) = Real.sqrt (a / b * (b / c)) := by\n            have h\u2085\u2083\u2081\u2081 : (a / c : \u211d) = (a / b : \u211d) * (b / c : \u211d) := by\n              field_simp\n              <;> ring_nf\n            rw [h\u2085\u2083\u2081\u2081]\n            <;> rw [Real.sqrt_mul (by positivity)]\n          have h\u2085\u2083\u2082 : Real.sqrt (b / a) = Real.sqrt (b / c * (c / a)) := by\n            have h\u2085\u2083\u2082\u2081 : (b / a : \u211d) = (b / c : \u211d) * (c / a : \u211d) := by\n              field_simp\n              <;> ring_nf\n            rw [h\u2085\u2083\u2082\u2081]\n            <;> rw [Real.sqrt_mul (by positivity)]\n          have h\u2085\u2083\u2083 : Real.sqrt (c / b) = Real.sqrt (c / a * (a / b)) := by\n            have h\u2085\u2083\u2083\u2081 : (c / b : \u211d) = (c / a : \u211d) * (a / b : \u211d) := by\n              field_simp\n              <;> ring_nf\n            rw [h\u2085\u2083\u2083\u2081]\n            <;> rw [Real.sqrt_mul (by positivity)]\n          have h\u2085\u2083\u2084 : Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b) = Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) := by\n            have h\u2085\u2083\u2084\u2081 : Real.sqrt (a / c) = Real.sqrt (a / b) * Real.sqrt (b / c) := by\n              rw [h\u2085\u2083\u2081]\n              <;> rw [Real.sqrt_mul (by positivity)]\n              <;> ring_nf\n              <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n              <;> ring_nf\n            have h\u2085\u2083\u2084\u2082 : Real.sqrt (b / a) = Real.sqrt (b / c) * Real.sqrt (c / a) := by\n              rw [h\u2085\u2083\u2082]\n              <;> rw [Real.sqrt_mul (by positivity)]\n              <;> ring_nf\n              <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n              <;> ring_nf\n            have h\u2085\u2083\u2084\u2083 : Real.sqrt (c / b) = Real.sqrt (c / a) * Real.sqrt (a / b) := by\n              rw [h\u2085\u2083\u2083]\n              <;> rw [Real.sqrt_mul (by positivity)]\n              <;> ring_nf\n              <;> field_simp [Real.sqrt_eq_iff_sq_eq]\n              <;> ring_nf\n            calc\n              Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b) = (Real.sqrt (a / b) * Real.sqrt (b / c)) + (Real.sqrt (b / c) * Real.sqrt (c / a)) + (Real.sqrt (c / a) * Real.sqrt (a / b)) := by\n                rw [h\u2085\u2083\u2084\u2081, h\u2085\u2083\u2084\u2082, h\u2085\u2083\u2084\u2083]\n              _ = Real.sqrt (a / b) * Real.sqrt (b / c) + Real.sqrt (b / c) * Real.sqrt (c / a) + Real.sqrt (c / a) * Real.sqrt (a / b) := by ring\n              _ = Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) := by\n                have h\u2085\u2083\u2084\u2084 : Real.sqrt (a / b) > 0 := Real.sqrt_pos.mpr (by positivity)\n                have h\u2085\u2083\u2084\u2085 : Real.sqrt (b / c) > 0 := Real.sqrt_pos.mpr (by positivity)\n                have h\u2085\u2083\u2084\u2086 : Real.sqrt (c / a) > 0 := Real.sqrt_pos.mpr (by positivity)\n                have h\u2085\u2083\u2084\u2087 : Real.sqrt (a / b) * Real.sqrt (b / c) * Real.sqrt (c / a) = 1 := by\n                  have h\u2085\u2083\u2084\u2088 : Real.sqrt (a / b) * Real.sqrt (b / c) * Real.sqrt (c / a) = Real.sqrt ((a / b) * (b / c) * (c / a)) := by\n                    rw [\u2190 Real.sqrt_mul, \u2190 Real.sqrt_mul] <;>\n                      (try positivity) <;>\n                      (try ring_nf) <;>\n                      (try field_simp) <;>\n                      (try norm_num)\n                    <;>\n                    positivity\n                  have h\u2085\u2083\u2084\u2089 : (a / b : \u211d) * (b / c : \u211d) * (c / a : \u211d) = 1 := by\n                    field_simp\n                    <;> ring_nf\n                  rw [h\u2085\u2083\u2084\u2088, h\u2085\u2083\u2084\u2089]\n                  <;> rw [Real.sqrt_one]\n                have h\u2085\u2083\u2084\u2088 : Real.sqrt (a / b) * Real.sqrt (b / c) + Real.sqrt (b / c) * Real.sqrt (c / a) + Real.sqrt (c / a) * Real.sqrt (a / b) = Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) := by\n                  nlinarith [sq_nonneg (Real.sqrt (a / b) - Real.sqrt (b / c)), sq_nonneg (Real.sqrt (b / c) - Real.sqrt (c / a)), sq_nonneg (Real.sqrt (c / a) - Real.sqrt (a / b)), Real.sq_sqrt (show 0 \u2264 (a / b : \u211d) by positivity), Real.sq_sqrt (show 0 \u2264 (b / c : \u211d) by positivity), Real.sq_sqrt (show 0 \u2264 (c / a : \u211d) by positivity)]\n                linarith\n          linarith\n        have h\u2085\u2084 : (Real.sqrt 2 / 2) * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) + Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b)) = Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) := by\n          have h\u2085\u2084\u2081 : Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b) = Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) := by\n            linarith\n          calc\n            (Real.sqrt 2 / 2) * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) + Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b)) =\n                (Real.sqrt 2 / 2) * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) + (Real.sqrt (a / c) + Real.sqrt (b / a) + Real.sqrt (c / b))) := by ring\n            _ = (Real.sqrt 2 / 2) * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) + (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a))) := by rw [h\u2085\u2084\u2081]\n            _ = (Real.sqrt 2 / 2) * (2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a))) := by ring\n            _ = Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) := by ring\n            _ = Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) := by ring\n        linarith\n  \n  have h\u2085 : Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) \u2265 3 := by\n    have h\u2085\u2081 : 0 < a := ha\n    have h\u2085\u2082 : 0 < b := hb\n    have h\u2085\u2083 : 0 < c := hc\n    have h\u2085\u2084 : 0 < a / b := by positivity\n    have h\u2085\u2085 : 0 < b / c := by positivity\n    have h\u2085\u2086 : 0 < c / a := by positivity\n    have h\u2085\u2087 : Real.sqrt (a / b) > 0 := Real.sqrt_pos.mpr (by positivity)\n    have h\u2085\u2088 : Real.sqrt (b / c) > 0 := Real.sqrt_pos.mpr (by positivity)\n    have h\u2085\u2089 : Real.sqrt (c / a) > 0 := Real.sqrt_pos.mpr (by positivity)\n    have h\u2086\u2080 : Real.sqrt (a / b) * Real.sqrt (b / c) * Real.sqrt (c / a) = 1 := by\n      have h\u2086\u2080\u2081 : Real.sqrt (a / b) * Real.sqrt (b / c) * Real.sqrt (c / a) = Real.sqrt ((a / b) * (b / c) * (c / a)) := by\n        rw [\u2190 Real.sqrt_mul, \u2190 Real.sqrt_mul] <;>\n          (try positivity) <;>\n          (try ring_nf) <;>\n          (try field_simp) <;>\n          (try norm_num)\n        <;>\n        positivity\n      have h\u2086\u2080\u2082 : (a / b : \u211d) * (b / c : \u211d) * (c / a : \u211d) = 1 := by\n        field_simp\n        <;> ring_nf\n      rw [h\u2086\u2080\u2081, h\u2086\u2080\u2082]\n      <;> rw [Real.sqrt_one]\n    have h\u2086\u2081 : Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) \u2265 3 := by\n      nlinarith [sq_nonneg (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)),\n        sq_nonneg (Real.sqrt (a / b) - Real.sqrt (b / c)),\n        sq_nonneg (Real.sqrt (b / c) - Real.sqrt (c / a)),\n        sq_nonneg (Real.sqrt (c / a) - Real.sqrt (a / b)),\n        Real.sq_sqrt (show 0 \u2264 a / b by positivity),\n        Real.sq_sqrt (show 0 \u2264 b / c by positivity),\n        Real.sq_sqrt (show 0 \u2264 c / a by positivity)]\n    exact h\u2086\u2081\n  \n  have h\u2086 : Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) \u2265 3 * Real.sqrt 2 := by\n    have h\u2086\u2081 : Real.sqrt 2 > 0 := Real.sqrt_pos.mpr (by norm_num)\n    have h\u2086\u2082 : Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a) \u2265 3 := h\u2085\n    have h\u2086\u2083 : Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) \u2265 Real.sqrt 2 * 3 := by\n      exact mul_le_mul_of_nonneg_left h\u2086\u2082 (by positivity)\n    linarith\n  \n  have h\u2087 : (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) + (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) + (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) \u2265 3 * Real.sqrt 2 := by\n    have h\u2087\u2081 : (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) + (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) + (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) = Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) := h\u2084\n    have h\u2087\u2082 : Real.sqrt 2 * (Real.sqrt (a / b) + Real.sqrt (b / c) + Real.sqrt (c / a)) \u2265 3 * Real.sqrt 2 := h\u2086\n    linarith\n  \n  have h\u2088 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 3 * Real.sqrt 2 := by\n    have h\u2088\u2081 : Real.sqrt ((a + b) / c) \u2265 (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) := h\u2081\n    have h\u2088\u2082 : Real.sqrt ((b + c) / a) \u2265 (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) := h\u2082\n    have h\u2088\u2083 : Real.sqrt ((c + a) / b) \u2265 (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) := h\u2083\n    have h\u2088\u2084 : (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) + (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) + (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) \u2265 3 * Real.sqrt 2 := h\u2087\n    have h\u2088\u2085 : Real.sqrt ((a + b) / c) + Real.sqrt ((b + c) / a) + Real.sqrt ((c + a) / b) \u2265 (Real.sqrt a + Real.sqrt b) / Real.sqrt (2 * c) + (Real.sqrt b + Real.sqrt c) / Real.sqrt (2 * a) + (Real.sqrt c + Real.sqrt a) / Real.sqrt (2 * b) := by\n      linarith\n    linarith\n  \n  exact h\u2088", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The variable definitions X, Y, Z are captured correctly in the Lean formalization, though expressed inline rather than as separate definitions. The mathematical meaning is preserved.", "The natural language presents X+Y+Z \u2265 3\u221a2 as an assumption (l8), but the Lean formalization treats this as the theorem to be proved. This represents a fundamental difference in logical structure.", "The conclusion ts_1 in natural language perfectly matches the theorem statement in Lean, with identical mathematical expressions and inequality.", "The Lean formalization appropriately adds positivity constraints (a > 0, b > 0, c > 0) which are mathematically necessary for the expressions to be well-defined, though not explicitly mentioned in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable definitions X, Y, Z are captured correctly in the Lean formalization, though expressed inline rather than as separate definitions. The mathematical meaning is preserved.', 'The natural language presents X+Y+Z \u2265 3\u221a2 as an assumption (l8), but the Lean formalization treats this as the theorem to be proved. This represents a fundamental difference in logical structure.', 'The conclusion ts_1 in natural language perfectly matches the theorem statement in Lean, with identical mathematical expressions and inequality.', 'The Lean formalization appropriately adds positivity constraints (a > 0, b > 0, c > 0) which are mathematically necessary for the expressions to be well-defined, though not explicitly mentioned in the natural language.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    