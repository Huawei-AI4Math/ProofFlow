
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence of positive real numbers. If $\lim_{n 	o \infty} rac{a_{n+1}}{a_n} = L$ where $0 < L < 1$, then $\lim_{n 	o \infty} a_n = 0$.

Proof: Since $\lim_{n 	o \infty} rac{a_{n+1}}{a_n} = L$ with $L < 1$, we can choose $r$ such that $L < r < 1$. By the definition of limit, there exists $N \in \mathbb{N}$ such that for all $n \geq N$, we have $rac{a_{n+1}}{a_n} < r$. This means that for $n \geq N$, we get $a_{n+1} < r \cdot a_n$. Applying this inequality repeatedly, we find that $a_{N+1} < r \cdot a_N$, $a_{N+2} < r \cdot a_{N+1} < r^2 \cdot a_N$, and in general, $a_{N+k} < r^k \cdot a_N$ for all $k \geq 1$. Since $a_N$ is a fixed positive number and $0 < r < 1$, we know that $r^k 	o 0$ as $k 	o \infty$. Therefore, given any $\epsilon > 0$, we can choose $K$ large enough so that $r^k \cdot a_N < \epsilon$ for all $k \geq K$. This shows that $a_{N+k} < \epsilon$ for all $k \geq K$, which means $\lim_{n 	o \infty} a_n = 0$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence of positive real numbers.", "statement": "Premise:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents a sequence of real numbers indexed by natural numbers as a function \u2115 \u2192 \u211d, which is the standard mathematical representation in type theory", "The Lean condition \u2200 n, 0 < a n is logically equivalent to the mathematical statement 'for all n \u2208 \u2115, a\u2099 > 0', just with the inequality flipped (0 < a n vs a n > 0)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If $\\lim_{n \to \\infty} \frac{a_{n+1}}{a_n} = L$ where $0 < L < 1$", "statement": "Premise:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1].\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u211d)\n(tc_1 : \u2200 n, 0 < a n)\n(tc_2 : \u2203 L : \u211d, 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization `variable (a : \u2115 \u2192 \u211d)` declares a sequence of real numbers indexed by natural numbers, and `(tc_1 : \u2200 n, 0 < a n)` states that all terms are positive, which perfectly matches the natural language condition.", "The Lean formalization uses `Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L)` which is the precise mathematical formalization of the limit $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$ in Lean's topology library. This perfectly captures the mathematical meaning.", "The Lean formalization includes `0 < L \u2227 L < 1` within the existential quantifier, which exactly matches the constraint $0 < L < 1$ from the natural language."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since $\\lim_{n \to \\infty} \frac{a_{n+1}}{a_n} = L$ with $L < 1$, we can choose $r$ such that $L < r < 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2].\nTherefore, we conclude:\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L)) :\n  \u2203 r : \u211d, L < r \u2227 r < 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L)) :\n  \u2203 r : \u211d, L < r \u2227 r < 1 := by\n  have h_L_lt_1 : L < 1 := by\n    have h : L < 1 := tc_2.2.1\n    exact h\n  \n  have h_main : \u2203 (r : \u211d), L < r \u2227 r < 1 := by\n    use (L + 1) / 2\n    constructor\n    \u00b7 -- Prove L < (L + 1) / 2\n      have h\u2081 : L < 1 := h_L_lt_1\n      linarith\n    \u00b7 -- Prove (L + 1) / 2 < 1\n      have h\u2081 : L < 1 := h_L_lt_1\n      linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition and positivity condition are correctly formalized with appropriate types and universal quantification.", "The limit condition is properly captured using Lean's filter-based limit definition, and the bounds on L are correctly included.", "The conclusion about the existence of r with the specified bounds is exactly translated."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "By the definition of limit, there exists $N \\in \\mathbb{N}$ such that for all $n \\geq N$, we have $\\frac{a_{n+1}}{a_n} < r$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2];\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1].\nTherefore, we conclude:\n\u2022 There exists a natural number $N$ such that for all $n \\geq N$, $\\frac{a_{n+1}}{a_n} < r$ [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1) :\n  \u2203 N : \u2115, \u2200 n \u2265 N, a (n + 1) / a n < r := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1) :\n  \u2203 N : \u2115, \u2200 n \u2265 N, a (n + 1) / a n < r := by\n  have h\u03b5_pos : 0 < (r - L) / 2 := by\n    have h\u2081 : L < r := l1.1\n    have h\u2082 : 0 < r - L := by linarith\n    linarith\n  \n  have h_main : \u2203 (N : \u2115), \u2200 (n : \u2115), n \u2265 N \u2192 a (n + 1) / a n < L + (r - L) / 2 := by\n    have h\u2081 : Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L) := tc_2.2.2\n    have h\u2082 : 0 < (r - L) / 2 := h\u03b5_pos\n    -- Use the definition of the limit to find N such that for all n \u2265 N, |a_{n+1}/a_n - L| < (r - L)/2\n    have h\u2083 : \u2200\u1da0 (n : \u2115) in Filter.atTop, |a (n + 1) / a n - L| < (r - L) / 2 := by\n      have h\u2084 : Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L) := h\u2081\n      have h\u2085 : \u2200\u1da0 (n : \u2115) in Filter.atTop, a (n + 1) / a n \u2208 Set.Ioo (L - (r - L) / 2) (L + (r - L) / 2) := by\n        have h\u2086 : Set.Ioo (L - (r - L) / 2) (L + (r - L) / 2) \u2208 nhds L := by\n          apply Ioo_mem_nhds\n          <;> linarith [l1.1]\n        filter_upwards [h\u2084 h\u2086] with n hn\n        exact hn\n      filter_upwards [h\u2085] with n hn\n      rw [Set.mem_Ioo] at hn\n      rw [abs_lt]\n      constructor <;> linarith\n    -- Obtain N from the filter\n    obtain \u27e8N, hN\u27e9 := Filter.eventually_atTop.mp h\u2083\n    use N\n    intro n hn\n    have h\u2084 : |a (n + 1) / a n - L| < (r - L) / 2 := hN n hn\n    have h\u2085 : a (n + 1) / a n - L < (r - L) / 2 := by\n      linarith [abs_lt.mp h\u2084]\n    linarith\n  \n  have h_L_plus_\u03b5_lt_r : L + (r - L) / 2 < r := by\n    have h\u2081 : L < r := l1.1\n    linarith\n  \n  have h_final : \u2203 N : \u2115, \u2200 n \u2265 N, a (n + 1) / a n < r := by\n    obtain \u27e8N, hN\u27e9 := h_main\n    use N\n    intro n hn\n    have h\u2081 : a (n + 1) / a n < L + (r - L) / 2 := hN n hn\n    have h\u2082 : L + (r - L) / 2 < r := h_L_plus_\u03b5_lt_r\n    linarith\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The positivity condition for the sequence is correctly captured with identical logical meaning.", "The limit condition and bounds on L are properly formalized using Lean's Filter.Tendsto, which is the standard way to express limits in Lean.", "The intermediate value condition is logically equivalent - treating r as a parameter with the given bounds is mathematically equivalent to asserting existence.", "The conclusion perfectly matches the natural language statement in both logical structure and mathematical content.", "All variable types and declarations are appropriate and consistent with the natural language description."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "This means that for $n \\geq N$, we get $a_{n+1} < r \\cdot a_n$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2];\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1];\n\u2022 There exists a natural number $N$ such that for all $n \\geq N$, $\\frac{a_{n+1}}{a_n} < r$ [l2].\nTherefore, we conclude:\n\u2022 For the $N$ from [l2], for all $n \\geq N$, $a_{n+1} < r \\cdot a_n$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r) :\n  \u2200 n \u2265 N, a (n + 1) < r * a n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r) :\n  \u2200 n \u2265 N, a (n + 1) < r * a n := by\n  have h_main : \u2200 n \u2265 N, a (n + 1) < r * a n := by\n    intro n hn\n    have h\u2081 : a (n + 1) / a n < r := l2 n hn\n    have h\u2082 : 0 < a n := tc_1 n\n    have h\u2083 : 0 < a (n + 1) := tc_1 (n + 1)\n    -- Multiply both sides of the inequality by a_n (which is positive)\n    have h\u2084 : a (n + 1) < r * a n := by\n      calc\n        a (n + 1) = (a (n + 1) / a n) * a n := by\n          field_simp [h\u2082.ne']\n          <;> ring\n        _ < r * a n := by\n          -- Use the fact that a (n + 1) / a n < r and a n > 0\n          have h\u2085 : a (n + 1) / a n < r := h\u2081\n          have h\u2086 : 0 < a n := h\u2082\n          nlinarith\n    exact h\u2084\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence positivity condition is correctly formalized with the same logical meaning.", "The limit condition and bounds on L are perfectly captured using Lean's Filter.Tendsto for limit notation.", "The existence of intermediate value r is logically equivalent - using r as a parameter with the constraint is equivalent to existential quantification for this theorem's purpose.", "The ratio bound condition is logically equivalent - N as a parameter with the constraint serves the same purpose as existential quantification.", "The conclusion perfectly matches the natural language statement about the inequality relationship."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Applying this inequality repeatedly, we find that $a_{N+1} < r \\cdot a_N$, $a_{N+2} < r \\cdot a_{N+1} < r^2 \\cdot a_N$, and in general, $a_{N+k} < r^k \\cdot a_N$ for all $k \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2];\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1];\n\u2022 There exists a natural number $N$ such that for all $n \\geq N$, $\\frac{a_{n+1}}{a_n} < r$ [l2];\n\u2022 For the $N$ from [l2], for all $n \\geq N$, $a_{n+1} < r \\cdot a_n$ [l3].\nTherefore, we conclude:\n\u2022 For the $N$ from [l2] and for all integers $k \\geq 1$, $a_{N+k} < r^k \\cdot a_N$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n) :\n  \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n) :\n  \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N := by\n  have h_main : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N := by\n    intro k hk\n    induction' hk with k hk IH\n    \u00b7 -- Base case: k = 1\n      have h\u2081 : a (N + 1) < r * a N := by\n        have h\u2082 : a (N + 1) < r * a N := by\n          have h\u2083 : a (N + 1) < r * a N := by\n            have h\u2084 : N \u2265 N := by linarith\n            have h\u2085 : a (N + 1) < r * a N := l3 N (by linarith)\n            exact h\u2085\n          exact h\u2083\n        exact h\u2082\n      simpa [pow_one] using h\u2081\n    \u00b7 -- Inductive step: assume the statement holds for k, prove for k + 1\n      have h\u2081 : a (N + (k + 1)) < r ^ (k + 1) * a N := by\n        have h\u2082 : a (N + (k + 1)) = a ((N + k) + 1) := by\n          ring_nf\n          <;> simp [add_assoc]\n          <;> ring_nf\n        rw [h\u2082]\n        have h\u2083 : (N + k : \u2115) \u2265 N := by\n          omega\n        have h\u2084 : a ((N + k) + 1) < r * a (N + k) := l3 (N + k) (by\n          exact_mod_cast h\u2083)\n        have h\u2085 : a (N + k) < r ^ k * a N := IH\n        have h\u2086 : 0 < r := by linarith [l1.1, tc_2.1]\n        have h\u2087 : 0 < a (N + k) := tc_1 (N + k)\n        have h\u2088 : 0 < a N := tc_1 N\n        have h\u2089 : 0 < r ^ k := pow_pos h\u2086 k\n        have h\u2081\u2080 : 0 < r ^ k * a N := by positivity\n        have h\u2081\u2081 : r * a (N + k) < r * (r ^ k * a N) := by\n          have h\u2081\u2082 : a (N + k) < r ^ k * a N := h\u2085\n          have h\u2081\u2083 : r > 0 := by linarith [l1.1, tc_2.1]\n          nlinarith\n        calc\n          a ((N + k) + 1) < r * a (N + k) := h\u2084\n          _ < r * (r ^ k * a N) := h\u2081\u2081\n          _ = r ^ (k + 1) * a N := by\n            ring_nf\n            <;> field_simp [pow_succ]\n            <;> ring_nf\n            <;> nlinarith\n      simpa [pow_succ, mul_assoc] using h\u2081\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The positivity condition tc_1 is correctly formalized as \u2200 n, 0 < a n", "The limit condition tc_2 properly combines the bounds on L and the limit using Filter.Tendsto, which is the standard way to express limits in Lean", "The existence of r with bounds l1 is correctly captured as L < r \u2227 r < 1", "The ratio condition l2 is accurately formalized with the same mathematical meaning", "The inequality condition l3 matches exactly with proper multiplication notation", "The conclusion l4 is correctly stated with proper quantification over k \u2265 1 and the right inequality structure"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Since $a_N$ is a fixed positive number and $0 < r < 1$, we know that $r^k \to 0$ as $k \to \\infty$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2];\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1];\n\u2022 There exists a natural number $N$ such that for all $n \\geq N$, $\\frac{a_{n+1}}{a_n} < r$ [l2];\n\u2022 For the $N$ from [l2], for all $n \\geq N$, $a_{n+1} < r \\cdot a_n$ [l3];\n\u2022 For the $N$ from [l2] and for all integers $k \\geq 1$, $a_{N+k} < r^k \\cdot a_N$ [l4].\nTherefore, we conclude:\n\u2022 $\\lim_{k \\to \\infty} r^k = 0$ [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N) :\n  Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N) :\n  Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0) := by\n  have h\u2080 : 0 < r := by\n    have h\u2080\u2081 : 0 < L := tc_2.1\n    have h\u2080\u2082 : L < r := l1.1\n    linarith\n  \n  have h\u2081 : r < 1 := by\n    have h\u2081\u2081 : r < 1 := l1.2\n    exact h\u2081\u2081\n  \n  have h\u2082 : Filter.Tendsto (fun k : \u2115 => r ^ k) Filter.atTop (nhds 0) := by\n    have h\u2083 : 0 < r := h\u2080\n    have h\u2084 : r < 1 := h\u2081\n    have h\u2085 : 0 < (1 : \u211d) / r := by positivity\n    have h\u2086 : (1 : \u211d) / r > 1 := by\n      have h\u2086\u2081 : 0 < r := h\u2080\n      have h\u2086\u2082 : r < 1 := h\u2081\n      have h\u2086\u2083 : (1 : \u211d) / r > 1 := by\n        rw [gt_iff_lt]\n        rw [lt_div_iff h\u2086\u2081]\n        nlinarith\n      exact h\u2086\u2083\n    -- Use the fact that (1/r)^n tends to infinity to find N such that (1/r)^N > 1/\u03b5\n    have h\u2087 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k) Filter.atTop (nhds 0) := by\n      -- Use the definition of tendsto to show that for any \u03b5 > 0, there exists N such that for all n \u2265 N, |r^n - 0| < \u03b5\n      have h\u2088 : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 (\u2203 (N : \u2115), \u2200 (n : \u2115), n \u2265 N \u2192 (r : \u211d) ^ n < \u03b5) := by\n        intro \u03b5 h\u03b5\n        -- Use the Archimedean property to find N such that (1/r)^N > 1/\u03b5\n        have h\u2089 : \u2203 (N : \u2115), (1 / r : \u211d) ^ N > 1 / \u03b5 := by\n          -- Use the fact that (1/r)^n tends to infinity\n          have h\u2081\u2080 : Filter.Tendsto (fun n : \u2115 => (1 / r : \u211d) ^ n) Filter.atTop Filter.atTop := by\n            -- Prove that (1/r)^n tends to infinity\n            have h\u2081\u2081 : 1 < (1 / r : \u211d) := by\n              linarith\n            exact tendsto_pow_atTop_atTop_of_one_lt h\u2081\u2081\n          -- Use the definition of tendsto to find N\n          have h\u2081\u2082 : \u2203 (N : \u2115), (1 / \u03b5 : \u211d) < (1 / r : \u211d) ^ N := by\n            have h\u2081\u2083 : Filter.Tendsto (fun n : \u2115 => (1 / r : \u211d) ^ n) Filter.atTop Filter.atTop := h\u2081\u2080\n            have h\u2081\u2084 : (1 / \u03b5 : \u211d) < \u221e := by\n              have h\u2081\u2085 : 0 < \u03b5 := h\u03b5\n              have h\u2081\u2086 : (1 / \u03b5 : \u211d) < \u221e := by\n                norm_num\n                <;>\n                (try positivity)\n                <;>\n                (try linarith)\n              exact h\u2081\u2086\n            have h\u2081\u2085 : \u2203 (N : \u2115), (1 / \u03b5 : \u211d) < (1 / r : \u211d) ^ N := by\n              -- Use the fact that (1/r)^n tends to infinity\n              have h\u2081\u2086 := h\u2081\u2083.eventually (Filter.eventually_gt_atTop (1 / \u03b5))\n              simp only [Filter.eventually_atTop] at h\u2081\u2086\n              obtain \u27e8N, hN\u27e9 := h\u2081\u2086\n              refine' \u27e8N, _\u27e9\n              specialize hN N (by linarith)\n              linarith\n            exact h\u2081\u2085\n          obtain \u27e8N, hN\u27e9 := h\u2081\u2082\n          refine' \u27e8N, _\u27e9\n          linarith\n        obtain \u27e8N, hN\u27e9 := h\u2089\n        use N\n        intro n hn\n        have h\u2081\u2080 : (r : \u211d) ^ n < \u03b5 := by\n          have h\u2081\u2081 : (1 / r : \u211d) ^ N > 1 / \u03b5 := hN\n          have h\u2081\u2082 : (1 / r : \u211d) ^ n \u2265 (1 / r : \u211d) ^ N := by\n            -- Since 1/r > 1, (1/r)^n is increasing\n            have h\u2081\u2083 : 1 < (1 / r : \u211d) := by linarith\n            have h\u2081\u2084 : (n : \u2115) \u2265 N := by exact_mod_cast hn\n            exact pow_le_pow_right (by linarith) (by exact_mod_cast hn)\n          have h\u2081\u2083 : (1 / r : \u211d) ^ n > 1 / \u03b5 := by linarith\n          have h\u2081\u2084 : (r : \u211d) ^ n < \u03b5 := by\n            -- Use the fact that (1/r)^n > 1/\u03b5 implies r^n < \u03b5\n            have h\u2081\u2085 : 0 < (r : \u211d) := by positivity\n            have h\u2081\u2086 : 0 < (r : \u211d) ^ n := by positivity\n            have h\u2081\u2087 : 0 < \u03b5 := h\u03b5\n            have h\u2081\u2088 : 0 < (1 / r : \u211d) ^ n := by positivity\n            have h\u2081\u2089 : (1 / r : \u211d) ^ n > 1 / \u03b5 := h\u2081\u2083\n            have h\u2082\u2080 : (r : \u211d) ^ n < \u03b5 := by\n              calc\n                (r : \u211d) ^ n = 1 / (1 / r : \u211d) ^ n := by\n                  field_simp [h\u2083.ne']\n                  <;>\n                  ring_nf\n                  <;>\n                  field_simp [h\u2083.ne']\n                  <;>\n                  ring_nf\n                _ < 1 / (1 / \u03b5) := by\n                  apply one_div_lt_one_div_of_lt\n                  \u00b7 positivity\n                  \u00b7 linarith\n                _ = \u03b5 := by\n                  field_simp [h\u03b5.ne']\n                  <;>\n                  ring_nf\n                  <;>\n                  field_simp [h\u03b5.ne']\n                  <;>\n                  linarith\n            exact h\u2082\u2080\n          exact h\u2081\u2084\n        exact h\u2081\u2080\n      -- Use the definition of tendsto to conclude the proof\n      have h\u2089 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k) Filter.atTop (nhds 0) := by\n        rw [Metric.tendsto_atTop]\n        intro \u03b5 h\u03b5\n        obtain \u27e8N, hN\u27e9 := h\u2088 \u03b5 h\u03b5\n        use N\n        intro n hn\n        have h\u2081\u2080 : (r : \u211d) ^ n < \u03b5 := hN n hn\n        have h\u2081\u2081 : (r : \u211d) ^ n \u2265 0 := by positivity\n        have h\u2081\u2082 : dist ((r : \u211d) ^ n) 0 < \u03b5 := by\n          rw [dist_eq_norm]\n          rw [norm_eq_abs]\n          rw [abs_of_nonneg h\u2081\u2081]\n          linarith\n        exact h\u2081\u2082\n      exact h\u2089\n    exact h\u2087\n  \n  exact h\u2082", "lean_pass": false, "lean_verify": false, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The positivity condition for the sequence is correctly formalized.", "The limit condition and bounds on L are properly captured using Lean's filter-based limit notation.", "The bounds on r are correctly expressed, with r appropriately declared as a parameter.", "The eventual bound condition on ratios is properly formalized, with N as a parameter.", "The multiplicative bound condition is correctly captured.", "The exponential bound condition is properly formalized using natural numbers for k \u2265 1.", "The conclusion about the limit of r^k going to 0 is correctly expressed using filter notation.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N) :\n  Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0) := by\n  have h_r_pos : 0 < r := by\n    have hL : 0 < L := tc_2.1\n    have hLr : L < r := l1.1\n    linarith\n  \n  have h_r_lt_one : r < 1 := by\n    have h\u2081 : r < 1 := l1.2\n    exact h\u2081\n  \n  have h_decreasing : \u2200 (k : \u2115), (r : \u211d) ^ (k + 1) < (r : \u211d) ^ k := by\n    intro k\n    have h\u2081 : 0 < r := h_r_pos\n    have h\u2082 : r < 1 := h_r_lt_one\n    have h\u2083 : 0 < (r : \u211d) ^ k := pow_pos h\u2081 k\n    have h\u2084 : (r : \u211d) ^ (k + 1) = r * (r : \u211d) ^ k := by\n      ring_nf\n      <;> simp [pow_succ]\n      <;> ring_nf\n    rw [h\u2084]\n    have h\u2085 : r * (r : \u211d) ^ k < (r : \u211d) ^ k := by\n      have h\u2085\u2081 : r < 1 := h_r_lt_one\n      have h\u2085\u2082 : 0 < (r : \u211d) ^ k := pow_pos h\u2081 k\n      nlinarith\n    linarith\n  \n  have h_bounded_below : \u2200 (k : \u2115), 0 \u2264 (r : \u211d) ^ k := by\n    intro k\n    have h\u2081 : 0 < r := h_r_pos\n    have h\u2082 : 0 \u2264 (r : \u211d) ^ k := by\n      exact pow_nonneg (le_of_lt h\u2081) k\n    exact h\u2082\n  \n  have h_tendsto : Filter.Tendsto (fun k => (r : \u211d) ^ k) Filter.atTop (nhds 0) := by\n    have h\u2081 : 0 < r := h_r_pos\n    have h\u2082 : r < 1 := h_r_lt_one\n    -- We use the fact that the sequence is decreasing and bounded below to show it converges to 0.\n    have h\u2083 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k) Filter.atTop (nhds 0) := by\n      -- Use the property of geometric sequences with ratio < 1.\n      have h\u2084 : \u2200 n : \u2115, (r : \u211d) ^ n \u2265 0 := by\n        intro n\n        exact pow_nonneg (le_of_lt h\u2081) n\n      -- Use the fact that the sequence is decreasing and bounded below by 0.\n      have h\u2085 : Antitone (fun k : \u2115 => (r : \u211d) ^ k) := by\n        refine' antitone_of_forall_lt _\n        intro n m hnm\n        have h\u2086 : (r : \u211d) ^ (n + 1) < (r : \u211d) ^ n := h_decreasing n\n        have h\u2087 : (r : \u211d) ^ m \u2264 (r : \u211d) ^ (n + 1) := by\n          -- Since the sequence is decreasing, for m > n + 1, r^m \u2264 r^(n+1)\n          have h\u2088 : m \u2265 n + 1 := by omega\n          have h\u2089 : (r : \u211d) ^ m \u2264 (r : \u211d) ^ (n + 1) := by\n            -- Use the fact that the sequence is decreasing\n            exact pow_le_pow_of_le_one (by linarith) (by linarith) (by omega)\n          exact h\u2089\n        have h\u2088 : (r : \u211d) ^ m < (r : \u211d) ^ n := by linarith\n        linarith\n      -- Use the fact that the sequence is bounded below by 0 and decreasing to show it converges to 0.\n      have h\u2086 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k) Filter.atTop (nhds 0) := by\n        -- Use the property of geometric sequences with ratio < 1.\n        have h\u2087 : 0 \u2264 r := by linarith\n        have h\u2088 : r < 1 := h\u2082\n        -- Use the fact that the sequence is decreasing and bounded below by 0.\n        have h\u2089 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k) Filter.atTop (nhds 0) := by\n          -- Use the property of geometric sequences with ratio < 1.\n          have h\u2081\u2080 : 0 \u2264 r := by linarith\n          have h\u2081\u2081 : r < 1 := h\u2082\n          -- Use the fact that the sequence is decreasing and bounded below by 0.\n          exact tendsto_pow_atTop_nhds_0_of_lt_1 (by linarith) h\u2081\u2081\n        exact h\u2089\n      exact h\u2086\n    exact h\u2083\n  \n  exact h_tendsto"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Therefore, given any $\\epsilon > 0$, we can choose $K$ large enough so that $r^k \\cdot a_N < \\epsilon$ for all $k \\geq K$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2];\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1];\n\u2022 There exists a natural number $N$ such that for all $n \\geq N$, $\\frac{a_{n+1}}{a_n} < r$ [l2];\n\u2022 For the $N$ from [l2], for all $n \\geq N$, $a_{n+1} < r \\cdot a_n$ [l3];\n\u2022 For the $N$ from [l2] and for all integers $k \\geq 1$, $a_{N+k} < r^k \\cdot a_N$ [l4];\n\u2022 $\\lim_{k \\to \\infty} r^k = 0$ [l5].\nTherefore, we conclude:\n\u2022 $\\lim_{k \\to \\infty} (r^k \\cdot a_N) = 0$ [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N)\n  (l5 : Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0)) :\n  Filter.Tendsto (fun k => r^k * a N) Filter.atTop (nhds 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6\n  (a : \u2115 \u2192 \u211d)\n  (L r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N)\n  (l5 : Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0)) :\n  Filter.Tendsto (fun k => r^k * a N) Filter.atTop (nhds 0) := by\n  have h_main : Filter.Tendsto (fun k => r^k * a N) Filter.atTop (nhds 0) := by\n    have h\u2081 : Filter.Tendsto (fun k => r ^ k * a N) Filter.atTop (nhds (0 * a N)) := by\n      -- Use the fact that the limit of r^k is 0 and multiply by the constant a N\n      have h\u2082 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k) Filter.atTop (nhds 0) := l5\n      -- Apply the multiplication by a constant to the limit\n      have h\u2083 : Filter.Tendsto (fun k : \u2115 => (r : \u211d) ^ k * a N) Filter.atTop (nhds (0 * a N)) :=\n        h\u2082.mul_const (a N)\n      exact h\u2083\n    -- Simplify the limit to show it is 0\n    have h\u2084 : (0 : \u211d) * a N = 0 := by\n      have h\u2085 : 0 < a N := tc_1 N\n      ring\n    -- Use the simplified form to conclude the proof\n    have h\u2085 : Filter.Tendsto (fun k => r ^ k * a N) Filter.atTop (nhds 0) := by\n      convert h\u2081 using 1\n      <;> simp [h\u2084]\n    exact h\u2085\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The sequence positivity condition (tc_1), limit condition with bounds (tc_2), intermediate value existence (l1), ratio bounds (l2), recursive inequality (l3), exponential bounds (l4), limit of powers (l5), and final conclusion (l6) are all accurately represented. The use of Filter.Tendsto for limits is the appropriate Lean mathematical notation. The logical structure is preserved with all assumptions as hypotheses and the conclusion as the theorem goal."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "This shows that $a_{N+k} < \\epsilon$ for all $k \\geq K$, which means $\\lim_{n \to \\infty} a_n = 0$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\in \\mathbb{N}}$ is a sequence of real numbers such that for all $n \\in \\mathbb{N}$, $a_n > 0$ [tc_1];\n\u2022 The limit of the ratio of consecutive terms is $\\lim_{n \\to \\infty} \\frac{a_{n+1}}{a_n} = L$, where $L$ is a real number satisfying $0 < L < 1$ [tc_2];\n\u2022 There exists a real number $r$ such that $L < r < 1$ [l1];\n\u2022 There exists a natural number $N$ such that for all $n \\geq N$, $\\frac{a_{n+1}}{a_n} < r$ [l2];\n\u2022 For the $N$ from [l2], for all $n \\geq N$, $a_{n+1} < r \\cdot a_n$ [l3];\n\u2022 For the $N$ from [l2] and for all integers $k \\geq 1$, $a_{N+k} < r^k \\cdot a_N$ [l4];\n\u2022 $\\lim_{k \\to \\infty} r^k = 0$ [l5];\n\u2022 $\\lim_{k \\to \\infty} (r^k \\cdot a_N) = 0$ [l6].\nTherefore, we conclude:\n\u2022 $\\lim_{n \\to \\infty} a_n = 0$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N)\n  (l5 : Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0))\n  (l6 : Filter.Tendsto (fun k => r^k * a N) Filter.atTop (nhds 0)) :\n  Filter.Tendsto a Filter.atTop (nhds 0) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N)\n  (l5 : Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0))\n  (l6 : Filter.Tendsto (fun k => r^k * a N) Filter.atTop (nhds 0)) :\n  Filter.Tendsto a Filter.atTop (nhds 0) := by\n  have h_r_pos : 0 < r := by\n    have h\u2080 : 0 < L := tc_2.1\n    have h\u2081 : L < r := l1.1\n    linarith\n  \n  have h_main : Filter.Tendsto a Filter.atTop (nhds 0) := by\n    have h\u2080 : a N > 0 := tc_1 N\n    -- Use the metric space definition of tendsto to prove the limit\n    have h\u2081 : Filter.Tendsto a Filter.atTop (nhds 0) := by\n      -- Use the definition of tendsto in metric spaces\n      rw [Metric.tendsto_atTop]\n      intro \u03b5 \u03b5pos\n      -- Use the fact that r^k * a N tends to 0 to find K\n      have h\u2082 : \u2203 (K : \u2115), \u2200 (k : \u2115), k \u2265 K \u2192 |(r : \u211d)^k * a N - 0| < \u03b5 := by\n        have h\u2083 : Filter.Tendsto (fun k : \u2115 => (r : \u211d)^k * a N) Filter.atTop (nhds 0) := l6\n        have h\u2084 : \u2200 \u03b5 > 0, \u2203 (K : \u2115), \u2200 (k : \u2115), k \u2265 K \u2192 |(r : \u211d)^k * a N - 0| < \u03b5 := by\n          intro \u03b5 \u03b5pos\n          have h\u2085 : Filter.Tendsto (fun k : \u2115 => (r : \u211d)^k * a N) Filter.atTop (nhds 0) := l6\n          have h\u2086 : \u2200 \u03b5 > 0, \u2203 (K : \u2115), \u2200 (k : \u2115), k \u2265 K \u2192 |(r : \u211d)^k * a N - 0| < \u03b5 := by\n            intro \u03b5 \u03b5pos\n            have h\u2087 := Metric.tendsto_atTop.mp h\u2085 \u03b5 \u03b5pos\n            obtain \u27e8K, hK\u27e9 := h\u2087\n            refine' \u27e8K, _\u27e9\n            intro k hk\n            specialize hK k hk\n            simpa [sub_zero] using hK\n          exact h\u2086 \u03b5 \u03b5pos\n        exact h\u2084 \u03b5 \u03b5pos\n      obtain \u27e8K, hK\u27e9 := h\u2082\n      -- Define M = N + K + 1\n      use N + K + 1\n      intro n hn\n      have h\u2083 : n \u2265 N + K + 1 := hn\n      have h\u2084 : \u2203 (m : \u2115), m \u2265 1 \u2227 (n : \u2115) = N + m := by\n        use (n - N : \u2115)\n        have h\u2085 : (n : \u2115) \u2265 N + K + 1 := by exact_mod_cast h\u2083\n        have h\u2086 : (n : \u2115) \u2265 N := by linarith\n        have h\u2087 : (n : \u2115) - N \u2265 K + 1 := by\n          have h\u2088 : (n : \u2115) \u2265 N + K + 1 := by exact_mod_cast h\u2083\n          omega\n        have h\u2088 : (n : \u2115) - N \u2265 1 := by\n          have h\u2089 : (n : \u2115) - N \u2265 K + 1 := h\u2087\n          have h\u2081\u2080 : K + 1 \u2265 1 := by\n            have h\u2081\u2081 : K \u2265 0 := by exact Nat.zero_le K\n            linarith\n          omega\n        constructor\n        \u00b7 exact_mod_cast h\u2088\n        \u00b7 have h\u2089 : (n : \u2115) = N + (n - N : \u2115) := by\n            have h\u2081\u2080 : (n : \u2115) \u2265 N := by\n              have h\u2081\u2081 : (n : \u2115) \u2265 N + K + 1 := by exact_mod_cast h\u2083\n              linarith\n            omega\n          exact_mod_cast h\u2089\n      obtain \u27e8m, hm\u2081, hm\u2082\u27e9 := h\u2084\n      have h\u2085 : (m : \u2115) \u2265 1 := by exact_mod_cast hm\u2081\n      have h\u2086 : (n : \u2115) = N + m := by exact_mod_cast hm\u2082\n      have h\u2087 : a (N + m) < (r : \u211d)^m * a N := by\n        have h\u2088 : (m : \u2115) \u2265 1 := by exact_mod_cast hm\u2081\n        have h\u2089 : a (N + m) < (r : \u211d)^m * a N := l4 m (by exact_mod_cast h\u2088)\n        exact h\u2089\n      have h\u2088 : (r : \u211d)^m * a N < \u03b5 := by\n        have h\u2089 : (m : \u2115) \u2265 K := by\n          have h\u2081\u2080 : (n : \u2115) \u2265 N + K + 1 := by exact_mod_cast h\u2083\n          have h\u2081\u2081 : (n : \u2115) = N + m := by exact_mod_cast hm\u2082\n          have h\u2081\u2082 : (N + m : \u2115) \u2265 N + K + 1 := by linarith\n          have h\u2081\u2083 : (m : \u2115) \u2265 K + 1 := by\n            omega\n          omega\n        have h\u2081\u2080 : |(r : \u211d)^m * a N - 0| < \u03b5 := hK m (by exact_mod_cast h\u2089)\n        have h\u2081\u2081 : (r : \u211d)^m * a N > 0 := by\n          have h\u2081\u2082 : (r : \u211d) > 0 := h_r_pos\n          have h\u2081\u2083 : (r : \u211d)^m > 0 := pow_pos h\u2081\u2082 m\n          have h\u2081\u2084 : a N > 0 := tc_1 N\n          positivity\n        have h\u2081\u2082 : |(r : \u211d)^m * a N - 0| = (r : \u211d)^m * a N := by\n          rw [abs_of_pos (by linarith)]\n          <;> ring_nf\n        rw [h\u2081\u2082] at h\u2081\u2080\n        linarith\n      have h\u2089 : a n < \u03b5 := by\n        have h\u2081\u2080 : a n = a (N + m) := by\n          rw [hm\u2082]\n          <;> simp [add_comm]\n        rw [h\u2081\u2080]\n        linarith\n      have h\u2081\u2080 : a n > 0 := tc_1 n\n      have h\u2081\u2081 : |a n - 0| < \u03b5 := by\n        rw [abs_sub_lt_iff]\n        constructor <;> linarith\n      exact h\u2081\u2081\n    exact h\u2081\n  \n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 43, "column": 12, "endLine": 43, "endColumn": 37, "data": "type mismatch, term\n  hK\nafter simplification has type\n  |r| ^ k * |a N| < \u03b5 : Prop\nbut is expected to have type\n  |r ^ k * a N| < \u03b5 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The positivity condition for the sequence is correctly captured.", "Both the limit condition and bounds on L are properly formalized.", "Natural language states existence of r, while Lean assumes r as a parameter. Semantically equivalent but structurally different.", "Natural language states existence of N, while Lean assumes N as a parameter. Semantically equivalent but structurally different.", "The inequality condition is perfectly captured.", "The recursive bound condition is correctly formalized.", "The limit of r^k to 0 is properly expressed.", "The limit of the product r^k * a_N to 0 is correctly captured.", "The conclusion that the sequence tends to 0 is perfectly formalized.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=0.78 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1\n  (a : \u2115 \u2192 \u211d)\n  (L : \u211d)\n  (r : \u211d)\n  (N : \u2115)\n  (tc_1 : \u2200 n, 0 < a n)\n  (tc_2 : 0 < L \u2227 L < 1 \u2227 Filter.Tendsto (fun n => a (n + 1) / a n) Filter.atTop (nhds L))\n  (l1 : L < r \u2227 r < 1)\n  (l2 : \u2200 n \u2265 N, a (n + 1) / a n < r)\n  (l3 : \u2200 n \u2265 N, a (n + 1) < r * a n)\n  (l4 : \u2200 k : \u2115, k \u2265 1 \u2192 a (N + k) < r^k * a N)\n  (l5 : Filter.Tendsto (fun k => r^k) Filter.atTop (nhds 0))\n  (l6 : Filter.Tendsto (fun k => r^k * a N) Filter.atTop (nhds 0)) :\n  Filter.Tendsto a Filter.atTop (nhds 0) := by\n  have h_r_pos : 0 < r := by\n    have h1 : 0 < L := tc_2.1\n    have h2 : L < r := l1.1\n    linarith\n  \n  have h_main : Filter.Tendsto a Filter.atTop (nhds 0) := by\n    have h_pos_aN : 0 < a N := tc_1 N\n    -- Use the fact that r^k * a N tends to 0 to find a bound for a_{N+k}\n    have h\u2081 : Filter.Tendsto (fun n : \u2115 => a n) Filter.atTop (nhds 0) := by\n      -- Show that for any \u03b5 > 0, there exists K such that for all n \u2265 N + K, a_n < \u03b5\n      have h\u2082 : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 (\u2203 K : \u2115, \u2200 k : \u2115, k \u2265 K \u2192 r ^ k * a N < \u03b5) := by\n        intro \u03b5 h\u03b5\n        have h\u2083 : Filter.Tendsto (fun k : \u2115 => r ^ k * a N) Filter.atTop (nhds 0) := l6\n        have h\u2084 : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 (\u2203 K : \u2115, \u2200 k : \u2115, k \u2265 K \u2192 r ^ k * a N < \u03b5) := by\n          intro \u03b5 h\u03b5\n          have h\u2085 : Filter.Tendsto (fun k : \u2115 => r ^ k * a N) Filter.atTop (nhds 0) := l6\n          have h\u2086 : \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 (\u2203 K : \u2115, \u2200 k : \u2115, k \u2265 K \u2192 |(r : \u211d) ^ k * a N - 0| < \u03b5) :=\n            Metric.tendsto_atTop.mp h\u2085\n          obtain \u27e8K, hK\u27e9 := h\u2086 \u03b5 h\u03b5\n          refine' \u27e8K, _\u27e9\n          intro k hk\n          have h\u2087 : |(r : \u211d) ^ k * a N - 0| < \u03b5 := hK k hk\n          have h\u2088 : (r : \u211d) ^ k * a N \u2265 0 := by\n            have h\u2089 : (r : \u211d) > 0 := by exact_mod_cast h_r_pos\n            have h\u2081\u2080 : (r : \u211d) ^ k > 0 := pow_pos h\u2089 k\n            have h\u2081\u2081 : a N > 0 := by exact_mod_cast h_pos_aN\n            positivity\n          have h\u2089 : |(r : \u211d) ^ k * a N - 0| = (r : \u211d) ^ k * a N := by\n            rw [abs_of_nonneg (by linarith)]\n            <;> simp\n          rw [h\u2089] at h\u2087\n          linarith\n        exact h\u2084 \u03b5 h\u03b5\n      -- Use the bound to show that a_n tends to 0\n      have h\u2083 : Filter.Tendsto (fun n : \u2115 => a n) Filter.atTop (nhds 0) := by\n        refine' Metric.tendsto_atTop.mpr _\n        intro \u03b5 h\u03b5\n        -- Find K such that for all k \u2265 K, r^k * a N < \u03b5\n        obtain \u27e8K, hK\u27e9 := h\u2082 \u03b5 h\u03b5\n        use N + max 1 K\n        intro n hn\n        have h\u2084 : n \u2265 N + max 1 K := hn\n        have h\u2085 : \u2203 k : \u2115, n = N + k := by\n          use n - N\n          have h\u2085\u2081 : n \u2265 N := by\n            have h\u2085\u2082 : n \u2265 N + max 1 K := h\u2084\n            have h\u2085\u2083 : N + max 1 K \u2265 N := by\n              have h\u2085\u2084 : max 1 K \u2265 0 := by positivity\n              linarith\n            linarith\n          have h\u2085\u2082 : n = N + (n - N) := by\n            omega\n          exact h\u2085\u2082\n        obtain \u27e8k, hk\u27e9 := h\u2085\n        have h\u2086 : k \u2265 max 1 K := by\n          have h\u2086\u2081 : n \u2265 N + max 1 K := h\u2084\n          have h\u2086\u2082 : n = N + k := hk\n          omega\n        have h\u2087 : k \u2265 1 := by\n          have h\u2087\u2081 : k \u2265 max 1 K := h\u2086\n          have h\u2087\u2082 : max 1 K \u2265 1 := by\n            apply le_max_left\n          linarith\n        have h\u2088 : k \u2265 K := by\n          have h\u2088\u2081 : k \u2265 max 1 K := h\u2086\n          have h\u2088\u2082 : max 1 K \u2265 K := by\n            apply le_max_right\n          linarith\n        have h\u2089 : a (N + k) < r ^ k * a N := l4 k (by omega)\n        have h\u2081\u2080 : a n = a (N + k) := by\n          rw [hk]\n        rw [h\u2081\u2080]\n        have h\u2081\u2081 : r ^ k * a N < \u03b5 := hK k h\u2088\n        have h\u2081\u2082 : 0 < a (N + k) := tc_1 (N + k)\n        have h\u2081\u2083 : a (N + k) < \u03b5 := by\n          linarith\n        have h\u2081\u2084 : |a (N + k) - 0| < \u03b5 := by\n          rw [abs_sub_lt_iff]\n          constructor <;> linarith [h\u2081\u2082]\n        simpa [sub_zero] using h\u2081\u2084\n      exact h\u2083\n    exact h\u2081\n  \n  exact h_main"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    