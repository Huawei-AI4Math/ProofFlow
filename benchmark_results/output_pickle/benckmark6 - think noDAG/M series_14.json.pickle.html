
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=1$ and the recurrence relation $a_n=a_{n-1}+2a_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the formula for the nth term is $a_n = 2^{n-1} + (-1)^n+1}$.

Proof: **Proof:** We will prove this by **strong mathematical induction** on $n$. First, we verify the formula for the base cases, $n=1$ and $n=2$. For $n=1$, the formula gives $a_1=2^{1-1}+(-1)^{1+1}=2^0+(-1)^2=1+1=2$. This matches the given $a_1=2$. For $n=2$, the formula gives $a_2=2^{2-1}+(-1)^{2+1}=2^1+(-1)^3=2-1=1$. This also matches the given $a_2=1$. Now, for the inductive step, we assume the formula holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j = 2^{j-1}+(-1)^{j+1}$. We want to show the statement is true for $n=k+1$, i.e., $a_{k+1}=2^{k}+(-1)^{k+2}$. We have the recurrence relation $a_{k+1}=a_k+2a_{k-1}$. By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+(-1)^{k+1}$ and $a_{k-1}=2^{k-2}+(-1)^k$. So, $a_{k+1}=(2^{k-1}+(-1)^{k+1})+2(2^{k-2}+(-1)^k)$. We simplify the expression by combining terms. $a_{k+1}=(2^{k-1}+2 \cdot 2^{k-2})+((-1)^{k+1}+2(-1)^k)$. The first term simplifies to $2^{k-1}+2^{k-1}=2 \cdot 2^{k-1}=2^k$. The second term simplifies to $-(-1)^k+2(-1)^k=(-1)^k$. And we know that $(-1)^{k+2}=(-1)^k$. Thus, $a_{k+1}=2^k+(-1)^k=2^k+(-1)^{k+2}$. This matches the formula for $n=k+1$. By the principle of strong mathematical induction, the formula is true for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(a_n)$ be a sequence defined by $a_1=2$, $a_2=1$ and the recurrence relation $a_n=a_{n-1}+2a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a : \u2115 \u2192 \u2124)\n(tc_1 : a 1 = 2 \u2227 a 2 = 1 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration `variable (a : \u2115 \u2192 \u2124)` correctly captures that a is a sequence of integers indexed by natural numbers, which corresponds to the mathematical notation $(a_n)_{n \u2265 1}$", "The Lean condition `a 1 = 2` directly matches the mathematical statement $a_1 = 2$", "The Lean condition `a 2 = 1` directly matches the mathematical statement $a_2 = 1$", "The Lean condition `\u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)` correctly formalizes the recurrence relation $a_n = a_{n-1} + 2a_{n-2}$ for all integers $n \u2265 3$. The use of natural numbers instead of integers for the index is appropriate since we're dealing with sequence indices", "The Lean formalization completely captures the well-defined nature of the sequence by providing all the initial conditions and recurrence relation in a single conjunctive statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, the formula gives $a_1=2^{1-1}+(-1)^{1+1}=2^0+(-1)^2=1+1=2$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\nTherefore, we conclude:\n\u2022 For $n=1$, the formula $2^{n-1} + (-1)^{n+1}$ evaluates to $2$ [l1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)) :\n  (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a : \u2115 \u2192 \u2124) \n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)) :\n  (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2 := by\n  have h4 : (2 : \u2124)^(1-1) = 1 := by\n    norm_num\n    <;>\n    simp [pow_zero]\n    <;>\n    norm_num\n  \n  have h5 : (-1 : \u2124)^(1+1) = 1 := by\n    norm_num\n    <;>\n    simp [pow_two]\n    <;>\n    norm_num\n  \n  have h6 : (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2 := by\n    rw [h4, h5]\n    <;> norm_num\n  \n  apply h6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition with initial conditions a\u2081=2, a\u2082=1 and recurrence relation is correctly captured in the Lean hypotheses h1, h2, and h3.", "The formula evaluation 2^(n-1) + (-1)^(n+1) = 2 for n=1 is correctly represented as the arithmetic statement (2:\u2124)^(1-1) + (-1:\u2124)^(1+1) = 2.", "The natural language presents the formula evaluation as a conclusion that follows from the sequence definition ('Therefore, we conclude...'), but the Lean formalization treats this as a standalone arithmetic fact that doesn't use the sequence properties at all. This breaks the logical flow implied in the natural language."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition with initial conditions a\u2081=2, a\u2082=1 and recurrence relation is correctly captured in the Lean hypotheses h1, h2, and h3.', 'The formula evaluation 2^(n-1) + (-1)^(n+1) = 2 for n=1 is correctly represented as the arithmetic statement (2:\u2124)^(1-1) + (-1:\u2124)^(1+1) = 2.', \"The natural language presents the formula evaluation as a conclusion that follows from the sequence definition ('Therefore, we conclude...'), but the Lean formalization treats this as a standalone arithmetic fact that doesn't use the sequence properties at all. This breaks the logical flow implied in the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "This matches the given $a_1=2$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 For $n=1$, the formula $2^{n-1} + (-1)^{n+1}$ evaluates to $2$ [l1].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=1$ [l2].", "dependencies": ["tc_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (l1 : (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2) :\n  a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (l1 : (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2) :\n  a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) := by\n  have h_main : a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) := by\n    have h4 : a 1 = 2 := h1\n    have h5 : (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2 := l1\n    -- Use the given hypotheses to prove the main statement by transitivity of equality\n    linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition with initial conditions and recurrence relation is correctly formalized with appropriate type declarations", "The formula evaluation for n=1 is properly captured as a hypothesis with correct type annotations", "The conclusion is correctly stated as the theorem goal, showing that a_1 equals the formula value"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "For $n=2$, the formula gives $a_2=2^{2-1}+(-1)^{2+1}=2^1+(-1)^3=2-1=1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 For $n=1$, the formula $2^{n-1} + (-1)^{n+1}$ evaluates to $2$ [l1].\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=1$ [l2].\nTherefore, we conclude:\n\u2022 For $n=2$, the formula $2^{n-1} + (-1)^{n+1}$ evaluates to $1$ [l3].", "dependencies": ["tc_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 : (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1 := by\n  have h\u2081 : (2 : \u2124)^(2-1) = 2 := by\n    norm_num\n    <;> rfl\n  \n  have h\u2082 : (-1 : \u2124)^(2+1) = -1 := by\n    norm_num\n    <;> rfl\n  \n  have h\u2083 : (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1 := by\n    rw [h\u2081, h\u2082]\n    <;> norm_num\n  \n  exact h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the core mathematical statement from the natural language. While it doesn't explicitly reference the context (sequence definition, previous lemmas), it accurately translates the specific claim that 2^(2-1) + (-1)^(2+1) = 1. The type annotations for integers are appropriate additions that don't change the mathematical meaning. The theorem structure properly represents the conclusion being drawn."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "This also matches the given $a_2=1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 For $n=1$, the formula $2^{n-1} + (-1)^{n+1}$ evaluates to $2$ [l1].\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=1$ [l2].\n\u2022 For $n=2$, the formula $2^{n-1} + (-1)^{n+1}$ evaluates to $1$ [l3].\nTherefore, we conclude:\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=2$ [l4].", "dependencies": ["tc_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (l1 : (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2)\n  (l2 : a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1))\n  (l3 : (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1) :\n  a 2 = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l4 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (l1 : (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1) = 2)\n  (l2 : a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1))\n  (l3 : (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1) :\n  a 2 = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) := by\n  have h_main : a 2 = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) := by\n    have h4 : a 2 = 1 := h2\n    have h5 : (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1 := l3\n    -- Rewrite the goal using h4 and h5\n    calc\n      a 2 = 1 := by rw [h4]\n      _ = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) := by\n        -- Use the fact that (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1) = 1\n        linarith\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence definition is correctly formalized with proper types (\u2115 \u2192 \u2124) and all three defining conditions (initial values and recurrence relation)", "The formula evaluation for n=1 is accurately represented with explicit type annotations", "The statement that the formula holds for n=1 is correctly captured as an equality between a 1 and the formula value", "The formula evaluation for n=2 is accurately represented with correct substitution", "The conclusion is properly formalized as the goal statement, showing that a 2 equals the formula value at n=2"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now, for the inductive step, we assume the formula holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j = 2^{j-1}+(-1)^{j+1}$.", "statement": "Definition:\n\u2022 For the inductive step, we assume for some integer $k \\geq 2$ that for all integers $j$ with $1 \\leq j \\leq k$, the formula $a_j = 2^{j-1}+(-1)^{j+1}$ holds (this is the Inductive Hypothesis) [def_1].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem def_1 \n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The inductive step context is implicitly captured in the Lean theorem structure with the inductive hypothesis as a premise", "Natural language specifies k as an integer, but Lean uses natural numbers. Since k \u2265 2, this doesn't affect the mathematical meaning but is a type difference", "Natural language specifies j as an integer, but Lean uses natural numbers. Given the constraint 1 \u2264 j \u2264 k, this is mathematically equivalent but represents a minor type inconsistency", "The inductive hypothesis formula is perfectly captured in Lean, with the universal quantification and conditional structure matching exactly"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The inductive step context is implicitly captured in the Lean theorem structure with the inductive hypothesis as a premise', \"Natural language specifies k as an integer, but Lean uses natural numbers. Since k \u2265 2, this doesn't affect the mathematical meaning but is a type difference\", 'Natural language specifies j as an integer, but Lean uses natural numbers. Given the constraint 1 \u2264 j \u2264 k, this is mathematically equivalent but represents a minor type inconsistency', 'The inductive hypothesis formula is perfectly captured in Lean, with the universal quantification and conditional structure matching exactly']"}, "type": "definition"}, "l5": {"id": "l5", "natural_language": "We have the recurrence relation $a_{k+1}=a_k+2a_{k-1}$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=1$ [l2] and $n=2$ [l4].\n\u2022 For some integer $k \\geq 2$, for all integers $j$ with $1 \\leq j \\leq k$, $a_j = 2^{j-1}+(-1)^{j+1}$ [def_1].\nTherefore, we conclude:\n\u2022 $a_{k+1}=a_k+2a_{k-1}$ [l5].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (h_formula : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a (k+1) = a k + 2 * a (k-1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (h_formula : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a (k+1) = a k + 2 * a (k-1) := by\n  have h\u2081 : k + 1 \u2265 3 := by\n    have h\u2081\u2081 : k \u2265 2 := hk\n    have h\u2081\u2082 : k + 1 \u2265 3 := by\n      omega\n    exact h\u2081\u2082\n  \n  have h\u2082 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := by\n    have h\u2082\u2081 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := by\n      have h\u2082\u2082 : k + 1 \u2265 3 := h\u2081\n      have h\u2082\u2083 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := by\n        have h\u2082\u2084 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := by\n          apply h_rec\n          <;> omega\n        exact h\u2082\u2084\n      exact h\u2082\u2083\n    exact h\u2082\u2081\n  \n  have h\u2083 : a (k + 1) = a k + 2 * a (k - 1) := by\n    have h\u2083\u2081 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := h\u2082\n    have h\u2083\u2082 : a (k + 1) = a k + 2 * a (k - 1) := by\n      have h\u2083\u2083 : k + 1 - 1 = k := by\n        have h\u2083\u2084 : k + 1 \u2265 1 := by omega\n        have h\u2083\u2085 : k + 1 - 1 = k := by\n          omega\n        exact h\u2083\u2085\n      have h\u2083\u2086 : k + 1 - 2 = k - 1 := by\n        have h\u2083\u2087 : k \u2265 2 := hk\n        have h\u2083\u2088 : k + 1 \u2265 3 := h\u2081\n        have h\u2083\u2089 : k + 1 - 2 = k - 1 := by\n          omega\n        exact h\u2083\u2089\n      rw [h\u2083\u2081]\n      rw [h\u2083\u2083]\n      rw [h\u2083\u2086]\n      <;>\n      simp_all [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]\n      <;>\n      ring_nf at *\n      <;>\n      omega\n    exact h\u2083\u2082\n  \n  apply h\u2083", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the logical components from the natural language. The recurrence relation, inductive hypothesis with the constraint k\u22652, and the conclusion are all properly formalized. While the explicit initial conditions a\u2081=2 and a\u2082=1 are not stated as separate hypotheses, they are logically contained within the inductive hypothesis h_formula when j=1 and j=2. The conclusion follows directly from applying the recurrence relation to a_{k+1} since k+1\u22653 when k\u22652."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "By the inductive hypothesis, we can substitute the formulas for $a_k$ and $a_{k-1}$. We have $a_k=2^{k-1}+(-1)^{k+1}$ and $a_{k-1}=2^{k-2}+(-1)^k$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 For some integer $k \\geq 2$, for all integers $j$ with $1 \\leq j \\leq k$, $a_j = 2^{j-1}+(-1)^{j+1}$ [def_1].\n Therefore, we conclude:\n\u2022 $a_k = 2^{k-1} + (-1)^{k+1}$ and $a_{k-1} = 2^{k-2} + (-1)^{k-1+1} = 2^{k-2} + (-1)^{k}$ [l6].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a k = 2^(k-1) + (-1)^(k+1) \u2227 a (k-1) = 2^(k-2) + (-1)^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h3 : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a k = 2^(k-1) + (-1)^(k+1) \u2227 a (k-1) = 2^(k-2) + (-1)^k := by\n  have h_k : a k = 2^(k-1) + (-1)^(k+1) := by\n    have h4 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h5 : a k = 2 ^ (k - 1) + (-1 : \u2124) ^ (k + 1) := h k h4\n    exact h5\n  \n  have h_k1 : a (k-1) = 2^(k-2) + (-1)^k := by\n    have h4 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h5 : k \u2265 2 := hk\n      have h6 : 1 \u2264 (k - 1 : \u2115) := by\n        have h7 : k \u2265 2 := hk\n        have h8 : (k : \u2115) - 1 \u2265 1 := by\n          omega\n        omega\n      have h9 : (k - 1 : \u2115) \u2264 k := by\n        have h10 : (k : \u2115) - 1 \u2264 k := by\n          omega\n        omega\n      exact \u27e8h6, h9\u27e9\n    have h5 : a (k - 1) = 2 ^ ((k - 1 : \u2115) - 1 : \u2115) + (-1 : \u2124) ^ ((k - 1 : \u2115) + 1 : \u2115) := h (k - 1) h4\n    have h6 : (k - 1 : \u2115) - 1 = k - 2 := by\n      have h7 : k \u2265 2 := hk\n      have h8 : (k : \u2115) \u2265 2 := by exact_mod_cast h7\n      have h9 : (k : \u2115) - 1 \u2265 1 := by omega\n      have h10 : (k : \u2115) - 1 - 1 = (k : \u2115) - 2 := by\n        omega\n      exact_mod_cast h10\n    have h7 : (k - 1 : \u2115) + 1 = k := by\n      have h8 : k \u2265 2 := hk\n      have h9 : (k : \u2115) \u2265 2 := by exact_mod_cast h8\n      have h10 : (k : \u2115) - 1 + 1 = (k : \u2115) := by\n        omega\n      exact_mod_cast h10\n    rw [h5]\n    rw [h6]\n    rw [h7]\n    <;> norm_num <;>\n    (try omega) <;>\n    (try ring_nf at *) <;>\n    (try simp_all [pow_add, pow_one, mul_assoc]) <;>\n    (try norm_cast) <;>\n    (try omega)\n  \n  have h_main : a k = 2^(k-1) + (-1)^(k+1) \u2227 a (k-1) = 2^(k-2) + (-1)^k := by\n    refine' \u27e8h_k, h_k1\u27e9\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly and completely captures all aspects of the natural language statement. The sequence definition, recurrence relation, assumptions about the formula validity, and the conclusion are all faithfully represented. The logical structure as a theorem with hypotheses leading to a conclusion perfectly matches the natural language presentation. The use of natural numbers for indices and the conjunction for the two-part conclusion are appropriate mathematical formalizations."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "So, $a_{k+1}=(2^{k-1}+(-1)^{k+1})+2(2^{k-2}+(-1)^k)$.", "statement": "We assume:\n\u2022 $a_{k+1}=a_k+2a_{k-1}$ [l5].\n\u2022 $a_k = 2^{k-1} + (-1)^{k+1}$ and $a_{k-1} = 2^{k-2} + (-1)^{k}$ [l6].\nTherefore, we conclude:\n\u2022 $a_{k+1}=(2^{k-1}+(-1)^{k+1})+2(2^{k-2}+(-1)^k)$ [l7].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem a_formula \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n-1) + (-1)^(n+1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem a_formula \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n-1) + (-1 : \u2124)^(n+1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2^(n-1) + (-1 : \u2124)^(n+1) := by\n    intro n hn\n    have h : \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n-1) + (-1 : \u2124)^(n+1) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h1] at hn \u22a2\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h2] at hn \u22a2\n      | 3 =>\n        -- Base case: n = 3\n        have h3 := h_rec 3 (by norm_num)\n        have h4 := ih 2 (by norm_num)\n        have h5 := ih 1 (by norm_num)\n        norm_num [h1, h2] at h3 h4 h5 \u22a2\n        <;> simp_all [pow_succ]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> linarith\n      | k + 4 =>\n        -- Inductive step for n \u2265 4\n        have h3 := h_rec (k + 4) (by omega)\n        have h4 := ih (k + 3) (by omega)\n        have h5 := ih (k + 2) (by omega)\n        have h6 : (k + 4 : \u2115) \u2265 4 := by omega\n        have h7 : (k + 3 : \u2115) \u2265 3 := by omega\n        have h8 : (k + 2 : \u2115) \u2265 2 := by omega\n        have h9 : (k + 1 : \u2115) \u2265 1 := by omega\n        simp [h3, h4, h5, pow_add, pow_one, pow_two, pow_succ, mul_assoc] at *\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;>\n          (try omega) <;>\n          (try\n            {\n              cases' Nat.even_or_odd k with h h <;>\n                simp_all [pow_add, pow_mul, Nat.even_iff, Nat.odd_iff, pow_one, pow_two, mul_assoc]\n              <;>\n                ring_nf at *\n              <;>\n                norm_num at *\n              <;>\n                linarith\n            }) <;>\n          (try\n            {\n              simp_all [pow_add, pow_mul, Nat.even_iff, Nat.odd_iff, pow_one, pow_two, mul_assoc]\n              <;>\n                ring_nf at *\n              <;>\n                norm_num at *\n              <;>\n                linarith\n            })\n    exact h n hn\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content from the natural language. The recurrence relation a_{k+1} = a_k + 2a_{k-1} is equivalent to the Lean version with different indexing. The formula a_k = 2^{k-1} + (-1)^{k+1} is exactly what the Lean code aims to prove. The additional initial conditions in Lean (a 1 = 2, a 2 = 1) are mathematically necessary and consistent additions not contradicting the natural language. The structural difference between presenting the formula as an assumption versus a theorem to prove does not affect the mathematical meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "We simplify the expression by combining terms. $a_{k+1}=(2^{k-1}+2 \\cdot 2^{k-2})+((-1)^{k+1}+2(-1)^k)$.", "statement": "We assume:\n\u2022 $a_{k+1}=(2^{k-1}+(-1)^{k+1})+2(2^{k-2}+(-1)^k)$ [l7].\nTherefore, we conclude:\n\u2022 $a_{k+1}=(2^{k-1}+2 \\cdot 2^{k-2})+((-1)^{k+1}+2(-1)^k)$ [l8].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h_formula : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a (k+1) = 2^k + (-1)^(k+2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l8 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h_formula : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1 : \u2124)^(j+1)) :\n  a (k+1) = 2^k + (-1 : \u2124)^(k+2) := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    omega\n  \n  have h_a_k_plus_1 : a (k + 1) = a k + 2 * a (k - 1) := by\n    have h\u2082 : a (k + 1) = a ((k + 1) - 1) + 2 * a ((k + 1) - 2) := by\n      apply h_rec\n      <;> omega\n    have h\u2083 : (k + 1 : \u2115) - 1 = k := by\n      omega\n    have h\u2084 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2085 : k \u2265 2 := hk\n      have h\u2086 : (k + 1 : \u2115) - 2 = k - 1 := by\n        cases k with\n        | zero => omega\n        | succ k' =>\n          cases k' with\n          | zero => omega\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc]\n            <;> ring_nf at *\n            <;> omega\n      exact h\u2086\n    rw [h\u2082, h\u2083, h\u2084]\n    <;> ring_nf\n    <;> simp_all\n    <;> omega\n  \n  have h_a_k : a k = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) := by\n    have h\u2083 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2084 : a k = (2 : \u2124) ^ (k - 1) + (-1 : \u2124) ^ (k + 1) := by\n      have h\u2085 := h_formula k h\u2083\n      norm_cast at h\u2085 \u22a2\n      <;> simp_all [pow_add, pow_one, mul_assoc]\n      <;> ring_nf at *\n      <;> simp_all\n    exact h\u2084\n  \n  have h_a_k_sub_1 : a (k - 1) = (2 : \u2124)^(k - 2) + (-1 : \u2124)^k := by\n    have h\u2083 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2084 : k \u2265 2 := hk\n      have h\u2085 : 1 \u2264 (k - 1 : \u2115) := by\n        omega\n      have h\u2086 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h\u2085, h\u2086\u27e9\n    have h\u2084 : a (k - 1) = (2 : \u2124) ^ ((k - 1 : \u2115) - 1) + (-1 : \u2124) ^ ((k - 1 : \u2115) + 1) := by\n      have h\u2085 := h_formula (k - 1) h\u2083\n      norm_cast at h\u2085 \u22a2\n      <;> simp_all [pow_add, pow_one, mul_assoc]\n      <;> ring_nf at *\n      <;> simp_all\n    have h\u2085 : (k - 1 : \u2115) - 1 = k - 2 := by\n      have h\u2086 : k \u2265 2 := hk\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    have h\u2086 : ((k - 1 : \u2115) + 1 : \u2115) = k := by\n      have h\u2087 : k \u2265 2 := hk\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    rw [h\u2084]\n    <;> simp [h\u2085, h\u2086]\n    <;> norm_cast\n    <;> simp_all [pow_add, pow_one, mul_assoc]\n    <;> ring_nf at *\n    <;> simp_all\n  \n  have h_substituted : a (k + 1) = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) := by\n    rw [h_a_k_plus_1]\n    rw [h_a_k]\n    rw [h_a_k_sub_1]\n    <;> ring_nf\n    <;> norm_num\n    <;>\n    (try omega)\n    <;>\n    (try\n      {\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_assoc]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> omega\n      })\n  \n  have h_pow2 : (2 : \u2124)^(k - 1) + 2 * (2 : \u2124)^(k - 2) = (2 : \u2124)^k := by\n    have h\u2083 : k \u2265 2 := hk\n    have h\u2084 : (2 : \u2124) ^ (k - 1) + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ k := by\n      have h\u2085 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n      have h\u2086 : (2 : \u2124) ^ (k - 1) + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ (k - 2) * (2 + 2) := by\n        have h\u2087 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n        have h\u2088 : (k : \u2115) - 1 \u2265 1 := by omega\n        have h\u2089 : (k : \u2115) - 2 \u2265 0 := by omega\n        have h\u2081\u2080 : (2 : \u2124) ^ (k - 1 : \u2115) = (2 : \u2124) ^ (k - 2 : \u2115) * 2 := by\n          have h\u2081\u2081 : (k - 1 : \u2115) = (k - 2 : \u2115) + 1 := by\n            have h\u2081\u2082 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n            omega\n          rw [h\u2081\u2081]\n          ring_nf\n          <;> simp [pow_add, pow_one]\n          <;> ring_nf\n          <;> norm_cast\n          <;> simp [pow_add, pow_one]\n          <;> ring_nf\n        calc\n          (2 : \u2124) ^ (k - 1) + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ (k - 2) * 2 + 2 * (2 : \u2124) ^ (k - 2) := by rw [h\u2081\u2080]\n          _ = (2 : \u2124) ^ (k - 2) * 2 + (2 : \u2124) ^ (k - 2) * 2 := by ring\n          _ = (2 : \u2124) ^ (k - 2) * (2 + 2) := by ring\n      have h\u2081\u2081 : (2 : \u2124) ^ (k - 2 : \u2115) * (2 + 2) = (2 : \u2124) ^ (k - 2 : \u2115) * 4 := by ring\n      have h\u2081\u2082 : (2 : \u2124) ^ (k - 2 : \u2115) * 4 = (2 : \u2124) ^ (k : \u2115) := by\n        have h\u2081\u2083 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n        have h\u2081\u2084 : (2 : \u2124) ^ (k : \u2115) = (2 : \u2124) ^ (k - 2 : \u2115) * 2 ^ 2 := by\n          have h\u2081\u2085 : (k : \u2115) = (k - 2 : \u2115) + 2 := by\n            have h\u2081\u2086 : (k : \u2115) \u2265 2 := by exact_mod_cast hk\n            omega\n          rw [h\u2081\u2085]\n          ring_nf\n          <;> simp [pow_add]\n          <;> ring_nf\n          <;> norm_cast\n          <;> simp [pow_add]\n          <;> ring_nf\n        calc\n          (2 : \u2124) ^ (k - 2 : \u2115) * 4 = (2 : \u2124) ^ (k - 2 : \u2115) * (2 ^ 2 : \u2124) := by norm_num\n          _ = (2 : \u2124) ^ (k : \u2115) := by\n            rw [h\u2081\u2084]\n            <;> ring_nf\n            <;> norm_cast\n            <;> simp [pow_add]\n            <;> ring_nf\n      calc\n        (2 : \u2124) ^ (k - 1) + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ (k - 2) * (2 + 2) := by rw [h\u2086]\n        _ = (2 : \u2124) ^ (k - 2) * 4 := by rw [h\u2081\u2081]\n        _ = (2 : \u2124) ^ (k : \u2115) := by rw [h\u2081\u2082]\n        _ = (2 : \u2124) ^ k := by norm_cast\n    exact h\u2084\n  \n  have h_pow_neg1 : (-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k = (-1 : \u2124)^(k + 2) := by\n    have h\u2083 : (-1 : \u2124) ^ (k + 2) = (-1 : \u2124) ^ (k + 1) * (-1 : \u2124) := by\n      rw [show (k + 2 : \u2115) = (k + 1 : \u2115) + 1 by ring]\n      simp [pow_add, pow_one]\n      <;> ring_nf\n    have h\u2084 : (-1 : \u2124) ^ k = (-1 : \u2124) ^ (k + 1) * (-1 : \u2124) := by\n      have h\u2085 : (k : \u2115) + 1 = (k : \u2115) + 1 := rfl\n      have h\u2086 : (-1 : \u2124) ^ (k + 1) = (-1 : \u2124) ^ k * (-1 : \u2124) := by\n        rw [show (k + 1 : \u2115) = (k : \u2115) + 1 by ring]\n        simp [pow_add, pow_one]\n        <;> ring_nf\n      calc\n        (-1 : \u2124) ^ k = (-1 : \u2124) ^ k := by rfl\n        _ = (-1 : \u2124) ^ (k + 1) * (-1 : \u2124) := by\n          have h\u2087 : (-1 : \u2124) ^ (k + 1) = (-1 : \u2124) ^ k * (-1 : \u2124) := by\n            rw [show (k + 1 : \u2115) = (k : \u2115) + 1 by ring]\n            simp [pow_add, pow_one]\n            <;> ring_nf\n          calc\n            (-1 : \u2124) ^ k = (-1 : \u2124) ^ k := by rfl\n            _ = (-1 : \u2124) ^ (k + 1) * (-1 : \u2124) := by\n              rw [h\u2087]\n              <;> ring_nf\n              <;> simp [mul_assoc]\n              <;> ring_nf\n        _ = (-1 : \u2124) ^ (k + 1) * (-1 : \u2124) := by rfl\n    calc\n      (-1 : \u2124) ^ (k + 1) + 2 * (-1 : \u2124) ^ k = (-1 : \u2124) ^ (k + 1) + 2 * ((-1 : \u2124) ^ (k + 1) * (-1 : \u2124)) := by rw [h\u2084]\n      _ = (-1 : \u2124) ^ (k + 1) + (2 * (-1 : \u2124)) * ((-1 : \u2124) ^ (k + 1)) := by ring\n      _ = (-1 : \u2124) ^ (k + 1) * (1 + 2 * (-1 : \u2124)) := by ring\n      _ = (-1 : \u2124) ^ (k + 1) * (-1 : \u2124) := by ring\n      _ = (-1 : \u2124) ^ (k + 2) := by\n        rw [h\u2083]\n        <;> ring_nf\n  \n  have h_main : a (k + 1) = (2 : \u2124)^k + (-1 : \u2124)^(k + 2) := by\n    have h\u2085 : a (k + 1) = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) := h_substituted\n    have h\u2086 : (2 : \u2124)^(k - 1) + 2 * (2 : \u2124)^(k - 2) = (2 : \u2124)^k := h_pow2\n    have h\u2087 : (-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k = (-1 : \u2124)^(k + 2) := h_pow_neg1\n    calc\n      a (k + 1) = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) := by rw [h\u2085]\n      _ = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + (2 * (2 : \u2124)^(k - 2) + 2 * (-1 : \u2124)^k) := by ring\n      _ = ((2 : \u2124)^(k - 1) + 2 * (2 : \u2124)^(k - 2)) + ((-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k) := by ring\n      _ = (2 : \u2124)^k + ((-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k) := by rw [h\u2086]\n      _ = (2 : \u2124)^k + (-1 : \u2124)^(k + 2) := by rw [h\u2087]\n      _ = (2 : \u2124)^k + (-1 : \u2124)^(k + 2) := by rfl\n  \n  rw [h_main]\n  <;> simp_all\n  <;> norm_num\n  <;>\n  (try omega)\n  <;>\n  (try\n    {\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_assoc]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> omega\n    })", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The premise from natural language is correctly captured through the recurrence relation h_rec and the formula hypothesis h_formula, which together allow deriving the assumed expression for a_{k+1}.", "The conclusion in Lean (2^k + (-1)^{k+2}) is mathematically equivalent to the natural language conclusion (2^{k-1} + 2\u00b72^{k-2} + (-1)^{k+1} + 2(-1)^k), representing the same final simplified form after algebraic manipulation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l9": {"id": "l9", "natural_language": "The first term simplifies to $2^{k-1}+2^{k-1}=2 \\cdot 2^{k-1}=2^k$.", "statement": "We assume:\n\u2022 k is an integer [def_1].\nTherefore, we conclude:\n\u2022 $2^{k-1}+2 \\cdot 2^{k-2} = 2^k$ [l9].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 \n  (k : \u2124) :\n  (2 : \u211d)^(k-1) + 2 * (2 : \u211d)^(k-2) = (2 : \u211d)^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l9 \n  (k : \u2124) :\n  (2 : \u211d)^(k-1) + 2 * (2 : \u211d)^(k-2) = (2 : \u211d)^k := by\n  have h1 : (2 : \u211d)^(k - 1 : \u2124) = 2 * (2 : \u211d)^(k - 2 : \u2124) := by\n    have h1\u2081 : (2 : \u211d) ^ (k - 1 : \u2124) = (2 : \u211d) ^ ((k - 2 : \u2124) + 1 : \u2124) := by\n      norm_num [zpow_add\u2080, zpow_one]\n      <;> ring_nf at *\n      <;> simp_all [zpow_add\u2080, zpow_one]\n      <;> norm_cast\n      <;> ring_nf at *\n      <;> simp_all\n      <;> linarith\n    rw [h1\u2081]\n    have h1\u2082 : (2 : \u211d) ^ ((k - 2 : \u2124) + 1 : \u2124) = (2 : \u211d) ^ (k - 2 : \u2124) * (2 : \u211d) ^ (1 : \u2124) := by\n      rw [zpow_add\u2080 (by norm_num : (2 : \u211d) \u2260 0)]\n      <;> ring_nf at *\n      <;> simp_all [zpow_add\u2080, zpow_one]\n      <;> norm_cast\n      <;> ring_nf at *\n      <;> simp_all\n      <;> linarith\n    rw [h1\u2082]\n    have h1\u2083 : (2 : \u211d) ^ (1 : \u2124) = 2 := by\n      norm_num [zpow_one]\n    rw [h1\u2083]\n    <;> ring_nf at *\n    <;> simp_all [zpow_add\u2080, zpow_one]\n    <;> norm_cast\n    <;> ring_nf at *\n    <;> simp_all\n    <;> linarith\n  \n  have h2 : (2 : \u211d)^(k - 1 : \u2124) + 2 * (2 : \u211d)^(k - 2 : \u2124) = 2 * (2 : \u211d)^(k - 1 : \u2124) := by\n    have h\u2082 : (2 : \u211d)^(k - 1 : \u2124) + 2 * (2 : \u211d)^(k - 2 : \u2124) = (2 : \u211d)^(k - 1 : \u2124) + (2 : \u211d)^(k - 1 : \u2124) := by\n      have h\u2082\u2081 : (2 : \u211d)^(k - 1 : \u2124) = 2 * (2 : \u211d)^(k - 2 : \u2124) := h1\n      have h\u2082\u2082 : 2 * (2 : \u211d)^(k - 2 : \u2124) = (2 : \u211d)^(k - 1 : \u2124) := by linarith\n      linarith\n    rw [h\u2082]\n    <;> ring\n    <;> simp [h1]\n    <;> linarith\n  \n  have h3 : 2 * (2 : \u211d)^(k - 1 : \u2124) = (2 : \u211d)^(k : \u2124) := by\n    have h3\u2081 : (2 : \u211d) * (2 : \u211d) ^ (k - 1 : \u2124) = (2 : \u211d) ^ (1 : \u2124) * (2 : \u211d) ^ (k - 1 : \u2124) := by\n      norm_num [zpow_one]\n    rw [h3\u2081]\n    have h3\u2082 : (2 : \u211d) ^ (1 : \u2124) * (2 : \u211d) ^ (k - 1 : \u2124) = (2 : \u211d) ^ ((1 : \u2124) + (k - 1 : \u2124)) := by\n      rw [\u2190 zpow_add\u2080 (by norm_num : (2 : \u211d) \u2260 0)]\n      <;> ring_nf at *\n      <;> simp_all [zpow_add\u2080, zpow_one]\n      <;> norm_cast\n      <;> ring_nf at *\n      <;> simp_all\n      <;> linarith\n    rw [h3\u2082]\n    have h3\u2083 : (1 : \u2124) + (k - 1 : \u2124) = k := by\n      ring_nf at *\n      <;> simp_all\n      <;> linarith\n    rw [h3\u2083]\n    <;> ring_nf at *\n    <;> simp_all [zpow_add\u2080, zpow_one]\n    <;> norm_cast\n    <;> ring_nf at *\n    <;> simp_all\n    <;> linarith\n  \n  have h4 : (2 : \u211d)^(k - 1) + 2 * (2 : \u211d)^(k - 2) = (2 : \u211d)^k := by\n    have h4\u2081 : (2 : \u211d)^(k - 1 : \u2124) + 2 * (2 : \u211d)^(k - 2 : \u2124) = 2 * (2 : \u211d)^(k - 1 : \u2124) := h2\n    have h4\u2082 : 2 * (2 : \u211d)^(k - 1 : \u2124) = (2 : \u211d)^(k : \u2124) := h3\n    have h4\u2083 : (2 : \u211d)^(k - 1 : \u2124) + 2 * (2 : \u211d)^(k - 2 : \u2124) = (2 : \u211d)^(k : \u2124) := by\n      linarith\n    -- Convert the result back to the original form\n    norm_cast at h4\u2083 \u22a2\n    <;>\n    (try simp_all [zpow_ofNat]) <;>\n    (try ring_nf at * <;> simp_all [zpow_ofNat]) <;>\n    (try norm_num at * <;> simp_all [zpow_ofNat]) <;>\n    (try linarith)\n    <;>\n    (try\n      {\n        simp_all [zpow_ofNat]\n        <;>\n        ring_nf at *\n        <;>\n        norm_num at *\n        <;>\n        linarith\n      })\n  \n  exact h4", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all components of the natural language statement. The variable k is properly declared as an integer, and the mathematical equation is accurately represented. The additional type specification (2 : \u211d) is a reasonable mathematical detail that doesn't contradict the natural language but rather clarifies the mathematical context for proper formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l10": {"id": "l10", "natural_language": "The second term simplifies to $-(-1)^k+2(-1)^k=(-1)^k$.", "statement": "We assume:\n\u2022 k is an integer [def_1].\nTherefore, we conclude:\n\u2022 $(-1)^{k+1}+2(-1)^k = (-1)^k$ [l10].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7", "l8", "l9"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h_formula : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a (k+1) = 2^k + (-1)^(k+2) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l10 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h_formula : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = 2^(j-1) + (-1)^(j+1)) :\n  a (k+1) = 2^k + (-1)^(k+2) := by\n  have h_k_plus_1_ge_3 : (k + 1 : \u2115) \u2265 3 := by\n    have h : k \u2265 2 := hk\n    have h\u2081 : (k : \u2115) + 1 \u2265 3 := by\n      omega\n    exact h\u2081\n  \n  have h_a_k_plus_1 : a (k+1) = a k + 2 * a (k-1) := by\n    have h\u2083 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := by\n      have h\u2084 : (k + 1 : \u2115) \u2265 3 := h_k_plus_1_ge_3\n      have h\u2085 : a (k + 1) = a (k + 1 - 1) + 2 * a (k + 1 - 2) := by\n        apply h_rec\n        <;> omega\n      exact h\u2085\n    have h\u2086 : a (k + 1 - 1) = a k := by\n      have h\u2087 : (k + 1 : \u2115) - 1 = k := by\n        omega\n      rw [h\u2087]\n    have h\u2088 : a (k + 1 - 2) = a (k - 1) := by\n      have h\u2089 : (k + 1 : \u2115) - 2 = k - 1 := by\n        have h\u2081\u2080 : k \u2265 2 := hk\n        have h\u2081\u2081 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2081\u2080\n        omega\n      rw [h\u2089]\n    rw [h\u2083, h\u2086, h\u2088]\n    <;> ring_nf at *\n    <;> simp_all\n    <;> try omega\n  \n  have h_a_k : a k = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) := by\n    have h\u2083 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor\n      \u00b7 -- Prove 1 \u2264 k\n        omega\n      \u00b7 -- Prove k \u2264 k\n        omega\n    have h\u2084 : a k = 2 ^ (k - 1) + (-1 : \u2124) ^ (k + 1) := by\n      have h\u2085 := h_formula k h\u2083\n      norm_cast at h\u2085 \u22a2\n      <;>\n      (try omega) <;>\n      (try simp_all [pow_add, pow_one, mul_comm]) <;>\n      (try ring_nf at *) <;>\n      (try norm_num at *) <;>\n      (try linarith) <;>\n      (try omega)\n      <;>\n      (try\n        {\n          cases k with\n          | zero => contradiction\n          | succ k' =>\n            cases k' with\n            | zero => contradiction\n            | succ k'' =>\n              simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_comm]\n              <;> ring_nf at * <;> norm_num at * <;> linarith\n        })\n      <;>\n      (try\n        {\n          simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_comm]\n          <;> ring_nf at * <;> norm_num at * <;> linarith\n        })\n    exact h\u2084\n  \n  have h_a_k_minus_1 : a (k - 1) = (2 : \u2124)^(k - 2) + (-1 : \u2124)^k := by\n    have h\u2083 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2084 : k \u2265 2 := hk\n      have h\u2085 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2086 : k \u2265 2 := hk\n        omega\n      have h\u2086 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h\u2085, h\u2086\u27e9\n    have h\u2084 : a (k - 1) = (2 : \u2124) ^ ((k - 1 : \u2115) - 1) + (-1 : \u2124) ^ ((k - 1 : \u2115) + 1) := by\n      have h\u2085 := h_formula (k - 1) h\u2083\n      norm_cast at h\u2085 \u22a2\n      <;>\n      (try omega) <;>\n      (try simp_all [pow_add, pow_one, mul_comm]) <;>\n      (try ring_nf at *) <;>\n      (try norm_num at *) <;>\n      (try linarith) <;>\n      (try omega)\n      <;>\n      (try\n        {\n          cases k with\n          | zero => contradiction\n          | succ k' =>\n            cases k' with\n            | zero => contradiction\n            | succ k'' =>\n              simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_comm]\n              <;> ring_nf at * <;> norm_num at * <;> linarith\n        })\n      <;>\n      (try\n        {\n          simp_all [Nat.succ_eq_add_one, pow_add, pow_one, mul_comm]\n          <;> ring_nf at * <;> norm_num at * <;> linarith\n        })\n    have h\u2085 : (2 : \u2124) ^ ((k - 1 : \u2115) - 1) + (-1 : \u2124) ^ ((k - 1 : \u2115) + 1) = (2 : \u2124) ^ (k - 2) + (-1 : \u2124) ^ k := by\n      have h\u2086 : k \u2265 2 := hk\n      have h\u2087 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2086\n      have h\u2088 : (k - 1 : \u2115) \u2265 1 := by omega\n      -- Simplify the exponents\n      have h\u2089 : ((k - 1 : \u2115) - 1 : \u2115) = k - 2 := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc]\n            <;> ring_nf at * <;> omega\n      have h\u2081\u2080 : ((k - 1 : \u2115) + 1 : \u2115) = k := by\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp [Nat.succ_eq_add_one, Nat.add_assoc]\n            <;> ring_nf at * <;> omega\n      rw [h\u2089, h\u2081\u2080]\n      <;>\n      (try simp_all) <;>\n      (try ring_nf at *) <;>\n      (try norm_num at *) <;>\n      (try linarith) <;>\n      (try omega)\n    rw [h\u2084, h\u2085]\n    <;>\n    (try simp_all) <;>\n    (try ring_nf at *) <;>\n    (try norm_num at *) <;>\n    (try linarith) <;>\n    (try omega)\n  \n  have h_subst : a (k+1) = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) := by\n    rw [h_a_k_plus_1]\n    rw [h_a_k]\n    rw [h_a_k_minus_1]\n    <;> ring_nf\n    <;> norm_cast\n    <;> simp [pow_add, pow_one, mul_assoc]\n    <;> ring_nf\n    <;> norm_num\n    <;> linarith\n  \n  have h_pow2 : (2 : \u2124)^(k - 1) + 2 * (2 : \u2124)^(k - 2) = (2 : \u2124)^k := by\n    have h\u2083 : k \u2265 2 := hk\n    have h\u2084 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2083\n    have h\u2085 : (2 : \u2124) ^ (k - 1) + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ k := by\n      have h\u2086 : k \u2265 2 := hk\n      have h\u2087 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2086\n      have h\u2088 : (2 : \u2124) ^ (k - 1) + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ (k - 2) * 2 + 2 * (2 : \u2124) ^ (k - 2) := by\n        have h\u2089 : (k - 1 : \u2115) = (k - 2 : \u2115) + 1 := by\n          omega\n        have h\u2081\u2080 : (2 : \u2124) ^ (k - 1) = (2 : \u2124) ^ ((k - 2 : \u2115) + 1) := by\n          rw [h\u2089]\n          <;> simp [pow_add]\n        rw [h\u2081\u2080]\n        have h\u2081\u2081 : (2 : \u2124) ^ ((k - 2 : \u2115) + 1) = (2 : \u2124) ^ (k - 2) * 2 := by\n          simp [pow_add, pow_one]\n          <;> ring_nf\n        rw [h\u2081\u2081]\n        <;> ring_nf\n      rw [h\u2088]\n      have h\u2089 : (2 : \u2124) ^ (k - 2) * 2 + 2 * (2 : \u2124) ^ (k - 2) = (2 : \u2124) ^ (k - 2) * 4 := by\n        ring_nf\n      rw [h\u2089]\n      have h\u2081\u2080 : (2 : \u2124) ^ (k - 2) * 4 = (2 : \u2124) ^ (k - 2) * 2 ^ 2 := by\n        norm_num\n        <;> ring_nf\n      rw [h\u2081\u2080]\n      have h\u2081\u2081 : (2 : \u2124) ^ (k - 2) * 2 ^ 2 = (2 : \u2124) ^ ((k - 2) + 2) := by\n        rw [\u2190 pow_add]\n        <;> ring_nf\n      rw [h\u2081\u2081]\n      have h\u2081\u2082 : (k - 2 : \u2115) + 2 = k := by\n        have h\u2081\u2083 : k \u2265 2 := hk\n        have h\u2081\u2084 : (k : \u2115) \u2265 2 := by exact_mod_cast h\u2081\u2083\n        omega\n      rw [h\u2081\u2082]\n      <;> ring_nf\n    exact h\u2085\n  \n  have h_pow_neg1 : (-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k = (-1 : \u2124)^k := by\n    have h\u2081 : (-1 : \u2124) ^ (k + 1) = (-1 : \u2124) ^ k * (-1 : \u2124) := by\n      calc\n        (-1 : \u2124) ^ (k + 1) = (-1 : \u2124) ^ (k + 1) := by rfl\n        _ = (-1 : \u2124) ^ k * (-1 : \u2124) := by\n          rw [show (k + 1 : \u2115) = k + 1 by rfl]\n          simp [pow_add, pow_one, mul_comm]\n          <;> ring_nf\n          <;> norm_num\n    rw [h\u2081]\n    ring_nf\n    <;>\n    (try\n      {\n        cases' Nat.even_or_odd k with h h <;>\n        simp [h, pow_add, pow_mul, pow_one, mul_assoc, mul_comm, mul_left_comm] <;>\n        ring_nf at * <;>\n        norm_num at * <;>\n        linarith\n      })\n    <;>\n    (try\n      {\n        cases k with\n        | zero => contradiction\n        | succ k' =>\n          cases k' with\n          | zero => contradiction\n          | succ k'' =>\n            simp_all [Nat.even_iff, Nat.odd_iff, pow_add, pow_mul, pow_one, mul_assoc, mul_comm, mul_left_comm]\n            <;> ring_nf at *\n            <;> norm_num at *\n            <;> linarith\n      })\n  \n  have h_main : a (k+1) = (2 : \u2124)^k + (-1 : \u2124)^k := by\n    have h\u2081 : a (k+1) = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) := h_subst\n    rw [h\u2081]\n    have h\u2082 : (2 : \u2124)^(k - 1) + 2 * (2 : \u2124)^(k - 2) = (2 : \u2124)^k := h_pow2\n    have h\u2083 : (-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k = (-1 : \u2124)^k := h_pow_neg1\n    have h\u2084 : (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) = (2 : \u2124)^k + (-1 : \u2124)^k := by\n      calc\n        (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + 2 * ((2 : \u2124)^(k - 2) + (-1 : \u2124)^k) = (2 : \u2124)^(k - 1) + (-1 : \u2124)^(k + 1) + (2 * (2 : \u2124)^(k - 2) + 2 * (-1 : \u2124)^k) := by\n          ring_nf\n        _ = ((2 : \u2124)^(k - 1) + 2 * (2 : \u2124)^(k - 2)) + ((-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k) := by ring_nf\n        _ = (2 : \u2124)^k + ((-1 : \u2124)^(k + 1) + 2 * (-1 : \u2124)^k) := by rw [h\u2082]\n        _ = (2 : \u2124)^k + (-1 : \u2124)^k := by rw [h\u2083]\n    linarith\n  \n  have h_neg1_pow : (-1 : \u2124)^k = (-1 : \u2124)^(k + 2) := by\n    have h\u2081 : (-1 : \u2124) ^ (k + 2) = (-1 : \u2124) ^ k := by\n      calc\n        (-1 : \u2124) ^ (k + 2) = (-1 : \u2124) ^ (k + 2) := rfl\n        _ = (-1 : \u2124) ^ k * (-1 : \u2124) ^ 2 := by\n          rw [show (k + 2 : \u2115) = k + 2 by rfl]\n          rw [pow_add]\n          <;> ring_nf\n        _ = (-1 : \u2124) ^ k * 1 := by\n          norm_num\n        _ = (-1 : \u2124) ^ k := by ring\n    linarith\n  \n  have h_final : a (k+1) = (2 : \u2124)^k + (-1 : \u2124)^(k + 2) := by\n    have h\u2081 : a (k+1) = (2 : \u2124)^k + (-1 : \u2124)^k := h_main\n    have h\u2082 : (-1 : \u2124)^k = (-1 : \u2124)^(k + 2) := h_neg1_pow\n    rw [h\u2081]\n    <;> rw [h\u2082]\n    <;> ring_nf\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The premise differs significantly: natural language assumes k is an integer, while Lean declares k as a natural number with k \u2265 2. More critically, the Lean formalization introduces a sequence 'a' with recurrence relations that are completely absent from the natural language.", "The conclusion is fundamentally different: natural language proves a simple algebraic identity about powers of -1, while Lean proves a statement about a sequence element a(k+1) involving both powers of 2 and powers of -1. The mathematical objects and relationships being proven are entirely different."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The premise differs significantly: natural language assumes k is an integer, while Lean declares k as a natural number with k \u2265 2. More critically, the Lean formalization introduces a sequence 'a' with recurrence relations that are completely absent from the natural language.\", 'The conclusion is fundamentally different: natural language proves a simple algebraic identity about powers of -1, while Lean proves a statement about a sequence element a(k+1) involving both powers of 2 and powers of -1. The mathematical objects and relationships being proven are entirely different.']"}, "solved_negation": null, "type": "lemma"}, "l11": {"id": "l11", "natural_language": "And we know that $(-1)^{k+2}=(-1)^k$.", "statement": "We assume:\n\u2022 k is an integer [def_1].\nTherefore, we conclude:\n\u2022 $(-1)^{k+2}=(-1)^k$ [l11].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7", "l8", "l9", "l10"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l11 (k : \u2124) : (-1 : \u211d)^(k+2) = (-1 : \u211d)^k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l11 (k : \u2124) : (-1 : \u211d)^(k+2) = (-1 : \u211d)^k := by\n  have h1 : (-1 : \u211d) \u2260 0 := by\n    norm_num\n    <;> simp [ne_eq]\n    <;> norm_num\n  \n  have h2 : (-1 : \u211d)^(k+2) = (-1 : \u211d)^k * (-1 : \u211d)^(2 : \u2124) := by\n    have h2\u2081 : (-1 : \u211d) ^ (k + 2 : \u2124) = (-1 : \u211d) ^ (k : \u2124) * (-1 : \u211d) ^ (2 : \u2124) := by\n      rw [zpow_add\u2080 h1]\n      <;> simp [h1]\n      <;> norm_cast\n      <;> ring_nf\n      <;> simp_all\n      <;> norm_num\n    simpa using h2\u2081\n  \n  have h3 : (-1 : \u211d)^(2 : \u2124) = (1 : \u211d) := by\n    norm_num [zpow_ofNat]\n    <;>\n    simp_all [zpow_neg, zpow_ofNat]\n    <;>\n    norm_num\n    <;>\n    linarith\n  \n  have h4 : (-1 : \u211d)^(k+2) = (-1 : \u211d)^k := by\n    calc\n      (-1 : \u211d) ^ (k + 2) = (-1 : \u211d) ^ k * (-1 : \u211d) ^ (2 : \u2124) := by rw [h2]\n      _ = (-1 : \u211d) ^ k * 1 := by rw [h3]\n      _ = (-1 : \u211d) ^ k := by ring\n  \n  rw [h4]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the premise that k is an integer and the conclusion that (-1)^(k+2) = (-1)^k. The explicit type annotation of (-1) as a real number is an appropriate technical detail that doesn't alter the mathematical meaning but provides necessary precision for the formal system."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l12": {"id": "l12", "natural_language": "Thus, $a_{k+1}=2^k+(-1)^k=2^k+(-1)^{k+2}$.", "statement": "We assume:\n\u2022 $a_{k+1}=(2^{k-1}+2 \\cdot 2^{k-2})+((-1)^{k+1}+2(-1)^k)$ [l8].\n\u2022 $2^{k-1}+2 \\cdot 2^{k-2} = 2^k$ [l9].\n\u2022 $(-1)^{k+1}+2(-1)^k = (-1)^k$ [l10].\n\u2022 $(-1)^{k+2}=(-1)^k$ [l11].\nTherefore, we conclude:\n\u2022 $a_{k+1} = 2^k + (-1)^{k+2}$ [l12].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7", "l8", "l9", "l10", "l11"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem a_formula \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n-1) + (-1)^(n+1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem a_formula \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = 2^(n-1) + (-1 : \u2124)^(n+1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2^(n-1) + (-1 : \u2124)^(n+1) := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = 2^(n-1) + (-1 : \u2124)^(n+1) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false.\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        norm_num [h1] at hn \u22a2\n      | 2 =>\n        -- Base case: n = 2\n        norm_num [h2] at hn \u22a2\n      | k + 3 =>\n        -- Inductive step: n = k + 3 \u2265 3\n        have h3 : a (k + 3) = a (k + 2) + 2 * a (k + 1) := by\n          have h4 : (k + 3 : \u2115) \u2265 3 := by\n            omega\n          have h5 : a (k + 3) = a (k + 3 - 1) + 2 * a (k + 3 - 2) := h_rec (k + 3) h4\n          have h6 : (k + 3 : \u2115) - 1 = k + 2 := by\n            omega\n          have h7 : (k + 3 : \u2115) - 2 = k + 1 := by\n            omega\n          rw [h5, h6, h7]\n          <;> ring_nf at *\n          <;> simp_all\n          <;> linarith\n        have h8 : a (k + 2) = (2 : \u2124) ^ ((k + 2) - 1) + (-1 : \u2124) ^ ((k + 2) + 1) := by\n          have h9 : (k + 2 : \u2115) \u2265 1 := by omega\n          have h10 : a (k + 2) = (2 : \u2124) ^ ((k + 2) - 1) + (-1 : \u2124) ^ ((k + 2) + 1) := by\n            apply ih (k + 2)\n            <;> omega\n          exact h10\n        have h11 : a (k + 1) = (2 : \u2124) ^ ((k + 1) - 1) + (-1 : \u2124) ^ ((k + 1) + 1) := by\n          have h12 : (k + 1 : \u2115) \u2265 1 := by omega\n          have h13 : a (k + 1) = (2 : \u2124) ^ ((k + 1) - 1) + (-1 : \u2124) ^ ((k + 1) + 1) := by\n            apply ih (k + 1)\n            <;> omega\n          exact h13\n        rw [h3, h8, h11]\n        have h14 : (2 : \u2124) ^ ((k + 2) - 1) + (-1 : \u2124) ^ ((k + 2) + 1) + 2 * ((2 : \u2124) ^ ((k + 1) - 1) + (-1 : \u2124) ^ ((k + 1) + 1)) = (2 : \u2124) ^ (k + 3 - 1) + (-1 : \u2124) ^ (k + 3 + 1) := by\n          have h15 : (k + 2 : \u2115) - 1 = k + 1 := by\n            omega\n          have h16 : (k + 1 : \u2115) - 1 = k := by\n            omega\n          have h17 : (k + 3 : \u2115) - 1 = k + 2 := by\n            omega\n          have h18 : (k + 2 : \u2115) + 1 = k + 3 := by\n            omega\n          have h19 : (k + 1 : \u2115) + 1 = k + 2 := by\n            omega\n          simp [h15, h16, h17, h18, h19, pow_add, pow_one, pow_two, mul_add, mul_comm, mul_left_comm, mul_assoc] at *\n          <;>\n          (try omega) <;>\n          (try ring_nf at *) <;>\n          (try norm_num at *) <;>\n          (try\n            {\n              cases' Nat.even_or_odd k with h h <;>\n              simp_all [pow_add, pow_mul, Nat.even_iff, Nat.odd_iff, pow_one, pow_two, mul_assoc] <;>\n              ring_nf at * <;>\n              norm_num at * <;>\n              (try omega) <;>\n              (try linarith)\n            })\n          <;>\n          (try\n            {\n              simp_all [pow_add, pow_mul, Nat.even_iff, Nat.odd_iff, pow_one, pow_two, mul_assoc]\n              <;>\n              ring_nf at *\n              <;>\n              norm_num at *\n              <;>\n              (try omega)\n              <;>\n              (try linarith)\n            })\n          <;>\n          (try\n            {\n              omega\n            })\n          <;>\n          (try\n            {\n              ring_nf at *\n              <;>\n              norm_num at *\n              <;>\n              (try omega)\n              <;>\n              (try linarith)\n            })\n        rw [h14]\n        <;> simp_all [Nat.add_assoc]\n        <;> ring_nf at *\n        <;> norm_num at *\n        <;> omega\n    exact h n hn\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the main mathematical claim (the closed-form formula for the sequence) and properly establishes the recurrence relation with base cases. However, it omits the intermediate algebraic manipulations (l8-l11) that constitute the proof strategy described in the natural language. The natural language presents a step-by-step derivation showing how a_{k+1} simplifies to the desired form, while the Lean code only states the final theorem without including these proof steps. The mathematical content is equivalent, but the proof structure is not represented."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures the main mathematical claim (the closed-form formula for the sequence) and properly establishes the recurrence relation with base cases. However, it omits the intermediate algebraic manipulations (l8-l11) that constitute the proof strategy described in the natural language. The natural language presents a step-by-step derivation showing how a_{k+1} simplifies to the desired form, while the Lean code only states the final theorem without including these proof steps. The mathematical content is equivalent, but the proof structure is not represented.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of strong mathematical induction, the formula is true for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 $(a_n)_{n \\geq 1}$ is a sequence of integers defined by $a_1=2$, $a_2=1$, and $a_n=a_{n-1}+2a_{n-2}$ for all integers $n \\geq 3$ [tc_1].\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=1$ [l2].\n\u2022 The formula $a_n = 2^{n-1} + (-1)^{n+1}$ holds for $n=2$ [l4].\n\u2022 For an integer $k \\geq 2$, assuming the formula holds for all integers $j$ with $1 \\leq j \\leq k$ implies that the formula holds for $k+1$, i.e. $a_{k+1} = 2^k + (-1)^{k+2}$ [l12].\nTherefore, we conclude:\n\u2022 For all integers $n \\geq 1$, $a_n = 2^{n-1} + (-1)^{n+1}$ [ts_1].", "dependencies": ["tc_1", "l1", "l2", "l3", "l4", "def_1", "l5", "l6", "l7", "l8", "l9", "l10", "l11", "l12"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (h_formula_1 : a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1))\n  (h_formula_2 : a 2 = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1))\n  (h_inductive : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (2 : \u2124)^(j-1) + (-1 : \u2124)^(j+1)) \u2192 a (k+1) = (2 : \u2124)^k + (-1 : \u2124)^(k+2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (h_formula_1 : a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1))\n  (h_formula_2 : a 2 = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1))\n  (h_inductive : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (2 : \u2124)^(j-1) + (-1 : \u2124)^(j+1)) \u2192 a (k+1) = (2 : \u2124)^k + (-1 : \u2124)^(k+2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by\n    intro n\n    have h : \u2200 n : \u2115, n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by\n      intro n\n      induction' n using Nat.strong_induction_on with n ih\n      intro hn\n      match n with\n      | 0 =>\n        exfalso\n        linarith\n      | 1 =>\n        simp_all [h_formula_1]\n      | 2 =>\n        simp_all [h_formula_2]\n      | k + 3 =>\n        have h\u2081 : k + 3 \u2265 3 := by linarith\n        have h\u2082 : (k + 3 - 1 : \u2115) = k + 2 := by\n          omega\n        have h\u2083 : (k + 3 - 1 : \u2115) \u2265 2 := by\n          omega\n        have h\u2084 : \u2200 (j : \u2115), 1 \u2264 j \u2227 j \u2264 (k + 2 : \u2115) \u2192 a j = (2 : \u2124)^(j - 1) + (-1 : \u2124)^(j + 1) := by\n          intro j hj\n          have h\u2085 : j < k + 3 := by\n            omega\n          have h\u2086 : j \u2265 1 := by\n            linarith\n          have h\u2087 : a j = (2 : \u2124)^(j - 1) + (-1 : \u2124)^(j + 1) := by\n            have h\u2088 : j \u2265 1 := by linarith\n            have h\u2089 : a j = (2 : \u2124)^(j - 1) + (-1 : \u2124)^(j + 1) := by\n              apply ih j\n              <;> omega\n            exact h\u2089\n          exact h\u2087\n        have h\u2085 : a ((k + 2 : \u2115) + 1) = (2 : \u2124)^(k + 2 : \u2115) + (-1 : \u2124)^((k + 2 : \u2115) + 2) := by\n          apply h_inductive (k + 2)\n          <;> norm_num at h\u2083 \u22a2 <;>\n            (try omega) <;>\n            (try simp_all) <;>\n            (try omega)\n          <;>\n            (try\n              {\n                intro j hj\n                exact h\u2084 j \u27e8by omega, by omega\u27e9\n              })\n        have h\u2086 : a (k + 3) = (2 : \u2124)^(k + 2 : \u2115) + (-1 : \u2124)^((k + 2 : \u2115) + 2) := by\n          have h\u2087 : (k + 2 : \u2115) + 1 = k + 3 := by ring\n          rw [h\u2087] at h\u2085\n          exact h\u2085\n        have h\u2087 : (2 : \u2124)^(k + 2 : \u2115) + (-1 : \u2124)^((k + 2 : \u2115) + 2) = (2 : \u2124)^((k + 3) - 1 : \u2115) + (-1 : \u2124)^((k + 3) + 1) := by\n          have h\u2088 : (k + 3 : \u2115) - 1 = k + 2 := by\n            omega\n          have h\u2089 : ((k + 2 : \u2115) + 2 : \u2115) = ((k + 3 : \u2115) + 1 : \u2115) := by\n            ring_nf\n            <;> omega\n          calc\n            (2 : \u2124)^(k + 2 : \u2115) + (-1 : \u2124)^((k + 2 : \u2115) + 2) = (2 : \u2124)^((k + 3) - 1 : \u2115) + (-1 : \u2124)^((k + 2 : \u2115) + 2) := by\n              rw [show (k + 2 : \u2115) = (k + 3 : \u2115) - 1 by omega]\n              <;> simp [h\u2088]\n            _ = (2 : \u2124)^((k + 3) - 1 : \u2115) + (-1 : \u2124)^((k + 3) + 1) := by\n              rw [show ((k + 2 : \u2115) + 2 : \u2115) = ((k + 3 : \u2115) + 1 : \u2115) by\n                ring_nf\n                <;> omega]\n              <;> simp [h\u2089]\n        have h\u2088 : a (k + 3) = (2 : \u2124)^((k + 3) - 1 : \u2115) + (-1 : \u2124)^((k + 3) + 1) := by\n          rw [h\u2086, h\u2087]\n        simp_all [Nat.add_assoc]\n        <;>\n          (try omega) <;>\n          (try ring_nf at *) <;>\n          (try norm_num at *) <;>\n          (try linarith)\n    exact h n\n  exact h_main", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 24, "column": 8, "endLine": 24, "endColumn": 30, "data": "tactic 'simp' failed, nested error:\nmaximum recursion depth has been reached\nuse `set_option maxRecDepth <num>` to increase limit\nuse `set_option diagnostics true` to get diagnostic information"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definition is correctly formalized. The function type (\u2115 \u2192 \u2124), initial conditions, and recurrence relation all match the natural language specification perfectly.", "The base case for n=1 is correctly represented. The Lean formalization explicitly shows the formula evaluation at n=1, which matches the natural language statement.", "The base case for n=2 is correctly represented. The Lean formalization explicitly shows the formula evaluation at n=2, consistent with the natural language.", "The inductive step is perfectly captured. The Lean formalization correctly represents the logical structure: for k\u22652, if the formula holds for all j in [1,k], then it holds for k+1.", "The conclusion is correctly formalized. The universal quantification over natural numbers n\u22651 and the formula statement match the natural language conclusion exactly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "NL statement", "error_report": "Formalization appears correct (score=1.0 > 0.6), and the prover could prove the NEGATION of the NL lemma. The NL statement is likely incorrect."}, "solved_negation": {"lean_verify": true, "lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a : \u2115 \u2192 \u2124)\n  (h1 : a 1 = 2) \n  (h2 : a 2 = 1) \n  (h_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = a (n-1) + 2 * a (n-2))\n  (h_formula_1 : a 1 = (2 : \u2124)^(1-1) + (-1 : \u2124)^(1+1))\n  (h_formula_2 : a 2 = (2 : \u2124)^(2-1) + (-1 : \u2124)^(2+1))\n  (h_inductive : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j = (2 : \u2124)^(j-1) + (-1 : \u2124)^(j+1)) \u2192 a (k+1) = (2 : \u2124)^k + (-1 : \u2124)^(k+2)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by\n  have h_main : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by\n    intro n hn\n    have h : \u2200 (n : \u2115), n \u2265 1 \u2192 a n = (2 : \u2124)^(n-1) + (-1 : \u2124)^(n+1) := by\n      intro n hn\n      induction' n using Nat.strong_induction_on with n ih\n      match n with\n      | 0 =>\n        -- This case is impossible because hn : 0 \u2265 1 is false\n        exfalso\n        linarith\n      | 1 =>\n        -- Base case: n = 1\n        simp [h_formula_1]\n      | 2 =>\n        -- Base case: n = 2\n        simp [h_formula_2]\n      | k + 3 =>\n        -- Inductive step for n = k + 3\n        have h\u2081 : a (k + 3) = (2 : \u2124)^(k + 2) + (-1 : \u2124)^(k + 4) := by\n          have h\u2082 : a (k + 3) = a (k + 2) + 2 * a (k + 1) := by\n            have h\u2083 : (k + 3 : \u2115) \u2265 3 := by\n              omega\n            have h\u2084 : a (k + 3) = a (k + 3 - 1) + 2 * a (k + 3 - 2) := h_rec (k + 3) h\u2083\n            have h\u2085 : (k + 3 : \u2115) - 1 = k + 2 := by\n              omega\n            have h\u2086 : (k + 3 : \u2115) - 2 = k + 1 := by\n              omega\n            rw [h\u2084, h\u2085, h\u2086]\n            <;> simp [add_assoc]\n          have h\u2083 : a (k + 2) = (2 : \u2124)^((k + 2) - 1) + (-1 : \u2124)^((k + 2) + 1) := by\n            have h\u2084 : (k + 2 : \u2115) \u2265 1 := by\n              omega\n            have h\u2085 : a (k + 2) = (2 : \u2124)^((k + 2) - 1) + (-1 : \u2124)^((k + 2) + 1) := ih (k + 2) (by omega) (by omega)\n            exact h\u2085\n          have h\u2084 : a (k + 1) = (2 : \u2124)^((k + 1) - 1) + (-1 : \u2124)^((k + 1) + 1) := by\n            have h\u2085 : (k + 1 : \u2115) \u2265 1 := by\n              omega\n            have h\u2086 : a (k + 1) = (2 : \u2124)^((k + 1) - 1) + (-1 : \u2124)^((k + 1) + 1) := ih (k + 1) (by omega) (by omega)\n            exact h\u2086\n          rw [h\u2082, h\u2083, h\u2084]\n          -- Simplify the expression to match the target form\n          have h\u2085 : (k + 2 : \u2115) - 1 = k + 1 := by\n            omega\n          have h\u2086 : (k + 2 : \u2115) + 1 = k + 3 := by\n            omega\n          have h\u2087 : (k + 1 : \u2115) - 1 = k := by\n            omega\n          have h\u2088 : (k + 1 : \u2115) + 1 = k + 2 := by\n            omega\n          simp [h\u2085, h\u2086, h\u2087, h\u2088, pow_add, pow_one, pow_two, mul_add, mul_one, mul_assoc]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> cases' Nat.even_or_odd k with h\u2089 h\u2089 <;> simp_all [pow_add, pow_mul, Nat.even_iff, Nat.odd_iff]\n          <;> ring_nf at *\n          <;> norm_num at *\n          <;> omega\n        exact h\u2081\n    exact h n hn\n  exact h_main"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l9", "label": "l9", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l10", "label": "l10", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l11", "label": "l11", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l12", "label": "l12", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l9", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l10", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l9", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "l11", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l10", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l11", "to": "l12", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l11", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l12", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    