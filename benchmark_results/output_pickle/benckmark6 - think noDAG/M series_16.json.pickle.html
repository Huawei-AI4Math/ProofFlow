
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=3$ and the recurrence relation $a_n = 2a_{n-1} + a_{n-2}$ for $n \geq 3$. Let the sequence $(b_n)$ be defined by $b_1=2$, $b_2=5$ and the recurrence relation $b_n = 2b_{n-1} + b_{n-2}$ for $n \geq 3$. Prove that for all integers $n \geq 1$, the inequality $a_n < b_n$ holds.

Proof: For $n=1$, we have $a_1=1$ and $b_1=2$. The inequality $1 < 2$ holds. For $n=2$, we have $a_2=3$ and $b_2=5$. The inequality $3 < 5$ holds. Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \leq j \leq k$ for some integer $k \geq 2$. So, we assume $a_j < b_j$ is true. We must prove the inequality holds for $n=k+1$, i.e., $a_{k+1} < b_{k+1}$. From the recurrence relations, we have: $a_{k+1} = 2a_k + a_{k-1}$ and $b_{k+1} = 2b_k + b_{k-1}$. By the inductive hypothesis, we know that $a_k < b_k$ and $a_{k-1} < b_{k-1}$. Since we are dealing with positive sequences, we can multiply inequalities by positive numbers. We have $2a_k < 2b_k$ and $a_{k-1} < b_{k-1}$. Adding these two inequalities, we get: $2a_k + a_{k-1} < 2b_k + b_{k-1}$. By the definitions of the recurrence relations, the left side is $a_{k+1}$ and the right side is $b_{k+1}$. Thus, $a_{k+1} < b_{k+1}$. By the principle of **strong mathematical induction**, the inequality $a_n < b_n$ holds for all integers $n \geq 1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let the sequence $(a_n)$ be defined by $a_1=1$, $a_2=3$ and the recurrence relation $a_n = 2a_{n-1} + a_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u2115 \u2192 \u2124)\n(tc_1 : a 1 = 1 \u2227 a 2 = 3 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n(tc_2 : b 1 = 2 \u2227 b 2 = 5 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition a\u2081 = 1 is exactly captured by 'a 1 = 1' in tc_1", "The condition a\u2082 = 3 is exactly captured by 'a 2 = 3' in tc_1", "The recurrence relation a\u2099 = 2\u00b7a\u2099\u208b\u2081 + a\u2099\u208b\u2082 for n \u2265 3 is exactly captured by '\u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2)' in tc_1", "The integer requirement is captured by the type declaration 'a : \u2115 \u2192 \u2124' which specifies that a maps to integers", "The natural language conclusion states that sequence (a\u2099) is completely defined, but the Lean code introduces an additional sequence b with different initial conditions that is not mentioned in the natural language at all. This is a major addition not present in the original statement"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The condition a\u2081 = 1 is exactly captured by 'a 1 = 1' in tc_1\", \"The condition a\u2082 = 3 is exactly captured by 'a 2 = 3' in tc_1\", \"The recurrence relation a\u2099 = 2\u00b7a\u2099\u208b\u2081 + a\u2099\u208b\u2082 for n \u2265 3 is exactly captured by '\u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2)' in tc_1\", \"The integer requirement is captured by the type declaration 'a : \u2115 \u2192 \u2124' which specifies that a maps to integers\", 'The natural language conclusion states that sequence (a\u2099) is completely defined, but the Lean code introduces an additional sequence b with different initial conditions that is not mentioned in the natural language at all. This is a major addition not present in the original statement']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let the sequence $(b_n)$ be defined by $b_1=2$, $b_2=5$ and the recurrence relation $b_n = 2b_{n-1} + b_{n-2}$ for $n \\geq 3$.", "statement": "Premise:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem tc_2 :\n  \u2203 (a b : \u2115 \u2192 \u2124),\n    (a 1 = 1 \u2227 a 2 = 3 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2)) \u2227\n    (b 1 = 2 \u2227 b 2 = 5 \u2227 \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2)) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition a\u2081 = 1 matches exactly with 'a 1 = 1' in Lean", "The condition a\u2082 = 3 matches exactly with 'a 2 = 3' in Lean", "The recurrence relation a\u2099 = 2\u00b7a\u2099\u208b\u2081 + a\u2099\u208b\u2082 for n \u2265 3 matches exactly with '\u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2)' in Lean", "The condition b\u2081 = 2 matches exactly with 'b 1 = 2' in Lean", "The condition b\u2082 = 5 matches exactly with 'b 2 = 5' in Lean", "The recurrence relation b\u2099 = 2\u00b7b\u2099\u208b\u2081 + b\u2099\u208b\u2082 for n \u2265 3 matches exactly with '\u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2)' in Lean", "The natural language concludes that sequence (a\u2099) is well-defined for all positive integers n, but the Lean formalization only states existence of such sequences without asserting well-definedness", "The natural language concludes that sequence (b\u2099) is well-defined for all positive integers n, but the Lean formalization only states existence of such sequences without asserting well-definedness"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The condition a\u2081 = 1 matches exactly with 'a 1 = 1' in Lean\", \"The condition a\u2082 = 3 matches exactly with 'a 2 = 3' in Lean\", \"The recurrence relation a\u2099 = 2\u00b7a\u2099\u208b\u2081 + a\u2099\u208b\u2082 for n \u2265 3 matches exactly with '\u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2)' in Lean\", \"The condition b\u2081 = 2 matches exactly with 'b 1 = 2' in Lean\", \"The condition b\u2082 = 5 matches exactly with 'b 2 = 5' in Lean\", \"The recurrence relation b\u2099 = 2\u00b7b\u2099\u208b\u2081 + b\u2099\u208b\u2082 for n \u2265 3 matches exactly with '\u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2)' in Lean\", 'The natural language concludes that sequence (a\u2099) is well-defined for all positive integers n, but the Lean formalization only states existence of such sequences without asserting well-definedness', 'The natural language concludes that sequence (b\u2099) is well-defined for all positive integers n, but the Lean formalization only states existence of such sequences without asserting well-definedness']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "For $n=1$, we have $a_1=1$ and $b_1=2$. The inequality $1 < 2$ holds.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2].\nTherefore, we conclude:\n\u2022 a\u2081 < b\u2081 [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b : \u2115 \u2192 \u2124) \n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2)) :\n  a 1 < b 1 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l1 (a b : \u2115 \u2192 \u2124) \n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2)) :\n  a 1 < b 1 := by\n  have h_a1 : a 1 = (1 : \u2124) := by\n    norm_num [ha1]\n    <;> simp_all\n    <;> norm_num\n    <;> linarith\n  \n  have h_b1 : b 1 = (2 : \u2124) := by\n    norm_num [hb1]\n    <;> simp_all\n    <;> norm_num\n    <;> linarith\n  \n  have h_main : a 1 < b 1 := by\n    rw [h_a1, h_b1]\n    <;> norm_num\n    <;> simp_all\n    <;> norm_num\n    <;> linarith\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence (a_n) definition is correctly formalized with proper type declaration (\u2115 \u2192 \u2124), initial conditions, and recurrence relation exactly matching the natural language specification.", "The sequence (b_n) definition is correctly formalized with the same structure as sequence a, with all initial conditions and recurrence relation properly captured.", "The conclusion a\u2081 < b\u2081 is directly and correctly translated to a 1 < b 1, which is the standard Lean notation for the same mathematical statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "For $n=2$, we have $a_2=3$ and $b_2=5$. The inequality $3 < 5$ holds.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1].\nTherefore, we conclude:\n\u2022 a\u2082 < b\u2082 [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b : \u2115 \u2192 \u2124) \n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (l1 : a 1 < b 1) :\n  a 2 < b 2 := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l2 (a b : \u2115 \u2192 \u2124) \n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (l1 : a 1 < b 1) :\n  a 2 < b 2 := by\n  have h_main : a 2 < b 2 := by\n    rw [ha2, hb2]\n    <;> norm_num\n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The sequence (a_n) definition is correctly formalized with proper base cases and recurrence relation", "The sequence (b_n) definition is correctly formalized with proper base cases and recurrence relation", "The assumption a\u2081 < b\u2081 is correctly captured as l1 : a 1 < b 1", "The conclusion a\u2082 < b\u2082 is correctly stated as the theorem goal", "The function types \u2115 \u2192 \u2124 appropriately represent sequences of integers as described in natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "Now for the inductive step, assume the inequality holds for all integers $j$ such that $1 \\leq j \\leq k$ for some integer $k \\geq 2$. So, we assume $a_j < b_j$ is true.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1];\n\u2022 a\u2082 < b\u2082 [l2].\nDefinition:\n\u2022 For an integer k \u2265 2, we assume as the inductive hypothesis (IH) that for all integers j such that 1 \u2264 j \u2264 k, the inequality a_j < b_j holds [def_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u2115 \u2192 \u2124)\n\ntheorem def_1 (k : \u2115) (hk : k \u2265 2)\n  (h_a1 : a 1 = 1) (h_a2 : a 2 = 3) \n  (h_a_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (h_b1 : b 1 = 2) (h_b2 : b 2 = 5) \n  (h_b_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_base : a 1 < b 1 \u2227 a 2 < b 2) :\n  \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the definition of sequence a_n with initial values and recurrence relation", "The Lean formalization correctly captures the definition of sequence b_n with initial values and recurrence relation", "The Lean formalization captures a\u2081 < b\u2081 as part of the conjunction in h_base", "The Lean formalization captures a\u2082 < b\u2082 as part of the conjunction in h_base", "The Lean formalization correctly represents the inductive hypothesis with parameter k \u2265 2 and the conclusion that for all j with 1 \u2264 j \u2264 k, we have a_j < b_j"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "From the recurrence relations, we have: $a_{k+1} = 2a_k + a_{k-1}$ and $b_{k+1} = 2b_k + b_{k-1}$.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1];\n\u2022 a\u2082 < b\u2082 [l2];\n\u2022 For an integer k \u2265 2, we assume as the inductive hypothesis (IH) that for all integers j such that 1 \u2264 j \u2264 k, the inequality a_j < b_j holds [def_1].\nTherefore, we conclude:\n\u2022 a_{k+1} = 2*a_k + a_{k-1} and b_{k+1} = 2*b_k + b_{k-1} [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u2115 \u2192 \u2124)\n\ntheorem l3 (k : \u2115) (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_base : a 1 < b 1 \u2227 a 2 < b 2)\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  a (k + 1) < b (k + 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l3 {a b : \u2115 \u2192 \u2124} (k : \u2115) (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_base : a 1 < b 1 \u2227 a 2 < b 2)\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  a (k + 1) < b (k + 1) := by\n  have h_k_plus_1_ge_3 : k + 1 \u2265 3 := by\n    omega\n  \n  have h_a_rec : a (k + 1) = 2 * a k + a (k - 1) := by\n    have h\u2081 : a (k + 1) = 2 * a (k + 1 - 1) + a (k + 1 - 2) := by\n      apply ha_rec\n      <;> omega\n    have h\u2082 : (k + 1 : \u2115) - 1 = k := by\n      omega\n    have h\u2083 : (k + 1 : \u2115) - 2 = k - 1 := by\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    rw [h\u2081]\n    rw [h\u2082]\n    rw [h\u2083]\n    <;>\n    (try omega)\n    <;>\n    (try linarith)\n  \n  have h_b_rec : b (k + 1) = 2 * b k + b (k - 1) := by\n    have h\u2081 : b (k + 1) = 2 * b (k + 1 - 1) + b (k + 1 - 2) := by\n      apply hb_rec\n      <;> omega\n    have h\u2082 : (k + 1 : \u2115) - 1 = k := by\n      omega\n    have h\u2083 : (k + 1 : \u2115) - 2 = k - 1 := by\n      cases k with\n      | zero => contradiction\n      | succ k' =>\n        cases k' with\n        | zero => contradiction\n        | succ k'' =>\n          simp [Nat.succ_eq_add_one, Nat.add_assoc]\n          <;> ring_nf at *\n          <;> omega\n    rw [h\u2081]\n    rw [h\u2082]\n    rw [h\u2083]\n    <;>\n    (try omega)\n    <;>\n    (try linarith)\n  \n  have h_ineq_k : a k < b k := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try linarith)\n    have h\u2082 : a k < b k := h_inh k h\u2081\n    exact h\u2082\n  \n  have h_ineq_k_minus_1 : a (k - 1) < b (k - 1) := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2084 : k \u2265 2 := hk\n        omega\n      have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n        have h\u2085 : k \u2265 2 := hk\n        omega\n      exact \u27e8h\u2083, h\u2084\u27e9\n    have h\u2082 : a (k - 1) < b (k - 1) := h_inh (k - 1) h\u2081\n    exact h\u2082\n  \n  have h_combine : 2 * a k + a (k - 1) < 2 * b k + b (k - 1) := by\n    have h\u2081 : (2 : \u2124) * a k < 2 * b k := by\n      have h\u2082 : a k < b k := h_ineq_k\n      linarith\n    have h\u2082 : a (k - 1) < b (k - 1) := h_ineq_k_minus_1\n    linarith\n  \n  have h_main : a (k + 1) < b (k + 1) := by\n    rw [h_a_rec]\n    rw [h_b_rec]\n    exact h_combine\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence (a_n) definition is correctly captured with proper initial conditions and recurrence relation.", "The sequence (b_n) definition is correctly captured with proper initial conditions and recurrence relation.", "The base case inequalities a\u2081 < b\u2081 and a\u2082 < b\u2082 are properly formalized as a conjunction.", "The inductive hypothesis is correctly formalized with the constraint k \u2265 2 and the universal quantification over valid indices.", "Major discrepancy in the conclusion: Natural language concludes that the recurrence relations hold for k+1 terms, but Lean concludes the inequality a_{k+1} < b_{k+1}. These represent fundamentally different logical conclusions."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence (a_n) definition is correctly captured with proper initial conditions and recurrence relation.', 'The sequence (b_n) definition is correctly captured with proper initial conditions and recurrence relation.', 'The base case inequalities a\u2081 < b\u2081 and a\u2082 < b\u2082 are properly formalized as a conjunction.', 'The inductive hypothesis is correctly formalized with the constraint k \u2265 2 and the universal quantification over valid indices.', 'Major discrepancy in the conclusion: Natural language concludes that the recurrence relations hold for k+1 terms, but Lean concludes the inequality a_{k+1} < b_{k+1}. These represent fundamentally different logical conclusions.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By the inductive hypothesis, we know that $a_k < b_k$ and $a_{k-1} < b_{k-1}$.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1];\n\u2022 a\u2082 < b\u2082 [l2];\n\u2022 For an integer k \u2265 2, we assume as the inductive hypothesis (IH) that for all integers j such that 1 \u2264 j \u2264 k, the inequality a_j < b_j holds [def_1];\n\u2022 a_{k+1} = 2*a_k + a_{k-1} and b_{k+1} = 2*b_k + b_{k-1} [l3].\nTherefore, we conclude:\n\u2022 a_k < b_k and a_{k-1} < b_{k-1} [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u2115 \u2192 \u2124)\n\ntheorem l4 (k : \u2115) (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  a (k + 1) < b (k + 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (a b : \u2115 \u2192 \u2124)\n\ntheorem l4 (k : \u2115) (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  a (k + 1) < b (k + 1) := by\n  have h_k1_ge_3 : k + 1 \u2265 3 := by\n    have h\u2081 : k \u2265 2 := hk\n    omega\n  \n  have h_a_k1 : a (k + 1) = 2 * a k + a (k - 1) := by\n    have h\u2081 : a (k + 1) = 2 * a ((k + 1) - 1) + a ((k + 1) - 2) := by\n      have h\u2082 : (k + 1 : \u2115) \u2265 3 := by omega\n      have h\u2083 := ha_rec (k + 1) h\u2082\n      exact h\u2083\n    have h\u2082 : (k + 1 : \u2115) - 1 = k := by\n      simp [Nat.add_sub_cancel]\n    have h\u2083 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2084 : k \u2265 2 := hk\n      have h\u2085 : (k + 1 : \u2115) \u2265 3 := by omega\n      have h\u2086 : (k + 1 : \u2115) - 2 = k - 1 := by\n        omega\n      exact h\u2086\n    rw [h\u2081, h\u2082, h\u2083]\n    <;> simp [Nat.add_sub_cancel]\n    <;> ring_nf\n    <;> norm_num\n    <;> omega\n  \n  have h_b_k1 : b (k + 1) = 2 * b k + b (k - 1) := by\n    have h\u2081 : b (k + 1) = 2 * b ((k + 1) - 1) + b ((k + 1) - 2) := by\n      have h\u2082 : (k + 1 : \u2115) \u2265 3 := by omega\n      have h\u2083 := hb_rec (k + 1) h\u2082\n      exact h\u2083\n    have h\u2082 : (k + 1 : \u2115) - 1 = k := by\n      simp [Nat.add_sub_cancel]\n    have h\u2083 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2084 : k \u2265 2 := hk\n      have h\u2085 : (k + 1 : \u2115) \u2265 3 := by omega\n      have h\u2086 : (k + 1 : \u2115) - 2 = k - 1 := by\n        omega\n      exact h\u2086\n    rw [h\u2081, h\u2082, h\u2083]\n    <;> simp [Nat.add_sub_cancel]\n    <;> ring_nf\n    <;> norm_num\n    <;> omega\n  \n  have h_a_k_lt_b_k : a k < b k := by\n    have h\u2081 : 1 \u2264 k \u2227 k \u2264 k := by\n      constructor\n      \u00b7 -- Prove 1 \u2264 k\n        omega\n      \u00b7 -- Prove k \u2264 k\n        omega\n    have h\u2082 : a k < b k := h_inh k h\u2081\n    exact h\u2082\n  \n  have h_a_k1_lt_b_k1 : a (k - 1) < b (k - 1) := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k \u2265 2 := hk\n      have h\u2083 : 1 \u2264 (k - 1 : \u2115) := by\n        have h\u2084 : k \u2265 2 := hk\n        omega\n      have h\u2084 : (k - 1 : \u2115) \u2264 k := by\n        omega\n      exact \u27e8h\u2083, h\u2084\u27e9\n    have h\u2082 : a (k - 1) < b (k - 1) := h_inh (k - 1) h\u2081\n    exact h\u2082\n  \n  have h_main : a (k + 1) < b (k + 1) := by\n    rw [h_a_k1, h_b_k1]\n    have h\u2081 : (a k : \u2124) < b k := by exact_mod_cast h_a_k_lt_b_k\n    have h\u2082 : (a (k - 1) : \u2124) < b (k - 1) := by exact_mod_cast h_a_k1_lt_b_k1\n    have h\u2083 : (2 : \u2124) * a k + a (k - 1) < 2 * b k + b (k - 1) := by\n      -- Use the fact that 2 * a_k + a_{k-1} < 2 * b_k + b_{k-1} because a_k < b_k and a_{k-1} < b_{k-1}\n      have h\u2084 : (2 : \u2124) * a k < 2 * b k := by\n        -- Multiply both sides of a_k < b_k by 2\n        linarith\n      -- Add the inequalities 2 * a_k < 2 * b_k and a_{k-1} < b_{k-1}\n      linarith\n    exact_mod_cast h\u2083\n  \n  apply h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The sequence definition for a_n is correctly captured with initial conditions ha1, ha2 and recurrence relation ha_rec.", "The sequence definition for b_n is correctly captured with initial conditions hb1, hb2 and recurrence relation hb_rec.", "The condition a\u2081 < b\u2081 is not explicitly stated as a hypothesis in the Lean formalization, though it could be derived from the given values.", "The condition a\u2082 < b\u2082 is not explicitly stated as a hypothesis in the Lean formalization, though it could be derived from the given values.", "The inductive hypothesis is correctly formalized as h_inh with the proper quantification over j.", "The recurrence relations l3 are not explicitly stated as separate hypotheses but are embedded in the sequence definitions, which is a structural difference.", "The conclusion in Lean is a(k+1) < b(k+1), but the natural language states the conclusion should be a_k < b_k and a_{k-1} < b_{k-1}. This is a major logical inconsistency - the Lean version proves the next step of induction rather than stating what follows from the inductive hypothesis."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definition for a_n is correctly captured with initial conditions ha1, ha2 and recurrence relation ha_rec.', 'The sequence definition for b_n is correctly captured with initial conditions hb1, hb2 and recurrence relation hb_rec.', 'The condition a\u2081 < b\u2081 is not explicitly stated as a hypothesis in the Lean formalization, though it could be derived from the given values.', 'The condition a\u2082 < b\u2082 is not explicitly stated as a hypothesis in the Lean formalization, though it could be derived from the given values.', 'The inductive hypothesis is correctly formalized as h_inh with the proper quantification over j.', 'The recurrence relations l3 are not explicitly stated as separate hypotheses but are embedded in the sequence definitions, which is a structural difference.', 'The conclusion in Lean is a(k+1) < b(k+1), but the natural language states the conclusion should be a_k < b_k and a_{k-1} < b_{k-1}. This is a major logical inconsistency - the Lean version proves the next step of induction rather than stating what follows from the inductive hypothesis.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Since we are dealing with positive sequences, we can multiply inequalities by positive numbers. We have $2a_k < 2b_k$.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1];\n\u2022 a\u2082 < b\u2082 [l2];\n\u2022 For an integer k \u2265 2, we assume as the inductive hypothesis (IH) that for all integers j such that 1 \u2264 j \u2264 k, the inequality a_j < b_j holds [def_1];\n\u2022 a_{k+1} = 2*a_k + a_{k-1} and b_{k+1} = 2*b_k + b_{k-1} [l3];\n\u2022 a_k < b_k and a_{k-1} < b_{k-1} [l4].\nTherefore, we conclude:\n\u2022 2*a_k < 2*b_k [l5].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a b : \u2115 \u2192 \u2124)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  2 * a k < 2 * b k := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l5 \n  (a b : \u2115 \u2192 \u2124)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (k : \u2115) (hk : k \u2265 2)\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  2 * a k < 2 * b k := by\n  have h_aj_lt_bj : a k < b k := by\n    have h\u2081 : 1 \u2264 (k : \u2115) := by\n      omega\n    have h\u2082 : (k : \u2115) \u2264 k := by\n      omega\n    have h\u2083 : 1 \u2264 (k : \u2115) \u2227 (k : \u2115) \u2264 k := by\n      exact \u27e8h\u2081, h\u2082\u27e9\n    have h\u2084 : a k < b k := h_inh k h\u2083\n    exact h\u2084\n  \n  have h_main : 2 * a k < 2 * b k := by\n    have h\u2081 : (2 : \u2124) > 0 := by norm_num\n    -- Since 2 is positive, multiplying both sides of the inequality a_k < b_k by 2 preserves the inequality.\n    have h\u2082 : 2 * a k < 2 * b k := by\n      nlinarith\n    exact h\u2082\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all the essential mathematical content from the natural language. The sequence definitions, recurrence relations, inductive hypothesis, and conclusion are all properly formalized. While the natural language includes some redundant statements (like [l1], [l2], [l3], [l4]) that are either subsumed by other hypotheses or derivable from the recurrence definitions, the Lean code efficiently captures the core logical structure. The inductive hypothesis `h_inh` properly encompasses the base cases and the required inequalities, making the separate mention of these cases in the natural language redundant rather than missing from the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Adding these two inequalities, we get: $2a_k + a_{k-1} < 2b_k + b_{k-1}$.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1];\n\u2022 a\u2082 < b\u2082 [l2];\n\u2022 For an integer k \u2265 2, we assume as the inductive hypothesis (IH) that for all integers j such that 1 \u2264 j \u2264 k, the inequality a_j < b_j holds [def_1];\n\u2022 a_{k+1} = 2*a_k + a_{k-1} and b_{k+1} = 2*b_k + b_{k-1} [l3];\n\u2022 a_k < b_k and a_{k-1} < b_{k-1} [l4];\n\u2022 2*a_k < 2*b_k [l5].\nTherefore, we conclude:\n\u2022 2*a_k + a_{k-1} < 2*b_k + b_{k-1} [l6].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a b : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j)\n  (h_l5 : 2 * a k < 2 * b k) :\n  2 * a k + a (k - 1) < 2 * b k + b (k - 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l6 \n  (a b : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j)\n  (h_l5 : 2 * a k < 2 * b k) :\n  2 * a k + a (k - 1) < 2 * b k + b (k - 1) := by\n  have h_k1 : 1 \u2264 (k - 1 : \u2115) := by\n    have h\u2081 : k \u2265 2 := hk\n    have h\u2082 : k - 1 \u2265 1 := by\n      have h\u2083 : k \u2265 2 := hk\n      omega\n    exact h\u2082\n  \n  have h_k2 : (k - 1 : \u2115) \u2264 k := by\n    have h\u2081 : (k - 1 : \u2115) \u2264 k := by\n      have h\u2082 : k - 1 \u2264 k := by\n        omega\n      exact h\u2082\n    exact h\u2081\n  \n  have h_aj_lt_bj : a (k - 1) < b (k - 1) := by\n    have h\u2081 : 1 \u2264 (k - 1 : \u2115) \u2227 (k - 1 : \u2115) \u2264 k := by\n      constructor <;>\n      (try omega) <;>\n      (try\n        {\n          have h\u2082 : k \u2265 2 := hk\n          omega\n        }) <;>\n      (try\n        {\n          have h\u2082 : k \u2265 2 := hk\n          omega\n        })\n    have h\u2082 : a (k - 1) < b (k - 1) := h_inh (k - 1) h\u2081\n    exact h\u2082\n  \n  have h_main : 2 * a k + a (k - 1) < 2 * b k + b (k - 1) := by\n    have h\u2081 : (2 : \u2124) * a k < 2 * b k := by\n      exact h_l5\n    have h\u2082 : (a (k - 1) : \u2124) < b (k - 1) := by\n      exact_mod_cast h_aj_lt_bj\n    -- Add the two inequalities to get the final result\n    have h\u2083 : (2 : \u2124) * a k + a (k - 1) < 2 * b k + b (k - 1) := by\n      linarith\n    exact h\u2083\n  \n  exact h_main", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all essential logical components from the natural language. The sequence definitions, recurrence relations, inductive hypothesis, and conclusion are all properly formalized. Some intermediate steps (l1, l2, l4) are not explicitly stated as separate hypotheses but are derivable from the given conditions (particularly h_inh). The constraint hk : k \u2265 2 is appropriately included to ensure the inductive step is valid. The mathematical meaning and logical structure are preserved completely."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "By the definitions of the recurrence relations, the left side is $a_{k+1}$ and the right side is $b_{k+1}$. Thus, $a_{k+1} < b_{k+1}$.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 a\u2081 < b\u2081 [l1];\n\u2022 a\u2082 < b\u2082 [l2];\n\u2022 For an integer k \u2265 2, we assume as the inductive hypothesis (IH) that for all integers j such that 1 \u2264 j \u2264 k, the inequality a_j < b_j holds [def_1];\n\u2022 a_{k+1} = 2*a_k + a_{k-1} and b_{k+1} = 2*b_k + b_{k-1} [l3];\n\u2022 a_k < b_k and a_{k-1} < b_{k-1} [l4];\n\u2022 2*a_k < 2*b_k [l5];\n\u2022 2*a_k + a_{k-1} < 2*b_k + b_{k-1} [l6].\nTherefore, we conclude:\n\u2022 a_{k+1} < b_{k+1} [l7].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a b : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  a (k + 1) < b (k + 1) := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem l7 \n  (a b : \u2115 \u2192 \u2124)\n  (k : \u2115)\n  (hk : k \u2265 2)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (h_inh : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) :\n  a (k + 1) < b (k + 1) := by\n  have h\u2081 : a k < b k := by\n    have h\u2081\u2081 : 1 \u2264 k := by linarith\n    have h\u2081\u2082 : k \u2264 k := by linarith\n    have h\u2081\u2083 : a k < b k := h_inh k \u27e8h\u2081\u2081, h\u2081\u2082\u27e9\n    exact h\u2081\u2083\n  \n  have h\u2082 : a (k - 1) < b (k - 1) := by\n    have h\u2082\u2081 : 1 \u2264 (k - 1 : \u2115) := by\n      have h\u2082\u2081\u2081 : k \u2265 2 := hk\n      have h\u2082\u2081\u2082 : (k : \u2115) - 1 \u2265 1 := by\n        omega\n      exact h\u2082\u2081\u2082\n    have h\u2082\u2082 : (k - 1 : \u2115) \u2264 k := by\n      omega\n    have h\u2082\u2083 : a (k - 1) < b (k - 1) := h_inh (k - 1) \u27e8h\u2082\u2081, h\u2082\u2082\u27e9\n    exact h\u2082\u2083\n  \n  have h\u2083 : 2 * (a k : \u2124) < 2 * (b k : \u2124) := by\n    have h\u2083\u2081 : (a k : \u2124) < (b k : \u2124) := by exact_mod_cast h\u2081\n    have h\u2083\u2082 : 2 * (a k : \u2124) < 2 * (b k : \u2124) := by\n      linarith\n    exact h\u2083\u2082\n  \n  have h\u2084 : 2 * (a k : \u2124) + a (k - 1) < 2 * (b k : \u2124) + b (k - 1) := by\n    have h\u2084\u2081 : (a (k - 1) : \u2124) < (b (k - 1) : \u2124) := by exact_mod_cast h\u2082\n    have h\u2084\u2082 : 2 * (a k : \u2124) < 2 * (b k : \u2124) := h\u2083\n    linarith\n  \n  have h\u2085 : a (k + 1) = 2 * a k + a (k - 1) := by\n    have h\u2085\u2081 : (k + 1 : \u2115) \u2265 3 := by\n      omega\n    have h\u2085\u2082 : a (k + 1) = 2 * a (k + 1 - 1) + a (k + 1 - 2) := ha_rec (k + 1) h\u2085\u2081\n    have h\u2085\u2083 : (k + 1 : \u2115) - 1 = k := by\n      simp [Nat.add_sub_cancel]\n    have h\u2085\u2084 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2085\u2084\u2081 : k \u2265 2 := hk\n      have h\u2085\u2084\u2082 : (k + 1 : \u2115) - 2 = k - 1 := by\n        omega\n      exact h\u2085\u2084\u2082\n    rw [h\u2085\u2082, h\u2085\u2083, h\u2085\u2084]\n    <;> ring_nf\n    <;> simp_all [ha1, ha2]\n    <;> norm_num\n    <;> linarith\n  \n  have h\u2086 : b (k + 1) = 2 * b k + b (k - 1) := by\n    have h\u2086\u2081 : (k + 1 : \u2115) \u2265 3 := by\n      omega\n    have h\u2086\u2082 : b (k + 1) = 2 * b (k + 1 - 1) + b (k + 1 - 2) := hb_rec (k + 1) h\u2086\u2081\n    have h\u2086\u2083 : (k + 1 : \u2115) - 1 = k := by\n      simp [Nat.add_sub_cancel]\n    have h\u2086\u2084 : (k + 1 : \u2115) - 2 = k - 1 := by\n      have h\u2086\u2084\u2081 : k \u2265 2 := hk\n      have h\u2086\u2084\u2082 : (k + 1 : \u2115) - 2 = k - 1 := by\n        omega\n      exact h\u2086\u2084\u2082\n    rw [h\u2086\u2082, h\u2086\u2083, h\u2086\u2084]\n    <;> ring_nf\n    <;> simp_all [hb1, hb2]\n    <;> norm_num\n    <;> linarith\n  \n  have h\u2087 : a (k + 1) < b (k + 1) := by\n    rw [h\u2085, h\u2086]\n    -- Now we need to prove that 2 * a k + a (k - 1) < 2 * b k + b (k - 1)\n    -- This follows directly from h\u2084\n    have h\u2087\u2081 : (2 : \u2124) * a k + a (k - 1) < (2 : \u2124) * b k + b (k - 1) := by\n      -- Use the previously established inequality h\u2084\n      linarith\n    -- Since the left-hand side and right-hand side are the same as in h\u2087\u2081, we can directly use it\n    linarith\n  \n  exact h\u2087", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures all essential components from the natural language. The sequence definitions, initial conditions, inductive hypothesis, and conclusion are all properly represented. The intermediate algebraic steps (l3-l6) mentioned in the natural language are logical consequences that would be derived during proof construction, so their absence from the theorem statement is appropriate. The constraint k \u2265 2 is correctly included to ensure the validity of the inductive step."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "By the principle of **strong mathematical induction**, the inequality $a_n < b_n$ holds for all integers $n \\geq 1$.", "statement": "We assume:\n\u2022 The sequence (a_n) of integers is defined by a\u2081=1, a\u2082=3 and a_n = 2*a_{n-1} + a_{n-2} for n \u2265 3 [tc_1];\n\u2022 The sequence (b_n) of integers is defined by b\u2081=2, b\u2082=5 and b_n = 2*b_{n-1} + b_{n-2} for n \u2265 3 [tc_2];\n\u2022 The base case n=1 holds: a\u2081 < b\u2081 [l1];\n\u2022 The base case n=2 holds: a\u2082 < b\u2082 [l2];\n\u2022 For an integer k \u2265 2, assuming a_j < b_j for 1 \u2264 j \u2264 k (from [def_1]), it follows that a_{k+1} < b_{k+1} (from [l7]).\nTherefore, we conclude:\n\u2022 For all integers n \u2265 1, a_n < b_n [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "def_1", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat\n\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b : \u2115 \u2192 \u2124)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (l1 : a 1 < b 1)\n  (l2 : a 2 < b 2)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1))\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1))\n  (l5 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 2 * a k < 2 * b k)\n  (l6 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 2 * a k + a (k - 1) < 2 * b k + b (k - 1))\n  (l7 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by sorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\ntheorem ts_1 \n  (a b : \u2115 \u2192 \u2124)\n  (ha1 : a 1 = 1) (ha2 : a 2 = 3) \n  (ha_rec : \u2200 n : \u2115, n \u2265 3 \u2192 a n = 2 * a (n - 1) + a (n - 2))\n  (hb1 : b 1 = 2) (hb2 : b 2 = 5) \n  (hb_rec : \u2200 n : \u2115, n \u2265 3 \u2192 b n = 2 * b (n - 1) + b (n - 2))\n  (l1 : a 1 < b 1)\n  (l2 : a 2 < b 2)\n  (def_1 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1))\n  (l3 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1))\n  (l4 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1))\n  (l5 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 2 * a k < 2 * b k)\n  (l6 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 2 * a k + a (k - 1) < 2 * b k + b (k - 1))\n  (l7 : \u2200 k : \u2115, k \u2265 2 \u2192 (\u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 k \u2192 a j < b j) \u2192 a (k + 1) < b (k + 1)) :\n  \u2200 n : \u2115, n \u2265 1 \u2192 a n < b n := by\n  have h_main : \u2200 (n : \u2115), \u2200 (m : \u2115), 1 \u2264 m \u2192 m \u2264 n \u2192 a m < b m := by\n    intro n\n    induction' n with n ih\n    \u00b7 -- Base case: n = 0\n      intro m hm\u2081 hm\u2082\n      -- Since m \u2264 0 and 1 \u2264 m, this case is impossible\n      omega\n    \u00b7 -- Inductive step: assume the statement holds for n, prove for n + 1\n      intro m hm\u2081 hm\u2082\n      by_cases h : m \u2264 n\n      \u00b7 -- Case: m \u2264 n\n        -- Use the induction hypothesis for n\n        exact ih m hm\u2081 h\n      \u00b7 -- Case: m > n\n        -- Since m \u2264 n + 1 and m > n, we have m = n + 1\n        have h\u2081 : m = n + 1 := by omega\n        rw [h\u2081]\n        -- Now we need to prove a (n + 1) < b (n + 1)\n        -- Consider cases for n + 1\n        by_cases hn : n + 1 = 1\n        \u00b7 -- Subcase: n + 1 = 1\n          -- This implies n = 0\n          have h\u2082 : n = 0 := by omega\n          -- Then m = 1\n          have h\u2083 : (n + 1 : \u2115) = 1 := by omega\n          simp_all\n          <;> norm_num at *\n          <;> linarith\n        \u00b7 -- Subcase: n + 1 \u2260 1\n          by_cases hn' : n + 1 = 2\n          \u00b7 -- Subsubcase: n + 1 = 2\n            -- This implies n = 1\n            have h\u2082 : n = 1 := by omega\n            -- Then m = 2\n            have h\u2083 : (n + 1 : \u2115) = 2 := by omega\n            simp_all\n            <;> norm_num at *\n            <;> linarith\n          \u00b7 -- Subsubcase: n + 1 \u2265 3\n            -- Since n + 1 \u2260 1 and n + 1 \u2260 2, and m = n + 1 \u2265 1 (since m \u2265 1)\n            -- We have n \u2265 2\n            have h\u2082 : n \u2265 1 := by\n              by_contra h\u2082\n              have h\u2083 : n = 0 := by omega\n              simp_all\n              <;> norm_num at *\n              <;> omega\n            -- Use the given lemma def_1 to prove the inequality\n            have h\u2083 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 n \u2192 a j < b j := by\n              intro j hj\n              have h\u2084 : j \u2264 n := hj.2\n              have h\u2085 : 1 \u2264 j := hj.1\n              exact ih j h\u2085 h\u2084\n            -- Use def_1 to get the desired inequality\n            have h\u2084 : a (n + 1) < b (n + 1) := by\n              have h\u2085 : n \u2265 2 \u2192 a (n + 1) < b (n + 1) := by\n                intro hn''\n                have h\u2086 : \u2200 j : \u2115, 1 \u2264 j \u2227 j \u2264 n \u2192 a j < b j := by\n                  intro j hj\n                  have h\u2087 : j \u2264 n := hj.2\n                  have h\u2088 : 1 \u2264 j := hj.1\n                  exact ih j h\u2088 h\u2087\n                -- Use def_1 to get the desired inequality\n                have h\u2087 : a (n + 1) < b (n + 1) := def_1 n hn'' h\u2086\n                exact h\u2087\n              by_cases hn'' : n \u2265 2\n              \u00b7 -- Subsubsubcase: n \u2265 2\n                exact h\u2085 hn''\n              \u00b7 -- Subsubsubcase: n < 2\n                have hn''' : n = 1 := by\n                  omega\n                simp_all\n                <;> norm_num at *\n                <;> linarith\n            exact h\u2084\n  have h_final : \u2200 (n : \u2115), n \u2265 1 \u2192 a n < b n := by\n    intro n hn\n    have h\u2081 : \u2200 (m : \u2115), 1 \u2264 m \u2192 m \u2264 n \u2192 a m < b m := h_main n\n    have h\u2082 : a n < b n := h\u2081 n (by omega) (by omega)\n    exact h\u2082\n  \n  exact h_final", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Sequence definitions for both a_n and b_n are correctly formalized with proper initial values and recurrence relations", "Base cases l1 and l2 correctly capture a\u2081 < b\u2081 and a\u2082 < b\u2082", "The inductive step logic is preserved, though with redundant hypotheses (def_1, l3, l4, l7 all express the same relationship)", "Intermediate steps l5 and l6 are mathematically sound derivations that support the main inductive argument", "The conclusion correctly formalizes the universal quantification over all n \u2265 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    