
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Prove that for all positive real numbers $x, y, z$ such that $xyz \geq xy + yz + zx$, the inequality $xyz \geq 3(x + y + z)$ holds.

Proof: Let $x, y, z$ be positive real numbers such that $xyz \ge xy + yz + zx$. Dividing both sides by $xyz$ and setting $a = 1/x, b = 1/y, c = 1/z$, the condition becomes $a+b+c \le 1$, and the inequality to prove, $xyz \ge 3(x+y+z)$, reduces to $1 \ge 3(ab+bc+ca)$. Observing that $(a-b)^2+(b-c)^2+(c-a)^2 \ge 0$ implies $a^2+b^2+c^2 \ge ab+bc+ca$, we expand $(a+b+c)^2 = a^2+b^2+c^2 + 2(ab+bc+ca) \ge 3(ab+bc+ca)$. Since $a+b+c \le 1$, squaring gives $(a+b+c)^2 \le 1$, and combining the inequalities yields $1 \ge (a+b+c)^2 \ge 3(ab+bc+ca)$. Substituting back $a=1/x, b=1/y, c=1/z$ and multiplying through by $xyz$ gives the desired result $xyz \ge 3(x+y+z)$, completing the proof.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $x, y, z$ be positive real numbers", "statement": "Premise:\n\u2022 x, y, z are positive real numbers [tc_1]", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x y z : \u211d)\n(tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly declares x, y, z as real numbers and specifies they are positive using the conjunction x > 0 \u2227 y > 0 \u2227 z > 0, which perfectly captures the natural language condition", "Both the natural language and Lean formalization contain no conclusions, which is consistent since this is just a premise statement"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "such that $xyz \\ge xy + yz + zx$.", "statement": "Premise:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2]", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x y z : \u211d)\n(tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n(tc_2 : x * y * z \u2265 x * y + y * z + z * x)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that x, y, z are real numbers (declared as \u211d) and positive (tc_1 states x > 0 \u2227 y > 0 \u2227 z > 0), which perfectly matches the natural language condition.", "The inequality xyz \u2265 xy + yz + zx is faithfully represented in Lean as x * y * z \u2265 x * y + y * z + z * x, with multiplication notation being the standard Lean representation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Dividing both sides by $xyz$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\nTherefore, we conclude:\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1]", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x) :\n  1 \u2265 1 / x + 1 / y + 1 / z := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x) :\n  1 \u2265 1 / x + 1 / y + 1 / z := by\n  have hx := tc_1.1\n  have hy := tc_1.2.1\n  have hz := tc_1.2.2\n  have := calc\n    (x * y + y * z + z * x) / (x * y * z) \u2264 x * y * z / (x * y * z) := by gcongr; exact tc_2\n    _ = 1 := by field_simp [mul_ne_zero hx.ne' (mul_ne_zero hy.ne' hz.ne')]\n  field_simp [hx.ne', hy.ne', hz.ne'] at this\n  rw [div_eq_mul_inv, div_eq_mul_inv, div_eq_mul_inv] at this\n  simp only [inv_mul_cancel hx.ne', inv_mul_cancel hy.ne', inv_mul_cancel hz.ne', one_mul] at this\n  exact this", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 14, "column": 82, "endLine": 14, "endColumn": 92, "data": "no goals to be solved"}, {"line": 17, "column": 22, "endLine": 17, "endColumn": 36, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a / ?b\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nhx : x > 0\nhy : y > 0\nhz : z > 0\nthis : (x * y + y * z + z * x) * (x * y * z)\u207b\u00b9 \u2264 1\n\u22a2 1 \u2265 1 / x + 1 / y + 1 / z"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized. The real number type \u211d and conjunction of positivity conditions x > 0 \u2227 y > 0 \u2227 z > 0 accurately capture the natural language specification.", "The mathematical constraint xyz \u2265 xy + yz + zx is precisely translated with explicit multiplication operators and correct inequality direction.", "The conclusion 1 \u2265 1/x + 1/y + 1/z is faithfully represented with proper division notation and maintains the exact mathematical relationship.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1 : \u00ac (\u2200 x y z : \u211d, x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 x * y * z \u2265 x * y + y * z + z * x \u2192 1 \u2265 1 / x + 1 / y + 1 / z) := by\n  intro h\n  let x : \u211d := 2\n  let y : \u211d := 2\n  let z : \u211d := 2\n  have tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0 := by norm_num\n  have tc_2 : x * y * z \u2265 x * y + y * z + z * x := by norm_num\n  have h' := h x y z tc_1 tc_2\n  norm_num at h'"}, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "setting $a = 1/x, b = 1/y, c = 1/z$", "statement": "Definition:\n\u2022 Let a, b, c be real numbers such that a = 1/x, b = 1/y, and c = 1/z [def_1]", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x y z : \u211d)\n(def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly declares x, y, z as real numbers, matching the natural language condition", "The existence of real numbers a, b, c is captured in the Lean formalization through the existential quantifier", "The natural language implies x \u2260 0, y \u2260 0, z \u2260 0 for reciprocals to exist, but Lean uses the stronger condition x > 0 \u2227 y > 0 \u2227 z > 0. This changes the mathematical meaning significantly", "The natural language presents a = 1/x as a direct definition/assignment, but Lean structures this as a conditional implication with existential quantification, fundamentally changing the logical structure", "The natural language presents b = 1/y as a direct definition/assignment, but Lean structures this as part of a conditional implication with existential quantification, fundamentally changing the logical structure", "The natural language presents c = 1/z as a direct definition/assignment, but Lean structures this as part of a conditional implication with existential quantification, fundamentally changing the logical structure"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly declares x, y, z as real numbers, matching the natural language condition', 'The existence of real numbers a, b, c is captured in the Lean formalization through the existential quantifier', 'The natural language implies x \u2260 0, y \u2260 0, z \u2260 0 for reciprocals to exist, but Lean uses the stronger condition x > 0 \u2227 y > 0 \u2227 z > 0. This changes the mathematical meaning significantly', 'The natural language presents a = 1/x as a direct definition/assignment, but Lean structures this as a conditional implication with existential quantification, fundamentally changing the logical structure', 'The natural language presents b = 1/y as a direct definition/assignment, but Lean structures this as part of a conditional implication with existential quantification, fundamentally changing the logical structure', 'The natural language presents c = 1/z as a direct definition/assignment, but Lean structures this as part of a conditional implication with existential quantification, fundamentally changing the logical structure']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "the condition becomes $a+b+c \\le 1$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\nTherefore, we conclude:\n\u2022 a+b+c \u2264 1 [l2]", "dependencies": ["tc_1", "tc_2", "l1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z)) :\n  (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z)) :\n  (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1) := by\n  let a := 1 / x\n  let b := 1 / y\n  let c := 1 / z\n  refine \u27e8a, b, c, rfl, rfl, rfl, ?_\u27e9\n  exact l1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly captured", "The inequality xyz \u2265 xy + yz + zx is perfectly translated with appropriate operator precedence", "The constraint 1 \u2265 1/x + 1/y + 1/z is correctly formalized", "The simple variable definitions a = 1/x, b = 1/y, c = 1/z are incorrectly formalized as an implication with existential quantification, fundamentally changing the logical structure", "The conclusion uses existential quantification instead of directly stating the inequality about the defined variables, creating a structural difference from the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations and positivity constraints are correctly captured', 'The inequality xyz \u2265 xy + yz + zx is perfectly translated with appropriate operator precedence', 'The constraint 1 \u2265 1/x + 1/y + 1/z is correctly formalized', 'The simple variable definitions a = 1/x, b = 1/y, c = 1/z are incorrectly formalized as an implication with existential quantification, fundamentally changing the logical structure', 'The conclusion uses existential quantification instead of directly stating the inequality about the defined variables, creating a structural difference from the natural language']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "the inequality to prove, $xyz \\ge 3(x+y+z)$, reduces to $1 \\ge 3(ab+bc+ca)$.", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\n\u2022 a+b+c \u2264 1 [l2];\nTherefore, we conclude:\n\u2022 The inequality xyz \u2265 3(x+y+z) is equivalent to 1 \u2265 3(ab+bc+ca) [l3]", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1)) :\n  (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1)) :\n  (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))) := by\n  constructor\n  \u00b7 intro h\n    have hx := tc_1.1\n    have hy := tc_1.2.1\n    have hz := tc_1.2.2\n    have hpos := mul_pos (mul_pos hx hy) hz\n    rw [\u2190 mul_le_mul_right hpos] at h\n    simp only [mul_one] at h\n    rw [mul_assoc, mul_assoc, mul_assoc, \u2190 mul_add, \u2190 mul_add] at h\n    simp only [mul_one_div_cancel hx.ne.symm, mul_one_div_cancel hy.ne.symm, mul_one_div_cancel hz.ne.symm] at h\n    exact h\n  \u00b7 intro h\n    have hx := tc_1.1\n    have hy := tc_1.2.1\n    have hz := tc_1.2.2\n    have hpos := mul_pos (mul_pos hx hy) hz\n    rw [\u2190 mul_le_mul_right hpos]\n    simp only [mul_one]\n    rw [mul_assoc, mul_assoc, mul_assoc, \u2190 mul_add, \u2190 mul_add]\n    simp only [mul_one_div_cancel hx.ne.symm, mul_one_div_cancel hy.ne.symm, mul_one_div_cancel hz.ne.symm]\n    exact h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 8, "endLine": 19, "endColumn": 31, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.2651 \u2264 ?m.2652\ncase mp\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nl1 : 1 \u2265 1 / x + 1 / y + 1 / z\ndef_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z\nl2 : \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1\nh : x * y * z \u2265 3 * (x + y + z)\nhx : x > 0\nhy : y > 0\nhz : z > 0\nhpos : 0 < x * y * z\n\u22a2 1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))"}, {"line": 29, "column": 8, "endLine": 29, "endColumn": 31, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.4282 \u2264 ?m.4283\ncase mpr\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nl1 : 1 \u2265 1 / x + 1 / y + 1 / z\ndef_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z\nl2 : \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1\nh : 1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))\nhx : x > 0\nhy : y > 0\nhz : z > 0\nhpos : 0 < x * y * z\n\u22a2 x * y * z \u2265 3 * (x + y + z)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable types and positivity constraints are correctly formalized", "The inequality constraint tc_2 is accurately represented", "The inequality constraint l1 matches exactly", "The variable definitions are semantically correct but use existential quantification instead of direct definitions, making the formalization more complex than the natural language suggests", "The constraint l2 is correct but again uses existential quantification rather than treating it as a direct consequence of the substitution", "The main equivalence statement correctly captures the mathematical relationship, properly translating the products of reciprocals", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.67 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3 :\n  \u2203 (x y z : \u211d), x > 0 \u2227 y > 0 \u2227 z > 0 \u2227\n  x * y * z \u2265 x * y + y * z + z * x \u2227\n  1 \u2265 1 / x + 1 / y + 1 / z \u2227\n  (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1) \u2227\n  \u00ac((x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)))) := by\n  refine \u27e81, 1, 2, ?_\u27e9\n  simp\n  refine \u27e8by norm_num, by norm_num, ?_\u27e9\n  refine \u27e8by norm_num, ?_\u27e9\n  refine \u27e8by norm_num, ?_\u27e9\n  refine \u27e8\u27e81, 1, 1/2, by simp, by simp, by simp, by norm_num\u27e9, ?_\u27e9\n  simp\n  norm_num"}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Observing that $(a-b)^2+(b-c)^2+(c-a)^2 \\ge 0$ implies $a^2+b^2+c^2 \\ge ab+bc+ca$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\n\u2022 a+b+c \u2264 1 [l2];\n\u2022 The inequality xyz \u2265 3(x+y+z) is equivalent to 1 \u2265 3(ab+bc+ca) [l3];\nTherefore, we conclude:\n\u2022 a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca [l4]", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)))) :\n  \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)))) :\n  \u2200 a b c : \u211d, a = 1 / x \u2192 b = 1 / y \u2192 c = 1 / z \u2192 a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a := by\n  intro a b c ha hb hc\n  have habc : a + b + c \u2264 1 := by\n    obtain \u27e8a', b', c', ha', hb', hc', hsum\u27e9 := l2\n    rw [ha, hb, hc] at ha' hb' hc'\n    cases ha'; cases hb'; cases hc'\n    exact hsum\n  have hsq : (a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a) := by ring\n  have h3 : 1 \u2265 3*(a*b + b*c + c*a) := by\n    rw [\u2190 l3]\n    exact tc_2\n  have hineq : (a + b + c)^2 \u2265 3*(a*b + b*c + c*a) := by\n    calc\n      (a + b + c)^2 \u2265 (a + b + c) * (3*(a*b + b*c + c*a)) := by\n        rw [ha, hb, hc] at tc_2\n        field_simp at tc_2\n        exact habc.trans h3\n      _ \u2265 3*(a*b + b*c + c*a) := by nlinarith\n  rw [hsq] at hineq\n  linarith", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 8, "endLine": 17, "endColumn": 10, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  a\ncase intro.intro.intro.intro.intro.intro\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nl1 : 1 \u2265 1 / x + 1 / y + 1 / z\ndef_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z\nl3 : x * y * z \u2265 3 * (x + y + z) \u2194 1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))\na b c : \u211d\nha : a = 1 / x\nhb : b = 1 / y\nhc : c = 1 / z\na' b' c' : \u211d\nha' : a' = 1 / x\nhb' : b' = 1 / y\nhc' : c' = 1 / z\nhsum : a' + b' + c' \u2264 1\n\u22a2 a + b + c \u2264 1"}, {"line": 22, "column": 8, "endLine": 22, "endColumn": 12, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nl1 : 1 \u2265 1 / x + 1 / y + 1 / z\ndef_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z\nl2 : \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1\nl3 : x * y * z \u2265 3 * (x + y + z) \u2194 1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))\na b c : \u211d\nha : a = 1 / x\nhb : b = 1 / y\nhc : c = 1 / z\nhabc : a + b + c \u2264 1\nhsq : (a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + b * c + c * a)\n\u22a2 1 \u2265 3 * (a * b + b * c + c * a)"}, {"line": 27, "column": 12, "endLine": 27, "endColumn": 14, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  a\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nl1 : 1 \u2265 1 / x + 1 / y + 1 / z\ndef_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z\nl2 : \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1\nl3 : x * y * z \u2265 3 * (x + y + z) \u2194 1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))\na b c : \u211d\nha : a = 1 / x\nhb : b = 1 / y\nhc : c = 1 / z\nhabc : a + b + c \u2264 1\nhsq : (a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + b * c + c * a)\nh3 : 1 \u2265 3 * (a * b + b * c + c * a)\n\u22a2 (a + b + c) ^ 2 \u2265 (a + b + c) * (3 * (a * b + b * c + c * a))"}, {"line": 30, "column": 36, "endLine": 30, "endColumn": 45, "data": "linarith failed to find a contradiction\ncase a\nx y z : \u211d\ntc_1 : x > 0 \u2227 y > 0 \u2227 z > 0\ntc_2 : x * y * z \u2265 x * y + y * z + z * x\nl1 : 1 \u2265 1 / x + 1 / y + 1 / z\ndef_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z\nl2 : \u2203 a b c, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1\nl3 : x * y * z \u2265 3 * (x + y + z) \u2194 1 \u2265 3 * (1 / x * (1 / y) + 1 / y * (1 / z) + 1 / z * (1 / x))\na b c : \u211d\nha : a = 1 / x\nhb : b = 1 / y\nhc : c = 1 / z\nhabc : a + b + c \u2264 1\nhsq : (a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2 * (a * b + b * c + c * a)\nh3 : 1 \u2265 3 * (a * b + b * c + c * a)\na\u271d : 3 * (a * b + b * c + c * a) > (a + b + c) * (3 * (a * b + b * c + c * a))\n\u22a2 False failed"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations and positivity constraints are correctly formalized.", "The first inequality constraint xyz \u2265 xy + yz + zx is correctly captured.", "The constraint 1 \u2265 1/x + 1/y + 1/z is correctly formalized.", "The variable definitions should be direct assignments (a = 1/x, etc.) rather than existential statements within an implication. The current formalization doesn't establish usable variables.", "The constraint a+b+c \u2264 1 should be a direct statement about the defined variables, not an existential quantification that doesn't connect to the conclusion.", "The equivalence statement is correctly formalized, though it uses 1/x, 1/y, 1/z directly instead of the defined variables a, b, c.", "The conclusion should be about the specific variables a, b, c defined as reciprocals of x, y, z, not a universal statement about arbitrary real numbers. This completely breaks the logical connection to the premises.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Variable declarations and positivity constraints are correctly formalized.', 'The first inequality constraint xyz \u2265 xy + yz + zx is correctly captured.', 'The constraint 1 \u2265 1/x + 1/y + 1/z is correctly formalized.', \"The variable definitions should be direct assignments (a = 1/x, etc.) rather than existential statements within an implication. The current formalization doesn't establish usable variables.\", \"The constraint a+b+c \u2264 1 should be a direct statement about the defined variables, not an existential quantification that doesn't connect to the conclusion.\", 'The equivalence statement is correctly formalized, though it uses 1/x, 1/y, 1/z directly instead of the defined variables a, b, c.', 'The conclusion should be about the specific variables a, b, c defined as reciprocals of x, y, z, not a universal statement about arbitrary real numbers. This completely breaks the logical connection to the premises.']"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "we expand $(a+b+c)^2 = a^2+b^2+c^2 + 2(ab+bc+ca) \\ge 3(ab+bc+ca)$.", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\n\u2022 a+b+c \u2264 1 [l2];\n\u2022 The inequality xyz \u2265 3(x+y+z) is equivalent to 1 \u2265 3(ab+bc+ca) [l3];\n\u2022 a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca [l4];\nTherefore, we conclude:\n\u2022 (a+b+c)\u00b2 \u2265 3(ab+bc+ca) [l5]", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)))) :\n  \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)))) :\n  \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a) := by\n  intro a b c\n  have h : (a + b + c)^2 = a^2 + b^2 + c^2 + 2*(a*b + b*c + c*a) := by ring\n  rw [h]\n  have h\u2081 : a^2 + b^2 + c^2 \u2265 a*b + b*c + c*a := by\n    calc\n      a^2 + b^2 + c^2 = (a^2 + b^2)/2 + (b^2 + c^2)/2 + (a^2 + c^2)/2 := by ring\n      _ \u2265 a*b + b*c + c*a := by\n        apply _root_.add_le_add\n        apply _root_.add_le_add\n        \u00b7 have : (a - b)^2 \u2265 0 := sq_nonneg (a - b)\n          linarith\n        \u00b7 have : (b - c)^2 \u2265 0 := sq_nonneg (b - c)\n          linarith\n        \u00b7 have : (a - c)^2 \u2265 0 := sq_nonneg (a - c)\n          linarith\n  linarith", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1 correctly captures that x, y, z are positive real numbers", "tc_2 correctly captures the inequality xyz \u2265 xy + yz + zx", "l1 correctly captures the constraint 1 \u2265 1/x + 1/y + 1/z", "def_1 uses existential quantification under a conditional instead of direct variable definitions. The natural language defines specific variables a, b, c, but Lean treats them as existentially quantified.", "l2 uses existential quantification instead of referring to the previously defined variables a, b, c from def_1", "l3 correctly captures the equivalence but uses explicit fractions (1/x)(1/y) instead of the defined variables ab, bc, ca", "l4 (a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca) is completely missing from the Lean formalization", "The conclusion l5 uses universal quantification over arbitrary variables a, b, c instead of the specific variables defined earlier. This changes the logical structure significantly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1 correctly captures that x, y, z are positive real numbers', 'tc_2 correctly captures the inequality xyz \u2265 xy + yz + zx', 'l1 correctly captures the constraint 1 \u2265 1/x + 1/y + 1/z', 'def_1 uses existential quantification under a conditional instead of direct variable definitions. The natural language defines specific variables a, b, c, but Lean treats them as existentially quantified.', 'l2 uses existential quantification instead of referring to the previously defined variables a, b, c from def_1', 'l3 correctly captures the equivalence but uses explicit fractions (1/x)(1/y) instead of the defined variables ab, bc, ca', 'l4 (a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca) is completely missing from the Lean formalization', 'The conclusion l5 uses universal quantification over arbitrary variables a, b, c instead of the specific variables defined earlier. This changes the logical structure significantly.']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "Since $a+b+c \\le 1$, squaring gives $(a+b+c)^2 \\le 1$", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\n\u2022 a+b+c \u2264 1 [l2];\n\u2022 The inequality xyz \u2265 3(x+y+z) is equivalent to 1 \u2265 3(ab+bc+ca) [l3];\n\u2022 a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca [l4];\n\u2022 (a+b+c)\u00b2 \u2265 3(ab+bc+ca) [l5];\nTherefore, we conclude:\n\u2022 (a+b+c)\u00b2 \u2264 1 [l6]", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))))\n  (l4 : \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a)\n  (l5 : \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a)) :\n  (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 (a + b + c)^2 \u2264 1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))))\n  (l4 : \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a)\n  (l5 : \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a)) :\n  (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 (a + b + c)^2 \u2264 1) := by\n  obtain \u27e8a, b, c, ha, hb, hc, habc\u27e9 := l2\n  refine \u27e8a, b, c, ha, hb, hc, ?_\u27e9\n  have hpos : a + b + c \u2265 0 := by\n    rw [ha, hb, hc]\n    simp [div_pos, tc_1.1, tc_1.2.1, tc_1.2.2]\n    positivity\n  have h := habc\n  calc\n    (a + b + c)^2 \u2264 (1:\u211d)^2 := by apply pow_le_pow_left hpos h\n    _ = 1 := by simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 4, "endLine": 21, "endColumn": 14, "data": "failed to prove positivity/nonnegativity/nonzeroness"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["tc_1: Correctly captures that x, y, z are positive real numbers", "tc_2: Correctly captures the inequality xyz \u2265 xy + yz + zx", "l1: Correctly captures the inequality 1 \u2265 1/x + 1/y + 1/z", "def_1: The natural language presents simple definitions a = 1/x, b = 1/y, c = 1/z, but Lean makes this a conditional existential statement, fundamentally changing the logical structure", "l2: The natural language treats a+b+c \u2264 1 as a direct consequence, but Lean makes it an independent existential assumption, missing the logical connection to l1 and def_1", "l3: Correctly captures the equivalence between the two inequality forms", "l4: Correctly captures the general inequality a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca for all real a,b,c", "l5: Correctly captures the general inequality (a+b+c)\u00b2 \u2265 3(ab+bc+ca) for all real a,b,c", "l6: The conclusion is structurally consistent with the existential pattern used in the premises, though it differs slightly from the natural language presentation", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1: Correctly captures that x, y, z are positive real numbers', 'tc_2: Correctly captures the inequality xyz \u2265 xy + yz + zx', 'l1: Correctly captures the inequality 1 \u2265 1/x + 1/y + 1/z', 'def_1: The natural language presents simple definitions a = 1/x, b = 1/y, c = 1/z, but Lean makes this a conditional existential statement, fundamentally changing the logical structure', 'l2: The natural language treats a+b+c \u2264 1 as a direct consequence, but Lean makes it an independent existential assumption, missing the logical connection to l1 and def_1', 'l3: Correctly captures the equivalence between the two inequality forms', 'l4: Correctly captures the general inequality a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca for all real a,b,c', 'l5: Correctly captures the general inequality (a+b+c)\u00b2 \u2265 3(ab+bc+ca) for all real a,b,c', 'l6: The conclusion is structurally consistent with the existential pattern used in the premises, though it differs slightly from the natural language presentation']"}, "solved_negation": null, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "combining the inequalities yields $1 \\ge (a+b+c)^2 \\ge 3(ab+bc+ca)$.", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\n\u2022 a+b+c \u2264 1 [l2];\n\u2022 The inequality xyz \u2265 3(x+y+z) is equivalent to 1 \u2265 3(ab+bc+ca) [l3];\n\u2022 a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca [l4];\n\u2022 (a+b+c)\u00b2 \u2265 3(ab+bc+ca) [l5];\n\u2022 (a+b+c)\u00b2 \u2264 1 [l6];\nTherefore, we conclude:\n\u2022 1 \u2265 3(ab+bc+ca) [l7]", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))))\n  (l4 : \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a)\n  (l5 : \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a))\n  (l6 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 (a + b + c)^2 \u2264 1)) :\n  1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))))\n  (l4 : \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a)\n  (l5 : \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a))\n  (l6 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 (a + b + c)^2 \u2264 1)) :\n  1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x)) := by\n  obtain \u27e8a, b, c, ha, hb, hc, hsum\u27e9 := l2\n  obtain \u27e8a', b', c', ha', hb', hc', hsum'\u27e9 := l6\n  have h1 : a = a' := by rw [ha, ha']\n  have h2 : b = b' := by rw [hb, hb']\n  have h3 : c = c' := by rw [hc, hc']\n  subst h1; subst h2; subst h3\n  have h := l5 a b c\n  have h' := hsum'\n  have h'' : (a + b + c)^2 \u2264 1 := by linarith\n  have h''' : 3 * (a * b + b * c + c * a) \u2264 1 := by linarith\n  rw [ha, hb, hc] at h'''\n  exact h'''", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1 correctly captures that x, y, z are positive real numbers", "tc_2 correctly formalizes the constraint xyz \u2265 xy + yz + zx", "l1 correctly states the inequality 1 \u2265 1/x + 1/y + 1/z", "def_1 should define specific variables a, b, c, but instead uses existential quantification with a conditional, changing the logical structure", "l2 should reference the defined variables a, b, c from def_1, but uses existential quantification instead", "l3 correctly captures the equivalence between the two inequalities", "l4 should refer to the specific variables a, b, c, but uses universal quantification over all reals instead", "l5 has the same issue as l4 - uses universal quantification instead of referring to specific variables", "l6 should reference the defined variables but again uses existential quantification", "l7 correctly states the conclusion to be proved"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1 correctly captures that x, y, z are positive real numbers', 'tc_2 correctly formalizes the constraint xyz \u2265 xy + yz + zx', 'l1 correctly states the inequality 1 \u2265 1/x + 1/y + 1/z', 'def_1 should define specific variables a, b, c, but instead uses existential quantification with a conditional, changing the logical structure', 'l2 should reference the defined variables a, b, c from def_1, but uses existential quantification instead', 'l3 correctly captures the equivalence between the two inequalities', 'l4 should refer to the specific variables a, b, c, but uses universal quantification over all reals instead', 'l5 has the same issue as l4 - uses universal quantification instead of referring to specific variables', 'l6 should reference the defined variables but again uses existential quantification', 'l7 correctly states the conclusion to be proved']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Substituting back $a=1/x, b=1/y, c=1/z$ and multiplying through by $xyz$ gives the desired result $xyz \\ge 3(x+y+z)$, completing the proof.", "statement": "We assume:\n\u2022 x, y, z are positive real numbers [tc_1];\n\u2022 xyz \u2265 xy + yz + zx [tc_2];\n\u2022 1 \u2265 1/x + 1/y + 1/z [l1];\n\u2022 a = 1/x, b = 1/y, c = 1/z [def_1];\n\u2022 a+b+c \u2264 1 [l2];\n\u2022 The inequality xyz \u2265 3(x+y+z) is equivalent to 1 \u2265 3(ab+bc+ca) [l3];\n\u2022 a\u00b2+b\u00b2+c\u00b2 \u2265 ab+bc+ca [l4];\n\u2022 (a+b+c)\u00b2 \u2265 3(ab+bc+ca) [l5];\n\u2022 (a+b+c)\u00b2 \u2264 1 [l6];\n\u2022 1 \u2265 3(ab+bc+ca) [l7];\nTherefore, we conclude:\n\u2022 xyz \u2265 3(x+y+z) [ts_1]", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))))\n  (l4 : \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a)\n  (l5 : \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a))\n  (l6 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 (a + b + c)^2 \u2264 1))\n  (l7 : 1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))) :\n  x * y * z \u2265 3 * (x + y + z) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (x y z : \u211d)\n  (tc_1 : x > 0 \u2227 y > 0 \u2227 z > 0)\n  (tc_2 : x * y * z \u2265 x * y + y * z + z * x)\n  (l1 : 1 \u2265 1 / x + 1 / y + 1 / z)\n  (def_1 : x > 0 \u2227 y > 0 \u2227 z > 0 \u2192 (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z))\n  (l2 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 a + b + c \u2264 1))\n  (l3 : (x * y * z \u2265 3 * (x + y + z)) \u2194 (1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))))\n  (l4 : \u2200 a b c : \u211d, a^2 + b^2 + c^2 \u2265 a * b + b * c + c * a)\n  (l5 : \u2200 a b c : \u211d, (a + b + c)^2 \u2265 3 * (a * b + b * c + c * a))\n  (l6 : (\u2203 a b c : \u211d, a = 1 / x \u2227 b = 1 / y \u2227 c = 1 / z \u2227 (a + b + c)^2 \u2264 1))\n  (l7 : 1 \u2265 3 * ((1 / x) * (1 / y) + (1 / y) * (1 / z) + (1 / z) * (1 / x))) :\n  x * y * z \u2265 3 * (x + y + z) := by\n  rw [l3]\n  exact l7", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.9, "semantic_feedback": ["tc_1: Direct correspondence between positive real numbers condition", "tc_2: Exact translation of the inequality xyz \u2265 xy + yz + zx", "l1: Perfect match of the constraint 1 \u2265 1/x + 1/y + 1/z", "def_1: Natural language gives simple definitions, Lean uses conditional existence. Structurally different but semantically equivalent", "l2: Lean includes variable definitions within existential quantification, which is logically consistent", "l3: Perfect equivalence statement with explicit variable substitutions", "l4: Lean uses universal quantification over all reals, which is stronger but consistent with the mathematical meaning", "l5: Same as l4, universal quantification maintains the mathematical relationship", "l6: Existential quantification with embedded definitions captures the intended constraint", "l7: Exact correspondence with explicit substitution of variables", "ts_1: Perfect match of the conclusion xyz \u2265 3(x+y+z)"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    