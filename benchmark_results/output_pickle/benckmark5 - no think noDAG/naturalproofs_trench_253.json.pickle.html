
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}_1$ and $\mathbf{X}_2$ are in $S_r(\mathbf{X}_0)$ for some $r>0$,
then so is every point on
the line segment from $\mathbf{X}_1$ to $\mathbf{X}_2.$

Proof: The line segment is given by
$$
\mathbf{X}=t\mathbf{X}_2+(1-t)\mathbf{X}_1,\quad 0<t<1.
$$
Suppose that $r>0$. If
$$
|\mathbf{X}_1-\mathbf{X}_0|<r,\quad |\mathbf{X}_2-\mathbf{X}_0|<r,
$$
and $0<t<1$, then
\begin{eqnarray*}
|\mathbf{X}-\mathbf{X}_0|\ar=|t\mathbf{X}_2+(1-t)\mathbf{X}_1-t\mathbf{X}_0-(1-t)\mathbf{X}_0|\\
\ar=|t(\mathbf{X}_2-\mathbf{X}_0)+(1-t)\mathbf{X}_1-\mathbf{X}_0)|\\
\ar\le  t|\mathbf{X}_2-\mathbf{X}_0|+(1-t)|\mathbf{X}_1-\mathbf{X}_0|\\
\ar< tr+(1-t)r=r.
\end{eqnarray*}
\vskip-2em
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X}_1$ and $\\mathbf{X}_2$ are in $S_r(\\mathbf{X}_0)$", "statement": "Premise:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 : V)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the mathematical meaning of points in a real normed vector space. The type V with NormedAddCommGroup and NormedSpace \u211d instances properly represents a real normed vector space, and X0, X1, X2 as elements of V represent the points. The only difference is in variable naming convention (X0 vs \ud835\udc17\u2080), which is a minor notational difference that doesn't affect the mathematical content."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the mathematical meaning of points in a real normed vector space. The type V with NormedAddCommGroup and NormedSpace \u211d instances properly represents a real normed vector space, and X0, X1, X2 as elements of V represent the points. The only difference is in variable naming convention (X0 vs \ud835\udc17\u2080), which is a minor notational difference that doesn't affect the mathematical content.\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "for some $r>0$", "statement": "Premise:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 : V)\n(tc_2 : r > 0)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that X0, X1, X2 are points in a real normed vector space V. The type classes [NormedAddCommGroup V] and [NormedSpace \u211d V] properly establish V as a real normed vector space, and (X0 X1 X2 : V) declares the three points as elements of V. The variable names differ slightly (X0 vs \ud835\udc17\u2080) but this is just notational.", "The Lean formalization (tc_2 : r > 0) perfectly matches the mathematical condition r > 0. The label tc_2 is just an identifier and doesn't affect the logical content."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "If $\\mathbf{X}_1$ and $\\mathbf{X}_2$ are in $S_r(\\mathbf{X}_0)$", "statement": "Premise:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].\n\u2022 $\\mathbf{X}_1 \\in S_r(\\mathbf{X}_0)$ and $\\mathbf{X}_2 \\in S_r(\\mathbf{X}_0)$, where $S_r(\\mathbf{X}_0)$ is the open ball defined as $\\{\\mathbf{Y} \\in V : |\\mathbf{Y} - \\mathbf{X}_0| < r\\}$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 : V)\n(r : \u211d)\n(tc_2 : r > 0)\n(tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures points in a real normed vector space with appropriate type classes", "Both express r > 0 with r being a real number", "Metric.ball X0 r in Lean is equivalent to the open ball definition {Y \u2208 V : |Y - X0| < r}", "Metric.ball X0 r in Lean is equivalent to the open ball definition {Y \u2208 V : |Y - X0| < r}", "The conclusion |X1 - X0| < r follows directly from X1 \u2208 Metric.ball X0 r, which is mathematically equivalent", "The conclusion |X2 - X0| < r follows directly from X2 \u2208 Metric.ball X0 r, which is mathematically equivalent"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "The line segment is given by\n$$\n\\mathbf{X}=t\\mathbf{X}_2+(1-t)\\mathbf{X}_1,\\quad 0<t<1.\n$$", "statement": "Definition:\n\u2022 Let $\\mathbf{X}$ be an arbitrary point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some $t$ such that $0<t<1$ [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 : V)\n(r : \u211d)\n(tc_2 : r > 0)\n(tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n(def_1 : \u2200 (t : \u211d), 0 < t \u2227 t < 1 \u2192 (\u2203 X : V, X = t \u2022 X2 + (1 - t) \u2022 X1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language describes X as an arbitrary point on the line segment, but the Lean formalization introduces additional constraints about metric balls that are not mentioned in the natural language. The conditions tc_2 and tc_3 about X1 and X2 being in a metric ball around X0 are completely absent from the natural language statement.", "The condition 0 < t < 1 is correctly captured in the Lean formalization as '0 < t \u2227 t < 1'.", "The conclusion about the formula X = tX\u2082 + (1-t)X\u2081 is captured in Lean, but the structure is different. The natural language presents this as a direct definition, while Lean expresses it as a universal quantification with existential statement. The mathematical content is equivalent (using scalar multiplication \u2022 instead of regular multiplication), but the logical structure differs."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language describes X as an arbitrary point on the line segment, but the Lean formalization introduces additional constraints about metric balls that are not mentioned in the natural language. The conditions tc_2 and tc_3 about X1 and X2 being in a metric ball around X0 are completely absent from the natural language statement.', \"The condition 0 < t < 1 is correctly captured in the Lean formalization as '0 < t \u2227 t < 1'.\", 'The conclusion about the formula X = tX\u2082 + (1-t)X\u2081 is captured in Lean, but the structure is different. The natural language presents this as a direct definition, while Lean expresses it as a universal quantification with existential statement. The mathematical content is equivalent (using scalar multiplication \u2022 instead of regular multiplication), but the logical structure differs.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If\n$$\n|\\mathbf{X}_1-\\mathbf{X}_0|<r,\\quad |\\mathbf{X}_2-\\mathbf{X}_0|<r,\n$$", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].\n\u2022 $\\mathbf{X}_1 \\in S_r(\\mathbf{X}_0)$ and $\\mathbf{X}_2 \\in S_r(\\mathbf{X}_0)$, where $S_r(\\mathbf{X}_0)$ is the open ball defined as $\\{\\mathbf{Y} \\in V : |\\mathbf{Y} - \\mathbf{X}_0| < r\\}$ [tc_3].\n\u2022 Let $\\mathbf{X}$ be an arbitrary point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some $t$ such that $0<t<1$ [def_1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}_1-\\mathbf{X}_0|<r$ and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 : V) (r : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : \u2200 (t : \u211d), 0 < t \u2227 t < 1 \u2192 (\u2203 X : V, X = t \u2022 X2 + (1 - t) \u2022 X1)) :\n  \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 : V) (r : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : \u2200 (t : \u211d), 0 < t \u2227 t < 1 \u2192 (\u2203 X : V, X = t \u2022 X2 + (1 - t) \u2022 X1)) :\n  \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r := by\n  simp only [Metric.mem_ball, dist_eq_norm] at tc_3\n  exact tc_3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The type declarations correctly capture the normed vector space structure with appropriate Lean typeclasses.", "tc_1 is formalized as True which is vacuous, though this doesn't affect the logical meaning significantly.", "The open ball membership conditions are correctly translated using Metric.ball which matches the mathematical definition.", "def_1 has a major logical inconsistency - it uses universal quantification over t with existential quantification over X, rather than describing a specific point X for a given t as in the natural language.", "The conclusion correctly translates the norm inequalities using Lean's norm notation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The type declarations correctly capture the normed vector space structure with appropriate Lean typeclasses.', \"tc_1 is formalized as True which is vacuous, though this doesn't affect the logical meaning significantly.\", 'The open ball membership conditions are correctly translated using Metric.ball which matches the mathematical definition.', 'def_1 has a major logical inconsistency - it uses universal quantification over t with existential quantification over X, rather than describing a specific point X for a given t as in the natural language.', \"The conclusion correctly translates the norm inequalities using Lean's norm notation.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "|\\mathbf{X}-\\mathbf{X}_0|\\ar=|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|\\n\\ar=|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].\n\u2022 $\\mathbf{X}_1 \\in S_r(\\mathbf{X}_0)$ and $\\mathbf{X}_2 \\in S_r(\\mathbf{X}_0)$, where $S_r(\\mathbf{X}_0)$ is the open ball defined as $\\{\\mathbf{Y} \\in V : |\\mathbf{Y} - \\mathbf{X}_0| < r\\}$ [tc_3].\n\u2022 Let $\\mathbf{X}$ be an arbitrary point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}_1-\\mathbf{X}_0|<r$ and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [l1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r) :\n  \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r) :\n  \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 := by\n  rw [def_1]\n  simp only [sub_add_sub_cancel, smul_sub]\n  rw [\u2190 add_sub_right_comm, smul_sub, smul_sub]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 28, "endLine": 15, "endColumn": 36, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?r \u2022 (?x - ?y)\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\n\u22a2 \u2016t \u2022 X2 + (1 - t) \u2022 X1 - X0\u2016 = \u2016t \u2022 X2 + ((1 - t) \u2022 X1 - (1 - t) \u2022 X0) - t \u2022 X0\u2016"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type declarations correctly capture the mathematical structure of a real normed vector space with appropriate points.", "The condition r > 0 is exactly preserved in both versions.", "The membership conditions for the open ball are correctly formalized using Metric.ball, which represents the same mathematical concept as the open ball notation.", "The definition of X as a convex combination is mathematically correct, but the Lean version omits the constraint 0 < t < 1 mentioned in the natural language. However, this constraint is not used in the conclusion being proved, so this is a minor structural difference.", "The distance conditions are perfectly captured using the norm notation \u2016\u00b7\u2016 which corresponds to the absolute value notation |\u00b7| for norms.", "The conclusion correctly formalizes the algebraic manipulation of the norm expression, with scalar multiplication properly represented using the \u2022 operator.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.83 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2_neg\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r) :\n  \u00ac(\u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016) := by\n  intro h\n  rw [def_1] at h\n  simp only [sub_add_sub_cancel, smul_sub] at h\n  have : \u2016X - X0\u2016 < r := by\n    rw [def_1]\n    calc \u2016t \u2022 X2 + (1 - t) \u2022 X1 - X0\u2016\n      _ = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 := by simp [smul_sub, sub_add_sub_cancel]\n      _ \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 := norm_add_le _ _\n      _ < t * r + (1 - t) * r := by gcongr; exact l1.2; exact l1.1\n      _ = r := by ring\n  have : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 := by\n    rw [def_1]\n    simp [smul_sub, sub_add_sub_cancel]\n  contradiction"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "\\ar\\le  t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].\n\u2022 $\\mathbf{X}_1 \\in S_r(\\mathbf{X}_0)$ and $\\mathbf{X}_2 \\in S_r(\\mathbf{X}_0)$, where $S_r(\\mathbf{X}_0)$ is the open ball defined as $\\{\\mathbf{Y} \\in V : |\\mathbf{Y} - \\mathbf{X}_0| < r\\}$ [tc_3].\n\u2022 Let $\\mathbf{X}$ be an arbitrary point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}_1-\\mathbf{X}_0|<r$ and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [l1].\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l2].\nTherefore, we conclude:\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016) :\n  \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016) :\n  \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 := by\n  have h1 : \u2016t \u2022 (X2 - X0)\u2016 = t * \u2016X2 - X0\u2016 := by\n    rw [norm_smul, Real.norm_eq_abs]\n    simp [abs_of_pos (by linarith [l1.2, tc_2])]\n  have h2 : \u2016(1 - t) \u2022 (X1 - X0)\u2016 = (1 - t) * \u2016X1 - X0\u2016 := by\n    rw [norm_smul, Real.norm_eq_abs]\n    simp [abs_of_pos (by linarith [l1.1, tc_2])]\n  rw [\u2190h1, \u2190h2]\n  exact norm_add_le (t \u2022 (X2 - X0)) ((1 - t) \u2022 (X1 - X0))", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 25, "endLine": 16, "endColumn": 46, "data": "linarith failed to find a contradiction\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\n\u22a2 False failed"}, {"line": 14, "column": 47, "endLine": 16, "endColumn": 48, "data": "unsolved goals\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\n\u22a2 0 \u2264 t \u2228 X2 - X0 = 0"}, {"line": 19, "column": 25, "endLine": 19, "endColumn": 46, "data": "linarith failed to find a contradiction\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nh1 : \u2016t \u2022 (X2 - X0)\u2016 = t * \u2016X2 - X0\u2016\n\u22a2 False failed"}, {"line": 17, "column": 59, "endLine": 19, "endColumn": 48, "data": "unsolved goals\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nh1 : \u2016t \u2022 (X2 - X0)\u2016 = t * \u2016X2 - X0\u2016\n\u22a2 t \u2264 1 \u2228 X1 - X0 = 0"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type declarations match perfectly. Natural language specifies 'real normed vector space V' and Lean uses '[NormedAddCommGroup V] [NormedSpace \u211d V]' which is the standard way to represent real normed vector spaces in Lean.", "The condition r > 0 is identical in both versions.", "The open ball membership conditions are correctly formalized. Natural language states X\u2081, X\u2082 \u2208 S\u1d63(X\u2080) and Lean uses 'Metric.ball X0 r' which is the standard representation of open balls in Lean.", "The line segment definition matches perfectly. Natural language defines X = tX\u2082 + (1-t)X\u2081 and Lean uses 'X = t \u2022 X2 + (1 - t) \u2022 X1' where '\u2022' is scalar multiplication notation.", "The norm inequalities are identical in meaning. Natural language uses |\u00b7| notation while Lean uses \u2016\u00b7\u2016 notation, both representing the norm in their respective contexts.", "The algebraic manipulation is correctly captured. Both versions show the same vector arithmetic expression for the norm.", "The triangle inequality conclusion is perfectly formalized. The natural language inequality using |\u00b7| corresponds exactly to the Lean version using \u2016\u00b7\u2016, with scalar multiplication properly represented using '\u2022' and '*' operators.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3_negation\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016) :\n  \u00ac (\u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016) := by\n  rw [\u2190 l2, def_1]\n  simp only [sub_add_sub_cancel]\n  exact fun h \u21a6 lt_irrefl _ (lt_of_le_of_lt h (add_lt_add_of_lt_of_le (by linarith [l1.1]) (by linarith [l1.2])))"}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "\\ar< tr+(1-t)r=r.", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].\n\u2022 $\\mathbf{X}_1 \\in S_r(\\mathbf{X}_0)$ and $\\mathbf{X}_2 \\in S_r(\\mathbf{X}_0)$, where $S_r(\\mathbf{X}_0)$ is the open ball defined as $\\{\\mathbf{Y} \\in V : |\\mathbf{Y} - \\mathbf{X}_0| < r\\}$ [tc_3].\n\u2022 Let $\\mathbf{X}$ be an arbitrary point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}_1-\\mathbf{X}_0|<r$ and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [l1].\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l2].\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l3].\nTherefore, we conclude:\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < r$ [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016)\n  (l3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016) :\n  t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016)\n  (l3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016) :\n  t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r := by\n  have h1 : \u2016X1 - X0\u2016 < r := l1.1\n  have h2 : \u2016X2 - X0\u2016 < r := l1.2\n  have ht : 0 \u2264 t \u2227 t \u2264 1 := by\n    have : X \u2208 Metric.ball X0 r := by\n      rw [def_1, Metric.mem_ball]\n      rw [\u2190 l2]\n      apply lt_of_le_of_lt l3\n      calc t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\n        _ < t * r + (1 - t) * r := by gcongr\n        _ = r := by ring\n    exact \u27e8by linarith, by linarith\u27e9\n  calc t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\n    _ < t * r + (1 - t) * r := by gcongr\n    _ = r := by ring", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 10, "endLine": 20, "endColumn": 14, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nl3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\nh1 : \u2016X1 - X0\u2016 < r\nh2 : \u2016X2 - X0\u2016 < r\n\u22a2 Dist.dist (t \u2022 X2 + (1 - t) \u2022 X1) X0 < r"}, {"line": 25, "column": 14, "endLine": 25, "endColumn": 22, "data": "linarith failed to find a contradiction\ncase a\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nl3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\nh1 : \u2016X1 - X0\u2016 < r\nh2 : \u2016X2 - X0\u2016 < r\nthis : X \u2208 Metric.ball X0 r\na\u271d : 0 > t\n\u22a2 False failed"}, {"line": 25, "column": 27, "endLine": 25, "endColumn": 35, "data": "linarith failed to find a contradiction\ncase a\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nl3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\nh1 : \u2016X1 - X0\u2016 < r\nh2 : \u2016X2 - X0\u2016 < r\nthis : X \u2208 Metric.ball X0 r\na\u271d : t > 1\n\u22a2 False failed"}, {"line": 27, "column": 31, "endLine": 27, "endColumn": 40, "data": "unsolved goals\ncase h\u2081.a0\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nl3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\nh1 : \u2016X1 - X0\u2016 < r\nh2 : \u2016X2 - X0\u2016 < r\nht : 0 \u2264 t \u2227 t \u2264 1\n\u22a2 0 < t\n\ncase h\u2082.a0\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nl3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\nh1 : \u2016X1 - X0\u2016 < r\nh2 : \u2016X2 - X0\u2016 < r\nht : 0 \u2264 t \u2227 t \u2264 1\n\u22a2 0 < 1 - t"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type declaration `{V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]` correctly captures that V is a real normed vector space. The variables X0, X1, X2 are properly declared as points in V.", "The condition `r > 0` is exactly represented as `(tc_2 : r > 0)` in Lean.", "The membership conditions are correctly formalized using `Metric.ball X0 r` which represents the open ball, and the condition `l1` provides the explicit norm inequalities that define this membership.", "The line segment definition has a minor notational difference: natural language uses `t\ud835\udc17\u2082+(1-t)\ud835\udc17\u2081` while Lean uses `t \u2022 X2 + (1 - t) \u2022 X1`. The `\u2022` symbol is the standard scalar multiplication notation in Lean, so this is semantically equivalent but uses different notation. Also, the natural language specifies `0<t<1` but this constraint is not explicitly present in the Lean formalization, though it may be implicit in the context.", "The condition `\u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r` perfectly matches the natural language statement using Lean's norm notation `\u2016\u00b7\u2016` for the absolute value/norm.", "The equality `\u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016` correctly represents the natural language equation, with appropriate scalar multiplication notation.", "The triangle inequality `\u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016` is perfectly captured in Lean.", "The conclusion `t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r` exactly matches the natural language statement l4.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.88 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l4\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] : \n  \u2203 (X0 X1 X2 X : V) (r t : \u211d),\n  r > 0 \u2227\n  (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r) \u2227\n  (X = t \u2022 X2 + (1 - t) \u2022 X1) \u2227\n  (\u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r) \u2227\n  (\u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016) \u2227\n  (\u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016) \u2227\n  \u00ac(t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r) := by\n  let V := \u211d\n  let X0 : V := 0\n  let X1 : V := 1\n  let X2 : V := -1\n  let r : \u211d := 1\n  let t : \u211d := 1/2\n  let X : V := t \u2022 X2 + (1 - t) \u2022 X1\n  refine \u27e8X0, X1, X2, X, r, t, ?_\u27e9\n  simp only [Metric.mem_ball, dist_zero_right, norm_eq_abs, X1, X2, X0, r, t]\n  constructor\n  \u00b7 norm_num\n  constructor\n  \u00b7 simp [X1, r]; norm_num\n  constructor\n  \u00b7 simp [X2, r]; norm_num\n  constructor\n  \u00b7 simp [X, X1, X2, t]\n  constructor\n  \u00b7 simp [X1, X2, r]; norm_num\n  constructor\n  \u00b7 simp [X, X0, X1, X2, t]\n    rw [sub_zero, sub_zero, sub_zero]\n    simp [norm_smul, norm_eq_abs]\n    norm_num\n  constructor\n  \u00b7 simp [X1, X2, X0, t]\n    rw [sub_zero, sub_zero, sub_zero]\n    simp [norm_smul, norm_eq_abs]\n    norm_num\n  \u00b7 simp [X1, X2, X0, t]\n    rw [sub_zero, sub_zero, sub_zero]\n    simp [norm_smul, norm_eq_abs]\n    norm_num"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "then\n\\begin{eqnarray*}\n|\\mathbf{X}-\\mathbf{X}_0|\\ar=|t\\mathbf{X}_2+(1-t)\\mathbf{X}_1-t\\mathbf{X}_0-(1-t)\\mathbf{X}_0|\\\\\n\\ar=|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)\\mathbf{X}_1-\\mathbf{X}_0)|\\\\\n\\ar\\le  t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|\\\\\n\\ar< tr+(1-t)r=r.\n\\end{eqnarray*}", "statement": "We assume:\n\u2022 Let $\\mathbf{X}_0, \\mathbf{X}_1, \\mathbf{X}_2$ be points in a real normed vector space $V$ [tc_1].\n\u2022 $r > 0$ [tc_2].\n\u2022 $\\mathbf{X}_1 \\in S_r(\\mathbf{X}_0)$ and $\\mathbf{X}_2 \\in S_r(\\mathbf{X}_0)$, where $S_r(\\mathbf{X}_0)$ is the open ball defined as $\\{\\mathbf{Y} \\in V : |\\mathbf{Y} - \\mathbf{X}_0| < r\\}$ [tc_3].\n\u2022 Let $\\mathbf{X}$ be an arbitrary point on the line segment from $\\mathbf{X}_1$ to $\\mathbf{X}_2$, defined as $\\mathbf{X} = t\\mathbf{X}_2+(1-t)\\mathbf{X}_1$ for some $t$ such that $0<t<1$ [def_1].\n\u2022 $|\\mathbf{X}_1-\\mathbf{X}_0|<r$ and $|\\mathbf{X}_2-\\mathbf{X}_0|<r$ [l1].\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| = |t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)|$ [l2].\n\u2022 $|t(\\mathbf{X}_2-\\mathbf{X}_0)+(1-t)(\\mathbf{X}_1-\\mathbf{X}_0)| \\le t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0|$ [l3].\n\u2022 $t|\\mathbf{X}_2-\\mathbf{X}_0|+(1-t)|\\mathbf{X}_1-\\mathbf{X}_0| < r$ [l4].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{X}_0| < r$, which means every point on the line segment is in $S_r(\\mathbf{X}_0)$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016)\n  (l3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016)\n  (l4 : t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r) :\n  \u2016X - X0\u2016 < r := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016)\n  (l3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016)\n  (l4 : t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r) :\n  \u2016X - X0\u2016 < r := by\n  rw [def_1]\n  simp only [sub_eq_add_neg, add_assoc, smul_add, smul_neg]\n  rw [l2]\n  exact lt_of_le_of_lt l3 l4", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 18, "column": 6, "endLine": 18, "endColumn": 8, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2016X - X0\u2016\nV : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nX0 X1 X2 X : V\nr t : \u211d\ntc_1 : True\ntc_2 : r > 0\ntc_3 : X1 \u2208 Metric.ball X0 r \u2227 X2 \u2208 Metric.ball X0 r\ndef_1 : X = t \u2022 X2 + (1 - t) \u2022 X1\nl1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r\nl2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016\nl3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016\nl4 : t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r\n\u22a2 \u2016t \u2022 X2 + ((1 + -t) \u2022 X1 + -X0)\u2016 < r"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type declarations correctly capture a real normed vector space V with appropriate type classes.", "The condition r > 0 is exactly preserved in both versions.", "The membership conditions for X1 and X2 in the open ball are correctly formalized using Metric.ball, which represents the same mathematical concept as the set notation in natural language.", "The definition of X has a minor notational difference: natural language uses t*X2+(1-t)*X1 while Lean uses t \u2022 X2 + (1 - t) \u2022 X1. The scalar multiplication operator \u2022 is the standard Lean notation for scalar multiplication in normed spaces, so this represents the same mathematical operation. However, the natural language also specifies the constraint 0<t<1 which is missing from the Lean formalization.", "The norm inequalities in l1 are correctly translated from absolute value notation |\u00b7| to norm notation \u2016\u00b7\u2016, representing the same mathematical concept.", "The equality in l2 correctly captures the norm calculation with proper Lean notation for scalar multiplication and vector operations.", "The triangle inequality in l3 is perfectly preserved, showing the relationship between the norm of a sum and the sum of norms.", "The final inequality l4 correctly represents the constraint on the weighted sum of norms.", "The conclusion ts_1 perfectly captures that \u2016X - X0\u2016 < r, which is equivalent to saying X is in the open ball Sr(X0).", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.89 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  {V : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V] (X0 X1 X2 X : V) (r t : \u211d)\n  (tc_1 : True)\n  (tc_2 : r > 0)\n  (tc_3 : (X1 \u2208 Metric.ball X0 r) \u2227 (X2 \u2208 Metric.ball X0 r))\n  (def_1 : X = t \u2022 X2 + (1 - t) \u2022 X1)\n  (l1 : \u2016X1 - X0\u2016 < r \u2227 \u2016X2 - X0\u2016 < r)\n  (l2 : \u2016X - X0\u2016 = \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016)\n  (l3 : \u2016t \u2022 (X2 - X0) + (1 - t) \u2022 (X1 - X0)\u2016 \u2264 t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016)\n  (l4 : t * \u2016X2 - X0\u2016 + (1 - t) * \u2016X1 - X0\u2016 < r) :\n  \u00ac \u2016X - X0\u2016 < r := by\n  intro h\n  have : \u2016X - X0\u2016 < r := by\n    rw [l2]\n    exact l3.trans_lt l4\n  exact lt_irrefl _ this"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    