
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Every natural number is a product of primes.

Proof: Let~$n$ be a natural number.  If $n=1$, then~$n$ is the empty
product of primes.
If $n$ is prime, we are done.
If $n$ is composite, then $n=ab$ with $a,b<n$. By induction,~$a$
and~$b$ are products of primes, so~$n$ is also a product of primes.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let n be a natural number.", "statement": "Premise:\n\u2022 n is a natural number such that n \u2265 1 [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115)\n(tc_1 : n \u2265 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean declaration 'variable (n : \u2115)' correctly captures that n is a natural number", "The Lean constraint '(tc_1 : n \u2265 1)' exactly matches the mathematical condition n \u2265 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "If n=1, then n is the empty product of primes.", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1].\nDefinition:\n\u2022 A natural number is a 'product of primes' if it can be written as the product of a finite multiset of prime numbers. The product of the empty multiset is defined to be 1 [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115)\n(tc_1 : n \u2265 1)\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly declares n as a natural number with the constraint n \u2265 1, matching the natural language exactly.", "The Lean definition captures the concept perfectly: a number k is a product of primes if there exists a multiset S where all elements are prime and k equals the product of S. This matches the natural language definition.", "The Lean formalization implicitly handles the empty multiset case correctly since Multiset.prod of an empty multiset equals 1 by definition in Lean, which matches the stated requirement that the product of the empty multiset is 1."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "By induction", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 A natural number is a 'product of primes' if it can be written as the product of a finite multiset of prime numbers. The product of the empty multiset is defined to be 1 [def_1].\nAssumption (Inductive Hypothesis):\n\u2022 For all natural numbers k such that 1 \u2264 k < n, k is a product of primes [def_2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (n : \u2115)\n(tc_1 : n \u2265 1)\n(def_1 : \u2200 k : \u2115, (\u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = S.prod) \u2192 IsProductOfPrimes k)\n(def_2 : \u2200 k : \u2115, 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)", "lean_pass": false, "error_msg": [{"line": 7, "column": 76, "endLine": 7, "endColumn": 95, "data": "function expected at\n  IsProductOfPrimes\nterm has type\n  ?m.175"}, {"line": 8, "column": 34, "endLine": 8, "endColumn": 53, "data": "function expected at\n  IsProductOfPrimes\nterm has type\n  ?m.175"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If n=1, then n is the empty product of primes.", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 A natural number is a 'product of primes' if it can be written as the product of a finite multiset of prime numbers. The product of the empty multiset is defined to be 1 [def_1];\n\u2022 For all natural numbers k such that 1 \u2264 k < n, k is a product of primes [def_2].\nTherefore, we conclude:\n\u2022 If n = 1, then n is a product of primes [l1].", "dependencies": ["tc_1", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma l1\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k) :\n  n = 1 \u2192 IsProductOfPrimes 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma l1\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k) :\n  n = 1 \u2192 IsProductOfPrimes 1 := by\n  intro h\n  use \u2205\n  simp [IsProductOfPrimes]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The definition correctly captures that a number is a product of primes via existence of a multiset of primes, and handles the empty multiset case implicitly through Lean's multiset product definition", "The constraint n \u2265 1 is directly and correctly formalized", "The inductive hypothesis is properly formalized using universal quantification with conjunction for the bounds 1 \u2264 k \u2227 k < n", "The conclusion correctly formalizes the conditional statement, with IsProductOfPrimes 1 being equivalent to IsProductOfPrimes n when n = 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "If n is prime, we are done.", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 A natural number is a 'product of primes' if it can be written as the product of a finite multiset of prime numbers. The product of the empty multiset is defined to be 1 [def_1];\n\u2022 For all natural numbers k such that 1 \u2264 k < n, k is a product of primes [def_2];\n\u2022 If n = 1, then n is a product of primes [l1].\nTherefore, we conclude:\n\u2022 If n is a prime number, then n is a product of primes [l2].", "dependencies": ["tc_1", "def_1", "def_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma l2\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l1 : n = 1 \u2192 IsProductOfPrimes 1) :\n  Nat.Prime n \u2192 IsProductOfPrimes n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma l2\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l1 : n = 1 \u2192 IsProductOfPrimes 1) :\n  Nat.Prime n \u2192 IsProductOfPrimes n := by\n  intro h\n  cases n with\n  | zero => simp at tc_1\n  | succ n' =>\n    cases n' with\n    | zero => exact l1 rfl\n    | succ n'' =>\n      use Multiset.singleton n.succ.succ\n      constructor\n      \u00b7 intro p hp\n        rw [Multiset.mem_singleton] at hp\n        rw [hp]\n        exact h\n      \u00b7 simp [Multiset.prod_singleton]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 10, "endLine": 21, "endColumn": 40, "data": "unknown constant 'Multiset.singleton'"}, {"line": 24, "column": 12, "endLine": 24, "endColumn": 34, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.1302 \u2208 {?m.1301}\ncase h.left\nn'' : \u2115\ntc_1 : n'' + 1 + 1 \u2265 1\ndef_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n'' + 1 + 1 \u2192 IsProductOfPrimes k\nl1 : n'' + 1 + 1 = 1 \u2192 IsProductOfPrimes 1\nh : Nat.Prime (n'' + 1 + 1)\np : \u2115\nhp : p \u2208 sorry\n\u22a2 Nat.Prime p"}, {"line": 27, "column": 8, "endLine": 27, "endColumn": 38, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The IsProductOfPrimes definition correctly captures the natural language concept using multisets, with the empty multiset case properly handled by Lean's default product behavior.", "The constraint tc_1 is a direct and accurate translation of n \u2265 1.", "The inductive hypothesis def_2 correctly formalizes the universal quantification with the compound condition 1 \u2264 k \u2227 k < n.", "In l1, the natural language says 'n is a product of primes' but the Lean formalization uses 'IsProductOfPrimes 1'. While logically equivalent when n = 1, this is a slight structural difference in how the conclusion is expressed.", "The goal l2 perfectly captures the implication from primality to being a product of primes.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = S.prod\n\nlemma neg_l2 :\n  \u2203 n : \u2115, Nat.Prime n \u2227 \u00ac IsProductOfPrimes n := by\n  use 2\n  constructor\n  \u00b7 simp [Nat.prime_def_lt]\n    constructor\n    exact Nat.le_refl 2\n    intro m h\n    simp at h\n    linarith\n  \u00b7 intro \u27e8S, hS\u27e9\n    have : S.prod = 2 := hS.2.symm\n    have : S = {2} := by\n      cases S using Multiset.induction_on\n      \u00b7 simp at this\n      \u00b7 simp [Multiset.prod_cons] at this\n        cases this\n        simp [Multiset.prod_zero]\n        contradiction\n    simp [this] at hS\n    contradiction"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "If n is composite, then n=ab with a,b<n.", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 (deps...);\n\u2022 If n is a prime number, then n is a product of primes [l2].\nTherefore, we conclude:\n\u2022 If n is a composite number, then there exist natural numbers a and b such that n = a * b, 1 < a < n, and 1 < b < n [l3].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma l3\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l1 : n = 1 \u2192 IsProductOfPrimes 1)\n  (l2 : Nat.Prime n \u2192 IsProductOfPrimes n) :\n  (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma l3\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l1 : n = 1 \u2192 IsProductOfPrimes 1)\n  (l2 : Nat.Prime n \u2192 IsProductOfPrimes n) :\n  (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) := by\n  intro \u27e8h_prime, h_one\u27e9\n  have h_gt_one : 1 < n := by\n    cases lt_or_eq_of_le tc_1 with\n    | inl h => exact h\n    | inr h => exact absurd h.symm h_one\n  have : \u2203 m, m \u2223 n \u2227 m \u2260 1 \u2227 m \u2260 n := by\n    simp [Nat.prime_def_lt'] at h_prime\n    push_neg at h_prime\n    exact h_prime h_gt_one\n  obtain \u27e8a, \u27e8b, hb\u27e9, ha1, han\u27e9 := this\n  refine \u27e8a, b, hb, ?_, ?_, ?_, ?_\u27e9\n  \u00b7 exact Nat.one_lt_iff_ne_zero_and_ne_one.2 \u27e8fun h => by simp [h] at ha1, ha1\u27e9\n  \u00b7 rw [hb]\n    exact Nat.lt_mul_of_lt_left han (Nat.one_lt_iff_ne_zero_and_ne_one.1 \u20391 < a\u203a).1\n  \u00b7 rw [hb]\n    exact Nat.one_lt_iff_ne_zero_and_ne_one.2 \u27e8fun h => by simp [h] at han, fun h => by rw [h, mul_one] at hb; exact h_one hb.symm\u27e9\n  \u00b7 rw [hb]\n    exact Nat.lt_mul_of_lt_right han (Nat.one_lt_iff_ne_zero_and_ne_one.1 \u20391 < a\u203a).1", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 22, "column": 4, "endLine": 22, "endColumn": 23, "data": "push_neg made no progress"}, {"line": 26, "column": 56, "endLine": 26, "endColumn": 74, "data": "unsolved goals\nn : \u2115\ntc_1 : n \u2265 1\ndef_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k\nl1 : n = 1 \u2192 IsProductOfPrimes 1\nl2 : Nat.Prime n \u2192 IsProductOfPrimes n\nh_prime : \u00acNat.Prime n\nh_one : n \u2260 1\nh_gt_one : 1 < n\na b : \u2115\nhb : n = a * b\nhan : a \u2260 n\nh : a = 0\nha1 : True\n\u22a2 False"}, {"line": 28, "column": 10, "endLine": 28, "endColumn": 83, "data": "unknown constant 'Nat.lt_mul_of_lt_left'"}, {"line": 29, "column": 8, "endLine": 29, "endColumn": 10, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  n\ncase intro.intro.intro.intro.refine_3\nn : \u2115\ntc_1 : n \u2265 1\ndef_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k\nl1 : n = 1 \u2192 IsProductOfPrimes 1\nl2 : Nat.Prime n \u2192 IsProductOfPrimes n\nh_prime : \u00acNat.Prime n\nh_one : n \u2260 1\nh_gt_one : 1 < n\na b : \u2115\nhb : n = a * b\nha1 : a \u2260 1\nhan : a \u2260 n\n\u22a2 1 < b"}, {"line": 32, "column": 10, "endLine": 32, "endColumn": 84, "data": "unknown constant 'Nat.lt_mul_of_lt_right'"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variable declaration and constraint tc_1 correctly capture that n is a natural number with n \u2265 1.", "The deps placeholder in natural language is replaced with specific mathematical assumptions (def_2 and l1) that are logically consistent and provide necessary context for the theorem.", "The assumption l2 about prime numbers being products of primes is correctly formalized using the IsProductOfPrimes predicate.", "The conclusion correctly formalizes 'composite number' as '\u00ac Nat.Prime n \u2227 n \u2260 1' and accurately captures all the existential conditions for the factorization.", "The IsProductOfPrimes definition properly captures the mathematical concept of being a product of primes using multisets.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\ndef IsProductOfPrimes (k : \u2115) : Prop :=\n  \u2203 S : Multiset \u2115, (\u2200 p \u2208 S, Nat.Prime p) \u2227 k = (S.prod : \u2115)\n\nlemma neg_l3\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l1 : n = 1 \u2192 IsProductOfPrimes 1)\n  (l2 : Nat.Prime n \u2192 IsProductOfPrimes n) :\n  \u2203 n, (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2227 \u2200 a b : \u2115, n = a * b \u2192 \u00ac(1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) := by\n  use 4\n  constructor\n  \u00b7 constructor\n    \u00b7 simp\n    \u00b7 decide\n  \u00b7 intro a b h\n    rw [h]\n    intro \u27e8ha1, ha2, hb1, hb2\u27e9\n    have : a \u2264 2 := by\n      apply Nat.le_of_mul_le_mul_left\n      \u00b7 rw [h]\n        exact ha2\n      \u00b7 exact ha1\n    interval_cases a\n    \u00b7 simp at hb1\n      contradiction\n    \u00b7 simp at hb2\n      contradiction"}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By induction, a and b are products of primes", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 A natural number is a 'product of primes' if ... [def_1];\n\u2022 For all natural numbers k such that 1 \u2264 k < n, k is a product of primes [def_2];\n\u2022 (deps...);\n\u2022 If n is a composite number, then there exist natural numbers a and b such that n = a * b, 1 < a < n, and 1 < b < n [l3].\nTherefore, we conclude:\n\u2022 If n is a composite number with factors a, b such that n=a*b and 1 < a < n and 1 < b < n, then a is a product of primes and b is a product of primes [l4].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l3 : (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n)) :\n  (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) \u2192 (IsProductOfPrimes a \u2227 IsProductOfPrimes b) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l3 : (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n)) :\n  \u2200 a b : \u2115, (n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) \u2192 (IsProductOfPrimes a \u2227 IsProductOfPrimes b) := by\n  intro a b \u27e8h\u2081, h\u2082, h\u2083, h\u2084, h\u2085\u27e9\n  have ha : 1 \u2264 a \u2227 a < n := \u27e8Nat.le_of_lt h\u2082, h\u2083\u27e9\n  have hb : 1 \u2264 b \u2227 b < n := \u27e8Nat.le_of_lt h\u2084, h\u2085\u27e9\n  constructor\n  \u00b7 exact def_2 a ha\n  \u00b7 exact def_2 b hb", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The basic setup including n \u2265 1, the IsProductOfPrimes predicate, and the inductive hypothesis def_2 are correctly formalized and match the natural language assumptions.", "The characterization of composite numbers using (\u00ac Nat.Prime n \u2227 n \u2260 1) is mathematically equivalent to 'composite number' and the existential statement about factors matches perfectly.", "The conclusion has a critical scoping error. The variables a and b in '(IsProductOfPrimes a \u2227 IsProductOfPrimes b)' are not bound and refer to nothing. The natural language clearly indicates that the conclusion should be about the specific a and b that satisfy the factorization conditions, but the Lean formalization fails to capture this logical dependency properly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The basic setup including n \u2265 1, the IsProductOfPrimes predicate, and the inductive hypothesis def_2 are correctly formalized and match the natural language assumptions.', \"The characterization of composite numbers using (\u00ac Nat.Prime n \u2227 n \u2260 1) is mathematically equivalent to 'composite number' and the existential statement about factors matches perfectly.\", \"The conclusion has a critical scoping error. The variables a and b in '(IsProductOfPrimes a \u2227 IsProductOfPrimes b)' are not bound and refer to nothing. The natural language clearly indicates that the conclusion should be about the specific a and b that satisfy the factorization conditions, but the Lean formalization fails to capture this logical dependency properly.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "so n is also a product of primes.", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 (deps...);\n\u2022 If n is a composite number, then there exist natural numbers a and b such that n = a * b, 1 < a < n, and 1 < b < n [l3];\n\u2022 If n is a composite number with factors a, b such that n=a*b and 1 < a < n and 1 < b < n, then a is a product of primes and b is a product of primes [l4].\nTherefore, we conclude:\n\u2022 If n is a composite number, then n is a product of primes [l5].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l3 : (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n))\n  (l4 : (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) \u2192 (IsProductOfPrimes a \u2227 IsProductOfPrimes b)) :\n  (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 IsProductOfPrimes n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (def_2 : \u2200 (k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l3 : (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n))\n  (l4 : (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) \u2192 (IsProductOfPrimes a \u2227 IsProductOfPrimes b)) :\n  (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 IsProductOfPrimes n := by\n  intro h\n  obtain \u27e8a, b, hn, ha1, han, hb1, hbn\u27e9 := l3 h\n  have ha := def_2 a \u27e8Nat.le_of_lt ha1, han\u27e9\n  have hb := def_2 b \u27e8Nat.le_of_lt hb1, hbn\u27e9\n  rw [hn]\n  let hab := l4 \u27e8a, b, hn, ha1, han, hb1, hbn\u27e9\n  match hab with\n  | \u27e8ha, hb\u27e9 => exact ha.mul hb", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 22, "endLine": 20, "endColumn": 31, "data": "invalid field notation, type is not of the form (C ...) where C is a constant\n  ha\nhas type\n  IsProductOfPrimes a\u271d"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declaration and constraint n \u2265 1 are correctly formalized", "Composite number definition using \u00ac Nat.Prime n \u2227 n \u2260 1 accurately captures the natural language meaning, with all factor conditions preserved", "The existential quantification in l4's antecedent creates a scoping issue where variables a and b are not accessible in the consequent, though the logical intent is similar to the natural language", "The conclusion correctly formalizes the implication from composite number to product of primes", "Additional elements like IsProductOfPrimes predicate and def_2 inductive hypothesis are reasonable additions that support the proof structure without contradicting the natural language", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (def_2 : \u2200 (n k : \u2115), 1 \u2264 k \u2227 k < n \u2192 IsProductOfPrimes k)\n  (l3 : \u2200 n, (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 (\u2203 a b : \u2115, n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n))\n  (l4 : \u2200 n a b, (n = a * b \u2227 1 < a \u2227 a < n \u2227 1 < b \u2227 b < n) \u2192 (IsProductOfPrimes a \u2227 IsProductOfPrimes b)) :\n  \u2203 n, n \u2265 1 \u2227 \u00ac Nat.Prime n \u2227 n \u2260 1 \u2227 \u00ac IsProductOfPrimes n := by\n  use 4\n  simp\n  repeat' constructor\n  \u00b7 norm_num\n  \u00b7 simp [Nat.prime_iff]\n  \u00b7 norm_num\n  \u00b7 intro h\n    have \u27e8a, b, h\u2081, h\u2082, h\u2083, h\u2084, h\u2085\u27e9 := l3 4 \u27e8by simp [Nat.prime_iff], by norm_num\u27e9\n    have \u27e8h\u2086, h\u2087\u27e9 := l4 4 a b \u27e8h\u2081, h\u2082, h\u2083, h\u2084, h\u2085\u27e9\n    sorry"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Let n be a natural number. If n=1, then n is the empty product of primes. If n is prime, we are done. If n is composite, then n=ab with a,b<n. By induction, a and b are products of primes, so n is also a product of primes.", "statement": "We assume:\n\u2022 n is a natural number such that n \u2265 1 [tc_1];\n\u2022 If n = 1, then n is a product of primes [l1];\n\u2022 If n is a prime number, then n is a product of primes [l2];\n\u2022 If n is a composite number, then n is a product of primes [l5].\nTherefore, we conclude:\n\u2022 n is a product of primes [ts_1].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (l1 : n = 1 \u2192 IsProductOfPrimes 1)\n  (l2 : Nat.Prime n \u2192 IsProductOfPrimes n)\n  (l5 : (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 IsProductOfPrimes n) :\n  IsProductOfPrimes n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115)\n  (tc_1 : n \u2265 1)\n  (IsProductOfPrimes : \u2115 \u2192 Prop)\n  (l1 : n = 1 \u2192 IsProductOfPrimes n)\n  (l2 : Nat.Prime n \u2192 IsProductOfPrimes n)\n  (l5 : (\u00ac Nat.Prime n \u2227 n \u2260 1) \u2192 IsProductOfPrimes n) :\n  IsProductOfPrimes n := by\n  by_cases h\u2081 : n = 1\n  \u00b7 exact l1 h\u2081\n  \u00b7 by_cases h\u2082 : Nat.Prime n\n    \u00b7 exact l2 h\u2082\n    \u00b7 exact l5 \u27e8h\u2082, h\u2081\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 3}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declaration and constraint n \u2265 1 are correctly formalized", "The predicate IsProductOfPrimes is appropriately introduced as \u2115 \u2192 Prop", "The case n = 1 is correctly formalized, with IsProductOfPrimes 1 being semantically equivalent to IsProductOfPrimes n when n = 1", "The prime case is perfectly captured with Nat.Prime n \u2192 IsProductOfPrimes n", "The composite case is correctly formalized using \u00ac Nat.Prime n \u2227 n \u2260 1, which is the standard mathematical definition of composite numbers", "The conclusion IsProductOfPrimes n matches the natural language exactly", "The overall logical structure correctly represents a complete case analysis for all natural numbers \u2265 1"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    