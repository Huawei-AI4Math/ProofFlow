
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $A$ and $B$ be $n 	imes n$ matrices. If $AB = I$ where $I$ is the identity matrix, then $\det(A) 
eq 0$ and $\det(B) = rac{1}{\det(A)}$.

Proof: Since $AB = I$, we can take the determinant of both sides: $\det(AB) = \det(I)$. We know that $\det(I) = 1$ for any identity matrix. By the multiplicative property of determinants, $\det(AB) = \det(A) \cdot \det(B)$. Therefore, $\det(A) \cdot \det(B) = 1$. For this equation to hold, we need $\det(A) 
eq 0$ (otherwise the product would be $0$, not $1$). Since $\det(A) \cdot \det(B) = 1$ and $\det(A) 
eq 0$, we can divide both sides by $\det(A)$ to get $\det(B) = rac{1}{\det(A)}$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let A and B be n x n matrices.", "statement": "Premise:\n\u2022 A and B are n\u00d7n matrices [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that A and B are n\u00d7n matrices. The type `Matrix (Fin n) (Fin n) \u211d` precisely represents n\u00d7n matrices with real entries, where `Fin n` provides the appropriate indexing for both rows and columns from 0 to n-1. The additional specification that entries are real numbers is a reasonable mathematical detail that doesn't contradict the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If AB = I where I is the identity matrix", "statement": "Premise:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n(tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The natural language states 'A and B are n\u00d7n matrices' without specifying the field/ring, while Lean specifies they are matrices over real numbers (\u211d). This is a minor addition of type information that doesn't contradict the natural language but adds specificity not explicitly mentioned.", "The Lean formalization correctly captures AB = I using matrix multiplication notation A * B and the identity matrix representation (1 : Matrix (Fin n) (Fin n) \u211d). This perfectly matches the mathematical meaning."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The natural language states 'A and B are n\u00d7n matrices' without specifying the field/ring, while Lean specifies they are matrices over real numbers (\u211d). This is a minor addition of type information that doesn't contradict the natural language but adds specificity not explicitly mentioned.\", 'The Lean formalization correctly captures AB = I using matrix multiplication notation A * B and the identity matrix representation (1 : Matrix (Fin n) (Fin n) \u211d). This perfectly matches the mathematical meaning.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Since AB = I, we can take the determinant of both sides: det(AB) = det(I).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2].\nTherefore, we conclude:\n\u2022 det(AB) = det(I) [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d)) :\n  Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d)) :\n  Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) := by\n  rw [tc_2]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language mentions tc_1 for the matrix dimensions assumption, but this label is missing in the Lean formalization. The Lean code declares A and B as n\u00d7n matrices over reals without explicitly labeling this assumption as tc_1. However, the mathematical content is identical - both specify A and B as n\u00d7n matrices.", "The matrix multiplication condition AB = I is perfectly captured. The Lean formalization correctly uses tc_2 as the label and represents the identity matrix as (1 : Matrix (Fin n) (Fin n) \u211d), which is the standard Lean notation for the identity matrix.", "The conclusion about determinants is perfectly captured. Both the natural language and Lean formalization state that det(AB) = det(I), with appropriate Lean syntax using Matrix.det and the same identity matrix representation."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "We know that det(I) = 1 for any identity matrix.", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1].\nTherefore, we conclude:\n\u2022 det(I) = 1 [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True) -- A and B are n x n matrices is implicit in their type Matrix (Fin n) (Fin n) \u211d\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d)) :\n  Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True) -- A and B are n x n matrices is implicit in their type Matrix (Fin n) (Fin n) \u211d\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d)) :\n  Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1 := by\n  rw [\u2190 l1, tc_2, Matrix.det_one]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Matrix type declarations correctly capture n\u00d7n matrices with appropriate handling of implicit typing", "Matrix multiplication equation AB = I is accurately represented using Lean's matrix notation", "Determinant equality statement is faithfully translated with proper Matrix.det syntax", "Conclusion about determinant of identity matrix is correctly formulated as the lemma goal"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "By the multiplicative property of determinants, det(AB) = det(A) * det(B).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2].\nTherefore, we conclude:\n\u2022 det(AB) = det(A) * det(B) [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1) :\n  Matrix.det (A * B) = Matrix.det A * Matrix.det B := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1) :\n  Matrix.det (A * B) = Matrix.det A * Matrix.det B := by\n  rw [Matrix.det_mul]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The matrix type declarations are correctly captured in the function signature, but tc_1 is represented as 'True' rather than encoding the actual matrix dimension constraint. This is a minor structural difference as the semantic meaning (A and B are n\u00d7n matrices) is preserved through the type system.", "The condition AB = I is perfectly captured, with the identity matrix correctly represented as '1' in Lean's matrix notation.", "The determinant equality det(AB) = det(I) is exactly represented with proper Lean matrix determinant syntax.", "The identity matrix determinant condition det(I) = 1 is perfectly captured.", "The conclusion det(AB) = det(A) * det(B) is exactly represented with correct determinant multiplication syntax."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Therefore, det(A) * det(B) = 1.", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2];\n\u2022 det(AB) = det(A) * det(B) [l3].\nTherefore, we conclude:\n\u2022 det(A) * det(B) = 1 [l4].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1)\n  (l3 : Matrix.det (A * B) = Matrix.det A * Matrix.det B) :\n  Matrix.det A * Matrix.det B = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1)\n  (l3 : Matrix.det (A * B) = Matrix.det A * Matrix.det B) :\n  Matrix.det A * Matrix.det B = 1 := by\n  rw [\u2190 l3, l1, l2]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Matrix declarations are correctly formalized with appropriate types. The tc_1 : True is a harmless placeholder.", "The matrix multiplication condition AB = I is correctly captured using Lean's matrix multiplication and identity notation.", "The determinant equality det(AB) = det(I) is precisely formalized using Matrix.det.", "The identity matrix determinant condition det(I) = 1 is correctly formalized.", "The determinant multiplicativity property det(AB) = det(A) * det(B) is accurately captured.", "The conclusion det(A) * det(B) = 1 is correctly stated as the goal of the lemma."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "For this equation to hold, we need det(A) != 0 (otherwise the product would be 0, not 1).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2];\n\u2022 det(AB) = det(A) * det(B) [l3];\n\u2022 det(A) * det(B) = 1 [l4].\nTherefore, we conclude:\n\u2022 det(A) \u2260 0 [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1)\n  (l3 : Matrix.det (A * B) = Matrix.det A * Matrix.det B)\n  (l4 : Matrix.det A * Matrix.det B = 1) :\n  Matrix.det A \u2260 0 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1)\n  (l3 : Matrix.det (A * B) = Matrix.det A * Matrix.det B)\n  (l4 : Matrix.det A * Matrix.det B = 1) :\n  Matrix.det A \u2260 0 := by\n  intro h\n  have : Matrix.det A * Matrix.det B = 0 := by rw [h, zero_mul]\n  rw [\u2190 l3, l1, l2] at l4\n  contradiction", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 2, "endLine": 17, "endColumn": 15, "data": "tactic 'contradiction' failed\nn : \u2115\nA B : Matrix (Fin n) (Fin n) \u211d\ntc_1 : True\ntc_2 : A * B = 1\nl1 : (A * B).det = Matrix.det 1\nl2 : Matrix.det 1 = 1\nl3 : (A * B).det = A.det * B.det\nl4 : 1 = 1\nh : A.det = 0\nthis : A.det * B.det = 0\n\u22a2 False"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization accurately captures the mathematical content and logical structure of the natural language proof. The matrix types, equations, and conclusion are all correctly represented. The only minor issue is that tc_1 is represented as 'True' rather than explicitly stating the matrix dimensions, but since the matrix types are properly declared in the function signature, this doesn't affect the mathematical meaning. All the essential logical components (the identity AB = I, determinant properties, and the conclusion det(A) \u2260 0) are faithfully translated.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization accurately captures the mathematical content and logical structure of the natural language proof. The matrix types, equations, and conclusion are all correctly represented. The only minor issue is that tc_1 is represented as 'True' rather than explicitly stating the matrix dimensions, but since the matrix types are properly declared in the function signature, this doesn't affect the mathematical meaning. All the essential logical components (the identity AB = I, determinant properties, and the conclusion det(A) \u2260 0) are faithfully translated.\"]"}, "solved_negation": null, "type": "solution"}, "ts_2": {"id": "ts_2", "natural_language": "Since det(A) * det(B) = 1 and det(A) != 0, we can divide both sides by det(A) to get det(B) = 1/det(A).", "statement": "We assume:\n\u2022 A and B are n\u00d7n matrices [tc_1];\n\u2022 AB = I, where I is the n\u00d7n identity matrix [tc_2];\n\u2022 det(AB) = det(I) [l1];\n\u2022 det(I) = 1 [l2];\n\u2022 det(AB) = det(A) * det(B) [l3];\n\u2022 det(A) * det(B) = 1 [l4];\n\u2022 det(A) \u2260 0 [ts_1].\nTherefore, we conclude:\n\u2022 det(B) = 1 / det(A) [ts_2].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3", "l4", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1)\n  (l3 : Matrix.det (A * B) = Matrix.det A * Matrix.det B)\n  (l4 : Matrix.det A * Matrix.det B = 1)\n  (ts_1 : Matrix.det A \u2260 0) :\n  Matrix.det B = 1 / Matrix.det A := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (A B : Matrix (Fin n) (Fin n) \u211d)\n  (tc_1 : True)\n  (tc_2 : A * B = (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l1 : Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d))\n  (l2 : Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1)\n  (l3 : Matrix.det (A * B) = Matrix.det A * Matrix.det B)\n  (l4 : Matrix.det A * Matrix.det B = 1)\n  (ts_1 : Matrix.det A \u2260 0) :\n  Matrix.det B = 1 / Matrix.det A := by\n  rw [\u2190 l4, mul_comm, eq_div_iff_mul_eq ts_1, mul_comm]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.88, "semantic_feedback": ["The natural language states 'A and B are n\u00d7n matrices [tc_1]' but in Lean, tc_1 is just 'True' rather than encoding the matrix property. The matrix types are declared separately in the function signature, which is mathematically equivalent but structurally different from what the natural language suggests.", "The condition AB = I is correctly formalized as A * B = (1 : Matrix (Fin n) (Fin n) \u211d), where 1 represents the identity matrix in Lean's matrix library.", "The equation det(AB) = det(I) is perfectly captured as Matrix.det (A * B) = Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d).", "The statement det(I) = 1 is correctly formalized as Matrix.det (1 : Matrix (Fin n) (Fin n) \u211d) = 1.", "The multiplicativity property det(AB) = det(A) * det(B) is accurately represented as Matrix.det (A * B) = Matrix.det A * Matrix.det B.", "The equation det(A) * det(B) = 1 is precisely formalized as Matrix.det A * Matrix.det B = 1.", "The condition det(A) \u2260 0 is exactly captured as Matrix.det A \u2260 0.", "The conclusion det(B) = 1 / det(A) is correctly stated as the goal Matrix.det B = 1 / Matrix.det A."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    