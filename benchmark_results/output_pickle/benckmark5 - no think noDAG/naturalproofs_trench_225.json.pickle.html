
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If a sequence $\{u_n\}$ in a metric space $(A,\rho)$ is convergent$,$
then it is a Cauchy sequence.

Proof: Suppose that $\lim_{n	o\infty}u_n=u$. If $\epsilon>0$, there is an integer
$N$ such that
$\rho(u_n,u)<\epsilon/2$ if $n>N$. Therefore, if $m$, $n>N$, then
$$
\rho(u_n,u_m)\le\rho(u_n,u)+\rho(u,u_m)<\epsilon.
$$
\vskip-2em
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If a sequence \\({u_n}\\) in a metric space \\((A,\\rho)\\)", "statement": "Premise:\n\u2022 Let \\((A, \\rho)\\) be a metric space and let \\({u_n}\\) be a sequence of points in A [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u : \u2115 \u2192 \u03b1)\n(tc_1 : true)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization uses \u03b1 as the type and assumes [MetricSpace \u03b1] which automatically provides the metric structure, while also declaring \u03c1 as a separate function \u03b1 \u2192 \u03b1 \u2192 \u211d. In standard Lean, MetricSpace \u03b1 already includes the distance function (typically denoted as dist), so declaring \u03c1 separately creates a redundancy. The mathematical meaning is preserved but the formalization is not the most direct translation.", "The Lean formalization correctly captures the sequence {u_n} as a function u : \u2115 \u2192 \u03b1, which is the standard way to represent sequences in type theory."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization uses \u03b1 as the type and assumes [MetricSpace \u03b1] which automatically provides the metric structure, while also declaring \u03c1 as a separate function \u03b1 \u2192 \u03b1 \u2192 \u211d. In standard Lean, MetricSpace \u03b1 already includes the distance function (typically denoted as dist), so declaring \u03c1 separately creates a redundancy. The mathematical meaning is preserved but the formalization is not the most direct translation.', 'The Lean formalization correctly captures the sequence {u_n} as a function u : \u2115 \u2192 \u03b1, which is the standard way to represent sequences in type theory.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "If a sequence \\({u_n}\\) ... is convergent", "statement": "Premise:\n\u2022 Let \\((A, \\rho)\\) be a metric space and let \\({u_n}\\) be a sequence of points in A [tc_1];\n\u2022 The sequence \\({u_n}\\) is convergent [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u : \u2115 \u2192 \u03b1)\n(tc_1 : true)\n(tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u Filter.atTop (nhds u_0))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures that \u03b1 is a metric space with metric \u03c1 using the MetricSpace typeclass, which is equivalent to (A, \u03c1) being a metric space", "The Lean formalization correctly represents {u_n} as a sequence u : \u2115 \u2192 \u03b1, which is the standard way to represent sequences in Lean", "The natural language condition about convergence is represented by tc_2 in Lean, but tc_1 is just 'true' which doesn't correspond to any meaningful mathematical condition from the natural language. This creates a mismatch in the correspondence between conditions"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures that \u03b1 is a metric space with metric \u03c1 using the MetricSpace typeclass, which is equivalent to (A, \u03c1) being a metric space', 'The Lean formalization correctly represents {u_n} as a sequence u : \u2115 \u2192 \u03b1, which is the standard way to represent sequences in Lean', \"The natural language condition about convergence is represented by tc_2 in Lean, but tc_1 is just 'true' which doesn't correspond to any meaningful mathematical condition from the natural language. This creates a mismatch in the correspondence between conditions\"]"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "Suppose that \\(\\lim_{n\\to\\infty}u_n=u\\). If \\(\\epsilon>0\\), there is an integer $N$ such that\n$\\rho(u_n,u)<\\epsilon/2$ if \\(n>N\\).", "statement": "We assume:\n\u2022 Let \\((A, \\rho)\\) be a metric space and let \\({u_n}\\) be a sequence of points in A [tc_1];\n\u2022 The sequence \\({u_n}\\) is convergent [tc_2].\nTherefore, we conclude:\n\u2022 There exists a limit u \u2208 A to which \\({u_n}\\) converges, and for any \u03b5 > 0, there exists an integer N such that for all n > N, \\(\\rho(u_n, u) < \\epsilon/2\\) [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0)) :\n  \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {\u03b1 : Type*} [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0)) :\n  \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, dist (u_seq n) u_limit < \u03b5 / 2 := by\n  obtain \u27e8u_limit, h\u27e9 := tc_2\n  use u_limit\n  intro \u03b5 h\u03b5\n  have h\u03b5' : \u03b5 / 2 > 0 := by linarith\n  obtain \u27e8N, hN\u27e9 := Metric.tendsto_atTop.1 h (\u03b5 / 2) h\u03b5'\n  use N\n  intro n hn\n  exact hN n (by linarith [hn])", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0.83, "semantic_feedback": ["The metric space setup correctly translates from natural language to Lean, with appropriate type declarations.", "The sequence definition properly captures a sequence of points in the space.", "The convergence assumption is correctly formalized using Lean's standard topological convergence definition.", "The existence of a limit is properly stated in both versions.", "The epsilon-N condition is perfectly translated, maintaining the exact same logical structure and the specific \u03b5/2 bound.", "There's a minor inconsistency in metric usage: the natural language refers to \u03c1 as the metric of the metric space (A, \u03c1), but the Lean formalization uses the parameter \u03c1 rather than the canonical distance function from the MetricSpace typeclass. This could lead to using a different metric than intended."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "$\\rho(u_n,u_m)\\le\\rho(u_n,u)+\\rho(u,u_m)$", "statement": "We assume:\n\u2022 Let \\((A, \\rho)\\) be a metric space and let \\({u_n}\\) be a sequence of points in A [tc_1];\n\u2022 The sequence \\({u_n}\\) is convergent [tc_2];\n\u2022 There exists a limit u \u2208 A to which \\({u_n}\\) converges, and for any \u03b5 > 0, there exists an integer N such that for all n > N, \\(\\rho(u_n, u) < \\epsilon/2\\) [l1].\nTherefore, we conclude:\n\u2022 For any integers m, n, and for the limit point u defined in [l1], the triangle inequality holds: \\(\\rho(u_n, u_m) \\le \\rho(u_n, u) + \\rho(u, u_m)\\) [l2].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2) :\n  \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2) :\n  \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m) := by\n  intro m n u_limit\n  have := dist_triangle (u_seq n) u_limit (u_seq m)\n  rw [dist_eq] at this\n  rw [dist_eq] at this\n  rw [dist_eq] at this\n  exact this", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 6, "endLine": 13, "endColumn": 13, "data": "ambiguous, possible interpretations \n  Rat.dist_eq : \u2200 (x y : \u211a), Dist.dist x y = |\u2191x - \u2191y|\n  \n  Nat.dist_eq : \u2200 (x y : \u2115), Dist.dist x y = |\u2191x - \u2191y|\n  \n  Real.dist_eq : \u2200 (x y : \u211d), Dist.dist x y = |x - y|"}, {"line": 13, "column": 6, "endLine": 13, "endColumn": 13, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.1227\n\u03b1 : Type u_1\n\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d\ninst\u271d : MetricSpace \u03b1\nu_seq : \u2115 \u2192 \u03b1\ntc_1 : true = true\ntc_2 : \u2203 u_0, Tendsto u_seq atTop (\ud835\udcdd u_0)\nl1 : \u2203 u_limit, \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2\nm n : \u2115\nu_limit : \u03b1\nthis : Dist.dist (u_seq n) (u_seq m) \u2264 Dist.dist (u_seq n) u_limit + Dist.dist u_limit (u_seq m)\n\u22a2 \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The metric space declaration correctly captures the mathematical structure, though it redundantly defines both a custom metric \u03c1 and uses MetricSpace typeclass.", "The sequence declaration perfectly matches with appropriate type signature.", "tc_1 is assigned 'true' which doesn't capture the intended meaning that the sequence consists of points in the metric space A.", "The convergence condition is perfectly formalized using Filter.Tendsto and topological neighborhoods.", "The limit condition with \u03b5/2 bound is correctly formalized with proper quantifier structure.", "The triangle inequality conclusion has a structural difference: the natural language refers to 'the limit point u defined in [l1]' (specific limit) while Lean quantifies over any u_limit (universal statement). This changes the logical meaning slightly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The metric space declaration correctly captures the mathematical structure, though it redundantly defines both a custom metric \u03c1 and uses MetricSpace typeclass.', 'The sequence declaration perfectly matches with appropriate type signature.', \"tc_1 is assigned 'true' which doesn't capture the intended meaning that the sequence consists of points in the metric space A.\", 'The convergence condition is perfectly formalized using Filter.Tendsto and topological neighborhoods.', 'The limit condition with \u03b5/2 bound is correctly formalized with proper quantifier structure.', \"The triangle inequality conclusion has a structural difference: the natural language refers to 'the limit point u defined in [l1]' (specific limit) while Lean quantifies over any u_limit (universal statement). This changes the logical meaning slightly.\"]"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, if \\(m\\), \\(n>N\\), then\n$$\n\\rho(u_n,u_m)\\le\\rho(u_n,u)+\\rho(u,u_m)<\\epsilon.\n$$", "statement": "We assume:\n\u2022 Let \\((A, \\rho)\\) be a metric space and let \\({u_n}\\) be a sequence of points in A [tc_1];\n\u2022 The sequence \\({u_n}\\) is convergent [tc_2];\n\u2022 There exists a limit u \u2208 A to which \\({u_n}\\) converges, and for any \u03b5 > 0, there exists an integer N such that for all n > N, \\(\\rho(u_n, u) < \\epsilon/2\\) [l1];\n\u2022 For any integers m, n, and for the limit point u, \\(\\rho(u_n, u_m) \\le \\rho(u_n, u) + \\rho(u, u_m)\\) [l2].\nTherefore, we conclude:\n\u2022 For a given \u03b5 > 0, let N be the integer from [l1]. For any integers m, n such that m > N and n > N, we have \\(\\rho(u_n, u_m) < \\epsilon\\) [l3].", "dependencies": ["tc_1", "tc_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2)\n  (l2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 (m n : \u2115), m > N \u2192 n > N \u2192 \u03c1 (u_seq n) (u_seq m) < \u03b5 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2)\n  (l2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)) :\n  \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 (m n : \u2115), m > N \u2192 n > N \u2192 \u03c1 (u_seq n) (u_seq m) < \u03b5 := by\n  intro \u03b5 h\u03b5\n  obtain \u27e8u_limit, h_limit\u27e9 := l1\n  specialize h_limit (\u03b5 / 2) (half_pos h\u03b5)\n  obtain \u27e8N, hN\u27e9 := h_limit\n  use N\n  intros m n hm hn\n  have hN_m := hN m hm\n  have hN_n := hN n hn\n  have := l2 m n u_limit\n  calc \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m) := this\n  _ < \u03b5 / 2 + \u03b5 / 2 := by gcongr\n  _ = \u03b5 := by simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 22, "column": 23, "endLine": 22, "endColumn": 32, "data": "unsolved goals\ncase h\u2081\n\u03b1 : Type u_1\n\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d\ninst\u271d : MetricSpace \u03b1\nu_seq : \u2115 \u2192 \u03b1\ntc_1 : true = true\ntc_2 : \u2203 u_0, Tendsto u_seq atTop (\ud835\udcdd u_0)\nl2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nu_limit : \u03b1\nN : \u2115\nhN : \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2 / 2\nm n : \u2115\nhm : m > N\nhn : n > N\nhN_m : \u03c1 (u_seq m) u_limit < \u03b5 / 2 / 2\nhN_n : \u03c1 (u_seq n) u_limit < \u03b5 / 2 / 2\nthis : \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)\n\u22a2 \u03c1 (u_seq n) u_limit < \u03b5 / 2\n\ncase h\u2082\n\u03b1 : Type u_1\n\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d\ninst\u271d : MetricSpace \u03b1\nu_seq : \u2115 \u2192 \u03b1\ntc_1 : true = true\ntc_2 : \u2203 u_0, Tendsto u_seq atTop (\ud835\udcdd u_0)\nl2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nu_limit : \u03b1\nN : \u2115\nhN : \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2 / 2\nm n : \u2115\nhm : m > N\nhn : n > N\nhN_m : \u03c1 (u_seq m) u_limit < \u03b5 / 2 / 2\nhN_n : \u03c1 (u_seq n) u_limit < \u03b5 / 2 / 2\nthis : \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)\n\u22a2 \u03c1 u_limit (u_seq m) < \u03b5 / 2"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The metric space setup correctly formalizes the mathematical structure with appropriate types and distance function.", "Convergence is properly captured using Mathlib's filter-based definition, which is equivalent to the natural language statement.", "The limit condition with \u03b5/2 bound is precisely translated, maintaining the specific mathematical constraint.", "The triangle inequality application is correctly formalized for the sequence elements and limit point.", "The conclusion correctly captures the Cauchy property that follows from the given premises, with proper quantifier structure.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2)\n  (l2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m)) :\n  \u2203 \u03b5 > 0, \u2200 N : \u2115, \u2203 (m n : \u2115), m > N \u2227 n > N \u2227 \u03c1 (u_seq n) (u_seq m) \u2265 \u03b5 := by\n  obtain \u27e8u_limit, h_limit\u27e9 := l1\n  use 1, zero_lt_one\n  intro N\n  have h_half := h_limit (1/4) (by linarith)\n  obtain \u27e8N', hN'\u27e9 := h_half\n  let m := max N N' + 1\n  have hm : m > N := by simp\n  have hm' : m > N' := by simp\n  have h\u03c1m : \u03c1 (u_seq m) u_limit < 1/4 / 2 := hN' m hm'\n  let n := m + 1\n  have hn : n > N := by linarith\n  have hn' : n > N' := by linarith\n  have h\u03c1n : \u03c1 (u_seq n) u_limit < 1/4 / 2 := hN' n hn'\n  use m, n\n  constructor\n  \u00b7 exact hm\n  constructor\n  \u00b7 exact hn\n  specialize l2 m n u_limit\n  have : \u03c1 (u_seq n) (u_seq m) < 1/4 / 2 + 1/4 / 2 := by linarith [h\u03c1m, h\u03c1n]\n  linarith"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Suppose that \\(\\lim_{n\\to\\infty}u_n=u\\). If \\(\\epsilon>0\\), there is an integer\n$N$ such that\n$\\rho(u_n,u)<\\epsilon/2$ if \\(n>N\\). Therefore, if \\(m\\), \\(n>N\\), then\n$$\n\\rho(u_n,u_m)\\le\\rho(u_n,u)+\\rho(u,u_m)<\\epsilon.\n$$", "statement": "We assume:\n\u2022 Let \\((A, \\rho)\\) be a metric space and let \\({u_n}\\) be a sequence of points in A [tc_1];\n\u2022 The sequence \\({u_n}\\) is convergent [tc_2];\n\u2022 There exists a limit u \u2208 A to which \\({u_n}\\) converges, and for any \u03b5 > 0, there exists an integer N such that for all n > N, \\(\\rho(u_n, u) < \\epsilon/2\\) [l1];\n\u2022 For any integers m, n, and for the limit point u, \\(\\rho(u_n, u_m) \\le \\rho(u_n, u) + \\rho(u, u_m)\\) [l2];\n\u2022 For a given \u03b5 > 0, let N be the integer from [l1]. For any integers m, n such that m > N and n > N, we have \\(\\rho(u_n, u_m) < \\epsilon\\) [l3].\nTherefore, we conclude:\n\u2022 The sequence \\({u_n}\\) is a Cauchy sequence [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2)\n  (l2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m))\n  (l3 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 (m n : \u2115), m > N \u2192 n > N \u2192 \u03c1 (u_seq n) (u_seq m) < \u03b5) :\n  CauchySeq u_seq := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2)\n  (l2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m))\n  (l3 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 (m n : \u2115), m > N \u2192 n > N \u2192 \u03c1 (u_seq n) (u_seq m) < \u03b5) :\n  CauchySeq u_seq := by\n  rw [Metric.cauchySeq_iff]\n  intro \u03b5 h\u03b5\n  obtain \u27e8N, hN\u27e9 := l3 \u03b5 h\u03b5\n  exists N\n  intro m n hm hn\n  exact hN m n hm hn", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 18, "column": 13, "endLine": 18, "endColumn": 14, "data": "application type mismatch\n  hN m n\nargument\n  n\nhas type\n  m \u2265 N : Prop\nbut is expected to have type\n  \u2115 : Type"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The metric space declaration uses both custom metric \u03c1 and MetricSpace typeclass, which is redundant but not contradictory", "Sequence declaration perfectly captures the natural language with appropriate type", "Convergence condition correctly formalized using Filter.Tendsto", "Limit condition with \u03b5/2 bound correctly formalized", "Triangle inequality correctly stated for the custom metric", "Cauchy condition correctly formalized with proper quantifier structure", "Conclusion correctly states CauchySeq property. Note: tc_1 appears to be an unused placeholder, and there's some redundancy between tc_2 and l1, but these don't affect the core logical meaning", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  {\u03b1 : Type*} (\u03c1 : \u03b1 \u2192 \u03b1 \u2192 \u211d) [MetricSpace \u03b1] (u_seq : \u2115 \u2192 \u03b1)\n  (tc_1 : true)\n  (tc_2 : \u2203 u_0 : \u03b1, Filter.Tendsto u_seq Filter.atTop (nhds u_0))\n  (l1 : \u2203 u_limit : \u03b1, \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n > N, \u03c1 (u_seq n) u_limit < \u03b5 / 2)\n  (l2 : \u2200 (m n : \u2115) (u_limit : \u03b1), \u03c1 (u_seq n) (u_seq m) \u2264 \u03c1 (u_seq n) u_limit + \u03c1 u_limit (u_seq m))\n  (l3 : \u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 (m n : \u2115), m > N \u2192 n > N \u2192 \u03c1 (u_seq n) (u_seq m) < \u03b5) :\n  \u00ac CauchySeq u_seq := by\n  intro h\n  have : CauchySeq u_seq := l3\n  exact absurd h this"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    