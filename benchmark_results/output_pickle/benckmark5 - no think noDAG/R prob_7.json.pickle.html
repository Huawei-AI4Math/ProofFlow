
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(\Omega, \mathcal{F}, \mu)$ be a measure space. Let $A_1, A_2 \in \mathcal{F}$ be two disjoint sets with measures $\mu(A_1) = 5$ and $\mu(A_2) = 3$. Let $f: \Omega 	o \mathbb{R}$ be a function defined by $f = 4 \cdot \mathbf{1}_{A_1} + 7 \cdot \mathbf{1}_{A_2}$. Then the Lebesgue integral of $f$ is $\int_\Omega f \, d\mu = 41$.

Proof: By linearity of the Lebesgue integral, we can decompose the integral of $f$ as $\int_\Omega f \, d\mu = \int_\Omega 4 \cdot \mathbf{1}_{A_1} \, d\mu + \int_\Omega 7 \cdot \mathbf{1}_{A_2} \, d\mu$. Based on the definition of the integral for a scaled indicator function, the first term evaluates to $\int_\Omega 4 \cdot \mathbf{1}_{A_1} \, d\mu = 4 \cdot \mu(A_1)$. Similarly, the second term evaluates to $\int_\Omega 7 \cdot \mathbf{1}_{A_2} \, d\mu = 7 \cdot \mu(A_2)$. Substituting these results into the sum gives the expression $\int_\Omega f \, d\mu = 4 \cdot \mu(A_1) + 7 \cdot \mu(A_2)$. Using the given measures $\mu(A_1) = 5$ and $\mu(A_2) = 3$, we calculate the final value as $\int_\Omega f \, d\mu = 4 \cdot 5 + 7 \cdot 3 = 41$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(\\Omega, \\mathcal{F}, \\mu)$ be a measure space.", "statement": "Premise:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (\u03a9 : Type*)\n  [MeasurableSpace \u03a9]\n  (\u03bc : MeasureTheory.Measure \u03a9)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the measure space structure. While it uses Lean's typeclass system and includes both MeasurableSpace and MeasureSpace (which provides some redundancy), it accurately represents the mathematical concept of a measure space (\u03a9, F, \u03bc). The extra typeclass declarations are consistent additional details that don't contradict the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $A_1, A_2 \\in \\mathcal{F}$ be two disjoint sets", "statement": "Premise:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (\u03a9 : Type*)\n  [MeasurableSpace \u03a9]\n  (\u03bc : MeasureTheory.Measure \u03a9)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (A1 A2 : Set \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the measure space structure with \u03a9 as the underlying type, MeasurableSpace \u03a9 providing the \u03c3-algebra structure (corresponding to \u2131), \u03bc as the measure, and MeasureTheory.MeasureSpace \u03a9 ensuring the complete measure space structure.", "The Lean formalization correctly represents A\u2081, A\u2082 \u2208 \u2131 through MeasurableSet A1 \u2227 MeasurableSet A2, which is the appropriate way to express set membership in the \u03c3-algebra in Lean's type system.", "The disjointness condition is directly and correctly captured by Disjoint A1 A2 in the Lean formalization."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "with measures $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$.", "statement": "Premise:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (\u03a9 : Type*)\n  [MeasurableSpace \u03a9]\n  (\u03bc : MeasureTheory.Measure \u03a9)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (A1 A2 : Set \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the measure space structure with \u03a9 as the underlying type, MeasurableSpace \u03a9 providing the \u03c3-algebra structure (corresponding to \u2131), and \u03bc as the measure. The MeasureSpace instance provides additional structure that is consistent with the mathematical concept.", "The Lean formalization correctly represents A1 and A2 as sets in \u03a9, with MeasurableSet conditions ensuring they belong to the \u03c3-algebra (corresponding to \u2131), and the Disjoint condition capturing the disjointness requirement. The variable names A1, A2 vs A_1, A_2 are just notational differences.", "The Lean formalization directly matches the measure conditions \u03bc A1 = 5 and \u03bc A2 = 3, expressed as a conjunction which is mathematically equivalent to the natural language statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "Let $f: \\Omega \\to \\mathbb{R}$ be a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$.", "statement": "Premise:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (\u03a9 : Type*)\n  [MeasurableSpace \u03a9]\n  (\u03bc : MeasureTheory.Measure \u03a9)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (A1 A2 : Set \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_4 : f = 4 * A1.indicator 1 + 7 * A2.indicator 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the measure space structure with MeasurableSpace, Measure, and MeasureSpace instances", "The Lean version correctly translates membership in \u03c3-algebra F as MeasurableSet and captures disjointness with the Disjoint predicate", "The measure values are exactly preserved in the Lean formalization", "The function definition is correctly formalized using Set.indicator, where A1.indicator 1 is equivalent to the characteristic/indicator function \ud835\udfd9_{A_1}"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "By linearity of the Lebesgue integral, we can decompose the integral of $f$ as $\\int_\\Omega f \\, d\\mu = \\int_\\Omega 4 \\cdot \\mathbf{1}_{A_1} \\, d\\mu + \\int_\\Omega 7 \\cdot \\mathbf{1}_{A_2} \\, d\\mu$.", "statement": "We assume:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4].\nTherefore, we conclude:\n\u2022 $\\int_\\Omega f \\, d\\mu = \\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu + \\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d))) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = fun x => (4 * (A1.indicator (fun _ => (1 : \u211d)) x) + 7 * (A2.indicator (fun _ => (1 : \u211d)) x))) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc := by\n  rw [tc_4]\n  simp_rw [MeasureTheory.integral_add]\n  \u00b7 congr\n  \u00b7 exact MeasureTheory.Integrable.const_mul (MeasureTheory.integrable_indicator tc_2.left (MeasureTheory.integrable_const (1 : \u211d))) (4 : \u211d)\n  \u00b7 exact MeasureTheory.Integrable.const_mul (MeasureTheory.integrable_indicator tc_2.right.left (MeasureTheory.integrable_const (1 : \u211d))) (7 : \u211d)", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 11, "endLine": 15, "endColumn": 37, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The measure space structure is correctly formalized with appropriate Lean types and instances.", "The disjoint measurable sets condition is accurately captured with the conjunction of measurability and disjointness.", "The measure values are exactly translated with proper equality statements.", "The function definition correctly uses Lean's indicator function notation to represent the characteristic functions.", "The integral equation conclusion perfectly captures the linearity property being demonstrated.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter MeasureTheory\n\nlemma l1_neg\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d))) :\n  \u00ac (\u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc) := by\n  simp [tc_4]\n  rw [integral_add]\n  \u00b7 rw [integral_mul_left, integral_mul_left]\n    simp [integral_indicator (fun _ => (1 : \u211d)) tc_2.1, integral_indicator (fun _ => (1 : \u211d)) tc_2.2.1, tc_3]\n    norm_num\n  \u00b7 exact (Measurable.aestronglyMeasurable (Measurable.const_mul (measurable_const.indicator tc_2.1) 4))\n  \u00b7 exact (Measurable.aestronglyMeasurable (Measurable.const_mul (measurable_const.indicator tc_2.2.1) 7))"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Based on the definition of the integral for a scaled indicator function, the first term evaluates to $\\int_\\Omega 4 \\cdot \\mathbf{1}_{A_1} \\, d\\mu = 4 \\cdot \\mu(A_1)$.", "statement": "We assume:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4];\n\u2022 $\\int_\\Omega f \\, d\\mu = \\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu + \\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu$ [l1].\nTherefore, we conclude:\n\u2022 $\\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu = 4 \\cdot \\mu(A_1)$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc) :\n  \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc) :\n  \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal := by\n  rw [MeasureTheory.integral_mul_left, MeasureTheory.integral_indicator (tc_2.left), MeasureTheory.set_integral_const]\n  simp [tc_3.left]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The measure space structure is correctly formalized with appropriate type declarations.", "Measurability and disjointness conditions are accurately translated.", "The measure value conditions are directly and correctly stated.", "The function definition using indicator functions is properly formalized.", "The integral decomposition property is accurately captured.", "The conclusion has a major inconsistency: the natural language states the equality as 4\u00b7\u03bc(A\u2081), but the Lean formalization uses (\u03bc A1).toReal, introducing a type conversion from ENNReal to Real that changes the mathematical meaning. The natural language treats \u03bc(A\u2081) as a real number directly, while Lean requires explicit conversion."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The measure space structure is correctly formalized with appropriate type declarations.', 'Measurability and disjointness conditions are accurately translated.', 'The measure value conditions are directly and correctly stated.', 'The function definition using indicator functions is properly formalized.', 'The integral decomposition property is accurately captured.', 'The conclusion has a major inconsistency: the natural language states the equality as 4\u00b7\u03bc(A\u2081), but the Lean formalization uses (\u03bc A1).toReal, introducing a type conversion from ENNReal to Real that changes the mathematical meaning. The natural language treats \u03bc(A\u2081) as a real number directly, while Lean requires explicit conversion.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Similarly, the second term evaluates to $\\int_\\Omega 7 \\cdot \\mathbf{1}_{A_2} \\, d\\mu = 7 \\cdot \\mu(A_2)$.", "statement": "We assume:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4];\n\u2022 $\\int_\\Omega f \\, d\\mu = \\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu + \\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu$ [l1];\n\u2022 $\\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu = 4 \\cdot \\mu(A_1)$ [l2].\nTherefore, we conclude:\n\u2022 $\\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu = 7 \\cdot \\mu(A_2)$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal) :\n  \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter MeasureTheory\n\nlemma l3\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal) :\n  \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal := by\n  have h : \u222b (x : \u03a9), f x \u2202\u03bc = 4 * (\u03bc A1).toReal + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc := by\n    rw [l1, l2]\n  rw [tc_4, integral_add (Measurable.aestronglyMeasurable (by measurability)) (Measurable.aestronglyMeasurable (by measurability)),\n      integral_mul_left, integral_mul_left, tc_3.left, tc_3.right] at h\n  simp only [ENNReal.toReal_ofNat, add_left_inj] at h\n  exact h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 12, "endLine": 17, "endColumn": 14, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u222b (x : \u03a9), 4 * A1.indicator (fun x => 1) x \u2202\u03bc\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nA1 A2 : Set \u03a9\nf : \u03a9 \u2192 \u211d\ntc_1 : MeasureSpace \u03a9\ntc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2\ntc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3\ntc_4 : f = (4 * A1.indicator fun x => 1) + 7 * A2.indicator fun x => 1\nl1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * A1.indicator fun x => 1) x \u2202\u03bc + \u222b (x : \u03a9), (7 * A2.indicator fun x => 1) x \u2202\u03bc\nl2 : \u222b (x : \u03a9), 4 * A1.indicator (fun x => 1) x \u2202\u03bc = 4 * (\u03bc A1).toReal\n\u22a2 \u222b (x : \u03a9), (4 * A1.indicator fun x => 1) x \u2202\u03bc + \u222b (x : \u03a9), (7 * A2.indicator fun x => 1) x \u2202\u03bc =\n    4 * (\u03bc A1).toReal + \u222b (x : \u03a9), (7 * A2.indicator fun x => 1) x \u2202\u03bc"}, {"line": 18, "column": 25, "endLine": 18, "endColumn": 77, "data": "application type mismatch\n  integral_add (Measurable.aestronglyMeasurable ?m.2769)\nargument\n  Measurable.aestronglyMeasurable ?m.2769\nhas type\n  AEStronglyMeasurable ?m.2445 ?m.2447 : Prop\nbut is expected to have type\n  Integrable ?m.2438 ?m.2437 : Prop"}, {"line": 18, "column": 12, "endLine": 18, "endColumn": 130, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u222b (a : ?m.2432), ?m.2438 a + ?m.2439 a \u2202?m.2437\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc : Measure \u03a9\nA1 A2 : Set \u03a9\nf : \u03a9 \u2192 \u211d\ntc_1 : MeasureSpace \u03a9\ntc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2\ntc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3\ntc_4 : f = (4 * A1.indicator fun x => 1) + 7 * A2.indicator fun x => 1\nl1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * A1.indicator fun x => 1) x \u2202\u03bc + \u222b (x : \u03a9), (7 * A2.indicator fun x => 1) x \u2202\u03bc\nl2 : \u222b (x : \u03a9), 4 * A1.indicator (fun x => 1) x \u2202\u03bc = 4 * (\u03bc A1).toReal\nh :\n  \u222b (x : \u03a9), ((4 * A1.indicator fun x => 1) + 7 * A2.indicator fun x => 1) x \u2202\u03bc =\n    4 * (\u03bc A1).toReal + \u222b (x : \u03a9), (7 * A2.indicator fun x => 1) x \u2202\u03bc\n\u22a2 \u222b (x : \u03a9), 7 * A2.indicator (fun x => 1) x \u2202\u03bc = 7 * (\u03bc A2).toReal"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The measure space structure is correctly formalized with appropriate type classes.", "Measurability and disjointness conditions are properly captured.", "Measure values are directly translated.", "Function definition using indicator functions is correctly formalized.", "Integral decomposition properly represents linearity.", "The integral computation introduces .toReal conversion not mentioned in natural language, creating a slight structural difference in how measures are handled.", "The conclusion similarly uses .toReal conversion, maintaining consistency with l2 but deviating from the natural language presentation.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.71 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l3\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal) :\n  \u00ac (\u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal) := by\n  have h1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc := by rw [tc_4]\n  have h2 : \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc = \n            \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc := by\n    exact MeasureTheory.integral_add (MeasureTheory.integrable_indicator_const tc_2.1 _) (MeasureTheory.integrable_indicator_const tc_2.2.1 _)\n  rw [h1, h2] at l1\n  rw [l2] at l1\n  simp [tc_3]\n  norm_num at l1\n  intro h\n  rw [h] at l1\n  norm_num at l1"}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Substituting these results into the sum gives the expression $\\int_\\Omega f \\, d\\mu = 4 \\cdot \\mu(A_1) + 7 \\cdot \\mu(A_2)$.", "statement": "We assume:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4];\n\u2022 $\\int_\\Omega f \\, d\\mu = \\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu + \\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu$ [l1];\n\u2022 $\\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu = 4 \\cdot \\mu(A_1)$ [l2];\n\u2022 $\\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu = 7 \\cdot \\mu(A_2)$ [l3].\nTherefore, we conclude:\n\u2022 $\\int_\\Omega f \\, d\\mu = 4 \\cdot \\mu(A_1) + 7 \\cdot \\mu(A_2)$ [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal)\n  (l3 : \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal + (7 : \u211d) * (\u03bc A2).toReal := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal)\n  (l3 : \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal + (7 : \u211d) * (\u03bc A2).toReal := by\n  rw [l1]\n  congr\n  rw [l2, l3]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 6, "endLine": 19, "endColumn": 8, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical content and logical structure of the natural language premise. However, there's a minor inconsistency in that the natural language presents measures as real numbers (\u03bc(A1) = 5, \u03bc(A2) = 3), while the Lean code treats them as extended non-negative reals requiring .toReal conversion. This is mathematically sound but represents a structural difference in type handling that wasn't explicit in the natural language.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the mathematical content and logical structure of the natural language premise. However, there's a minor inconsistency in that the natural language presents measures as real numbers (\u03bc(A1) = 5, \u03bc(A2) = 3), while the Lean code treats them as extended non-negative reals requiring .toReal conversion. This is mathematically sound but represents a structural difference in type handling that wasn't explicit in the natural language.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "Using the given measures $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$, we calculate the final value as $\\int_\\Omega f \\, d\\mu = 4 \\cdot 5 + 7 \\cdot 3$.", "statement": "We assume:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4];\n\u2022 $\\int_\\Omega f \\, d\\mu = \\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu + \\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu$ [l1];\n\u2022 $\\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu = 4 \\cdot \\mu(A_1)$ [l2];\n\u2022 $\\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu = 7 \\cdot \\mu(A_2)$ [l3];\n\u2022 $\\int_\\Omega f \\, d\\mu = 4 \\cdot \\mu(A_1) + 7 \\cdot \\mu(A_2)$ [l4].\nTherefore, we conclude:\n\u2022 $\\int_\\Omega f \\, d\\mu = 4 \\cdot 5 + 7 \\cdot 3$ [l5].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal)\n  (l3 : \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal)\n  (l4 : \u222b (x : \u03a9), f x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal + (7 : \u211d) * (\u03bc A2).toReal) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = 4 * 5 + 7 * 3 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal)\n  (l3 : \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal)\n  (l4 : \u222b (x : \u03a9), f x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal + (7 : \u211d) * (\u03bc A2).toReal) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = 4 * 5 + 7 * 3 := by\n  rw [l4, tc_3.1, tc_3.2]\n  norm_cast", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The measure space setup correctly captures (\u03a9, \u2131, \u03bc) with appropriate Lean types.", "Disjoint measurable sets are properly expressed with MeasurableSet and Disjoint conditions.", "The measure values \u03bc(A\u2081) = 5 and \u03bc(A\u2082) = 3 are correctly stated.", "The function definition using indicator functions is properly formalized with Set.indicator.", "The integral decomposition correctly uses linearity of integration.", "The integral evaluations are correct but introduce .toReal conversions not explicit in natural language.", "The combined formula maintains the .toReal conversion pattern from l2 and l3.", "The conclusion has a type inconsistency - it should use .toReal conversions to match the premises, or the premises should be stated differently to work with real-valued measures directly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The measure space setup correctly captures (\u03a9, \u2131, \u03bc) with appropriate Lean types.', 'Disjoint measurable sets are properly expressed with MeasurableSet and Disjoint conditions.', 'The measure values \u03bc(A\u2081) = 5 and \u03bc(A\u2082) = 3 are correctly stated.', 'The function definition using indicator functions is properly formalized with Set.indicator.', 'The integral decomposition correctly uses linearity of integration.', 'The integral evaluations are correct but introduce .toReal conversions not explicit in natural language.', 'The combined formula maintains the .toReal conversion pattern from l2 and l3.', 'The conclusion has a type inconsistency - it should use .toReal conversions to match the premises, or the premises should be stated differently to work with real-valued measures directly.']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "= 41.", "statement": "We assume:\n\u2022 $(\\Omega, \\mathcal{F}, \\mu)$ is a measure space [tc_1];\n\u2022 $A_1, A_2 \\in \\mathcal{F}$ are two disjoint sets [tc_2];\n\u2022 $\\mu(A_1) = 5$ and $\\mu(A_2) = 3$ [tc_3];\n\u2022 $f: \\Omega \\to \\mathbb{R}$ is a function defined by $f = 4 \\cdot \\mathbf{1}_{A_1} + 7 \\cdot \\mathbf{1}_{A_2}$ [tc_4];\n\u2022 $\\int_\\Omega f \\, d\\mu = \\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu + \\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu$ [l1];\n\u2022 $\\int_\\Omega (4 \\cdot \\mathbf{1}_{A_1}) \\, d\\mu = 4 \\cdot \\mu(A_1)$ [l2];\n\u2022 $\\int_\\Omega (7 \\cdot \\mathbf{1}_{A_2}) \\, d\\mu = 7 \\cdot \\mu(A_2)$ [l3];\n\u2022 $\\int_\\Omega f \\, d\\mu = 4 \\cdot \\mu(A_1) + 7 \\cdot \\mu(A_2)$ [l4];\n\u2022 $\\int_\\Omega f \\, d\\mu = 4 \\cdot 5 + 7 \\cdot 3$ [l5].\nTherefore, we conclude:\n\u2022 $\\int_\\Omega f \\, d\\mu = 41$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal)\n  (l3 : \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal)\n  (l4 : \u222b (x : \u03a9), f x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal + (7 : \u211d) * (\u03bc A2).toReal)\n  (l5 : \u222b (x : \u03a9), f x \u2202\u03bc = 4 * 5 + 7 * 3) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = 41 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (\u03a9 : Type*) [MeasurableSpace \u03a9] (\u03bc : MeasureTheory.Measure \u03a9)\n  (A1 A2 : Set \u03a9)\n  (f : \u03a9 \u2192 \u211d)\n  (tc_1 : MeasureTheory.MeasureSpace \u03a9)\n  (tc_2 : MeasurableSet A1 \u2227 MeasurableSet A2 \u2227 Disjoint A1 A2)\n  (tc_3 : \u03bc A1 = 5 \u2227 \u03bc A2 = 3)\n  (tc_4 : f = 4 * (A1.indicator fun _ => (1 : \u211d)) + 7 * (A2.indicator fun _ => (1 : \u211d)))\n  (l1 : \u222b (x : \u03a9), f x \u2202\u03bc = \u222b (x : \u03a9), (4 * (A1.indicator fun _ => (1 : \u211d))) x \u2202\u03bc + \u222b (x : \u03a9), (7 * (A2.indicator fun _ => (1 : \u211d))) x \u2202\u03bc)\n  (l2 : \u222b (x : \u03a9), (4 : \u211d) * (A1.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal)\n  (l3 : \u222b (x : \u03a9), (7 : \u211d) * (A2.indicator fun _ => (1 : \u211d)) x \u2202\u03bc = (7 : \u211d) * (\u03bc A2).toReal)\n  (l4 : \u222b (x : \u03a9), f x \u2202\u03bc = (4 : \u211d) * (\u03bc A1).toReal + (7 : \u211d) * (\u03bc A2).toReal)\n  (l5 : \u222b (x : \u03a9), f x \u2202\u03bc = 4 * 5 + 7 * 3) :\n  \u222b (x : \u03a9), f x \u2202\u03bc = 41 := by\n  rw [l5]\n  norm_num", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The measure space concept is correctly captured with MeasurableSpace and MeasureTheory.MeasureSpace", "Disjointness and measurability of sets A1, A2 are properly formalized", "The specific measure values \u03bc(A1) = 5 and \u03bc(A2) = 3 are directly translated", "The function definition using indicator functions is correctly represented in Lean syntax", "Linearity of integration is properly expressed in both versions", "The integral formula is correct but uses .toReal conversion which suggests technical handling of extended reals vs reals", "Same issue as l2 - the .toReal conversion is a minor technical difference from treating measures as reals directly", "The combined formula correctly follows from previous steps", "The numerical substitution is correctly represented", "The final conclusion matches perfectly"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    