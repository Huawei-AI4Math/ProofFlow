
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Suppose that $\mathbf{F}:\R^n	o\R^n$ is continuously
differentiable on a neighborhood of $\mathbf{X}_0$
 and $\mathbf{F}'(\mathbf{X}_0)$ is nonsingular$.$ Let
\begin{equation}\label{eq:6.2.14}
r=\frac{1}{\|(\mathbf{F}'(\mathbf{X}_0))^{-1}\|}.
\end{equation}
Then$,$ for every $\epsilon>0,$ there is a $\delta>0$ such that
\begin{equation}\label{eq:6.2.15}
|\mathbf{F}(\mathbf{X})-\mathbf{F}(\mathbf{Y})|\ge (r-\epsilon)
|\mathbf{X}-\mathbf{Y}|\mbox{\quad if\quad} \mathbf{X},\mathbf{Y}\in
B_\delta(\mathbf{X}_{0}).
\end{equation}

Proof: Let $\mathbf{X}$  and $\mathbf{Y}$ be arbitrary points in
$D_\mathbf{F}$  and let $\mathbf{G}$ be as in \eqref{eq:6.2.9}. From
\eqref{eq:6.2.13},
\begin{equation} \label{eq:6.2.16}
|\mathbf{F}(\mathbf{X})-\mathbf{F}(\mathbf{Y})|\ge\big|
|\mathbf{F}'(\mathbf{X}_0)(\mathbf{X}
-\mathbf{Y})|-|\mathbf{G}(\mathbf{X})-\mathbf{G}(\mathbf{Y})|\big|,
\end{equation}
Since
$$
\mathbf{X}-\mathbf{Y}=[\mathbf{F}'(\mathbf{X}_0)]^{-1}
\mathbf{F}'(\mathbf{X}_{0})
(\mathbf{X}-\mathbf{Y}),
$$
\eqref{eq:6.2.14} implies that
$$
|\mathbf{X}-\mathbf{Y}|\le \frac{1}{ r} |\mathbf{F}'(\mathbf{X}_0)
(\mathbf{X}-\mathbf{Y}|,
$$
so
\begin{equation}\label{eq:6.2.17}
|\mathbf{F}'(\mathbf{X}_0)(\mathbf{X}-\mathbf{Y})|\ge r|\mathbf{X}-\mathbf{Y}|.
\end{equation}
 Now choose $\delta>0$ so that \eqref{eq:6.2.12} holds.
Then \eqref{eq:6.2.16}  and \eqref{eq:6.2.17} imply \eqref{eq:6.2.15}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Suppose that $\\mathbf{F}:\\R^n\\to\\R^n$ is continuously differentiable on a neighborhood of $\\mathbf{X}_0$", "statement": "Premise:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is a function that is continuously differentiable on a neighborhood of a point $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : ContDiffAt \u211d 1 F X\u2080)", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean type (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d) correctly represents \u211d\u207f \u2192 \u211d\u207f, as (Fin n \u2192 \u211d) is the standard way to represent \u211d\u207f in Lean", "The natural language states 'continuously differentiable on a neighborhood of X\u2080' while Lean uses 'ContDiffAt \u211d 1 F X\u2080' which means continuously differentiable at the point X\u2080. ContDiffAt captures the neighborhood property implicitly, but the phrasing is slightly different from the explicit 'on a neighborhood' statement", "X\u2080 : Fin n \u2192 \u211d correctly represents X\u2080 \u2208 \u211d\u207f, as (Fin n \u2192 \u211d) is equivalent to \u211d\u207f in Lean's type system"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "$\\mathbf{F}'(\\mathbf{X}_0)$ is nonsingular$.$", "statement": "Premise:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is a function that is continuously differentiable on a neighborhood of a point $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The derivative of $\\mathbf{F}$ at $\\mathbf{X}_0$, denoted $\\mathbf{F}'(\\mathbf{X}_0)$, is a nonsingular linear map [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : ContDiffAt \u211d 1 F X\u2080)\n(tc_2 : Invertible (fderiv \u211d F X\u2080))", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical statement. The function F is typed as (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d) which represents \u211d\u207f \u2192 \u211d\u207f, and ContDiffAt \u211d 1 F X\u2080 means F is continuously differentiable (C\u00b9) at X\u2080, which is equivalent to being continuously differentiable on a neighborhood of X\u2080.", "The Lean formalization correctly captures that the derivative is nonsingular. In Lean, fderiv \u211d F X\u2080 represents the Fr\u00e9chet derivative of F at X\u2080, and Invertible means it has an inverse, which is exactly what nonsingular means for a linear map."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "Let\n\\begin{equation}\\label{eq:6.2.14}\nr=\\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}.\n\\end{equation}", "statement": "Premise:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is a function that is continuously differentiable on a neighborhood of a point $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The derivative of $\\mathbf{F}$ at $\\mathbf{X}_0$, denoted $\\mathbf{F}'(\\mathbf{X}_0)$, is a nonsingular linear map [tc_2];\n\u2022 $r$ is a real number defined as $r = \\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}$, where $\\|\\cdot\\|$ is the operator norm [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : ContDiffAt \u211d 1 F X\u2080)\n(tc_2 : Invertible (fderiv \u211d F X\u2080))\n(r : \u211d)\n(tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly represents F as a function from (Fin n \u2192 \u211d) to (Fin n \u2192 \u211d), which is equivalent to \u211d\u207f \u2192 \u211d\u207f. ContDiffAt \u211d 1 F X\u2080 correctly captures continuous differentiability at X\u2080.", "Invertible (fderiv \u211d F X\u2080) correctly captures that the derivative is nonsingular (invertible). The fderiv represents the Fr\u00e9chet derivative, which is the appropriate formalization of F'(X\u2080).", "The operator norm is implicitly used in Lean's \u2016\u00b7\u2016 notation for continuous linear maps, which is appropriate here.", "The Lean formalization r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016 correctly captures the definition, where \u215f represents the inverse operator. The declaration r : \u211d establishes it as a real number."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "let $\\mathbf{G}$ be as in \\eqref{eq:6.2.9}.", "statement": "We assume:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is a function that is continuously differentiable on a neighborhood of a point $\\mathbf{X}_0 \\in \\mathbb{R}^n$ [tc_1];\n\u2022 The derivative of $\\mathbf{F}$ at $\\mathbf{X}_0$, denoted $\\mathbf{F}'(\\mathbf{X}_0)$, is a nonsingular linear map [tc_2];\n\u2022 $r$ is a real number defined as $r = \\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}$, where $\\|\\cdot\\|$ is the operator norm [tc_3].\nDefinition:\n\u2022 Let $\\mathbf{G}:\\mathbb{R}^n \\to \\mathbb{R}^n$ be a function defined by $\\mathbf{G}(\\mathbf{X}) = \\mathbf{F}'(\\mathbf{X}_0)\\mathbf{X} - \\mathbf{F}(\\mathbf{X})$. This definition is inferred from the reference to (6.2.9) and its use in the proof [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : ContDiffAt \u211d 1 F X\u2080)\n(tc_2 : Invertible (fderiv \u211d F X\u2080))\n(r : \u211d)\n(tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n(def_1 : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n(def_1_axiom : \u2200 X, def_1 X = (fderiv \u211d F X\u2080) X - F X)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The Lean formalization correctly captures continuous differentiability at X\u2080 using ContDiffAt with degree 1, which is equivalent to the natural language statement", "Invertible (fderiv \u211d F X\u2080) correctly captures that the derivative is nonsingular (invertible), which is equivalent to being a nonsingular linear map", "The operator norm is implicitly used in Lean through the \u2016\u00b7\u2016 notation, which matches the natural language specification", "The Lean formalization correctly defines r as 1 divided by the norm of the inverse of the derivative, using \u215f for inverse which matches the mathematical expression", "The mathematical content is identical, but the natural language uses G while Lean uses def_1 as the function name. This is a minor notational difference that doesn't affect the mathematical meaning"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From \\eqref{eq:6.2.13},\n\\begin{equation} \\label{eq:6.2.16}\n|\\mathbf{F}(\\mathbf{X})-\\mathbf{F}(\\mathbf{Y})|\\ge\\big|\n|\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}\n-\\mathbf{Y})|-|\\mathbf{G}(\\mathbf{X})-\\mathbf{G}(\\mathbf{Y})|\\big|,\n\\end{equation}", "statement": "We assume:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is continuously differentiable near $\\mathbf{X}_0$ [tc_1];\n\u2022 $\\mathbf{F}'(\\mathbf{X}_0)$ is nonsingular [tc_2];\n\u2022 $r = \\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}$ [tc_3];\n\u2022 $\\mathbf{G}(\\mathbf{X}) = \\mathbf{F}'(\\mathbf{X}_0)\\mathbf{X} - \\mathbf{F}(\\mathbf{X})$ [def_1].\nTherefore, we conclude:\n\u2022 For any $\\mathbf{X}, \\mathbf{Y}$ in the domain of $\\mathbf{F}$, $|\\mathbf{F}(\\mathbf{X})-\\mathbf{F}(\\mathbf{Y})| \\ge \\big| |\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})| - |\\mathbf{G}(\\mathbf{X})-\\mathbf{G}(\\mathbf{Y})| \\big|$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X, G X = (fderiv \u211d F X\u2080) X - F X)\n  (X Y : Fin n \u2192 \u211d) :\n  \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X, G X = (fderiv \u211d F X\u2080) X - F X)\n  (X Y : Fin n \u2192 \u211d) :\n  \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016 := by\n  have hG : \u2200 X, G X = (fderiv \u211d F X\u2080) X - F X := def_1_axiom\n  simp_rw [hG, Pi.sub_apply, \u2190 sub_sub_sub_comm]\n  rw [norm_sub_rev]\n  have := norm_sub_norm_le (fderiv \u211d F X\u2080 (X - Y)) (F X - F Y)\n  rw [\u2190 norm_neg (F X - F Y), neg_sub, norm_sub_rev, norm_sub_rev] at this\n  exact this", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 15, "endLine": 16, "endColumn": 27, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The continuous differentiability condition has a slight difference: natural language says 'near X\u2080' (suggesting a neighborhood) while Lean uses 'ContDiffAt' (at the point X\u2080). This is a minor structural difference in how the locality is expressed.", "The nonsingularity condition perfectly matches - nonsingular corresponds exactly to Invertible, and fderiv correctly represents the derivative F'(X\u2080).", "The definition of parameter r matches perfectly - the inverse operation and norm are correctly represented.", "The definition of function G matches perfectly - the universal quantification properly captures that the definition holds for all X.", "The main inequality conclusion matches perfectly - all norm operations, the inequality structure, and the nested absolute value expressions are correctly represented.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X, G X = (fderiv \u211d F X\u2080) X - F X) :\n  \u2203 X Y : Fin n \u2192 \u211d, \u2016F X - F Y\u2016 < \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016 := by\n  let F : (Fin 1 \u2192 \u211d) \u2192 Fin 1 \u2192 \u211d := fun x => x\n  let X\u2080 : Fin 1 \u2192 \u211d := fun _ => 0\n  have tc_1 : ContDiffAt \u211d 1 F X\u2080 := by\n    apply contDiffAt_id\n  have tc_2 : Invertible (fderiv \u211d F X\u2080) := by\n    simp [fderiv]\n    apply Invertible.of_invertible_id\n  let r : \u211d := 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016\n  have tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016 := rfl\n  let G : (Fin 1 \u2192 \u211d) \u2192 Fin 1 \u2192 \u211d := fun X => (fderiv \u211d F X\u2080) X - F X\n  have def_1_axiom : \u2200 X, G X = (fderiv \u211d F X\u2080) X - F X := fun _ => rfl\n  let X : Fin 1 \u2192 \u211d := fun _ => 1\n  let Y : Fin 1 \u2192 \u211d := fun _ => 0\n  refine \u27e8X, Y, ?_\u27e9\n  simp [F, X, Y, G, fderiv]\n  norm_num"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since\n$$\n\\mathbf{X}-\\mathbf{Y}=[\\mathbf{F}'(\\mathbf{X}_0)]^{-1}\n\\mathbf{F}'(\\mathbf{X}_{0})\n(\\mathbf{X}-\\mathbf{Y}),\n$$\n\\eqref{eq:6.2.14} implies that\n$$\n|\\mathbf{X}-\\mathbf{Y}|\\le \\frac{1}{ r} |\\mathbf{F}'(\\mathbf{X}_0)\n(\\mathbf{X}-\\mathbf{Y})|,", "statement": "We assume:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is continuously differentiable near $\\mathbf{X}_0$ [tc_1];\n\u2022 $\\mathbf{F}'(\\mathbf{X}_0)$ is nonsingular [tc_2];\n\u2022 $r = \\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}$ [tc_3];\n\u2022 $\\mathbf{G}(\\mathbf{X}) = \\mathbf{F}'(\\mathbf{X}_0)\\mathbf{X} - \\mathbf{F}(\\mathbf{X})$ [def_1];\n\u2022 $|\\mathbf{F}(\\mathbf{X})-\\mathbf{F}(\\mathbf{Y})| \\ge \\big| |\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})| - |\\mathbf{G}(\\mathbf{X})-\\mathbf{G}(\\mathbf{Y})| \\big|$ [l1].\nTherefore, we conclude:\n\u2022 $|\\mathbf{X}-\\mathbf{Y}| \\le \\frac{1}{r} |\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})|$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d) (X Y : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X', G X' = (fderiv \u211d F X\u2080) X' - F X')\n  (l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016) :\n  \u2016X - Y\u2016 \u2264 (1 / r) * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d) (X Y : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X', G X' = (fderiv \u211d F X\u2080) X' - F X')\n  (l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016) :\n  \u2016X - Y\u2016 \u2264 (1 / r) * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 := by\n  have h1 : X - Y = \u215f(fderiv \u211d F X\u2080) (fderiv \u211d F X\u2080 (X - Y)) := by\n    rw [\u2190 LinearMap.comp_apply, invOf_comp (fderiv \u211d F X\u2080)]\n    simp [LinearMap.id_apply]\n  rw [h1, tc_3, one_div_one_div]\n  calc\n    \u2016\u215f(fderiv \u211d F X\u2080) (fderiv \u211d F X\u2080 (X - Y))\u2016 \u2264 \u2016\u215f(fderiv \u211d F X\u2080)\u2016 * \u2016fderiv \u211d F X\u2080 (X - Y)\u2016 :=\n      ContinuousLinearMap.le_op_norm _ _\n    _ = (1 / r) * \u2016fderiv \u211d F X\u2080 (X - Y)\u2016 := by rw [\u2190 tc_3, norm_invOf]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 8, "endLine": 16, "endColumn": 30, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?f (?g ?x)\nn : \u2115\nF : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\nX\u2080 X Y : Fin n \u2192 \u211d\ntc_1 : ContDiffAt \u211d 1 F X\u2080\ntc_2 : Invertible (fderiv \u211d F X\u2080)\nr : \u211d\ntc_3 : r = 1 / \u2016\u215f(fderiv \u211d F X\u2080)\u2016\nG : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\ndef_1_axiom : \u2200 (X' : Fin n \u2192 \u211d), G X' = (fderiv \u211d F X\u2080) X' - F X'\nl1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016\n\u22a2 X - Y = \u215f(fderiv \u211d F X\u2080) ((fderiv \u211d F X\u2080) (X - Y))"}, {"line": 22, "column": 52, "endLine": 22, "endColumn": 58, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  1 / \u2016\u215f(fderiv \u211d F X\u2080)\u2016\nn : \u2115\nF : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\nX\u2080 X Y : Fin n \u2192 \u211d\ntc_1 : ContDiffAt \u211d 1 F X\u2080\ntc_2 : Invertible (fderiv \u211d F X\u2080)\nr : \u211d\ntc_3 : r = 1 / \u2016\u215f(fderiv \u211d F X\u2080)\u2016\nG : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\ndef_1_axiom : \u2200 (X' : Fin n \u2192 \u211d), G X' = (fderiv \u211d F X\u2080) X' - F X'\nl1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016\nh1 : X - Y = \u215f(fderiv \u211d F X\u2080) ((fderiv \u211d F X\u2080) (X - Y))\n\u22a2 \u2016\u215f(fderiv \u211d F X\u2080)\u2016 * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 = 1 / r * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016"}, {"line": 14, "column": 51, "endLine": 22, "endColumn": 71, "data": "unsolved goals\ncase calc.step\nn : \u2115\nF : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\nX\u2080 X Y : Fin n \u2192 \u211d\ntc_1 : ContDiffAt \u211d 1 F X\u2080\ntc_2 : Invertible (fderiv \u211d F X\u2080)\nr : \u211d\ntc_3 : r = 1 / \u2016\u215f(fderiv \u211d F X\u2080)\u2016\nG : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\ndef_1_axiom : \u2200 (X' : Fin n \u2192 \u211d), G X' = (fderiv \u211d F X\u2080) X' - F X'\nl1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016\nh1 : X - Y = \u215f(fderiv \u211d F X\u2080) ((fderiv \u211d F X\u2080) (X - Y))\n\u22a2 1 / r * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2264\n    \u2016\u215f(fderiv \u211d F X\u2080)\u2016 * \u2016(fderiv \u211d F X\u2080) (\u215f(fderiv \u211d F X\u2080) ((fderiv \u211d F X\u2080) (X - Y)))\u2016"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The function type and continuous differentiability condition are correctly captured. ContDiffAt \u211d 1 F X\u2080 properly represents continuous differentiability at X\u2080.", "The nonsingularity condition is correctly translated. Invertible (fderiv \u211d F X\u2080) is the appropriate way to express that the derivative is nonsingular in Lean.", "The definition of r is correctly formalized. The notation \u215f represents matrix/operator inverse, and the norm is properly applied.", "The definition of G is correctly captured with universal quantification over X'. The linear operator application and subtraction are properly represented.", "The inequality l1 is correctly formalized. The absolute value bars in natural language correspond to norms in Lean, and the nested absolute value structure is preserved with \u2016\u2016...\u2016 - \u2016...\u2016\u2016.", "The conclusion l2 is correctly stated. The inequality direction, the factor 1/r, and the norm of the derivative applied to the difference are all properly captured.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d) (X Y : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X', G X' = (fderiv \u211d F X\u2080) X' - F X')\n  (l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016) :\n  \u2203 X Y, \u00ac(\u2016X - Y\u2016 \u2264 (1 / r) * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016) := by\n  let F : (Fin 1 \u2192 \u211d) \u2192 (Fin 1 \u2192 \u211d) := fun _ => 0\n  let X\u2080 : Fin 1 \u2192 \u211d := fun _ => 0\n  let X : Fin 1 \u2192 \u211d := fun _ => 1\n  let Y : Fin 1 \u2192 \u211d := fun _ => 0\n  have tc_1 : ContDiffAt \u211d 1 F X\u2080 := contDiffAt_const\n  have tc_2 : Invertible (fderiv \u211d F X\u2080) := by\n    simp [fderiv_const]\n    exact invertibleOne\n  have r := 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016\n  have tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016 := rfl\n  let G : (Fin 1 \u2192 \u211d) \u2192 (Fin 1 \u2192 \u211d) := fun X' => (fderiv \u211d F X\u2080) X' - F X'\n  have def_1_axiom : \u2200 X', G X' = (fderiv \u211d F X\u2080) X' - F X' := fun _ => rfl\n  have l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016 := by\n    simp [F, fderiv_const]\n    norm_num\n  refine \u27e8fun _ => 1, fun _ => 0, ?_\u27e9\n  simp [fderiv_const, X, Y]\n  norm_num\n  rw [tc_3]\n  simp [r]\n  norm_num"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "so\n\\begin{equation}\\label{eq:6.2.17}\n|\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})|\\ge r|\\mathbf{X}-\\mathbf{Y}|.\n\\end{equation}", "statement": "We assume:\n\u2022 $r = \\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}$ [tc_3];\n\u2022 $|\\mathbf{X}-\\mathbf{Y}| \\le \\frac{1}{r} |\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})|$ [l2].\nTherefore, we conclude:\n\u2022 $|\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})| \\ge r|\\mathbf{X}-\\mathbf{Y}|$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d) (X Y : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (def_1 : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X', def_1 X' = (fderiv \u211d F X\u2080) X' - F X')\n  (l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016def_1 X - def_1 Y\u2016\u2016)\n  (l2 : \u2016X - Y\u2016 \u2264 (1 / r) * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016) :\n  \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2265 r * \u2016X - Y\u2016 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d) (X Y : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (def_1 : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X', def_1 X' = (fderiv \u211d F X\u2080) X' - F X')\n  (l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016def_1 X - def_1 Y\u2016\u2016)\n  (l2 : \u2016X - Y\u2016 \u2264 (1 / r) * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016) :\n  \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2265 r * \u2016X - Y\u2016 := by\n  rw [tc_3]\n  simp only [one_div]\n  have h : \u2016(\u215f(fderiv \u211d F X\u2080))\u2016 \u2260 0 := by\n    intro h'\n    have := IsUnit.ne_zero (invertible_iff_isUnit.mp tc_2)\n    simp [h'] at this\n  rwa [\u2190 mul_le_mul_left (norm_pos_iff.mpr h), mul_assoc, mul_comm \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016, \n    \u2190 mul_assoc, inv_mul_cancel h, one_mul] at l2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 28, "endLine": 20, "endColumn": 52, "data": "unknown identifier 'invertible_iff_isUnit.mp'"}, {"line": 22, "column": 47, "endLine": 22, "endColumn": 56, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a * ?b * ?c\nn : \u2115\nF : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\nX\u2080 X Y : Fin n \u2192 \u211d\ntc_1 : ContDiffAt \u211d 1 F X\u2080\ntc_2 : Invertible (fderiv \u211d F X\u2080)\nr : \u211d\ntc_3 : r = 1 / \u2016\u215f(fderiv \u211d F X\u2080)\u2016\ndef_1 : (Fin n \u2192 \u211d) \u2192 Fin n \u2192 \u211d\ndef_1_axiom : \u2200 (X' : Fin n \u2192 \u211d), def_1 X' = (fderiv \u211d F X\u2080) X' - F X'\nl1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016def_1 X - def_1 Y\u2016\u2016\nl2 : \u2016\u2016\u215f(fderiv \u211d F X\u2080)\u2016\u2016 * \u2016X - Y\u2016 \u2264 \u2016\u2016\u215f(fderiv \u211d F X\u2080)\u2016\u2016 * (1 / r * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016)\nh : \u2016\u215f(fderiv \u211d F X\u2080)\u2016 \u2260 0\n\u22a2 \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2265 \u2016\u215f(fderiv \u211d F X\u2080)\u2016\u207b\u00b9 * \u2016X - Y\u2016"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Variable declarations correctly represent vectors as functions from finite index sets to reals, which is the standard mathematical representation in Lean.", "The definition of r is accurately translated, with fderiv representing the derivative and \u215f representing the inverse operator.", "The inequality constraint l2 is correctly formalized with proper norm notation and maintains the exact mathematical relationship.", "The target conclusion l3 is precisely stated as the goal, correctly translating the inequality relationship.", "Additional technical conditions like differentiability and invertibility are mathematically necessary and implicit in the natural language context - their inclusion strengthens rather than contradicts the formalization.", "The overall logical structure from assumptions to conclusion is faithfully preserved in the lemma format.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d) (X Y : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (def_1 : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_1_axiom : \u2200 X', def_1 X' = (fderiv \u211d F X\u2080) X' - F X')\n  (l1 : \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016def_1 X - def_1 Y\u2016\u2016)\n  (l2 : \u2016X - Y\u2016 \u2264 (1 / r) * \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016) :\n  \u00ac(\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2265 r * \u2016X - Y\u2016) := by\n  simp [not_le]\n  rw [tc_3]\n  simp [norm_inv]\n  rw [mul_comm]\n  exact l2"}, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "Now choose $\\delta>0$ so that \\eqref{eq:6.2.12} holds.", "statement": "We assume:\n\u2022 $\\mathbf{F}:\\mathbb{R}^n \\to \\mathbb{R}^n$ is continuously differentiable near $\\mathbf{X}_0$ [tc_1];\n\u2022 $\\mathbf{G}(\\mathbf{X}) = \\mathbf{F}'(\\mathbf{X}_0)\\mathbf{X} - \\mathbf{F}(\\mathbf{X})$ [def_1].\nDefinition:\n\u2022 For any given $\\epsilon > 0$, we can choose a $\\delta > 0$ such that for all $\\mathbf{X}, \\mathbf{Y}$ in the ball $B_\\delta(\\mathbf{X}_0)$, the inequality $|\\mathbf{G}(\\mathbf{X}) - \\mathbf{G}(\\mathbf{Y})| \\le \\epsilon|\\mathbf{X}-\\mathbf{Y}|$ holds. This property, cited as (6.2.12), follows from $\\mathbf{F}$ being continuously differentiable at $\\mathbf{X}_0$ [tc_1] and the definition of $\\mathbf{G}$ [def_1], which implies $\\mathbf{G}'(\\mathbf{X}_0)=0$ [def_2].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n(tc_1 : ContDiffAt \u211d 1 F X\u2080)\n(def_1 : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n(def_1_axiom : \u2200 X, def_1 X = (fderiv \u211d F X\u2080) X - F X)\n(def_2 : HasFDerivAt (def_1) (0 : (Fin n \u2192 \u211d) \u2192L[\u211d] (Fin n \u2192 \u211d)) X\u2080)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states F is continuously differentiable 'near' X\u2080, while Lean uses ContDiffAt which means continuously differentiable 'at' X\u2080. This is a minor difference in locality specification.", "The Lean formalization correctly captures the definition of G using fderiv for the derivative and the same algebraic structure.", "The Lean formalization correctly expresses that G has derivative 0 at X\u2080 using HasFDerivAt with the zero linear map.", "The main conclusion about the Lipschitz-like property of G is completely missing from the Lean formalization. This is a major omission as it's the key result being proven."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states F is continuously differentiable 'near' X\u2080, while Lean uses ContDiffAt which means continuously differentiable 'at' X\u2080. This is a minor difference in locality specification.\", 'The Lean formalization correctly captures the definition of G using fderiv for the derivative and the same algebraic structure.', 'The Lean formalization correctly expresses that G has derivative 0 at X\u2080 using HasFDerivAt with the zero linear map.', \"The main conclusion about the Lipschitz-like property of G is completely missing from the Lean formalization. This is a major omission as it's the key result being proven.\"]"}, "type": "definition"}, "ts_1": {"id": "ts_1", "natural_language": "Then \\eqref{eq:6.2.16}  and \\eqref{eq:6.2.17} imply \\eqref{eq:6.2.15}.", "statement": "We assume:\n\u2022 $r = \\frac{1}{\\|(\\mathbf{F}'(\\mathbf{X}_0))^{-1}\\|}$ [tc_3];\n\u2022 For any $\\epsilon > 0$, there exists $\\delta > 0$ such that for $\\mathbf{X}, \\mathbf{Y} \\in B_\\delta(\\mathbf{X}_0)$, $|\\mathbf{G}(\\mathbf{X}) - \\mathbf{G}(\\mathbf{Y})| \\le \\epsilon|\\mathbf{X}-\\mathbf{Y}|$ [def_2];\n\u2022 $|\\mathbf{F}(\\mathbf{X})-\\mathbf{F}(\\mathbf{Y})| \\ge \\big| |\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})| - |\\mathbf{G}(\\mathbf{X})-\\mathbf{G}(\\mathbf{Y})| \\big|$ [l1];\n\u2022 $|\\mathbf{F}'(\\mathbf{X}_0)(\\mathbf{X}-\\mathbf{Y})| \\ge r|\\mathbf{X}-\\mathbf{Y}|$ [l3].\nTherefore, we conclude:\n\u2022 For every $\\epsilon > 0$, there is a $\\delta > 0$ such that $|\\mathbf{F}(\\mathbf{X})-\\mathbf{F}(\\mathbf{Y})| \\ge (r-\\epsilon)|\\mathbf{X}-\\mathbf{Y}|$ if $\\mathbf{X}, \\mathbf{Y} \\in B_\\delta(\\mathbf{X}_{0})$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2", "l3", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 X Y, X \u2208 Metric.ball X\u2080 \u03b4 \u2192 Y \u2208 Metric.ball X\u2080 \u03b4 \u2192 \u2016G X - G Y\u2016 \u2264 \u03b5 * \u2016X - Y\u2016)\n  (l1 : \u2200 X Y, \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016)\n  (l3 : \u2200 X Y, \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2265 r * \u2016X - Y\u2016) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 X Y, X \u2208 Metric.ball X\u2080 \u03b4 \u2192 Y \u2208 Metric.ball X\u2080 \u03b4 \u2192 \u2016F X - F Y\u2016 \u2265 (r - \u03b5) * \u2016X - Y\u2016 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (F : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d)) (X\u2080 : Fin n \u2192 \u211d)\n  (tc_1 : ContDiffAt \u211d 1 F X\u2080)\n  (tc_2 : Invertible (fderiv \u211d F X\u2080))\n  (r : \u211d)\n  (tc_3 : r = 1 / \u2016(\u215f(fderiv \u211d F X\u2080))\u2016)\n  (G : (Fin n \u2192 \u211d) \u2192 (Fin n \u2192 \u211d))\n  (def_2 : \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 X Y, X \u2208 Metric.ball X\u2080 \u03b4 \u2192 Y \u2208 Metric.ball X\u2080 \u03b4 \u2192 \u2016G X - G Y\u2016 \u2264 \u03b5 * \u2016X - Y\u2016)\n  (l1 : \u2200 X Y, \u2016F X - F Y\u2016 \u2265 \u2016\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016\u2016)\n  (l3 : \u2200 X Y, \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 \u2265 r * \u2016X - Y\u2016) :\n  \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 X Y, X \u2208 Metric.ball X\u2080 \u03b4 \u2192 Y \u2208 Metric.ball X\u2080 \u03b4 \u2192 \u2016F X - F Y\u2016 \u2265 (r - \u03b5) * \u2016X - Y\u2016 := by\n  intro \u03b5 h\u03b5\n  obtain \u27e8\u03b4, h\u03b4, hG\u27e9 := def_2 \u03b5 h\u03b5\n  refine \u27e8\u03b4, h\u03b4, fun X Y hX hY \u21a6 ?_\u27e9\n  have h1 := l1 X Y\n  have h3 := l3 X Y\n  have hG' := hG X Y hX hY\n  have h : \u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016 \u2265 (r - \u03b5) * \u2016X - Y\u2016 := by\n    rw [sub_mul]\n    exact sub_le_sub h3 hG'\n  rw [Real.norm_eq_abs] at h1\n  have h1' : |\u2016(fderiv \u211d F X\u2080) (X - Y)\u2016 - \u2016G X - G Y\u2016| \u2265 (r - \u03b5) * \u2016X - Y\u2016 := by\n    refine le_trans ?_ (le_abs_self _)\n    exact h\n  exact le_trans h1' h1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations appropriately represent the mathematical objects with proper typing", "Definition of r correctly translates the inverse norm formula using Lean's inverse operator", "Uniform continuity condition for G is accurately formalized with proper quantifier structure", "Lower bound inequality l1 correctly uses nested norms to represent the absolute value structure", "Lower bound inequality l3 for the derivative is perfectly translated", "Main conclusion ts_1 accurately captures the epsilon-delta formulation", "Additional technical conditions (continuous differentiability and invertibility) are mathematically necessary and enhance the formalization without contradicting the natural language"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    