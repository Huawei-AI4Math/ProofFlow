
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $P_1,$ $P_2, $\dots$,$ $P_n,$ \dots\ be
propositions$,$ one
for each positive integer$,$ such that
\begin{alist}
\item % (a)
 $P_1$ is true$;$
\item % (b)
 for each positive integer $n,$  $P_n$  implies $P_{n+1}.$
\end{alist}
Then $P_n$ is true for each positive integer $n.$

Proof: Let
$$
\mathbb M=\set{n}{n\in \mathbb N\mbox{ and } P_n\mbox{ is
true}}.
$$
From \part{a}, $1\in \mathbb M$, and from \part{b}, $n+1\in \mathbb M$ whenever
$n\in \mathbb M$. Therefore, $\mathbb M=\mathbb N$, by postulate
\part{E}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $P_1,$ $P_2, \\dots,$ $P_n,$ \\dots\\ be propositions$,$ one for each positive integer", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ (i.e. for each $n \\in \\mathbb{N}$, $P_n$ is a proposition) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean declaration `(P : \u2115 \u2192 Prop)` correctly captures that P is a sequence of propositions indexed by natural numbers.", "The Lean declaration `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` introduces an entirely different concept - a function that maps each `P n` to a proposition type. The natural language simply states that each `P_n` is a proposition, which is already captured by the type `P : \u2115 \u2192 Prop`. The `tc_1` declaration adds an unnecessary and conceptually different layer."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean declaration `(P : \u2115 \u2192 Prop)` correctly captures that P is a sequence of propositions indexed by natural numbers.', 'The Lean declaration `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` introduces an entirely different concept - a function that maps each `P n` to a proposition type. The natural language simply states that each `P_n` is a proposition, which is already captured by the type `P : \u2115 \u2192 Prop`. The `tc_1` declaration adds an unnecessary and conceptually different layer.']"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "$P_1$ is true$;$", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures that P is a sequence of propositions indexed by natural numbers.", "The Lean variable `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` introduces a completely new logical structure not mentioned in the natural language. This states that for each n, P n implies some other proposition, which is not present in the original conditions.", "The Lean formalization `(tc_2 : P 1)` correctly captures that P_1 is true."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures that P is a sequence of propositions indexed by natural numbers.', 'The Lean variable `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` introduces a completely new logical structure not mentioned in the natural language. This states that for each n, P n implies some other proposition, which is not present in the original conditions.', 'The Lean formalization `(tc_2 : P 1)` correctly captures that P_1 is true.']"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "for each positive integer $n,$  $P_n$  implies $P_{n+1}.$", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean declaration `(P : \u2115 \u2192 Prop)` correctly captures that P is a sequence of propositions indexed by natural numbers", "The declaration `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` is logically incorrect and doesn't correspond to any condition in the natural language. This states that for each n, 'P n implies Prop', which is meaningless since Prop is the type of propositions, not a specific proposition. This appears to be an erroneous formalization", "The declaration `(tc_2 : P 1)` perfectly matches the condition that P_1 is true", "The declaration `(tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))` perfectly matches the inductive step condition that for each positive integer n, P_n implies P_{n+1}"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean declaration `(P : \u2115 \u2192 Prop)` correctly captures that P is a sequence of propositions indexed by natural numbers', \"The declaration `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` is logically incorrect and doesn't correspond to any condition in the natural language. This states that for each n, 'P n implies Prop', which is meaningless since Prop is the type of propositions, not a specific proposition. This appears to be an erroneous formalization\", 'The declaration `(tc_2 : P 1)` perfectly matches the condition that P_1 is true', 'The declaration `(tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))` perfectly matches the inductive step condition that for each positive integer n, P_n implies P_{n+1}']"}, "type": "condition"}, "tc_4": {"id": "tc_4", "natural_language": "by postulate \\part{E}.", "statement": "Premise:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].\n\u2022 Postulate E (Axiom of Induction for positive integers) states that for any set $\\mathbb{M} \\subseteq \\mathbb{N}$, if $1 \\in \\mathbb{M}$ and for all $n \\in \\mathbb{M}$, $n+1 \\in \\mathbb{M}$, then $\\mathbb{M} = \\mathbb{N}$ [tc_4].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language states that P is a sequence of propositions indexed by positive integers. In Lean, `(P : \u2115 \u2192 Prop)` correctly represents this, but `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` is redundant and incorrect - it suggests that each P n maps to a proposition type, which doesn't match the natural language meaning where P is already the sequence of propositions.", "The Lean formalization `(tc_2 : P 1)` perfectly matches the natural language statement that P_1 is true.", "The Lean formalization `(tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))` perfectly captures the natural language statement that for each positive integer n, P_n implies P_{n+1}.", "The Lean formalization captures the logical structure of the induction axiom correctly, but uses `Set.univ` (the universal set of natural numbers) instead of explicitly representing the constraint that M is a subset of \u2115. While semantically equivalent in this context, it's a slight notational difference from the natural language description."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language states that P is a sequence of propositions indexed by positive integers. In Lean, `(P : \u2115 \u2192 Prop)` correctly represents this, but `(tc_1 : \u2200 n : \u2115, P n \u2192 Prop)` is redundant and incorrect - it suggests that each P n maps to a proposition type, which doesn't match the natural language meaning where P is already the sequence of propositions.\", 'The Lean formalization `(tc_2 : P 1)` perfectly matches the natural language statement that P_1 is true.', 'The Lean formalization `(tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))` perfectly captures the natural language statement that for each positive integer n, P_n implies P_{n+1}.', \"The Lean formalization captures the logical structure of the induction axiom correctly, but uses `Set.univ` (the universal set of natural numbers) instead of explicitly representing the constraint that M is a subset of \u2115. While semantically equivalent in this context, it's a slight notational difference from the natural language description.\"]"}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let\n$$\n\\mathbb M=\\set{n}{n\\in \\mathbb N\\mbox{ and } P_n\\mbox{ is\ntrue}}.\n$$", "statement": "Definition:\n\u2022 $\\mathbb{M}$ is the set of positive integers $n$ for which $P_n$ is true, i.e., $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$ [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures that P_n is a statement (proposition) about natural numbers that can be true or false", "The Lean formalization uses \u2115 which in Lean represents natural numbers including 0, but the context and usage make it clear we're dealing with positive integers", "The natural language only states that P_n is true for some values of n, but the Lean formalization includes specific assumptions like `(tc_2 : P 1)` and `(tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))` which are much stronger - they imply P is true for ALL positive integers via induction, not just some", "The natural language defines M as the set of positive integers where P_n is true, but the Lean formalization doesn't actually define M at all. Instead, it has `(def_1 : {n : \u2115 | P n} = {n | P n})` which is just a tautological statement about set notation, not a definition of the set M mentioned in the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization `(P : \u2115 \u2192 Prop)` correctly captures that P_n is a statement (proposition) about natural numbers that can be true or false', \"The Lean formalization uses \u2115 which in Lean represents natural numbers including 0, but the context and usage make it clear we're dealing with positive integers\", 'The natural language only states that P_n is true for some values of n, but the Lean formalization includes specific assumptions like `(tc_2 : P 1)` and `(tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))` which are much stronger - they imply P is true for ALL positive integers via induction, not just some', \"The natural language defines M as the set of positive integers where P_n is true, but the Lean formalization doesn't actually define M at all. Instead, it has `(def_1 : {n : \u2115 | P n} = {n | P n})` which is just a tautological statement about set notation, not a definition of the set M mentioned in the natural language\"]"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "From \\part{a}, $1\\in \\mathbb M$", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].\n\u2022 Postulate E (Axiom of Induction for positive integers) states that for any set $\\mathbb{M} \\subseteq \\mathbb{N}$, if $1 \\in \\mathbb{M}$ and for all $n \\in \\mathbb{M}$, $n+1 \\in \\mathbb{M}$, then $\\mathbb{M} = \\mathbb{N}$ [tc_4].\n\u2022 $\\mathbb{M}$ is the set of positive integers $n$ for which $P_n$ is true, i.e., $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$ [def_1].\nTherefore, we conclude:\n\u2022 $1 \\in \\mathbb{M}$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n}) :\n  1 \u2208 {n : \u2115 | P n} := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n}) :\n  1 \u2208 {n : \u2115 | P n} := by\n  simp [tc_2]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["P as a sequence of propositions indexed by positive integers is correctly represented as \u2115 \u2192 Prop", "P\u2081 is true correctly translates to P 1 in Lean", "The implication structure \u2200 n, P n \u2192 P (n + 1) correctly captures the natural language statement", "The induction axiom uses Set.univ which includes 0, but natural language specifies positive integers only (M = \u2115 should exclude 0)", "def_1 is a tautological statement that doesn't capture the actual definition of M as the set of n where P n is true", "tc_1 parameter doesn't correspond to anything in the natural language and creates unnecessary complexity", "The conclusion 1 \u2208 {n : \u2115 | P n} correctly represents 1 \u2208 M from the natural language"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['P as a sequence of propositions indexed by positive integers is correctly represented as \u2115 \u2192 Prop', 'P\u2081 is true correctly translates to P 1 in Lean', 'The implication structure \u2200 n, P n \u2192 P (n + 1) correctly captures the natural language statement', 'The induction axiom uses Set.univ which includes 0, but natural language specifies positive integers only (M = \u2115 should exclude 0)', \"def_1 is a tautological statement that doesn't capture the actual definition of M as the set of n where P n is true\", \"tc_1 parameter doesn't correspond to anything in the natural language and creates unnecessary complexity\", 'The conclusion 1 \u2208 {n : \u2115 | P n} correctly represents 1 \u2208 M from the natural language']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "from \\part{b}, $n+1\\in \\mathbb M$ whenever\n$n\\in \\mathbb M$.", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].\n\u2022 Postulate E (Axiom of Induction for positive integers) states that for any set $\\mathbb{M} \\subseteq \\mathbb{N}$, if $1 \\in \\mathbb{M}$ and for all $n \\in \\mathbb{M}$, $n+1 \\in \\mathbb{M}$, then $\\mathbb{M} = \\mathbb{N}$ [tc_4].\n\u2022 $\\mathbb{M}$ is the set of positive integers $n$ for which $P_n$ is true, i.e., $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$ [def_1].\n\u2022 $1 \\in \\mathbb{M}$ [l1].\nTherefore, we conclude:\n\u2022 For any positive integer $n$, if $n \\in \\mathbb{M}$, then $n+1 \\in \\mathbb{M}$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})\n  (l1 : 1 \u2208 {n : \u2115 | P n}) :\n  \u2200 (n : \u2115), n \u2208 {n : \u2115 | P n} \u2192 n + 1 \u2208 {n : \u2115 | P n} := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})\n  (l1 : 1 \u2208 {n : \u2115 | P n}) :\n  \u2200 (n : \u2115), n \u2208 {n : \u2115 | P n} \u2192 n + 1 \u2208 {n : \u2115 | P n} := by\n  intro n hn\n  simp at hn \u22a2\n  exact tc_3 n hn", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The type declaration P : \u2115 \u2192 Prop correctly captures P as a sequence of propositions indexed by natural numbers.", "tc_1 appears to be extraneous in the Lean formalization. The natural language mentions it as an assumption but provides no semantic content, while the Lean version introduces a meaningless type \u2200 n : \u2115, P n \u2192 Prop that doesn't correspond to anything in the natural language.", "tc_2 : P 1 correctly represents that P_1 is true.", "tc_3 correctly formalizes the inductive step that P_n implies P_{n+1} for all n.", "tc_4 correctly captures the axiom of induction, with Set.univ representing \u2115 in the context of Set \u2115.", "def_1 is problematic - it states {n : \u2115 | P n} = {n | P n}, which is a tautology that doesn't capture the intended definition of M as the set where P_n is true. The natural language defines M as a specific set, but this Lean statement is just an identity.", "l1 correctly states that 1 is in the set of natural numbers where P holds.", "The conclusion correctly formalizes the statement that if n is in M, then n+1 is also in M."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The type declaration P : \u2115 \u2192 Prop correctly captures P as a sequence of propositions indexed by natural numbers.', \"tc_1 appears to be extraneous in the Lean formalization. The natural language mentions it as an assumption but provides no semantic content, while the Lean version introduces a meaningless type \u2200 n : \u2115, P n \u2192 Prop that doesn't correspond to anything in the natural language.\", 'tc_2 : P 1 correctly represents that P_1 is true.', 'tc_3 correctly formalizes the inductive step that P_n implies P_{n+1} for all n.', 'tc_4 correctly captures the axiom of induction, with Set.univ representing \u2115 in the context of Set \u2115.', \"def_1 is problematic - it states {n : \u2115 | P n} = {n | P n}, which is a tautology that doesn't capture the intended definition of M as the set where P_n is true. The natural language defines M as a specific set, but this Lean statement is just an identity.\", 'l1 correctly states that 1 is in the set of natural numbers where P holds.', 'The conclusion correctly formalizes the statement that if n is in M, then n+1 is also in M.']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Therefore, $\\mathbb M=\\mathbb N$, by postulate\n\\part{E}.", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].\n\u2022 Postulate E (Axiom of Induction for positive integers) states that for any set $\\mathbb{M} \\subseteq \\mathbb{N}$, if $1 \\in \\mathbb{M}$ and for all $n \\in \\mathbb{M}$, $n+1 \\in \\mathbb{M}$, then $\\mathbb{M} = \\mathbb{N}$ [tc_4].\n\u2022 $\\mathbb{M}$ is the set of positive integers $n$ for which $P_n$ is true, i.e., $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$ [def_1].\n\u2022 $1 \\in \\mathbb{M}$ [l1].\n\u2022 For any positive integer $n$, if $n \\in \\mathbb{M}$, then $n+1 \\in \\mathbb{M}$ [l2].\nTherefore, we conclude:\n\u2022 $\\mathbb{M} = \\mathbb{N}$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})\n  (l1 : 1 \u2208 {n : \u2115 | P n})\n  (l2 : \u2200 (n : \u2115), n \u2208 {n : \u2115 | P n} \u2192 n + 1 \u2208 {n : \u2115 | P n}) :\n  {n : \u2115 | P n} = Set.univ := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})\n  (l1 : 1 \u2208 {n : \u2115 | P n})\n  (l2 : \u2200 (n : \u2115), n \u2208 {n : \u2115 | P n} \u2192 n + 1 \u2208 {n : \u2115 | P n}) :\n  {n : \u2115 | P n} = Set.univ := by\n  apply tc_4 {n | P n} l1 l2", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1 should simply be P : \u2115 \u2192 Prop (P is a sequence of propositions), but the Lean formalization makes it a function \u2200 n : \u2115, P n \u2192 Prop, which has completely different meaning", "tc_2 correctly states P 1, matching 'P\u2081 is true'", "tc_3 correctly captures the implication \u2200 n : \u2115, P n \u2192 P (n + 1)", "tc_4 correctly formalizes the induction axiom with Set.univ representing \u2115", "def_1 is a meaningless tautology {n : \u2115 | P n} = {n | P n} instead of properly defining M as the set {n : \u2115 | P n}", "l1 correctly states 1 \u2208 {n : \u2115 | P n}, which represents 1 \u2208 M", "l2 correctly captures the closure property of M under successor", "l3 correctly concludes {n : \u2115 | P n} = Set.univ, representing M = \u2115"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1 should simply be P : \u2115 \u2192 Prop (P is a sequence of propositions), but the Lean formalization makes it a function \u2200 n : \u2115, P n \u2192 Prop, which has completely different meaning', \"tc_2 correctly states P 1, matching 'P\u2081 is true'\", 'tc_3 correctly captures the implication \u2200 n : \u2115, P n \u2192 P (n + 1)', 'tc_4 correctly formalizes the induction axiom with Set.univ representing \u2115', 'def_1 is a meaningless tautology {n : \u2115 | P n} = {n | P n} instead of properly defining M as the set {n : \u2115 | P n}', 'l1 correctly states 1 \u2208 {n : \u2115 | P n}, which represents 1 \u2208 M', 'l2 correctly captures the closure property of M under successor', 'l3 correctly concludes {n : \u2115 | P n} = Set.univ, representing M = \u2115']"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Then $P_n$ is true for each positive integer $n.$", "statement": "We assume:\n\u2022 $P$ is a sequence of propositions indexed by the positive integers $\\mathbb{N}$ [tc_1].\n\u2022 $P_1$ is true [tc_2].\n\u2022 For each positive integer $n$, $P_n$ implies $P_{n+1}$ [tc_3].\n\u2022 Postulate E (Axiom of Induction for positive integers) states that for any set $\\mathbb{M} \\subseteq \\mathbb{N}$, if $1 \\in \\mathbb{M}$ and for all $n \\in \\mathbb{M}$, $n+1 \\in \\mathbb{M}$, then $\\mathbb{M} = \\mathbb{N}$ [tc_4].\n\u2022 $\\mathbb{M}$ is the set of positive integers $n$ for which $P_n$ is true, i.e., $\\mathbb{M} = \\{n \\in \\mathbb{N} \\mid P_n \\text{ is true}\\}$ [def_1].\n\u2022 $1 \\in \\mathbb{M}$ [l1].\n\u2022 For any positive integer $n$, if $n \\in \\mathbb{M}$, then $n+1 \\in \\mathbb{M}$ [l2].\n\u2022 $\\mathbb{M} = \\mathbb{N}$ [l3].\nTherefore, we conclude:\n\u2022 $P_n$ is true for each positive integer $n$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "tc_4", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})\n  (l1 : 1 \u2208 {n : \u2115 | P n})\n  (l2 : \u2200 (n : \u2115), n \u2208 {n : \u2115 | P n} \u2192 n + 1 \u2208 {n : \u2115 | P n})\n  (l3 : {n : \u2115 | P n} = Set.univ) :\n  \u2200 n : \u2115, P n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (P : \u2115 \u2192 Prop)\n  (tc_1 : \u2200 n : \u2115, P n \u2192 Prop)\n  (tc_2 : P 1)\n  (tc_3 : \u2200 n : \u2115, P n \u2192 P (n + 1))\n  (tc_4 : \u2200 (M : Set \u2115), (1 \u2208 M) \u2192 (\u2200 (n : \u2115), n \u2208 M \u2192 n + 1 \u2208 M) \u2192 M = Set.univ)\n  (def_1 : {n : \u2115 | P n} = {n | P n})\n  (l1 : 1 \u2208 {n : \u2115 | P n})\n  (l2 : \u2200 (n : \u2115), n \u2208 {n : \u2115 | P n} \u2192 n + 1 \u2208 {n : \u2115 | P n})\n  (l3 : {n : \u2115 | P n} = Set.univ) :\n  \u2200 n : \u2115, P n := by\n  intro n\n  have h : n \u2208 {n : \u2115 | P n} := by rw [l3]; exact Set.mem_univ n\n  exact h", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.0, "semantic_feedback": ["tc_1 should simply be (P : \u2115 \u2192 Prop) to represent P as a sequence of propositions indexed by \u2115. The current formalization (tc_1 : \u2200 n : \u2115, P n \u2192 Prop) incorrectly makes tc_1 a function rather than representing the indexing of P.", "tc_2 correctly represents that P\u2081 is true.", "tc_3 correctly captures the implication P n \u2192 P (n + 1) for all n.", "tc_4 correctly formalizes the axiom of induction using Set.univ to represent \u2115.", "def_1 is a meaningless tautology. It should properly define M as the set {n : \u2115 | P n}, not assert an equality between identical sets.", "l1 correctly states that 1 is in the set of n where P n holds.", "l2 correctly formalizes the closure property of the set under successor.", "l3 correctly states that the set equals the universal set (\u2115).", "ts_1 correctly concludes that P n holds for all natural numbers n."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['tc_1 should simply be (P : \u2115 \u2192 Prop) to represent P as a sequence of propositions indexed by \u2115. The current formalization (tc_1 : \u2200 n : \u2115, P n \u2192 Prop) incorrectly makes tc_1 a function rather than representing the indexing of P.', 'tc_2 correctly represents that P\u2081 is true.', 'tc_3 correctly captures the implication P n \u2192 P (n + 1) for all n.', 'tc_4 correctly formalizes the axiom of induction using Set.univ to represent \u2115.', 'def_1 is a meaningless tautology. It should properly define M as the set {n : \u2115 | P n}, not assert an equality between identical sets.', 'l1 correctly states that 1 is in the set of n where P n holds.', 'l2 correctly formalizes the closure property of the set under successor.', 'l3 correctly states that the set equals the universal set (\u2115).', 'ts_1 correctly concludes that P n holds for all natural numbers n.']"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_4", "label": "tc_4", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "tc_4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    