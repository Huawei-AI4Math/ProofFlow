
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If~$R$ is a complete set of residues modulo~$n$ and $a\in\Z$ with
$\gcd(a,n)=1$, then $aR = \{ax : x \in R\}$
is also a complete set of residues modulo~$n$.

We can assume the following statement(s) without a proof. 

If $\gcd(c,n)=1$ and
$$
   ac\con bc\pmod{n},
$$
then $a \con b\pmod{n}$.

Proof: If $ax\con ax'\pmod{n}$ with $x, x'\in R$, then $x\con{}x'\pmod{n}$.
Because $R$ is a complete set of residues, this implies
that $x=x'$.  Thus the elements of
$aR$ have distinct reductions modulo~$n$.
It follows, since $\#aR=n$, that $aR$ is a
complete set of residues modulo~$n$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If R is a complete set of residues modulo n", "statement": "Premise:\n\u2022 R is a complete set of residues modulo n [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (R : Finset \u2124)\n(tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])", "lean_pass": true, "error_msg": [], "tries": 4}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the mathematical definition of 'complete set of residues modulo n' through three equivalent conditions: R has exactly n elements, no two elements in R are congruent modulo n, and every integer is congruent to some element in R modulo n. This is the standard mathematical definition expressed formally."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "a\u2208Z with gcd(a,n)=1", "statement": "Premise:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (R : Finset \u2124) (a : \u2124)\n(tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n(tc_2 : Int.gcd a n = 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures 'R is a complete set of residues modulo n' through tc_1, which defines three essential properties: (1) R has exactly n elements (R.card = n), (2) no two distinct elements in R are congruent modulo n (injectivity), and (3) every integer is congruent to some element in R modulo n (surjectivity). This is the standard mathematical definition of a complete set of residues. The additional type information that R is a Finset \u2124 is consistent and necessary for the formalization.", "The Lean formalization perfectly matches 'a is an integer such that gcd(a, n) = 1' with (a : \u2124) declaring a as an integer and (tc_2 : Int.gcd a n = 1) stating the gcd condition exactly as required."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "If gcd(c,n)=1 and ac \u2261 bc(mod n), then a \u2261 b(mod n).", "statement": "Premise:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2];\n\u2022 For any integers k, l, m, p, if gcd(m, p) = 1 and km \u2261 lm (mod p), then k \u2261 l (mod p) [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (R : Finset \u2124) (a : \u2124) (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n]) (tc_2 : Int.gcd a n = 1)\n(tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization correctly captures that R is a complete set of residues modulo n through three conditions: R has exactly n elements, no two distinct elements are congruent mod n, and every integer has a representative in R that is congruent to it mod n. This is the precise mathematical definition of a complete set of residues.", "The Lean formalization exactly matches the natural language condition that a is an integer with gcd(a,n) = 1.", "The Lean version uses multiplication in the order 'm * k' and 'm * l', while the natural language uses 'km' and 'lm'. These represent the same mathematical concept since multiplication is commutative, but the order is reversed. The logical meaning is identical."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Because R is a complete set of residues", "statement": "Definition:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2];\n\u2022 For any integers k, l, m, p, if gcd(m, p) = 1 and km \u2261 lm (mod p), then k \u2261 l (mod p) [tc_3];\n\u2022 A set S is a complete set of residues modulo n (CSR) if it satisfies two properties: (1) it contains exactly n elements (#S = n), and (2) its elements are pairwise incongruent modulo n. The second property is equivalent to: for any y, z \u2208 S, if y \u2261 z (mod n), then y = z [def_1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {n : \u2115} (R : Finset \u2124) (a : \u2124) (S : Finset \u2124)\n(tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n(tc_2 : Int.gcd a n = 1)\n(tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n(def_1 : S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)))", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization completely captures the definition of a complete set of residues with all three required properties: correct cardinality, pairwise incongruence, and completeness (every integer is congruent to some element in R).", "The Lean formalization correctly captures that a is an integer (implicit in variable declaration) with gcd(a,n) = 1.", "The Lean version uses multiplication in the order 'm * k' and 'm * l' while the natural language uses 'km' and 'lm'. This is mathematically equivalent due to commutativity of multiplication, but represents a minor notational difference.", "The Lean formalization correctly captures both properties of a complete set of residues, but the natural language mentions this is equivalent to the definition while Lean presents it as direct conditions. This is a minor structural difference in presentation."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization completely captures the definition of a complete set of residues with all three required properties: correct cardinality, pairwise incongruence, and completeness (every integer is congruent to some element in R).', 'The Lean formalization correctly captures that a is an integer (implicit in variable declaration) with gcd(a,n) = 1.', \"The Lean version uses multiplication in the order 'm * k' and 'm * l' while the natural language uses 'km' and 'lm'. This is mathematically equivalent due to commutativity of multiplication, but represents a minor notational difference.\", 'The Lean formalization correctly captures both properties of a complete set of residues, but the natural language mentions this is equivalent to the definition while Lean presents it as direct conditions. This is a minor structural difference in presentation.']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If ax\u2261ax\u2032(mod n) with x,x\u2032\u2208R, then x\u2261x\u2032(mod n). Because R is a complete set of residues, this implies that x=x\u2032.", "statement": "We assume:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2];\n\u2022 For any integers k, l, m, p, if gcd(m, p) = 1 and km \u2261 lm (mod p), then k \u2261 l (mod p) [tc_3];\n\u2022 The definition of a complete set of residues (CSR) [def_1];\nTherefore, we conclude:\n\u2022 For any x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n])) :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x' := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n])) :\n  \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x' := by\n  intro x x' hx hx' h\n  have h1 := tc_3 x x' a n tc_2 h\n  rcases tc_1 with \u27e8_, hR, _\u27e9\n  exact hR x hx x' hx' h1", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.6, "semantic_feedback": ["The complete set of residues condition tc_1 is correctly formalized with all three required properties: cardinality, distinctness modulo n, and coverage.", "The gcd condition tc_2 is a direct and accurate translation.", "The cancellation property tc_3 has a minor notational difference: natural language uses 'km \u2261 lm' while Lean uses 'm * k \u2261 m * l'. The logical meaning is identical due to commutativity of multiplication, but the structure differs.", "The definition def_1 correctly captures the logical structure of what defines a complete set of residues.", "The conclusion l1 has the same minor notational difference as tc_3: 'ax' vs 'a * x'. The logical meaning is preserved but the structural representation differs slightly."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: ['The complete set of residues condition tc_1 is correctly formalized with all three required properties: cardinality, distinctness modulo n, and coverage.', 'The gcd condition tc_2 is a direct and accurate translation.', \"The cancellation property tc_3 has a minor notational difference: natural language uses 'km \u2261 lm' while Lean uses 'm * k \u2261 m * l'. The logical meaning is identical due to commutativity of multiplication, but the structure differs.\", 'The definition def_1 correctly captures the logical structure of what defines a complete set of residues.', \"The conclusion l1 has the same minor notational difference as tc_3: 'ax' vs 'a * x'. The logical meaning is preserved but the structural representation differs slightly.\"]"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Thus the elements of aR have distinct reductions modulo n.", "statement": "We assume:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2];\n\u2022 For any integers k, l, m, p, if gcd(m, p) = 1 and km \u2261 lm (mod p), then k \u2261 l (mod p) [tc_3];\n\u2022 The definition of a complete set of residues (CSR) [def_1];\n\u2022 For any x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l1];\nTherefore, we conclude:\n\u2022 The elements of the set aR = {ax : x \u2208 R} are pairwise incongruent modulo n [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x') :\n  (\u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x') :\n  (\u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z) := by\n  intro y z hx hx' hyz\n  obtain \u27e8x\u2081, hx\u2081, rfl\u27e9 := hx\n  obtain \u27e8x\u2082, hx\u2082, rfl\u27e9 := hx'\n  apply congr_arg (a * .)\n  apply l1 x\u2081 x\u2082 hx\u2081 hx\u2082\n  exact hyz", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly capture the mathematical objects with appropriate types.", "tc_1 correctly formalizes the complete set of residues property with all three required conditions.", "tc_2 perfectly matches the coprimality condition.", "tc_3 correctly captures the cancellation property; multiplication order difference is mathematically irrelevant.", "def_1 provides an appropriate general definition of complete set of residues.", "l1 correctly formalizes the injectivity property of multiplication by a on the set R.", "l2 correctly formalizes the conclusion that elements of aR are pairwise incongruent modulo n."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "since #aR=n", "statement": "We assume:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2];\n\u2022 For any integers k, l, m, p, if gcd(m, p) = 1 and km \u2261 lm (mod p), then k \u2261 l (mod p) [tc_3];\n\u2022 The definition of a complete set of residues (CSR) [def_1];\n\u2022 For any x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l1];\n\u2022 The elements of the set aR are pairwise incongruent modulo n [l2];\nTherefore, we conclude:\n\u2022 The set aR = {ax : x \u2208 R} has n elements, i.e., #aR = n [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x')\n  (l2 : \u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z) :\n  (R.image fun x => a * x).card = n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x')\n  (l2 : \u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z) :\n  (R.image fun x => a * x).card = n := by\n  have h_inj : Set.InjOn (fun x => a * x) R := by\n    intro x hx y hy h\n    apply l1 x y hx hy\n    rw [h]\n    exact Int.modEq_refl _\n  rw [Finset.card_image_of_injOn h_inj, tc_1.1]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 8, "endLine": 17, "endColumn": 9, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (fun x => a * x) x\nn : \u2115\nR : Finset \u2124\na : \u2124\ntc_1 : R.card = n \u2227 (\u2200 x \u2208 R, \u2200 y \u2208 R, x \u2261 y [ZMOD \u2191n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 x \u2208 R, z \u2261 x [ZMOD \u2191n]\ntc_2 : a.gcd \u2191n = 1\ntc_3 : \u2200 (k l m p : \u2124), m.gcd p = 1 \u2192 m * k \u2261 m * l [ZMOD p] \u2192 k \u2261 l [ZMOD p]\ndef_1 :\n  \u2200 (S : Finset \u2124),\n    (S.card = n \u2227 \u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 y \u2261 z [ZMOD \u2191n] \u2192 y = z) \u2192 \u2200 (z : \u2124), \u2203 x \u2208 S, z \u2261 x [ZMOD \u2191n]\nl1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 a * x \u2261 a * x' [ZMOD \u2191n] \u2192 x = x'\nl2 : \u2200 (y z : \u2124), (\u2203 x_1 \u2208 R, y = a * x_1) \u2192 (\u2203 x_2 \u2208 R, z = a * x_2) \u2192 y \u2261 z [ZMOD \u2191n] \u2192 y = z\nx : \u2124\nhx : x \u2208 \u2191R\ny : \u2124\nhy : y \u2208 \u2191R\nh : (fun x => a * x) x = (fun x => a * x) y\n\u22a2 a * x \u2261 a * y [ZMOD \u2191n]"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["tc_1 correctly captures all three properties of a complete set of residues: cardinality, pairwise incongruence, and completeness", "tc_2 is a direct translation of the gcd condition", "tc_3 has the same logical meaning but uses different multiplication order (m*k vs km), which is semantically equivalent due to commutativity", "def_1 properly formalizes the definition of a complete set of residues as an implication", "l1 correctly captures the injectivity property with proper logical structure", "l2 correctly formalizes pairwise incongruence using the contrapositive form", "The conclusion correctly uses Finset.image to represent the set {ax : x \u2208 R} and states its cardinality equals n", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.86 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x')\n  (l2 : \u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z) :\n  \u00ac (R.image fun x => a * x).card = n := by\n  intro h\n  have hR : (R.image fun x => a * x).card \u2264 R.card := Finset.card_image_le\n  rw [h, (tc_1).1] at hR\n  have h_inj : Set.InjOn (fun x => a * x) R := by\n    intro x hx y hy hxy\n    apply l1 x y hx hy\n    rw [\u2190 ZMod.nat_cast_zmod_eq_zero_iff_dvd] at hxy\n    rw [sub_eq_zero] at hxy\n    exact hxy\n  have h_card : (R.image fun x => a * x).card = R.card := Finset.card_image_of_injOn h_inj\n  rw [h_card, (tc_1).1] at h\n  exact (ne_of_lt (Nat.lt_succ_self n)).symm h"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "It follows, since #aR=n, that aR is a complete set of residues modulo n.", "statement": "We assume:\n\u2022 R is a complete set of residues modulo n [tc_1];\n\u2022 a is an integer such that gcd(a, n) = 1 [tc_2];\n\u2022 For any integers k, l, m, p, if gcd(m, p) = 1 and km \u2261 lm (mod p), then k \u2261 l (mod p) [tc_3];\n\u2022 The definition of a complete set of residues (CSR) [def_1];\n\u2022 For any x, x' \u2208 R, if ax \u2261 ax' (mod n), then x = x' [l1];\n\u2022 The elements of the set aR are pairwise incongruent modulo n [l2];\n\u2022 The set aR has n elements, i.e., #aR = n [l3];\nTherefore, we conclude:\n\u2022 The set aR = {ax : x \u2208 R} is a complete set of residues modulo n [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "def_1", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x')\n  (l2 : \u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z)\n  (l3 : (R.image fun x => a * x).card = n) :\n  (R.image fun x => a * x).card = n \u2227 (\u2200 (y z : \u2124), (y \u2208 R.image fun x => a * x) \u2192 (z \u2208 R.image fun x => a * x) \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2227 (\u2200 (z : \u2124), \u2203 (x : \u2124), (x \u2208 R.image fun x => a * x) \u2227 z \u2261 x [ZMOD n]) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x')\n  (l2 : \u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z)\n  (l3 : (R.image fun x => a * x).card = n) :\n  (R.image fun x => a * x).card = n \u2227 (\u2200 (y z : \u2124), (y \u2208 R.image fun x => a * x) \u2192 (z \u2208 R.image fun x => a * x) \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2227 (\u2200 (z : \u2124), \u2203 (x : \u2124), (x \u2208 R.image fun x => a * x) \u2227 z \u2261 x [ZMOD n]) := by\n  refine \u27e8l3, ?_, ?_\u27e9\n  \u00b7 intro y z hy hz h\n    obtain \u27e8x\u2081, hx\u2081, rfl\u27e9 := Finset.mem_image.mp hy\n    obtain \u27e8x\u2082, hx\u2082, rfl\u27e9 := Finset.mem_image.mp hz\n    exact l2 _ _ \u27e8x\u2081, hx\u2081, rfl\u27e9 \u27e8x\u2082, hx\u2082, rfl\u27e9 h\n  \u00b7 intro z\n    obtain \u27e8x, hx, h\u27e9 := tc_1.2.2 z\n    refine \u27e8a * x, Finset.mem_image.mpr \u27e8x, hx, rfl\u27e9, ?_\u27e9\n    rw [Int.ModEq] at h \u22a2\n    rw [mul_mod, h, mul_mod]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 24, "column": 8, "endLine": 24, "endColumn": 15, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a * ?b % ?n\ncase refine_2.intro.intro\nn : \u2115\nR : Finset \u2124\na : \u2124\ntc_1 : R.card = n \u2227 (\u2200 x \u2208 R, \u2200 y \u2208 R, x \u2261 y [ZMOD \u2191n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 x \u2208 R, z \u2261 x [ZMOD \u2191n]\ntc_2 : a.gcd \u2191n = 1\ntc_3 : \u2200 (k l m p : \u2124), m.gcd p = 1 \u2192 m * k \u2261 m * l [ZMOD p] \u2192 k \u2261 l [ZMOD p]\ndef_1 :\n  \u2200 (S : Finset \u2124),\n    (S.card = n \u2227 \u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 y \u2261 z [ZMOD \u2191n] \u2192 y = z) \u2192 \u2200 (z : \u2124), \u2203 x \u2208 S, z \u2261 x [ZMOD \u2191n]\nl1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 a * x \u2261 a * x' [ZMOD \u2191n] \u2192 x = x'\nl2 : \u2200 (y z : \u2124), (\u2203 x_1 \u2208 R, y = a * x_1) \u2192 (\u2203 x_2 \u2208 R, z = a * x_2) \u2192 y \u2261 z [ZMOD \u2191n] \u2192 y = z\nl3 : (Finset.image (fun x => a * x) R).card = n\nz x : \u2124\nhx : x \u2208 R\nh : z % \u2191n = x % \u2191n\n\u22a2 z % \u2191n = a * x % \u2191n"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["tc_1 correctly captures all three conditions for R being a complete set of residues: correct cardinality, pairwise incongruence, and coverage of all residue classes.", "tc_2 perfectly matches the coprimality condition between a and n.", "tc_3 has the multiplication order switched (m * k vs k * m) compared to the natural language, but this is mathematically equivalent due to commutativity of integer multiplication.", "def_1 correctly formalizes the definition of a complete set of residues as an implication from cardinality and pairwise incongruence to coverage.", "l1 perfectly captures the injectivity property of multiplication by a on elements of R.", "l2 correctly formalizes that elements in aR are pairwise incongruent modulo n using the image representation.", "l3 correctly states that the image set aR has cardinality n.", "The conclusion correctly requires proving all three conditions for aR being a complete set of residues, matching the natural language goal.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.88 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_ts_1\n  {n : \u2115} (R : Finset \u2124) (a : \u2124)\n  (tc_1 : R.card = n \u2227 (\u2200 (x : \u2124) (hx : x \u2208 R) (y : \u2124) (hy : y \u2208 R), x \u2261 y [ZMOD n] \u2192 x = y) \u2227 \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 R \u2227 z \u2261 x [ZMOD n])\n  (tc_2 : Int.gcd a n = 1)\n  (tc_3 : \u2200 (k l m p : \u2124), Int.gcd m p = 1 \u2192 (m * k \u2261 m * l [ZMOD p]) \u2192 (k \u2261 l [ZMOD p]))\n  (def_1 : \u2200 (S : Finset \u2124), S.card = n \u2227 (\u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2192 (\u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n]))\n  (l1 : \u2200 (x x' : \u2124), x \u2208 R \u2192 x' \u2208 R \u2192 (a * x \u2261 a * x' [ZMOD n]) \u2192 x = x')\n  (l2 : \u2200 (y z : \u2124), (\u2203 (x_1 : \u2124), x_1 \u2208 R \u2227 y = a * x_1) \u2192 (\u2203 (x_2 : \u2124), x_2 \u2208 R \u2227 z = a * x_2) \u2192 (y \u2261 z [ZMOD n]) \u2192 y = z)\n  (l3 : (R.image fun x => a * x).card = n) :\n  \u00ac ((R.image fun x => a * x).card = n \u2227 (\u2200 (y z : \u2124), (y \u2208 R.image fun x => a * x) \u2192 (z \u2208 R.image fun x => a * x) \u2192 (y \u2261 z [ZMOD n] \u2192 y = z)) \u2227 (\u2200 (z : \u2124), \u2203 (x : \u2124), (x \u2208 R.image fun x => a * x) \u2227 z \u2261 x [ZMOD n])) := by\n  intro h\n  have h1 := h.1\n  have h2 := h.2.1\n  have h3 := h.2.2\n  let S := R.image fun x => a * x\n  have hS : S.card = n := l3\n  have hS' : \u2200 (y z : \u2124), y \u2208 S \u2192 z \u2208 S \u2192 (y \u2261 z [ZMOD n] \u2192 y = z) := h2\n  have hS'' : \u2200 (z : \u2124), \u2203 (x : \u2124), x \u2208 S \u2227 z \u2261 x [ZMOD n] := h3\n  have hR := tc_1.2.2\n  have hR' := tc_1.2.1\n  have hgcd := tc_2\n  have hcancel := tc_3\n  let z : \u2124 := 1\n  obtain \u27e8x, hx\u27e9 := hS'' z\n  have hx' : x \u2208 S := hx.1\n  rw [Finset.mem_image] at hx'\n  obtain \u27e8y, hy, rfl\u27e9 := hx'\n  have hz : z \u2261 a * y [ZMOD n] := hx.2\n  have hzero : a * y \u2261 1 [ZMOD n] := hz\n  obtain \u27e8y', hy'\u27e9 := hR y\n  have hy'' : y' \u2208 R \u2227 y \u2261 y' [ZMOD n] := hy'\n  have hy''' : a * y \u2261 a * y' [ZMOD n] := by\n    rw [hy''.2]\n  have hy'''' : a * y' \u2261 1 [ZMOD n] := Int.ModEq.trans hy''' hzero\n  have hcontra : a * y' \u2261 0 [ZMOD n] := by\n    apply hcancel (a * y') 0 1 n (by simp [hgcd])\n    rw [mul_one, mul_zero]\n    exact hy''''\n  have : 1 \u2261 0 [ZMOD n] := Int.ModEq.trans (Int.ModEq.symm hy'''') hcontra\n  simp [Int.ModEq] at this\n  exact this"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    