
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: If $\mathbf{X}\in\R^n$ and $p_2>p_1\ge1,$ then
\begin{equation} \label{eq:8.1.12}
\|\mathbf{X}\|_{p_2}\le\|\mathbf{X}\|_{p_1};
\end{equation}
moreover,
\begin{equation} \label{eq:8.1.13}
\lim_{p	o\infty}\|\mathbf{X}\|_{p}=\max\set{|x_i|}{1\le i\le n}.
\end{equation}

Proof: Let $u_1$, $u_2$, \dots, $u_n$  be
nonnegative and $M=\max\set{u_i}{1\le i\le n}$. Define
$$
\sigma(p)=\left(\sum_{i=1}^n u_i^p\right)^{1/p}.
$$
Since $u_i/\sigma(p)\le1$ and $p_2>p_1$,
$$
\left(\frac{u_i}{\sigma(p_2)}\right)^{p_1}\ge
\left(\frac{u_i}{\sigma(p_2)}\right)^{p_2};
$$
 therefore,
$$
\frac{\sigma(p_1)}{\sigma(p_2)}
=\left(\sum_{i=1}^n\left(\frac{
u_i}{\sigma(p_2)}\right)^{p_1}\right)^{1/p_1}
\ge\left(\sum_{i=1}^n\left(\frac{
u_i}{\sigma(p_2)}\right)^{p_2}\right)^{1/p_1}=1,
$$
so $\sigma(p_1)\ge\sigma(p_2)$.
Since $M\le\sigma(p)\le Mn^{1/p}$,
$\lim_{p	o\infty}\sigma(p)= M$.
Letting  $u_i=|x_i|$  yields \eqref{eq:8.1.12} and \eqref{eq:8.1.13}.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">ðŸ“Š</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "If $\\mathbf{X}\\in\\R^n$ and $p_2>p_1\\ge1,$ then...", "statement": "Premise:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (X : EuclideanSpace \u211d (Fin n)) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The natural language specifies X \u2208 \u211d\u207f (standard Euclidean space), while Lean uses EuclideanSpace \u211d (Fin n). While these are mathematically equivalent and EuclideanSpace is the appropriate Lean type for Euclidean spaces, it's not a direct literal translation of the \u211d\u207f notation.", "The Lean formalization correctly declares p1 and p2 as real numbers, matching the natural language exactly.", "The Lean condition tc_1 : p2 > p1 \u2227 p1 \u2265 1 perfectly captures the mathematical constraint p\u2082 > p\u2081 \u2265 1 using logical conjunction."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "Let $u_1$, $u_2$, ..., $u_n$  be nonnegative and $M=\\max\\set{u_i}{1\\le i\\le n}$.", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1].\nDefinition:\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115} [NeZero n]\n  (X : EuclideanSpace \u211d (Fin n)) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (u : Fin n \u2192 \u211d)\n  (def_1 : (\u2200 i, 0 \u2264 u i) \u2227 (let M := (Finset.univ.image u).sup' Finset.univ.nonempty; M = (Finset.univ.image u).sup' Finset.univ.nonempty))", "lean_pass": false, "error_msg": [{"line": 10, "column": 65, "endLine": 10, "endColumn": 85, "data": "invalid field 'nonempty', the environment does not contain 'Finset.nonempty'\n  Finset.univ\nhas type\n  Finset ?m.951"}, {"line": 10, "column": 118, "endLine": 10, "endColumn": 138, "data": "invalid field 'nonempty', the environment does not contain 'Finset.nonempty'\n  Finset.univ\nhas type\n  Finset ?m.1780"}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "definition"}, "def_2": {"id": "def_2", "natural_language": "Define\n$$\\sigma(p)=\\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}.$$", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1].\nDefinition:\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  {n : \u2115}\n  (p : \u211d)\n  (u : Fin n \u2192 \u211d)\n  (tc_1 : p > 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (def_2 : p \u2265 1)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language mentions $\\mathbf{X} \\in \\R^n$ but this variable X is completely missing from the Lean formalization", "The natural language specifies two distinct real numbers $p_1, p_2$ with $p_2 > p_1 \\ge 1$, but the Lean formalization only has a single real number $p$ with constraints $p > 1$ and $p \u2265 1$", "The Lean formalization correctly captures the sequence of n nonnegative real numbers using `(u : Fin n \u2192 \u211d)` and `(def_1 : \u2200 i, u i \u2265 0)`", "The natural language defines $M = \\max\\set{u_i}{1\\le i\\le n}$ but this definition of M is completely missing from the Lean formalization", "The natural language defines the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ but this function definition is completely missing from the Lean formalization"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The natural language mentions $\\\\mathbf{X} \\\\in \\\\R^n$ but this variable X is completely missing from the Lean formalization', 'The natural language specifies two distinct real numbers $p_1, p_2$ with $p_2 > p_1 \\\\ge 1$, but the Lean formalization only has a single real number $p$ with constraints $p > 1$ and $p \u2265 1$', 'The Lean formalization correctly captures the sequence of n nonnegative real numbers using `(u : Fin n \u2192 \u211d)` and `(def_1 : \u2200 i, u i \u2265 0)`', 'The natural language defines $M = \\\\max\\\\set{u_i}{1\\\\le i\\\\le n}$ but this definition of M is completely missing from the Lean formalization', 'The natural language defines the function $\\\\sigma(p) = \\\\left(\\\\sum_{i=1}^n u_i^p\\\\right)^{1/p}$ but this function definition is completely missing from the Lean formalization']"}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "Since $u_i/\\sigma(p_2)\\le1$", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2].\nTherefore, we conclude:\n\u2022 For any $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1].", "dependencies": ["tc_1", "def_1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (hp1_ge_1 : p1 \u2265 1)\n  (hp2_gt_p1 : p2 > p1)\n  (hu_nonneg : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (hsigma : \u2200 p, p \u2265 1 \u2192 sigma p = (\u2211 i, (u i)^p)^(1/p)) :\n  \u2200 i : Fin n, u i / sigma p2 \u2264 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (hp1_ge_1 : p1 \u2265 1)\n  (hp2_gt_p1 : p2 > p1)\n  (hu_nonneg : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (hsigma : \u2200 p, p \u2265 1 \u2192 sigma p = (\u2211 i, (u i)^p)^(1/p)) :\n  \u2200 i : Fin n, u i / sigma p2 \u2264 1 := by\n  intro i\n  have hp2_ge_1 : p2 \u2265 1 := by linarith [hp1_ge_1, hp2_gt_p1]\n  rw [hsigma p2 hp2_ge_1]\n  have hsum_pos : 0 < \u2211 i, (u i)^p2 := by\n    apply Finset.sum_pos\n    \u00b7 intro i _\n      exact Real.rpow_pos_of_pos (lt_of_le_of_ne (hu_nonneg i) (Ne.symm (fun h => by simp [h] at hu_nonneg))) p2\n    \u00b7 use i\n      simp [hu_nonneg i]\n  rw [div_le_iff (Real.rpow_pos_of_pos hsum_pos (1/p2))]\n  simp only [one_mul]\n  trans (max (u i) 0)\n  \u00b7 simp [hu_nonneg i]\n  \u00b7 rw [max_eq_left (hu_nonneg i)]\n    have : (u i)^p2 \u2264 \u2211 j, (u j)^p2 := by\n      apply Finset.single_le_sum (fun j _ => Real.rpow_nonneg (hu_nonneg j) p2) (Finset.mem_univ i)\n    rw [\u2190 Real.rpow_le_rpow_iff (hu_nonneg i) (Real.rpow_nonneg (Finset.sum_nonneg (fun j _ => Real.rpow_nonneg (hu_nonneg j) p2)) (1/p2)) hp2_ge_1]\n    simp [this]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 82, "endLine": 20, "endColumn": 106, "data": "unsolved goals\nn : \u2115\nu : Fin n \u2192 \u211d\np1 p2 : \u211d\nhp1_ge_1 : p1 \u2265 1\nhp2_gt_p1 : p2 > p1\nsigma : \u211d \u2192 \u211d\nhsigma : \u2200 p \u2265 1, sigma p = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\ni\u271d : Fin n\nhp2_ge_1 : p2 \u2265 1\ni : Fin n\na\u271d : i \u2208 Finset.univ\nh : u i = 0\nhu_nonneg : \u2200 (i : Fin n), 0 \u2264 u i\n\u22a2 False"}, {"line": 30, "column": 139, "endLine": 30, "endColumn": 147, "data": "application type mismatch\n  rpow_le_rpow_iff (hu_nonneg i) (rpow_nonneg (Finset.sum_nonneg fun j x => rpow_nonneg (hu_nonneg j) p2) (1 / p2))\n    hp2_ge_1\nargument\n  hp2_ge_1\nhas type\n  p2 \u2265 1 : Prop\nbut is expected to have type\n  0 < ?m.11397 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variable X in natural language appears to refer to the vector (u\u2081, u\u2082, ..., u\u2099), which is appropriately represented as u : Fin n \u2192 \u211d in Lean, though the naming is different.", "The constraints on p\u2081 and p\u2082 are correctly captured with the right inequalities and types.", "The definition of M = max{u\u1d62 | 1\u2264i\u2264n} is completely missing from the Lean formalization. This is a significant omission as M is explicitly defined in the natural language.", "The function \u03c3(p) definition is correctly formalized with the proper domain restriction p \u2265 1 and the exact mathematical formula.", "The conclusion statement is perfectly captured with the correct quantification over indices and the inequality.", "The nonnegativity constraint on the sequence is properly formalized.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable X in natural language appears to refer to the vector (u\u2081, u\u2082, ..., u\u2099), which is appropriately represented as u : Fin n \u2192 \u211d in Lean, though the naming is different.', 'The constraints on p\u2081 and p\u2082 are correctly captured with the right inequalities and types.', 'The definition of M = max{u\u1d62 | 1\u2264i\u2264n} is completely missing from the Lean formalization. This is a significant omission as M is explicitly defined in the natural language.', 'The function \u03c3(p) definition is correctly formalized with the proper domain restriction p \u2265 1 and the exact mathematical formula.', 'The conclusion statement is perfectly captured with the correct quantification over indices and the inequality.', 'The nonnegativity constraint on the sequence is properly formalized.']"}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since $u_i/\\sigma(p_2)\\le1$ and $p_2>p_1$,\n$$\n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\ge\n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2};\n$$", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1].\nTherefore, we conclude:\n\u2022 For any $i \\in \\{1, ..., n\\}$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2].", "dependencies": ["tc_1", "def_1", "def_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1) :\n  \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1) :\n  \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2 := by\n  intro i\n  have hsigma_pos : sigma p2 > 0 := by\n    have p2_ge_1 : p2 \u2265 1 := by linarith [tc_1.1, tc_1.2]\n    rw [def_2 p2 p2_ge_1]\n    apply Real.rpow_pos_of_pos\n    apply Finset.sum_pos\n    \u00b7 intro j _\n      exact Real.rpow_nonneg (def_1 j) p2\n    \u00b7 use i\n      simp\n      apply Real.rpow_pos_of_pos\n      exact lt_of_le_of_lt (def_1 i) (lt_add_one _)\n  have h := l1 i\n  rw [div_le_one hsigma_pos] at h\n  have h' : 0 \u2264 u i / sigma p2 := by\n    apply div_nonneg (def_1 i) (le_of_lt hsigma_pos)\n  exact Real.rpow_le_rpow_of_exponent_ge h' h (le_of_lt tc_1.1) tc_1.2", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 6, "endLine": 21, "endColumn": 41, "data": "type mismatch\n  rpow_nonneg (def_1 j) p2\nhas type\n  0 \u2264 u j ^ p2 : Prop\nbut is expected to have type\n  0 < u j ^ p2 : Prop"}, {"line": 24, "column": 6, "endLine": 24, "endColumn": 32, "data": "no goals to be solved"}, {"line": 30, "column": 8, "endLine": 30, "endColumn": 70, "data": "function expected at\n  rpow_le_rpow_of_exponent_ge ?m.6002 ?m.6021 (le_of_lt tc_1.left)\nterm has type\n  ?m.5984 ^ p2 \u2264 ?m.5984 ^ p1"}, {"line": 30, "column": 44, "endLine": 30, "endColumn": 45, "data": "application type mismatch\n  rpow_le_rpow_of_exponent_ge ?m.6002 h\nargument\n  h\nhas type\n  u i \u2264 sigma p2 : Prop\nbut is expected to have type\n  ?m.5984 \u2264 1 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variable X mentioned in natural language is not used in the Lean formalization, but this is acceptable since the actual mathematical content works with the sequence u_i which is properly represented as u : Fin n \u2192 \u211d", "The constraint p2 > p1 \u2227 p1 \u2265 1 perfectly captures the mathematical condition p_2 > p_1 \u2265 1", "The nonnegativity condition \u2200 i, u i \u2265 0 correctly represents that all u_i are nonnegative real numbers", "The definition of M = max{u_i | 1\u2264i\u2264n} is completely missing from the Lean formalization, which is a significant omission since it's explicitly defined in the natural language", "The sigma function definition perfectly captures the mathematical formula (\u2211u_i^p)^(1/p) with the appropriate domain constraint p \u2265 1", "The condition l1 correctly formalizes that u_i/\u03c3(p_2) \u2264 1 for all i", "The conclusion l2 perfectly matches the mathematical statement about the inequality between the two power expressions", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable X mentioned in natural language is not used in the Lean formalization, but this is acceptable since the actual mathematical content works with the sequence u_i which is properly represented as u : Fin n \u2192 \u211d', 'The constraint p2 > p1 \u2227 p1 \u2265 1 perfectly captures the mathematical condition p_2 > p_1 \u2265 1', 'The nonnegativity condition \u2200 i, u i \u2265 0 correctly represents that all u_i are nonnegative real numbers', \"The definition of M = max{u_i | 1\u2264i\u2264n} is completely missing from the Lean formalization, which is a significant omission since it's explicitly defined in the natural language\", 'The sigma function definition perfectly captures the mathematical formula (\u2211u_i^p)^(1/p) with the appropriate domain constraint p \u2265 1', 'The condition l1 correctly formalizes that u_i/\u03c3(p_2) \u2264 1 for all i', 'The conclusion l2 perfectly matches the mathematical statement about the inequality between the two power expressions']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "therefore,\n$$\n\\frac{\\sigma(p_1)}{\\sigma(p_2)}\n=\\left(\\sum_{i=1}^n\\left(\\frac{\nu_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1}\n$$", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2].\nTherefore, we conclude:\n\u2022 $\\frac{\\sigma(p_1)}{\\sigma(p_2)} = \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1}$ [l3].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2) :\n  sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2) :\n  sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1) := by\n  have hp2_ge1 : p2 \u2265 1 := by linarith [tc_1.1, tc_1.2]\n  have hsigma2_pos : sigma p2 > 0 := by\n    rw [def_2 p2 hp2_ge1]\n    apply rpow_pos_of_pos\n    apply Finset.sum_pos\n    \u00b7 intro i _\n      exact Real.rpow_nonneg (def_1 i) p2\n    \u00b7 obtain \u27e8i\u27e9 := (inferInstance : Nonempty (Fin n))\n      specialize l1 i\n      specialize def_1 i\n      have : sigma p2 \u2260 0 := by\n        intro h\n        rw [h, div_zero] at l1\n        linarith\n      exact Finset.univ_nonempty\n  rw [def_2 p1 tc_1.2, def_2 p2 hp2_ge1]\n  simp_rw [div_rpow (by positivity) (by positivity)]\n  rw [\u2190 rpow_mul (by positivity), mul_comm (1 / p1), rpow_mul (by positivity), \u2190 Finset.sum_div, \u2190 mul_rpow (by positivity) (by positivity), div_pow, rpow_sub' (by positivity), rpow_one, div_div]\n  congr 2\n  rw [mul_comm]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 6, "endLine": 21, "endColumn": 41, "data": "type mismatch\n  rpow_nonneg (def_1 i) p2\nhas type\n  0 \u2264 u i ^ p2 : Prop\nbut is expected to have type\n  0 < u i ^ p2 : Prop"}, {"line": 22, "column": 21, "endLine": 22, "endColumn": 34, "data": "failed to synthesize\n  Nonempty (Fin n)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 28, "column": 8, "endLine": 28, "endColumn": 16, "data": "linarith failed to find a contradiction\nn : \u2115\nu : Fin n \u2192 \u211d\np1 p2 : \u211d\ntc_1 : p2 > p1 \u2227 p1 \u2265 1\nsigma : \u211d \u2192 \u211d\ndef_2 : \u2200 p \u2265 1, sigma p = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nl2 : \u2200 (i : Fin n), (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2\nhp2_ge1 : p2 \u2265 1\ni : Fin n\nl1 : 0 \u2264 1\ndef_1 : u i \u2265 0\nh : sigma p2 = 0\n\u22a2 False failed"}, {"line": 29, "column": 12, "endLine": 29, "endColumn": 32, "data": "failed to synthesize\n  Nonempty (Fin n)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 31, "column": 11, "endLine": 31, "endColumn": 51, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Type declarations correctly capture the mathematical structure with n-dimensional sequences", "Constraint tc_1 perfectly matches the ordering conditions on p1 and p2", "Nonnegativity constraint def_1 correctly formalizes the requirement", "The maximum M is defined in natural language but not used in the conclusion, so its omission in Lean is acceptable", "Function definition def_2 correctly captures the p-norm formula with proper domain restriction", "Constraint l1 perfectly matches the boundedness condition", "Constraint l2 correctly formalizes the power comparison inequality", "Conclusion l3 perfectly captures the main equality statement", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l3\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2) :\n  \u00ac (sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1)) := by\n  intro h\n  have h_p2_ge_1 : p2 \u2265 1 := by linarith [tc_1.1, tc_1.2]\n  have h_sigma_pos : sigma p2 > 0 := by\n    by_contra h'\n    simp only [not_lt, le_zero_iff] at h'\n    have := def_2 p2 h_p2_ge_1\n    simp [h'] at this\n    have := def_1 0\n    simp [this] at this\n  have h_sum : (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) = 1 := by\n    rw [\u2190 h, \u2190 def_2 p1 tc_1.2]\n    simp [sigma, div_pow, div_div, mul_comm, mul_assoc, mul_left_comm]\n  have h_eq : \u2200 i, (u i / sigma p2) ^ p1 = (u i / sigma p2) ^ p2 := by\n    intro i\n    exact le_antisymm (l2 i) (pow_le_pow_of_le_one (div_nonneg (def_1 i) (le_of_lt h_sigma_pos)) (l1 i) tc_1.1)\n  have h_one : \u2203 i, u i / sigma p2 = 1 := by\n    by_contra h'\n    push_neg at h'\n    have h'' : \u2200 i, u i / sigma p2 < 1 := fun i => lt_of_le_of_ne (l1 i) (h' i)\n    have h''' : \u2200 i, (u i / sigma p2) ^ p1 > (u i / sigma p2) ^ p2 := by\n      intro i\n      refine pow_lt_pow_left ?_ (h'' i) tc_1.1\n      exact div_nonneg (def_1 i) (le_of_lt h_sigma_pos)\n    have : \u2203 i, (u i / sigma p2) ^ p1 > (u i / sigma p2) ^ p2 := by exists 0\n    simp [h_eq] at this\n  obtain \u27e8i, hi\u27e9 := h_one\n  have : sigma p2 = u i := by field_simp [hi]\n  have : sigma p2 = (Finset.sum Finset.univ fun j => u j ^ p2) ^ (1 / p2) := def_2 p2 h_p2_ge_1\n  rw [this] at hi\n  have : u i = (Finset.sum Finset.univ fun j => u j ^ p2) ^ (1 / p2) := by rw [\u2190 hi]\n  have : \u2200 j, u j = 0 \u2228 u j = u i := by\n    intro j\n    have := l2 j\n    rw [hi, \u2190 hi] at this\n    simp only [one_pow] at this\n    have := l1 j\n    rw [hi] at this\n    simp only [div_self, le_refl] at this\n    by_cases huj : u j = 0\n    \u00b7 left; exact huj\n    \u00b7 right\n      have : (u j / u i) ^ p1 \u2265 (u j / u i) ^ p2 := by rwa [hi]\n      have : (u j / u i) ^ p1 = (u j / u i) ^ p2 := by\n        refine le_antisymm ?_ this\n        refine pow_le_pow_of_le_one ?_ ?_ tc_1.1\n        \u00b7 exact (div_nonneg (def_1 j) (def_1 i))\n        \u00b7 exact (div_le_one (def_1 j)).mpr (by rwa [\u2190 hi])\n      have : u j / u i = 1 := by\n        by_contra h'\n        have h'' : u j / u i < 1 := by\n          refine lt_of_le_of_ne ?_ h'\n          exact div_le_one (def_1 j)\n        have : (u j / u i) ^ p1 > (u j / u i) ^ p2 := by\n          refine pow_lt_pow_left ?_ h'' tc_1.1\n          exact div_nonneg (def_1 j) (def_1 i)\n        linarith\n      field_simp at this\n  have : Finset.sum Finset.univ (fun j => u j ^ p2) = Finset.card Finset.univ * (u i) ^ p2 := by\n    apply Finset.sum_congr rfl\n    intro j _\n    cases this j\n    \u00b7 simp [h]\n    \u00b7 simp [h]\n  rw [this]\n  simp only [Finset.card_fin, mul_one]\n  have : u i = (n * (u i) ^ p2) ^ (1 / p2) := by rw [\u2190 this]\n  have : u i = n ^ (1 / p2) * u i := by\n    rw [mul_rpow (Nat.cast_nonneg n) (def_1 i), \u2190 rpow_mul (def_1 i)]\n    simp [this]\n    rw [mul_comm, \u2190 rpow_add (def_1 i)]\n    simp [tc_1.2.ne', (zero_lt_one.trans_le tc_1.2).ne']\n  have : u i = 0 \u2228 n ^ (1 / p2) = 1 := by\n    rw [\u2190 mul_right_inj' (u i)]\n    simp [this]\n    exact (def_1 i).ne'\n  cases this\n  \u00b7 have := def_1 i\n    simp [*] at *\n  \u00b7 have : n = 1 := by\n      rw [\u2190 rpow_eq_one_iff_of_nonneg (Nat.cast_nonneg n) (tc_1.2.ne')]\n      exact this\n    cases n\n    \u00b7 simp at this\n    \u00b7 cases n\n      \u00b7 simp\n      \u00b7 simp at this"}, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "$$\\ge\\left(\\sum_{i=1}^n\\left(\\frac{\nu_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1}$$", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2];\n\u2022 $\\frac{\\sigma(p_1)}{\\sigma(p_2)} = \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1}$ [l3].\nTherefore, we conclude:\n\u2022 $\\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1} \\ge \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1}$ [l4].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1)) :\n  (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1)) :\n  (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) := by\n  have h_sum : \u2211 i : Fin n, (u i / sigma p2) ^ p1 \u2265 \u2211 i : Fin n, (u i / sigma p2) ^ p2 := by\n    refine Finset.sum_le_sum (fun i _ => ?_)\n    exact l2 i\n  have h_nonneg : 0 \u2264 \u2211 i : Fin n, (u i / sigma p2) ^ p2 := by\n    apply Finset.sum_nonneg\n    intro i _\n    refine Real.rpow_nonneg (div_nonneg (def_1 i) ?_) p2\n    have : sigma p2 = (\u2211 i : Fin n, u i ^ p2) ^ (1 / p2) := def_2 p2 (by linarith [tc_1.1, tc_1.2])\n    rw [this]\n    exact Real.rpow_nonneg (Finset.sum_nonneg (fun i _ => Real.rpow_nonneg (def_1 i) p2)) _\n  have h_p1_pos : 0 < 1 / p1 := by\n    rw [one_div_pos]\n    exact lt_of_lt_of_le zero_lt_one tc_1.2\n  refine Real.rpow_le_rpow (by positivity) h_sum h_p1_pos.le", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0.86, "semantic_feedback": ["The constraint p2 > p1 \u2265 1 is correctly captured in Lean.", "The Lean formalization captures the nonnegativity of the sequence u_i but omits the definition of M = max{u_i}. However, since M is not used elsewhere in the statement, this is a minor omission.", "The definition of \u03c3(p) is correctly formalized using Finset.sum and appropriate exponentiation.", "The constraint u_i / \u03c3(p_2) \u2264 1 for all i is correctly captured.", "The inequality (u_i/\u03c3(p_2))^p_1 \u2265 (u_i/\u03c3(p_2))^p_2 for all i is correctly captured.", "The equation \u03c3(p_1)/\u03c3(p_2) = (\u2211(u_i/\u03c3(p_2))^p_1)^(1/p_1) is correctly captured.", "The conclusion inequality is correctly stated as the goal to be proven."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "$$\\left(\\sum_{i=1}^n\\left(\\frac{\nu_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1}=1,$$", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2];\n\u2022 $\\frac{\\sigma(p_1)}{\\sigma(p_2)} = \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1}$ [l3];\n\u2022 $\\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1} \\ge \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1}$ [l4].\nTherefore, we conclude:\n\u2022 $\\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1} = 1$ [l5].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1)) :\n  (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1)) :\n  (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1 := by\n  have h : sigma p2 = (\u2211 i : Fin n, (u i) ^ p2) ^ (1 / p2) := def_2 p2 (tc_1.2.trans (le_of_lt tc_1.1))\n  have h_sum : \u2211 i : Fin n, (u i / sigma p2) ^ p2 = 1 := by\n    rw [h]\n    simp_rw [div_rpow (def_1 _) (by positivity), \u2190 rpow_mul (def_1 _)]\n    have : \u2200 i, (u i / (\u2211 j, u j ^ p2) ^ (1 / p2)) ^ p2 = u i ^ p2 / \u2211 j, u j ^ p2 := by\n      intro i\n      rw [div_pow, \u2190 rpow_neg_one, \u2190 rpow_add (def_1 _)]\n      simp [rpow_neg_one, add_comm]\n    simp [this, sum_div_self]\n  rw [h_sum, one_rpow]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 36, "endLine": 20, "endColumn": 46, "data": "failed to prove positivity/nonnegativity/nonzeroness"}, {"line": 20, "column": 13, "endLine": 20, "endColumn": 47, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The constraint tc_1 is correctly formalized as a conjunction of the two inequalities.", "The nonnegativity condition is correctly captured, but the definition of M = max{u_i} mentioned in the natural language is omitted in the Lean formalization. However, since M is not used elsewhere, this omission doesn't affect the logical content.", "The sigma function definition is correctly formalized using Finset.sum and appropriate exponentiation.", "The inequality constraint l1 is perfectly captured.", "The inequality constraint l2 is perfectly captured.", "The equality l3 is correctly formalized.", "The inequality l4 is correctly formalized.", "The conclusion l5 is correctly stated as the goal to be proved.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.88 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l5\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1)) :\n  \u00ac (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1 := by\n  intro h\n  have sum_eq : \u2211 i : Fin n, (u i / sigma p2) ^ p2 = 1 := by\n    rw [\u2190 Real.rpow_one (\u2211 i : Fin n, (u i / sigma p2) ^ p2), \u2190 h]\n    simp [Real.rpow_mul]\n  have h1 : \u2200 i : Fin n, u i / sigma p2 = 0 \u2228 u i / sigma p2 = 1 := by\n    intro i\n    have h2 := l2 i\n    have h3 := l1 i\n    rcases le_or_lt (u i / sigma p2) 0 with hle | hlt\n    \u00b7 left\n      exact le_antisymm hle (div_nonneg (def_1 i) (by positivity))\n    \u00b7 right\n      have h4 : (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2 := by exact l2 i\n      have h5 : (u i / sigma p2) \u2264 1 := by exact l1 i\n      refine le_antisymm h5 ?_\n      have : (u i / sigma p2) ^ p2 \u2264 (u i / sigma p2) ^ p1 := by\n        rw [\u2190 Real.one_rpow (p2 - p1), \u2190 Real.div_rpow (u i / sigma p2) 1 (sub_nonneg_of_le tc_1.1)]\n        simp only [div_one]\n        apply Real.rpow_le_rpow _ _ (sub_nonneg_of_le tc_1.1)\n        \u00b7 exact hlt.le\n        \u00b7 exact h5\n      linarith [h4, this]\n  have h6 : \u2200 i : Fin n, u i / sigma p2 = 1 \u2192 False := by\n    intro i hi\n    have : \u2211 j : Fin n, (u j / sigma p2) ^ p2 = 1 := sum_eq\n    rw [Finset.sum_eq_card] at this\n    \u00b7 simp at this\n    \u00b7 intro j\n      rcases h1 j with (h0 | h1)\n      \u00b7 simp [h0]\n      \u00b7 simp [h1]\n  have h7 : \u2200 i : Fin n, u i / sigma p2 = 0 := by\n    intro i\n    rcases h1 i with (h0 | h1)\n    \u00b7 exact h0\n    \u00b7 exact False.elim (h6 i h1)\n  have h8 : sigma p2 = 0 := by\n    by_contra hne\n    have : \u2200 i : Fin n, u i = 0 := by\n      intro i\n      exact (div_eq_zero_iff.mp (h7 i)).resolve_right hne\n    have : sigma p2 = 0 := by\n      simp [def_2 _ tc_1.2, this]\n    contradiction\n  simp [h8] at sum_eq\n  have : (0 : \u211d) = 1 := by\n    rw [\u2190 sum_eq]\n    simp [h7]\n  contradiction"}, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "so $\\sigma(p_1)\\ge\\sigma(p_2)$.", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $u_i / \\sigma(p_2) \\le 1$ [l1];\n\u2022 For any $i \\in \\{1, ..., n\\}$, $\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1} \\ge \\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}$ [l2];\n\u2022 $\\frac{\\sigma(p_1)}{\\sigma(p_2)} = \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1}$ [l3];\n\u2022 $\\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_1}\\right)^{1/p_1} \\ge \\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1}$ [l4];\n\u2022 $\\left(\\sum_{i=1}^n\\left(\\frac{u_i}{\\sigma(p_2)}\\right)^{p_2}\\right)^{1/p_1} = 1$ [l5].\nTherefore, we conclude:\n\u2022 $\\sigma(p_1) \\ge \\sigma(p_2)$ [l6].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1))\n  (l5 : (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1) :\n  sigma p1 \u2265 sigma p2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1))\n  (l5 : (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1) :\n  sigma p1 \u2265 sigma p2 := by\n  have h1 : sigma p1 / sigma p2 \u2265 1 := by\n    rw [l3]\n    refine le_trans ?_ l4\n    rw [l5]\n    exact le_refl _\n  have h2 : sigma p2 > 0 := by\n    have h : sigma p2 = (\u2211 i, (u i) ^ p2) ^ (1 / p2) := def_2 p2 (tc_1.2.trans tc_1.1.le)\n    rw [h]\n    apply rpow_pos_of_pos\n    apply Finset.sum_pos\n    \u00b7 intro i _\n      apply rpow_pos_of_pos\n      exact lt_of_le_of_ne (def_1 i) (Ne.symm (by\n        intro h\n        have := l1 i\n        simp [h] at this\n        have := zero_lt_one\n        contradiction))\n    \u00b7 exact Finset.univ_nonempty\n  rw [ge_iff_le]\n  exact (le_div_iff h2).mpr h1", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 22, "column": 4, "endLine": 22, "endColumn": 19, "data": "no goals to be solved"}, {"line": 30, "column": 47, "endLine": 35, "endColumn": 21, "data": "unsolved goals\nn : \u2115\nu : Fin n \u2192 \u211d\np1 p2 : \u211d\ntc_1 : p2 > p1 \u2227 p1 \u2265 1\ndef_1 : \u2200 (i : Fin n), u i \u2265 0\nsigma : \u211d \u2192 \u211d\ndef_2 : \u2200 p \u2265 1, sigma p = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nl1 : \u2200 (i : Fin n), u i / sigma p2 \u2264 1\nl2 : \u2200 (i : Fin n), (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2\nl3 : sigma p1 / sigma p2 = (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1)\nl4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1)\nl5 : (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1\nh1 : sigma p1 / sigma p2 \u2265 1\nh\u271d : sigma p2 = (\u2211 i : Fin n, u i ^ p2) ^ (1 / p2)\ni : Fin n\na\u271d : i \u2208 Finset.univ\nh : u i = 0\nthis : True\n\u22a2 False"}, {"line": 36, "column": 12, "endLine": 36, "endColumn": 32, "data": "failed to synthesize\n  Nonempty (Fin n)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 38, "column": 28, "endLine": 38, "endColumn": 30, "data": "application type mismatch\n  (le_div_iff h2).mpr h1\nargument\n  h1\nhas type\n  sigma p1 / sigma p2 \u2265 1 : Prop\nbut is expected to have type\n  ?m.15386 * sigma p2 \u2264 ?m.15387 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["tc_1: Constraint p\u2082 > p\u2081 \u2265 1 correctly formalized", "def_1: Non-negativity of sequence u correctly captured", "def_1 (M): The definition of M = max{u\u1d62} is completely missing from Lean formalization", "def_2: Function \u03c3(p) definition correctly formalized with proper sum notation", "l1: Inequality u\u1d62/\u03c3(p\u2082) \u2264 1 correctly formalized", "l2: Power inequality correctly formalized", "l3: Equation for \u03c3(p\u2081)/\u03c3(p\u2082) correctly formalized", "l4: Sum inequality correctly formalized", "l5: Final equation equals 1 correctly formalized", "l6: Conclusion \u03c3(p\u2081) \u2265 \u03c3(p\u2082) correctly formalized", "X variable: Mentioned in natural language as X \u2208 \u211d\u207f but not present in Lean formalization, though it appears unused in the mathematical development", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=0.8 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l6\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1))\n  (l5 : (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1) :\n  \u00ac (sigma p1 \u2265 sigma p2) := by\n  simp only [not_le]\n  have h : sigma p1 / sigma p2 = 1 := by\n    rw [l3, l5]\n    exact l4\n  have : sigma p2 \u2260 0 := by\n    intro h0\n    have := def_2 p2 (by linarith [tc_1.2])\n    rw [h0] at this\n    simp at this\n    have : \u2200 i, u i = 0 := by\n      intro i\n      have := l1 i\n      rw [h0, div_zero] at this\n      exact le_antisymm (def_1 i) this\n    have : sigma p1 = 0 := by\n      rw [def_2 p1 (by linarith [tc_1.2])]\n      simp [this]\n    rw [this] at h\n    simp at h\n  rw [div_eq_one_iff_eq this] at h\n  rw [h]\n  exact tc_1.1"}, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Since $M\\le\\sigma(p)\\le Mn^{1/p}$,", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 $\\sigma(p_1) \\ge \\sigma(p_2)$ [l6].\nTherefore, we conclude:\n\u2022 $M \\le \\sigma(p) \\le M n^{1/p}$ [l7].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p : \u211d)\n  (hu_nonneg : \u2200 i, u i \u2265 0)\n  (hp_ge_1 : p \u2265 1)\n  (M : \u211d)\n  (hM : M = (Finset.univ : Finset (Fin n)).sup' (Finset.univ.nonempty) u)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (val : \u211d), val \u2265 1 \u2192 sigma val = ( Finset.sum Finset.univ fun i => (u i) ^ val ) ^ (1 / val)) :\n  M \u2264 sigma p \u2227 sigma p \u2264 M * n ^ (1 / p) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 11, "column": 49, "endLine": 11, "endColumn": 69, "data": "invalid field 'nonempty', the environment does not contain 'Finset.nonempty'\n  Finset.univ\nhas type\n  Finset ?m.428"}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p : \u211d)\n  (hu_nonneg : \u2200 i, u i \u2265 0)\n  (hp_ge_1 : p \u2265 1)\n  (M : \u211d)\n  (hM : M = Finset.sup' Finset.univ (by exact Fintype.card_pos_iff.mpr (by simp)) u)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (val : \u211d), val \u2265 1 \u2192 sigma val = ( Finset.sum Finset.univ fun i => (u i) ^ val ) ^ (1 / val)) :\n  M \u2264 sigma p \u2227 sigma p \u2264 M * n ^ (1 / p) := by\n  have hM_def : \u2200 i, u i \u2264 M := by\n    intro i\n    rw [hM]\n    exact Finset.le_sup' (by exact Fintype.card_pos_iff.mpr (by simp)) (Finset.mem_univ i)\n  have hsigma_def : sigma p = (\u2211 i, u i ^ p) ^ (1 / p) := def_2 p hp_ge_1\n  constructor\n  \u00b7 rw [hsigma_def]\n    have hM_nonneg : 0 \u2264 M := by\n      obtain \u27e8i\u27e9 := Fintype.card_pos_iff.mp (by simp)\n      exact (hu_nonneg i).trans (hM_def i)\n    have hsum_nonneg : 0 \u2264 \u2211 i, u i ^ p := by\n      apply Finset.sum_nonneg\n      intro i _\n      exact Real.rpow_nonneg (hu_nonneg i) p\n    have hp_pos : 0 < p := by linarith\n    have h_div_pos : 0 < 1 / p := by positivity\n    rw [\u2190 Real.rpow_le_rpow_iff hM_nonneg hsum_nonneg h_div_pos]\n    simp [\u2190 Real.rpow_mul hsum_nonneg]\n    rw [\u2190 hM]\n    rw [mul_comm, Real.rpow_mul hM_nonneg]\n    simp [Real.rpow_one]\n    rw [\u2190 Finset.sum_const]\n    apply Finset.sum_le_sum\n    intro i _\n    exact Real.rpow_le_rpow (hu_nonneg i) (hM_def i) hp_ge_1\n  \u00b7 rw [hsigma_def]\n    have hsum_nonneg : 0 \u2264 \u2211 i, u i ^ p := by\n      apply Finset.sum_nonneg\n      intro i _\n      exact Real.rpow_nonneg (hu_nonneg i) p\n    have hM_nonneg : 0 \u2264 M := by\n      obtain \u27e8i\u27e9 := Fintype.card_pos_iff.mp (by simp)\n      exact (hu_nonneg i).trans (hM_def i)\n    have hn_nonneg : 0 \u2264 (n : \u211d) := Nat.cast_nonneg n\n    have hp_pos : 0 < p := by linarith\n    have h_div_pos : 0 < 1 / p := by positivity\n    rw [\u2190 Real.rpow_le_rpow_iff hsum_nonneg (mul_nonneg hM_nonneg (Real.rpow_nonneg hn_nonneg (1 / p))) h_div_pos]\n    simp [\u2190 Real.rpow_mul hsum_nonneg]\n    trans (\u2211 i, M ^ p)\n    \u00b7 apply Finset.sum_le_sum\n      intro i _\n      exact Real.rpow_le_rpow (hu_nonneg i) (hM_def i) hp_ge_1\n    \u00b7 rw [Finset.sum_const, Finset.card_univ, Finset.card_fin]\n      simp [Real.rpow_mul hM_nonneg, mul_comm]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 11, "column": 75, "endLine": 11, "endColumn": 79, "data": "simp made no progress"}, {"line": 18, "column": 64, "endLine": 18, "endColumn": 68, "data": "simp made no progress"}, {"line": 23, "column": 48, "endLine": 23, "endColumn": 52, "data": "simp made no progress"}, {"line": 31, "column": 8, "endLine": 31, "endColumn": 63, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  M \u2264 \u2211 i : Fin n, u i ^ p\ncase left\nn : \u2115\nu : Fin n \u2192 \u211d\np : \u211d\nhu_nonneg : \u2200 (i : Fin n), u i \u2265 0\nhp_ge_1 : p \u2265 1\nM : \u211d\nhM : M = Finset.univ.sup' \u22ef u\nsigma : \u211d \u2192 \u211d\ndef_2 : \u2200 val \u2265 1, sigma val = (\u2211 i : Fin n, u i ^ val) ^ (1 / val)\nhM_def : \u2200 (i : Fin n), u i \u2264 M\nhsigma_def : sigma p = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nhM_nonneg : 0 \u2264 M\nhsum_nonneg : 0 \u2264 \u2211 i : Fin n, u i ^ p\nhp_pos : 0 < p\nh_div_pos : 0 < 1 / p\n\u22a2 M \u2264 (\u2211 i : Fin n, u i ^ p) ^ (1 / p)"}, {"line": 46, "column": 48, "endLine": 46, "endColumn": 52, "data": "simp made no progress"}, {"line": 51, "column": 8, "endLine": 51, "endColumn": 113, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  \u2211 i : Fin n, u i ^ p \u2264 M * \u2191n ^ (1 / p)\ncase right\nn : \u2115\nu : Fin n \u2192 \u211d\np : \u211d\nhu_nonneg : \u2200 (i : Fin n), u i \u2265 0\nhp_ge_1 : p \u2265 1\nM : \u211d\nhM : M = Finset.univ.sup' \u22ef u\nsigma : \u211d \u2192 \u211d\ndef_2 : \u2200 val \u2265 1, sigma val = (\u2211 i : Fin n, u i ^ val) ^ (1 / val)\nhM_def : \u2200 (i : Fin n), u i \u2264 M\nhsigma_def : sigma p = (\u2211 i : Fin n, u i ^ p) ^ (1 / p)\nhsum_nonneg : 0 \u2264 \u2211 i : Fin n, u i ^ p\nhM_nonneg : 0 \u2264 M\nhn_nonneg : 0 \u2264 \u2191n\nhp_pos : 0 < p\nh_div_pos : 0 < 1 / p\n\u22a2 (\u2211 i : Fin n, u i ^ p) ^ (1 / p) \u2264 M * \u2191n ^ (1 / p)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "l8": {"id": "l8", "natural_language": "$\\lim_{p\\to\\infty}\\sigma(p)= M$.", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 Let $u_1, u_2, \\dots, u_n$ be a sequence of $n$ nonnegative real numbers and let $M = \\max\\set{u_i}{1\\le i\\le n}$ [def_1];\n\u2022 Define the function $\\sigma(p) = \\left(\\sum_{i=1}^n u_i^p\\right)^{1/p}$ for $p \\ge 1$ [def_2];\n\u2022 $\\sigma(p_1) \\ge \\sigma(p_2)$ [l6];\n\u2022 $M \\le \\sigma(p) \\le M n^{1/p}$ [l7].\nTherefore, we conclude:\n\u2022 $\\lim_{p\\to\\infty}\\sigma(p)= M$ [l8].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {n : \u2115}\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d) (M : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : (\u2200 i : Fin n, u i \u2265 0) \u2227 M = Finset.sup Finset.univ u)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p_val : \u211d), p_val \u2265 1 \u2192 sigma p_val = (Finset.sum Finset.univ fun i => (u i) ^ p_val) ^ (1 / p_val))\n  (l6 : \u2200 p1_val p2_val, p2_val > p1_val \u2227 p1_val \u2265 1 \u2192 sigma p1_val \u2265 sigma p2_val)\n  (l7 : \u2200 p_val : \u211d, p_val \u2265 1 \u2192 M \u2264 sigma p_val \u2227 sigma p_val \u2264 M * (n : \u211d) ^ (1 / p_val)) :\n  Filter.Tendsto sigma Filter.atTop (nhds M) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 9, "column": 40, "endLine": 9, "endColumn": 64, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l8\n  {n : \u2115} (hn : n \u2260 0)\n  (u : Fin n \u2192 \u211d) (p1 p2 : \u211d) (M : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (def_1 : (\u2200 i : Fin n, u i \u2265 0) \u2227 M = Finset.sup' Finset.univ (Finset.univ_nonempty.mpr hn) u)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p_val : \u211d), p_val \u2265 1 \u2192 sigma p_val = (Finset.sum Finset.univ fun i => (u i) ^ p_val) ^ (1 / p_val))\n  (l6 : \u2200 p1_val p2_val, p2_val > p1_val \u2227 p1_val \u2265 1 \u2192 sigma p1_val \u2265 sigma p2_val)\n  (l7 : \u2200 p_val : \u211d, p_val \u2265 1 \u2192 M \u2264 sigma p_val \u2227 sigma p_val \u2264 M * (n : \u211d) ^ (1 / p_val)) :\n  Filter.Tendsto sigma Filter.atTop (nhds M) := by\n  have hM : M \u2265 0 := by\n    obtain \u27e8h\u2081, h\u2082\u27e9 := def_1\n    rw [h\u2082]\n    apply Finset.le_sup' (fun i => u i) (Finset.mem_univ 0)\n    exact h\u2081 0\n  have mono : MonotoneOn sigma (Set.Ici 1) := by\n    intro p1_val hp1 p2_val hp2 hle\n    exact l6 p1_val p2_val \u27e8hle, hp1\u27e9\n  refine tendsto_atTop_nhds_of_monotone mono ?_\n  intro \u03b5 h\u03b5\n  have hn' : (n : \u211d) \u2265 1 := by exact_mod_cast Nat.one_le_of_lt (Nat.pos_of_ne_zero hn)\n  have hM_pos : M = 0 \u2228 M > 0 := by exact LE.le.eq_or_gt hM\n  cases hM_pos with\n  | inl hM_zero =>\n    use 1\n    intro p hp\n    simp [hM_zero] at *\n    obtain \u27e8h\u2081, h\u2082\u27e9 := l7 p hp\n    rw [hM_zero] at h\u2082\n    simp [abs_le, h\u2081, h\u2082]\n  | inr hM_pos =>\n    have h : \u2203 p, p \u2265 1 \u2227 M * (n : \u211d) ^ (1 / p) - M < \u03b5 := by\n      have h\u2081 : Tendsto (fun p : \u211d => M * (n : \u211d) ^ (1 / p)) atTop (nhds (M * 1)) := by\n        refine Tendsto.const_mul _ (tendsto_rpow_div (by linarith) (by norm_cast))\n        simp\n      have h\u2082 : M * 1 = M := mul_one M\n      rw [h\u2082] at h\u2081\n      have h\u2083 : Tendsto (fun p : \u211d => M * (n : \u211d) ^ (1 / p) - M) atTop (nhds 0) := by\n        simp [h\u2081]\n      have h\u2084 : \u2200\u1da0 p in atTop, |M * (n : \u211d) ^ (1 / p) - M - 0| < \u03b5 :=\n        Metric.tendsto_atTop.mp h\u2083 \u03b5 h\u03b5\n      simp at h\u2084\n      obtain \u27e8p, hp\u27e9 := h\u2084\n      use max p 1\n      constructor\n      \u00b7 exact le_max_right p 1\n      \u00b7 exact hp (max p 1) (le_max_left p 1)\n    obtain \u27e8p, hp\u27e9 := h\n    use p\n    intro q hq\n    obtain \u27e8h\u2081, h\u2082\u27e9 := l7 q hq\n    rw [abs_le]\n    constructor\n    \u00b7 linarith\n    \u00b7 have h\u2083 := l6 p q \u27e8hq, hp.1\u27e9\n      have h\u2084 := h\u2082.trans (mul_le_mul_of_nonneg_left (rpow_le_rpow_of_exponent_le hn' (one_div_le_one_div_of_le hq hp.1)) hM)\n      linarith", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 9, "column": 65, "endLine": 9, "endColumn": 92, "data": "invalid field 'mpr', the environment does not contain 'Finset.Nonempty.mpr'\n  Finset.univ_nonempty\nhas type\n  Finset.univ.Nonempty"}, {"line": 9, "column": 65, "endLine": 9, "endColumn": 92, "data": "invalid field 'mpr', the environment does not contain 'Exists.mpr'\n  Finset.univ_nonempty\nhas type\n  \u2203 x, x \u2208 Finset.univ"}, {"line": 18, "column": 57, "endLine": 18, "endColumn": 58, "data": "failed to synthesize\n  OfNat (Fin n) 0\nnumerals are polymorphic in Lean, but the numeral `0` cannot be used in a context where the expected type is\n  Fin n\ndue to the absence of the instance above\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 22, "column": 28, "endLine": 22, "endColumn": 31, "data": "application type mismatch\n  And.intro hle\nargument\n  hle\nhas type\n  p1_val \u2264 p2_val : Prop\nbut is expected to have type\n  p2_val > p1_val : Prop"}, {"line": 23, "column": 9, "endLine": 23, "endColumn": 39, "data": "unknown identifier 'tendsto_atTop_nhds_of_monotone'"}, {"line": 24, "column": 2, "endLine": 24, "endColumn": 12, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Letting  $u_i=|x_i|$  yields \\eqref{eq:8.1.12} and \\eqref{eq:8.1.13}.", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 For a sequence of $n$ nonnegative numbers $u_i$, if $\\sigma(p) = (\\sum u_i^p)^{1/p}$, then $\\sigma(p_1) \\ge \\sigma(p_2)$ [l6];\n\u2022 The p-norm of $\\mathbf{X}$ is defined as $\\|\\mathbf{X}\\|_{p} = (\\sum_{i=1}^n |x_i|^p)^{1/p}$.\nTherefore, we conclude:\n\u2022 $\\|\\mathbf{X}\\|_{p_2} \\le \\|\\mathbf{X}\\|_{p_1}$ [ts_1].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "l8"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (X : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (u : Fin n \u2192 \u211d)\n  (def_1_X_u : \u2200 i, u i = |X i|)\n  (def_1_nonneg : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1))\n  (l5 : (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1)\n  (l6 : sigma p1 \u2265 sigma p2) :\n  (\u2211 i : Fin n, |X i| ^ p2) ^ (1 / p2) \u2264 (\u2211 i : Fin n, |X i| ^ p1) ^ (1 / p1) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {n : \u2115} (X : Fin n \u2192 \u211d) (p1 p2 : \u211d)\n  (tc_1 : p2 > p1 \u2227 p1 \u2265 1)\n  (u : Fin n \u2192 \u211d)\n  (def_1_X_u : \u2200 i, u i = |X i|)\n  (def_1_nonneg : \u2200 i, u i \u2265 0)\n  (sigma : \u211d \u2192 \u211d)\n  (def_2 : \u2200 (p : \u211d), p \u2265 1 \u2192 sigma p = ( Finset.sum Finset.univ fun i => (u i) ^ p ) ^ (1 / p))\n  (l1 : \u2200 i : Fin n, u i / sigma p2 \u2264 1)\n  (l2 : \u2200 i : Fin n, (u i / sigma p2) ^ p1 \u2265 (u i / sigma p2) ^ p2)\n  (l3 : sigma p1 / sigma p2 = (Finset.sum Finset.univ (fun i => (u i / sigma p2) ^ p1)) ^ (1 / p1))\n  (l4 : (\u2211 i : Fin n, (u i / sigma p2) ^ p1) ^ (1 / p1) \u2265 (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1))\n  (l5 : (\u2211 i : Fin n, (u i / sigma p2) ^ p2) ^ (1 / p1) = 1)\n  (l6 : sigma p1 \u2265 sigma p2) :\n  (\u2211 i : Fin n, |X i| ^ p2) ^ (1 / p2) \u2264 (\u2211 i : Fin n, |X i| ^ p1) ^ (1 / p1) := by\n  have h1 : sigma p1 = (\u2211 i : Fin n, |X i| ^ p1) ^ (1 / p1) := by\n    rw [def_2 p1 tc_1.2]\n    simp [def_1_X_u]\n  have h2 : sigma p2 = (\u2211 i : Fin n, |X i| ^ p2) ^ (1 / p2) := by\n    rw [def_2 p2 (le_trans tc_1.2 (le_of_lt tc_1.1))]\n    simp [def_1_X_u]\n  rw [\u2190 h1, \u2190 h2]\n  exact l6", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 2}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The variable declarations and basic conditions (X \u2208 \u211d\u207f, p\u2082 > p\u2081 \u2265 1) are correctly formalized.", "The nonnegative sequence condition is properly captured with explicit nonnegativity constraints.", "The definition of \u03c3(p) as (\u2211u\u1d62\u1d56)^(1/p) is accurately formalized using Lean's sum notation.", "The key assumption \u03c3(p\u2081) \u2265 \u03c3(p\u2082) is correctly stated as l6.", "The connection between the sequence u and the vector X through absolute values is properly established.", "The conclusion about p-norm inequality is correctly formalized using the standard p-norm definition.", "The additional lemmas l1-l5 represent intermediate proof steps that are mathematically consistent with the overall argument, though not explicitly mentioned in the natural language. These are acceptable as they support the logical flow."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "ts_2": {"id": "ts_2", "natural_language": "Letting  $u_i=|x_i|$  yields \\eqref{eq:8.1.12} and \\eqref{eq:8.1.13}.", "statement": "We assume:\n\u2022 $\\mathbf{X} \\in \\R^n$ and $p_1, p_2$ are real numbers such that $p_2 > p_1 \\ge 1$ [tc_1];\n\u2022 For a sequence of $n$ nonnegative numbers $u_i$ with maximum $M$, if $\\sigma(p) = (\\sum u_i^p)^{1/p}$, then $\\lim_{p\\to\\infty}\\sigma(p)= M$ [l8];\n\u2022 The p-norm of $\\mathbf{X}$ is defined as $\\|\\mathbf{X}\\|_{p} = (\\sum_{i=1}^n |x_i|^p)^{1/p}$.\nTherefore, we conclude:\n\u2022 $\\lim_{p\\to\\infty}\\|\\mathbf{X}\\|_{p}=\\max\\set{|x_i|}{1\\le i\\le n}$ [ts_2].", "dependencies": ["tc_1", "def_1", "def_2", "l1", "l2", "l3", "l4", "l5", "l6", "l7", "l8", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (X : Fin n \u2192 \u211d)\n  (tc_1 : (\u2203 p1 p2 : \u211d, p2 > p1 \u2227 p1 \u2265 1))\n  (l8 : \u2200 (u : Fin n \u2192 \u211d) (M : \u211d), (\u2200 i, u i \u2265 0) \u2192 M = Finset.univ.sup u \u2192 (Filter.Tendsto (fun p : \u211d => (\u2211 i : Fin n, (u i)^p)^(1/p)) Filter.atTop (nhds M))) :\n  Filter.Tendsto (fun p : \u211d => (\u2211 i : Fin n, |X i|^p)^(1/p)) Filter.atTop (nhds (Finset.univ.sup (fun i : Fin n => |X i|))) := by\nsorry", "lean_pass": false, "error_msg": [{"line": 8, "column": 56, "endLine": 8, "endColumn": 73, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 81, "endLine": 9, "endColumn": 121, "data": "failed to synthesize\n  OrderBot \u211d\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {n : \u2115} (X : Fin n \u2192 \u211d)\n  (tc_1 : (\u2203 p1 p2 : \u211d, p2 > p1 \u2227 p1 \u2265 1))\n  (l8 : \u2200 (u : Fin n \u2192 \u211d) (M : \u211d), (\u2200 i, u i \u2265 0) \u2192 M = Finset.sup' Finset.univ (Finset.univ_nonempty) u \u2192 (Filter.Tendsto (fun p : \u211d => (\u2211 i : Fin n, (u i)^p)^(1/p)) Filter.atTop (nhds M))) :\n  Filter.Tendsto (fun p : \u211d => (\u2211 i : Fin n, |X i|^p)^(1/p)) Filter.atTop (nhds (Finset.sup' Finset.univ Finset.univ_nonempty (fun i : Fin n => |X i|))) := by\n  apply l8 (fun i => |X i|) (Finset.sup' Finset.univ Finset.univ_nonempty (fun i => |X i|))\n  \u00b7 intro i\n    exact abs_nonneg (X i)\n  \u00b7 rfl", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 8, "column": 81, "endLine": 8, "endColumn": 101, "data": "failed to synthesize\n  Nonempty (Fin n)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 105, "endLine": 9, "endColumn": 125, "data": "failed to synthesize\n  Nonempty (Fin n)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 10, "column": 53, "endLine": 10, "endColumn": 73, "data": "failed to synthesize\n  Nonempty (Fin n)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}, {"line": 9, "column": 156, "endLine": 13, "endColumn": 7, "data": "unsolved goals\nn : \u2115\nX : Fin n \u2192 \u211d\ntc_1 : \u2203 p1, \u2203 p2 > p1, p1 \u2265 1\nl8 :\n  \u2200 (u : Fin n \u2192 \u211d) (M : \u211d),\n    (\u2200 (i : Fin n), u i \u2265 0) \u2192\n      M = Finset.univ.sup' \u22ef u \u2192 Tendsto (fun p => (\u2211 i : Fin n, u i ^ p) ^ (1 / p)) atTop (\ud835\udcdd M)\n\u22a2 Nonempty (Fin n)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#fa2c07", "highlight": {"background": "#cfb795", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l8", "label": "l8", "color": {"background": "#8dafcc", "border": "#fa2c07", "highlight": {"background": "#8dafcc", "border": "#fa2c07"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#fa2c07", "highlight": {"background": "#a3c2a8", "border": "#fa2c07"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "l8", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l8", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    