
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: \iprop{root bound}
Let $f\in k[x]$ be a nonzero polynomial
over a field $k$.  Then there are at most
$\deg(f)$ elements $\alpha\in k$ such that $f(\alpha)=0$.

Proof: We prove the proposition by induction on $\deg(f)$.  The cases in
which
$\deg(f)\leq 1$ are clear.  Write
$f = a_n x^n + \cdots a_1 x + a_0$.  If
$f(\alpha)=0$, then
\begin{align*}
 f(x) &= f(x) - f(\alpha)\\
      &= a_n(x^n-\alpha^n) + \cdots + a_1(x-\alpha) + a_0(1-1)\\
      &= (x-\alpha)(a_n(x^{n-1}+\cdots + \alpha^{n-1}) + \cdots + a_2(x+\alpha) + a_1)\\
      &= (x-\alpha)g(x),
\end{align*}
for some polynomial $g(x)\in k[x]$.
Next, suppose that $f(\beta)=0$ with $\beta
eq \alpha$.  Then
$(\beta-\alpha) g(\beta) = 0$, so, since $\beta-\alpha
eq 0$ and $k$
is a field,  we have $g(\beta)=0$.
By our inductive hypothesis,~$g$ has at most $n-1$ roots, so
there are at most $n-1$ possibilities for~$\beta$.
It follows that~$f$ has at most~$n$ roots.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $f\\in k[x]$ be a nonzero polynomial over a field $k$.", "statement": "Premise:\n\u2022 k is a field [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (k : Type*)\n(tc_1 : Field k)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that k is a field using the standard typeclass approach where k is declared as a Type* and tc_1 provides the Field instance", "Both the natural language and Lean code contain no conclusions or propositions to prove, only premise declarations"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "Let $f\\in k[x]$ be a nonzero polynomial over a field $k$.", "statement": "Premise:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (k : Type*)\n  (tc_1 : Field k)\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that k is a field through the Field type class instance, which is the standard way to express this in Lean", "The Lean formalization correctly represents f as a polynomial over k using Polynomial k (equivalent to k[x]) and captures the nonzero condition with f \u2260 0"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "We prove the proposition by induction on $\\deg(f)$.", "statement": "Definition:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] [tc_2];\n\u2022 Let n be the degree of f, n = deg(f) [def_1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (k : Type*)\n  (tc_1 : Field k)\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.67, "semantic_feedback": ["The Lean formalization `(tc_1 : Field k)` perfectly captures that k is a field", "The Lean formalization `(f : Polynomial k)` with `(tc_2 : f \u2260 0)` correctly represents that f is a nonzero polynomial in k[x]. The type `Polynomial k` is the standard way to represent polynomials over field k in Lean", "The natural language uses `deg(f)` while Lean uses `f.degree`. In Lean's Mathlib, `f.degree` returns a value of type `WithBot \u2115` (natural number with bottom element) rather than just `\u2115`. This is a minor notational difference in how degree is represented, but the semantic meaning is the same"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "The cases in which $\\deg(f)\\leq 1$ are clear.", "statement": "We assume:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] [tc_2];\n\u2022 n is the degree of f [def_1].\nTherefore, we conclude:\n\u2022 If n \u2264 1, then f has at most n roots in k [l1].", "dependencies": ["tc_1", "tc_2", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree) :\n  n \u2264 1 \u2192 (f.roots.toFinset.card \u2264 n) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.natDegree) :\n  n \u2264 1 \u2192 (f.roots.toFinset.card \u2264 n) := by\n  intro h\n  rw [def_1]\n  cases' n with n\n  \u00b7 simp [Polynomial.natDegree_eq_zero_iff_degree_le_zero.1 (by rw [\u2190def_1]; simp [h]), Polynomial.roots_zero]\n  \u00b7 cases' n with n\n    \u00b7 simp [Polynomial.card_roots (Polynomial.ne_zero_of_natDegree_gt (by rw [\u2190def_1]; simp [h])), Polynomial.degree_le_one_iff_card_roots_le_one.1 (by rw [\u2190Polynomial.degree_eq_natDegree tc_2, \u2190def_1]; simp [h])]\n    \u00b7 simp at h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 15, "column": 77, "endLine": 15, "endColumn": 85, "data": "no goals to be solved"}, {"line": 15, "column": 4, "endLine": 15, "endColumn": 110, "data": "simp made no progress"}, {"line": 17, "column": 71, "endLine": 17, "endColumn": 95, "data": "unsolved goals\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nf : Polynomial k\ntc_2 : f \u2260 0\ndef_1 : 0 + 1 = f.natDegree\nh : 0 + 1 \u2264 1\n\u22a2 ?m.1841 = 0"}, {"line": 17, "column": 99, "endLine": 17, "endColumn": 212, "data": "unknown constant 'Polynomial.degree_le_one_iff_card_roots_le_one'"}, {"line": 17, "column": 6, "endLine": 17, "endColumn": 213, "data": "simp made no progress"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly and completely captures all logical and mathematical meaning from the natural language. The field assumption, nonzero polynomial condition, degree definition, and conditional conclusion about the number of roots are all properly formalized. The additional DecidableEq constraint is a technical requirement that doesn't alter the mathematical meaning but makes the formalization computationally tractable.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter Polynomial\n\nlemma neg_l1\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree) :\n  \u2203 (h : n \u2264 1), \u00ac(f.roots.toFinset.card \u2264 n) := by\n  let k := ZMod 2\n  let f : Polynomial k := Polynomial.X * (Polynomial.X - 1)\n  have hf : f \u2260 0 := by simp\n  have hn : f.degree = 2 := by\n    rw [degree_mul, degree_X, degree_sub, degree_X, degree_one]\n    simp\n  refine \u27e8by simp, ?_\u27e9\n  rw [hn]\n  simp\n  have : (f.roots.toFinset.card : \u2115) = 2 := by\n    rw [roots_mul, Multiset.toFinset_add, Finset.card_union_eq]\n    \u00b7 simp [X_sub_C_ne_zero, X_ne_zero]\n    \u00b7 simp [X_sub_C_ne_zero, X_ne_zero]\n  linarith"}, "type": "lemma"}, "def_2": {"id": "def_2", "natural_language": "We prove the proposition by induction on $\\deg(f)$.", "statement": "Definition:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] [tc_2];\n\u2022 n is the degree of f [def_1];\n\u2022 If n \u2264 1, f has at most n roots [l1];\n\u2022 For the inductive step, we assume n > 1 and that for any nonzero polynomial h in k[x] with deg(h) < n, h has at most deg(h) roots in k. This is the inductive hypothesis [def_2].", "dependencies": ["tc_1", "tc_2", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (l1 : n \u2264 1 \u2192 (f.roots.toFinset.card \u2264 n))\n  (def_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.degree < n \u2192 h.roots.toFinset.card \u2264 h.degree)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization correctly captures k as a field, with additional DecidableEq constraint which is fine as an extra detail", "Both specify f as a nonzero polynomial in k[x]", "Both define n as the degree of f", "The natural language states n > 1 as a condition, but this is completely missing from the Lean formalization", "Both express the inductive hypothesis that any nonzero polynomial h with degree less than n has at most deg(h) roots", "The natural language lists this as a conclusion, but in Lean it appears as a hypothesis/assumption rather than something to be proven"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The Lean formalization correctly captures k as a field, with additional DecidableEq constraint which is fine as an extra detail', 'Both specify f as a nonzero polynomial in k[x]', 'Both define n as the degree of f', 'The natural language states n > 1 as a condition, but this is completely missing from the Lean formalization', 'Both express the inductive hypothesis that any nonzero polynomial h with degree less than n has at most deg(h) roots', 'The natural language lists this as a conclusion, but in Lean it appears as a hypothesis/assumption rather than something to be proven']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "If $f(\\alpha)=0$, then\n\\begin{align*}\n f(x) &= f(x) - f(\\alpha)\\\\\n      &= a_n(x^n-\\alpha^n) + \\cdots + a_1(x-\\alpha) + a_0(1-1)\\\\\n      &= (x-\\alpha)(a_n(x^{n-1}+\\cdots + \\alpha^{n-1}) + \\cdots + a_2(x+\\alpha) + a_1)\\\\\n      &= (x-\\alpha)g(x),\n\\end{align*}\nfor some polynomial $g(x)\\in k[x]$.", "statement": "We assume:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] with degree n > 1 [tc_2, def_1, def_2];\n\u2022 Assume f has at least one root \u03b1 in k [def_3_assumption].\nTherefore, we conclude:\n\u2022 There exists a polynomial g in k[x] such that f(x) = (x-\u03b1)g(x) and deg(g) = n-1 [l2].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (k : Type*) [Field k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (def_3_assumption : f.IsRoot \u03b1) :\n  \u2203 g : Polynomial k, f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (k : Type*) [Field k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (def_3_assumption : f.IsRoot \u03b1) :\n  \u2203 g : Polynomial k, f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115) := by\n  have h := Polynomial.dvd_iff_isRoot.mpr def_3_assumption\n  obtain \u27e8g, hg\u27e9 := h\n  use g\n  constructor\n  \u00b7 exact hg\n  \u00b7 rw [hg, def_1, Polynomial.degree_mul]\n    \u00b7 simp [Polynomial.degree_X_sub_C]\n    \u00b7 simp [Polynomial.X_sub_C_ne_zero]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 19, "column": 8, "endLine": 19, "endColumn": 10, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  f\ncase h.right\nk : Type u_1\ninst\u271d : Field k\nf : Polynomial k\ntc_2 : f \u2260 0\nn : \u2115\ndef_1 : \u2191n = f.degree\n\u03b1 : k\ndef_3_assumption : f.IsRoot \u03b1\ng : Polynomial k\nhg : f = (Polynomial.X - Polynomial.C \u03b1) * g\n\u22a2 g.degree = \u2191(n - 1)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Field assumption correctly formalized with appropriate type class instance", "Polynomial declaration and non-zero condition properly captured", "Missing the crucial constraint n > 1 that is explicitly stated in the natural language. This constraint is mathematically significant and should be included as a hypothesis", "Root assumption correctly formalized using IsRoot predicate", "Conclusion structure perfectly captures the factorization theorem with correct degree relationship", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Field assumption correctly formalized with appropriate type class instance', 'Polynomial declaration and non-zero condition properly captured', 'Missing the crucial constraint n > 1 that is explicitly stated in the natural language. This constraint is mathematically significant and should be included as a hypothesis', 'Root assumption correctly formalized using IsRoot predicate', 'Conclusion structure perfectly captures the factorization theorem with correct degree relationship']"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Next, suppose that $f(\\beta)=0$ with $\\beta\\neq \\alpha$. Then $(\\beta-\\alpha) g(\\beta) = 0$, so, since $\\beta-\\alpha\\neq 0$ and $k$ is a field, we have $g(\\beta)=0$.", "statement": "We assume:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] with degree n > 1 [tc_2, def_1, def_2];\n\u2022 f(x) = (x-\u03b1)g(x) for some root \u03b1 and polynomial g with deg(g) = n-1 [l2].\nTherefore, we conclude:\n\u2022 If \u03b2 is a root of f and \u03b2 \u2260 \u03b1, then \u03b2 must be a root of g [l3].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "def_2", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (\u03b2 : k) :\n  f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (\u03b2 : k) :\n  f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2 := by\n  intro hf h\u03b2\n  rw [l2.1] at hf\n  simp only [Polynomial.IsRoot, Polynomial.eval_mul, Polynomial.eval_sub, Polynomial.eval_X, Polynomial.eval_C] at hf\n  have h : \u03b2 - \u03b1 \u2260 0 := by rwa [sub_ne_zero]\n  cases mul_eq_zero.1 hf with\n  | inl h' => contradiction\n  | inr h' => exact h'", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization is mostly accurate but missing the important constraint 'n > 1' (degree greater than 1) that is explicitly stated in the natural language. While other differences like the addition of [DecidableEq k] or the way variables are introduced are acceptable technical details, the missing degree constraint represents a gap in capturing the complete logical meaning of the natural language statement."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization is mostly accurate but missing the important constraint 'n > 1' (degree greater than 1) that is explicitly stated in the natural language. While other differences like the addition of [DecidableEq k] or the way variables are introduced are acceptable technical details, the missing degree constraint represents a gap in capturing the complete logical meaning of the natural language statement.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "By our inductive hypothesis,~$g$ has at most $n-1$ roots", "statement": "We assume:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] with n > 1 [tc_2, def_1, def_2];\n\u2022 The inductive hypothesis holds for polynomials of degree < n [def_2];\n\u2022 There exists a polynomial g with deg(g) = n-1 such that any root of f other than \u03b1 is a root of g [l2, l3].\nTherefore, we conclude:\n\u2022 The polynomial g has at most n-1 roots [l4].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "def_2", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (def_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.degree < n \u2192 h.roots.toFinset.card \u2264 h.degree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (l3 : \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) :\n  g.roots.toFinset.card \u2264 n - 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.natDegree)\n  (def_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.natDegree < n \u2192 h.roots.toFinset.card \u2264 h.natDegree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.natDegree = n - 1)\n  (l3 : \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) :\n  g.roots.toFinset.card \u2264 n - 1 := by\n  have g_ne_zero : g \u2260 0 := by\n    intro h\n    rw [h, mul_zero] at l2\n    exact tc_2 l2.1\n  have h_deg : g.natDegree < n := by\n    rw [l2.2, def_1]\n    exact Nat.sub_lt (Nat.pos_of_ne_zero (by rw [def_1]; exact natDegree_ne_zero_of_ne_zero tc_2)) (by decide)\n  specialize def_2_hyp g g_ne_zero h_deg\n  rwa [l2.2] at def_2_hyp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 23, "column": 49, "endLine": 23, "endColumn": 54, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  n\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nf : Polynomial k\ntc_2 : f \u2260 0\nn : \u2115\ndef_1 : n = f.natDegree\ndef_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.natDegree < n \u2192 h.roots.toFinset.card \u2264 h.natDegree\n\u03b1 : k\ng : Polynomial k\nl2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.natDegree = n - 1\nl3 : \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2\ng_ne_zero : g \u2260 0\n\u22a2 f.natDegree \u2260 0"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization is largely accurate and captures most of the logical structure from the natural language. However, there is one notable omission: the constraint 'n > 1' mentioned in the natural language is missing from the Lean formalization. This constraint could be important for the validity of the theorem. The Lean version provides additional structural details (like the explicit factorization f = (X - \u03b1) * g) that are mathematically consistent and actually strengthen the statement, which is acceptable. The core logical flow from assumptions to conclusion is preserved correctly.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization is largely accurate and captures most of the logical structure from the natural language. However, there is one notable omission: the constraint 'n > 1' mentioned in the natural language is missing from the Lean formalization. This constraint could be important for the validity of the theorem. The Lean version provides additional structural details (like the explicit factorization f = (X - \u03b1) * g) that are mathematically consistent and actually strengthen the statement, which is acceptable. The core logical flow from assumptions to conclusion is preserved correctly.\"]"}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "so there are at most $n-1$ possibilities for~$\\beta$.", "statement": "We assume:\n\u2022 Any root of f other than \u03b1 is also a root of g [l3];\n\u2022 The polynomial g has at most n-1 roots [l4].\nTherefore, we conclude:\n\u2022 There are at most n-1 roots of f that are not equal to \u03b1 [l5].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "def_2", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (l3 : \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2)\n  (l4 : g.roots.toFinset.card \u2264 n - 1) :\n  (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (l3 : \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2)\n  (l4 : g.roots.toFinset.card \u2264 n - 1) :\n  (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1 := by\n  have h : (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)) \u2286 g.roots.toFinset := by\n    intro \u03b2 h\u03b2\n    simp only [Finset.mem_filter, Finset.mem_def, Multiset.mem_toFinset] at h\u03b2\n    have h\u03b2_root : Polynomial.IsRoot f \u03b2 := by\n      rw [Polynomial.IsRoot]\n      exact Polynomial.eval_eq_zero_of_mem_roots (Multiset.mem_toFinset.mp h\u03b2.1)\n    have hg : g \u2260 0 := by\n      intro hg'\n      rw [hg', mul_zero] at l2\n      exact tc_2 l2.1\n    rw [Multiset.mem_toFinset, Polynomial.mem_roots hg]\n    exact l3 \u03b2 h\u03b2_root h\u03b2.2\n  exact le_trans (Finset.card_mono h) l4", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 22, "column": 12, "endLine": 22, "endColumn": 80, "data": "unknown constant 'Polynomial.eval_eq_zero_of_mem_roots'"}, {"line": 28, "column": 23, "endLine": 28, "endColumn": 27, "data": "invalid projection, structure expected\n  h\u03b2\nhas type\n  \u03b2 \u2208 (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).val"}, {"line": 28, "column": 23, "endLine": 28, "endColumn": 27, "data": "invalid projection, structure expected\n  h\u03b2\nhas type\n  (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).val.Mem \u03b2"}, {"line": 28, "column": 23, "endLine": 28, "endColumn": 27, "data": "invalid projection, structure expected\n  h\u03b2\nhas type\n  Quot.liftOn (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).val (fun l => \u03b2 \u2208 l) \u22ef"}, {"line": 28, "column": 23, "endLine": 28, "endColumn": 27, "data": "invalid projection, structure expected\n  h\u03b2\nhas type\n  Quot.lift (fun l => \u03b2 \u2208 l) \u22ef (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).val"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The context and setup correctly establishes the mathematical framework with appropriate type constraints", "Assumption l3 perfectly captures the logical implication about roots of f being roots of g", "Assumption l4 correctly formalizes the upper bound on the number of roots of g", "The conclusion l5 accurately represents the desired bound on non-\u03b1 roots of f using appropriate filtering", "The additional structural information l2 provides necessary context about the polynomial factorization that supports the reasoning", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter Polynomial\n\nlemma neg_l5\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (\u03b1 : k)\n  (g : Polynomial k)\n  (l2 : f = (X - C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (l3 : \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2)\n  (l4 : g.roots.toFinset.card \u2264 n - 1) :\n  \u00ac(f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1 := by\n  simp only [not_le]\n  have h : f.roots.toFinset.filter (fun x => x \u2260 \u03b1) = g.roots.toFinset := by\n    ext \u03b2\n    simp only [Finset.mem_filter, Multiset.mem_toFinset, mem_roots tc_2, IsRoot]\n    rw [l2.1]\n    simp only [eval_mul, eval_sub, eval_X, eval_C, sub_eq_zero]\n    constructor\n    \u00b7 intro \u27e8h\u03b2, hne\u27e9\n      rw [IsRoot] at h\u03b2\n      exact l3 \u03b2 h\u03b2 hne\n    \u00b7 intro hg\n      refine \u27e8?_, ?_\u27e9\n      \u00b7 rw [l2.1, eval_mul, eval_sub, eval_X, eval_C, sub_eq_zero, mul_eq_zero]\n        exact Or.inr hg\n      \u00b7 intro h\n        rw [h] at hg\n        have := eval (C \u03b1) g\n        rw [hg] at this\n        simp at this\n  rw [h]\n  exact not_le_of_lt (Nat.lt_succ_self _) l4"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "It follows that~$f$ has at most~$n$ roots.", "statement": "We assume:\n\u2022 k is a field [tc_1];\n\u2022 f is a nonzero polynomial in k[x] of degree n [tc_2, def_1];\n\u2022 The proposition holds for n \u2264 1 [l1];\n\u2022 The proposition holds for degree n > 1, which we showed by considering two cases:\n  1. If f has no roots, it has 0 roots, and 0 \u2264 n.\n  2. If f has at least one root \u03b1, then there are at most n-1 other roots [l5].\nTherefore, we conclude:\n\u2022 f has at most n roots [ts_1].", "dependencies": ["tc_1", "tc_2", "def_1", "l1", "def_2", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (l1 : n \u2264 1 \u2192 (f.roots.toFinset.card \u2264 n))\n  (def_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.degree < n \u2192 h.roots.toFinset.card \u2264 h.degree)\n  (l2 : \u2200 (\u03b1 : k), f.IsRoot \u03b1 \u2192 \u2203 g : Polynomial k, f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (l3 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115)) \u2192 \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2)\n  (l4 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115)) \u2192 (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 g.roots.toFinset.card \u2264 n - 1)\n  (l5 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115)) \u2192 (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 (g.roots.toFinset.card \u2264 n - 1) \u2192 (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1) :\n  f.roots.toFinset.card \u2264 n := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = Polynomial.natDegree f)\n  (l1 : n \u2264 1 \u2192 (f.roots.toFinset.card \u2264 n))\n  (def_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 Polynomial.natDegree h < n \u2192 h.roots.toFinset.card \u2264 Polynomial.natDegree h)\n  (l2 : \u2200 (\u03b1 : k), f.IsRoot \u03b1 \u2192 \u2203 g : Polynomial k, f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 Polynomial.natDegree g = n - 1)\n  (l3 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 Polynomial.natDegree g = n - 1) \u2192 \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2)\n  (l4 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 Polynomial.natDegree g = n - 1) \u2192 (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 g.roots.toFinset.card \u2264 n - 1)\n  (l5 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 Polynomial.natDegree g = n - 1) \u2192 (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 (g.roots.toFinset.card \u2264 n - 1) \u2192 (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1) :\n  f.roots.toFinset.card \u2264 n := by\n  by_cases hn : n \u2264 1\n  \u00b7 exact l1 hn\n  \u00b7 push_neg at hn\n    cases' Classical.em (\u2203 \u03b1 : k, f.IsRoot \u03b1) with h\u03b1 h\u03b1\n    \u00b7 obtain \u27e8\u03b1, h\u03b1\u27e9 := h\u03b1\n      obtain \u27e8g, hfg, hg\u27e9 := l2 \u03b1 h\u03b1\n      have hg' : g \u2260 0 := by\n        intro hg''\n        rw [hg'', mul_zero] at hfg\n        exact tc_2 hfg\n      have hg_le : g.roots.toFinset.card \u2264 n - 1 := by\n        apply l4 \u03b1 g \u27e8hfg, hg\u27e9\n        intro \u03b2 h\u03b2 h\u03b2\u03b1\n        exact l3 \u03b1 g \u27e8hfg, hg\u27e9 \u03b2 h\u03b2 h\u03b2\u03b1\n      have hf_le : (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1 :=\n        l5 \u03b1 g \u27e8hfg, hg\u27e9 (fun \u03b2 h\u03b2 h\u03b2\u03b1 => l3 \u03b1 g \u27e8hfg, hg\u27e9 \u03b2 h\u03b2 h\u03b2\u03b1) hg_le\n      have h\u03b1_in : \u03b1 \u2208 f.roots.toFinset := by\n        simp [Polynomial.mem_roots tc_2, h\u03b1]\n      rw [\u2190 Finset.insert_erase h\u03b1_in, Finset.card_insert_of_not_mem (Finset.not_mem_erase \u03b1 _)]\n      exact Nat.succ_le_of_lt (Nat.lt_of_le_of_lt hf_le (Nat.sub_lt (Nat.succ_le_of_lt hn) (Nat.succ_pos 0)))\n    \u00b7 simp only [Polynomial.roots, dif_neg tc_2, Multiset.toFinset_zero, Finset.card_empty]\n      exact Nat.zero_le n", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 34, "column": 43, "endLine": 35, "endColumn": 44, "data": "unsolved goals\nk : Type u_1\ninst\u271d\u00b9 : Field k\ninst\u271d : DecidableEq k\nf : Polynomial k\ntc_2 : f \u2260 0\nn : \u2115\ndef_1 : n = f.natDegree\nl1 : n \u2264 1 \u2192 f.roots.toFinset.card \u2264 n\ndef_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.natDegree < n \u2192 h.roots.toFinset.card \u2264 h.natDegree\nl2 : \u2200 (\u03b1 : k), f.IsRoot \u03b1 \u2192 \u2203 g, f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.natDegree = n - 1\nl3 :\n  \u2200 (\u03b1 : k) (g : Polynomial k),\n    f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.natDegree = n - 1 \u2192 \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2\nl4 :\n  \u2200 (\u03b1 : k) (g : Polynomial k),\n    f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.natDegree = n - 1 \u2192\n      (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 g.roots.toFinset.card \u2264 n - 1\nl5 :\n  \u2200 (\u03b1 : k) (g : Polynomial k),\n    f = (Polynomial.X - Polynomial.C \u03b1) * g \u2227 g.natDegree = n - 1 \u2192\n      (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192\n        g.roots.toFinset.card \u2264 n - 1 \u2192 (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).card \u2264 n - 1\nhn : 1 < n\n\u03b1 : k\nh\u03b1 : f.IsRoot \u03b1\ng : Polynomial k\nhfg : f = (Polynomial.X - Polynomial.C \u03b1) * g\nhg : g.natDegree = n - 1\nhg' : g \u2260 0\nhg_le : g.roots.toFinset.card \u2264 n - 1\nhf_le : (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).card \u2264 n - 1\n\u22a2 Polynomial.eval \u03b1 f = 0"}, {"line": 37, "column": 87, "endLine": 37, "endColumn": 89, "data": "application type mismatch\n  succ_le_of_lt hn\nargument\n  hn\nhas type\n  1 < n : Prop\nbut is expected to have type\n  0 < n : Prop"}, {"line": 37, "column": 50, "endLine": 37, "endColumn": 55, "data": "application type mismatch\n  Nat.lt_of_le_of_lt hf_le\nargument\n  hf_le\nhas type\n  (Finset.filter (fun x => x \u2260 \u03b1) f.roots.toFinset).card \u2264 n - 1 : Prop\nbut is expected to have type\n  (f.roots.toFinset.erase \u03b1).card \u2264 n - succ 0 : Prop"}, {"line": 39, "column": 6, "endLine": 39, "endColumn": 25, "data": "type mismatch\n  Nat.zero_le n\nhas type\n  0 \u2264 n : Prop\nbut is expected to have type\n  (Classical.choose \u22ef).toFinset.card \u2264 n : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The basic setup correctly formalizes k as a field and f as a nonzero polynomial of degree n", "The base case for n \u2264 1 is correctly captured", "The inductive hypothesis is properly formalized for polynomials of smaller degree", "Root factorization is correctly expressed using polynomial division", "The relationship between roots of f and the quotient polynomial g is properly captured", "The application of the inductive hypothesis to the quotient polynomial is correct", "The final step correctly relates the bound on 'other roots' to the total count", "The conclusion correctly states the desired bound on the total number of roots", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter Polynomial\n\nlemma neg_ts_1\n  (k : Type*) [Field k] [DecidableEq k]\n  (f : Polynomial k)\n  (tc_2 : f \u2260 0)\n  (n : \u2115)\n  (def_1 : n = f.degree)\n  (l1 : n \u2264 1 \u2192 (f.roots.toFinset.card \u2264 n))\n  (def_2_hyp : \u2200 (h : Polynomial k), h \u2260 0 \u2192 h.degree < n \u2192 h.roots.toFinset.card \u2264 h.degree)\n  (l2 : \u2200 (\u03b1 : k), f.IsRoot \u03b1 \u2192 \u2203 g : Polynomial k, f = (X - C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115))\n  (l3 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (X - C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115)) \u2192 \u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2)\n  (l4 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (X - C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115)) \u2192 (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 g.roots.toFinset.card \u2264 n - 1)\n  (l5 : \u2200 (\u03b1 : k) (g : Polynomial k), (f = (X - C \u03b1) * g \u2227 g.degree = (n - 1 : \u2115)) \u2192 (\u2200 (\u03b2 : k), f.IsRoot \u03b2 \u2192 \u03b2 \u2260 \u03b1 \u2192 g.IsRoot \u03b2) \u2192 (g.roots.toFinset.card \u2264 n - 1) \u2192 (f.roots.toFinset.filter (fun x => x \u2260 \u03b1)).card \u2264 n - 1) :\n  \u00ac f.roots.toFinset.card \u2264 n := by\n  let k := \u2124\n  let f := X^2 - X\n  have tc_2 : f \u2260 0 := by simp\n  have def_1 : 2 = f.degree := by simp [f]; decide\n  have roots_card : f.roots.toFinset.card = 2 := by\n    simp [f, roots, rootSet]\n    have : splits (RingHom.id \u2124) (X^2 - X) := by\n      simp [splits_iff_exists_multiset]\n      use [0, 1]\n      simp\n    simp [this]\n    decide\n  simp [roots_card]\n  linarith"}, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#FFA500", "highlight": {"background": "#a3c2a8", "border": "#FFA500"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    