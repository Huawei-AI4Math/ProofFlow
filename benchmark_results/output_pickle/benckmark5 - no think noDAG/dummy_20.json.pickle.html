
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: (a) Union of open sets is open. (b) Intersection of closed sets is closed.

Proof: (a) Let G be a collection of open sets, S = ∪G. If x₀ ∈ S, then x₀ ∈ some open G₀, so ∃ ε-nbhd in G₀ ⊆ S ⇒ S open. (b) If F is a collection of closed sets, T = ∩F ⇒ Tᶜ = ∪Fᶜ. Each Fᶜ open ⇒ Tᶜ open ⇒ T closed.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let G be a collection of open sets", "statement": "Premise:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [MetricSpace X]\nvariable (G : Set (Set X))\n(tc_1 : \u2200 s \u2208 G, IsOpen s)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the metric space structure. While the natural language explicitly mentions (X, d), Lean's [MetricSpace X] typeclass provides the same mathematical structure with the metric implicitly available.", "The Lean formalization perfectly captures that G is a collection of open sets. The combination of (G : Set (Set X)) and (tc_1 : \u2200 s \u2208 G, IsOpen s) correctly formalizes the condition that G is a collection of open sets."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_1": {"id": "def_1", "natural_language": "S = \u222aG", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1].\nDefinition:\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [MetricSpace X] (G : Set (Set X))\n(tc_1 : \u2200 s \u2208 G, IsOpen s)\n(S : Set X) (def_1 : S = \u22c3\u2080 G)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures that G is a collection of open sets in a metric space. The metric space is established with [MetricSpace X], G is defined as Set (Set X) meaning a collection of sets, and tc_1 ensures all sets in G are open.", "The Lean notation \u22c3\u2080 G is the standard way to express the union of a collection of sets, which is mathematically equivalent to \u22c3_{G\u2080\u2208G} G\u2080. The definition perfectly matches the mathematical statement."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "definition"}, "l1": {"id": "l1", "natural_language": "If x\u2080 \u2208 S, then x\u2080 \u2208 some open G\u2080", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1].\nTherefore, we conclude:\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1].", "dependencies": ["tc_1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G) :\n  \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G) :\n  \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 := by\n  intro x\u2080 hx\u2080\n  rw [def_1] at hx\u2080\n  exact hx\u2080", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The metric space setup and collection type are correctly formalized", "The open sets condition is properly captured with the universal quantification", "The union notation \u22c3\u2080 G is the standard Lean equivalent of \u22c3_{G\u2080\u2208G} G\u2080", "The conclusion statement perfectly matches the logical structure in natural language", "The overall mathematical logic and reasoning are correctly preserved in the formalization"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "so \u2203 \u03b5-nbhd in G\u2080 \u2286 S", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1].\nTherefore, we conclude:\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2].", "dependencies": ["tc_1", "def_1", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080) :\n  \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080) :\n  \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S := by\n  intro x\u2080 hx\u2080\n  obtain \u27e8G\u2080, hG\u2080, hx\u2080G\u2080\u27e9 := l1 x\u2080 hx\u2080\n  have hG\u2080_open := tc_1 G\u2080 hG\u2080\n  rcases Metric.isOpen_iff.1 hG\u2080_open x\u2080 hx\u2080G\u2080 with \u27e8\u03b5, h\u03b5, hball\u27e9\n  use \u03b5, h\u03b5\n  rw [def_1]\n  exact Set.Subset.trans hball (Set.subset_sUnion_of_mem hG\u2080)", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The type setup correctly establishes X as a metric space and G as a collection of subsets of X, matching the natural language description.", "The openness condition tc_1 perfectly captures that G is a collection of open sets using Lean's IsOpen predicate.", "The union definition def_1 correctly uses Lean's \u22c3\u2080 notation to express the union of all sets in collection G.", "The membership condition l1 is a direct logical translation of the natural language statement about points in S belonging to some set in G.", "The conclusion l2 correctly formalizes the \u03b5-neighborhood concept as a metric ball with positive radius, which is the standard mathematical interpretation of \u03b5-neighborhoods in metric spaces. The additional constraint \u03b5 > 0 is mathematically necessary and consistent."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "S open", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2].\nTherefore, we conclude:\n\u2022 S is an open set [ts_1].", "dependencies": ["tc_1", "def_1", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S) :\n  IsOpen S := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S) :\n  IsOpen S := by\n  rw [Metric.isOpen_iff]\n  intro x\u2080 hx\u2080\n  rcases l2 x\u2080 hx\u2080 with \u27e8\u03b5, h\u03b5, hball\u27e9\n  exact \u27e8\u03b5, h\u03b5, hball\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The type setup correctly captures a metric space X with G as a collection of sets. The MetricSpace typeclass provides the metric structure equivalent to (X,d).", "The condition tc_1 perfectly formalizes that all sets in G are open using the standard IsOpen predicate.", "The definition def_1 correctly uses \u22c3\u2080 G (union of sets in G) which is the standard Lean notation for the union described in natural language.", "Condition l1 is a direct and accurate translation of the membership requirement using standard quantifier notation.", "Condition l2 correctly formalizes the \u03b5-neighborhood concept using Metric.ball with the additional constraint \u03b5 > 0, which is mathematically necessary and consistent. The natural language '\u03b5-neighborhood' implicitly assumes \u03b5 > 0.", "The conclusion ts_1 directly corresponds to the natural language statement using the standard IsOpen predicate."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}, "tc_2": {"id": "tc_2", "natural_language": "If F is a collection of closed sets", "statement": "Premise:\n\u2022 F is a collection of closed sets in a metric space (X, d) [tc_2].", "dependencies": ["tc_1", "def_1", "l1", "l2", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [MetricSpace X] (F : Set (Set X))\n(tc_2 : \u2200 s \u2208 F, IsClosed s)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The Lean formalization correctly captures the metric space structure. While the natural language explicitly mentions 'd' as the metric, Lean's MetricSpace typeclass implicitly provides this, which is a standard and appropriate formalization.", "The Lean formalization perfectly captures that F is a collection of closed sets. It declares F as Set (Set X) (a collection of sets) and tc_2 ensures all elements in F are closed sets via \u2200 s \u2208 F, IsClosed s."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "type": "condition"}, "def_2": {"id": "def_2", "natural_language": "T = \u2229F", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2];\n\u2022 S is an open set [ts_1];\n\u2022 F is a collection of closed sets in a metric space (X, d) [tc_2].\nDefinition:\n\u2022 T is the intersection of the sets in F, T = \u22c2_{F\u2080\u2208F} F\u2080 [def_2].", "dependencies": ["tc_1", "def_1", "l1", "l2", "ts_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable {X : Type*} [MetricSpace X] (F : Set (Set X))\n(def_2 : \u2200 T, T = \u22c2\u2080 F)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The Lean formalization does not include G as a collection of open sets. Only F is declared as a Set (Set X), but there's no mention of G at all.", "While F is declared as Set (Set X) in Lean, there's no specification that the sets in F are closed sets, whereas the natural language explicitly states F is a collection of closed sets.", "The Lean formalization completely missing the definition S = \u22c3_{G\u2080\u2208G} G\u2080. There's no S variable or union operation defined.", "The Lean formalization is missing this conclusion about points in S and their relationship to sets in G. No such statement exists in the Lean code.", "The Lean formalization is missing this conclusion about \u03b5-neighborhoods. No such statement about neighborhoods or subset relationships exists.", "The Lean formalization is missing the conclusion that S is an open set. S is not even defined in the Lean code.", "While the Lean code has def_2 : \u2200 T, T = \u22c2\u2080 F which represents intersection, it's quantified over all T rather than defining a specific T as the intersection of sets in F. The natural language defines a specific T, not a universal quantification."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization does not include G as a collection of open sets. Only F is declared as a Set (Set X), but there's no mention of G at all.\", \"While F is declared as Set (Set X) in Lean, there's no specification that the sets in F are closed sets, whereas the natural language explicitly states F is a collection of closed sets.\", \"The Lean formalization completely missing the definition S = \u22c3_{G\u2080\u2208G} G\u2080. There's no S variable or union operation defined.\", 'The Lean formalization is missing this conclusion about points in S and their relationship to sets in G. No such statement exists in the Lean code.', 'The Lean formalization is missing this conclusion about \u03b5-neighborhoods. No such statement about neighborhoods or subset relationships exists.', 'The Lean formalization is missing the conclusion that S is an open set. S is not even defined in the Lean code.', \"While the Lean code has def_2 : \u2200 T, T = \u22c2\u2080 F which represents intersection, it's quantified over all T rather than defining a specific T as the intersection of sets in F. The natural language defines a specific T, not a universal quantification.\"]"}, "type": "definition"}, "l3": {"id": "l3", "natural_language": "T\u1d9c = \u222aF\u1d9c", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2];\n\u2022 S is an open set [ts_1];\n\u2022 F is a collection of closed sets in a metric space (X, d) [tc_2];\n\u2022 T is the intersection of the sets in F, T = \u22c2_{F\u2080\u2208F} F\u2080 [def_2].\nTherefore, we conclude:\n\u2022 The complement of T is the union of the complements of the sets in F: T\u1d9c = \u22c3_{F\u2080\u2208F} F\u2080\u1d9c [l3].", "dependencies": ["tc_1", "def_1", "l1", "l2", "ts_1", "tc_2", "def_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F) :\n  T\u1d9c = \u22c3\u2080 (compl '' F) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F) :\n  T\u1d9c = \u22c3\u2080 (compl '' F) := by\n  ext x\n  simp only [Set.mem_compl_iff, Set.mem_sUnion, Set.mem_iInter, Set.mem_image]\n  constructor\n  \u00b7 intro h\n    simp [def_2] at h\n    obtain \u27e8F\u2080, hF\u2080, hx\u27e9 := h\n    exact \u27e8F\u2080\u1d9c, \u27e8F\u2080, hF\u2080, rfl\u27e9, hx\u27e9\n  \u00b7 intro h\n    simp [def_2]\n    obtain \u27e8_, \u27e8F\u2080, hF\u2080, rfl\u27e9, hx\u27e9 := h\n    exact \u27e8F\u2080, hF\u2080, hx\u27e9", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 4}, "score": {"semantic_score": 1.0, "semantic_feedback": ["Variable declarations correctly establish the metric space context and collection types", "Union definition using \u22c3\u2080 G accurately captures the mathematical notation", "Open set condition properly formalized with universal quantification", "Membership property is directly and accurately translated", "\u03b5-neighborhood property correctly uses metric balls with necessary positivity constraint", "Open set property is straightforwardly and correctly formalized", "Closed set collection properly formalized with universal quantification", "Intersection definition using \u22c2\u2080 F accurately captures the mathematical notation", "Conclusion correctly uses complement image notation to represent the union of complements"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "Each F\u1d9c open", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2];\n\u2022 S is an open set [ts_1];\n\u2022 F is a collection of closed sets in a metric space (X, d) [tc_2];\n\u2022 T is the intersection of the sets in F, T = \u22c2_{F\u2080\u2208F} F\u2080 [def_2];\n\u2022 The complement of T is the union of the complements of the sets in F: T\u1d9c = \u22c3_{F\u2080\u2208F} F\u2080\u1d9c [l3].\nTherefore, we conclude:\n\u2022 For each set F\u2080 in the collection F, its complement F\u2080\u1d9c is an open set [l4].", "dependencies": ["tc_1", "def_1", "l1", "l2", "ts_1", "tc_2", "def_2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F)\n  (l3 : T\u1d9c = \u22c3\u2080 (compl '' F)) :\n  \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F)\n  (l3 : T\u1d9c = \u22c3\u2080 (compl '' F)) :\n  \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c) := by\n  intro F\u2080 hF\u2080\n  exact (tc_2 F\u2080 hF\u2080).isOpen_compl", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["tc_1: \u2200 s \u2208 G, IsOpen s correctly captures that G is a collection of open sets in the metric space", "def_1: S = \u22c3\u2080 G correctly formalizes S as the union of sets in G using Lean's union notation", "l1: \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080 perfectly captures that for any point in S, there exists a set in G containing that point", "l2: \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S correctly formalizes the \u03b5-neighborhood condition, with the additional \u03b5 > 0 constraint being mathematically necessary", "ts_1: IsOpen S directly captures that S is an open set", "tc_2: \u2200 s \u2208 F, IsClosed s correctly captures that F is a collection of closed sets", "def_2: T = \u22c2\u2080 F correctly formalizes T as the intersection of sets in F using Lean's intersection notation", "l3: T\u1d9c = \u22c3\u2080 (compl '' F) correctly captures that the complement of T equals the union of complements of sets in F, using Lean's image notation for the complement operation", "Goal: \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c) perfectly captures the conclusion that each set's complement in collection F is open"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "T\u1d9c open", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2];\n\u2022 The union of a collection of open sets is open [ts_1];\n\u2022 F is a collection of closed sets in a metric space (X, d) [tc_2];\n\u2022 T is the intersection of the sets in F, T = \u22c2_{F\u2080\u2208F} F\u2080 [def_2];\n\u2022 The complement of T is the union of the complements of the sets in F: T\u1d9c = \u22c3_{F\u2080\u2208F} F\u2080\u1d9c [l3];\n\u2022 For each set F\u2080 in the collection F, its complement F\u2080\u1d9c is an open set [l4].\nTherefore, we conclude:\n\u2022 T\u1d9c is an open set [l5].", "dependencies": ["tc_1", "def_1", "l1", "l2", "ts_1", "tc_2", "def_2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F)\n  (l3 : T\u1d9c = \u22c3\u2080 (compl '' F))\n  (l4 : \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c)) :\n  IsOpen (T\u1d9c) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F)\n  (l3 : T\u1d9c = \u22c3\u2080 (compl '' F))\n  (l4 : \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c)) :\n  IsOpen (T\u1d9c) := by\n  rw [l3]\n  apply isOpen_sUnion\n  intro t ht\n  rcases ht with \u27e8F\u2080, hF\u2080, rfl\u27e9\n  exact l4 F\u2080 hF\u2080", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The assumption about G being a collection of open sets is correctly formalized as a universal quantification over membership.", "The definition of S as union of sets in G uses the appropriate Lean notation \u22c3\u2080 for union of a collection.", "The property about points in S belonging to some set in G is correctly captured with existential quantification.", "The \u03b5-neighborhood property is appropriately formalized using metric balls with positive real \u03b5, which is more precise than the natural language.", "The general theorem about unions of open sets being open is applied specifically to S, which is sufficient for the context.", "The assumption about F being a collection of closed sets is correctly formalized.", "The definition of T as intersection of sets in F uses the appropriate Lean notation \u22c2\u2080.", "The complement relationship is correctly expressed using image notation for the collection of complements.", "The openness of complements of closed sets is properly formalized.", "The conclusion that T\u1d9c is open is correctly stated as the goal to be proven."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_2": {"id": "ts_2", "natural_language": "T closed", "statement": "We assume:\n\u2022 G is a collection of open sets in a metric space (X, d) [tc_1];\n\u2022 S is the union of the sets in G, S = \u22c3_{G\u2080\u2208G} G\u2080 [def_1];\n\u2022 For any point x\u2080 \u2208 S, there exists a set G\u2080 in the collection G such that x\u2080 \u2208 G\u2080 [l1];\n\u2022 For any point x\u2080 \u2208 S, there exists an \u03b5-neighborhood N of x\u2080 such that N \u2286 S [l2];\n\u2022 The union of a collection of open sets is open [ts_1];\n\u2022 F is a collection of closed sets in a metric space (X, d) [tc_2];\n\u2022 T is the intersection of the sets in F, T = \u22c2_{F\u2080\u2208F} F\u2080 [def_2];\n\u2022 The complement of T is the union of the complements of the sets in F: T\u1d9c = \u22c3_{F\u2080\u2208F} F\u2080\u1d9c [l3];\n\u2022 For each set F\u2080 in the collection F, its complement F\u2080\u1d9c is an open set [l4];\n\u2022 T\u1d9c is an open set [l5].\nTherefore, we conclude:\n\u2022 T is a closed set [ts_2].", "dependencies": ["tc_1", "def_1", "l1", "l2", "ts_1", "tc_2", "def_2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F)\n  (l3 : T\u1d9c = \u22c3\u2080 (compl '' F))\n  (l4 : \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c))\n  (l5 : IsOpen (T\u1d9c)) :\n  IsClosed T := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  {X : Type*} [MetricSpace X] (G : Set (Set X)) (S : Set X) (F : Set (Set X)) (T : Set X)\n  (tc_1 : \u2200 s \u2208 G, IsOpen s)\n  (def_1 : S = \u22c3\u2080 G)\n  (l1 : \u2200 x\u2080 \u2208 S, \u2203 G\u2080 \u2208 G, x\u2080 \u2208 G\u2080)\n  (l2 : \u2200 x\u2080 \u2208 S, \u2203 \u03b5 : \u211d, \u03b5 > 0 \u2227 Metric.ball x\u2080 \u03b5 \u2286 S)\n  (ts_1 : IsOpen S)\n  (tc_2 : \u2200 s \u2208 F, IsClosed s)\n  (def_2 : T = \u22c2\u2080 F)\n  (l3 : T\u1d9c = \u22c3\u2080 (compl '' F))\n  (l4 : \u2200 F\u2080 \u2208 F, IsOpen (F\u2080\u1d9c))\n  (l5 : IsOpen (T\u1d9c)) :\n  IsClosed T := by\n  rw [\u2190 isOpen_compl_iff]\n  exact l5", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["tc_1 correctly formalizes G as a collection of open sets in metric space X", "def_1 uses \u22c3\u2080 G which is the standard Lean notation for union of a collection of sets", "l1 perfectly captures the existential statement about points in S belonging to some set in G", "l2 correctly uses Metric.ball for \u03b5-neighborhood and includes the necessary \u03b5 > 0 constraint", "ts_1 correctly states that S is open, representing the theorem about unions of open sets", "tc_2 correctly formalizes F as a collection of closed sets", "def_2 uses \u22c2\u2080 F which correctly represents intersection of all sets in F", "l3 uses compl '' F to represent the collection of complements, then \u22c3\u2080 for their union - this correctly captures the mathematical relationship", "l4 perfectly formalizes the statement about complements of closed sets being open", "l5 correctly states that the complement of T is open", "The conclusion correctly states that T is closed"]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_2", "label": "def_2", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    