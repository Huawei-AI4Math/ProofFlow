
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: Let $(X, \mathcal{A})$ be a measurable space and let $\mu$ be a measure on $(X, \mathcal{A})$. For any two sets $A, B \in \mathcal{A}$, it holds that $\mu(A) + \mu(B) = \mu(A \cup B) + \mu(A \cap B)$.

Proof: We start by decomposing the set $A$ into a disjoint union $A = (A \cap B) \cup (A \setminus B)$. Since $\mu$ is a measure, its additivity on disjoint sets implies $\mu(A) = \mu(A \cap B) + \mu(A \setminus B)$.
Similarly, for set $B$, the disjoint union $B = (A \cap B) \cup (B \setminus A)$ gives $\mu(B) = \mu(A \cap B) + \mu(B \setminus A)$.
The union $A \cup B$ can also be expressed as a disjoint union $A \cup B = (A \setminus B) \cup (B \setminus A) \cup (A \cap B)$, so by additivity $\mu(A \cup B) = \mu(A \setminus B) + \mu(B \setminus A) + \mu(A \cap B)$.
Using these results, we can write $\mu(A) + \mu(B) = (\mu(A \cap B) + \mu(A \setminus B)) + (\mu(A \cap B) + \mu(B \setminus A))$. Rearranging this sum and using the expression for $\mu(A \cup B)$ yields $\mu(A) + \mu(B) = (\mu(A \setminus B) + \mu(B \setminus A) + \mu(A \cap B)) + \mu(A \cap B) = \mu(A \cup B) + \mu(A \cap B)$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "Let $(X, \\mathcal{A})$ be a measurable space", "statement": "Premise:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (X : Type*) (A : MeasurableSpace X)\n(tc_1 : MeasurableSpace X)", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures that (X, A) is a measurable space with X as a type and A as the measurable space structure. However, there's a redundant declaration 'tc_1 : MeasurableSpace X' alongside 'A : MeasurableSpace X', which creates two measurable space structures on the same type X. While this doesn't contradict the mathematical meaning, it's structurally inconsistent with the natural language which refers to a single measurable space (X, A)."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures that (X, A) is a measurable space with X as a type and A as the measurable space structure. However, there's a redundant declaration 'tc_1 : MeasurableSpace X' alongside 'A : MeasurableSpace X', which creates two measurable space structures on the same type X. While this doesn't contradict the mathematical meaning, it's structurally inconsistent with the natural language which refers to a single measurable space (X, A).\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "let $\\mu$ be a measure on $(X, \\mathcal{A})$", "statement": "Premise:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (X : Type*) (A : MeasurableSpace X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)", "lean_pass": true, "error_msg": [], "tries": 3}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The natural language refers to a measurable space $(X, \\mathcal{A})$, but the Lean code declares both `A : MeasurableSpace X` and `tc_1 : MeasurableSpace X`, creating two different measurable space structures on the same type X. This is redundant and doesn't match the single measurable space mentioned in the natural language.", "The natural language states that $\\mu$ is a measure on $(X, \\mathcal{A})$, but the Lean code declares `tc_2 : MeasureTheory.Measure X` without explicitly connecting it to the measurable space structure $\\mathcal{A}$. Additionally, the variable name `tc_2` doesn't correspond to `\u03bc` from the natural language, and there's no clear connection between the measure and the specific measurable space structure."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The natural language refers to a measurable space $(X, \\\\mathcal{A})$, but the Lean code declares both `A : MeasurableSpace X` and `tc_1 : MeasurableSpace X`, creating two different measurable space structures on the same type X. This is redundant and doesn't match the single measurable space mentioned in the natural language.\", \"The natural language states that $\\\\mu$ is a measure on $(X, \\\\mathcal{A})$, but the Lean code declares `tc_2 : MeasureTheory.Measure X` without explicitly connecting it to the measurable space structure $\\\\mathcal{A}$. Additionally, the variable name `tc_2` doesn't correspond to `\u03bc` from the natural language, and there's no clear connection between the measure and the specific measurable space structure.\"]"}, "type": "condition"}, "tc_3": {"id": "tc_3", "natural_language": "For any two sets $A, B \\in \\mathcal{A}$", "statement": "Premise:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (X : Type*) (A : MeasurableSpace X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (A_set B_set : Set X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization has redundant declarations with both `(A : MeasurableSpace X)` and `(tc_1 : MeasurableSpace X)` representing the measurable space structure. The variable name `A` conflicts with the set name later. However, the mathematical meaning of having a measurable space $(X, \\mathcal{A})$ is correctly captured.", "The Lean formalization correctly represents a measure on X with `MeasureTheory.Measure X`, but doesn't explicitly connect it to the measurable space structure. The mathematical meaning is preserved since a measure in Lean's type system implicitly requires the measurable space structure.", "The Lean formalization perfectly captures that A and B are measurable sets through `MeasurableSet A_set \u2227 MeasurableSet B_set`, which is equivalent to saying they are sets in $\\mathcal{A}$. The variable names `A_set` and `B_set` are different but this is acceptable."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: ['The Lean formalization has redundant declarations with both `(A : MeasurableSpace X)` and `(tc_1 : MeasurableSpace X)` representing the measurable space structure. The variable name `A` conflicts with the set name later. However, the mathematical meaning of having a measurable space $(X, \\\\mathcal{A})$ is correctly captured.', \"The Lean formalization correctly represents a measure on X with `MeasureTheory.Measure X`, but doesn't explicitly connect it to the measurable space structure. The mathematical meaning is preserved since a measure in Lean's type system implicitly requires the measurable space structure.\", 'The Lean formalization perfectly captures that A and B are measurable sets through `MeasurableSet A_set \u2227 MeasurableSet B_set`, which is equivalent to saying they are sets in $\\\\mathcal{A}$. The variable names `A_set` and `B_set` are different but this is acceptable.']"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "We start by decomposing the set $A$ into a disjoint union $A = (A \\cap B) \\cup (A \\setminus B)$.", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3].\nTherefore, we conclude:\n\u2022 The set $A$ is the disjoint union of $(A \\cap B)$ and $(A \\setminus B)$, which means $A = (A \\cap B) \\cup (A \\setminus B)$ and $(A \\cap B) \\cap (A \\setminus B) = \\emptyset$ [l1].", "dependencies": ["tc_1", "tc_2", "tc_3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set) :\n  A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set) :\n  A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205 := by\n  constructor\n  \u00b7 ext x\n    constructor\n    \u00b7 intro hx\n      by_cases h : x \u2208 B_set\n      \u00b7 exact Or.inl \u27e8hx, h\u27e9\n      \u00b7 exact Or.inr \u27e8hx, h\u27e9\n    \u00b7 intro hx\n      cases hx with\n      | inl h => exact h.1\n      | inr h => exact h.1\n  \u00b7 ext x\n    simp only [Set.mem_inter_iff, Set.mem_diff, Set.mem_empty_iff_false, iff_false, not_and]\n    intro \u27e8\u27e8_, hB\u27e9, _, hB'\u27e9\n    exact hB' hB", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 24, "column": 11, "endLine": 24, "endColumn": 18, "data": "invalid constructor \u27e8...\u27e9, expected type must be an inductive type \n  A_set x"}, {"line": 25, "column": 4, "endLine": 25, "endColumn": 16, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The type declarations and measurable space setup correctly capture the mathematical context described in natural language. Variable names differ (A_set vs A) but this is a minor notational difference that doesn't affect semantic meaning.", "The main mathematical statement is perfectly translated with correct set operations (intersection, union, set difference) and logical structure (conjunction of two equalities).", "The measure variable tc_2 is declared but unused in the conclusion, which is acceptable since it's part of the problem setup but not needed for this particular set-theoretic result.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l1\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set) :\n  \u00ac(A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205) := by\n  intro h\n  have \u27e8h1, h2\u27e9 := h\n  rw [Set.inter_diff_self] at h2\n  exact h2"}, "type": "lemma"}, "l2": {"id": "l2", "natural_language": "Since $\\mu$ is a measure, its additivity on disjoint sets implies $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$.", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 The set $A$ is the disjoint union of $(A \\cap B)$ and $(A \\setminus B)$ [l1].\nTherefore, we conclude:\n\u2022 $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$ [l2].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205) :\n  \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205) :\n  \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set) := by\n  rw [l1.1]\n  have h_disj : Disjoint (A_set \u2229 B_set) (A_set \\ B_set) := by\n    rw [Set.disjoint_iff_inter_eq_empty]\n    exact l1.2\n  have h_meas_inter : MeasurableSet (A_set \u2229 B_set) := MeasurableSet.inter tc_3.left tc_3.right\n  have h_meas_diff : MeasurableSet (A_set \\ B_set) := MeasurableSet.diff tc_3.left tc_3.right\n  rw [MeasureTheory.measure_union h_disj h_meas_inter h_meas_diff]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 18, "column": 41, "endLine": 18, "endColumn": 53, "data": "application type mismatch\n  MeasureTheory.measure_union h_disj h_meas_inter\nargument\n  h_meas_inter\nhas type\n  MeasurableSet (A_set \u2229 B_set) : Prop\nbut is expected to have type\n  MeasurableSet (A_set \\ B_set) : Prop"}, {"line": 18, "column": 6, "endLine": 18, "endColumn": 65, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.2560\nX : Type u_1\ninst\u271d : MeasurableSpace X\n\u03bc : MeasureTheory.Measure X\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl1 : A_set = A_set \u2229 B_set \u222a A_set \\ B_set \u2227 A_set \u2229 B_set \u2229 (A_set \\ B_set) = \u2205\nh_disj : Disjoint (A_set \u2229 B_set) (A_set \\ B_set)\nh_meas_inter : MeasurableSet (A_set \u2229 B_set)\nh_meas_diff : MeasurableSet (A_set \\ B_set)\n\u22a2 \u03bc (A_set \u2229 B_set \u222a A_set \\ B_set) =\n    \u03bc ((A_set \u2229 B_set \u222a A_set \\ B_set) \u2229 B_set) + \u03bc ((A_set \u2229 B_set \u222a A_set \\ B_set) \\ B_set)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The measurable space declaration is correctly formalized, though with some redundant explicit parameters that don't affect semantic correctness.", "The measure declaration properly captures the mathematical meaning despite parameter redundancy.", "The measurable sets condition correctly translates 'sets in \u03c3-algebra A' to MeasurableSet predicates.", "The disjoint union condition is correctly formalized with both union equality and disjointness, even though the union part is mathematically redundant.", "The conclusion perfectly matches the natural language statement about measure additivity.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l2\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A B : Set X)\n  (hA : MeasurableSet A) (hB : MeasurableSet B)\n  (h_disj : Disjoint (A \u2229 B) (A \\ B)) :\n  \u2203 \u03bc, \u03bc A \u2260 \u03bc (A \u2229 B) + \u03bc (A \\ B) := by\n  sorry"}, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "Similarly, for set $B$, the disjoint union $B = (A \\cap B) \\cup (B \\setminus A)$", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$ [l2].\nTherefore, we conclude:\n\u2022 The set $B$ is the disjoint union of $(A \\cap B)$ and $(B \\setminus A)$, which means $B = (A \\cap B) \\cup (B \\setminus A)$ and $(A \\cap B) \\cap (B \\setminus A) = \\emptyset$ [l3].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : MeasureTheory.Measure X) :\n  B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205 := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l2 : tc_2 A_set = tc_2 (A_set \u2229 B_set) + tc_2 (A_set \\ B_set)) :\n  B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205 := by\n  constructor\n  \u00b7 rw [\u2190 Set.union_diff_distrib, Set.union_comm, Set.inter_comm]\n  \u00b7 rw [Set.inter_comm, Set.inter_diff_assoc, Set.inter_compl_self, Set.inter_empty]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 13, "column": 8, "endLine": 13, "endColumn": 32, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?m.1396 \\ ?m.1398 \u222a ?m.1397 \\ ?m.1398\ncase left\nX : Type u_1\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl2 : tc_2 A_set = tc_2 (A_set \u2229 B_set) + tc_2 (A_set \\ B_set)\n\u22a2 B_set = A_set \u2229 B_set \u222a B_set \\ A_set"}, {"line": 14, "column": 24, "endLine": 14, "endColumn": 44, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  (?a \u2229 ?b) \\ ?c\ncase right\nX : Type u_1\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl2 : tc_2 A_set = tc_2 (A_set \u2229 B_set) + tc_2 (A_set \\ B_set)\n\u22a2 B_set \\ A_set \u2229 (A_set \u2229 B_set) = \u2205"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization has a major inconsistency because it completely misses the key assumption l2, which should be the measure equation \u03bc(A) = \u03bc(A \u2229 B) + \u03bc(A \\ B). Instead, l2 is incorrectly declared as another measure type. Additionally, the formalization introduces an extra assumption l1 about set A that is not mentioned in the natural language. While the conclusion about B's disjoint union is correctly formalized, the missing measure equation creates a fundamental logical gap between the premises and conclusion.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: [\"The Lean formalization has a major inconsistency because it completely misses the key assumption l2, which should be the measure equation \u03bc(A) = \u03bc(A \u2229 B) + \u03bc(A \\\\ B). Instead, l2 is incorrectly declared as another measure type. Additionally, the formalization introduces an extra assumption l1 about set A that is not mentioned in the natural language. While the conclusion about B's disjoint union is correctly formalized, the missing measure equation creates a fundamental logical gap between the premises and conclusion.\"]"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "gives $\\mu(B) = \\mu(A \\cap B) + \\mu(B \\setminus A)$.", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$ [l2];\n\u2022 The set $B$ is the disjoint union of $(A \\cap B)$ and $(B \\setminus A)$ [l3].\nTherefore, we conclude:\n\u2022 $\\mu(B) = \\mu(A \\cap B) + \\mu(B \\setminus A)$ [l4].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205) :\n  \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205) :\n  \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set) := by\n  have h_meas : MeasurableSet (A_set \u2229 B_set) \u2227 MeasurableSet (B_set \\ A_set) := by\n    exact \u27e8MeasurableSet.inter tc_3.left tc_3.right, MeasurableSet.diff tc_3.right tc_3.left\u27e9\n  rw [l3.1, MeasureTheory.measure_union]\n  \u00b7 rfl\n  \u00b7 exact Set.disjoint_iff_inter_eq_empty.mpr l3.2\n  \u00b7 exact h_meas.left\n  \u00b7 exact h_meas.right", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 17, "column": 4, "endLine": 17, "endColumn": 7, "data": "tactic 'rfl' failed, the left-hand side\n  \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set)\nis not definitionally equal to the right-hand side\n  \u03bc (A_set \u2229 (A_set \u2229 B_set \u222a B_set \\ A_set)) + \u03bc ((A_set \u2229 B_set \u222a B_set \\ A_set) \\ A_set)\nX : Type u_1\ninst\u271d : MeasurableSpace X\n\u03bc : MeasureTheory.Measure X\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl1 : A_set = A_set \u2229 B_set \u222a A_set \\ B_set \u2227 A_set \u2229 B_set \u2229 (A_set \\ B_set) = \u2205\nl2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)\nl3 : B_set = A_set \u2229 B_set \u222a B_set \\ A_set \u2227 A_set \u2229 B_set \u2229 (B_set \\ A_set) = \u2205\nh_meas : MeasurableSet (A_set \u2229 B_set) \u2227 MeasurableSet (B_set \\ A_set)\n\u22a2 \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set) =\n    \u03bc (A_set \u2229 (A_set \u2229 B_set \u222a B_set \\ A_set)) + \u03bc ((A_set \u2229 B_set \u222a B_set \\ A_set) \\ A_set)"}, {"line": 19, "column": 4, "endLine": 19, "endColumn": 21, "data": "type mismatch\n  h_meas.left\nhas type\n  MeasurableSet (A_set \u2229 B_set) : Prop\nbut is expected to have type\n  MeasurableSet (B_set \\ A_set) : Prop"}, {"line": 20, "column": 2, "endLine": 20, "endColumn": 22, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content from the natural language. The measurable space structure, measure, measurable sets, equations, and disjoint union properties are all properly formalized. The additional premise l1 (disjoint union decomposition of A) is mathematically sound and consistent, representing a standard fact that's often implicitly assumed in measure theory contexts. The redundant type class parameters (tc_1, tc_2) don't affect the logical meaning. All core mathematical statements from the natural language are faithfully represented in the Lean code.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4 :\n  \u2203 (X : Type) (_ : MeasurableSpace X) (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X),\n  MeasurableSet A_set \u2227 MeasurableSet B_set \u2227\n  A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205 \u2227\n  \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set) \u2227\n  B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205 \u2227\n  \u00ac (\u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set)) := by\n  use Unit\n  use instMeasurableSpace\n  use MeasureTheory.Measure.count\n  use ({()} : Set Unit)\n  use ({()} : Set Unit)\n  constructor\n  \u00b7 simp [MeasurableSet.countable]\n  constructor\n  \u00b7 simp\n  constructor\n  \u00b7 simp\n  constructor\n  \u00b7 simp\n  constructor\n  \u00b7 simp\n  \u00b7 simp [MeasureTheory.Measure.count_apply]"}, "type": "lemma"}, "l5": {"id": "l5", "natural_language": "The union $A \\cup B$ can also be expressed as a disjoint union $A \\cup B = (A \\setminus B) \\cup (B \\setminus A) \\cup (A \\cap B)$,", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$ [l2];\n\u2022 $\\mu(B) = \\mu(A \\cap B) + \\mu(B \\setminus A)$ [l4].\nTherefore, we conclude:\n\u2022 The set $A \\cup B$ is the disjoint union of $(A \\setminus B)$, $(B \\setminus A)$, and $(A \\cap B)$ [l5].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : MeasureTheory.Measure X)  -- This looks like a duplicate l2. If l2 is supposed to be the measure statement, then use its type from the previous lemma definition.\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : MeasureTheory.Measure X) : -- This looks like a duplicate l4. If l4 is supposed to be the measure statement, then use its type from the previous lemma definition.\n  (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l5\n  {X : Type*} (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : tc_2 A_set = tc_2 (A_set \u2229 B_set) + tc_2 (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : tc_2 B_set = tc_2 (A_set \u2229 B_set) + tc_2 (B_set \\ A_set)) :\n  (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set)) := by\n  constructor\n  \u00b7 rw [\u2190 Set.union_assoc, \u2190 Set.union_distrib_left, l1.1, l3.1]\n    simp only [Set.union_assoc]\n  \u00b7 constructor\n    \u00b7 rw [Set.disjoint_iff]\n      simp [Set.inter_diff_distrib_left, Set.inter_diff_self]\n    \u00b7 rw [Set.disjoint_iff]\n      simp [Set.inter_diff_distrib_left, Set.inter_diff_self, l1.2, l3.2]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 8, "endLine": 16, "endColumn": 25, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  ?a \u222a (?b \u222a ?c)\ncase left\nX : Type u_1\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl1 : A_set = A_set \u2229 B_set \u222a A_set \\ B_set \u2227 A_set \u2229 B_set \u2229 (A_set \\ B_set) = \u2205\nl2 : tc_2 A_set = tc_2 (A_set \u2229 B_set) + tc_2 (A_set \\ B_set)\nl3 : B_set = A_set \u2229 B_set \u222a B_set \\ A_set \u2227 A_set \u2229 B_set \u2229 (B_set \\ A_set) = \u2205\nl4 : tc_2 B_set = tc_2 (A_set \u2229 B_set) + tc_2 (B_set \\ A_set)\n\u22a2 A_set \u222a B_set = A_set \\ B_set \u222a B_set \\ A_set \u222a A_set \u2229 B_set"}, {"line": 21, "column": 4, "endLine": 22, "endColumn": 73, "data": "unsolved goals\ncase right.right\nX : Type u_1\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl1 : A_set = A_set \u2229 B_set \u222a A_set \\ B_set \u2227 A_set \u2229 B_set \u2229 (A_set \\ B_set) = \u2205\nl2 : tc_2 A_set = tc_2 (A_set \u2229 B_set) + tc_2 (A_set \\ B_set)\nl3 : B_set = A_set \u2229 B_set \u222a B_set \\ A_set \u2227 A_set \u2229 B_set \u2229 (B_set \\ A_set) = \u2205\nl4 : tc_2 B_set = tc_2 (A_set \u2229 B_set) + tc_2 (B_set \\ A_set)\n\u22a2 (A_set \\ B_set \u222a B_set \\ A_set) \u2229 (A_set \u2229 B_set) = \u2205"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The measurable space declaration is correctly formalized", "The measure declaration is correctly formalized", "The measurable sets condition is correctly captured", "l2 should be the measure equation \u03bc(A) = \u03bc(A \u2229 B) + \u03bc(A \\ B) but instead declares another measure type", "l4 should be the measure equation \u03bc(B) = \u03bc(A \u2229 B) + \u03bc(B \\ A) but instead declares another measure type", "The conclusion about disjoint union is correctly formalized with proper set equality and disjointness conditions", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The measurable space declaration is correctly formalized', 'The measure declaration is correctly formalized', 'The measurable sets condition is correctly captured', 'l2 should be the measure equation \u03bc(A) = \u03bc(A \u2229 B) + \u03bc(A \\\\ B) but instead declares another measure type', 'l4 should be the measure equation \u03bc(B) = \u03bc(A \u2229 B) + \u03bc(B \\\\ A) but instead declares another measure type', 'The conclusion about disjoint union is correctly formalized with proper set equality and disjointness conditions']"}, "solved_negation": null, "type": "lemma"}, "l6": {"id": "l6", "natural_language": "so by additivity $\\mu(A \\cup B) = \\mu(A \\setminus B) + \\mu(B \\setminus A) + \\mu(A \\cap B)$.", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$ [l2];\n\u2022 $\\mu(B) = \\mu(A \\cap B) + \\mu(B \\setminus A)$ [l4];\n\u2022 The set $A \\cup B$ is the disjoint union of $(A \\setminus B)$, $(B \\setminus A)$, and $(A \\cap B)$ [l5].\nTherefore, we conclude:\n\u2022 $\\mu(A \\cup B) = \\mu(A \\setminus B) + \\mu(B \\setminus A) + \\mu(A \\cap B)$ [l6].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set))) :\n  \u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l6\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set))) :\n  \u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set) := by\n  have h_disj : Disjoint (A_set \\ B_set) (B_set \\ A_set) \u2227 Disjoint (A_set \\ B_set \u222a B_set \\ A_set) (A_set \u2229 B_set) := by\n    exact \u27e8l5.2.1, l5.2.2\u27e9\n  have mA : MeasurableSet (A_set \\ B_set) := MeasurableSet.diff tc_3.1 tc_3.2\n  have mB : MeasurableSet (B_set \\ A_set) := MeasurableSet.diff tc_3.2 tc_3.1\n  have mAB : MeasurableSet (A_set \u2229 B_set) := MeasurableSet.inter tc_3.1 tc_3.2\n  have mUnion : MeasurableSet (A_set \\ B_set \u222a B_set \\ A_set) := MeasurableSet.union mA mB\n  rw [l5.1, MeasureTheory.measure_union h_disj.2 mUnion mAB]\n  rw [MeasureTheory.measure_union h_disj.1 mA mB]\n  simp", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 22, "column": 49, "endLine": 22, "endColumn": 55, "data": "application type mismatch\n  MeasureTheory.measure_union h_disj.right mUnion\nargument\n  mUnion\nhas type\n  MeasurableSet (A_set \\ B_set \u222a B_set \\ A_set) : Prop\nbut is expected to have type\n  MeasurableSet (A_set \u2229 B_set) : Prop"}, {"line": 22, "column": 12, "endLine": 22, "endColumn": 59, "data": "tactic 'rewrite' failed, equality or iff proof expected\n  ?m.5033\nX : Type u_1\ninst\u271d : MeasurableSpace X\n\u03bc : MeasureTheory.Measure X\nA_set B_set : Set X\ntc_1 : MeasurableSpace X\ntc_2 : MeasureTheory.Measure X\ntc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set\nl1 : A_set = A_set \u2229 B_set \u222a A_set \\ B_set \u2227 A_set \u2229 B_set \u2229 (A_set \\ B_set) = \u2205\nl2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)\nl3 : B_set = A_set \u2229 B_set \u222a B_set \\ A_set \u2227 A_set \u2229 B_set \u2229 (B_set \\ A_set) = \u2205\nl4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set)\nl5 :\n  A_set \u222a B_set = A_set \\ B_set \u222a B_set \\ A_set \u222a A_set \u2229 B_set \u2227\n    Disjoint (A_set \\ B_set) (B_set \\ A_set) \u2227 Disjoint (A_set \\ B_set \u222a B_set \\ A_set) (A_set \u2229 B_set)\nh_disj : Disjoint (A_set \\ B_set) (B_set \\ A_set) \u2227 Disjoint (A_set \\ B_set \u222a B_set \\ A_set) (A_set \u2229 B_set)\nmA : MeasurableSet (A_set \\ B_set)\nmB : MeasurableSet (B_set \\ A_set)\nmAB : MeasurableSet (A_set \u2229 B_set)\nmUnion : MeasurableSet (A_set \\ B_set \u222a B_set \\ A_set)\n\u22a2 \u03bc (A_set \\ B_set \u222a B_set \\ A_set \u222a A_set \u2229 B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set)"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["Measurable space declaration correctly formalized with both typeclass instance and explicit parameter", "Measure declaration properly captured with appropriate Lean measure theory types", "Measurable sets condition correctly translated using MeasurableSet predicate", "First measure equation perfectly matches the mathematical statement", "Second measure equation perfectly matches the mathematical statement", "Disjoint union property correctly formalized with both equality and disjointness conditions", "Conclusion statement perfectly matches the target mathematical equation. The Lean formalization includes additional logically consistent conditions (l1, l3) that provide set decompositions, which are mathematically sound auxiliary assumptions.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma not_l6\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set))) :\n  \u00ac (\u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set)) := by\n  intro h\n  have h_union := \u03bc.add_union (tc_3.left) (tc_3.right)\n  rw [h] at h_union\n  simp [l2, l4] at h_union\n  have h_add := add_assoc (\u03bc (A_set \u2229 B_set)) (\u03bc (A_set \\ B_set)) (\u03bc (B_set \\ A_set))\n  rw [\u2190h_add] at h_union\n  have h_eq : \u03bc (A_set \u2229 B_set) + (\u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set)) = \u03bc A_set + \u03bc B_set - \u03bc (A_set \u2229 B_set) := by\n    rw [h_union]\n    ring\n  rw [l2, l4] at h_eq\n  ring_nf at h_eq\n  have h_contra := congrArg (fun x => x - \u03bc (A_set \u2229 B_set)) h_eq\n  simp at h_contra\n  exact (add_ne_self.mp h_contra) rfl"}, "type": "lemma"}, "l7": {"id": "l7", "natural_language": "Using these results, we can write $\\mu(A) + \\mu(B) = (\\mu(A \\cap B) + \\mu(A \\setminus B)) + (\\mu(A \\cap B) + \\mu(B \\setminus A))$.", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 $\\mu(A) = \\mu(A \\cap B) + \\mu(A \\setminus B)$ [l2];\n\u2022 $\\mu(B) = \\mu(A \\cap B) + \\mu(B \\setminus A)$ [l4];\n\u2022 $\\mu(A \\cup B) = \\mu(A \\setminus B) + \\mu(B \\setminus A) + \\mu(A \\cap B)$ [l6].\nTherefore, we conclude:\n\u2022 $\\mu(A) + \\mu(B) = (\\mu(A \\cap B) + \\mu(A \\setminus B)) + (\\mu(A \\cap B) + \\mu(B \\setminus A))$ [l7].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5", "l6"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set)))\n  (l6 : \u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set)) :\n  \u03bc A_set + \u03bc B_set = (\u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)) + (\u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l7\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set)))\n  (l6 : \u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set)) :\n  \u03bc A_set + \u03bc B_set = (\u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)) + (\u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set)) :=\n  calc\n    \u03bc A_set + \u03bc B_set = (\u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)) + (\u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set)) := by rw [l2, l4]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 5}, "score": {"semantic_score": 0.8, "semantic_feedback": ["The type setup correctly establishes the measurable space structure with appropriate type classes, though tc_1 and tc_2 are redundant.", "The core measure equations l2, l4, and l6 perfectly capture the mathematical relationships stated in the natural language.", "The additional conditions l1, l3, and l5 provide necessary mathematical foundations (set decompositions and disjointness) that are implicit in the natural language assumptions.", "The conclusion l7 exactly matches the natural language statement in terms of logical and mathematical content.", "Variable names differ (A_set vs A, B_set vs B) but this is purely notational and doesn't affect the semantic meaning."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "Rearranging this sum and using the expression for $\\mu(A \\cup B)$ yields $\\mu(A) + \\mu(B) = (\\mu(A \\setminus B) + \\mu(B \\setminus A) + \\mu(A \\cap B)) + \\mu(A \\cap B) = \\mu(A \\cup B) + \\mu(A \\cap B)$.", "statement": "We assume:\n\u2022 $(X, \\mathcal{A})$ is a measurable space [tc_1];\n\u2022 $\\mu$ is a measure on $(X, \\mathcal{A})$ [tc_2];\n\u2022 $A, B$ are sets in $\\mathcal{A}$ [tc_3];\n\u2022 $\\mu(A \\cup B) = \\mu(A \\setminus B) + \\mu(B \\setminus A) + \\mu(A \\cap B)$ [l6];\n\u2022 $\\mu(A) + \\mu(B) = (\\mu(A \\cap B) + \\mu(A \\setminus B)) + (\\mu(A \\cap B) + \\mu(B \\setminus A))$ [l7].\nTherefore, we conclude:\n\u2022 $\\mu(A) + \\mu(B) = \\mu(A \\cup B) + \\mu(A \\cap B)$ [ts_1].", "dependencies": ["tc_1", "tc_2", "tc_3", "l1", "l2", "l3", "l4", "l5", "l6", "l7"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set)))\n  (l6 : \u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set))\n  (l7 : \u03bc A_set + \u03bc B_set = (\u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)) + (\u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))) :\n  \u03bc A_set + \u03bc B_set = \u03bc (A_set \u222a B_set) + \u03bc (A_set \u2229 B_set) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  {X : Type*} [MeasurableSpace X] (\u03bc : MeasureTheory.Measure X) (A_set B_set : Set X)\n  (tc_1 : MeasurableSpace X)\n  (tc_2 : MeasureTheory.Measure X)\n  (tc_3 : MeasurableSet A_set \u2227 MeasurableSet B_set)\n  (l1 : A_set = (A_set \u2229 B_set) \u222a (A_set \\ B_set) \u2227 (A_set \u2229 B_set) \u2229 (A_set \\ B_set) = \u2205)\n  (l2 : \u03bc A_set = \u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set))\n  (l3 : B_set = (A_set \u2229 B_set) \u222a (B_set \\ A_set) \u2227 (A_set \u2229 B_set) \u2229 (B_set \\ A_set) = \u2205)\n  (l4 : \u03bc B_set = \u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))\n  (l5 : (A_set \u222a B_set = ((A_set \\ B_set) \u222a (B_set \\ A_set)) \u222a (A_set \u2229 B_set)) \u2227 (Disjoint (A_set \\ B_set) (B_set \\ A_set)) \u2227 (Disjoint ((A_set \\ B_set) \u222a (B_set \\ A_set)) (A_set \u2229 B_set)))\n  (l6 : \u03bc (A_set \u222a B_set) = \u03bc (A_set \\ B_set) + \u03bc (B_set \\ A_set) + \u03bc (A_set \u2229 B_set))\n  (l7 : \u03bc A_set + \u03bc B_set = (\u03bc (A_set \u2229 B_set) + \u03bc (A_set \\ B_set)) + (\u03bc (A_set \u2229 B_set) + \u03bc (B_set \\ A_set))) :\n  \u03bc A_set + \u03bc B_set = \u03bc (A_set \u222a B_set) + \u03bc (A_set \u2229 B_set) := by\n  rw [l6, l7]\n  ring", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 1.0, "semantic_feedback": ["The type setup correctly captures the measurable space structure with appropriate Lean syntax for the mathematical objects described in natural language.", "The key assumption l6 is perfectly translated, maintaining the exact mathematical relationship between the union measure and the sum of disjoint component measures.", "The assumption l7 correctly formalizes the algebraic expansion of \u03bc(A) + \u03bc(B) as stated in natural language.", "The goal statement precisely captures the desired conclusion about the inclusion-exclusion principle for measures.", "The additional assumptions (l1-l5) provide necessary mathematical foundations that are logically consistent with and supportive of the natural language reasoning, without contradicting any stated conditions."]}, "error_report": {"error_type": null, "error_report": "Natural-language lemma and formalization appear consistent (lean_verify = True)."}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_3", "label": "tc_3", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l5", "label": "l5", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l6", "label": "l6", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l7", "label": "l7", "color": {"background": "#8dafcc", "border": "#00ff00", "highlight": {"background": "#8dafcc", "border": "#00ff00"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "tc_3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l5", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l6", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l5", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "l7", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l6", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l7", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    