
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Proof Graph Visualization</title>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" type="text/css" />
        <style>
            body {
                margin: 0;
                padding: 0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                height: 100vh;
                overflow: hidden;
            }
            
            .container {
                display: flex;
                height: 100vh;
                background: #f0f0f0;
            }
            
            #left-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: white;
                border-right: 2px solid #ddd;
                height: 100vh;
                overflow: hidden;
            }
            
            #proof-str-panel {
                background: #f8f9fa;
                border-bottom: 2px solid #ddd;
                padding: 15px;
                height: 200px;
                overflow-y: auto;
                flex-shrink: 0;
            }
            
            #proof-str-title {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            #proof-str-content {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
                background: white;
                padding: 12px;
                border-radius: 4px;
                border: 1px solid #e2e8f0;
            }
            
            #graph-container {
                flex: 1;
                position: relative;
                background: white;
                min-height: 0;
                overflow: hidden;
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
            }
            
            #info-panel {
                width: 40%;
                max-width: 600px;
                background: white;
                overflow-y: auto;
                padding: 20px;
                box-shadow: -2px 0 10px rgba(0,0,0,0.1);
            }
            
            #info-panel.hidden {
                display: none;
            }
            
            .info-header {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 15px;
                border-radius: 8px;
                margin-bottom: 20px;
            }
            
            .info-header h2 {
                margin: 0;
                font-size: 24px;
            }
            
            .info-header .node-type {
                opacity: 0.9;
                font-size: 14px;
                margin-top: 5px;
            }
            
            .field-group {
                background: #f8f9fa;
                border-left: 4px solid #667eea;
                padding: 15px;
                margin-bottom: 15px;
                border-radius: 4px;
            }
            
            .field-name {
                font-weight: 600;
                color: #2d3748;
                margin-bottom: 8px;
                font-size: 14px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .field-value {
                color: #4a5568;
                line-height: 1.6;
                white-space: pre-wrap;
                word-wrap: break-word;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 13px;
            }
            
            .field-value.code {
                color: #4a5568;
                padding: 12px;
                border-radius: 4px;
                overflow-x: auto;
            }
            
            .sub-dict {
                background: #ffffff;
                border: 1px solid #e2e8f0;
                border-radius: 4px;
                padding: 10px;
                margin: 8px 0;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            .sub-dict-title {
                font-weight: 600;
                color: #4a5568;
                margin-bottom: 8px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .sub-dict-content {
                color: #2d3748;
                line-height: 1.5;
                font-size: 12px;
            }
            
            .placeholder {
                text-align: center;
                color: #718096;
                padding: 40px;
                font-size: 18px;
            }
            
            .placeholder-icon {
                font-size: 48px;
                margin-bottom: 20px;
                opacity: 0.3;
            }
            
            #toggle-panel {
                position: absolute;
                right: 10px;
                top: 10px;
                z-index: 1000;
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 14px;
                transition: background 0.3s;
            }
            
            #toggle-panel:hover {
                background: #764ba2;
            }
            
            .legend {
                position: absolute;
                top: 20px;
                left: 20px;
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                z-index: 100;
                max-width: 300px;
            }
            
            .legend-section {
                margin-bottom: 15px;
            }
            
            .legend-section:last-child {
                margin-bottom: 0;
            }
            
            .legend-title {
                font-weight: 600;
                font-size: 12px;
                color: #2d3748;
                margin-bottom: 8px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 1px solid #e2e8f0;
                padding-bottom: 4px;
            }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin-bottom: 8px;
            }
            
            .legend-item:last-child {
                margin-bottom: 0;
            }
            
            .legend-color {
                width: 20px;
                height: 20px;
                margin-right: 10px;
                border-radius: 3px;
            }
            
            .resizer {
                background: #ddd;
                cursor: col-resize;
                width: 4px;
                height: 100%;
                position: absolute;
                right: 0;
                top: 0;
                z-index: 1000;
            }
            
            .resizer:hover {
                background: #bbb;
            }
            
            .resizer-vertical {
                background: #ddd;
                cursor: row-resize;
                height: 4px;
                width: 100%;
                position: absolute;
                bottom: 0;
                left: 0;
                z-index: 1000;
            }
            
            .resizer-vertical:hover {
                background: #bbb;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div id="left-panel">
                <div id="proof-str-panel">
                    <div id="proof-str-title">Informal theorem and proof</div>
                    <div id="proof-str-content">Theorem: For every $n$ such that $a_n$ is defined, we have
$$x = [a_0, a_1, \ldots, a_{n}+t_n],$$
and if $t_{n}
eq 0$, then
$
  x = [a_0, a_1, \ldots, a_{n}, \frac{1}{t_n}].
$

Proof: We use induction.  The statements are both true when $n=0$.
If the second statement is true for $n-1$, then
\begin{align*}
x &= \left[a_0,a_1, \ldots, a_{n-1},\frac{1}{t_{n-1}}\right]\\
  &=\left[a_0,a_1, \ldots, a_{n-1},a_n + t_n\right]\\
  &=\left[a_0,a_1, \ldots, a_{n-1},a_n, \frac{1}{t_n}\right].
\end{align*}
Similarly, the first statement is true for~$n$ if
it is true for $n-1$.
</div>
                    <div class="resizer-vertical" id="vertical-resizer"></div>
                </div>
                <div id="graph-container">
                    <button id="toggle-panel" onclick="togglePanel()">Toggle Info Panel</button>
                    <div class="legend">
                        <div class="legend-section">
                            <div class="legend-title">Node Types</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #eba0a0;"></div>
                                <span>Theorem Conditions (tc)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #cfb795 ;"></div>
                                <span>Theorem Definitions (def)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #8dafcc;"></div>
                                <span>Lemmas (l)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #a3c2a8;"></div>
                                <span>Theorem Solutions (ts)</span>
                            </div>

                        </div>
                        <div class="legend-section">
                            <div class="legend-title">Verification Status</div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #fa2c07;"></div>
                                <span>Formalization failed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #FFA500;"></div>
                                <span>Formalization passed</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #FFFFFF; border: 2px solid #00ff00;"></div>
                                <span>Fully verified</span>
                            </div>
                        </div>
                    </div>
                    <div id="mynetwork"></div>
                </div>
            </div>
            
            <div class="resizer" id="horizontal-resizer"></div>
            
            <div id="info-panel">
                <div id="info-content">
                    <div class="placeholder">
                        <div class="placeholder-icon">📊</div>
                        <p>Click on a node to view its details</p>
                    </div>
                </div>
            </div>
        </div>
        
        <script type="text/javascript">
            // Store node information
            var nodeInfo = {"tc_1": {"id": "tc_1", "natural_language": "For every $n$ such that $a_n$ is defined...", "statement": "Premise:\n\u2022 $x$ is a real number. The sequences $a_k, t_k, x_k$ for $k \\ge 0$ are defined by the algorithm: $x_0 = x$; for $k \\ge 0$ where $x_k$ is defined, $a_k = \\lfloor x_k \\rfloor$ and $t_k = x_k - a_k$; if $t_k \\neq 0$, then $x_{k+1} = 1/t_k$. The term $a_n$ is defined if this process does not terminate with some $t_k = 0$ for $k < n-1$ [tc_1].", "dependencies": [], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n(tc_1_def_x0 : x_seq 0 = x)\n(tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n(tc_1 : \u2200 n, (\u2200 k < n, t k \u2260 0))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["Both declare x as a real number", "Both state x_seq 0 = x (or x_0 = x)", "Both define a_k as the floor of x_k", "Both define t_k as x_k - a_k", "Both state the conditional relationship for x_{k+1}", "The natural language states 'The process does not terminate with some t_k = 0 for k < n-1' which refers to a specific n. However, the Lean version states '\u2200 n, (\u2200 k < n, t k \u2260 0)' which means for ALL n, no t_k equals 0 for k < n. This is much stronger than the natural language condition.", "The natural language concludes 'The term a_n is defined' but the Lean code provides no conclusion - it only sets up premises. The Lean code is missing the actual conclusion that a_n is defined."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['Both declare x as a real number', 'Both state x_seq 0 = x (or x_0 = x)', 'Both define a_k as the floor of x_k', 'Both define t_k as x_k - a_k', 'Both state the conditional relationship for x_{k+1}', \"The natural language states 'The process does not terminate with some t_k = 0 for k < n-1' which refers to a specific n. However, the Lean version states '\u2200 n, (\u2200 k < n, t k \u2260 0)' which means for ALL n, no t_k equals 0 for k < n. This is much stronger than the natural language condition.\", \"The natural language concludes 'The term a_n is defined' but the Lean code provides no conclusion - it only sets up premises. The Lean code is missing the actual conclusion that a_n is defined.\"]"}, "type": "condition"}, "tc_2": {"id": "tc_2", "natural_language": "$x = [a_0, a_1, \\ldots, a_{n}+t_n]$", "statement": "Premise:\n\u2022 The notation $[c_0, c_1, \\ldots, c_k]$ for real numbers $c_i$ denotes a finite continued fraction, defined recursively as $[c_k] = c_k$ and $[c_0, c_1, \\ldots, c_k] = c_0 + 1/[c_1, \\ldots, c_k]$ for $k > 0$ [tc_2].", "dependencies": ["tc_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\nset_option maxHeartbeats 0\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable\n  (c : \u2115 \u2192 \u211d)\n  (k : \u2115)\n  (tc_2 : (\u2200 (c_list : List \u211d),\n    (c_list.length = 1 \u2192 ([c_list.head!] = c_list.head!)) \u2227\n    (c_list.length > 1 \u2192 ([c_list.head!, c_list.tail!.head!, c_list.tail!.tail!.head!, c_list.tail!.tail!.tail!.head!] = c_list.head! + 1 / [c_list.tail!.head!, c_list.tail!.tail!.head!, c_list.tail!.tail!.tail!.head!]))))", "lean_pass": false, "error_msg": [{"line": 8, "column": 43, "endLine": 8, "endColumn": 55, "data": "type mismatch\n  c_list.head!\nhas type\n  \u211d : Type\nbut is expected to have type\n  List \u211d : Type"}, {"line": 9, "column": 136, "endLine": 9, "endColumn": 218, "data": "failed to synthesize\n  HDiv \u2115 (List \u211d) (?m.3884 c_list)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."}], "tries": 5}, "solved_lemma": {}, "score": {"semantic_score": 0, "semantic_feedback": "Failed Lean syntax check already."}, "error_report": {"error_type": "Formalization", "error_report": "Formalized statement is not a valid Lean4 statement"}, "type": "condition"}, "l1": {"id": "l1", "natural_language": "The statements are both true when $n=0$.", "statement": "We assume:\n\u2022 $x$ is a real number and sequences $a_k, t_k, x_k$ are defined as in [tc_1];\n\u2022 The notation for continued fractions is defined as in [tc_2].\nTherefore, we conclude:\n\u2022 For $n=0$, we have $x = [a_0+t_0]$, and if $t_0 \\neq 0$, then $x = [a_0, 1/t_0]$ [l1].", "dependencies": ["tc_1", "tc_2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n, (\u2200 k < n, t k \u2260 0)) :\n  (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l1\n  (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n, (\u2200 k < n, t k \u2260 0)) :\n  (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)) := by\n  have h1 : x = a 0 + t 0 := by\n    rw [\u2190 tc_1_def_x0]\n    have := tc_1_def_ak_tk_xk_succ 0\n    rcases this with \u27e8ha, ht, _\u27e9\n    rw [ha, ht]\n    exact add_sub_cancel'_right _ _\n  refine \u27e8h1, ?_\u27e9\n  intro ht0\n  rw [h1]\n  field_simp [ht0]\n  rw [div_div_eq_mul_div, mul_one]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 16, "column": 10, "endLine": 16, "endColumn": 35, "data": "typeclass instance problem is stuck, it is often due to metavariables\n  AddCommGroup ?m.789"}, {"line": 21, "column": 6, "endLine": 21, "endColumn": 24, "data": "no goals to be solved"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The variable declarations and basic setup correctly capture the real number x and sequences a_k, t_k, x_k with appropriate type annotations and definitional constraints.", "The equation x = a_0 + t_0 for n=0 is correctly formalized as x = a 0 + t 0.", "The continued fraction notation [a_0, 1/t_0] in natural language should represent a different mathematical expression than a_0 + t_0, but the Lean formalization 'a 0 + 1 / (1 / t 0)' simplifies to 'a 0 + t 0', making both cases identical. This misses the key distinction that continued fractions provide different representations.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The variable declarations and basic setup correctly capture the real number x and sequences a_k, t_k, x_k with appropriate type annotations and definitional constraints.', 'The equation x = a_0 + t_0 for n=0 is correctly formalized as x = a 0 + t 0.', \"The continued fraction notation [a_0, 1/t_0] in natural language should represent a different mathematical expression than a_0 + t_0, but the Lean formalization 'a 0 + 1 / (1 / t 0)' simplifies to 'a 0 + t 0', making both cases identical. This misses the key distinction that continued fractions provide different representations.\"]"}, "solved_negation": null, "type": "lemma"}, "def_1": {"id": "def_1", "natural_language": "If the second statement is true for $n-1$, then", "statement": "Definition:\n\u2022 For the inductive step, for a given $n \\ge 1$, we assume the second statement of the theorem is true for $n-1$: if $a_{n-1}$ is defined and $t_{n-1} \\neq 0$, then $x = [a_0, a_1, \\ldots, a_{n-1}, \\frac{1}{t_{n-1}}]$ [def_1].", "dependencies": ["tc_1", "tc_2", "l1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nvariable (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n(tc_1_def_x0 : x_seq 0 = x)\n(tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n(tc_1 : \u2200 n, (\u2200 k < n, t k \u2260 0))\n(tc_2 : \u2200 {k : \u2115}, (List \u211d) \u2192 \u211d)\n(def_1 : \u2200 (n : \u2115), n \u2265 1 \u2192 (a (n-1) = \u230ax_seq (n-1)\u230b) \u2192 t (n-1) \u2260 0 \u2192 x = tc_2 ([a 0, a 1, a (n-1), 1 / t (n-1)]))", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {}, "score": {"semantic_score": 0.0, "semantic_feedback": ["The condition n \u2265 1 is directly captured in the Lean formalization", "The natural language mentions assuming 'the second statement of the theorem is true for n-1', but this assumption is completely missing from the Lean formalization. There's no corresponding premise in def_1", "The natural language states 'a_{n-1} is defined' while Lean has 'a (n-1) = \u230ax_seq (n-1)\u230b'. The Lean version is more specific, defining what a_{n-1} equals rather than just asserting it's defined, but this captures the same logical intent", "The condition t_{n-1} \u2260 0 is exactly matched in Lean as 't (n-1) \u2260 0'", "The conclusion shows x equals a continued fraction. The natural language uses mathematical notation [a_0, a_1, ..., a_{n-1}, 1/t_{n-1}] while Lean uses tc_2 ([a 0, a 1, a (n-1), 1 / t (n-1)]). The Lean version uses a function tc_2 to represent the continued fraction operation and has a slightly different list structure, but captures the same mathematical meaning"]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The condition n \u2265 1 is directly captured in the Lean formalization', \"The natural language mentions assuming 'the second statement of the theorem is true for n-1', but this assumption is completely missing from the Lean formalization. There's no corresponding premise in def_1\", \"The natural language states 'a_{n-1} is defined' while Lean has 'a (n-1) = \u230ax_seq (n-1)\u230b'. The Lean version is more specific, defining what a_{n-1} equals rather than just asserting it's defined, but this captures the same logical intent\", \"The condition t_{n-1} \u2260 0 is exactly matched in Lean as 't (n-1) \u2260 0'\", 'The conclusion shows x equals a continued fraction. The natural language uses mathematical notation [a_0, a_1, ..., a_{n-1}, 1/t_{n-1}] while Lean uses tc_2 ([a 0, a 1, a (n-1), 1 / t (n-1)]). The Lean version uses a function tc_2 to represent the continued fraction operation and has a slightly different list structure, but captures the same mathematical meaning']"}, "type": "definition"}, "l2": {"id": "l2", "natural_language": "x = \\left[a_0,a_1, \\ldots, a_{n-1},\\frac{1}{t_{n-1}}\\right]", "statement": "We assume:\n\u2022 The definitions of sequences $a_k, t_k, x_k$ [tc_1];\n\u2022 The definition of continued fraction notation [tc_2];\n\u2022 The base case for $n=0$ holds [l1];\n\u2022 The inductive hypothesis for $n-1$ [def_1].\nTherefore, we conclude:\n\u2022 Assuming $a_n$ is defined, then $x = [a_0, a_1, \\ldots, a_{n-1}, \\frac{1}{t_{n-1}}]$ [l2].", "dependencies": ["tc_1", "tc_2", "l1", "def_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)]))) :\n  t (n-1) \u2260 0 \u2192 x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 2}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l2\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)]))) :\n  t (n-1) \u2260 0 \u2192 x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])) := by\n  intro h\n  cases n with\n  | zero => \n    simp at h\n    exact False.elim (h rfl)\n  | succ n_val =>\n    apply def_1 (n_val + 1) (by simp)\n    \u00b7 exact (tc_1_def_ak_tk_xk_succ n_val).1\n    \u00b7 exact h", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 18, "column": 24, "endLine": 18, "endColumn": 27, "data": "application type mismatch\n  h rfl\nargument\n  rfl\nhas type\n  ?m.3251 = ?m.3251 : Prop\nbut is expected to have type\n  t 0 = 0 : Prop"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definitions are properly formalized with explicit mathematical relationships, providing more detail than the natural language reference.", "The continued fraction notation tc_2 is declared as a function type but lacks the actual definition referenced in natural language.", "The base case l1 is properly formalized with specific mathematical content for n=0.", "The inductive hypothesis def_1 is appropriately formalized with the continued fraction representation.", "The conclusion has major issues: (1) condition mismatch - 'a_n is defined' vs 't(n-1) \u2260 0', (2) incomplete list representation missing intermediate terms a_1 through a_{n-2}, and (3) the logical structure doesn't properly capture the intended meaning.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definitions are properly formalized with explicit mathematical relationships, providing more detail than the natural language reference.', 'The continued fraction notation tc_2 is declared as a function type but lacks the actual definition referenced in natural language.', 'The base case l1 is properly formalized with specific mathematical content for n=0.', 'The inductive hypothesis def_1 is appropriately formalized with the continued fraction representation.', \"The conclusion has major issues: (1) condition mismatch - 'a_n is defined' vs 't(n-1) \u2260 0', (2) incomplete list representation missing intermediate terms a_1 through a_{n-2}, and (3) the logical structure doesn't properly capture the intended meaning.\"]"}, "solved_negation": null, "type": "lemma"}, "l3": {"id": "l3", "natural_language": "=\\left[a_0,a_1, \\ldots, a_{n-1},a_n + t_n\\right]", "statement": "We assume:\n\u2022 The definitions of sequences $a_k, t_k, x_k$ [tc_1];\n\u2022 The definition of continued fraction notation [tc_2];\n\u2022 The base case for $n=0$ holds [l1];\n\u2022 The inductive hypothesis for $n-1$ [def_1];\n\u2022 $x = [a_0, a_1, \\ldots, a_{n-1}, \\frac{1}{t_{n-1}}]$ [l2].\nTherefore, we conclude:\n\u2022 $x = [a_0, a_1, \\ldots, a_{n-1}, a_n + t_n]$ [l3].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)]))) :\n  x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l3\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)]))) :\n  x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) := by\n  cases n with\n  | zero =>\n    rcases l1 with \u27e8h1, _\u27e9\n    rw [h1]\n    simp [Nat.zero_eq, tc_1_def_x0]\n    have : tc_2 (k := 0) [a 0, a 1, a 0, a 0 + t 0] = a 0 + t 0 := by\n      simp [tc_1_def_x0]\n    rw [this]\n  | succ n =>\n    have h := tc_1_def_ak_tk_xk_succ n\n    rcases h with \u27e8ha, ht, hx\u27e9\n    have t_ne_zero : t n \u2260 0 := tc_1 (n + 1) n (Nat.lt_succ_self n)\n    have x_seq_eq : x_seq (n + 1) = 1 / t n := hx t_ne_zero\n    rw [ht, \u2190x_seq_eq, ha] at l2\n    simp [Nat.succ_sub_succ_eq_sub, Nat.sub_zero] at l2\n    rw [l2]\n    congr 1\n    simp [ha, ht]\n    have h_next := tc_1_def_ak_tk_xk_succ (n + 1)\n    rcases h_next with \u27e8ha_next, ht_next, _\u27e9\n    rw [ha_next, ht_next]\n    simp [x_seq_eq]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 21, "column": 6, "endLine": 21, "endColumn": 24, "data": "simp made no progress"}, {"line": 28, "column": 8, "endLine": 28, "endColumn": 10, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  t n\ncase succ.intro.intro\nx : \u211d\na t x_seq : \u2115 \u2192 \u211d\ntc_1_def_x0 : x_seq 0 = x\ntc_1_def_ak_tk_xk_succ : \u2200 (k : \u2115), a k = \u2191\u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k)\ntc_1 : \u2200 (n_val k : \u2115), k < n_val \u2192 t k \u2260 0\ntc_2 : {k : \u2115} \u2192 List \u211d \u2192 \u211d\nl1 : x = a 0 + t 0 \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0))\ndef_1 :\n  \u2200 n_val \u2265 1,\n    a (n_val - 1) = \u2191\u230ax_seq (n_val - 1)\u230b \u2192 t (n_val - 1) \u2260 0 \u2192 x = tc_2 [a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)]\nn : \u2115\nl2 : x = tc_2 [a 0, a 1, a (n + 1 - 1), 1 / t (n + 1 - 1)]\nha : a n = \u2191\u230ax_seq n\u230b\nht : t n = x_seq n - a n\nhx : t n \u2260 0 \u2192 x_seq (n + 1) = 1 / t n\nt_ne_zero : t n \u2260 0\nx_seq_eq : x_seq (n + 1) = 1 / t n\n\u22a2 x = tc_2 [a 0, a 1, a (n + 1 - 1), a (n + 1) + t (n + 1)]"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The sequence definitions are properly formalized with explicit mathematical relationships, providing more detail than the natural language reference.", "The continued fraction notation is appropriately declared as a function type, consistent with the natural language reference.", "The base case is given specific mathematical content, which is appropriate for a formal proof.", "The inductive hypothesis is formalized with specific mathematical content, appropriate for the formal context.", "The given condition l2 correctly represents the continued fraction form with 1/t_{n-1} as the final term.", "The conclusion l3 has a major structural issue: the Lean list [a 0, a 1, a (n-1), a n + t n] appears to have only 4 elements and jumps from a 1 to a (n-1), while the natural language [a_0, a_1, ..., a_{n-1}, a_n + t_n] clearly indicates all intermediate terms should be included. This misses the ellipsis terms a_2, a_3, ..., a_{n-2}.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.0, below threshold 0.6.\nScorer feedback: ['The sequence definitions are properly formalized with explicit mathematical relationships, providing more detail than the natural language reference.', 'The continued fraction notation is appropriately declared as a function type, consistent with the natural language reference.', 'The base case is given specific mathematical content, which is appropriate for a formal proof.', 'The inductive hypothesis is formalized with specific mathematical content, appropriate for the formal context.', 'The given condition l2 correctly represents the continued fraction form with 1/t_{n-1} as the final term.', 'The conclusion l3 has a major structural issue: the Lean list [a 0, a 1, a (n-1), a n + t n] appears to have only 4 elements and jumps from a 1 to a (n-1), while the natural language [a_0, a_1, ..., a_{n-1}, a_n + t_n] clearly indicates all intermediate terms should be included. This misses the ellipsis terms a_2, a_3, ..., a_{n-2}.']"}, "solved_negation": null, "type": "lemma"}, "l4": {"id": "l4", "natural_language": "=\\left[a_0,a_1, \\ldots, a_{n-1},a_n, \\frac{1}{t_n}\\right].", "statement": "We assume:\n\u2022 The definitions of sequences $a_k, t_k, x_k$ [tc_1];\n\u2022 The definition of continued fraction notation [tc_2];\n\u2022 The base case for $n=0$ holds [l1];\n\u2022 The inductive hypothesis for $n-1$ [def_1];\n\u2022 $x = [a_0, a_1, \\ldots, a_{n-1}, \\frac{1}{t_{n-1}}]$ [l2];\n\u2022 $x = [a_0, a_1, \\ldots, a_{n-1}, a_n + t_n]$ [l3].\nTherefore, we conclude:\n\u2022 If $t_n \\neq 0$, then $[a_0, a_1, \\ldots, a_{n-1}, a_n + t_n] = [a_0, a_1, \\ldots, a_n, \\frac{1}{t_n}]$ [l4].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n]))) :\n  t n \u2260 0 \u2192 (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma l4\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n]))) :\n  t n \u2260 0 \u2192 (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])) := by\n  intro hn\n  have h := tc_1_def_ak_tk_xk_succ n\n  rcases h with \u27e8han, htn, hx\u27e9\n  have hx_succ : x_seq (n + 1) = 1 / t n := hx hn\n  have hx_seq : x_seq n = a n + t n := by\n    rw [han, htn]\n    ring\n  have h := def_1 (n + 1) (by omega) (by rw [hx_seq, han]) hn\n  rw [\u2190 h, \u2190 l3, \u2190 l2]\n  simp only [Nat.add_sub_cancel, hx_succ]\n  congr\n  simp [hx_seq]", "lean_pass": false, "lean_verify": false, "error_msg": [{"line": 20, "column": 39, "endLine": 22, "endColumn": 8, "data": "unsolved goals\nn : \u2115\nx : \u211d\na t x_seq : \u2115 \u2192 \u211d\ntc_1_def_x0 : x_seq 0 = x\ntc_1_def_ak_tk_xk_succ : \u2200 (k : \u2115), a k = \u2191\u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k)\ntc_1 : \u2200 (n_val k : \u2115), k < n_val \u2192 t k \u2260 0\ntc_2 : {k : \u2115} \u2192 List \u211d \u2192 \u211d\nl1 : x = a 0 + t 0 \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0))\ndef_1 :\n  \u2200 n_val \u2265 1,\n    a (n_val - 1) = \u2191\u230ax_seq (n_val - 1)\u230b \u2192 t (n_val - 1) \u2260 0 \u2192 x = tc_2 [a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)]\nl2 : x = tc_2 [a 0, a 1, a (n - 1), 1 / t (n - 1)]\nl3 : x = tc_2 [a 0, a 1, a (n - 1), a n + t n]\nhn : t n \u2260 0\nhan : a n = \u2191\u230ax_seq n\u230b\nhtn : t n = x_seq n - a n\nhx : t n \u2260 0 \u2192 x_seq (n + 1) = 1 / t n\nhx_succ : x_seq (n + 1) = 1 / t n\n\u22a2 x_seq n = \u2191\u230ax_seq n\u230b + (x_seq n - a n)"}, {"line": 23, "column": 45, "endLine": 23, "endColumn": 51, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  x_seq n\nn : \u2115\nx : \u211d\na t x_seq : \u2115 \u2192 \u211d\ntc_1_def_x0 : x_seq 0 = x\ntc_1_def_ak_tk_xk_succ : \u2200 (k : \u2115), a k = \u2191\u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k)\ntc_1 : \u2200 (n_val k : \u2115), k < n_val \u2192 t k \u2260 0\ntc_2 : {k : \u2115} \u2192 List \u211d \u2192 \u211d\nl1 : x = a 0 + t 0 \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0))\ndef_1 :\n  \u2200 n_val \u2265 1,\n    a (n_val - 1) = \u2191\u230ax_seq (n_val - 1)\u230b \u2192 t (n_val - 1) \u2260 0 \u2192 x = tc_2 [a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)]\nl2 : x = tc_2 [a 0, a 1, a (n - 1), 1 / t (n - 1)]\nl3 : x = tc_2 [a 0, a 1, a (n - 1), a n + t n]\nhn : t n \u2260 0\nhan : a n = \u2191\u230ax_seq n\u230b\nhtn : t n = x_seq n - a n\nhx : t n \u2260 0 \u2192 x_seq (n + 1) = 1 / t n\nhx_succ : x_seq (n + 1) = 1 / t n\nhx_seq : x_seq n = a n + t n\n\u22a2 a (n + 1 - 1) = \u2191\u230ax_seq (n + 1 - 1)\u230b"}, {"line": 24, "column": 6, "endLine": 24, "endColumn": 9, "data": "tactic 'rewrite' failed, did not find instance of the pattern in the target expression\n  tc_2 [a 0, a 1, a (n + 1 - 1), 1 / t (n + 1 - 1)]\ncase intro.intro\nn : \u2115\nx : \u211d\na t x_seq : \u2115 \u2192 \u211d\ntc_1_def_x0 : x_seq 0 = x\ntc_1_def_ak_tk_xk_succ : \u2200 (k : \u2115), a k = \u2191\u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k)\ntc_1 : \u2200 (n_val k : \u2115), k < n_val \u2192 t k \u2260 0\ntc_2 : {k : \u2115} \u2192 List \u211d \u2192 \u211d\nl1 : x = a 0 + t 0 \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0))\ndef_1 :\n  \u2200 n_val \u2265 1,\n    a (n_val - 1) = \u2191\u230ax_seq (n_val - 1)\u230b \u2192 t (n_val - 1) \u2260 0 \u2192 x = tc_2 [a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)]\nl2 : x = tc_2 [a 0, a 1, a (n - 1), 1 / t (n - 1)]\nl3 : x = tc_2 [a 0, a 1, a (n - 1), a n + t n]\nhn : t n \u2260 0\nhan : a n = \u2191\u230ax_seq n\u230b\nhtn : t n = x_seq n - a n\nhx : t n \u2260 0 \u2192 x_seq (n + 1) = 1 / t n\nhx_succ : x_seq (n + 1) = 1 / t n\nhx_seq : x_seq n = a n + t n\nh : x = tc_2 [a 0, a 1, a (n + 1 - 1), 1 / t (n + 1 - 1)]\n\u22a2 tc_2 [a 0, a 1, a (n - 1), a n + t n] = tc_2 [a 0, a 1, a n, 1 / t n]"}], "tries": 5}, "score": {"semantic_score": 0, "semantic_feedback": ["The Lean formalization correctly captures all the mathematical content and logical structure from the natural language. While it includes additional technical details (like explicit sequence definitions and conditions), these are consistent with and necessary for formalizing the continued fraction concepts described. The core premise-conclusion relationship is faithfully preserved, with the conditional statement about continued fraction equality being accurately represented.", "The tactics contained syntactic mistakes, so final score is 0."]}, "error_report": {"error_type": "Prover", "error_report": "Formalization appears correct (score=1.0 > 0.6), but the prover could neither prove the lemma nor its negation. This may be due to prover limitations, missing lemmas, or incomplete context."}, "solved_negation": {"lean_verify": false, "lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma neg_l4\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n]))) :\n  \u2203 (hn : t n \u2260 0), (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) \u2260 (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])) := by\n  sorry"}, "type": "lemma"}, "ts_1": {"id": "ts_1", "natural_language": "We use induction. ... Similarly, the first statement is true for n if it is true for n-1.", "statement": "We assume:\n\u2022 All previous steps [tc_1, tc_2, l1, def_1, l2, l3, l4].\nTherefore, we conclude:\n\u2022 For every $n$ such that $a_n$ is defined, we have $x = [a_0, a_1, \\ldots, a_{n}+t_n]$ [ts_1].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "l4"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])))\n  (l4 : t n \u2260 0 \u2192 (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n]))) :\n  x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_1\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])))\n  (l4 : t n \u2260 0 \u2192 (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n]))) :\n  x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) := by\n  exact l3", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.6, "semantic_feedback": ["The natural language claims universal quantification 'for every n such that a\u2099 is defined' but the Lean formalization only proves this for a specific n, not universally.", "The assumptions/hypotheses (tc_1, tc_2, l1, def_1, l2, l3, l4) are correctly represented in both the natural language and Lean formalization.", "The mathematical content correctly represents the continued fraction evaluation with the final term being a\u2099+t\u2099, using tc_2 as the evaluation function.", "The notation [a\u2080, a\u2081, ..., a\u2099+t\u2099] in natural language corresponds well to the list [a 0, a 1, a (n-1), a n + t n] in Lean, though the ellipsis handling differs slightly.", "The logical structure correctly uses the given assumptions to derive the conclusion, with the proof following directly from hypothesis l3."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.6, below threshold 0.6.\nScorer feedback: [\"The natural language claims universal quantification 'for every n such that a\u2099 is defined' but the Lean formalization only proves this for a specific n, not universally.\", 'The assumptions/hypotheses (tc_1, tc_2, l1, def_1, l2, l3, l4) are correctly represented in both the natural language and Lean formalization.', 'The mathematical content correctly represents the continued fraction evaluation with the final term being a\u2099+t\u2099, using tc_2 as the evaluation function.', 'The notation [a\u2080, a\u2081, ..., a\u2099+t\u2099] in natural language corresponds well to the list [a 0, a 1, a (n-1), a n + t n] in Lean, though the ellipsis handling differs slightly.', 'The logical structure correctly uses the given assumptions to derive the conclusion, with the proof following directly from hypothesis l3.']"}, "solved_negation": null, "type": "solution"}, "ts_2": {"id": "ts_2", "natural_language": "We use induction. ... x = [a_0, a_1, ..., a_{n-1}, 1/t_{n-1}] ... = [a_0, a_1, ..., a_{n-1}, a_n, 1/t_n].", "statement": "We assume:\n\u2022 All previous steps [tc_1, tc_2, l1, def_1, l2, l3, l4, ts_1].\nTherefore, we conclude:\n\u2022 For every $n$ such that $a_n$ is defined, if $t_{n}\\neq 0$, then $x = [a_0, a_1, \\ldots, a_{n}, \\frac{1}{t_n}]$ [ts_2].", "dependencies": ["tc_1", "tc_2", "l1", "def_1", "l2", "l3", "l4", "ts_1"], "formalization": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])))\n  (l4 : t n \u2260 0 \u2192 (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])))\n  (ts_1 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n]))) :\n  t n \u2260 0 \u2192 x = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])) := by\nsorry", "lean_pass": true, "error_msg": [], "tries": 1}, "solved_lemma": {"lean_code": "import Mathlib\nimport Aesop\n\nset_option maxHeartbeats 0\n\nopen BigOperators Real Nat Topology Rat Filter\n\nlemma ts_2\n  (n : \u2115) (x : \u211d) (a t x_seq : \u2115 \u2192 \u211d)\n  (tc_1_def_x0 : x_seq 0 = x)\n  (tc_1_def_ak_tk_xk_succ : \u2200 k, a k = \u230ax_seq k\u230b \u2227 t k = x_seq k - a k \u2227 (t k \u2260 0 \u2192 x_seq (k + 1) = 1 / t k))\n  (tc_1 : \u2200 n_val, (\u2200 k < n_val, t k \u2260 0))\n  (tc_2 : \u2200 {k : \u2115}, List \u211d \u2192 \u211d)\n  (l1 : (x = a 0 + t 0) \u2227 (t 0 \u2260 0 \u2192 x = a 0 + 1 / (1 / t 0)))\n  (def_1 : \u2200 (n_val : \u2115), n_val \u2265 1 \u2192 (a (n_val - 1) = \u230ax_seq (n_val - 1)\u230b) \u2192 t (n_val - 1) \u2260 0 \u2192 x = (tc_2 (k := n_val) ([a 0, a 1, a (n_val - 1), 1 / t (n_val - 1)])))\n  (l2 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), 1 / t (n - 1)])))\n  (l3 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])))\n  (l4 : t n \u2260 0 \u2192 (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n])) = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])))\n  (ts_1 : x = (tc_2 (k := n) ([a 0, a 1, a (n - 1), a n + t n]))) :\n  t n \u2260 0 \u2192 x = (tc_2 (k := n + 1) ([a 0, a 1, a n, 1 / t n])) := by\n  intro h\n  rw [ts_1, l4 h]", "lean_pass": true, "lean_verify": true, "error_msg": [], "tries": 1}, "score": {"semantic_score": 0.5, "semantic_feedback": ["The Lean formalization correctly captures the logical structure and mathematical content of the natural language statement. The main difference is that the natural language suggests a universal statement 'for every n', while the Lean formalization proves the statement for a specific parameter n. The continued fraction notation is appropriately formalized using the tc_2 function, and all the necessary premises from previous steps are included. The proof structure follows logically from the given premises l4 and ts_1. This is a minor structural difference in how the quantification is handled, but the core mathematical meaning is preserved."]}, "error_report": {"error_type": "Formalizer", "error_report": "Formalization is likely incorrect: semantic score is 0.5, below threshold 0.6.\nScorer feedback: [\"The Lean formalization correctly captures the logical structure and mathematical content of the natural language statement. The main difference is that the natural language suggests a universal statement 'for every n', while the Lean formalization proves the statement for a specific parameter n. The continued fraction notation is appropriately formalized using the tc_2 function, and all the necessary premises from previous steps are included. The proof structure follows logically from the given premises l4 and ts_1. This is a minor structural difference in how the quantification is handled, but the core mathematical meaning is preserved.\"]"}, "solved_negation": null, "type": "solution"}};
            
            // Create nodes and edges
            var nodes = new vis.DataSet([{"id": "tc_1", "label": "tc_1", "color": {"background": "#eba0a0", "border": "#00ff00", "highlight": {"background": "#eba0a0", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "tc_2", "label": "tc_2", "color": {"background": "#eba0a0", "border": "#fa2c07", "highlight": {"background": "#eba0a0", "border": "#fa2c07"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l1", "label": "l1", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "def_1", "label": "def_1", "color": {"background": "#cfb795", "border": "#00ff00", "highlight": {"background": "#cfb795", "border": "#00ff00"}}, "shape": "box", "size": 30, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l2", "label": "l2", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l3", "label": "l3", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "l4", "label": "l4", "color": {"background": "#8dafcc", "border": "#FFA500", "highlight": {"background": "#8dafcc", "border": "#FFA500"}}, "shape": "dot", "size": 25, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_1", "label": "ts_1", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}, {"id": "ts_2", "label": "ts_2", "color": {"background": "#a3c2a8", "border": "#00ff00", "highlight": {"background": "#a3c2a8", "border": "#00ff00"}}, "shape": "star", "size": 40, "font": {"size": 14, "color": "#000000"}, "labelHighlightBold": false, "borderWidth": 3, "chosen": false}]);
            var edges = new vis.DataSet([{"from": "tc_1", "to": "tc_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "tc_2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "def_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "def_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l3", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l2", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "l4", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l3", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_1", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "l4", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}, {"from": "ts_1", "to": "ts_2", "arrows": "to", "color": {"color": "#666666", "highlight": "#666666", "hover": "#666666"}, "width": 2}]);
            
            // Create network
            var container = document.getElementById('mynetwork');
            var data = {
                nodes: nodes,
                edges: edges
            };
            
            var options = {
                physics: {
                    enabled: true,
                    solver: 'hierarchicalRepulsion',
                    hierarchicalRepulsion: {
                        centralGravity: 0.0,
                        springLength: 200,
                        springConstant: 0.01,
                        nodeDistance: 150,
                        damping: 0.09
                    }
                },
                edges: {
                    smooth: {
                        type: 'continuous',
                        forceDirection: 'none'
                    },
                    color: {
                        color: '#666666',
                        highlight: '#666666',
                        hover: '#666666'
                    },
                    width: 2
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true
                },
                nodes: {
                    font: {
                        size: 14,
                        color: '#000000'
                    },
                    labelHighlightBold: false,
                    chosen: false,
                    shapeProperties: {
                        useBorderWithImage: false
                    },
                    scaling: {
                        label: {
                            enabled: true,
                            min: 8,
                            max: 20,
                            maxVisible: 20,
                            drawThreshold: 5
                        }
                    }
                }
            };
            
            var network = new vis.Network(container, data, options);
            
            // Format field value for display
            function formatFieldValue(value, fieldName) {
                if (value === null || value === undefined) {
                    return 'N/A';
                }
                
                // Handle objects (dictionaries) as sub-boxes
                if (typeof value === 'object' && !Array.isArray(value)) {
                    var html = '';
                    for (var key in value) {
                        if (value.hasOwnProperty(key)) {
                            var subValue = value[key];
                            var subValueStr = '';
                            
                            if (typeof subValue === 'object' &&
                                    !Array.isArray(subValue)) {
                                // Nested object - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else if (Array.isArray(subValue)) {
                                // Array - show as JSON
                                subValueStr = JSON.stringify(subValue, null, 2);
                            } else {
                                // Primitive value
                                subValueStr = String(subValue);
                            }
                            
                            // Replace escaped newlines and tabs with actual characters
                            subValueStr = subValueStr.replace(/\\n/g, '\n');
                            subValueStr = subValueStr.replace(/\\t/g, '\t');
                            subValueStr = subValueStr.replace(/\t/g, '\t');
                            
                            html += '<div class="sub-dict">';
                            html += '<div class="sub-dict-title">' + key + '</div>';
                            html += '<div class="sub-dict-content">' + subValueStr + '</div>';
                            html += '</div>';
                        }
                    }
                    return html;
                }
                
                // Convert to string for primitive values and arrays
                var strValue = String(value);
                
                // Handle arrays
                if (Array.isArray(value)) {
                    strValue = JSON.stringify(value, null, 2);
                }
                
                // Replace escaped newlines and tabs with actual characters
                strValue = strValue.replace(/\\n/g, '\n');
                strValue = strValue.replace(/\\t/g, '\t');
                strValue = strValue.replace(/\t/g, '\t');
                
                return strValue;
            }
            
            // Handle node click events
            network.on("click", function(params) {
                if (params.nodes.length > 0) {
                    var nodeId = params.nodes[0];
                    var info = nodeInfo[nodeId];
                    
                    if (info) {
                        var html = '<div class="info-header">';
                        html += '<h2>' + nodeId + '</h2>';
                        var nodeType = info.type || 'unknown';
                        var capitalizedType = nodeType.charAt(0).toUpperCase() +
                            nodeType.slice(1);
                        html += '<div class="node-type">Type: ' + capitalizedType +
                            '</div>';
                        html += '</div>';
                        
                        // Add all fields
                        for (var key in info) {
                            if (key === 'type' || key === 'id') continue;
                            
                            var fieldName = key.replace(/_/g, ' ')
                                .replace(/\b\w/g, function(l) {
                                    return l.toUpperCase();
                                });
                            var fieldValue = formatFieldValue(info[key], fieldName);
                            
                            if (fieldValue && fieldValue !== 'N/A') {
                                // Special formatting for code fields
                                var isCode = key.includes('code') ||
                                    key.includes('lean') ||
                                    key.includes('statement');
                                
                                html += '<div class="field-group">';
                                html += '<div class="field-name">' + fieldName +
                                    '</div>';
                                html += '<div class="field-value' +
                                    (isCode ? ' code' : '') + '">' +
                                    fieldValue + '</div>';
                                html += '</div>';
                            }
                        }
                        
                        document.getElementById('info-content')
                            .innerHTML = html;
                    }
                }
            });
            
            // Toggle panel function
            function togglePanel() {
                var panel = document.getElementById('info-panel');
                panel.classList.toggle('hidden');
                
                // Resize network when panel is toggled
                setTimeout(function() {
                    network.fit();
                }, 300);
            }
            
            // Initial network fit
            network.once('stabilized', function() {
                network.fit();
            });
            
            // Resizable panels functionality
            function makeResizable() {
                const verticalResizer = document.getElementById('vertical-resizer');
                const horizontalResizer = document.getElementById('horizontal-resizer');
                const proofPanel = document.getElementById('proof-str-panel');
                const graphContainer = document.getElementById('graph-container');
                const infoPanel = document.getElementById('info-panel');
                const leftPanel = document.getElementById('left-panel');
                
                let isVerticalResizing = false;
                let isHorizontalResizing = false;
                
                // Vertical resizer (between proof panel and graph)
                verticalResizer.addEventListener('mousedown', function(e) {
                    isVerticalResizing = true;
                    document.addEventListener('mousemove', verticalResize);
                    document.addEventListener('mouseup', stopVerticalResize);
                    e.preventDefault();
                });
                
                function verticalResize(e) {
                    if (!isVerticalResizing) return;
                    
                    const containerHeight = leftPanel.offsetHeight;
                    const newHeight = e.clientY - leftPanel.offsetTop;
                    const minHeight = 100;
                    const maxHeight = containerHeight - 100;
                    
                    if (newHeight >= minHeight && newHeight <= maxHeight) {
                        proofPanel.style.height = newHeight + 'px';
                        graphContainer.style.height = (containerHeight - newHeight) + 'px';
                        network.fit();
                    }
                }
                
                function stopVerticalResize() {
                    isVerticalResizing = false;
                    document.removeEventListener('mousemove', verticalResize);
                    document.removeEventListener('mouseup', stopVerticalResize);
                }
                
                // Horizontal resizer (between left and right panels)
                horizontalResizer.addEventListener('mousedown', function(e) {
                    isHorizontalResizing = true;
                    document.addEventListener('mousemove', horizontalResize);
                    document.addEventListener('mouseup', stopHorizontalResize);
                    e.preventDefault();
                });
                
                function horizontalResize(e) {
                    if (!isHorizontalResizing) return;
                    
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newWidth = e.clientX - leftPanel.offsetLeft;
                    const minWidth = 300;
                    const maxWidth = containerWidth - 300;
                    
                    if (newWidth >= minWidth && newWidth <= maxWidth) {
                        leftPanel.style.flex = 'none';
                        leftPanel.style.width = newWidth + 'px';
                        infoPanel.style.width = (containerWidth - newWidth) + 'px';
                        network.fit();
                    }
                }
                
                function stopHorizontalResize() {
                    isHorizontalResizing = false;
                    document.removeEventListener('mousemove', horizontalResize);
                    document.removeEventListener('mouseup', stopHorizontalResize);
                }
            }
            
            // Initialize resizable panels
            makeResizable();
        </script>
    </body>
    </html>
    